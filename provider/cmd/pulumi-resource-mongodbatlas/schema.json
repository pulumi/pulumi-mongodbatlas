{
    "name": "mongodbatlas",
    "description": "A Pulumi package for creating and managing mongodbatlas cloud resources.",
    "keywords": [
        "pulumi",
        "mongodbatlas"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`mongodbatlas` Terraform Provider](https://github.com/mongodb/terraform-provider-mongodbatlas).",
    "repository": "https://github.com/pulumi/pulumi-mongodbatlas",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "compatibility": "tfbridge20",
            "namespaces": null,
            "packageReferences": {
                "Pulumi": "3.*"
            }
        },
        "go": {
            "generateExtraInputTypes": true,
            "generateResourceContainerTypes": true,
            "importBasePath": "github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas"
        },
        "nodejs": {
            "compatibility": "tfbridge20",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^10.0.0"
            },
            "disableUnionOutputTypes": true,
            "packageDescription": "A Pulumi package for creating and managing mongodbatlas cloud resources.",
            "packageName": "",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/mongodb/terraform-provider-mongodbatlas)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-mongodbatlas` repo](https://github.com/pulumi/pulumi-mongodbatlas/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-mongodbatlas` repo](https://github.com/mongodb/terraform-provider-mongodbatlas/issues).",
            "typescriptVersion": ""
        },
        "python": {
            "compatibility": "tfbridge20",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/mongodb/terraform-provider-mongodbatlas)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-mongodbatlas` repo](https://github.com/pulumi/pulumi-mongodbatlas/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-mongodbatlas` repo](https://github.com/mongodb/terraform-provider-mongodbatlas/issues).",
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            }
        }
    },
    "config": {
        "variables": {
            "assumeRole": {
                "$ref": "#/types/mongodbatlas:config/assumeRole:assumeRole"
            },
            "awsAccessKeyId": {
                "type": "string"
            },
            "awsSecretAccessKey": {
                "type": "string"
            },
            "awsSessionToken": {
                "type": "string"
            },
            "baseUrl": {
                "type": "string",
                "description": "MongoDB Atlas Base URL\n"
            },
            "isMongodbgovCloud": {
                "type": "boolean",
                "description": "MongoDB Atlas Base URL default to gov\n"
            },
            "privateKey": {
                "type": "string",
                "description": "MongoDB Atlas Programmatic Private Key\n",
                "secret": true
            },
            "publicKey": {
                "type": "string",
                "description": "MongoDB Atlas Programmatic Public Key\n"
            },
            "realmBaseUrl": {
                "type": "string",
                "description": "MongoDB Realm Base URL\n"
            },
            "region": {
                "type": "string"
            },
            "secretName": {
                "type": "string"
            },
            "stsEndpoint": {
                "type": "string"
            }
        }
    },
    "types": {
        "mongodbatlas:config/assumeRole:assumeRole": {
            "properties": {
                "duration": {
                    "type": "string"
                },
                "durationSeconds": {
                    "type": "integer",
                    "deprecationMessage": "Use assume_role.duration instead"
                },
                "externalId": {
                    "type": "string"
                },
                "policy": {
                    "type": "string"
                },
                "policyArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "roleArn": {
                    "type": "string"
                },
                "sessionName": {
                    "type": "string"
                },
                "sourceIdentity": {
                    "type": "string"
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "transitiveTagKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/AdvancedClusterAdvancedConfiguration:AdvancedClusterAdvancedConfiguration": {
            "properties": {
                "defaultReadConcern": {
                    "type": "string",
                    "description": "[Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "defaultWriteConcern": {
                    "type": "string",
                    "description": "[Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "failIndexKeyTooLong": {
                    "type": "boolean",
                    "description": "When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "javascriptEnabled": {
                    "type": "boolean",
                    "description": "When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minimumEnabledTlsProtocol": {
                    "type": "string",
                    "description": "Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "noTableScan": {
                    "type": "boolean",
                    "description": "When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oplogMinRetentionHours": {
                    "type": "integer",
                    "description": "Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.\n* **Note**  A minimum oplog retention is required when seeking to change a cluster's class to Local NVMe SSD. To learn more and for latest guidance see [`oplogMinRetentionHours`](https://www.mongodb.com/docs/manual/core/replica-set-oplog/#std-label-replica-set-minimum-oplog-size)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oplogSizeMb": {
                    "type": "integer",
                    "description": "The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sampleRefreshIntervalBiConnector": {
                    "type": "integer",
                    "description": "Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sampleSizeBiConnector": {
                    "type": "integer",
                    "description": "Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "defaultReadConcern",
                        "defaultWriteConcern",
                        "failIndexKeyTooLong",
                        "javascriptEnabled",
                        "minimumEnabledTlsProtocol",
                        "noTableScan",
                        "oplogMinRetentionHours",
                        "oplogSizeMb",
                        "sampleRefreshIntervalBiConnector",
                        "sampleSizeBiConnector"
                    ]
                }
            }
        },
        "mongodbatlas:index/AdvancedClusterBiConnector:AdvancedClusterBiConnector": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether or not BI Connector for Atlas is enabled on the cluster.l\n*\n- Set to `true` to enable BI Connector for Atlas.\n- Set to `false` to disable BI Connector for Atlas.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readPreference": {
                    "type": "string",
                    "description": "Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "enabled",
                        "readPreference"
                    ]
                }
            }
        },
        "mongodbatlas:index/AdvancedClusterBiConnectorConfig:AdvancedClusterBiConnectorConfig": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether or not BI Connector for Atlas is enabled on the cluster.l\n*\n- Set to `true` to enable BI Connector for Atlas.\n- Set to `false` to disable BI Connector for Atlas.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readPreference": {
                    "type": "string",
                    "description": "Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "enabled",
                        "readPreference"
                    ]
                }
            }
        },
        "mongodbatlas:index/AdvancedClusterConnectionString:AdvancedClusterConnectionString": {
            "properties": {
                "awsPrivateLink": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "deprecationMessage": "This field is deprecated. Use connection_strings.private_endpoint[n].connection_string instead",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "awsPrivateLinkSrv": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "deprecationMessage": "This field is deprecated. Use connection_strings.private_endpoint[n].srv_connection_string instead",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "private": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privateEndpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/AdvancedClusterConnectionStringPrivateEndpoint:AdvancedClusterConnectionStringPrivateEndpoint"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privateSrv": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "standard": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "standardSrv": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "awsPrivateLink",
                        "awsPrivateLinkSrv",
                        "private",
                        "privateEndpoints",
                        "privateSrv",
                        "standard",
                        "standardSrv"
                    ]
                }
            }
        },
        "mongodbatlas:index/AdvancedClusterConnectionStringPrivateEndpoint:AdvancedClusterConnectionStringPrivateEndpoint": {
            "properties": {
                "connectionString": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/AdvancedClusterConnectionStringPrivateEndpointEndpoint:AdvancedClusterConnectionStringPrivateEndpointEndpoint"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "srvConnectionString": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "connectionString",
                        "endpoints",
                        "srvConnectionString",
                        "type"
                    ]
                }
            }
        },
        "mongodbatlas:index/AdvancedClusterConnectionStringPrivateEndpointEndpoint:AdvancedClusterConnectionStringPrivateEndpointEndpoint": {
            "properties": {
                "endpointId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud service provider on which the servers are provisioned.\nThe possible values are:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "endpointId",
                        "providerName",
                        "region"
                    ]
                }
            }
        },
        "mongodbatlas:index/AdvancedClusterLabel:AdvancedClusterLabel": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key that you want to write.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "The value that you want to write.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "key",
                        "value"
                    ]
                }
            }
        },
        "mongodbatlas:index/AdvancedClusterReplicationSpec:AdvancedClusterReplicationSpec": {
            "properties": {
                "containerId": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "numShards": {
                    "type": "integer",
                    "description": "Provide this value if you set a `cluster_type` of SHARDED or GEOSHARDED. Omit this value if you selected a `cluster_type` of REPLICASET. This API resource accepts 1 through 50, inclusive. This parameter defaults to 1. If you specify a `num_shards` value of 1 and a `cluster_type` of SHARDED, Atlas deploys a single-shard [sharded cluster](https://docs.atlas.mongodb.com/reference/glossary/#std-term-sharded-cluster). Don't create a sharded cluster with a single shard for production environments. Single-shard sharded clusters don't provide the same benefits as multi-shard configurations.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "regionConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/AdvancedClusterReplicationSpecRegionConfig:AdvancedClusterReplicationSpecRegionConfig"
                    },
                    "description": "Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "zoneName": {
                    "type": "string",
                    "description": "Name for the zone in a Global Cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "regionConfigs"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "containerId",
                        "id",
                        "regionConfigs"
                    ]
                }
            }
        },
        "mongodbatlas:index/AdvancedClusterReplicationSpecRegionConfig:AdvancedClusterReplicationSpecRegionConfig": {
            "properties": {
                "analyticsAutoScaling": {
                    "$ref": "#/types/mongodbatlas:index/AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling:AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling",
                    "description": "Configuration for the Collection of settings that configures analytics-auto-scaling information for the cluster. The values for the `analytics_auto_scaling` parameter must be the same for every item in the `replication_specs` array. See below\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "analyticsSpecs": {
                    "$ref": "#/types/mongodbatlas:index/AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs:AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs",
                    "description": "Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. Analytics nodes handle analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only and can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary). If you don't specify this parameter, no analytics nodes deploy to this region. See below\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "autoScaling": {
                    "$ref": "#/types/mongodbatlas:index/AdvancedClusterReplicationSpecRegionConfigAutoScaling:AdvancedClusterReplicationSpecRegionConfigAutoScaling",
                    "description": "Configuration for the Collection of settings that configures auto-scaling information for the cluster. The values for the `auto_scaling` parameter must be the same for every item in the `replication_specs` array. See below\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "backingProviderName": {
                    "type": "string",
                    "description": "Cloud service provider on which you provision the host for a multi-tenant cluster. Use this only when a `provider_name` is `TENANT` and `instance_size` of a specs is `M2` or `M5`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "electableSpecs": {
                    "$ref": "#/types/mongodbatlas:index/AdvancedClusterReplicationSpecRegionConfigElectableSpecs:AdvancedClusterReplicationSpecRegionConfigElectableSpecs",
                    "description": "Hardware specifications for electable nodes in the region. Electable nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you do not specify this option, no electable nodes are deployed to the region. See below\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "priority": {
                    "type": "integer",
                    "description": "Election priority of the region. For regions with only read-only nodes, set this value to 0.\n* If you have multiple `region_configs` objects (your cluster is multi-region or multi-cloud), they must have priorities in descending order. The highest priority is 7.\n* If your region has set `region_configs.#.electable_specs.0.node_count` to 1 or higher, it must have a priority of exactly one (1) less than another region in the `replication_specs.#.region_configs.#` array. The highest-priority region must have a priority of 7. The lowest possible priority is 1.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud service provider on which the servers are provisioned.\nThe possible values are:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readOnlySpecs": {
                    "$ref": "#/types/mongodbatlas:index/AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs:AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs",
                    "description": "Hardware specifications for read-only nodes in the region. Read-only nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you don't specify this parameter, no read-only nodes are deployed to the region. See below\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "regionName": {
                    "type": "string",
                    "description": "Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "priority",
                "providerName",
                "regionName"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "analyticsAutoScaling",
                        "autoScaling",
                        "priority",
                        "providerName",
                        "regionName"
                    ]
                }
            }
        },
        "mongodbatlas:index/AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling:AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling": {
            "properties": {
                "computeEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether instance size auto-scaling is enabled. This parameter defaults to false.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "computeMaxInstanceSize": {
                    "type": "string",
                    "description": "Maximum instance size to which your cluster can automatically scale (such as M40). Atlas requires this parameter if `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_enabled` is true.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "computeMinInstanceSize": {
                    "type": "string",
                    "description": "Minimum instance size to which your cluster can automatically scale (such as M10). Atlas requires this parameter if `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_scale_down_enabled` is true.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "computeScaleDownEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the instance size may scale down. Atlas requires this parameter if `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_enabled` : true. If you enable this option, specify a value for `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_min_instance_size`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "diskGbEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether this cluster enables disk auto-scaling. This parameter defaults to true.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "computeEnabled",
                        "computeMaxInstanceSize",
                        "computeMinInstanceSize",
                        "computeScaleDownEnabled",
                        "diskGbEnabled"
                    ]
                }
            }
        },
        "mongodbatlas:index/AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs:AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs": {
            "properties": {
                "diskIops": {
                    "type": "integer",
                    "description": "Target throughput (IOPS) desired for AWS storage attached to your cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ebsVolumeType": {
                    "type": "string",
                    "description": "Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "instanceSize": {
                    "type": "string",
                    "description": "Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary), but can enable local reads.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "instanceSize"
            ]
        },
        "mongodbatlas:index/AdvancedClusterReplicationSpecRegionConfigAutoScaling:AdvancedClusterReplicationSpecRegionConfigAutoScaling": {
            "properties": {
                "computeEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether instance size auto-scaling is enabled. This parameter defaults to false.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "computeMaxInstanceSize": {
                    "type": "string",
                    "description": "Maximum instance size to which your cluster can automatically scale (such as M40). Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_enabled` is true.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "computeMinInstanceSize": {
                    "type": "string",
                    "description": "Minimum instance size to which your cluster can automatically scale (such as M10). Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_scale_down_enabled` is true.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "computeScaleDownEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the instance size may scale down. Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_enabled` : true. If you enable this option, specify a value for `replication_specs.#.region_configs.#.auto_scaling.0.compute_min_instance_size`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "diskGbEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether this cluster enables disk auto-scaling. This parameter defaults to true.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "computeEnabled",
                        "computeMaxInstanceSize",
                        "computeMinInstanceSize",
                        "computeScaleDownEnabled",
                        "diskGbEnabled"
                    ]
                }
            }
        },
        "mongodbatlas:index/AdvancedClusterReplicationSpecRegionConfigElectableSpecs:AdvancedClusterReplicationSpecRegionConfigElectableSpecs": {
            "properties": {
                "diskIops": {
                    "type": "integer",
                    "description": "Target throughput (IOPS) desired for AWS storage attached to your cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ebsVolumeType": {
                    "type": "string",
                    "description": "Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "instanceSize": {
                    "type": "string",
                    "description": "Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary), but can enable local reads.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "instanceSize"
            ]
        },
        "mongodbatlas:index/AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs:AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs": {
            "properties": {
                "diskIops": {
                    "type": "integer",
                    "description": "Target throughput (IOPS) desired for AWS storage attached to your cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ebsVolumeType": {
                    "type": "string",
                    "description": "Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "instanceSize": {
                    "type": "string",
                    "description": "Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary), but can enable local reads.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "instanceSize"
            ]
        },
        "mongodbatlas:index/AlertConfigurationMatcher:AlertConfigurationMatcher": {
            "properties": {
                "fieldName": {
                    "type": "string",
                    "description": "Name of the field in the target object to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "operator": {
                    "type": "string",
                    "description": "If omitted, the configuration is disabled.\nAccepted values are:\nAccepted values are:\nAccepted values are:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "If omitted, the configuration is disabled.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/AlertConfigurationMetricThresholdConfig:AlertConfigurationMetricThresholdConfig": {
            "properties": {
                "metricName": {
                    "type": "string",
                    "description": "Name of the metric to check. The full list being quite large, please refer to atlas docs [here for general metrics](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types) and [here for serverless metrics](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-create-config/#serverless-measurements)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mode": {
                    "type": "string",
                    "description": "This must be set to AVERAGE. Atlas computes the current metric value as an average.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "operator": {
                    "type": "string",
                    "description": "If omitted, the configuration is disabled.\nAccepted values are:\nAccepted values are:\nAccepted values are:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "threshold": {
                    "type": "number",
                    "description": "Threshold value outside of which an alert will be triggered.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "units": {
                    "type": "string",
                    "description": "The units for the threshold value. Depends on the type of metric.\nRefer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.\nRefer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/AlertConfigurationNotification:AlertConfigurationNotification": {
            "properties": {
                "apiToken": {
                    "type": "string",
                    "description": "Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "channelName": {
                    "type": "string",
                    "description": "Slack channel name. Required for the SLACK notifications type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datadogApiKey": {
                    "type": "string",
                    "description": "Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "datadogRegion": {
                    "type": "string",
                    "description": "Region that indicates which API URL to use. Accepted regions are: `US`, `EU`. The default Datadog region is US.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "delayMin": {
                    "type": "integer",
                    "description": "Number of minutes to wait after an alert condition is detected before sending out the first notification.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailAddress": {
                    "type": "string",
                    "description": "Email address to which alert notifications are sent. Required for the EMAIL notifications type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailEnabled": {
                    "type": "boolean",
                    "description": "Flag indicating email notifications should be sent. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "flowName": {
                    "type": "string",
                    "description": "Flowdock flow name in lower-case letters. Required for the `FLOWDOCK` notifications type\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "flowdockApiToken": {
                    "type": "string",
                    "description": "The Flowdock personal API token. Required for the `FLOWDOCK` notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "intervalMin": {
                    "type": "integer",
                    "description": "Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5. **NOTE** `PAGER_DUTY`, `VICTOR_OPS`, and `OPS_GENIE` notifications do not return this value. The notification interval must be configured and managed within each external service.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "microsoftTeamsWebhookUrl": {
                    "type": "string",
                    "description": "Microsoft Teams Webhook Uniform Resource Locator (URL) that MongoDB Cloud needs to send this notification via Microsoft Teams. Required if `type_name` is `MICROSOFT_TEAMS`. If the URL later becomes invalid, MongoDB Cloud sends an email to the project owners. If the key remains invalid, MongoDB Cloud removes it.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "mobileNumber": {
                    "type": "string",
                    "description": "Mobile number to which alert notifications are sent. Required for the SMS notifications type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "opsGenieApiKey": {
                    "type": "string",
                    "description": "Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "opsGenieRegion": {
                    "type": "string",
                    "description": "Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "orgName": {
                    "type": "string",
                    "description": "Flowdock organization name in lower-case letters. This is the name that appears after www.flowdock.com/app/ in the URL string. Required for the FLOWDOCK notifications type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Optional. One or more roles that receive the configured alert. If you include this field, Atlas sends alerts only to users assigned the roles you specify in the array. If you omit this field, Atlas sends alerts to users assigned any role. This parameter is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.\nAccepted values are:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serviceKey": {
                    "type": "string",
                    "description": "PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "smsEnabled": {
                    "type": "boolean",
                    "description": "Flag indicating if text message notifications should be sent to this user's mobile phone. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "teamId": {
                    "type": "string",
                    "description": "Unique identifier of a team.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "teamName": {
                    "type": "string",
                    "description": "Label for the team that receives this notification.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "typeName": {
                    "type": "string",
                    "description": "Type of alert notification.\nAccepted values are:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "victorOpsApiKey": {
                    "type": "string",
                    "description": "VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "victorOpsRoutingKey": {
                    "type": "string",
                    "description": "VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "webhookSecret": {
                    "type": "string",
                    "description": "Optional authentication secret for the `WEBHOOK` notifications type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "webhookUrl": {
                    "type": "string",
                    "description": "Target URL  for the `WEBHOOK` notifications type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "teamName"
                    ]
                }
            }
        },
        "mongodbatlas:index/AlertConfigurationThresholdConfig:AlertConfigurationThresholdConfig": {
            "properties": {
                "operator": {
                    "type": "string",
                    "description": "If omitted, the configuration is disabled.\nAccepted values are:\nAccepted values are:\nAccepted values are:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "threshold": {
                    "type": "number",
                    "description": "Threshold value outside of which an alert will be triggered.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "units": {
                    "type": "string",
                    "description": "The units for the threshold value. Depends on the type of metric.\nRefer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.\nRefer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/CloudBackupScheduleCopySetting:CloudBackupScheduleCopySetting": {
            "properties": {
                "cloudProvider": {
                    "type": "string",
                    "description": "Human-readable label that identifies the cloud provider that stores the snapshot copy. i.e. \"AWS\" \"AZURE\" \"GCP\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "frequencies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List that describes which types of snapshots to copy. i.e. \"HOURLY\" \"DAILY\" \"WEEKLY\" \"MONTHLY\" \"ON_DEMAND\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "regionName": {
                    "type": "string",
                    "description": "Target region to copy snapshots belonging to replicationSpecId to. Please supply the 'Atlas Region' which can be found under https://www.mongodb.com/docs/atlas/reference/cloud-providers/ 'regions' link\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "replicationSpecId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the replication object for a zone in a cluster. For global clusters, there can be multiple zones to choose from. For sharded clusters and replica set clusters, there is only one zone in the cluster. To find the Replication Spec Id, do a GET request to Return One Cluster in One Project and consult the replicationSpecs array https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#operation/returnOneCluster\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "shouldCopyOplogs": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to copy the oplogs to the target region. You can use the oplogs to perform point-in-time restores.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "cloudProvider",
                        "frequencies",
                        "regionName",
                        "replicationSpecId",
                        "shouldCopyOplogs"
                    ]
                }
            }
        },
        "mongodbatlas:index/CloudBackupScheduleExport:CloudBackupScheduleExport": {
            "properties": {
                "exportBucketId": {
                    "type": "string",
                    "description": "Unique identifier of the mongodbatlas.CloudBackupSnapshotExportBucket export_bucket_id value.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the export snapshot item.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "exportBucketId",
                        "frequencyType"
                    ]
                }
            }
        },
        "mongodbatlas:index/CloudBackupSchedulePolicyItemDaily:CloudBackupSchedulePolicyItemDaily": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (daily in this case). The only supported value for daily policies is `1` day.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For daily policies, the frequency type is defined as `daily`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, or `months`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`.  Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the hourly policy item specifies a retention of two days, the daily retention policy must specify two days or greater.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "frequencyInterval",
                        "frequencyType",
                        "id",
                        "retentionUnit",
                        "retentionValue"
                    ]
                }
            }
        },
        "mongodbatlas:index/CloudBackupSchedulePolicyItemHourly:CloudBackupSchedulePolicyItemHourly": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (hourly in this case). The supported values for hourly policies are `1`, `2`, `4`, `6`, `8` or `12` hours. Note that `12` hours is the only accepted value for NVMe clusters.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For hourly policies, the frequency type is defined as `hourly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, or `months`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "frequencyInterval",
                        "frequencyType",
                        "id",
                        "retentionUnit",
                        "retentionValue"
                    ]
                }
            }
        },
        "mongodbatlas:index/CloudBackupSchedulePolicyItemMonthly:CloudBackupSchedulePolicyItemMonthly": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, or `months`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "frequencyInterval",
                        "frequencyType",
                        "id",
                        "retentionUnit",
                        "retentionValue"
                    ]
                }
            }
        },
        "mongodbatlas:index/CloudBackupSchedulePolicyItemWeekly:CloudBackupSchedulePolicyItemWeekly": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (weekly in this case). The supported values for weekly policies are `1` through `7`, where `1` represents Monday and `7` represents Sunday.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For weekly policies, the frequency type is defined as `weekly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, or `months`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`. Weekly policy must have retention of at least 7 days or 1 week. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the daily policy item specifies a retention of two weeks, the weekly retention policy must specify two weeks or greater.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "frequencyInterval",
                        "frequencyType",
                        "id",
                        "retentionUnit",
                        "retentionValue"
                    ]
                }
            }
        },
        "mongodbatlas:index/CloudBackupSnapshotExportJobComponent:CloudBackupSnapshotExportJobComponent": {
            "properties": {
                "exportId": {
                    "type": "string",
                    "description": "_Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "replicaSetName": {
                    "type": "string",
                    "description": "_Returned for sharded clusters only._ Unique identifier of the export job for the replica set.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "exportId",
                        "replicaSetName"
                    ]
                }
            }
        },
        "mongodbatlas:index/CloudBackupSnapshotExportJobCustomData:CloudBackupSnapshotExportJobCustomData": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "Required if you want to include custom data using `custom_data` in the metadata file uploaded to the bucket. Key to include in the metadata file that Atlas uploads to the bucket when the export job finishes.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "willReplaceOnChanges": true
                },
                "value": {
                    "type": "string",
                    "description": "Required if you specify `key`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ]
        },
        "mongodbatlas:index/CloudBackupSnapshotMember:CloudBackupSnapshotMember": {
            "properties": {
                "cloudProvider": {
                    "type": "string",
                    "description": "Cloud provider that stores this snapshot.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier for the sharded cluster snapshot.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "replicaSetName": {
                    "type": "string",
                    "description": "Label given to a shard or config server from which Atlas took this snapshot.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "cloudProvider",
                        "id",
                        "replicaSetName"
                    ]
                }
            }
        },
        "mongodbatlas:index/CloudBackupSnapshotRestoreJobDeliveryTypeConfig:CloudBackupSnapshotRestoreJobDeliveryTypeConfig": {
            "properties": {
                "automated": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "willReplaceOnChanges": true
                },
                "download": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "willReplaceOnChanges": true
                },
                "oplogInc": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "willReplaceOnChanges": true
                },
                "oplogTs": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "willReplaceOnChanges": true
                },
                "pointInTime": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "willReplaceOnChanges": true
                },
                "pointInTimeUtcSeconds": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "willReplaceOnChanges": true
                },
                "targetClusterName": {
                    "type": "string",
                    "description": "Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "willReplaceOnChanges": true
                },
                "targetProjectId": {
                    "type": "string",
                    "description": "Name of the target Atlas project of the restore job. Only visible if deliveryType is automated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/CloudProviderAccessAuthorizationAws:CloudProviderAccessAuthorizationAws": {
            "properties": {
                "iamAssumedRoleArn": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "iamAssumedRoleArn"
            ]
        },
        "mongodbatlas:index/CloudProviderAccessAuthorizationFeatureUsage:CloudProviderAccessAuthorizationFeatureUsage": {
            "properties": {
                "featureId": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "featureType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "featureId",
                        "featureType"
                    ]
                }
            }
        },
        "mongodbatlas:index/CloudProviderAccessFeatureUsage:CloudProviderAccessFeatureUsage": {
            "properties": {
                "featureId": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "featureType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "featureId",
                        "featureType"
                    ]
                }
            }
        },
        "mongodbatlas:index/CloudProviderAccessSetupAwsConfig:CloudProviderAccessSetupAwsConfig": {
            "properties": {
                "atlasAssumedRoleExternalId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "atlasAwsAccountArn": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "atlasAssumedRoleExternalId",
                        "atlasAwsAccountArn"
                    ]
                }
            }
        },
        "mongodbatlas:index/CloudProviderSnapshotBackupPolicyPolicy:CloudProviderSnapshotBackupPolicyPolicy": {
            "properties": {
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policyItems": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudProviderSnapshotBackupPolicyPolicyPolicyItem:CloudProviderSnapshotBackupPolicyPolicyPolicyItem"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "id",
                "policyItems"
            ]
        },
        "mongodbatlas:index/CloudProviderSnapshotBackupPolicyPolicyPolicyItem:CloudProviderSnapshotBackupPolicyPolicyPolicyItem": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "frequencyType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "retentionUnit": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "retentionValue": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "frequencyType",
                "id",
                "retentionUnit",
                "retentionValue"
            ]
        },
        "mongodbatlas:index/CloudProviderSnapshotRestoreJobDeliveryTypeConfig:CloudProviderSnapshotRestoreJobDeliveryTypeConfig": {
            "properties": {
                "automated": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "willReplaceOnChanges": true
                },
                "download": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "willReplaceOnChanges": true
                },
                "oplogInc": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "willReplaceOnChanges": true
                },
                "oplogTs": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "willReplaceOnChanges": true
                },
                "pointInTime": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "willReplaceOnChanges": true
                },
                "pointInTimeUtcSeconds": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "willReplaceOnChanges": true
                },
                "targetClusterName": {
                    "type": "string",
                    "description": "Name of the target Atlas cluster to which the restore job restores the snapshot. Only required if deliveryType is automated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "willReplaceOnChanges": true
                },
                "targetProjectId": {
                    "type": "string",
                    "description": "Unique ID of the target Atlas project for the specified targetClusterName. Only required if deliveryType is automated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/ClusterAdvancedConfiguration:ClusterAdvancedConfiguration": {
            "properties": {
                "defaultReadConcern": {
                    "type": "string",
                    "description": "[Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "defaultWriteConcern": {
                    "type": "string",
                    "description": "[Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "failIndexKeyTooLong": {
                    "type": "boolean",
                    "description": "When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "javascriptEnabled": {
                    "type": "boolean",
                    "description": "When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minimumEnabledTlsProtocol": {
                    "type": "string",
                    "description": "Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "noTableScan": {
                    "type": "boolean",
                    "description": "When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oplogMinRetentionHours": {
                    "type": "integer",
                    "description": "Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.\n* **Note**  A minimum oplog retention is required when seeking to change a cluster's class to Local NVMe SSD. To learn more and for latest guidance see  [`oplogMinRetentionHours`](https://www.mongodb.com/docs/manual/core/replica-set-oplog/#std-label-replica-set-minimum-oplog-size)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oplogSizeMb": {
                    "type": "integer",
                    "description": "The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sampleRefreshIntervalBiConnector": {
                    "type": "integer",
                    "description": "Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sampleSizeBiConnector": {
                    "type": "integer",
                    "description": "Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "defaultReadConcern",
                        "defaultWriteConcern",
                        "failIndexKeyTooLong",
                        "javascriptEnabled",
                        "minimumEnabledTlsProtocol",
                        "noTableScan",
                        "oplogMinRetentionHours",
                        "oplogSizeMb",
                        "sampleRefreshIntervalBiConnector",
                        "sampleSizeBiConnector"
                    ]
                }
            }
        },
        "mongodbatlas:index/ClusterBiConnectorConfig:ClusterBiConnectorConfig": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether or not BI Connector for Atlas is enabled on the cluster.l\n*\n- Set to `true` to enable BI Connector for Atlas.\n- Set to `false` to disable BI Connector for Atlas.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readPreference": {
                    "type": "string",
                    "description": "Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "enabled",
                        "readPreference"
                    ]
                }
            }
        },
        "mongodbatlas:index/ClusterConnectionString:ClusterConnectionString": {
            "properties": {
                "awsPrivateLink": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "deprecationMessage": "This field is deprecated. Use connection_strings.private_endpoint[n].connection_string instead",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "awsPrivateLinkSrv": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "deprecationMessage": "This field is deprecated. Use connection_strings.private_endpoint[n].srv_connection_string instead",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "private": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privateEndpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ClusterConnectionStringPrivateEndpoint:ClusterConnectionStringPrivateEndpoint"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privateSrv": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "standard": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "standardSrv": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "awsPrivateLink",
                        "awsPrivateLinkSrv",
                        "private",
                        "privateEndpoints",
                        "privateSrv",
                        "standard",
                        "standardSrv"
                    ]
                }
            }
        },
        "mongodbatlas:index/ClusterConnectionStringPrivateEndpoint:ClusterConnectionStringPrivateEndpoint": {
            "properties": {
                "connectionString": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ClusterConnectionStringPrivateEndpointEndpoint:ClusterConnectionStringPrivateEndpointEndpoint"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "srvConnectionString": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "connectionString",
                        "endpoints",
                        "srvConnectionString",
                        "type"
                    ]
                }
            }
        },
        "mongodbatlas:index/ClusterConnectionStringPrivateEndpointEndpoint:ClusterConnectionStringPrivateEndpointEndpoint": {
            "properties": {
                "endpointId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud service provider on which the servers are provisioned.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "endpointId",
                        "providerName",
                        "region"
                    ]
                }
            }
        },
        "mongodbatlas:index/ClusterLabel:ClusterLabel": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key that you want to write.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "The value that you want to write.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "key",
                        "value"
                    ]
                }
            }
        },
        "mongodbatlas:index/ClusterReplicationSpec:ClusterReplicationSpec": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "Unique identifer of the replication document for a zone in a Global Cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "numShards": {
                    "type": "integer",
                    "description": "Selects whether the cluster is a replica set or a sharded cluster. If you use the replicationSpecs parameter, you must set num_shards.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "regionsConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ClusterReplicationSpecRegionsConfig:ClusterReplicationSpecRegionsConfig"
                    },
                    "description": "Physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "zoneName": {
                    "type": "string",
                    "description": "Name for the zone in a Global Cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "numShards"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "numShards",
                        "regionsConfigs"
                    ]
                }
            }
        },
        "mongodbatlas:index/ClusterReplicationSpecRegionsConfig:ClusterReplicationSpecRegionsConfig": {
            "properties": {
                "analyticsNodes": {
                    "type": "integer",
                    "description": "The number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary. If you do not specify this option, no analytics nodes are deployed to the region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "electableNodes": {
                    "type": "integer",
                    "description": "Number of electable nodes for Atlas to deploy to the region. Electable nodes can become the primary and can facilitate local reads.\n* The total number of electableNodes across all replication spec regions  must total 3, 5, or 7.\n* Specify 0 if you do not want any electable nodes in the region.\n* You cannot create electable nodes in a region if `priority` is 0.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "priority": {
                    "type": "integer",
                    "description": "Election priority of the region. For regions with only read-only nodes, set this value to 0.\n* For regions where `electable_nodes` is at least 1, each region must have a priority of exactly one (1) less than the previous region. The first region must have a priority of 7. The lowest possible priority is 1.\n* The priority 7 region identifies the Preferred Region of the cluster. Atlas places the primary node in the Preferred Region. Priorities 1 through 7 are exclusive - no more than one region per cluster can be assigned a given priority.\n* Example: If you have three regions, their priorities would be 7, 6, and 5 respectively. If you added two more regions for supporting electable nodes, the priorities of those regions would be 4 and 3 respectively.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readOnlyNodes": {
                    "type": "integer",
                    "description": "Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "regionName": {
                    "type": "string",
                    "description": "Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "regionName"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "electableNodes",
                        "priority",
                        "regionName"
                    ]
                }
            }
        },
        "mongodbatlas:index/ClusterSnapshotBackupPolicy:ClusterSnapshotBackupPolicy": {
            "properties": {
                "clusterId": {
                    "type": "string",
                    "description": "The cluster ID.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clusterName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nextSnapshot": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ClusterSnapshotBackupPolicyPolicy:ClusterSnapshotBackupPolicyPolicy"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "referenceHourOfDay": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "referenceMinuteOfHour": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "restoreWindowDays": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "updateSnapshots": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "clusterId",
                        "clusterName",
                        "nextSnapshot",
                        "policies",
                        "referenceHourOfDay",
                        "referenceMinuteOfHour",
                        "restoreWindowDays",
                        "updateSnapshots"
                    ]
                }
            }
        },
        "mongodbatlas:index/ClusterSnapshotBackupPolicyPolicy:ClusterSnapshotBackupPolicyPolicy": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "Unique identifer of the replication document for a zone in a Global Cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policyItems": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ClusterSnapshotBackupPolicyPolicyPolicyItem:ClusterSnapshotBackupPolicyPolicyPolicyItem"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "policyItems"
                    ]
                }
            }
        },
        "mongodbatlas:index/ClusterSnapshotBackupPolicyPolicyPolicyItem:ClusterSnapshotBackupPolicyPolicyPolicyItem": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "frequencyType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifer of the replication document for a zone in a Global Cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "retentionUnit": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "retentionValue": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "frequencyInterval",
                        "frequencyType",
                        "id",
                        "retentionUnit",
                        "retentionValue"
                    ]
                }
            }
        },
        "mongodbatlas:index/CustomDbRoleAction:CustomDbRoleAction": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Name of the privilege action. For a complete list of actions available in the Atlas API, see [Custom Role Actions](https://docs.atlas.mongodb.com/reference/api/custom-role-actions)\n\u003e **Note**: The privilege actions available to the Custom Roles API resource represent a subset of the privilege actions available in the Atlas Custom Roles UI.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "resources": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CustomDbRoleActionResource:CustomDbRoleActionResource"
                    },
                    "description": "Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "action",
                "resources"
            ]
        },
        "mongodbatlas:index/CustomDbRoleActionResource:CustomDbRoleActionResource": {
            "properties": {
                "cluster": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "collectionName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "databaseName": {
                    "type": "string",
                    "description": "Database on which the inherited role is granted.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/CustomDbRoleInheritedRole:CustomDbRoleInheritedRole": {
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "Database on which the inherited role is granted.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleName": {
                    "type": "string",
                    "description": "Name of the inherited role. This can either be another custom role or a built-in role.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "databaseName",
                "roleName"
            ]
        },
        "mongodbatlas:index/DataLakeAws:DataLakeAws": {
            "properties": {
                "externalId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "iamAssumedRoleArn": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "iamUserArn": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testS3Bucket": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "roleId",
                "testS3Bucket"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "externalId",
                        "iamAssumedRoleArn",
                        "iamUserArn",
                        "roleId",
                        "testS3Bucket"
                    ]
                }
            }
        },
        "mongodbatlas:index/DataLakeDataProcessRegion:DataLakeDataProcessRegion": {
            "properties": {
                "cloudProvider": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "cloudProvider",
                "region"
            ]
        },
        "mongodbatlas:index/DataLakeStorageDatabase:DataLakeStorageDatabase": {
            "properties": {
                "collections": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/DataLakeStorageDatabaseCollection:DataLakeStorageDatabaseCollection"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxWildcardCollections": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of the Atlas Data Lake.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "views": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/DataLakeStorageDatabaseView:DataLakeStorageDatabaseView"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "collections",
                        "maxWildcardCollections",
                        "name",
                        "views"
                    ]
                }
            }
        },
        "mongodbatlas:index/DataLakeStorageDatabaseCollection:DataLakeStorageDatabaseCollection": {
            "properties": {
                "dataSources": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/DataLakeStorageDatabaseCollectionDataSource:DataLakeStorageDatabaseCollectionDataSource"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of the Atlas Data Lake.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "dataSources",
                        "name"
                    ]
                }
            }
        },
        "mongodbatlas:index/DataLakeStorageDatabaseCollectionDataSource:DataLakeStorageDatabaseCollectionDataSource": {
            "properties": {
                "defaultFormat": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "storeName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "defaultFormat",
                        "path",
                        "storeName"
                    ]
                }
            }
        },
        "mongodbatlas:index/DataLakeStorageDatabaseView:DataLakeStorageDatabaseView": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the Atlas Data Lake.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pipeline": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "source": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "pipeline",
                        "source"
                    ]
                }
            }
        },
        "mongodbatlas:index/DataLakeStorageStore:DataLakeStorageStore": {
            "properties": {
                "additionalStorageClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bucket": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "delimiter": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "includeTags": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of the Atlas Data Lake.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "prefix": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "provider": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "additionalStorageClasses",
                        "bucket",
                        "delimiter",
                        "includeTags",
                        "name",
                        "prefix",
                        "provider",
                        "region"
                    ]
                }
            }
        },
        "mongodbatlas:index/DatabaseUserLabel:DatabaseUserLabel": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key that you want to write.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "The value that you want to write.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "key",
                        "value"
                    ]
                }
            }
        },
        "mongodbatlas:index/DatabaseUserRole:DatabaseUserRole": {
            "properties": {
                "collectionName": {
                    "type": "string",
                    "description": "Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "databaseName": {
                    "type": "string",
                    "description": "Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleName": {
                    "type": "string",
                    "description": "Name of the role to grant. See [Create a Database User](https://docs.atlas.mongodb.com/reference/api/database-users-create-a-user/) `roles.roleName` for valid values and restrictions.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "collectionName",
                        "databaseName",
                        "roleName"
                    ]
                }
            }
        },
        "mongodbatlas:index/DatabaseUserScope:DatabaseUserScope": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the cluster or Atlas Data Lake that the user has access to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/EncryptionAtRestAwsKmsConfig:EncryptionAtRestAwsKmsConfig": {
            "properties": {
                "accessKeyId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "customerMasterKeyId": {
                    "type": "string",
                    "description": "The AWS customer master key used to encrypt and decrypt the MongoDB master keys.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether Encryption at Rest is enabled for an Atlas project, To disable Encryption at Rest, pass only this parameter with a value of false, When you disable Encryption at Rest, Atlas also removes the configuration details.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "description": "The AWS region in which the AWS customer master key exists: CA_CENTRAL_1, US_EAST_1, US_EAST_2, US_WEST_1, US_WEST_2, SA_EAST_1\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleId": {
                    "type": "string",
                    "description": "ID of an AWS IAM role authorized to manage an AWS customer master key. To find the ID for an existing IAM role check the `role_id` attribute of the `mongodbatlas.CloudProviderAccess` resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "secretAccessKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/EncryptionAtRestAzureKeyVaultConfig:EncryptionAtRestAzureKeyVaultConfig": {
            "properties": {
                "azureEnvironment": {
                    "type": "string",
                    "description": "The Azure environment where the Azure account credentials reside. Valid values are the following: AZURE, AZURE_CHINA, AZURE_GERMANY\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clientId": {
                    "type": "string",
                    "description": "The client ID, also known as the application ID, for an Azure application associated with the Azure AD tenant.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether Encryption at Rest is enabled for an Atlas project. To disable Encryption at Rest, pass only this parameter with a value of false. When you disable Encryption at Rest, Atlas also removes the configuration details.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyIdentifier": {
                    "type": "string",
                    "description": "The unique identifier of a key in an Azure Key Vault.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "keyVaultName": {
                    "type": "string",
                    "description": "The name of an Azure Key Vault containing your key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "resourceGroupName": {
                    "type": "string",
                    "description": "The name of the Azure Resource group that contains an Azure Key Vault.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "secret": {
                    "type": "string",
                    "description": "The secret associated with the Azure Key Vault specified by azureKeyVault.tenantID.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "subscriptionId": {
                    "type": "string",
                    "description": "The unique identifier associated with an Azure subscription.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "tenantId": {
                    "type": "string",
                    "description": "The unique identifier for an Azure AD tenant within an Azure subscription.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "enabled"
            ]
        },
        "mongodbatlas:index/EncryptionAtRestGoogleCloudKmsConfig:EncryptionAtRestGoogleCloudKmsConfig": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether Encryption at Rest is enabled for an Atlas project. To disable Encryption at Rest, pass only this parameter with a value of false. When you disable Encryption at Rest, Atlas also removes the configuration details.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "keyVersionResourceId": {
                    "type": "string",
                    "description": "The Key Version Resource ID from your GCP account.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "serviceAccountKey": {
                    "type": "string",
                    "description": "String-formatted JSON object containing GCP KMS credentials from your GCP account.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/EventTriggerEventProcessors:EventTriggerEventProcessors": {
            "properties": {
                "awsEventbridge": {
                    "$ref": "#/types/mongodbatlas:index/EventTriggerEventProcessorsAwsEventbridge:EventTriggerEventProcessorsAwsEventbridge",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/EventTriggerEventProcessorsAwsEventbridge:EventTriggerEventProcessorsAwsEventbridge": {
            "properties": {
                "configAccountId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "configRegion": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/FederatedSettingsOrgRoleMappingRoleAssignment:FederatedSettingsOrgRoleMappingRoleAssignment": {
            "properties": {
                "groupId": {
                    "type": "string",
                    "description": "Unique identifier of the project to which you want the role mapping to apply.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the Roles that are attached to the Role Mapping. Available role IDs can be found on [the User Roles\nReference](https://www.mongodb.com/docs/atlas/reference/user-roles/).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/GlobalClusterConfigCustomZoneMapping:GlobalClusterConfigCustomZoneMapping": {
            "properties": {
                "location": {
                    "type": "string",
                    "description": "The ISO location code to which you want to map a zone in your Global Cluster. You can find a list of all supported location codes [here](https://cloud.mongodb.com/static/atlas/country_iso_codes.txt).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "zone": {
                    "type": "string",
                    "description": "The name of the zone in your Global Cluster that you want to map to location.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "location",
                        "zone"
                    ]
                }
            }
        },
        "mongodbatlas:index/GlobalClusterConfigManagedNamespace:GlobalClusterConfigManagedNamespace": {
            "properties": {
                "collection": {
                    "type": "string",
                    "description": "The name of the collection associated with the managed namespace.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "customShardKey": {
                    "type": "string",
                    "description": "The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "db": {
                    "type": "string",
                    "description": "The name of the database containing the collection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "isCustomShardKeyHashed": {
                    "type": "boolean",
                    "description": "Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "isShardKeyUnique": {
                    "type": "boolean",
                    "description": "Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "collection",
                "customShardKey",
                "db"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "collection",
                        "customShardKey",
                        "db",
                        "isCustomShardKeyHashed",
                        "isShardKeyUnique"
                    ]
                }
            }
        },
        "mongodbatlas:index/LdapConfigurationUserToDnMapping:LdapConfigurationUserToDnMapping": {
            "properties": {
                "ldapQuery": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "match": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "substitution": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "ldapQuery",
                        "match",
                        "substitution"
                    ]
                }
            }
        },
        "mongodbatlas:index/LdapVerifyLink:LdapVerifyLink": {
            "properties": {
                "href": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rel": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "href",
                        "rel"
                    ]
                }
            }
        },
        "mongodbatlas:index/LdapVerifyValidation:LdapVerifyValidation": {
            "properties": {
                "status": {
                    "type": "string",
                    "description": "The current status of the LDAP over TLS/SSL configuration. One of the following values: `PENDING`, `SUCCESS`, and `FAILED`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "validationType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "status",
                        "validationType"
                    ]
                }
            }
        },
        "mongodbatlas:index/OnlineArchiveCriteria:OnlineArchiveCriteria": {
            "properties": {
                "dateField": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "dateFormat": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "expireAfterDays": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "query": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "dateFormat",
                        "type"
                    ]
                }
            }
        },
        "mongodbatlas:index/OnlineArchivePartitionField:OnlineArchivePartitionField": {
            "properties": {
                "fieldName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fieldType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "order": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "fieldName",
                "order"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "fieldName",
                        "fieldType",
                        "order"
                    ]
                }
            }
        },
        "mongodbatlas:index/PrivateLinkEndpointServiceEndpoint:PrivateLinkEndpointServiceEndpoint": {
            "properties": {
                "endpointName": {
                    "type": "string",
                    "description": "Forwarding rule that corresponds to the endpoint you created in GCP.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipAddress": {
                    "type": "string",
                    "description": "Private IP address of the endpoint you created in GCP.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serviceAttachmentName": {
                    "type": "string",
                    "description": "Unique alphanumeric and special character strings that identify the service attachment associated with the endpoint.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "description": "Status of the endpoint. Atlas returns one of the [values shown above](https://docs.atlas.mongodb.com/reference/api/private-endpoints-endpoint-create-one/#std-label-ref-status-field).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "serviceAttachmentName",
                        "status"
                    ]
                }
            }
        },
        "mongodbatlas:index/ProjectApiKey:ProjectApiKey": {
            "properties": {
                "apiKeyId": {
                    "type": "string",
                    "description": "The unique identifier of the Programmatic API key you want to associate with the Project.  The Programmatic API key and Project must share the same parent organization.  Note: this is not the `publicKey` of the Programmatic API key but the `id` of the key. See [Programmatic API Keys](https://docs.atlas.mongodb.com/reference/api/apiKeys/) for more.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Each string in the array represents a project role you want to assign to the team. Every user associated with the team inherits these roles. You must specify an array even if you are only associating a single role with the team.\nThe following are valid roles:\nThe following are valid roles:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "apiKeyId",
                "roleNames"
            ]
        },
        "mongodbatlas:index/ProjectTeam:ProjectTeam": {
            "properties": {
                "roleNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Each string in the array represents a project role you want to assign to the team. Every user associated with the team inherits these roles. You must specify an array even if you are only associating a single role with the team.\nThe following are valid roles:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "teamId": {
                    "type": "string",
                    "description": "The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "roleNames",
                "teamId"
            ]
        },
        "mongodbatlas:index/ProviderAssumeRole:ProviderAssumeRole": {
            "properties": {
                "duration": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "durationSeconds": {
                    "type": "integer",
                    "deprecationMessage": "Use assume_role.duration instead",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "externalId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policy": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policyArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleArn": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sessionName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sourceIdentity": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "transitiveTagKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/SearchIndexSynonym:SearchIndexSynonym": {
            "properties": {
                "analyzer": {
                    "type": "string",
                    "description": "Name of the [analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use with this synonym mapping. Atlas Search doesn't support these [custom analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-custom-analyzers) tokenizers and token filters in [analyzers used in synonym mappings](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#options):\n* [nGram](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-ngram-tokenizer-ref) Tokenizer\n* [edgeGram](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-edgegram-tokenizer-ref) Tokenizers\n* [daitchMokotoffSoundex](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-daitchmokotoffsoundex-tf-ref) token filter\n* [nGram](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-ngram-tf-ref) token filter\n* [edgeGram](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-edgegram-tf-ref) token filter\n* [shingle](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-shingle-tf-ref) token filter\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of the [synonym mapping definition](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-ref). Name must be unique in this index definition and it can't be an empty string.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sourceCollection": {
                    "type": "string",
                    "description": "Name of the source MongoDB collection for the synonyms. Documents in this collection must be in the format described in the [Synonyms Source Collection Documents](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-coll-spec).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "analyzer",
                "name",
                "sourceCollection"
            ]
        },
        "mongodbatlas:index/ServerlessInstanceLink:ServerlessInstanceLink": {
            "properties": {
                "href": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rel": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "href",
                        "rel"
                    ]
                }
            }
        },
        "mongodbatlas:index/X509AuthenticationDatabaseUserCertificate:X509AuthenticationDatabaseUserCertificate": {
            "properties": {
                "createdAt": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groupId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "notAfter": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "subject": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "createdAt",
                        "groupId",
                        "id",
                        "notAfter",
                        "subject"
                    ]
                }
            }
        },
        "mongodbatlas:index/get509AuthenticationDatabaseUserCertificate:get509AuthenticationDatabaseUserCertificate": {
            "properties": {
                "createdAt": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "groupId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "notAfter": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "subject": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "createdAt",
                "groupId",
                "id",
                "notAfter",
                "subject"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAccessListApiKeysResult:getAccessListApiKeysResult": {
            "properties": {
                "accessCount": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cidrBlock": {
                    "type": "string",
                    "description": "Range of IP addresses in CIDR notation to be added to the access list.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "created": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipAddress": {
                    "type": "string",
                    "description": "Single IP address to be added to the access list.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lastUsed": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lastUsedAddress": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "accessCount",
                "cidrBlock",
                "created",
                "ipAddress",
                "lastUsed",
                "lastUsedAddress"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClusterAdvancedConfiguration:getAdvancedClusterAdvancedConfiguration": {
            "properties": {
                "defaultReadConcern": {
                    "type": "string",
                    "description": "[Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "defaultWriteConcern": {
                    "type": "string",
                    "description": "[Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "failIndexKeyTooLong": {
                    "type": "boolean",
                    "description": "When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "javascriptEnabled": {
                    "type": "boolean",
                    "description": "When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minimumEnabledTlsProtocol": {
                    "type": "string",
                    "description": "Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "noTableScan": {
                    "type": "boolean",
                    "description": "When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oplogMinRetentionHours": {
                    "type": "integer",
                    "description": "Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oplogSizeMb": {
                    "type": "integer",
                    "description": "The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sampleRefreshIntervalBiConnector": {
                    "type": "integer",
                    "description": "Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sampleSizeBiConnector": {
                    "type": "integer",
                    "description": "Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "defaultReadConcern",
                "defaultWriteConcern",
                "failIndexKeyTooLong",
                "javascriptEnabled",
                "minimumEnabledTlsProtocol",
                "noTableScan",
                "oplogMinRetentionHours",
                "oplogSizeMb",
                "sampleRefreshIntervalBiConnector",
                "sampleSizeBiConnector"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClusterBiConnectorConfig:getAdvancedClusterBiConnectorConfig": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether or not BI Connector for Atlas is enabled on the cluster.l\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readPreference": {
                    "type": "string",
                    "description": "Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "enabled",
                "readPreference"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClusterConnectionString:getAdvancedClusterConnectionString": {
            "properties": {
                "awsPrivateLink": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "deprecationMessage": "This field is deprecated. Use connection_strings.private_endpoint[n].connection_string instead",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "awsPrivateLinkSrv": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "deprecationMessage": "This field is deprecated. Use connection_strings.private_endpoint[n].srv_connection_string instead",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "private": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privateEndpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClusterConnectionStringPrivateEndpoint:getAdvancedClusterConnectionStringPrivateEndpoint"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privateSrv": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "standard": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "standardSrv": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "awsPrivateLink",
                "awsPrivateLinkSrv",
                "private",
                "privateEndpoints",
                "privateSrv",
                "standard",
                "standardSrv"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClusterConnectionStringPrivateEndpoint:getAdvancedClusterConnectionStringPrivateEndpoint": {
            "properties": {
                "connectionString": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClusterConnectionStringPrivateEndpointEndpoint:getAdvancedClusterConnectionStringPrivateEndpointEndpoint"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "srvConnectionString": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "connectionString",
                "endpoints",
                "srvConnectionString",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClusterConnectionStringPrivateEndpointEndpoint:getAdvancedClusterConnectionStringPrivateEndpointEndpoint": {
            "properties": {
                "endpointId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud service provider on which the servers are provisioned.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "endpointId",
                "providerName",
                "region"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClusterLabel:getAdvancedClusterLabel": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key that you want to write.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "The value that you want to write.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClusterReplicationSpec:getAdvancedClusterReplicationSpec": {
            "properties": {
                "containerId": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A key-value map of the Network Peering Container ID(s) for the configuration specified in `region_configs`. The Container ID is the id of the container either created programmatically by the user before any clusters existed in a project or when the first cluster in the region (AWS/Azure) or project (GCP) was created.  The syntax is `\"providerName:regionName\" = \"containerId\"`. Example `AWS:US_EAST_1\" = \"61e0797dde08fb498ca11a71`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "numShards": {
                    "type": "integer",
                    "description": "Provide this value if you set a `cluster_type` of SHARDED or GEOSHARDED.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "regionConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClusterReplicationSpecRegionConfig:getAdvancedClusterReplicationSpecRegionConfig"
                    },
                    "description": "Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "zoneName": {
                    "type": "string",
                    "description": "Name for the zone in a Global Cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "containerId",
                "id",
                "numShards",
                "regionConfigs",
                "zoneName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClusterReplicationSpecRegionConfig:getAdvancedClusterReplicationSpecRegionConfig": {
            "properties": {
                "analyticsAutoScalings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling:getAdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling"
                    },
                    "description": "Configuration for the Collection of settings that configures analytics-auto-scaling information for the cluster. See below\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "analyticsSpecs": {
                    "$ref": "#/types/mongodbatlas:index/getAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs:getAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs",
                    "description": "Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. See below\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "autoScalings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClusterReplicationSpecRegionConfigAutoScaling:getAdvancedClusterReplicationSpecRegionConfigAutoScaling"
                    },
                    "description": "Configuration for the Collection of settings that configures auto-scaling information for the cluster. See below\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "backingProviderName": {
                    "type": "string",
                    "description": "Cloud service provider on which you provision the host for a multi-tenant cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "electableSpecs": {
                    "$ref": "#/types/mongodbatlas:index/getAdvancedClusterReplicationSpecRegionConfigElectableSpecs:getAdvancedClusterReplicationSpecRegionConfigElectableSpecs",
                    "description": "Hardware specifications for electable nodes in the region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "priority": {
                    "type": "integer",
                    "description": "Election priority of the region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud service provider on which the servers are provisioned.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readOnlySpecs": {
                    "$ref": "#/types/mongodbatlas:index/getAdvancedClusterReplicationSpecRegionConfigReadOnlySpecs:getAdvancedClusterReplicationSpecRegionConfigReadOnlySpecs",
                    "description": "Hardware specifications for read-only nodes in the region. See below\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "regionName": {
                    "type": "string",
                    "description": "Physical location of your MongoDB cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "analyticsAutoScalings",
                "autoScalings",
                "backingProviderName",
                "priority",
                "providerName",
                "regionName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling:getAdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling": {
            "properties": {
                "computeEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether instance size auto-scaling is enabled.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "computeMaxInstanceSize": {
                    "type": "string",
                    "description": "Maximum instance size to which your cluster can automatically scale (such as M40). \n#### Advanced Configuration\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "computeMinInstanceSize": {
                    "type": "string",
                    "description": "Minimum instance size to which your cluster can automatically scale (such as M10).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "computeScaleDownEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the instance size may scale down.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "diskGbEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether this cluster enables disk auto-scaling.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "computeEnabled",
                "computeMaxInstanceSize",
                "computeMinInstanceSize",
                "computeScaleDownEnabled",
                "diskGbEnabled"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs:getAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs": {
            "properties": {
                "diskIops": {
                    "type": "integer",
                    "description": "Target throughput (IOPS) desired for AWS storage attached to your cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ebsVolumeType": {
                    "type": "string",
                    "description": "Type of storage you want to attach to your AWS-provisioned cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "instanceSize": {
                    "type": "string",
                    "description": "Hardware specification for the instance sizes in this region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "Number of read-only nodes for Atlas to deploy to the region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "instanceSize"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClusterReplicationSpecRegionConfigAutoScaling:getAdvancedClusterReplicationSpecRegionConfigAutoScaling": {
            "properties": {
                "computeEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether instance size auto-scaling is enabled.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "computeMaxInstanceSize": {
                    "type": "string",
                    "description": "Maximum instance size to which your cluster can automatically scale (such as M40). \n#### Advanced Configuration\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "computeMinInstanceSize": {
                    "type": "string",
                    "description": "Minimum instance size to which your cluster can automatically scale (such as M10).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "computeScaleDownEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the instance size may scale down.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "diskGbEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether this cluster enables disk auto-scaling.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "computeEnabled",
                "computeMaxInstanceSize",
                "computeMinInstanceSize",
                "computeScaleDownEnabled",
                "diskGbEnabled"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClusterReplicationSpecRegionConfigElectableSpecs:getAdvancedClusterReplicationSpecRegionConfigElectableSpecs": {
            "properties": {
                "diskIops": {
                    "type": "integer",
                    "description": "Target throughput (IOPS) desired for AWS storage attached to your cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ebsVolumeType": {
                    "type": "string",
                    "description": "Type of storage you want to attach to your AWS-provisioned cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "instanceSize": {
                    "type": "string",
                    "description": "Hardware specification for the instance sizes in this region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "Number of read-only nodes for Atlas to deploy to the region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "instanceSize"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClusterReplicationSpecRegionConfigReadOnlySpecs:getAdvancedClusterReplicationSpecRegionConfigReadOnlySpecs": {
            "properties": {
                "diskIops": {
                    "type": "integer",
                    "description": "Target throughput (IOPS) desired for AWS storage attached to your cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ebsVolumeType": {
                    "type": "string",
                    "description": "Type of storage you want to attach to your AWS-provisioned cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "instanceSize": {
                    "type": "string",
                    "description": "Hardware specification for the instance sizes in this region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "Number of read-only nodes for Atlas to deploy to the region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "instanceSize"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResult:getAdvancedClustersResult": {
            "properties": {
                "advancedConfigurations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResultAdvancedConfiguration:getAdvancedClustersResultAdvancedConfiguration"
                    },
                    "description": "Get the advanced configuration options. See Advanced Configuration below for more details.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "backupEnabled": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "biConnectorConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResultBiConnectorConfig:getAdvancedClustersResultBiConnectorConfig"
                    },
                    "description": "Configuration settings applied to BI Connector for Atlas on this cluster. See below. **NOTE** Prior version of provider had parameter as `bi_connector`\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clusterType": {
                    "type": "string",
                    "description": "Type of the cluster that you want to create.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectionStrings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResultConnectionString:getAdvancedClustersResultConnectionString"
                    },
                    "description": "Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "createDate": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "diskSizeGb": {
                    "type": "number",
                    "description": "Capacity, in gigabytes, of the host's root volume.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "encryptionAtRestProvider": {
                    "type": "string",
                    "description": "Possible values are AWS, GCP, AZURE or NONE.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResultLabel:getAdvancedClustersResultLabel"
                    },
                    "description": "Configuration for the collection of key-value pairs that tag and categorize the cluster. See below.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mongoDbMajorVersion": {
                    "type": "string",
                    "description": "Version of the cluster to deploy.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mongoDbVersion": {
                    "type": "string",
                    "description": "Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "paused": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the cluster is paused or not.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pitEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates if the cluster uses Continuous Cloud Backup.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "replicationSpecs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResultReplicationSpec:getAdvancedClustersResultReplicationSpec"
                    },
                    "description": "Configuration for cluster regions and the hardware provisioned in them. See below\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rootCertType": {
                    "type": "string",
                    "description": "Certificate Authority that MongoDB Atlas clusters use.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "stateName": {
                    "type": "string",
                    "description": "Current state of the cluster. The possible states are:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "terminationProtectionEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "versionReleaseSystem": {
                    "type": "string",
                    "description": "Release cadence that Atlas uses for this cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "advancedConfigurations",
                "backupEnabled",
                "biConnectorConfigs",
                "clusterType",
                "connectionStrings",
                "createDate",
                "diskSizeGb",
                "encryptionAtRestProvider",
                "labels",
                "mongoDbMajorVersion",
                "mongoDbVersion",
                "name",
                "paused",
                "pitEnabled",
                "replicationSpecs",
                "rootCertType",
                "stateName",
                "terminationProtectionEnabled",
                "versionReleaseSystem"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResultAdvancedConfiguration:getAdvancedClustersResultAdvancedConfiguration": {
            "properties": {
                "defaultReadConcern": {
                    "type": "string",
                    "description": "[Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "defaultWriteConcern": {
                    "type": "string",
                    "description": "[Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "failIndexKeyTooLong": {
                    "type": "boolean",
                    "description": "When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "javascriptEnabled": {
                    "type": "boolean",
                    "description": "When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minimumEnabledTlsProtocol": {
                    "type": "string",
                    "description": "Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "noTableScan": {
                    "type": "boolean",
                    "description": "When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oplogMinRetentionHours": {
                    "type": "integer",
                    "description": "Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oplogSizeMb": {
                    "type": "integer",
                    "description": "The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sampleRefreshIntervalBiConnector": {
                    "type": "integer",
                    "description": "Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sampleSizeBiConnector": {
                    "type": "integer",
                    "description": "Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "defaultReadConcern",
                "defaultWriteConcern",
                "failIndexKeyTooLong",
                "javascriptEnabled",
                "minimumEnabledTlsProtocol",
                "noTableScan",
                "oplogMinRetentionHours",
                "oplogSizeMb",
                "sampleRefreshIntervalBiConnector",
                "sampleSizeBiConnector"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResultBiConnectorConfig:getAdvancedClustersResultBiConnectorConfig": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether or not BI Connector for Atlas is enabled on the cluster.l\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readPreference": {
                    "type": "string",
                    "description": "Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "enabled",
                "readPreference"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResultConnectionString:getAdvancedClustersResultConnectionString": {
            "properties": {
                "awsPrivateLink": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "deprecationMessage": "This field is deprecated. Use connection_strings.private_endpoint[n].connection_string instead",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "awsPrivateLinkSrv": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "deprecationMessage": "This field is deprecated. Use connection_strings.private_endpoint[n].srv_connection_string instead",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "private": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privateEndpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResultConnectionStringPrivateEndpoint:getAdvancedClustersResultConnectionStringPrivateEndpoint"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privateSrv": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "standard": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "standardSrv": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "awsPrivateLink",
                "awsPrivateLinkSrv",
                "private",
                "privateEndpoints",
                "privateSrv",
                "standard",
                "standardSrv"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResultConnectionStringPrivateEndpoint:getAdvancedClustersResultConnectionStringPrivateEndpoint": {
            "properties": {
                "connectionString": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResultConnectionStringPrivateEndpointEndpoint:getAdvancedClustersResultConnectionStringPrivateEndpointEndpoint"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "srvConnectionString": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "connectionString",
                "endpoints",
                "srvConnectionString",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResultConnectionStringPrivateEndpointEndpoint:getAdvancedClustersResultConnectionStringPrivateEndpointEndpoint": {
            "properties": {
                "endpointId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud service provider on which the servers are provisioned.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "endpointId",
                "providerName",
                "region"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResultLabel:getAdvancedClustersResultLabel": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key that you want to write.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "The value that you want to write.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResultReplicationSpec:getAdvancedClustersResultReplicationSpec": {
            "properties": {
                "containerId": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A key-value map of the Network Peering Container ID(s) for the configuration specified in `region_configs`. The Container ID is the id of the container either created programmatically by the user before any clusters existed in a project or when the first cluster in the region (AWS/Azure) or project (GCP) was created.  The syntax is `\"providerName:regionName\" = \"containerId\"`. Example `AWS:US_EAST_1\" = \"61e0797dde08fb498ca11a71`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "numShards": {
                    "type": "integer",
                    "description": "Provide this value if you set a `cluster_type` of SHARDED or GEOSHARDED.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "regionConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResultReplicationSpecRegionConfig:getAdvancedClustersResultReplicationSpecRegionConfig"
                    },
                    "description": "Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "zoneName": {
                    "type": "string",
                    "description": "Name for the zone in a Global Cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "containerId",
                "id",
                "numShards",
                "regionConfigs",
                "zoneName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResultReplicationSpecRegionConfig:getAdvancedClustersResultReplicationSpecRegionConfig": {
            "properties": {
                "analyticsAutoScalings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResultReplicationSpecRegionConfigAnalyticsAutoScaling:getAdvancedClustersResultReplicationSpecRegionConfigAnalyticsAutoScaling"
                    },
                    "description": "Configuration for the Collection of settings that configures analytis-auto-scaling information for the cluster. See below\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "analyticsSpecs": {
                    "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecs:getAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecs",
                    "description": "Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. See below\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "autoScalings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResultReplicationSpecRegionConfigAutoScaling:getAdvancedClustersResultReplicationSpecRegionConfigAutoScaling"
                    },
                    "description": "Configuration for the Collection of settings that configures auto-scaling information for the cluster. See below\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "backingProviderName": {
                    "type": "string",
                    "description": "Cloud service provider on which you provision the host for a multi-tenant cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "electableSpecs": {
                    "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResultReplicationSpecRegionConfigElectableSpecs:getAdvancedClustersResultReplicationSpecRegionConfigElectableSpecs",
                    "description": "Hardware specifications for electable nodes in the region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "priority": {
                    "type": "integer",
                    "description": "Election priority of the region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud service provider on which the servers are provisioned.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readOnlySpecs": {
                    "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecs:getAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecs",
                    "description": "Hardware specifications for read-only nodes in the region. See below\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "regionName": {
                    "type": "string",
                    "description": "Physical location of your MongoDB cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "analyticsAutoScalings",
                "autoScalings",
                "backingProviderName",
                "priority",
                "providerName",
                "regionName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResultReplicationSpecRegionConfigAnalyticsAutoScaling:getAdvancedClustersResultReplicationSpecRegionConfigAnalyticsAutoScaling": {
            "properties": {
                "computeEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether instance size auto-scaling is enabled.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "computeMaxInstanceSize": {
                    "type": "string",
                    "description": "Maximum instance size to which your cluster can automatically scale (such as M40).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "computeMinInstanceSize": {
                    "type": "string",
                    "description": "Minimum instance size to which your cluster can automatically scale (such as M10).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "computeScaleDownEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the instance size may scale down.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "diskGbEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether this cluster enables disk auto-scaling.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "computeEnabled",
                "computeMaxInstanceSize",
                "computeMinInstanceSize",
                "computeScaleDownEnabled",
                "diskGbEnabled"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecs:getAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecs": {
            "properties": {
                "diskIops": {
                    "type": "integer",
                    "description": "Target throughput (IOPS) desired for AWS storage attached to your cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ebsVolumeType": {
                    "type": "string",
                    "description": "Type of storage you want to attach to your AWS-provisioned cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "instanceSize": {
                    "type": "string",
                    "description": "Hardware specification for the instance sizes in this region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "Number of read-only nodes for Atlas to deploy to the region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "instanceSize"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResultReplicationSpecRegionConfigAutoScaling:getAdvancedClustersResultReplicationSpecRegionConfigAutoScaling": {
            "properties": {
                "computeEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether instance size auto-scaling is enabled.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "computeMaxInstanceSize": {
                    "type": "string",
                    "description": "Maximum instance size to which your cluster can automatically scale (such as M40).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "computeMinInstanceSize": {
                    "type": "string",
                    "description": "Minimum instance size to which your cluster can automatically scale (such as M10).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "computeScaleDownEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the instance size may scale down.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "diskGbEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether this cluster enables disk auto-scaling.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "computeEnabled",
                "computeMaxInstanceSize",
                "computeMinInstanceSize",
                "computeScaleDownEnabled",
                "diskGbEnabled"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResultReplicationSpecRegionConfigElectableSpecs:getAdvancedClustersResultReplicationSpecRegionConfigElectableSpecs": {
            "properties": {
                "diskIops": {
                    "type": "integer",
                    "description": "Target throughput (IOPS) desired for AWS storage attached to your cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ebsVolumeType": {
                    "type": "string",
                    "description": "Type of storage you want to attach to your AWS-provisioned cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "instanceSize": {
                    "type": "string",
                    "description": "Hardware specification for the instance sizes in this region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "Number of read-only nodes for Atlas to deploy to the region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "instanceSize"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecs:getAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecs": {
            "properties": {
                "diskIops": {
                    "type": "integer",
                    "description": "Target throughput (IOPS) desired for AWS storage attached to your cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ebsVolumeType": {
                    "type": "string",
                    "description": "Type of storage you want to attach to your AWS-provisioned cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "instanceSize": {
                    "type": "string",
                    "description": "Hardware specification for the instance sizes in this region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "Number of read-only nodes for Atlas to deploy to the region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "instanceSize"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAlertConfigurationMatcher:getAlertConfigurationMatcher": {
            "properties": {
                "fieldName": {
                    "type": "string",
                    "description": "Name of the field in the target object to match on.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "operator": {
                    "type": "string",
                    "description": "Operator to apply when checking the current metric value against the threshold value.\nAccepted values are:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "fieldName",
                "operator",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAlertConfigurationMetricThresholdConfig:getAlertConfigurationMetricThresholdConfig": {
            "properties": {
                "metricName": {
                    "type": "string",
                    "description": "Name of the metric to check. The full list being quite large, please refer to atlas docs [here for general metrics](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types) and [here for serverless metrics](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-create-config/#serverless-measurements)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mode": {
                    "type": "string",
                    "description": "This must be set to AVERAGE. Atlas computes the current metric value as an average.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "operator": {
                    "type": "string",
                    "description": "Operator to apply when checking the current metric value against the threshold value.\nAccepted values are:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "threshold": {
                    "type": "number",
                    "description": "Threshold value outside of which an alert will be triggered.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "units": {
                    "type": "string",
                    "description": "The units for the threshold value. Depends on the type of metric.\nRefer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "metricName",
                "mode",
                "operator",
                "threshold",
                "units"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAlertConfigurationNotification:getAlertConfigurationNotification": {
            "properties": {
                "apiToken": {
                    "type": "string",
                    "description": "Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "channelName": {
                    "type": "string",
                    "description": "Slack channel name. Required for the SLACK notifications type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datadogApiKey": {
                    "type": "string",
                    "description": "Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "datadogRegion": {
                    "type": "string",
                    "description": "Region that indicates which API URL to use. Accepted regions are: `US`, `EU`. The default Datadog region is US.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "delayMin": {
                    "type": "integer",
                    "description": "Number of minutes to wait after an alert condition is detected before sending out the first notification.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailAddress": {
                    "type": "string",
                    "description": "Email address to which alert notifications are sent. Required for the EMAIL notifications type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailEnabled": {
                    "type": "boolean",
                    "description": "Flag indicating email notifications should be sent. Atlas returns this value if `type_name` is set  to `ORG`, `GROUP`, or `USER`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "flowName": {
                    "type": "string",
                    "description": "Flowdock flow name in lower-case letters. Required for the `FLOWDOCK` notifications type\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "flowdockApiToken": {
                    "type": "string",
                    "description": "The Flowdock personal API token. Required for the `FLOWDOCK` notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "intervalMin": {
                    "type": "integer",
                    "description": "Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "microsoftTeamsWebhookUrl": {
                    "type": "string",
                    "description": "Microsoft Teams channel incoming webhook URL. Required for the `MICROSOFT_TEAMS` notifications type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "mobileNumber": {
                    "type": "string",
                    "description": "Mobile number to which alert notifications are sent. Required for the SMS notifications type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "opsGenieApiKey": {
                    "type": "string",
                    "description": "Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "opsGenieRegion": {
                    "type": "string",
                    "description": "Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "orgName": {
                    "type": "string",
                    "description": "Flowdock organization name in lower-case letters. This is the name that appears after www.flowdock.com/app/ in the URL string. Required for the FLOWDOCK notifications type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Atlas role in current Project or Organization. Atlas returns this value if you set `type_name` to `ORG` or `GROUP`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serviceKey": {
                    "type": "string",
                    "description": "PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "smsEnabled": {
                    "type": "boolean",
                    "description": "Flag indicating text notifications should be sent. Atlas returns this value if `type_name` is set to `ORG`, `GROUP`, or `USER`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "teamId": {
                    "type": "string",
                    "description": "Unique identifier of a team.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "teamName": {
                    "type": "string",
                    "description": "Label for the team that receives this notification.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "typeName": {
                    "type": "string",
                    "description": "Type of alert notification.\nAccepted values are:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "victorOpsApiKey": {
                    "type": "string",
                    "description": "VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "victorOpsRoutingKey": {
                    "type": "string",
                    "description": "VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "webhookSecret": {
                    "type": "string",
                    "description": "Authentication secret for the `WEBHOOK` notifications type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "webhookUrl": {
                    "type": "string",
                    "description": "Target URL  for the `WEBHOOK` notifications type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "apiToken",
                "channelName",
                "datadogApiKey",
                "datadogRegion",
                "delayMin",
                "emailAddress",
                "emailEnabled",
                "flowName",
                "flowdockApiToken",
                "intervalMin",
                "mobileNumber",
                "opsGenieApiKey",
                "opsGenieRegion",
                "orgName",
                "serviceKey",
                "smsEnabled",
                "teamId",
                "teamName",
                "typeName",
                "username",
                "victorOpsApiKey",
                "victorOpsRoutingKey"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAlertConfigurationOutput:getAlertConfigurationOutput": {
            "properties": {
                "label": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "type",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": [
                        "type"
                    ]
                }
            }
        },
        "mongodbatlas:index/getAlertConfigurationThresholdConfig:getAlertConfigurationThresholdConfig": {
            "properties": {
                "operator": {
                    "type": "string",
                    "description": "Operator to apply when checking the current metric value against the threshold value.\nAccepted values are:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "threshold": {
                    "type": "number",
                    "description": "Threshold value outside of which an alert will be triggered.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "units": {
                    "type": "string",
                    "description": "The units for the threshold value. Depends on the type of metric.\nRefer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "operator",
                "threshold",
                "units"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAlertConfigurationsListOption:getAlertConfigurationsListOption": {
            "properties": {
                "includeCount": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "itemsPerPage": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pageNum": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/getAlertConfigurationsResult:getAlertConfigurationsResult": {
            "properties": {
                "alertConfigurationId": {
                    "type": "string",
                    "description": "The ID of the alert configuration\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "created": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when this alert configuration was created.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enabled": {
                    "type": "boolean",
                    "description": "If set to true, the alert configuration is enabled. If enabled is not exported it is set to false.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "eventType": {
                    "type": "string",
                    "description": "The type of event that will trigger an alert.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "matchers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAlertConfigurationsResultMatcher:getAlertConfigurationsResultMatcher"
                    },
                    "description": "Rules to apply when matching an object against this alert configuration\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "metricThreshold": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "metricThresholdConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAlertConfigurationsResultMetricThresholdConfig:getAlertConfigurationsResultMetricThresholdConfig"
                    },
                    "description": "The threshold that causes an alert to be triggered. Required if `event_type_name` : `OUTSIDE_METRIC_THRESHOLD` or `OUTSIDE_SERVERLESS_METRIC_THRESHOLD`\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "notifications": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAlertConfigurationsResultNotification:getAlertConfigurationsResultNotification"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "outputs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAlertConfigurationsResultOutput:getAlertConfigurationsResultOutput"
                    },
                    "description": "Requested output string format for the alert configuration\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to get the alert configurations.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "threshold": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "thresholdConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAlertConfigurationsResultThresholdConfig:getAlertConfigurationsResultThresholdConfig"
                    },
                    "description": "Threshold that triggers an alert. Required if `event_type_name` is any value other than `OUTSIDE_METRIC_THRESHOLD` or `OUTSIDE_SERVERLESS_METRIC_THRESHOLD`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "updated": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when this alert configuration was last updated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "alertConfigurationId",
                "created",
                "enabled",
                "eventType",
                "matchers",
                "metricThreshold",
                "metricThresholdConfigs",
                "notifications",
                "projectId",
                "threshold",
                "thresholdConfigs",
                "updated"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAlertConfigurationsResultMatcher:getAlertConfigurationsResultMatcher": {
            "properties": {
                "fieldName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "operator": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "fieldName",
                "operator",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAlertConfigurationsResultMetricThresholdConfig:getAlertConfigurationsResultMetricThresholdConfig": {
            "properties": {
                "metricName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mode": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "operator": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "threshold": {
                    "type": "number",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "units": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "metricName",
                "mode",
                "operator",
                "threshold",
                "units"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAlertConfigurationsResultNotification:getAlertConfigurationsResultNotification": {
            "properties": {
                "apiToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "channelName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "datadogApiKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "datadogRegion": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "delayMin": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailAddress": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "emailEnabled": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "flowName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "flowdockApiToken": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "intervalMin": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "microsoftTeamsWebhookUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "mobileNumber": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "opsGenieApiKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "opsGenieRegion": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "orgName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serviceKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "smsEnabled": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "teamId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "teamName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "typeName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "victorOpsApiKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "victorOpsRoutingKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "webhookSecret": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "webhookUrl": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "apiToken",
                "channelName",
                "datadogApiKey",
                "datadogRegion",
                "delayMin",
                "emailAddress",
                "emailEnabled",
                "flowName",
                "flowdockApiToken",
                "intervalMin",
                "mobileNumber",
                "opsGenieApiKey",
                "opsGenieRegion",
                "orgName",
                "serviceKey",
                "smsEnabled",
                "teamId",
                "teamName",
                "typeName",
                "username",
                "victorOpsApiKey",
                "victorOpsRoutingKey"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAlertConfigurationsResultOutput:getAlertConfigurationsResultOutput": {
            "properties": {
                "label": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "type",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAlertConfigurationsResultThresholdConfig:getAlertConfigurationsResultThresholdConfig": {
            "properties": {
                "operator": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "threshold": {
                    "type": "number",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "units": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "operator",
                "threshold",
                "units"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getApiKeysResult:getApiKeysResult": {
            "properties": {
                "apiKeyId": {
                    "type": "string",
                    "description": "Unique identifier for the API key you want to update. Use the /orgs/{ORG-ID}/apiKeys endpoint to retrieve all API keys to which the authenticated user has access for the specified organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "description": "Description of this Organization API key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "publicKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Name of the role. This resource returns all the roles the user has in Atlas.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "apiKeyId",
                "description",
                "publicKey",
                "roleNames"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupScheduleCopySetting:getCloudBackupScheduleCopySetting": {
            "properties": {
                "cloudProvider": {
                    "type": "string",
                    "description": "Human-readable label that identifies the cloud provider that stores the snapshot copy. i.e. \"AWS\" \"AZURE\" \"GCP\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "frequencies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List that describes which types of snapshots to copy. i.e. \"HOURLY\" \"DAILY\" \"WEEKLY\" \"MONTHLY\" \"ON_DEMAND\"\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "regionName": {
                    "type": "string",
                    "description": "Target region to copy snapshots belonging to replicationSpecId to. Please supply the 'Atlas Region' which can be found under https://www.mongodb.com/docs/atlas/reference/cloud-providers/ 'regions' link\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "replicationSpecId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the replication object for a zone in a cluster. For global clusters, there can be multiple zones to choose from. For sharded clusters and replica set clusters, there is only one zone in the cluster. To find the Replication Spec Id, do a GET request to Return One Cluster in One Project and consult the replicationSpecs array https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#operation/returnOneCluster\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "shouldCopyOplogs": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to copy the oplogs to the target region. You can use the oplogs to perform point-in-time restores.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "cloudProvider",
                "frequencies",
                "regionName",
                "replicationSpecId",
                "shouldCopyOplogs"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupScheduleExport:getCloudBackupScheduleExport": {
            "properties": {
                "exportBucketId": {
                    "type": "string",
                    "description": "Unique identifier of the mongodbatlas.CloudBackupSnapshotExportBucket export_bucket_id value.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "exportBucketId",
                "frequencyType"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSchedulePolicyItemDaily:getCloudBackupSchedulePolicyItemDaily": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, or `months`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "frequencyType",
                "id",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSchedulePolicyItemHourly:getCloudBackupSchedulePolicyItemHourly": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, or `months`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "frequencyType",
                "id",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSchedulePolicyItemMonthly:getCloudBackupSchedulePolicyItemMonthly": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, or `months`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "frequencyType",
                "id",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSchedulePolicyItemWeekly:getCloudBackupSchedulePolicyItemWeekly": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, or `months`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "frequencyType",
                "id",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotExportBucketsResult:getCloudBackupSnapshotExportBucketsResult": {
            "properties": {
                "bucketName": {
                    "type": "string",
                    "description": "Name of the bucket that the provided role ID is authorized to access. You must also specify the `iam_role_id`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "cloudProvider": {
                    "type": "string",
                    "description": "Name of the provider of the cloud service where Atlas can access the S3 bucket. Atlas only supports `AWS`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "exportBucketId": {
                    "type": "string",
                    "description": "Unique identifier of the snapshot bucket id.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "iamRoleId": {
                    "type": "string",
                    "description": "Unique identifier of the role that Atlas can use to access the bucket. You must also specify the `bucket_name`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "bucketName",
                "cloudProvider",
                "exportBucketId",
                "iamRoleId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotExportJobComponent:getCloudBackupSnapshotExportJobComponent": {
            "properties": {
                "exportId": {
                    "type": "string",
                    "description": "_Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "replicaSetName": {
                    "type": "string",
                    "description": "_Returned for sharded clusters only._ Unique identifier of the export job for the replica set.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "exportId",
                "replicaSetName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotExportJobCustomData:getCloudBackupSnapshotExportJobCustomData": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "Custom data specified as key in the key and value pair.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "Value for the key specified using `key`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotExportJobsResult:getCloudBackupSnapshotExportJobsResult": {
            "properties": {
                "components": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getCloudBackupSnapshotExportJobsResultComponent:getCloudBackupSnapshotExportJobsResultComponent"
                    },
                    "description": "_Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "createdAt": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when the export job was created.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "customDatas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getCloudBackupSnapshotExportJobsResultCustomData:getCloudBackupSnapshotExportJobsResultCustomData"
                    },
                    "description": "Custom data to include in the metadata file named `.complete` that Atlas uploads to the bucket when the export job finishes. Custom data can be specified as key and value pairs.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "errMsg": {
                    "type": "string",
                    "description": "Error message, only if the export job failed.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "exportBucketId": {
                    "type": "string",
                    "description": "Unique identifier of the AWS bucket to export the Cloud Backup snapshot to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "exportJobId": {
                    "type": "string",
                    "description": "Unique identifier of the export job.\n* `prefix ` - Full path on the cloud provider bucket to the folder where the snapshot is exported. The path is in the following format:`/exported_snapshots/{ORG-NAME}/{PROJECT-NAME}/{CLUSTER-NAME}/{SNAPSHOT-INITIATION-DATE}/{TIMESTAMP}`\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "exportStatusExportedCollections": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "exportStatusTotalCollections": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "finishedAt": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when the export job completes.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "prefix": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "snapshotId": {
                    "type": "string",
                    "description": "Unique identifier of the Cloud Backup snapshot to export.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "state": {
                    "type": "string",
                    "description": "Status of the export job. Value can be one of the following:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "components",
                "createdAt",
                "customDatas",
                "errMsg",
                "exportBucketId",
                "exportJobId",
                "exportStatusExportedCollections",
                "exportStatusTotalCollections",
                "finishedAt",
                "prefix",
                "snapshotId",
                "state"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotExportJobsResultComponent:getCloudBackupSnapshotExportJobsResultComponent": {
            "properties": {
                "exportId": {
                    "type": "string",
                    "description": "_Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "replicaSetName": {
                    "type": "string",
                    "description": "_Returned for sharded clusters only._ Unique identifier of the export job for the replica set.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "exportId",
                "replicaSetName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotExportJobsResultCustomData:getCloudBackupSnapshotExportJobsResultCustomData": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "Custom data specified as key in the key and value pair.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "Value for the key specified using `key`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotMember:getCloudBackupSnapshotMember": {
            "properties": {
                "cloudProvider": {
                    "type": "string",
                    "description": "Cloud provider that stores this snapshot.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier for the sharded cluster snapshot.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "replicaSetName": {
                    "type": "string",
                    "description": "Label given to a shard or config server from which Atlas took this snapshot.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "cloudProvider",
                "id",
                "replicaSetName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotRestoreJobsResult:getCloudBackupSnapshotRestoreJobsResult": {
            "properties": {
                "cancelled": {
                    "type": "boolean",
                    "description": "Indicates whether the restore job was canceled.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "createdAt": {
                    "type": "string",
                    "description": "UTC ISO 8601 formatted point in time when Atlas created the restore job.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "deliveryType": {
                    "type": "string",
                    "description": "Type of restore job to create. Possible values are: automated and download.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "deliveryUrls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "One or more URLs for the compressed snapshot files for manual download. Only visible if deliveryType is download.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "expired": {
                    "type": "boolean",
                    "description": "Indicates whether the restore job expired.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "expiresAt": {
                    "type": "string",
                    "description": "UTC ISO 8601 formatted point in time when the restore job expires.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "finishedAt": {
                    "type": "string",
                    "description": "UTC ISO 8601 formatted point in time when the restore job completed.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "The unique identifier of the restore job.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oplogInc": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oplogTs": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pointInTimeUtcSeconds": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "snapshotId": {
                    "type": "string",
                    "description": "Unique identifier of the source snapshot ID of the restore job.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "targetClusterName": {
                    "type": "string",
                    "description": "Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "targetProjectId": {
                    "type": "string",
                    "description": "Name of the target Atlas project of the restore job. Only visible if deliveryType is automated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "timestamp": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when the snapshot associated to snapshotId was taken.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "cancelled",
                "createdAt",
                "deliveryType",
                "deliveryUrls",
                "expired",
                "expiresAt",
                "finishedAt",
                "id",
                "oplogInc",
                "oplogTs",
                "pointInTimeUtcSeconds",
                "snapshotId",
                "targetClusterName",
                "targetProjectId",
                "timestamp"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotsResult:getCloudBackupSnapshotsResult": {
            "properties": {
                "cloudProvider": {
                    "type": "string",
                    "description": "Cloud provider that stores this snapshot.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "createdAt": {
                    "type": "string",
                    "description": "UTC ISO 8601 formatted point in time when Atlas took the snapshot.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "description": "UDescription of the snapshot. Only present for on-demand snapshots.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "expiresAt": {
                    "type": "string",
                    "description": "UTC ISO 8601 formatted point in time when Atlas will delete the snapshot.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier for the sharded cluster snapshot.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "masterKeyUuid": {
                    "type": "string",
                    "description": "Unique ID of the AWS KMS Customer Master Key used to encrypt the snapshot. Only visible for clusters using Encryption at Rest via Customer KMS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "members": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getCloudBackupSnapshotsResultMember:getCloudBackupSnapshotsResultMember"
                    },
                    "description": "Block of List of snapshots and the cloud provider where the snapshots are stored. See below\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mongodVersion": {
                    "type": "string",
                    "description": "Version of the MongoDB server.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "replicaSetName": {
                    "type": "string",
                    "description": "Label given to a shard or config server from which Atlas took this snapshot.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "snapshotIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Unique identifiers of the snapshots created for the shards and config server for a sharded cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "snapshotType": {
                    "type": "string",
                    "description": "Specified the type of snapshot. Valid values are onDemand and scheduled.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "description": "Current status of the snapshot. One of the following values: queued, inProgress, completed, failed.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "storageSizeBytes": {
                    "type": "integer",
                    "description": "Specifies the size of the snapshot in bytes.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "Specifies the type of cluster: replicaSet or shardedCluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "cloudProvider",
                "createdAt",
                "description",
                "expiresAt",
                "id",
                "masterKeyUuid",
                "members",
                "mongodVersion",
                "replicaSetName",
                "snapshotIds",
                "snapshotType",
                "status",
                "storageSizeBytes",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotsResultMember:getCloudBackupSnapshotsResultMember": {
            "properties": {
                "cloudProvider": {
                    "type": "string",
                    "description": "Cloud provider that stores this snapshot.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier for the sharded cluster snapshot.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "replicaSetName": {
                    "type": "string",
                    "description": "Label given to a shard or config server from which Atlas took this snapshot.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "cloudProvider",
                "id",
                "replicaSetName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudProviderAccessAwsIamRole:getCloudProviderAccessAwsIamRole": {
            "properties": {
                "atlasAssumedRoleExternalId": {
                    "type": "string",
                    "description": "Unique external ID Atlas uses when assuming the IAM role in your AWS account.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "atlasAwsAccountArn": {
                    "type": "string",
                    "description": "ARN associated with the Atlas AWS account used to assume IAM roles in your AWS account.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "authorizedDate": {
                    "type": "string",
                    "description": "Date on which this role was authorized.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "createdDate": {
                    "type": "string",
                    "description": "Date on which this role was created.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "featureUsages": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getCloudProviderAccessAwsIamRoleFeatureUsage:getCloudProviderAccessAwsIamRoleFeatureUsage"
                    },
                    "description": "Atlas features this AWS IAM role is linked to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "iamAssumedRoleArn": {
                    "type": "string",
                    "description": "ARN of the IAM Role that Atlas assumes when accessing resources in your AWS account.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerName": {
                    "type": "string",
                    "description": "Name of the cloud provider. Currently limited to AWS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleId": {
                    "type": "string",
                    "description": "Unique ID of this role.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "atlasAssumedRoleExternalId",
                "atlasAwsAccountArn",
                "authorizedDate",
                "createdDate",
                "featureUsages",
                "iamAssumedRoleArn",
                "providerName",
                "roleId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudProviderAccessAwsIamRoleFeatureUsage:getCloudProviderAccessAwsIamRoleFeatureUsage": {
            "properties": {
                "featureId": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "featureType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "featureId",
                "featureType"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudProviderAccessSetupAwsConfig:getCloudProviderAccessSetupAwsConfig": {
            "properties": {
                "atlasAssumedRoleExternalId": {
                    "type": "string",
                    "description": "Unique external ID Atlas uses when assuming the IAM role in your AWS account.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "atlasAwsAccountArn": {
                    "type": "string",
                    "description": "ARN associated with the Atlas AWS account used to assume IAM roles in your AWS account.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "atlasAssumedRoleExternalId",
                "atlasAwsAccountArn"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudProviderSnapshotBackupPolicyPolicy:getCloudProviderSnapshotBackupPolicyPolicy": {
            "properties": {
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policyItems": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getCloudProviderSnapshotBackupPolicyPolicyPolicyItem:getCloudProviderSnapshotBackupPolicyPolicyPolicyItem"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "id",
                "policyItems"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudProviderSnapshotBackupPolicyPolicyPolicyItem:getCloudProviderSnapshotBackupPolicyPolicyPolicyItem": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "frequencyType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "retentionUnit": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "retentionValue": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "frequencyType",
                "id",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudProviderSnapshotRestoreJobsResult:getCloudProviderSnapshotRestoreJobsResult": {
            "properties": {
                "cancelled": {
                    "type": "boolean",
                    "description": "Indicates whether the restore job was canceled.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "createdAt": {
                    "type": "string",
                    "description": "UTC ISO 8601 formatted point in time when Atlas created the restore job.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "deliveryType": {
                    "type": "string",
                    "description": "Type of restore job to create. Possible values are: automated and download.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "deliveryUrls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "One or more URLs for the compressed snapshot files for manual download. Only visible if deliveryType is download.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "expired": {
                    "type": "boolean",
                    "description": "Indicates whether the restore job expired.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "expiresAt": {
                    "type": "string",
                    "description": "UTC ISO 8601 formatted point in time when the restore job expires.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "finishedAt": {
                    "type": "string",
                    "description": "UTC ISO 8601 formatted point in time when the restore job completed.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "The unique identifier of the restore job.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oplogInc": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oplogTs": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pointInTimeUtcSeconds": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "snapshotId": {
                    "type": "string",
                    "description": "Unique identifier of the source snapshot ID of the restore job.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "targetClusterName": {
                    "type": "string",
                    "description": "Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "targetProjectId": {
                    "type": "string",
                    "description": "Name of the target Atlas project of the restore job. Only visible if deliveryType is automated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "timestamp": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when the snapshot associated to snapshotId was taken.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "cancelled",
                "createdAt",
                "deliveryType",
                "deliveryUrls",
                "expired",
                "expiresAt",
                "finishedAt",
                "id",
                "oplogInc",
                "oplogTs",
                "pointInTimeUtcSeconds",
                "snapshotId",
                "targetClusterName",
                "targetProjectId",
                "timestamp"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudProviderSnapshotsResult:getCloudProviderSnapshotsResult": {
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "UTC ISO 8601 formatted point in time when Atlas took the snapshot.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "description": "UDescription of the snapshot. Only present for on-demand snapshots.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "expiresAt": {
                    "type": "string",
                    "description": "UTC ISO 8601 formatted point in time when Atlas will delete the snapshot.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the snapshot.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "masterKeyUuid": {
                    "type": "string",
                    "description": "Unique ID of the AWS KMS Customer Master Key used to encrypt the snapshot. Only visible for clusters using Encryption at Rest via Customer KMS.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mongodVersion": {
                    "type": "string",
                    "description": "Version of the MongoDB server.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "snapshotType": {
                    "type": "string",
                    "description": "Specified the type of snapshot. Valid values are onDemand and scheduled.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "description": "Current status of the snapshot. One of the following values: queued, inProgress, completed, failed.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "storageSizeBytes": {
                    "type": "integer",
                    "description": "Specifies the size of the snapshot in bytes.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "Specifies the type of cluster: replicaSet or shardedCluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "createdAt",
                "description",
                "expiresAt",
                "id",
                "masterKeyUuid",
                "mongodVersion",
                "snapshotType",
                "status",
                "storageSizeBytes",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClusterAdvancedConfiguration:getClusterAdvancedConfiguration": {
            "properties": {
                "defaultReadConcern": {
                    "type": "string",
                    "description": "[Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "defaultWriteConcern": {
                    "type": "string",
                    "description": "[Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "failIndexKeyTooLong": {
                    "type": "boolean",
                    "description": "When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "javascriptEnabled": {
                    "type": "boolean",
                    "description": "When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minimumEnabledTlsProtocol": {
                    "type": "string",
                    "description": "Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "noTableScan": {
                    "type": "boolean",
                    "description": "When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oplogMinRetentionHours": {
                    "type": "integer",
                    "description": "Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oplogSizeMb": {
                    "type": "integer",
                    "description": "The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sampleRefreshIntervalBiConnector": {
                    "type": "integer",
                    "description": "Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sampleSizeBiConnector": {
                    "type": "integer",
                    "description": "Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "defaultReadConcern",
                "defaultWriteConcern",
                "failIndexKeyTooLong",
                "javascriptEnabled",
                "minimumEnabledTlsProtocol",
                "noTableScan",
                "oplogMinRetentionHours",
                "oplogSizeMb",
                "sampleRefreshIntervalBiConnector",
                "sampleSizeBiConnector"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClusterBiConnectorConfig:getClusterBiConnectorConfig": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Indicates whether or not BI Connector for Atlas is enabled on the cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readPreference": {
                    "type": "string",
                    "description": "Indicates the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "enabled",
                "readPreference"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClusterConnectionString:getClusterConnectionString": {
            "properties": {
                "awsPrivateLink": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "awsPrivateLinkSrv": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "private": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privateEndpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClusterConnectionStringPrivateEndpoint:getClusterConnectionStringPrivateEndpoint"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privateSrv": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "standard": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "standardSrv": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "awsPrivateLink",
                "awsPrivateLinkSrv",
                "private",
                "privateEndpoints",
                "privateSrv",
                "standard",
                "standardSrv"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClusterConnectionStringPrivateEndpoint:getClusterConnectionStringPrivateEndpoint": {
            "properties": {
                "connectionString": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClusterConnectionStringPrivateEndpointEndpoint:getClusterConnectionStringPrivateEndpointEndpoint"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "srvConnectionString": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "connectionString",
                "endpoints",
                "srvConnectionString",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClusterConnectionStringPrivateEndpointEndpoint:getClusterConnectionStringPrivateEndpointEndpoint": {
            "properties": {
                "endpointId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerName": {
                    "type": "string",
                    "description": "Indicates the cloud service provider on which the servers are provisioned.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "endpointId",
                "providerName",
                "region"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClusterLabel:getClusterLabel": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key that was set.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "The value that represents the key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClusterReplicationSpec:getClusterReplicationSpec": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "Unique identifer of the replication document for a zone in a Global Cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "numShards": {
                    "type": "integer",
                    "description": "Number of shards to deploy in the specified zone.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "regionsConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClusterReplicationSpecRegionsConfig:getClusterReplicationSpecRegionsConfig"
                    },
                    "description": "Describes the physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "zoneName": {
                    "type": "string",
                    "description": "Indicates the n ame for the zone in a Global Cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "id",
                "numShards",
                "regionsConfigs",
                "zoneName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClusterReplicationSpecRegionsConfig:getClusterReplicationSpecRegionsConfig": {
            "properties": {
                "analyticsNodes": {
                    "type": "integer",
                    "description": "Indicates the number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "electableNodes": {
                    "type": "integer",
                    "description": "Number of electable nodes for Atlas to deploy to the region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "priority": {
                    "type": "integer",
                    "description": "Election priority of the region. For regions with only read-only nodes, set this value to 0.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readOnlyNodes": {
                    "type": "integer",
                    "description": "Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "regionName": {
                    "type": "string",
                    "description": "Name for the region specified.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "analyticsNodes",
                "electableNodes",
                "priority",
                "readOnlyNodes",
                "regionName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClusterSnapshotBackupPolicy:getClusterSnapshotBackupPolicy": {
            "properties": {
                "clusterId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clusterName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nextSnapshot": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClusterSnapshotBackupPolicyPolicy:getClusterSnapshotBackupPolicyPolicy"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "referenceHourOfDay": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "referenceMinuteOfHour": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "restoreWindowDays": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "updateSnapshots": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "clusterId",
                "clusterName",
                "nextSnapshot",
                "policies",
                "referenceHourOfDay",
                "referenceMinuteOfHour",
                "restoreWindowDays",
                "updateSnapshots"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClusterSnapshotBackupPolicyPolicy:getClusterSnapshotBackupPolicyPolicy": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "Unique identifer of the replication document for a zone in a Global Cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policyItems": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClusterSnapshotBackupPolicyPolicyPolicyItem:getClusterSnapshotBackupPolicyPolicyPolicyItem"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "id",
                "policyItems"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClusterSnapshotBackupPolicyPolicyPolicyItem:getClusterSnapshotBackupPolicyPolicyPolicyItem": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "frequencyType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifer of the replication document for a zone in a Global Cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "retentionUnit": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "retentionValue": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "frequencyType",
                "id",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClustersResult:getClustersResult": {
            "properties": {
                "advancedConfigurations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClustersResultAdvancedConfiguration:getClustersResultAdvancedConfiguration"
                    },
                    "description": "Get the advanced configuration options. See Advanced Configuration below for more details.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "autoScalingComputeEnabled": {
                    "type": "boolean",
                    "description": "Specifies whether cluster tier auto-scaling is enabled. The default is false.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "autoScalingComputeScaleDownEnabled": {
                    "type": "boolean",
                    "description": "* `auto_scaling_compute_scale_down_enabled` - Specifies whether cluster tier auto-down-scaling is enabled.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "autoScalingDiskGbEnabled": {
                    "type": "boolean",
                    "description": "Indicates whether disk auto-scaling is enabled.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "backingProviderName": {
                    "type": "string",
                    "description": "Indicates Cloud service provider on which the server for a multi-tenant cluster is provisioned.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "backupEnabled": {
                    "type": "boolean",
                    "description": "Legacy Option, Indicates whether Atlas continuous backups are enabled for the cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "biConnector": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Indicates BI Connector for Atlas configuration on this cluster. BI Connector for Atlas is only available for M10+ clusters. See BI Connector below for more details. **DEPRECATED** Use `bi_connector_config` instead.\n",
                    "deprecationMessage": "use bi_connector_config instead",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "biConnectorConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClustersResultBiConnectorConfig:getClustersResultBiConnectorConfig"
                    },
                    "description": "Indicates BI Connector for Atlas configuration on this cluster. BI Connector for Atlas is only available for M10+ clusters. See BI Connector below for more details.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clusterType": {
                    "type": "string",
                    "description": "Indicates the type of the cluster that you want to modify. You cannot convert a sharded cluster deployment to a replica set deployment.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectionStrings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClustersResultConnectionString:getClustersResultConnectionString"
                    },
                    "description": "Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.\n- `connection_strings.standard` -   Public mongodb:// connection string for this cluster.\n- `connection_strings.standard_srv` - Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t, use connectionStrings.standard.\n- `connection_strings.aws_private_link` -  [Private-endpoint-aware](https://docs.atlas.mongodb.com/security-private-endpoint/#private-endpoint-connection-strings) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a AWS PrivateLink connection to this cluster. **DEPRECATED** Use `connection_strings.private_endpoint[n].connection_string` instead.\n- `connection_strings.aws_private_link_srv` - [Private-endpoint-aware](https://docs.atlas.mongodb.com/security-private-endpoint/#private-endpoint-connection-strings) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a AWS PrivateLink connection to this cluster. Use this URI format if your driver supports it. If it doesn’t, use connectionStrings.awsPrivateLink. **DEPRECATED** `connection_strings.private_endpoint[n].srv_connection_string` instead.\n- `connection_strings.private` -   [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.\n- `connection_strings.private_srv` -  [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.\n- `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.\n- `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint.\n- `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.\n- `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`\n- `connection_strings.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.\n- `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.\n- `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "containerId": {
                    "type": "string",
                    "description": "The Network Peering Container ID.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "diskSizeGb": {
                    "type": "number",
                    "description": "Indicates the size in gigabytes of the server’s root volume (AWS/GCP Only).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "encryptionAtRestProvider": {
                    "type": "string",
                    "description": "Indicates whether Encryption at Rest is enabled or disabled.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClustersResultLabel:getClustersResultLabel"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mongoDbMajorVersion": {
                    "type": "string",
                    "description": "Indicates the version of the cluster to deploy.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mongoDbVersion": {
                    "type": "string",
                    "description": "Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mongoUri": {
                    "type": "string",
                    "description": "Base connection string for the cluster. Atlas only displays this field after the cluster is operational, not while it builds the cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mongoUriUpdated": {
                    "type": "string",
                    "description": "Lists when the connection string was last updated. The connection string changes, for example, if you change a replica set to a sharded cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mongoUriWithOptions": {
                    "type": "string",
                    "description": "Describes connection string for connecting to the Atlas cluster. Includes the replicaSet, ssl, and authSource query parameters in the connection string with values appropriate for the cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of the current plugin\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "numShards": {
                    "type": "integer",
                    "description": "Number of shards to deploy in the specified zone.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "paused": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the cluster is paused or not.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pitEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates if the cluster uses Continuous Cloud Backup.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerAutoScalingComputeMaxInstanceSize": {
                    "type": "string",
                    "description": "Maximum instance size to which your cluster can automatically scale.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerAutoScalingComputeMinInstanceSize": {
                    "type": "string",
                    "description": "Minimum instance size to which your cluster can automatically scale.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerBackupEnabled": {
                    "type": "boolean",
                    "description": "Flag indicating if the cluster uses Cloud Backup Snapshots for backups. **DEPRECATED** Use `cloud_backup` instead.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerDiskIops": {
                    "type": "integer",
                    "description": "Indicates the maximum input/output operations per second (IOPS) the system can perform. The possible values depend on the selected providerSettings.instanceSizeName and diskSizeGB.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerDiskTypeName": {
                    "type": "string",
                    "description": "Describes Azure disk type of the server’s root volume (Azure Only).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerEncryptEbsVolume": {
                    "type": "boolean",
                    "description": "**(DEPRECATED)** Indicates whether the Amazon EBS encryption is enabled. This feature encrypts the server’s root volume for both data at rest within the volume and data moving between the volume and the instance. By default this attribute is always enabled, per deprecation process showing the real value at `provider_encrypt_ebs_volume_flag` computed attribute.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerInstanceSizeName": {
                    "type": "string",
                    "description": "Atlas provides different instance sizes, each with a default storage capacity and RAM size.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerName": {
                    "type": "string",
                    "description": "Indicates the cloud service provider on which the servers are provisioned.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerRegionName": {
                    "type": "string",
                    "description": "Indicates Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases. Requires the Atlas Region name, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerVolumeType": {
                    "type": "string",
                    "description": "Indicates the type of the volume. The possible values are: `STANDARD` and `PROVISIONED`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "replicationFactor": {
                    "type": "integer",
                    "description": "(Deprecated) Number of replica set members. Each member keeps a copy of your databases, providing high availability and data redundancy. The possible values are 3, 5, or 7. The default value is 3.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "replicationSpecs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClustersResultReplicationSpec:getClustersResultReplicationSpec"
                    },
                    "description": "Configuration for cluster regions.  See Replication Spec below for more details.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "snapshotBackupPolicies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClustersResultSnapshotBackupPolicy:getClustersResultSnapshotBackupPolicy"
                    },
                    "description": "current snapshot schedule and retention settings for the cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "srvAddress": {
                    "type": "string",
                    "description": "Connection string for connecting to the Atlas cluster. The +srv modifier forces the connection to use TLS/SSL. See the mongoURI for additional options.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "stateName": {
                    "type": "string",
                    "description": "Indicates the current state of the cluster. The possible states are:\n- IDLE\n- CREATING\n- UPDATING\n- DELETING\n- DELETED\n- REPAIRING\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "terminationProtectionEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "versionReleaseSystem": {
                    "type": "string",
                    "description": "Release cadence that Atlas uses for this cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "advancedConfigurations",
                "autoScalingComputeEnabled",
                "autoScalingComputeScaleDownEnabled",
                "autoScalingDiskGbEnabled",
                "backingProviderName",
                "backupEnabled",
                "biConnector",
                "biConnectorConfigs",
                "clusterType",
                "connectionStrings",
                "containerId",
                "diskSizeGb",
                "encryptionAtRestProvider",
                "labels",
                "mongoDbMajorVersion",
                "mongoDbVersion",
                "mongoUri",
                "mongoUriUpdated",
                "mongoUriWithOptions",
                "name",
                "numShards",
                "paused",
                "pitEnabled",
                "providerAutoScalingComputeMaxInstanceSize",
                "providerAutoScalingComputeMinInstanceSize",
                "providerBackupEnabled",
                "providerDiskIops",
                "providerDiskTypeName",
                "providerEncryptEbsVolume",
                "providerInstanceSizeName",
                "providerName",
                "providerRegionName",
                "providerVolumeType",
                "replicationFactor",
                "replicationSpecs",
                "snapshotBackupPolicies",
                "srvAddress",
                "stateName",
                "terminationProtectionEnabled",
                "versionReleaseSystem"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClustersResultAdvancedConfiguration:getClustersResultAdvancedConfiguration": {
            "properties": {
                "defaultReadConcern": {
                    "type": "string",
                    "description": "[Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "defaultWriteConcern": {
                    "type": "string",
                    "description": "[Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "failIndexKeyTooLong": {
                    "type": "boolean",
                    "description": "When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "javascriptEnabled": {
                    "type": "boolean",
                    "description": "When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "minimumEnabledTlsProtocol": {
                    "type": "string",
                    "description": "Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "noTableScan": {
                    "type": "boolean",
                    "description": "When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oplogMinRetentionHours": {
                    "type": "integer",
                    "description": "Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oplogSizeMb": {
                    "type": "integer",
                    "description": "The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sampleRefreshIntervalBiConnector": {
                    "type": "integer",
                    "description": "Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sampleSizeBiConnector": {
                    "type": "integer",
                    "description": "Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "defaultReadConcern",
                "defaultWriteConcern",
                "failIndexKeyTooLong",
                "javascriptEnabled",
                "minimumEnabledTlsProtocol",
                "noTableScan",
                "oplogMinRetentionHours",
                "oplogSizeMb",
                "sampleRefreshIntervalBiConnector",
                "sampleSizeBiConnector"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClustersResultBiConnectorConfig:getClustersResultBiConnectorConfig": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Indicates whether or not BI Connector for Atlas is enabled on the cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readPreference": {
                    "type": "string",
                    "description": "Indicates the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "enabled",
                "readPreference"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClustersResultConnectionString:getClustersResultConnectionString": {
            "properties": {
                "awsPrivateLink": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "awsPrivateLinkSrv": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "private": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privateEndpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClustersResultConnectionStringPrivateEndpoint:getClustersResultConnectionStringPrivateEndpoint"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privateSrv": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "standard": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "standardSrv": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "awsPrivateLink",
                "awsPrivateLinkSrv",
                "private",
                "privateEndpoints",
                "privateSrv",
                "standard",
                "standardSrv"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClustersResultConnectionStringPrivateEndpoint:getClustersResultConnectionStringPrivateEndpoint": {
            "properties": {
                "connectionString": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClustersResultConnectionStringPrivateEndpointEndpoint:getClustersResultConnectionStringPrivateEndpointEndpoint"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "srvConnectionString": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "connectionString",
                "endpoints",
                "srvConnectionString",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClustersResultConnectionStringPrivateEndpointEndpoint:getClustersResultConnectionStringPrivateEndpointEndpoint": {
            "properties": {
                "endpointId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerName": {
                    "type": "string",
                    "description": "Indicates the cloud service provider on which the servers are provisioned.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "endpointId",
                "providerName",
                "region"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClustersResultLabel:getClustersResultLabel": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key that was set.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "The value that represents the key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClustersResultReplicationSpec:getClustersResultReplicationSpec": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "Unique identifer of the replication document for a zone in a Global Cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "numShards": {
                    "type": "integer",
                    "description": "Number of shards to deploy in the specified zone.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "regionsConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClustersResultReplicationSpecRegionsConfig:getClustersResultReplicationSpecRegionsConfig"
                    },
                    "description": "Describes the physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "zoneName": {
                    "type": "string",
                    "description": "Indicates the n ame for the zone in a Global Cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "id",
                "numShards",
                "regionsConfigs",
                "zoneName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClustersResultReplicationSpecRegionsConfig:getClustersResultReplicationSpecRegionsConfig": {
            "properties": {
                "analyticsNodes": {
                    "type": "integer",
                    "description": "Indicates the number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "electableNodes": {
                    "type": "integer",
                    "description": "Number of electable nodes for Atlas to deploy to the region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "priority": {
                    "type": "integer",
                    "description": "Election priority of the region. For regions with only read-only nodes, set this value to 0.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readOnlyNodes": {
                    "type": "integer",
                    "description": "Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "regionName": {
                    "type": "string",
                    "description": "Name for the region specified.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "analyticsNodes",
                "electableNodes",
                "priority",
                "readOnlyNodes",
                "regionName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClustersResultSnapshotBackupPolicy:getClustersResultSnapshotBackupPolicy": {
            "properties": {
                "clusterId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clusterName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "nextSnapshot": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClustersResultSnapshotBackupPolicyPolicy:getClustersResultSnapshotBackupPolicyPolicy"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "referenceHourOfDay": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "referenceMinuteOfHour": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "restoreWindowDays": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "updateSnapshots": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "clusterId",
                "clusterName",
                "nextSnapshot",
                "policies",
                "referenceHourOfDay",
                "referenceMinuteOfHour",
                "restoreWindowDays",
                "updateSnapshots"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClustersResultSnapshotBackupPolicyPolicy:getClustersResultSnapshotBackupPolicyPolicy": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "Unique identifer of the replication document for a zone in a Global Cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "policyItems": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClustersResultSnapshotBackupPolicyPolicyPolicyItem:getClustersResultSnapshotBackupPolicyPolicyPolicyItem"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "id",
                "policyItems"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClustersResultSnapshotBackupPolicyPolicyPolicyItem:getClustersResultSnapshotBackupPolicyPolicyPolicyItem": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "frequencyType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifer of the replication document for a zone in a Global Cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "retentionUnit": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "retentionValue": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "frequencyType",
                "id",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCustomDbRoleAction:getCustomDbRoleAction": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "(Required) Name of the privilege action. For a complete list of actions available in the Atlas API, see Custom Role Actions.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "resources": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getCustomDbRoleActionResource:getCustomDbRoleActionResource"
                    },
                    "description": "(Required) Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "action",
                "resources"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCustomDbRoleActionResource:getCustomDbRoleActionResource": {
            "properties": {
                "cluster": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "collectionName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "databaseName": {
                    "type": "string",
                    "description": "(Required) Database on which the inherited role is granted.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "cluster",
                "collectionName",
                "databaseName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCustomDbRoleInheritedRole:getCustomDbRoleInheritedRole": {
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "(Required) Database on which the inherited role is granted.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleName": {
                    "type": "string",
                    "description": "Name of the custom role.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "databaseName",
                "roleName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCustomDbRolesResult:getCustomDbRolesResult": {
            "properties": {
                "actions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getCustomDbRolesResultAction:getCustomDbRolesResultAction"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "inheritedRoles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getCustomDbRolesResultInheritedRole:getCustomDbRolesResultInheritedRole"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleName": {
                    "type": "string",
                    "description": "(Required) Name of the inherited role. This can either be another custom role or a built-in role.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "actions",
                "inheritedRoles",
                "roleName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCustomDbRolesResultAction:getCustomDbRolesResultAction": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "(Required) Name of the privilege action. For a complete list of actions available in the Atlas API, see Custom Role Actions.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "resources": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getCustomDbRolesResultActionResource:getCustomDbRolesResultActionResource"
                    },
                    "description": "(Required) Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "action",
                "resources"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCustomDbRolesResultActionResource:getCustomDbRolesResultActionResource": {
            "properties": {
                "cluster": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "collectionName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "databaseName": {
                    "type": "string",
                    "description": "(Required) Database on which the inherited role is granted.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "cluster",
                "collectionName",
                "databaseName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCustomDbRolesResultInheritedRole:getCustomDbRolesResultInheritedRole": {
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "(Required) Database on which the inherited role is granted.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleName": {
                    "type": "string",
                    "description": "(Required) Name of the inherited role. This can either be another custom role or a built-in role.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "databaseName",
                "roleName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakeAw:getDataLakeAw": {
            "properties": {
                "externalId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "iamAssumedRoleArn": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "iamUserArn": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testS3Bucket": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "externalId",
                "iamAssumedRoleArn",
                "iamUserArn",
                "roleId",
                "testS3Bucket"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakeDataProcessRegion:getDataLakeDataProcessRegion": {
            "properties": {
                "cloudProvider": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "cloudProvider",
                "region"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakeStorageDatabase:getDataLakeStorageDatabase": {
            "properties": {
                "collections": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getDataLakeStorageDatabaseCollection:getDataLakeStorageDatabaseCollection"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxWildcardCollections": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of the data lake.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "views": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getDataLakeStorageDatabaseView:getDataLakeStorageDatabaseView"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "collections",
                "maxWildcardCollections",
                "name",
                "views"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakeStorageDatabaseCollection:getDataLakeStorageDatabaseCollection": {
            "properties": {
                "dataSources": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getDataLakeStorageDatabaseCollectionDataSource:getDataLakeStorageDatabaseCollectionDataSource"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of the data lake.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "dataSources",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakeStorageDatabaseCollectionDataSource:getDataLakeStorageDatabaseCollectionDataSource": {
            "properties": {
                "defaultFormat": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "storeName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "defaultFormat",
                "path",
                "storeName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakeStorageDatabaseView:getDataLakeStorageDatabaseView": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the data lake.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pipeline": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "source": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "pipeline",
                "source"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakeStorageStore:getDataLakeStorageStore": {
            "properties": {
                "additionalStorageClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bucket": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "delimiter": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "includeTags": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of the data lake.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "prefix": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "provider": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "additionalStorageClasses",
                "bucket",
                "delimiter",
                "includeTags",
                "name",
                "prefix",
                "provider",
                "region"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakesResult:getDataLakesResult": {
            "properties": {
                "aws": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getDataLakesResultAw:getDataLakesResultAw"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "dataProcessRegions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getDataLakesResultDataProcessRegion:getDataLakesResultDataProcessRegion"
                    },
                    "description": "The cloud provider region to which Atlas Data Lake routes client connections for data processing.\n* `data_process_region.0.cloud_provider` - Name of the cloud service provider.\n* `data_process_region.0.region` -Name of the region to which Data Lake routes client connections for data processing.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "hostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of hostnames assigned to the Atlas Data Lake. Each string in the array is a hostname assigned to the Atlas Data Lake.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to get all data lakes.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "state": {
                    "type": "string",
                    "description": "Current state of the Atlas Data Lake:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "storageDatabases": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getDataLakesResultStorageDatabase:getDataLakesResultStorageDatabase"
                    },
                    "description": "Configuration details for mapping each data store to queryable databases and collections.\n* `storage_databases.#.name` - Name of the database to which Data Lake maps the data contained in the data store.\n* `storage_databases.#.collections` -     Array of objects where each object represents a collection and data sources that map to a [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#mongodb-datalakeconf-datalakeconf.stores) data store.\n* `storage_databases.#.collections.#.name` - Name of the collection.\n* `storage_databases.#.collections.#.data_sources` -     Array of objects where each object represents a stores data store to map with the collection.\n* `storage_databases.#.collections.#.data_sources.#.store_name` -     Name of a data store to map to the `\u003ccollection\u003e`.\n* `storage_databases.#.collections.#.data_sources.#.default_format` - Default format that Data Lake assumes if it encounters a file without an extension while searching the storeName.\n* `storage_databases.#.collections.#.data_sources.#.path` - Controls how Atlas Data Lake searches for and parses files in the storeName before mapping them to the `\u003ccollection\u003e`.\n* `storage_databases.#.views` -     Array of objects where each object represents an [aggregation pipeline](https://docs.mongodb.com/manual/core/aggregation-pipeline/#id1) on a collection.\n* `storage_databases.#.views.#.name` - Name of the view.\n* `storage_databases.#.views.#.source` -  Name of the source collection for the view.\n* `storage_databases.#.views.#.pipeline`- Aggregation pipeline stage(s) to apply to the source collection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "storageStores": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getDataLakesResultStorageStore:getDataLakesResultStorageStore"
                    },
                    "description": "Each object in the array represents a data store. Data Lake uses the storage.databases configuration details to map data in each data store to queryable databases and collections.\n* `storage_stores.#.name` - Name of the data store.\n* `storage_stores.#.provider` - Defines where the data is stored.\n* `storage_stores.#.region` - Name of the AWS region in which the S3 bucket is hosted.\n* `storage_stores.#.bucket` - Name of the AWS S3 bucket.\n* `storage_stores.#.prefix` - Prefix Data Lake applies when searching for files in the S3 bucket .\n* `storage_stores.#.delimiter` - The delimiter that separates `storage_databases.#.collections.#.data_sources.#.path` segments in the data store.\n* `storage_stores.#.include_tags` - Determines whether or not to use S3 tags on the files in the given path as additional partition attributes.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "aws",
                "dataProcessRegions",
                "hostnames",
                "name",
                "projectId",
                "state",
                "storageDatabases",
                "storageStores"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakesResultAw:getDataLakesResultAw": {
            "properties": {
                "externalId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "iamAssumedRoleArn": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "iamUserArn": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "testS3Bucket": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "externalId",
                "iamAssumedRoleArn",
                "iamUserArn",
                "roleId",
                "testS3Bucket"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakesResultDataProcessRegion:getDataLakesResultDataProcessRegion": {
            "properties": {
                "cloudProvider": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "cloudProvider",
                "region"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakesResultStorageDatabase:getDataLakesResultStorageDatabase": {
            "properties": {
                "collections": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getDataLakesResultStorageDatabaseCollection:getDataLakesResultStorageDatabaseCollection"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "maxWildcardCollections": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "views": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getDataLakesResultStorageDatabaseView:getDataLakesResultStorageDatabaseView"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "collections",
                "maxWildcardCollections",
                "name",
                "views"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakesResultStorageDatabaseCollection:getDataLakesResultStorageDatabaseCollection": {
            "properties": {
                "dataSources": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getDataLakesResultStorageDatabaseCollectionDataSource:getDataLakesResultStorageDatabaseCollectionDataSource"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "dataSources",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakesResultStorageDatabaseCollectionDataSource:getDataLakesResultStorageDatabaseCollectionDataSource": {
            "properties": {
                "defaultFormat": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "path": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "storeName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "defaultFormat",
                "path",
                "storeName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakesResultStorageDatabaseView:getDataLakesResultStorageDatabaseView": {
            "properties": {
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pipeline": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "source": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "pipeline",
                "source"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakesResultStorageStore:getDataLakesResultStorageStore": {
            "properties": {
                "additionalStorageClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "bucket": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "delimiter": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "includeTags": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "prefix": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "provider": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "additionalStorageClasses",
                "bucket",
                "delimiter",
                "includeTags",
                "name",
                "prefix",
                "provider",
                "region"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDatabaseUserLabel:getDatabaseUserLabel": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key that you want to write.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "The value that you want to write.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDatabaseUserRole:getDatabaseUserRole": {
            "properties": {
                "collectionName": {
                    "type": "string",
                    "description": "Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "databaseName": {
                    "type": "string",
                    "description": "Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "collectionName",
                "databaseName",
                "roleName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDatabaseUserScope:getDatabaseUserScope": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the role to grant.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDatabaseUsersResult:getDatabaseUsersResult": {
            "properties": {
                "authDatabaseName": {
                    "type": "string",
                    "description": "(Required) Database against which Atlas authenticates the user. A user must provide both a username and authentication database to log into MongoDB.\nPossible values include:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "awsIamType": {
                    "type": "string",
                    "description": "The new database user authenticates with AWS IAM credentials. Default is `NONE`, `USER` means user has AWS IAM user credentials, `ROLE` - means user has credentials associated with an AWS IAM role.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getDatabaseUsersResultLabel:getDatabaseUsersResultLabel"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ldapAuthType": {
                    "type": "string",
                    "description": "Method by which the provided username is authenticated. Default is `NONE`. Other valid values are: `USER`, `GROUP`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to get all database users.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getDatabaseUsersResultRole:getDatabaseUsersResultRole"
                    },
                    "description": "List of user’s roles and the databases / collections on which the roles apply. A role allows the user to perform particular actions on the specified database. A role on the admin database can include privileges that apply to the other databases as well. See Roles below for more details.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getDatabaseUsersResultScope:getDatabaseUsersResultScope"
                    },
                    "description": "Array of clusters and Atlas Data Lakes that this user has access to.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "username": {
                    "type": "string",
                    "description": "Username for authenticating to MongoDB.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "x509Type": {
                    "type": "string",
                    "description": "X.509 method by which the provided username is authenticated.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "authDatabaseName",
                "awsIamType",
                "labels",
                "ldapAuthType",
                "projectId",
                "roles",
                "scopes",
                "username",
                "x509Type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDatabaseUsersResultLabel:getDatabaseUsersResultLabel": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key that you want to write.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "value": {
                    "type": "string",
                    "description": "The value that you want to write.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDatabaseUsersResultRole:getDatabaseUsersResultRole": {
            "properties": {
                "collectionName": {
                    "type": "string",
                    "description": "Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "databaseName": {
                    "type": "string",
                    "description": "Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "collectionName",
                "databaseName",
                "roleName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDatabaseUsersResultScope:getDatabaseUsersResultScope": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the role to grant.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "name",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getEventTriggerEventProcessor:getEventTriggerEventProcessor": {
            "properties": {
                "awsEventbridges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getEventTriggerEventProcessorAwsEventbridge:getEventTriggerEventProcessorAwsEventbridge"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "awsEventbridges"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getEventTriggerEventProcessorAwsEventbridge:getEventTriggerEventProcessorAwsEventbridge": {
            "properties": {
                "configAccountId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "configRegion": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "configAccountId",
                "configRegion"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getEventTriggersResult:getEventTriggersResult": {
            "properties": {
                "configCollection": {
                    "type": "string",
                    "description": "The name of the MongoDB collection that the trigger watches for change events.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "configDatabase": {
                    "type": "string",
                    "description": "The name of the MongoDB database that contains the watched collection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "configFullDocument": {
                    "type": "boolean",
                    "description": "If true, indicates that `UPDATE` change events should include the most current [majority-committed](https://docs.mongodb.com/manual/reference/read-concern-majority/) version of the modified document in the fullDocument field.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "configFullDocumentBefore": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "configMatch": {
                    "type": "string",
                    "description": "A [$match](https://docs.mongodb.com/manual/reference/operator/aggregation/match/) expression document that MongoDB Realm includes in the underlying change stream pipeline for the trigger.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "configOperationType": {
                    "type": "string",
                    "description": "The [authentication operation type](https://docs.mongodb.com/realm/triggers/authentication-triggers/#std-label-authentication-event-operation-types) to listen for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "configOperationTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The [database event operation types](https://docs.mongodb.com/realm/triggers/database-triggers/#std-label-database-events) to listen for.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "configProject": {
                    "type": "string",
                    "description": "A [$project](https://docs.mongodb.com/manual/reference/operator/aggregation/project/) expression document that Realm uses to filter the fields that appear in change event objects.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "configProviders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of one or more [authentication provider](https://docs.mongodb.com/realm/authentication/providers/) id values. The trigger will only listen for authentication events produced by these providers.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "configSchedule": {
                    "type": "string",
                    "description": "A [cron expression](https://docs.mongodb.com/realm/triggers/cron-expressions/) that defines the trigger schedule.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "configScheduleType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "configServiceId": {
                    "type": "string",
                    "description": "The ID of the MongoDB Service associated with the trigger.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "disabled": {
                    "type": "boolean",
                    "description": "Status of a trigger.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "eventProcessors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getEventTriggersResultEventProcessor:getEventTriggersResultEventProcessor"
                    },
                    "description": "An object where each field name is an event processor ID and each value is an object that configures its corresponding event processor.\n* `event_processors.0.aws_eventbridge.config_account_id` - AWS Account ID.\n* `event_processors.0.aws_eventbridge.config_region` - Region of AWS Account.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "functionId": {
                    "type": "string",
                    "description": "The ID of the function associated with the trigger.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "functionName": {
                    "type": "string",
                    "description": "The name of the function associated with the trigger.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of the trigger.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "triggerId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "The type of the trigger. Possible Values: `DATABASE`, `AUTHENTICATION`\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "unordered": {
                    "type": "boolean",
                    "description": "Sort order for `DATABASE` type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "configCollection",
                "configDatabase",
                "configFullDocument",
                "configFullDocumentBefore",
                "configMatch",
                "configOperationType",
                "configOperationTypes",
                "configProject",
                "configProviders",
                "configSchedule",
                "configScheduleType",
                "configServiceId",
                "disabled",
                "eventProcessors",
                "functionId",
                "functionName",
                "name",
                "triggerId",
                "type",
                "unordered"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getEventTriggersResultEventProcessor:getEventTriggersResultEventProcessor": {
            "properties": {
                "awsEventbridges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getEventTriggersResultEventProcessorAwsEventbridge:getEventTriggersResultEventProcessorAwsEventbridge"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "awsEventbridges"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getEventTriggersResultEventProcessorAwsEventbridge:getEventTriggersResultEventProcessorAwsEventbridge": {
            "properties": {
                "configAccountId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "configRegion": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "configAccountId",
                "configRegion"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProviderAssociatedOrg:getFederatedSettingsIdentityProviderAssociatedOrg": {
            "properties": {
                "domainAllowLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List that contains the approved domains from which organization users can log in.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "domainRestrictionEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether domain restriction is enabled for the connected organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "Unique 20-hexadecimal digit string that identifies the IdP.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "postAuthRoleGrants": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List that contains the default roles granted to users who authenticate through the IdP in a connected organization. If you provide a postAuthRoleGrants field in the request, the array that you provide replaces the current postAuthRoleGrants.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleMappings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsIdentityProviderAssociatedOrgRoleMapping:getFederatedSettingsIdentityProviderAssociatedOrgRoleMapping"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userConflicts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsIdentityProviderAssociatedOrgUserConflict:getFederatedSettingsIdentityProviderAssociatedOrgUserConflict"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "domainAllowLists",
                "domainRestrictionEnabled",
                "identityProviderId",
                "orgId",
                "postAuthRoleGrants",
                "roleMappings",
                "userConflicts"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProviderAssociatedOrgRoleMapping:getFederatedSettingsIdentityProviderAssociatedOrgRoleMapping": {
            "properties": {
                "externalGroupName": {
                    "type": "string",
                    "description": "Unique human-readable label that identifies the identity provider group to which this role mapping applies.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies this role mapping.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleAssignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignment:getFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignment"
                    },
                    "description": "Atlas roles and the unique identifiers of the groups and organizations associated with each role.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "externalGroupName",
                "id",
                "roleAssignments"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignment:getFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignment": {
            "properties": {
                "groupId": {
                    "type": "string",
                    "description": "Unique identifier of the project to which you want the role mapping to apply.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "role": {
                    "type": "string",
                    "description": "Specifies the Role that is attached to the Role Mapping.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "groupId",
                "orgId",
                "role"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProviderAssociatedOrgUserConflict:getFederatedSettingsIdentityProviderAssociatedOrgUserConflict": {
            "properties": {
                "emailAddress": {
                    "type": "string",
                    "description": "Email address of the the user that conflicts with selected domains.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "federationSettingsId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "firstName": {
                    "type": "string",
                    "description": "First name of the the user that conflicts with selected domains.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lastName": {
                    "type": "string",
                    "description": "Last name of the the user that conflicts with selected domains.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userId": {
                    "type": "string",
                    "description": "Name of the Atlas user that conflicts with selected domains.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "emailAddress",
                "federationSettingsId",
                "firstName",
                "lastName",
                "userId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProviderPemFileInfo:getFederatedSettingsIdentityProviderPemFileInfo": {
            "properties": {
                "certificates": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsIdentityProviderPemFileInfoCertificate:getFederatedSettingsIdentityProviderPemFileInfoCertificate"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fileName": {
                    "type": "string",
                    "description": "Filename of certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "certificates",
                "fileName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProviderPemFileInfoCertificate:getFederatedSettingsIdentityProviderPemFileInfoCertificate": {
            "properties": {
                "notAfter": {
                    "type": "string",
                    "description": "Expiration  Date.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "notBefore": {
                    "type": "string",
                    "description": "Start Date.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "notAfter",
                "notBefore"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProvidersResult:getFederatedSettingsIdentityProvidersResult": {
            "properties": {
                "acsUrl": {
                    "type": "string",
                    "description": "Assertion consumer service URL to which the IdP sends the SAML response.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "associatedDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List that contains the configured domains from which users can log in for this IdP.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "associatedOrgs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsIdentityProvidersResultAssociatedOrg:getFederatedSettingsIdentityProvidersResultAssociatedOrg"
                    },
                    "description": "List that contains the configured domains from which users can log in for this IdP.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "audienceUri": {
                    "type": "string",
                    "description": "Identifier for the intended audience of the SAML Assertion.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "displayName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the IdP.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "issuerUri": {
                    "type": "string",
                    "description": "Identifier for the issuer of the SAML Assertion.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "oktaIdpId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "pemFileInfos": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsIdentityProvidersResultPemFileInfo:getFederatedSettingsIdentityProvidersResultPemFileInfo"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "requestBinding": {
                    "type": "string",
                    "description": "SAML Authentication Request Protocol binding used to send the AuthNRequest. Atlas supports the following binding values:\n- HTTP POST\n- HTTP REDIRECT\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "responseSignatureAlgorithm": {
                    "type": "string",
                    "description": "Algorithm used to encrypt the IdP signature. Atlas supports the following signature algorithm values:\n- SHA-1\n- SHA-256\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ssoDebugEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the IdP has enabled Bypass SAML Mode. Enabling this mode generates a URL that allows you bypass SAML and login to your organizations at any point. You can authenticate with this special URL only when Bypass Mode is enabled. Set this parameter to true during testing. This keeps you from getting locked out of MongoDB.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ssoUrl": {
                    "type": "string",
                    "description": "URL of the receiver of the SAML AuthNRequest.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "description": "Label that indicates whether the identity provider is active. The IdP is Inactive until you map at least one domain to the IdP.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "acsUrl",
                "associatedDomains",
                "associatedOrgs",
                "audienceUri",
                "displayName",
                "issuerUri",
                "oktaIdpId",
                "pemFileInfos",
                "requestBinding",
                "responseSignatureAlgorithm",
                "ssoDebugEnabled",
                "ssoUrl",
                "status"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProvidersResultAssociatedOrg:getFederatedSettingsIdentityProvidersResultAssociatedOrg": {
            "properties": {
                "domainAllowLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List that contains the approved domains from which organization users can log in.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "domainRestrictionEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether domain restriction is enabled for the connected organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "postAuthRoleGrants": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List that contains the default roles granted to users who authenticate through the IdP in a connected organization. If you provide a postAuthRoleGrants field in the request, the array that you provide replaces the current postAuthRoleGrants.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleMappings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMapping:getFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMapping"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userConflicts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsIdentityProvidersResultAssociatedOrgUserConflict:getFederatedSettingsIdentityProvidersResultAssociatedOrgUserConflict"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "domainAllowLists",
                "domainRestrictionEnabled",
                "identityProviderId",
                "orgId",
                "postAuthRoleGrants",
                "roleMappings",
                "userConflicts"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMapping:getFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMapping": {
            "properties": {
                "externalGroupName": {
                    "type": "string",
                    "description": "Unique human-readable label that identifies the identity provider group to which this role mapping applies.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies this role mapping.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleAssignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignment:getFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignment"
                    },
                    "description": "Atlas roles and the unique identifiers of the groups and organizations associated with each role.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "externalGroupName",
                "id",
                "roleAssignments"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignment:getFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignment": {
            "properties": {
                "groupId": {
                    "type": "string",
                    "description": "Unique identifier of the project to which you want the role mapping to apply.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "role": {
                    "type": "string",
                    "description": "Specifies the Role that is attached to the Role Mapping.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "groupId",
                "orgId",
                "role"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProvidersResultAssociatedOrgUserConflict:getFederatedSettingsIdentityProvidersResultAssociatedOrgUserConflict": {
            "properties": {
                "emailAddress": {
                    "type": "string",
                    "description": "Email address of the the user that conflicts with selected domains.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "federationSettingsId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "firstName": {
                    "type": "string",
                    "description": "First name of the the user that conflicts with selected domains.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lastName": {
                    "type": "string",
                    "description": "Last name of the the user that conflicts with selected domains.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userId": {
                    "type": "string",
                    "description": "Name of the Atlas user that conflicts with selected domains.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "emailAddress",
                "federationSettingsId",
                "firstName",
                "lastName",
                "userId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProvidersResultPemFileInfo:getFederatedSettingsIdentityProvidersResultPemFileInfo": {
            "properties": {
                "certificates": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsIdentityProvidersResultPemFileInfoCertificate:getFederatedSettingsIdentityProvidersResultPemFileInfoCertificate"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fileName": {
                    "type": "string",
                    "description": "Filename of certificate\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "certificates",
                "fileName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProvidersResultPemFileInfoCertificate:getFederatedSettingsIdentityProvidersResultPemFileInfoCertificate": {
            "properties": {
                "notAfter": {
                    "type": "string",
                    "description": "Expiration  Date.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "notBefore": {
                    "type": "string",
                    "description": "Start Date.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "notAfter",
                "notBefore"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsOrgConfigRoleMapping:getFederatedSettingsOrgConfigRoleMapping": {
            "properties": {
                "externalGroupName": {
                    "type": "string",
                    "description": "Unique human-readable label that identifies the identity provider group to which this role mapping applies.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies this role mapping.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleAssignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsOrgConfigRoleMappingRoleAssignment:getFederatedSettingsOrgConfigRoleMappingRoleAssignment"
                    },
                    "description": "Atlas roles and the unique identifiers of the groups and organizations associated with each role.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "externalGroupName",
                "id",
                "roleAssignments"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsOrgConfigRoleMappingRoleAssignment:getFederatedSettingsOrgConfigRoleMappingRoleAssignment": {
            "properties": {
                "groupId": {
                    "type": "string",
                    "description": "Unique identifier of the project to which you want the role mapping to apply.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "role": {
                    "type": "string",
                    "description": "Specifies the Role that is attached to the Role Mapping.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "groupId",
                "orgId",
                "role"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsOrgConfigUserConflict:getFederatedSettingsOrgConfigUserConflict": {
            "properties": {
                "emailAddress": {
                    "type": "string",
                    "description": "Email address of the the user that conflicts with selected domains.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "federationSettingsId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "firstName": {
                    "type": "string",
                    "description": "First name of the the user that conflicts with selected domains.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lastName": {
                    "type": "string",
                    "description": "Last name of the the user that conflicts with selected domains.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userId": {
                    "type": "string",
                    "description": "Name of the Atlas user that conflicts with selected domains.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "emailAddress",
                "federationSettingsId",
                "firstName",
                "lastName",
                "userId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsOrgConfigsResult:getFederatedSettingsOrgConfigsResult": {
            "properties": {
                "domainAllowLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List that contains the approved domains from which organization users can log in.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "domainRestrictionEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether domain restriction is enabled for the connected organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "postAuthRoleGrants": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List that contains the default roles granted to users who authenticate through the IdP in a connected organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleMappings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsOrgConfigsResultRoleMapping:getFederatedSettingsOrgConfigsResultRoleMapping"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userConflicts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsOrgConfigsResultUserConflict:getFederatedSettingsOrgConfigsResultUserConflict"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "domainAllowLists",
                "domainRestrictionEnabled",
                "identityProviderId",
                "orgId",
                "postAuthRoleGrants",
                "roleMappings",
                "userConflicts"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsOrgConfigsResultRoleMapping:getFederatedSettingsOrgConfigsResultRoleMapping": {
            "properties": {
                "externalGroupName": {
                    "type": "string",
                    "description": "Unique human-readable label that identifies the identity provider group to which this role mapping applies.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies this role mapping.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleAssignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsOrgConfigsResultRoleMappingRoleAssignment:getFederatedSettingsOrgConfigsResultRoleMappingRoleAssignment"
                    },
                    "description": "Atlas roles and the unique identifiers of the groups and organizations associated with each role.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "externalGroupName",
                "id",
                "roleAssignments"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsOrgConfigsResultRoleMappingRoleAssignment:getFederatedSettingsOrgConfigsResultRoleMappingRoleAssignment": {
            "properties": {
                "groupId": {
                    "type": "string",
                    "description": "Unique identifier of the project to which you want the role mapping to apply.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "role": {
                    "type": "string",
                    "description": "Specifies the Role that is attached to the Role Mapping.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "groupId",
                "orgId",
                "role"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsOrgConfigsResultUserConflict:getFederatedSettingsOrgConfigsResultUserConflict": {
            "properties": {
                "emailAddress": {
                    "type": "string",
                    "description": "Email address of the the user that conflicts with selected domains.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "federationSettingsId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "firstName": {
                    "type": "string",
                    "description": "First name of the the user that conflicts with selected domains.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "lastName": {
                    "type": "string",
                    "description": "Last name of the the user that conflicts with selected domains.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userId": {
                    "type": "string",
                    "description": "Name of the Atlas user that conflicts with selected domains.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "emailAddress",
                "federationSettingsId",
                "firstName",
                "lastName",
                "userId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsOrgRoleMappingRoleAssignment:getFederatedSettingsOrgRoleMappingRoleAssignment": {
            "properties": {
                "groupId": {
                    "type": "string",
                    "description": "Unique identifier of the project to which you want the role mapping to apply.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "role": {
                    "type": "string",
                    "description": "Specifies the Role that is attached to the Role Mapping.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "groupId",
                "orgId",
                "role"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsOrgRoleMappingsResult:getFederatedSettingsOrgRoleMappingsResult": {
            "properties": {
                "externalGroupName": {
                    "type": "string",
                    "description": "Unique human-readable label that identifies the identity provider group to which this role mapping applies.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies this role mapping.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleAssignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsOrgRoleMappingsResultRoleAssignment:getFederatedSettingsOrgRoleMappingsResultRoleAssignment"
                    },
                    "description": "Atlas roles and the unique identifiers of the groups and organizations associated with each role.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "externalGroupName",
                "id",
                "roleAssignments"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsOrgRoleMappingsResultRoleAssignment:getFederatedSettingsOrgRoleMappingsResultRoleAssignment": {
            "properties": {
                "groupId": {
                    "type": "string",
                    "description": "Unique identifier of the project to which you want the role mapping to apply.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "role": {
                    "type": "string",
                    "description": "Specifies the Role that is attached to the Role Mapping.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "groupId",
                "orgId",
                "role"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getGlobalClusterConfigManagedNamespace:getGlobalClusterConfigManagedNamespace": {
            "properties": {
                "collection": {
                    "type": "string",
                    "description": "(Required) The name of the collection associated with the managed namespace.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "customShardKey": {
                    "type": "string",
                    "description": "(Required)\tThe custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "db": {
                    "type": "string",
                    "description": "(Required) The name of the database containing the collection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "isCustomShardKeyHashed": {
                    "type": "boolean",
                    "description": "Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "isShardKeyUnique": {
                    "type": "boolean",
                    "description": "Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "collection",
                "customShardKey",
                "db",
                "isCustomShardKeyHashed",
                "isShardKeyUnique"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": [
                        "collection",
                        "customShardKey",
                        "db"
                    ]
                }
            }
        },
        "mongodbatlas:index/getLdapConfigurationUserToDnMapping:getLdapConfigurationUserToDnMapping": {
            "properties": {
                "ldapQuery": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "match": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "substitution": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "ldapQuery",
                "match",
                "substitution"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getLdapVerifyLink:getLdapVerifyLink": {
            "properties": {
                "href": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rel": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "href",
                "rel"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getLdapVerifyValidation:getLdapVerifyValidation": {
            "properties": {
                "status": {
                    "type": "string",
                    "description": "The current status of the LDAP over TLS/SSL configuration.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "validationType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "status",
                "validationType"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getNetworkContainersResult:getNetworkContainersResult": {
            "properties": {
                "atlasCidrBlock": {
                    "type": "string",
                    "description": "CIDR block that Atlas uses for your clusters. Atlas uses the specified CIDR block for all other Network Peering connections created in the project. The Atlas CIDR block must be at least a /24 and at most a /21 in one of the following [private networks](https://tools.ietf.org/html/rfc1918.html#section-3).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "azureSubscriptionId": {
                    "type": "string",
                    "description": "Unique identifer of the Azure subscription in which the VNet resides.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "gcpProjectId": {
                    "type": "string",
                    "description": "Unique identifier of the GCP project in which the Network Peering connection resides.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "The Network Peering Container ID.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "networkName": {
                    "type": "string",
                    "description": "Name of the Network Peering connection in the Atlas project.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud provider for this Network peering container. Accepted values are AWS, GCP, and Azure.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "provisioned": {
                    "type": "boolean",
                    "description": "Indicates whether the project has Network Peering connections deployed in the container.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "region": {
                    "type": "string",
                    "description": "The Atlas Azure region name for where this container exists.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "regionName": {
                    "type": "string",
                    "description": "The Atlas AWS region name for where this container exists.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "regions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Atlas GCP regions where the container resides.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "vnetName": {
                    "type": "string",
                    "description": "The name of the Azure VNet. This value is null until you provision an Azure VNet in the container.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "vpcId": {
                    "type": "string",
                    "description": "Unique identifier of the project’s VPC.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "atlasCidrBlock",
                "azureSubscriptionId",
                "gcpProjectId",
                "id",
                "networkName",
                "providerName",
                "provisioned",
                "region",
                "regionName",
                "regions",
                "vnetName",
                "vpcId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getNetworkPeeringsResult:getNetworkPeeringsResult": {
            "properties": {
                "accepterRegionName": {
                    "type": "string",
                    "description": "Specifies the region where the peer VPC resides. For complete lists of supported regions, see [Amazon Web Services](https://docs.atlas.mongodb.com/reference/amazon-aws/).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "atlasCidrBlock": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "awsAccountId": {
                    "type": "string",
                    "description": "Account ID of the owner of the peer VPC.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "azureDirectoryId": {
                    "type": "string",
                    "description": "Unique identifier for an Azure AD directory.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "azureSubscriptionId": {
                    "type": "string",
                    "description": "Unique identifer of the Azure subscription in which the VNet resides.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "connectionId": {
                    "type": "string",
                    "description": "Unique identifier for the peering connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "containerId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "errorMessage": {
                    "type": "string",
                    "description": "When `\"status\" : \"FAILED\"`, Atlas provides a description of the error.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "errorState": {
                    "type": "string",
                    "description": "Description of the Atlas error when `status` is `Failed`, Otherwise, Atlas returns `null`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "errorStateName": {
                    "type": "string",
                    "description": "Error state, if any. The VPC peering connection error state value can be one of the following: `REJECTED`, `EXPIRED`, `INVALID_ARGUMENT`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "gcpProjectId": {
                    "type": "string",
                    "description": "GCP project ID of the owner of the network peer.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "networkName": {
                    "type": "string",
                    "description": "Name of the network peer to which Atlas connects.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "peeringId": {
                    "type": "string",
                    "description": "Atlas assigned unique ID for the peering connection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud provider for this VPC peering connection. If omitted, Atlas sets this parameter to AWS. (Possible Values `AWS`, `AZURE`, `GCP`).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "resourceGroupName": {
                    "type": "string",
                    "description": "Name of your Azure resource group.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "routeTableCidrBlock": {
                    "type": "string",
                    "description": "Peer VPC CIDR block or subnet.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "description": "Status of the Atlas network peering connection: `ADDING_PEER`, `AVAILABLE`, `FAILED`, `DELETING`, `WAITING_FOR_USER`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "statusName": {
                    "type": "string",
                    "description": "The VPC peering connection status value can be one of the following: `INITIATING`, `PENDING_ACCEPTANCE`, `FAILED`, `FINALIZING`, `AVAILABLE`, `TERMINATING`.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "vnetName": {
                    "type": "string",
                    "description": "Name of your Azure VNet.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "vpcId": {
                    "type": "string",
                    "description": "Unique identifier of the peer VPC.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "accepterRegionName",
                "atlasCidrBlock",
                "awsAccountId",
                "azureDirectoryId",
                "azureSubscriptionId",
                "connectionId",
                "containerId",
                "errorMessage",
                "errorState",
                "errorStateName",
                "gcpProjectId",
                "networkName",
                "peeringId",
                "providerName",
                "resourceGroupName",
                "routeTableCidrBlock",
                "status",
                "statusName",
                "vnetName",
                "vpcId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getOnlineArchiveCriteria:getOnlineArchiveCriteria": {
            "properties": {
                "dateField": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "dateFormat": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "expireAfterDays": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "query": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "dateField",
                "dateFormat",
                "expireAfterDays",
                "query",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getOnlineArchivePartitionField:getOnlineArchivePartitionField": {
            "properties": {
                "fieldName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fieldType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "order": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "fieldName",
                "fieldType",
                "order"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getOnlineArchivesResult:getOnlineArchivesResult": {
            "properties": {
                "archiveId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clusterName": {
                    "type": "string",
                    "description": "Name of the cluster that contains the collection.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "collName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "criterias": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getOnlineArchivesResultCriteria:getOnlineArchivesResultCriteria"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "dbName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "partitionFields": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getOnlineArchivesResultPartitionField:getOnlineArchivesResultPartitionField"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "paused": {
                    "type": "boolean",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "state": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "archiveId",
                "clusterName",
                "collName",
                "criterias",
                "dbName",
                "partitionFields",
                "paused",
                "projectId",
                "state"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getOnlineArchivesResultCriteria:getOnlineArchivesResultCriteria": {
            "properties": {
                "dateField": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "dateFormat": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "expireAfterDays": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "query": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "dateField",
                "dateFormat",
                "expireAfterDays",
                "query",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getOnlineArchivesResultPartitionField:getOnlineArchivesResultPartitionField": {
            "properties": {
                "fieldName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "fieldType": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "order": {
                    "type": "integer",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "fieldName",
                "fieldType",
                "order"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getPrivateLinkEndpointServiceEndpoint:getPrivateLinkEndpointServiceEndpoint": {
            "properties": {
                "endpointName": {
                    "type": "string",
                    "description": "Forwarding rule that corresponds to the endpoint you created in GCP.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "ipAddress": {
                    "type": "string",
                    "description": "Private IP address of the network endpoint group you created in GCP.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "serviceAttachmentName": {
                    "type": "string",
                    "description": "Unique alphanumeric and special character strings that identify the service attachment associated with the endpoint.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "description": "Status of the endpoint. Atlas returns one of the [values shown above](https://docs.atlas.mongodb.com/reference/api/private-endpoints-endpoint-create-one/#std-label-ref-status-field).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "endpointName",
                "ipAddress",
                "serviceAttachmentName",
                "status"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getPrivatelinkEndpointsServiceAdlLink:getPrivatelinkEndpointsServiceAdlLink": {
            "properties": {
                "href": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rel": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "href",
                "rel"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getPrivatelinkEndpointsServiceAdlResult:getPrivatelinkEndpointsServiceAdlResult": {
            "properties": {
                "comment": {
                    "type": "string",
                    "description": "Human-readable string to associate with this private endpoint.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpointId": {
                    "type": "string",
                    "description": "Unique 22-character alphanumeric string that identifies the private endpoint. Atlas supports AWS private endpoints using the [|aws| PrivateLink](https://aws.amazon.com/privatelink/) feature.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the cloud provider for this endpoint.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "Human-readable label that identifies the type of resource to associate with this private endpoint.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "comment",
                "endpointId",
                "providerName",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getPrivatelinkEndpointsServiceServerlessResult:getPrivatelinkEndpointsServiceServerlessResult": {
            "properties": {
                "cloudProviderEndpointId": {
                    "type": "string",
                    "description": "Unique string that identifies the private endpoint's network interface.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "comment": {
                    "type": "string",
                    "description": "Human-readable string to associate with this private endpoint.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpointId": {
                    "type": "string",
                    "description": "(Required) Unique 22-character alphanumeric string that identifies the private endpoint. Atlas supports AWS private endpoints using the [AWS PrivateLink](https://aws.amazon.com/privatelink/) feature.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "endpointServiceName": {
                    "type": "string",
                    "description": "Unique string that identifies the PrivateLink endpoint service. MongoDB Cloud returns null while it creates the endpoint service.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "errorMessage": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privateEndpointIpAddress": {
                    "type": "string",
                    "description": "IPv4 address of the private endpoint in your Azure VNet that someone added to this private endpoint service.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privateLinkServiceResourceId": {
                    "type": "string",
                    "description": "Root-relative path that identifies the Azure Private Link Service that MongoDB Cloud manages.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "description": "Human-readable label that indicates the current operating status of the private endpoint. Values include: RESERVATION_REQUESTED, RESERVED, INITIATING, AVAILABLE, FAILED, DELETING.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "cloudProviderEndpointId",
                "comment",
                "endpointId",
                "endpointServiceName",
                "errorMessage",
                "privateEndpointIpAddress",
                "privateLinkServiceResourceId",
                "status"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getProjectApiKey:getProjectApiKey": {
            "properties": {
                "apiKeyId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "apiKeyId",
                "roleNames"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getProjectApiKeysResult:getProjectApiKeysResult": {
            "properties": {
                "apiKeyId": {
                    "type": "string",
                    "description": "Unique identifier for the API key you want to update. Use the /orgs/{ORG-ID}/apiKeys endpoint to retrieve all API keys to which the authenticated user has access for the specified organization.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "description": {
                    "type": "string",
                    "description": "Description of this Project API key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "privateKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "publicKey": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Name of the role. This resource returns all the roles the user has in Atlas.\nThe following are valid roles:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "apiKeyId",
                "description",
                "privateKey",
                "publicKey",
                "roleNames"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getProjectTeam:getProjectTeam": {
            "properties": {
                "roleNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "teamId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "roleNames",
                "teamId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getProjectsResult:getProjectsResult": {
            "properties": {
                "apiKeys": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getProjectsResultApiKey:getProjectsResultApiKey"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clusterCount": {
                    "type": "integer",
                    "description": "The number of Atlas clusters deployed in the project.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "created": {
                    "type": "string",
                    "description": "The ISO-8601-formatted timestamp of when Atlas created the project.\n* `teams.#.team_id` - The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.\n* `teams.#.role_names` - Each string in the array represents a project role assigned to the team. Every user associated with the team inherits these roles.\nThe following are valid roles:\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Autogenerated Unique ID for this data source.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "isCollectDatabaseSpecificsStatisticsEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable statistics in [cluster metrics](https://www.mongodb.com/docs/atlas/monitor-cluster-metrics/) collection for the project.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "isDataExplorerEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable Data Explorer for the project. If enabled, you can query your database with an easy to use interface.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "isPerformanceAdvisorEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable Performance Advisor and Profiler for the project. If enabled, you can analyze database logs to recommend performance improvements.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "isRealtimePerformancePanelEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable Real Time Performance Panel for the project. If enabled, you can see real time metrics from your MongoDB database.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "isSchemaAdvisorEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable Schema Advisor for the project. If enabled, you receive customized recommendations to optimize your data model and enhance performance. Disable this setting to disable schema suggestions in the [Performance Advisor](https://www.mongodb.com/docs/atlas/performance-advisor/#std-label-performance-advisor) and the [Data Explorer](https://www.mongodb.com/docs/atlas/atlas-ui/#std-label-atlas-ui).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of the project you want to create. (Cannot be changed via this Provider after creation.)\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "orgId": {
                    "type": "string",
                    "description": "The ID of the organization you want to create the project within.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "regionUsageRestrictions": {
                    "type": "string",
                    "description": "If GOV_REGIONS_ONLY the project can be used for government regions only, otherwise defaults to standard regions. For more information see [MongoDB Atlas for Government](https://www.mongodb.com/docs/atlas/government/api/#creating-a-project).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getProjectsResultTeam:getProjectsResultTeam"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "apiKeys",
                "clusterCount",
                "created",
                "id",
                "isCollectDatabaseSpecificsStatisticsEnabled",
                "isDataExplorerEnabled",
                "isPerformanceAdvisorEnabled",
                "isRealtimePerformancePanelEnabled",
                "isSchemaAdvisorEnabled",
                "name",
                "orgId",
                "regionUsageRestrictions",
                "teams"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getProjectsResultApiKey:getProjectsResultApiKey": {
            "properties": {
                "apiKeyId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "roleNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "apiKeyId",
                "roleNames"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getProjectsResultTeam:getProjectsResultTeam": {
            "properties": {
                "roleNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "teamId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "roleNames",
                "teamId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getSearchIndexSynonym:getSearchIndexSynonym": {
            "properties": {
                "analyzer": {
                    "type": "string",
                    "description": "[Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of the index.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sourceCollection": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "analyzer",
                "name",
                "sourceCollection"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getSearchIndexesResult:getSearchIndexesResult": {
            "properties": {
                "analyzer": {
                    "type": "string",
                    "description": "[Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "analyzers": {
                    "type": "string",
                    "description": "[Custom analyzers](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-custom-analyzers) to use in this index (this is an array of objects).\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "clusterName": {
                    "type": "string",
                    "description": "Name of the cluster containing the collection with one or more Atlas Search indexes.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "collectionName": {
                    "type": "string",
                    "description": "Name of the collection with one or more Atlas Search indexes.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "database": {
                    "type": "string",
                    "description": "(Required) Name of the database the collection is in.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "indexId": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mappingsDynamic": {
                    "type": "boolean",
                    "description": "Flag indicating whether the index uses dynamic or static mappings.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mappingsFields": {
                    "type": "string",
                    "description": "Object containing one or more field specifications.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of the index.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique identifier for the [project](https://docs.atlas.mongodb.com/organizations-projects/#std-label-projects) that contains the specified cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "searchAnalyzer": {
                    "type": "string",
                    "description": "[Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when searching the index.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "status": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "synonyms": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getSearchIndexesResultSynonym:getSearchIndexesResultSynonym"
                    },
                    "description": "Synonyms mapping definition to use in this index.\n* `synonyms.#.name` - Name of the [synonym mapping definition](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-ref).\n* `synonyms.#.source_collection` - Name of the source MongoDB collection for the synonyms.\n* `synonyms.#.analyzer` - Name of the [analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use with this synonym mapping.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "analyzer",
                "clusterName",
                "collectionName",
                "database",
                "indexId",
                "name",
                "projectId",
                "status"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getSearchIndexesResultSynonym:getSearchIndexesResultSynonym": {
            "properties": {
                "analyzer": {
                    "type": "string",
                    "description": "[Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of the index.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "sourceCollection": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "analyzer",
                "name",
                "sourceCollection"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getServerlessInstanceLink:getServerlessInstanceLink": {
            "properties": {
                "href": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rel": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "href",
                "rel"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getServerlessInstancesResult:getServerlessInstancesResult": {
            "properties": {
                "connectionStringsStandardSrv": {
                    "type": "string",
                    "description": "Public `mongodb+srv://` connection string that you can use to connect to this serverless instance.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "continuousBackupEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the serverless instance uses Serverless Continuous Backup.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "createDate": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "id": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the serverless instance.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "links": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getServerlessInstancesResultLink:getServerlessInstancesResultLink"
                    },
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "mongoDbVersion": {
                    "type": "string",
                    "description": "Version of MongoDB that the serverless instance runs, in `\u003cmajor version\u003e`.`\u003cminor version\u003e` format.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "name": {
                    "type": "string",
                    "description": "(Required) Human-readable label that identifies your serverless instance.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique identifier for the [project](https://docs.atlas.mongodb.com/organizations-projects/#std-label-projects) that contains the specified cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerSettingsBackingProviderName": {
                    "type": "string",
                    "description": "Cloud service provider on which MongoDB Cloud provisioned the serverless instance.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerSettingsProviderName": {
                    "type": "string",
                    "description": "Cloud service provider that applies to the provisioned the serverless instance.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "providerSettingsRegionName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the physical location of your MongoDB serverless instance. The region you choose can affect network latency for clients accessing your databases.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "stateName": {
                    "type": "string",
                    "description": "Stage of deployment of this serverless instance when the resource made its request.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "terminationProtectionEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "connectionStringsStandardSrv",
                "continuousBackupEnabled",
                "createDate",
                "id",
                "links",
                "mongoDbVersion",
                "name",
                "projectId",
                "providerSettingsBackingProviderName",
                "providerSettingsProviderName",
                "providerSettingsRegionName",
                "stateName",
                "terminationProtectionEnabled"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getServerlessInstancesResultLink:getServerlessInstancesResultLink": {
            "properties": {
                "href": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "rel": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "href",
                "rel"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getThirdPartyIntegrationsResult:getThirdPartyIntegrationsResult": {
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "Unique identifier of your New Relic account.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "apiKey": {
                    "type": "string",
                    "description": "Your API Key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "apiToken": {
                    "type": "string",
                    "description": "Your API Token.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "channelName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether your cluster has Prometheus enabled.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "flowName": {
                    "type": "string",
                    "description": "Your Flowdock Flow name.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "licenseKey": {
                    "type": "string",
                    "description": "Your License Key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "microsoftTeamsWebhookUrl": {
                    "type": "string",
                    "description": "Your Microsoft Teams incoming webhook URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "orgName": {
                    "type": "string",
                    "description": "Your Flowdock organization name.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to get all Third-Party service integrations\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "readToken": {
                    "type": "string",
                    "description": "Your Insights Query Key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "region": {
                    "type": "string",
                    "description": "Indicates which API URL to use, either US or EU. Opsgenie will use US by default.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "routingKey": {
                    "type": "string",
                    "description": "An optional field for your Routing Key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "scheme": {
                    "type": "string",
                    "description": "Your Prometheus protocol scheme configured for requests.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "secret": {
                    "type": "string",
                    "description": "An optional field for your webhook secret.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "serviceDiscovery": {
                    "type": "string",
                    "description": "Indicates which service discovery method is used, either file or http.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "serviceKey": {
                    "type": "string",
                    "description": "Your Service Key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "teamName": {
                    "type": "string",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "type": {
                    "type": "string",
                    "description": "(Required) Thirt-Party service integration type.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "url": {
                    "type": "string",
                    "description": "Your webhook URL.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    }
                },
                "userName": {
                    "type": "string",
                    "description": "Your Prometheus username.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                },
                "writeToken": {
                    "type": "string",
                    "description": "Your Insights Insert Key.\n",
                    "language": {
                        "python": {
                            "mapCase": false
                        }
                    },
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "accountId",
                "apiKey",
                "apiToken",
                "channelName",
                "flowName",
                "licenseKey",
                "orgName",
                "projectId",
                "readToken",
                "region",
                "routingKey",
                "secret",
                "serviceKey",
                "teamName",
                "type",
                "url",
                "writeToken"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        }
    },
    "provider": {
        "description": "The provider type for the mongodbatlas package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "assumeRole": {
                "$ref": "#/types/mongodbatlas:index/ProviderAssumeRole:ProviderAssumeRole"
            },
            "awsAccessKeyId": {
                "type": "string"
            },
            "awsSecretAccessKey": {
                "type": "string"
            },
            "awsSessionToken": {
                "type": "string"
            },
            "baseUrl": {
                "type": "string",
                "description": "MongoDB Atlas Base URL\n"
            },
            "isMongodbgovCloud": {
                "type": "boolean",
                "description": "MongoDB Atlas Base URL default to gov\n"
            },
            "privateKey": {
                "type": "string",
                "description": "MongoDB Atlas Programmatic Private Key\n",
                "secret": true
            },
            "publicKey": {
                "type": "string",
                "description": "MongoDB Atlas Programmatic Public Key\n"
            },
            "realmBaseUrl": {
                "type": "string",
                "description": "MongoDB Realm Base URL\n"
            },
            "region": {
                "type": "string"
            },
            "secretName": {
                "type": "string"
            },
            "stsEndpoint": {
                "type": "string"
            }
        },
        "inputProperties": {
            "assumeRole": {
                "$ref": "#/types/mongodbatlas:index/ProviderAssumeRole:ProviderAssumeRole"
            },
            "awsAccessKeyId": {
                "type": "string"
            },
            "awsSecretAccessKey": {
                "type": "string"
            },
            "awsSessionToken": {
                "type": "string"
            },
            "baseUrl": {
                "type": "string",
                "description": "MongoDB Atlas Base URL\n"
            },
            "isMongodbgovCloud": {
                "type": "boolean",
                "description": "MongoDB Atlas Base URL default to gov\n"
            },
            "privateKey": {
                "type": "string",
                "description": "MongoDB Atlas Programmatic Private Key\n",
                "secret": true
            },
            "publicKey": {
                "type": "string",
                "description": "MongoDB Atlas Programmatic Public Key\n"
            },
            "realmBaseUrl": {
                "type": "string",
                "description": "MongoDB Realm Base URL\n"
            },
            "region": {
                "type": "string"
            },
            "secretName": {
                "type": "string"
            },
            "stsEndpoint": {
                "type": "string"
            }
        }
    },
    "resources": {
        "mongodbatlas:index/accessListApiKey:AccessListApiKey": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n### Using CIDR Block\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.AccessListApiKey(\"test\", {\n    apiKeyId: \"a29120e123cd\",\n    cidrBlock: \"1.2.3.4/32\",\n    orgId: \"\u003cORG-ID\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.AccessListApiKey(\"test\",\n    api_key_id=\"a29120e123cd\",\n    cidr_block=\"1.2.3.4/32\",\n    org_id=\"\u003cORG-ID\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.AccessListApiKey(\"test\", new()\n    {\n        ApiKeyId = \"a29120e123cd\",\n        CidrBlock = \"1.2.3.4/32\",\n        OrgId = \"\u003cORG-ID\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewAccessListApiKey(ctx, \"test\", \u0026mongodbatlas.AccessListApiKeyArgs{\n\t\t\tApiKeyId:  pulumi.String(\"a29120e123cd\"),\n\t\t\tCidrBlock: pulumi.String(\"1.2.3.4/32\"),\n\t\t\tOrgId:     pulumi.String(\"\u003cORG-ID\u003e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AccessListApiKey;\nimport com.pulumi.mongodbatlas.AccessListApiKeyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new AccessListApiKey(\"test\", AccessListApiKeyArgs.builder()        \n            .apiKeyId(\"a29120e123cd\")\n            .cidrBlock(\"1.2.3.4/32\")\n            .orgId(\"\u003cORG-ID\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:AccessListApiKey\n    properties:\n      apiKeyId: a29120e123cd\n      cidrBlock: 1.2.3.4/32\n      orgId: \u003cORG-ID\u003e\n```\n{{% /example %}}\n{{% example %}}\n### Using IP Address\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.AccessListApiKey(\"test\", {\n    apiKeyId: \"a29120e123cd\",\n    ipAddress: \"2.3.4.5\",\n    orgId: \"\u003cORG-ID\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.AccessListApiKey(\"test\",\n    api_key_id=\"a29120e123cd\",\n    ip_address=\"2.3.4.5\",\n    org_id=\"\u003cORG-ID\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.AccessListApiKey(\"test\", new()\n    {\n        ApiKeyId = \"a29120e123cd\",\n        IpAddress = \"2.3.4.5\",\n        OrgId = \"\u003cORG-ID\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewAccessListApiKey(ctx, \"test\", \u0026mongodbatlas.AccessListApiKeyArgs{\n\t\t\tApiKeyId:  pulumi.String(\"a29120e123cd\"),\n\t\t\tIpAddress: pulumi.String(\"2.3.4.5\"),\n\t\t\tOrgId:     pulumi.String(\"\u003cORG-ID\u003e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AccessListApiKey;\nimport com.pulumi.mongodbatlas.AccessListApiKeyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new AccessListApiKey(\"test\", AccessListApiKeyArgs.builder()        \n            .apiKeyId(\"a29120e123cd\")\n            .ipAddress(\"2.3.4.5\")\n            .orgId(\"\u003cORG-ID\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:AccessListApiKey\n    properties:\n      apiKeyId: a29120e123cd\n      ipAddress: 2.3.4.5\n      orgId: \u003cORG-ID\u003e\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nIP Access List entries can be imported using the `org_id` , `api_key_id` and `cidr_block` or `ip_address`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/accessListApiKey:AccessListApiKey test 5d0f1f74cf09a29120e123cd-a29120e123cd-10.242.88.0/21\n```\n\n For more information see[MongoDB Atlas API Reference.](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Programmatic-API-Keys/operation/createAccessListEntriesForOneOrganizationApiKey) ",
            "properties": {
                "apiKeyId": {
                    "type": "string",
                    "description": "Unique identifier for the Organization API Key for which you want to create a new access list entry.\n"
                },
                "cidrBlock": {
                    "type": "string",
                    "description": "Range of IP addresses in CIDR notation to be added to the access list. Your access list entry can include only one `cidrBlock`, or one `ipAddress`.\n"
                },
                "ipAddress": {
                    "type": "string",
                    "description": "Single IP address to be added to the access list.\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique identifier for the organinzation to which you want to add one or more access list entries.\n"
                }
            },
            "required": [
                "apiKeyId",
                "cidrBlock",
                "ipAddress",
                "orgId"
            ],
            "inputProperties": {
                "apiKeyId": {
                    "type": "string",
                    "description": "Unique identifier for the Organization API Key for which you want to create a new access list entry.\n"
                },
                "cidrBlock": {
                    "type": "string",
                    "description": "Range of IP addresses in CIDR notation to be added to the access list. Your access list entry can include only one `cidrBlock`, or one `ipAddress`.\n",
                    "willReplaceOnChanges": true
                },
                "ipAddress": {
                    "type": "string",
                    "description": "Single IP address to be added to the access list.\n",
                    "willReplaceOnChanges": true
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique identifier for the organinzation to which you want to add one or more access list entries.\n"
                }
            },
            "requiredInputs": [
                "apiKeyId",
                "orgId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessListApiKey resources.\n",
                "properties": {
                    "apiKeyId": {
                        "type": "string",
                        "description": "Unique identifier for the Organization API Key for which you want to create a new access list entry.\n"
                    },
                    "cidrBlock": {
                        "type": "string",
                        "description": "Range of IP addresses in CIDR notation to be added to the access list. Your access list entry can include only one `cidrBlock`, or one `ipAddress`.\n",
                        "willReplaceOnChanges": true
                    },
                    "ipAddress": {
                        "type": "string",
                        "description": "Single IP address to be added to the access list.\n",
                        "willReplaceOnChanges": true
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Unique identifier for the organinzation to which you want to add one or more access list entries.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/advancedCluster:AdvancedCluster": {
            "description": "\n\n\n## Import\n\nClusters can be imported using project ID and cluster name, in the format `PROJECTID-CLUSTERNAME`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/advancedCluster:AdvancedCluster my_cluster 1112222b3bf99403840e8934-Cluster0\n```\n\n See detailed information for arguments and attributes[MongoDB API Advanced Clusters](https://docs.atlas.mongodb.com/reference/api/cluster-advanced/create-one-cluster-advanced/) ",
            "properties": {
                "advancedConfiguration": {
                    "$ref": "#/types/mongodbatlas:index/AdvancedClusterAdvancedConfiguration:AdvancedClusterAdvancedConfiguration"
                },
                "backupEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the cluster can perform backups.\nIf `true`, the cluster can perform backups. You must set this value to `true` for NVMe clusters.\n"
                },
                "biConnector": {
                    "$ref": "#/types/mongodbatlas:index/AdvancedClusterBiConnector:AdvancedClusterBiConnector",
                    "deprecationMessage": "use bi_connector_config instead"
                },
                "biConnectorConfig": {
                    "$ref": "#/types/mongodbatlas:index/AdvancedClusterBiConnectorConfig:AdvancedClusterBiConnectorConfig",
                    "description": "Configuration settings applied to BI Connector for Atlas on this cluster. The MongoDB Connector for Business Intelligence for Atlas (BI Connector) is only available for M10 and larger clusters. The BI Connector is a powerful tool which provides users SQL-based access to their MongoDB databases. As a result, the BI Connector performs operations which may be CPU and memory intensive. Given the limited hardware resources on M10 and M20 cluster tiers, you may experience performance degradation of the cluster when enabling the BI Connector. If this occurs, upgrade to an M30 or larger cluster or disable the BI Connector. See below.\n"
                },
                "clusterId": {
                    "type": "string",
                    "description": "The cluster ID.\n"
                },
                "clusterType": {
                    "type": "string",
                    "description": "Type of the cluster that you want to create.\nAccepted values include:\n"
                },
                "connectionStrings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/AdvancedClusterConnectionString:AdvancedClusterConnectionString"
                    },
                    "description": "Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.\n"
                },
                "createDate": {
                    "type": "string"
                },
                "diskSizeGb": {
                    "type": "number",
                    "description": "Capacity, in gigabytes, of the host's root volume. Increase this number to add capacity, up to a maximum possible value of 4096 (i.e., 4 TB). This value must be a positive number. You can't set this value with clusters with local [NVMe SSDs](https://docs.atlas.mongodb.com/cluster-tier/#std-label-nvme-storage). The minimum disk size for dedicated clusters is 10 GB for AWS and GCP. If you specify diskSizeGB with a lower disk size, Atlas defaults to the minimum disk size value. If your cluster includes Azure nodes, this value must correspond to an existing Azure disk type (8, 16, 32, 64, 128, 256, 512, 1024, 2048, or 4095)Atlas calculates storage charges differently depending on whether you choose the default value or a custom value. The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require additional storage space beyond this limitation, consider [upgrading your cluster](https://docs.atlas.mongodb.com/scale-cluster/#std-label-scale-cluster-instance) to a higher tier. If your cluster spans cloud service providers, this value defaults to the minimum default of the providers involved.\n"
                },
                "encryptionAtRestProvider": {
                    "type": "string",
                    "description": "Possible values are AWS, GCP, AZURE or NONE.  Only needed if you desire to manage the keys, see [Encryption at Rest using Customer Key Management](https://docs.atlas.mongodb.com/security-kms-encryption/) for complete documentation.  You must configure encryption at rest for the Atlas project before enabling it on any cluster in the project. For Documentation, see [AWS](https://docs.atlas.mongodb.com/security-aws-kms/), [GCP](https://docs.atlas.mongodb.com/security-kms-encryption/) and [Azure](https://docs.atlas.mongodb.com/security-azure-kms/#std-label-security-azure-kms). Requirements are if `replication_specs.#.region_configs.#.\u003ctype\u003eSpecs.instance_size` is M10 or greater and `backup_enabled` is false or omitted.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/AdvancedClusterLabel:AdvancedClusterLabel"
                    },
                    "description": "Configuration for the collection of key-value pairs that tag and categorize the cluster. See below.\n"
                },
                "mongoDbMajorVersion": {
                    "type": "string",
                    "description": "Version of the cluster to deploy. Atlas supports the following MongoDB versions for M10+ clusters: `4.0`, `4.2`, `4.4`, or `5.0`. If omitted, Atlas deploys a cluster that runs MongoDB 4.4. If `replication_specs#.region_configs#.\u003ctype\u003eSpecs.instance_size`: `M0`, `M2` or `M5`, Atlas deploys MongoDB 4.4. Atlas always deploys the cluster with the latest stable release of the specified version.  If you set a value to this parameter and set `version_release_system` `CONTINUOUS`, the resource returns an error. Either clear this parameter or set `version_release_system`: `LTS`.\n"
                },
                "mongoDbVersion": {
                    "type": "string",
                    "description": "Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the cluster as it appears in Atlas. Once the cluster is created, its name cannot be changed. **WARNING** Changing the name will result in destruction of the existing cluster and the creation of a new cluster.\n"
                },
                "paused": {
                    "type": "boolean"
                },
                "pitEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates if the cluster uses Continuous Cloud Backup.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique ID for the project to create the database user.\n"
                },
                "replicationSpecs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/AdvancedClusterReplicationSpec:AdvancedClusterReplicationSpec"
                    },
                    "description": "Configuration for cluster regions and the hardware provisioned in them. See below\n"
                },
                "rootCertType": {
                    "type": "string",
                    "description": "Certificate Authority that MongoDB Atlas clusters use. You can specify ISRGROOTX1 (for ISRG Root X1).\n"
                },
                "stateName": {
                    "type": "string",
                    "description": "Current state of the cluster. The possible states are:\n- IDLE\n- CREATING\n- UPDATING\n- DELETING\n- DELETED\n- REPAIRING\n"
                },
                "terminationProtectionEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n"
                },
                "versionReleaseSystem": {
                    "type": "string",
                    "description": "Release cadence that Atlas uses for this cluster. This parameter defaults to `LTS`. If you set this field to `CONTINUOUS`, you must omit the `mongo_db_major_version` field. Atlas accepts:\n"
                }
            },
            "required": [
                "advancedConfiguration",
                "backupEnabled",
                "biConnector",
                "biConnectorConfig",
                "clusterId",
                "clusterType",
                "connectionStrings",
                "createDate",
                "diskSizeGb",
                "encryptionAtRestProvider",
                "labels",
                "mongoDbMajorVersion",
                "mongoDbVersion",
                "name",
                "pitEnabled",
                "projectId",
                "replicationSpecs",
                "rootCertType",
                "stateName",
                "terminationProtectionEnabled"
            ],
            "inputProperties": {
                "advancedConfiguration": {
                    "$ref": "#/types/mongodbatlas:index/AdvancedClusterAdvancedConfiguration:AdvancedClusterAdvancedConfiguration"
                },
                "backupEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the cluster can perform backups.\nIf `true`, the cluster can perform backups. You must set this value to `true` for NVMe clusters.\n"
                },
                "biConnector": {
                    "$ref": "#/types/mongodbatlas:index/AdvancedClusterBiConnector:AdvancedClusterBiConnector",
                    "deprecationMessage": "use bi_connector_config instead"
                },
                "biConnectorConfig": {
                    "$ref": "#/types/mongodbatlas:index/AdvancedClusterBiConnectorConfig:AdvancedClusterBiConnectorConfig",
                    "description": "Configuration settings applied to BI Connector for Atlas on this cluster. The MongoDB Connector for Business Intelligence for Atlas (BI Connector) is only available for M10 and larger clusters. The BI Connector is a powerful tool which provides users SQL-based access to their MongoDB databases. As a result, the BI Connector performs operations which may be CPU and memory intensive. Given the limited hardware resources on M10 and M20 cluster tiers, you may experience performance degradation of the cluster when enabling the BI Connector. If this occurs, upgrade to an M30 or larger cluster or disable the BI Connector. See below.\n"
                },
                "clusterType": {
                    "type": "string",
                    "description": "Type of the cluster that you want to create.\nAccepted values include:\n"
                },
                "diskSizeGb": {
                    "type": "number",
                    "description": "Capacity, in gigabytes, of the host's root volume. Increase this number to add capacity, up to a maximum possible value of 4096 (i.e., 4 TB). This value must be a positive number. You can't set this value with clusters with local [NVMe SSDs](https://docs.atlas.mongodb.com/cluster-tier/#std-label-nvme-storage). The minimum disk size for dedicated clusters is 10 GB for AWS and GCP. If you specify diskSizeGB with a lower disk size, Atlas defaults to the minimum disk size value. If your cluster includes Azure nodes, this value must correspond to an existing Azure disk type (8, 16, 32, 64, 128, 256, 512, 1024, 2048, or 4095)Atlas calculates storage charges differently depending on whether you choose the default value or a custom value. The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require additional storage space beyond this limitation, consider [upgrading your cluster](https://docs.atlas.mongodb.com/scale-cluster/#std-label-scale-cluster-instance) to a higher tier. If your cluster spans cloud service providers, this value defaults to the minimum default of the providers involved.\n"
                },
                "encryptionAtRestProvider": {
                    "type": "string",
                    "description": "Possible values are AWS, GCP, AZURE or NONE.  Only needed if you desire to manage the keys, see [Encryption at Rest using Customer Key Management](https://docs.atlas.mongodb.com/security-kms-encryption/) for complete documentation.  You must configure encryption at rest for the Atlas project before enabling it on any cluster in the project. For Documentation, see [AWS](https://docs.atlas.mongodb.com/security-aws-kms/), [GCP](https://docs.atlas.mongodb.com/security-kms-encryption/) and [Azure](https://docs.atlas.mongodb.com/security-azure-kms/#std-label-security-azure-kms). Requirements are if `replication_specs.#.region_configs.#.\u003ctype\u003eSpecs.instance_size` is M10 or greater and `backup_enabled` is false or omitted.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/AdvancedClusterLabel:AdvancedClusterLabel"
                    },
                    "description": "Configuration for the collection of key-value pairs that tag and categorize the cluster. See below.\n"
                },
                "mongoDbMajorVersion": {
                    "type": "string",
                    "description": "Version of the cluster to deploy. Atlas supports the following MongoDB versions for M10+ clusters: `4.0`, `4.2`, `4.4`, or `5.0`. If omitted, Atlas deploys a cluster that runs MongoDB 4.4. If `replication_specs#.region_configs#.\u003ctype\u003eSpecs.instance_size`: `M0`, `M2` or `M5`, Atlas deploys MongoDB 4.4. Atlas always deploys the cluster with the latest stable release of the specified version.  If you set a value to this parameter and set `version_release_system` `CONTINUOUS`, the resource returns an error. Either clear this parameter or set `version_release_system`: `LTS`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the cluster as it appears in Atlas. Once the cluster is created, its name cannot be changed. **WARNING** Changing the name will result in destruction of the existing cluster and the creation of a new cluster.\n",
                    "willReplaceOnChanges": true
                },
                "paused": {
                    "type": "boolean"
                },
                "pitEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates if the cluster uses Continuous Cloud Backup.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique ID for the project to create the database user.\n",
                    "willReplaceOnChanges": true
                },
                "replicationSpecs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/AdvancedClusterReplicationSpec:AdvancedClusterReplicationSpec"
                    },
                    "description": "Configuration for cluster regions and the hardware provisioned in them. See below\n"
                },
                "rootCertType": {
                    "type": "string",
                    "description": "Certificate Authority that MongoDB Atlas clusters use. You can specify ISRGROOTX1 (for ISRG Root X1).\n"
                },
                "terminationProtectionEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n"
                },
                "versionReleaseSystem": {
                    "type": "string",
                    "description": "Release cadence that Atlas uses for this cluster. This parameter defaults to `LTS`. If you set this field to `CONTINUOUS`, you must omit the `mongo_db_major_version` field. Atlas accepts:\n"
                }
            },
            "requiredInputs": [
                "clusterType",
                "projectId",
                "replicationSpecs"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AdvancedCluster resources.\n",
                "properties": {
                    "advancedConfiguration": {
                        "$ref": "#/types/mongodbatlas:index/AdvancedClusterAdvancedConfiguration:AdvancedClusterAdvancedConfiguration"
                    },
                    "backupEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether the cluster can perform backups.\nIf `true`, the cluster can perform backups. You must set this value to `true` for NVMe clusters.\n"
                    },
                    "biConnector": {
                        "$ref": "#/types/mongodbatlas:index/AdvancedClusterBiConnector:AdvancedClusterBiConnector",
                        "deprecationMessage": "use bi_connector_config instead"
                    },
                    "biConnectorConfig": {
                        "$ref": "#/types/mongodbatlas:index/AdvancedClusterBiConnectorConfig:AdvancedClusterBiConnectorConfig",
                        "description": "Configuration settings applied to BI Connector for Atlas on this cluster. The MongoDB Connector for Business Intelligence for Atlas (BI Connector) is only available for M10 and larger clusters. The BI Connector is a powerful tool which provides users SQL-based access to their MongoDB databases. As a result, the BI Connector performs operations which may be CPU and memory intensive. Given the limited hardware resources on M10 and M20 cluster tiers, you may experience performance degradation of the cluster when enabling the BI Connector. If this occurs, upgrade to an M30 or larger cluster or disable the BI Connector. See below.\n"
                    },
                    "clusterId": {
                        "type": "string",
                        "description": "The cluster ID.\n"
                    },
                    "clusterType": {
                        "type": "string",
                        "description": "Type of the cluster that you want to create.\nAccepted values include:\n"
                    },
                    "connectionStrings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/AdvancedClusterConnectionString:AdvancedClusterConnectionString"
                        },
                        "description": "Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.\n"
                    },
                    "createDate": {
                        "type": "string"
                    },
                    "diskSizeGb": {
                        "type": "number",
                        "description": "Capacity, in gigabytes, of the host's root volume. Increase this number to add capacity, up to a maximum possible value of 4096 (i.e., 4 TB). This value must be a positive number. You can't set this value with clusters with local [NVMe SSDs](https://docs.atlas.mongodb.com/cluster-tier/#std-label-nvme-storage). The minimum disk size for dedicated clusters is 10 GB for AWS and GCP. If you specify diskSizeGB with a lower disk size, Atlas defaults to the minimum disk size value. If your cluster includes Azure nodes, this value must correspond to an existing Azure disk type (8, 16, 32, 64, 128, 256, 512, 1024, 2048, or 4095)Atlas calculates storage charges differently depending on whether you choose the default value or a custom value. The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require additional storage space beyond this limitation, consider [upgrading your cluster](https://docs.atlas.mongodb.com/scale-cluster/#std-label-scale-cluster-instance) to a higher tier. If your cluster spans cloud service providers, this value defaults to the minimum default of the providers involved.\n"
                    },
                    "encryptionAtRestProvider": {
                        "type": "string",
                        "description": "Possible values are AWS, GCP, AZURE or NONE.  Only needed if you desire to manage the keys, see [Encryption at Rest using Customer Key Management](https://docs.atlas.mongodb.com/security-kms-encryption/) for complete documentation.  You must configure encryption at rest for the Atlas project before enabling it on any cluster in the project. For Documentation, see [AWS](https://docs.atlas.mongodb.com/security-aws-kms/), [GCP](https://docs.atlas.mongodb.com/security-kms-encryption/) and [Azure](https://docs.atlas.mongodb.com/security-azure-kms/#std-label-security-azure-kms). Requirements are if `replication_specs.#.region_configs.#.\u003ctype\u003eSpecs.instance_size` is M10 or greater and `backup_enabled` is false or omitted.\n"
                    },
                    "labels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/AdvancedClusterLabel:AdvancedClusterLabel"
                        },
                        "description": "Configuration for the collection of key-value pairs that tag and categorize the cluster. See below.\n"
                    },
                    "mongoDbMajorVersion": {
                        "type": "string",
                        "description": "Version of the cluster to deploy. Atlas supports the following MongoDB versions for M10+ clusters: `4.0`, `4.2`, `4.4`, or `5.0`. If omitted, Atlas deploys a cluster that runs MongoDB 4.4. If `replication_specs#.region_configs#.\u003ctype\u003eSpecs.instance_size`: `M0`, `M2` or `M5`, Atlas deploys MongoDB 4.4. Atlas always deploys the cluster with the latest stable release of the specified version.  If you set a value to this parameter and set `version_release_system` `CONTINUOUS`, the resource returns an error. Either clear this parameter or set `version_release_system`: `LTS`.\n"
                    },
                    "mongoDbVersion": {
                        "type": "string",
                        "description": "Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the cluster as it appears in Atlas. Once the cluster is created, its name cannot be changed. **WARNING** Changing the name will result in destruction of the existing cluster and the creation of a new cluster.\n",
                        "willReplaceOnChanges": true
                    },
                    "paused": {
                        "type": "boolean"
                    },
                    "pitEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates if the cluster uses Continuous Cloud Backup.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique ID for the project to create the database user.\n",
                        "willReplaceOnChanges": true
                    },
                    "replicationSpecs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/AdvancedClusterReplicationSpec:AdvancedClusterReplicationSpec"
                        },
                        "description": "Configuration for cluster regions and the hardware provisioned in them. See below\n"
                    },
                    "rootCertType": {
                        "type": "string",
                        "description": "Certificate Authority that MongoDB Atlas clusters use. You can specify ISRGROOTX1 (for ISRG Root X1).\n"
                    },
                    "stateName": {
                        "type": "string",
                        "description": "Current state of the cluster. The possible states are:\n- IDLE\n- CREATING\n- UPDATING\n- DELETING\n- DELETED\n- REPAIRING\n"
                    },
                    "terminationProtectionEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n"
                    },
                    "versionReleaseSystem": {
                        "type": "string",
                        "description": "Release cadence that Atlas uses for this cluster. This parameter defaults to `LTS`. If you set this field to `CONTINUOUS`, you must omit the `mongo_db_major_version` field. Atlas accepts:\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/alertConfiguration:AlertConfiguration": {
            "description": "`mongodbatlas.AlertConfiguration` provides an Alert Configuration resource to define the conditions that trigger an alert and the methods of notification within a MongoDB Atlas project.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.AlertConfiguration(\"test\", {\n    enabled: true,\n    eventType: \"OUTSIDE_METRIC_THRESHOLD\",\n    matchers: [{\n        fieldName: \"HOSTNAME_AND_PORT\",\n        operator: \"EQUALS\",\n        value: \"SECONDARY\",\n    }],\n    metricThresholdConfig: {\n        metricName: \"ASSERT_REGULAR\",\n        mode: \"AVERAGE\",\n        operator: \"LESS_THAN\",\n        threshold: 99,\n        units: \"RAW\",\n    },\n    notifications: [{\n        delayMin: 0,\n        emailEnabled: true,\n        intervalMin: 5,\n        roles: [\n            \"GROUP_CHARTS_ADMIN\",\n            \"GROUP_CLUSTER_MANAGER\",\n        ],\n        smsEnabled: false,\n        typeName: \"GROUP\",\n    }],\n    projectId: \"\u003cPROJECT-ID\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.AlertConfiguration(\"test\",\n    enabled=True,\n    event_type=\"OUTSIDE_METRIC_THRESHOLD\",\n    matchers=[mongodbatlas.AlertConfigurationMatcherArgs(\n        field_name=\"HOSTNAME_AND_PORT\",\n        operator=\"EQUALS\",\n        value=\"SECONDARY\",\n    )],\n    metric_threshold_config=mongodbatlas.AlertConfigurationMetricThresholdConfigArgs(\n        metric_name=\"ASSERT_REGULAR\",\n        mode=\"AVERAGE\",\n        operator=\"LESS_THAN\",\n        threshold=99,\n        units=\"RAW\",\n    ),\n    notifications=[mongodbatlas.AlertConfigurationNotificationArgs(\n        delay_min=0,\n        email_enabled=True,\n        interval_min=5,\n        roles=[\n            \"GROUP_CHARTS_ADMIN\",\n            \"GROUP_CLUSTER_MANAGER\",\n        ],\n        sms_enabled=False,\n        type_name=\"GROUP\",\n    )],\n    project_id=\"\u003cPROJECT-ID\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.AlertConfiguration(\"test\", new()\n    {\n        Enabled = true,\n        EventType = \"OUTSIDE_METRIC_THRESHOLD\",\n        Matchers = new[]\n        {\n            new Mongodbatlas.Inputs.AlertConfigurationMatcherArgs\n            {\n                FieldName = \"HOSTNAME_AND_PORT\",\n                Operator = \"EQUALS\",\n                Value = \"SECONDARY\",\n            },\n        },\n        MetricThresholdConfig = new Mongodbatlas.Inputs.AlertConfigurationMetricThresholdConfigArgs\n        {\n            MetricName = \"ASSERT_REGULAR\",\n            Mode = \"AVERAGE\",\n            Operator = \"LESS_THAN\",\n            Threshold = 99,\n            Units = \"RAW\",\n        },\n        Notifications = new[]\n        {\n            new Mongodbatlas.Inputs.AlertConfigurationNotificationArgs\n            {\n                DelayMin = 0,\n                EmailEnabled = true,\n                IntervalMin = 5,\n                Roles = new[]\n                {\n                    \"GROUP_CHARTS_ADMIN\",\n                    \"GROUP_CLUSTER_MANAGER\",\n                },\n                SmsEnabled = false,\n                TypeName = \"GROUP\",\n            },\n        },\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewAlertConfiguration(ctx, \"test\", \u0026mongodbatlas.AlertConfigurationArgs{\n\t\t\tEnabled:   pulumi.Bool(true),\n\t\t\tEventType: pulumi.String(\"OUTSIDE_METRIC_THRESHOLD\"),\n\t\t\tMatchers: mongodbatlas.AlertConfigurationMatcherArray{\n\t\t\t\t\u0026mongodbatlas.AlertConfigurationMatcherArgs{\n\t\t\t\t\tFieldName: pulumi.String(\"HOSTNAME_AND_PORT\"),\n\t\t\t\t\tOperator:  pulumi.String(\"EQUALS\"),\n\t\t\t\t\tValue:     pulumi.String(\"SECONDARY\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tMetricThresholdConfig: \u0026mongodbatlas.AlertConfigurationMetricThresholdConfigArgs{\n\t\t\t\tMetricName: pulumi.String(\"ASSERT_REGULAR\"),\n\t\t\t\tMode:       pulumi.String(\"AVERAGE\"),\n\t\t\t\tOperator:   pulumi.String(\"LESS_THAN\"),\n\t\t\t\tThreshold:  pulumi.Float64(99),\n\t\t\t\tUnits:      pulumi.String(\"RAW\"),\n\t\t\t},\n\t\t\tNotifications: mongodbatlas.AlertConfigurationNotificationArray{\n\t\t\t\t\u0026mongodbatlas.AlertConfigurationNotificationArgs{\n\t\t\t\t\tDelayMin:     pulumi.Int(0),\n\t\t\t\t\tEmailEnabled: pulumi.Bool(true),\n\t\t\t\t\tIntervalMin:  pulumi.Int(5),\n\t\t\t\t\tRoles: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_CHARTS_ADMIN\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_CLUSTER_MANAGER\"),\n\t\t\t\t\t},\n\t\t\t\t\tSmsEnabled: pulumi.Bool(false),\n\t\t\t\t\tTypeName:   pulumi.String(\"GROUP\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AlertConfiguration;\nimport com.pulumi.mongodbatlas.AlertConfigurationArgs;\nimport com.pulumi.mongodbatlas.inputs.AlertConfigurationMatcherArgs;\nimport com.pulumi.mongodbatlas.inputs.AlertConfigurationMetricThresholdConfigArgs;\nimport com.pulumi.mongodbatlas.inputs.AlertConfigurationNotificationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new AlertConfiguration(\"test\", AlertConfigurationArgs.builder()        \n            .enabled(true)\n            .eventType(\"OUTSIDE_METRIC_THRESHOLD\")\n            .matchers(AlertConfigurationMatcherArgs.builder()\n                .fieldName(\"HOSTNAME_AND_PORT\")\n                .operator(\"EQUALS\")\n                .value(\"SECONDARY\")\n                .build())\n            .metricThresholdConfig(AlertConfigurationMetricThresholdConfigArgs.builder()\n                .metricName(\"ASSERT_REGULAR\")\n                .mode(\"AVERAGE\")\n                .operator(\"LESS_THAN\")\n                .threshold(99)\n                .units(\"RAW\")\n                .build())\n            .notifications(AlertConfigurationNotificationArgs.builder()\n                .delayMin(0)\n                .emailEnabled(true)\n                .intervalMin(5)\n                .roles(                \n                    \"GROUP_CHARTS_ADMIN\",\n                    \"GROUP_CLUSTER_MANAGER\")\n                .smsEnabled(false)\n                .typeName(\"GROUP\")\n                .build())\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:AlertConfiguration\n    properties:\n      enabled: true\n      eventType: OUTSIDE_METRIC_THRESHOLD\n      matchers:\n        - fieldName: HOSTNAME_AND_PORT\n          operator: EQUALS\n          value: SECONDARY\n      metricThresholdConfig:\n        metricName: ASSERT_REGULAR\n        mode: AVERAGE\n        operator: LESS_THAN\n        threshold: 99\n        units: RAW\n      notifications:\n        - delayMin: 0\n          emailEnabled: true\n          intervalMin: 5\n          roles:\n            - GROUP_CHARTS_ADMIN\n            - GROUP_CLUSTER_MANAGER\n          smsEnabled: false\n          typeName: GROUP\n      projectId: \u003cPROJECT-ID\u003e\n```\n\n\u003e **NOTE:** In order to allow for a fast pace of change to alert variables some validations have been removed from this resource in order to unblock alert creation. Impacted areas have links to the MongoDB Atlas API documentation so always check it for the most current information: https://docs.atlas.mongodb.com/reference/api/alert-configurations-create-config/\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.AlertConfiguration(\"test\", {\n    enabled: true,\n    eventType: \"REPLICATION_OPLOG_WINDOW_RUNNING_OUT\",\n    matchers: [{\n        fieldName: \"HOSTNAME_AND_PORT\",\n        operator: \"EQUALS\",\n        value: \"SECONDARY\",\n    }],\n    notifications: [{\n        delayMin: 0,\n        emailEnabled: true,\n        intervalMin: 5,\n        roles: [\n            \"GROUP_CHARTS_ADMIN\",\n            \"GROUP_CLUSTER_MANAGER\",\n        ],\n        smsEnabled: false,\n        typeName: \"GROUP\",\n    }],\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    thresholdConfig: {\n        operator: \"LESS_THAN\",\n        threshold: 1,\n        units: \"HOURS\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.AlertConfiguration(\"test\",\n    enabled=True,\n    event_type=\"REPLICATION_OPLOG_WINDOW_RUNNING_OUT\",\n    matchers=[mongodbatlas.AlertConfigurationMatcherArgs(\n        field_name=\"HOSTNAME_AND_PORT\",\n        operator=\"EQUALS\",\n        value=\"SECONDARY\",\n    )],\n    notifications=[mongodbatlas.AlertConfigurationNotificationArgs(\n        delay_min=0,\n        email_enabled=True,\n        interval_min=5,\n        roles=[\n            \"GROUP_CHARTS_ADMIN\",\n            \"GROUP_CLUSTER_MANAGER\",\n        ],\n        sms_enabled=False,\n        type_name=\"GROUP\",\n    )],\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    threshold_config=mongodbatlas.AlertConfigurationThresholdConfigArgs(\n        operator=\"LESS_THAN\",\n        threshold=1,\n        units=\"HOURS\",\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.AlertConfiguration(\"test\", new()\n    {\n        Enabled = true,\n        EventType = \"REPLICATION_OPLOG_WINDOW_RUNNING_OUT\",\n        Matchers = new[]\n        {\n            new Mongodbatlas.Inputs.AlertConfigurationMatcherArgs\n            {\n                FieldName = \"HOSTNAME_AND_PORT\",\n                Operator = \"EQUALS\",\n                Value = \"SECONDARY\",\n            },\n        },\n        Notifications = new[]\n        {\n            new Mongodbatlas.Inputs.AlertConfigurationNotificationArgs\n            {\n                DelayMin = 0,\n                EmailEnabled = true,\n                IntervalMin = 5,\n                Roles = new[]\n                {\n                    \"GROUP_CHARTS_ADMIN\",\n                    \"GROUP_CLUSTER_MANAGER\",\n                },\n                SmsEnabled = false,\n                TypeName = \"GROUP\",\n            },\n        },\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        ThresholdConfig = new Mongodbatlas.Inputs.AlertConfigurationThresholdConfigArgs\n        {\n            Operator = \"LESS_THAN\",\n            Threshold = 1,\n            Units = \"HOURS\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewAlertConfiguration(ctx, \"test\", \u0026mongodbatlas.AlertConfigurationArgs{\n\t\t\tEnabled:   pulumi.Bool(true),\n\t\t\tEventType: pulumi.String(\"REPLICATION_OPLOG_WINDOW_RUNNING_OUT\"),\n\t\t\tMatchers: mongodbatlas.AlertConfigurationMatcherArray{\n\t\t\t\t\u0026mongodbatlas.AlertConfigurationMatcherArgs{\n\t\t\t\t\tFieldName: pulumi.String(\"HOSTNAME_AND_PORT\"),\n\t\t\t\t\tOperator:  pulumi.String(\"EQUALS\"),\n\t\t\t\t\tValue:     pulumi.String(\"SECONDARY\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tNotifications: mongodbatlas.AlertConfigurationNotificationArray{\n\t\t\t\t\u0026mongodbatlas.AlertConfigurationNotificationArgs{\n\t\t\t\t\tDelayMin:     pulumi.Int(0),\n\t\t\t\t\tEmailEnabled: pulumi.Bool(true),\n\t\t\t\t\tIntervalMin:  pulumi.Int(5),\n\t\t\t\t\tRoles: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_CHARTS_ADMIN\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_CLUSTER_MANAGER\"),\n\t\t\t\t\t},\n\t\t\t\t\tSmsEnabled: pulumi.Bool(false),\n\t\t\t\t\tTypeName:   pulumi.String(\"GROUP\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tThresholdConfig: \u0026mongodbatlas.AlertConfigurationThresholdConfigArgs{\n\t\t\t\tOperator:  pulumi.String(\"LESS_THAN\"),\n\t\t\t\tThreshold: pulumi.Float64(1),\n\t\t\t\tUnits:     pulumi.String(\"HOURS\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AlertConfiguration;\nimport com.pulumi.mongodbatlas.AlertConfigurationArgs;\nimport com.pulumi.mongodbatlas.inputs.AlertConfigurationMatcherArgs;\nimport com.pulumi.mongodbatlas.inputs.AlertConfigurationNotificationArgs;\nimport com.pulumi.mongodbatlas.inputs.AlertConfigurationThresholdConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new AlertConfiguration(\"test\", AlertConfigurationArgs.builder()        \n            .enabled(true)\n            .eventType(\"REPLICATION_OPLOG_WINDOW_RUNNING_OUT\")\n            .matchers(AlertConfigurationMatcherArgs.builder()\n                .fieldName(\"HOSTNAME_AND_PORT\")\n                .operator(\"EQUALS\")\n                .value(\"SECONDARY\")\n                .build())\n            .notifications(AlertConfigurationNotificationArgs.builder()\n                .delayMin(0)\n                .emailEnabled(true)\n                .intervalMin(5)\n                .roles(                \n                    \"GROUP_CHARTS_ADMIN\",\n                    \"GROUP_CLUSTER_MANAGER\")\n                .smsEnabled(false)\n                .typeName(\"GROUP\")\n                .build())\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .thresholdConfig(AlertConfigurationThresholdConfigArgs.builder()\n                .operator(\"LESS_THAN\")\n                .threshold(1)\n                .units(\"HOURS\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:AlertConfiguration\n    properties:\n      enabled: true\n      eventType: REPLICATION_OPLOG_WINDOW_RUNNING_OUT\n      matchers:\n        - fieldName: HOSTNAME_AND_PORT\n          operator: EQUALS\n          value: SECONDARY\n      notifications:\n        - delayMin: 0\n          emailEnabled: true\n          intervalMin: 5\n          roles:\n            - GROUP_CHARTS_ADMIN\n            - GROUP_CLUSTER_MANAGER\n          smsEnabled: false\n          typeName: GROUP\n      projectId: \u003cPROJECT-ID\u003e\n      thresholdConfig:\n        operator: LESS_THAN\n        threshold: 1\n        units: HOURS\n```\n{{% /example %}}\n{{% example %}}\n### Create an alert with two notifications using Email and SMS\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.AlertConfiguration(\"test\", {\n    enabled: true,\n    eventType: \"OUTSIDE_METRIC_THRESHOLD\",\n    matchers: [{\n        fieldName: \"HOSTNAME_AND_PORT\",\n        operator: \"EQUALS\",\n        value: \"SECONDARY\",\n    }],\n    metricThresholdConfig: {\n        metricName: \"ASSERT_REGULAR\",\n        mode: \"AVERAGE\",\n        operator: \"LESS_THAN\",\n        threshold: 99,\n        units: \"RAW\",\n    },\n    notifications: [\n        {\n            delayMin: 0,\n            emailEnabled: true,\n            intervalMin: 5,\n            roles: [\n                \"GROUP_DATA_ACCESS_READ_ONLY\",\n                \"GROUP_CLUSTER_MANAGER\",\n                \"GROUP_DATA_ACCESS_ADMIN\",\n            ],\n            smsEnabled: false,\n            typeName: \"GROUP\",\n        },\n        {\n            delayMin: 0,\n            emailEnabled: false,\n            intervalMin: 5,\n            smsEnabled: true,\n            typeName: \"ORG\",\n        },\n    ],\n    projectId: \"PROJECT ID\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.AlertConfiguration(\"test\",\n    enabled=True,\n    event_type=\"OUTSIDE_METRIC_THRESHOLD\",\n    matchers=[mongodbatlas.AlertConfigurationMatcherArgs(\n        field_name=\"HOSTNAME_AND_PORT\",\n        operator=\"EQUALS\",\n        value=\"SECONDARY\",\n    )],\n    metric_threshold_config=mongodbatlas.AlertConfigurationMetricThresholdConfigArgs(\n        metric_name=\"ASSERT_REGULAR\",\n        mode=\"AVERAGE\",\n        operator=\"LESS_THAN\",\n        threshold=99,\n        units=\"RAW\",\n    ),\n    notifications=[\n        mongodbatlas.AlertConfigurationNotificationArgs(\n            delay_min=0,\n            email_enabled=True,\n            interval_min=5,\n            roles=[\n                \"GROUP_DATA_ACCESS_READ_ONLY\",\n                \"GROUP_CLUSTER_MANAGER\",\n                \"GROUP_DATA_ACCESS_ADMIN\",\n            ],\n            sms_enabled=False,\n            type_name=\"GROUP\",\n        ),\n        mongodbatlas.AlertConfigurationNotificationArgs(\n            delay_min=0,\n            email_enabled=False,\n            interval_min=5,\n            sms_enabled=True,\n            type_name=\"ORG\",\n        ),\n    ],\n    project_id=\"PROJECT ID\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.AlertConfiguration(\"test\", new()\n    {\n        Enabled = true,\n        EventType = \"OUTSIDE_METRIC_THRESHOLD\",\n        Matchers = new[]\n        {\n            new Mongodbatlas.Inputs.AlertConfigurationMatcherArgs\n            {\n                FieldName = \"HOSTNAME_AND_PORT\",\n                Operator = \"EQUALS\",\n                Value = \"SECONDARY\",\n            },\n        },\n        MetricThresholdConfig = new Mongodbatlas.Inputs.AlertConfigurationMetricThresholdConfigArgs\n        {\n            MetricName = \"ASSERT_REGULAR\",\n            Mode = \"AVERAGE\",\n            Operator = \"LESS_THAN\",\n            Threshold = 99,\n            Units = \"RAW\",\n        },\n        Notifications = new[]\n        {\n            new Mongodbatlas.Inputs.AlertConfigurationNotificationArgs\n            {\n                DelayMin = 0,\n                EmailEnabled = true,\n                IntervalMin = 5,\n                Roles = new[]\n                {\n                    \"GROUP_DATA_ACCESS_READ_ONLY\",\n                    \"GROUP_CLUSTER_MANAGER\",\n                    \"GROUP_DATA_ACCESS_ADMIN\",\n                },\n                SmsEnabled = false,\n                TypeName = \"GROUP\",\n            },\n            new Mongodbatlas.Inputs.AlertConfigurationNotificationArgs\n            {\n                DelayMin = 0,\n                EmailEnabled = false,\n                IntervalMin = 5,\n                SmsEnabled = true,\n                TypeName = \"ORG\",\n            },\n        },\n        ProjectId = \"PROJECT ID\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewAlertConfiguration(ctx, \"test\", \u0026mongodbatlas.AlertConfigurationArgs{\n\t\t\tEnabled:   pulumi.Bool(true),\n\t\t\tEventType: pulumi.String(\"OUTSIDE_METRIC_THRESHOLD\"),\n\t\t\tMatchers: mongodbatlas.AlertConfigurationMatcherArray{\n\t\t\t\t\u0026mongodbatlas.AlertConfigurationMatcherArgs{\n\t\t\t\t\tFieldName: pulumi.String(\"HOSTNAME_AND_PORT\"),\n\t\t\t\t\tOperator:  pulumi.String(\"EQUALS\"),\n\t\t\t\t\tValue:     pulumi.String(\"SECONDARY\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tMetricThresholdConfig: \u0026mongodbatlas.AlertConfigurationMetricThresholdConfigArgs{\n\t\t\t\tMetricName: pulumi.String(\"ASSERT_REGULAR\"),\n\t\t\t\tMode:       pulumi.String(\"AVERAGE\"),\n\t\t\t\tOperator:   pulumi.String(\"LESS_THAN\"),\n\t\t\t\tThreshold:  pulumi.Float64(99),\n\t\t\t\tUnits:      pulumi.String(\"RAW\"),\n\t\t\t},\n\t\t\tNotifications: mongodbatlas.AlertConfigurationNotificationArray{\n\t\t\t\t\u0026mongodbatlas.AlertConfigurationNotificationArgs{\n\t\t\t\t\tDelayMin:     pulumi.Int(0),\n\t\t\t\t\tEmailEnabled: pulumi.Bool(true),\n\t\t\t\t\tIntervalMin:  pulumi.Int(5),\n\t\t\t\t\tRoles: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_READ_ONLY\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_CLUSTER_MANAGER\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_ADMIN\"),\n\t\t\t\t\t},\n\t\t\t\t\tSmsEnabled: pulumi.Bool(false),\n\t\t\t\t\tTypeName:   pulumi.String(\"GROUP\"),\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.AlertConfigurationNotificationArgs{\n\t\t\t\t\tDelayMin:     pulumi.Int(0),\n\t\t\t\t\tEmailEnabled: pulumi.Bool(false),\n\t\t\t\t\tIntervalMin:  pulumi.Int(5),\n\t\t\t\t\tSmsEnabled:   pulumi.Bool(true),\n\t\t\t\t\tTypeName:     pulumi.String(\"ORG\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tProjectId: pulumi.String(\"PROJECT ID\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AlertConfiguration;\nimport com.pulumi.mongodbatlas.AlertConfigurationArgs;\nimport com.pulumi.mongodbatlas.inputs.AlertConfigurationMatcherArgs;\nimport com.pulumi.mongodbatlas.inputs.AlertConfigurationMetricThresholdConfigArgs;\nimport com.pulumi.mongodbatlas.inputs.AlertConfigurationNotificationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new AlertConfiguration(\"test\", AlertConfigurationArgs.builder()        \n            .enabled(true)\n            .eventType(\"OUTSIDE_METRIC_THRESHOLD\")\n            .matchers(AlertConfigurationMatcherArgs.builder()\n                .fieldName(\"HOSTNAME_AND_PORT\")\n                .operator(\"EQUALS\")\n                .value(\"SECONDARY\")\n                .build())\n            .metricThresholdConfig(AlertConfigurationMetricThresholdConfigArgs.builder()\n                .metricName(\"ASSERT_REGULAR\")\n                .mode(\"AVERAGE\")\n                .operator(\"LESS_THAN\")\n                .threshold(99)\n                .units(\"RAW\")\n                .build())\n            .notifications(            \n                AlertConfigurationNotificationArgs.builder()\n                    .delayMin(0)\n                    .emailEnabled(true)\n                    .intervalMin(5)\n                    .roles(                    \n                        \"GROUP_DATA_ACCESS_READ_ONLY\",\n                        \"GROUP_CLUSTER_MANAGER\",\n                        \"GROUP_DATA_ACCESS_ADMIN\")\n                    .smsEnabled(false)\n                    .typeName(\"GROUP\")\n                    .build(),\n                AlertConfigurationNotificationArgs.builder()\n                    .delayMin(0)\n                    .emailEnabled(false)\n                    .intervalMin(5)\n                    .smsEnabled(true)\n                    .typeName(\"ORG\")\n                    .build())\n            .projectId(\"PROJECT ID\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:AlertConfiguration\n    properties:\n      enabled: true\n      eventType: OUTSIDE_METRIC_THRESHOLD\n      matchers:\n        - fieldName: HOSTNAME_AND_PORT\n          operator: EQUALS\n          value: SECONDARY\n      metricThresholdConfig:\n        metricName: ASSERT_REGULAR\n        mode: AVERAGE\n        operator: LESS_THAN\n        threshold: 99\n        units: RAW\n      notifications:\n        - delayMin: 0\n          emailEnabled: true\n          intervalMin: 5\n          roles:\n            - GROUP_DATA_ACCESS_READ_ONLY\n            - GROUP_CLUSTER_MANAGER\n            - GROUP_DATA_ACCESS_ADMIN\n          smsEnabled: false\n          typeName: GROUP\n        - delayMin: 0\n          emailEnabled: false\n          intervalMin: 5\n          smsEnabled: true\n          typeName: ORG\n      projectId: PROJECT ID\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAlert Configuration can be imported using the `project_id-alert_configuration_id`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/alertConfiguration:AlertConfiguration test 5d0f1f74cf09a29120e123cd-5d0f1f74cf09a29120e1fscg\n```\n\n For more information see[MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/alert-configurations/) ",
            "properties": {
                "alertConfigurationId": {
                    "type": "string",
                    "description": "Unique identifier for the alert configuration.\n"
                },
                "created": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when this alert configuration was created.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "It is not required, but If the attribute is omitted, by default will be false, and the configuration would be disabled. You must set true to enable the configuration.\n"
                },
                "eventType": {
                    "type": "string",
                    "description": "The type of event that will trigger an alert.\n"
                },
                "matchers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/AlertConfigurationMatcher:AlertConfigurationMatcher"
                    }
                },
                "metricThreshold": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "deprecationMessage": "use metric_threshold_config instead"
                },
                "metricThresholdConfig": {
                    "$ref": "#/types/mongodbatlas:index/AlertConfigurationMetricThresholdConfig:AlertConfigurationMetricThresholdConfig"
                },
                "notifications": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/AlertConfigurationNotification:AlertConfigurationNotification"
                    }
                },
                "projectId": {
                    "type": "string",
                    "description": "The ID of the project where the alert configuration will create.\n"
                },
                "threshold": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Threshold value outside of which an alert will be triggered.\n",
                    "deprecationMessage": "use threshold_config instead"
                },
                "thresholdConfig": {
                    "$ref": "#/types/mongodbatlas:index/AlertConfigurationThresholdConfig:AlertConfigurationThresholdConfig"
                },
                "updated": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when this alert configuration was last updated.\n"
                }
            },
            "required": [
                "alertConfigurationId",
                "created",
                "enabled",
                "eventType",
                "notifications",
                "projectId",
                "updated"
            ],
            "inputProperties": {
                "enabled": {
                    "type": "boolean",
                    "description": "It is not required, but If the attribute is omitted, by default will be false, and the configuration would be disabled. You must set true to enable the configuration.\n"
                },
                "eventType": {
                    "type": "string",
                    "description": "The type of event that will trigger an alert.\n"
                },
                "matchers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/AlertConfigurationMatcher:AlertConfigurationMatcher"
                    }
                },
                "metricThreshold": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "deprecationMessage": "use metric_threshold_config instead"
                },
                "metricThresholdConfig": {
                    "$ref": "#/types/mongodbatlas:index/AlertConfigurationMetricThresholdConfig:AlertConfigurationMetricThresholdConfig"
                },
                "notifications": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/AlertConfigurationNotification:AlertConfigurationNotification"
                    }
                },
                "projectId": {
                    "type": "string",
                    "description": "The ID of the project where the alert configuration will create.\n",
                    "willReplaceOnChanges": true
                },
                "threshold": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Threshold value outside of which an alert will be triggered.\n",
                    "deprecationMessage": "use threshold_config instead"
                },
                "thresholdConfig": {
                    "$ref": "#/types/mongodbatlas:index/AlertConfigurationThresholdConfig:AlertConfigurationThresholdConfig"
                }
            },
            "requiredInputs": [
                "eventType",
                "notifications",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AlertConfiguration resources.\n",
                "properties": {
                    "alertConfigurationId": {
                        "type": "string",
                        "description": "Unique identifier for the alert configuration.\n"
                    },
                    "created": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when this alert configuration was created.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "It is not required, but If the attribute is omitted, by default will be false, and the configuration would be disabled. You must set true to enable the configuration.\n"
                    },
                    "eventType": {
                        "type": "string",
                        "description": "The type of event that will trigger an alert.\n"
                    },
                    "matchers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/AlertConfigurationMatcher:AlertConfigurationMatcher"
                        }
                    },
                    "metricThreshold": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "deprecationMessage": "use metric_threshold_config instead"
                    },
                    "metricThresholdConfig": {
                        "$ref": "#/types/mongodbatlas:index/AlertConfigurationMetricThresholdConfig:AlertConfigurationMetricThresholdConfig"
                    },
                    "notifications": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/AlertConfigurationNotification:AlertConfigurationNotification"
                        }
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The ID of the project where the alert configuration will create.\n",
                        "willReplaceOnChanges": true
                    },
                    "threshold": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Threshold value outside of which an alert will be triggered.\n",
                        "deprecationMessage": "use threshold_config instead"
                    },
                    "thresholdConfig": {
                        "$ref": "#/types/mongodbatlas:index/AlertConfigurationThresholdConfig:AlertConfigurationThresholdConfig"
                    },
                    "updated": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when this alert configuration was last updated.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/apiKey:ApiKey": {
            "description": "\n\n## Import\n\nAPI Keys must be imported using org ID, API Key ID e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/apiKey:ApiKey test 5d09d6a59ccf6445652a444a-6576974933969669\n```\n\n See [MongoDB Atlas API - API Key](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Programmatic-API-Keys/operation/createOneOrganizationApiKey) - Documentation for more information. ",
            "properties": {
                "apiKeyId": {
                    "type": "string",
                    "description": "The unique identifier of the Programmatic API key you want to associate with the Project.  The Programmatic API key and Project must share the same parent organization.  Note: this is not the `publicKey` of the Programmatic API key but the `id` of the key. See [Programmatic API Keys](https://docs.atlas.mongodb.com/reference/api/apiKeys/) for more.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of this Organization API key.\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique identifier for the organization whose API keys you want to retrieve. Use the /orgs endpoint to retrieve all organizations to which the authenticated user has access.\n"
                },
                "privateKey": {
                    "type": "string",
                    "secret": true
                },
                "publicKey": {
                    "type": "string"
                },
                "roleNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Name of the role. This resource returns all the roles the user has in Atlas.\nThe following are valid roles:\n"
                }
            },
            "required": [
                "apiKeyId",
                "description",
                "orgId",
                "privateKey",
                "publicKey",
                "roleNames"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Description of this Organization API key.\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique identifier for the organization whose API keys you want to retrieve. Use the /orgs endpoint to retrieve all organizations to which the authenticated user has access.\n"
                },
                "roleNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Name of the role. This resource returns all the roles the user has in Atlas.\nThe following are valid roles:\n"
                }
            },
            "requiredInputs": [
                "description",
                "orgId",
                "roleNames"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ApiKey resources.\n",
                "properties": {
                    "apiKeyId": {
                        "type": "string",
                        "description": "The unique identifier of the Programmatic API key you want to associate with the Project.  The Programmatic API key and Project must share the same parent organization.  Note: this is not the `publicKey` of the Programmatic API key but the `id` of the key. See [Programmatic API Keys](https://docs.atlas.mongodb.com/reference/api/apiKeys/) for more.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of this Organization API key.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Unique identifier for the organization whose API keys you want to retrieve. Use the /orgs endpoint to retrieve all organizations to which the authenticated user has access.\n"
                    },
                    "privateKey": {
                        "type": "string",
                        "secret": true
                    },
                    "publicKey": {
                        "type": "string"
                    },
                    "roleNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Name of the role. This resource returns all the roles the user has in Atlas.\nThe following are valid roles:\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/auditing:Auditing": {
            "description": "`mongodbatlas.Auditing` provides an Auditing resource. This allows auditing to be created.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.Auditing(\"test\", {\n    auditAuthorizationSuccess: false,\n    auditFilter: \"{ 'atype': 'authenticate', 'param': {   'user': 'auditAdmin',   'db': 'admin',   'mechanism': 'SCRAM-SHA-1' }}\",\n    enabled: true,\n    projectId: \"\u003cproject-id\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.Auditing(\"test\",\n    audit_authorization_success=False,\n    audit_filter=\"{ 'atype': 'authenticate', 'param': {   'user': 'auditAdmin',   'db': 'admin',   'mechanism': 'SCRAM-SHA-1' }}\",\n    enabled=True,\n    project_id=\"\u003cproject-id\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.Auditing(\"test\", new()\n    {\n        AuditAuthorizationSuccess = false,\n        AuditFilter = \"{ 'atype': 'authenticate', 'param': {   'user': 'auditAdmin',   'db': 'admin',   'mechanism': 'SCRAM-SHA-1' }}\",\n        Enabled = true,\n        ProjectId = \"\u003cproject-id\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewAuditing(ctx, \"test\", \u0026mongodbatlas.AuditingArgs{\n\t\t\tAuditAuthorizationSuccess: pulumi.Bool(false),\n\t\t\tAuditFilter:               pulumi.String(\"{ 'atype': 'authenticate', 'param': {   'user': 'auditAdmin',   'db': 'admin',   'mechanism': 'SCRAM-SHA-1' }}\"),\n\t\t\tEnabled:                   pulumi.Bool(true),\n\t\t\tProjectId:                 pulumi.String(\"\u003cproject-id\u003e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Auditing;\nimport com.pulumi.mongodbatlas.AuditingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new Auditing(\"test\", AuditingArgs.builder()        \n            .auditAuthorizationSuccess(false)\n            .auditFilter(\"{ 'atype': 'authenticate', 'param': {   'user': 'auditAdmin',   'db': 'admin',   'mechanism': 'SCRAM-SHA-1' }}\")\n            .enabled(true)\n            .projectId(\"\u003cproject-id\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:Auditing\n    properties:\n      auditAuthorizationSuccess: false\n      auditFilter: '{ ''atype'': ''authenticate'', ''param'': {   ''user'': ''auditAdmin'',   ''db'': ''admin'',   ''mechanism'': ''SCRAM-SHA-1'' }}'\n      enabled: true\n      projectId: \u003cproject-id\u003e\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nAuditing must be imported using auditing ID, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/auditing:Auditing my_auditing 5d09d6a59ccf6445652a444a\n```\n\n For more information see[MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/auditing/) ",
            "properties": {
                "auditAuthorizationSuccess": {
                    "type": "boolean",
                    "description": "Indicates whether the auditing system captures successful authentication attempts for audit filters using the \"atype\" : \"authCheck\" auditing event. For more information, see [auditAuthorizationSuccess](https://docs.mongodb.com/manual/reference/parameters/#param.auditAuthorizationSuccess).  **Warning! Enabling Audit authorization successes can severely impact cluster performance. Enable this option with caution.**\n"
                },
                "auditFilter": {
                    "type": "string",
                    "description": "JSON-formatted audit filter. For complete documentation on custom auditing filters, see [Configure Audit Filters](https://docs.mongodb.com/manual/tutorial/configure-audit-filters/).\n"
                },
                "configurationType": {
                    "type": "string",
                    "description": "Denotes the configuration method for the audit filter. Possible values are: \n* NONE - auditing not configured for the project.\n* FILTER_BUILDER - auditing configured via Atlas UI filter builder.\n* FILTER_JSON - auditing configured via Atlas custom filter or API.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Denotes whether or not the project associated with the {project_id} has database auditing enabled.  Defaults to false.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to configure auditing.\n"
                }
            },
            "required": [
                "auditAuthorizationSuccess",
                "auditFilter",
                "configurationType",
                "enabled",
                "projectId"
            ],
            "inputProperties": {
                "auditAuthorizationSuccess": {
                    "type": "boolean",
                    "description": "Indicates whether the auditing system captures successful authentication attempts for audit filters using the \"atype\" : \"authCheck\" auditing event. For more information, see [auditAuthorizationSuccess](https://docs.mongodb.com/manual/reference/parameters/#param.auditAuthorizationSuccess).  **Warning! Enabling Audit authorization successes can severely impact cluster performance. Enable this option with caution.**\n"
                },
                "auditFilter": {
                    "type": "string",
                    "description": "JSON-formatted audit filter. For complete documentation on custom auditing filters, see [Configure Audit Filters](https://docs.mongodb.com/manual/tutorial/configure-audit-filters/).\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Denotes whether or not the project associated with the {project_id} has database auditing enabled.  Defaults to false.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to configure auditing.\n"
                }
            },
            "requiredInputs": [
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Auditing resources.\n",
                "properties": {
                    "auditAuthorizationSuccess": {
                        "type": "boolean",
                        "description": "Indicates whether the auditing system captures successful authentication attempts for audit filters using the \"atype\" : \"authCheck\" auditing event. For more information, see [auditAuthorizationSuccess](https://docs.mongodb.com/manual/reference/parameters/#param.auditAuthorizationSuccess).  **Warning! Enabling Audit authorization successes can severely impact cluster performance. Enable this option with caution.**\n"
                    },
                    "auditFilter": {
                        "type": "string",
                        "description": "JSON-formatted audit filter. For complete documentation on custom auditing filters, see [Configure Audit Filters](https://docs.mongodb.com/manual/tutorial/configure-audit-filters/).\n"
                    },
                    "configurationType": {
                        "type": "string",
                        "description": "Denotes the configuration method for the audit filter. Possible values are: \n* NONE - auditing not configured for the project.\n* FILTER_BUILDER - auditing configured via Atlas UI filter builder.\n* FILTER_JSON - auditing configured via Atlas custom filter or API.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Denotes whether or not the project associated with the {project_id} has database auditing enabled.  Defaults to false.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to configure auditing.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/cloudBackupSchedule:CloudBackupSchedule": {
            "description": "\n\n\n## Import\n\nCloud Backup Schedule entries can be imported using project_id and cluster_name, in the format `PROJECTID-CLUSTERNAME`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/cloudBackupSchedule:CloudBackupSchedule test 5d0f1f73cf09a29120e173cf-MyClusterTest\n```\n\n For more information see[MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/cloud-backup/schedule/modify-one-schedule/) ",
            "properties": {
                "autoExportEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether automatic export of cloud backup snapshots to the AWS bucket is enabled. Value can be one of the following:\n"
                },
                "clusterId": {
                    "type": "string",
                    "description": "Unique identifier of the Atlas cluster.\n"
                },
                "clusterName": {
                    "type": "string",
                    "description": "The name of the Atlas cluster that contains the snapshot backup policy you want to retrieve.\n"
                },
                "copySettings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupScheduleCopySetting:CloudBackupScheduleCopySetting"
                    }
                },
                "export": {
                    "$ref": "#/types/mongodbatlas:index/CloudBackupScheduleExport:CloudBackupScheduleExport"
                },
                "idPolicy": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy.\n"
                },
                "nextSnapshot": {
                    "type": "string",
                    "description": "Timestamp in the number of seconds that have elapsed since the UNIX epoch when Atlas takes the next snapshot.\n"
                },
                "policyItemDaily": {
                    "$ref": "#/types/mongodbatlas:index/CloudBackupSchedulePolicyItemDaily:CloudBackupSchedulePolicyItemDaily",
                    "description": "Daily policy item\n"
                },
                "policyItemHourly": {
                    "$ref": "#/types/mongodbatlas:index/CloudBackupSchedulePolicyItemHourly:CloudBackupSchedulePolicyItemHourly",
                    "description": "Hourly policy item\n"
                },
                "policyItemMonthlies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupSchedulePolicyItemMonthly:CloudBackupSchedulePolicyItemMonthly"
                    },
                    "description": "Monthly policy item\n"
                },
                "policyItemWeeklies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupSchedulePolicyItemWeekly:CloudBackupSchedulePolicyItemWeekly"
                    },
                    "description": "Weekly policy item\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier of the project for the Atlas cluster.\n"
                },
                "referenceHourOfDay": {
                    "type": "integer",
                    "description": "UTC Hour of day between 0 and 23, inclusive, representing which hour of the day that Atlas takes snapshots for backup policy items.\n"
                },
                "referenceMinuteOfHour": {
                    "type": "integer",
                    "description": "UTC Minutes after `reference_hour_of_day` that Atlas takes snapshots for backup policy items. Must be between 0 and 59, inclusive.\n"
                },
                "restoreWindowDays": {
                    "type": "integer",
                    "description": "Number of days back in time you can restore to with point-in-time accuracy. Must be a positive, non-zero integer.\n"
                },
                "updateSnapshots": {
                    "type": "boolean",
                    "description": "Specify true to apply the retention changes in the updated backup policy to snapshots that Atlas took previously.\n"
                },
                "useOrgAndGroupNamesInExportPrefix": {
                    "type": "boolean",
                    "description": "Specify true to use organization and project names instead of organization and project UUIDs in the path for the metadata files that Atlas uploads to your S3 bucket after it finishes exporting the snapshots. To learn more about the metadata files that Atlas uploads, see [Export Cloud Backup Snapshot](https://www.mongodb.com/docs/atlas/backup/cloud-backup/export/#std-label-cloud-provider-snapshot-export).\n"
                }
            },
            "required": [
                "autoExportEnabled",
                "clusterId",
                "clusterName",
                "export",
                "idPolicy",
                "nextSnapshot",
                "projectId",
                "referenceHourOfDay",
                "referenceMinuteOfHour",
                "restoreWindowDays",
                "updateSnapshots",
                "useOrgAndGroupNamesInExportPrefix"
            ],
            "inputProperties": {
                "autoExportEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether automatic export of cloud backup snapshots to the AWS bucket is enabled. Value can be one of the following:\n"
                },
                "clusterName": {
                    "type": "string",
                    "description": "The name of the Atlas cluster that contains the snapshot backup policy you want to retrieve.\n"
                },
                "copySettings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupScheduleCopySetting:CloudBackupScheduleCopySetting"
                    }
                },
                "export": {
                    "$ref": "#/types/mongodbatlas:index/CloudBackupScheduleExport:CloudBackupScheduleExport"
                },
                "policyItemDaily": {
                    "$ref": "#/types/mongodbatlas:index/CloudBackupSchedulePolicyItemDaily:CloudBackupSchedulePolicyItemDaily",
                    "description": "Daily policy item\n"
                },
                "policyItemHourly": {
                    "$ref": "#/types/mongodbatlas:index/CloudBackupSchedulePolicyItemHourly:CloudBackupSchedulePolicyItemHourly",
                    "description": "Hourly policy item\n"
                },
                "policyItemMonthlies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupSchedulePolicyItemMonthly:CloudBackupSchedulePolicyItemMonthly"
                    },
                    "description": "Monthly policy item\n"
                },
                "policyItemWeeklies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupSchedulePolicyItemWeekly:CloudBackupSchedulePolicyItemWeekly"
                    },
                    "description": "Weekly policy item\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier of the project for the Atlas cluster.\n",
                    "willReplaceOnChanges": true
                },
                "referenceHourOfDay": {
                    "type": "integer",
                    "description": "UTC Hour of day between 0 and 23, inclusive, representing which hour of the day that Atlas takes snapshots for backup policy items.\n"
                },
                "referenceMinuteOfHour": {
                    "type": "integer",
                    "description": "UTC Minutes after `reference_hour_of_day` that Atlas takes snapshots for backup policy items. Must be between 0 and 59, inclusive.\n"
                },
                "restoreWindowDays": {
                    "type": "integer",
                    "description": "Number of days back in time you can restore to with point-in-time accuracy. Must be a positive, non-zero integer.\n"
                },
                "updateSnapshots": {
                    "type": "boolean",
                    "description": "Specify true to apply the retention changes in the updated backup policy to snapshots that Atlas took previously.\n"
                },
                "useOrgAndGroupNamesInExportPrefix": {
                    "type": "boolean",
                    "description": "Specify true to use organization and project names instead of organization and project UUIDs in the path for the metadata files that Atlas uploads to your S3 bucket after it finishes exporting the snapshots. To learn more about the metadata files that Atlas uploads, see [Export Cloud Backup Snapshot](https://www.mongodb.com/docs/atlas/backup/cloud-backup/export/#std-label-cloud-provider-snapshot-export).\n"
                }
            },
            "requiredInputs": [
                "clusterName",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudBackupSchedule resources.\n",
                "properties": {
                    "autoExportEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether automatic export of cloud backup snapshots to the AWS bucket is enabled. Value can be one of the following:\n"
                    },
                    "clusterId": {
                        "type": "string",
                        "description": "Unique identifier of the Atlas cluster.\n"
                    },
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the Atlas cluster that contains the snapshot backup policy you want to retrieve.\n"
                    },
                    "copySettings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/CloudBackupScheduleCopySetting:CloudBackupScheduleCopySetting"
                        }
                    },
                    "export": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupScheduleExport:CloudBackupScheduleExport"
                    },
                    "idPolicy": {
                        "type": "string",
                        "description": "Unique identifier of the backup policy.\n"
                    },
                    "nextSnapshot": {
                        "type": "string",
                        "description": "Timestamp in the number of seconds that have elapsed since the UNIX epoch when Atlas takes the next snapshot.\n"
                    },
                    "policyItemDaily": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupSchedulePolicyItemDaily:CloudBackupSchedulePolicyItemDaily",
                        "description": "Daily policy item\n"
                    },
                    "policyItemHourly": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupSchedulePolicyItemHourly:CloudBackupSchedulePolicyItemHourly",
                        "description": "Hourly policy item\n"
                    },
                    "policyItemMonthlies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/CloudBackupSchedulePolicyItemMonthly:CloudBackupSchedulePolicyItemMonthly"
                        },
                        "description": "Monthly policy item\n"
                    },
                    "policyItemWeeklies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/CloudBackupSchedulePolicyItemWeekly:CloudBackupSchedulePolicyItemWeekly"
                        },
                        "description": "Weekly policy item\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster.\n",
                        "willReplaceOnChanges": true
                    },
                    "referenceHourOfDay": {
                        "type": "integer",
                        "description": "UTC Hour of day between 0 and 23, inclusive, representing which hour of the day that Atlas takes snapshots for backup policy items.\n"
                    },
                    "referenceMinuteOfHour": {
                        "type": "integer",
                        "description": "UTC Minutes after `reference_hour_of_day` that Atlas takes snapshots for backup policy items. Must be between 0 and 59, inclusive.\n"
                    },
                    "restoreWindowDays": {
                        "type": "integer",
                        "description": "Number of days back in time you can restore to with point-in-time accuracy. Must be a positive, non-zero integer.\n"
                    },
                    "updateSnapshots": {
                        "type": "boolean",
                        "description": "Specify true to apply the retention changes in the updated backup policy to snapshots that Atlas took previously.\n"
                    },
                    "useOrgAndGroupNamesInExportPrefix": {
                        "type": "boolean",
                        "description": "Specify true to use organization and project names instead of organization and project UUIDs in the path for the metadata files that Atlas uploads to your S3 bucket after it finishes exporting the snapshots. To learn more about the metadata files that Atlas uploads, see [Export Cloud Backup Snapshot](https://www.mongodb.com/docs/atlas/backup/cloud-backup/export/#std-label-cloud-provider-snapshot-export).\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/cloudBackupSnapshot:CloudBackupSnapshot": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Cluster;\nimport com.pulumi.mongodbatlas.ClusterArgs;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshot;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotArgs;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotRestoreJob;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotRestoreJobArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myCluster = new Cluster(\"myCluster\", ClusterArgs.builder()        \n            .projectId(\"5cf5a45a9ccf6400e60981b6\")\n            .diskSizeGb(5)\n            .providerName(\"AWS\")\n            .providerRegionName(\"EU_WEST_2\")\n            .providerInstanceSizeName(\"M10\")\n            .cloudBackup(true)\n            .build());\n\n        var testCloudBackupSnapshot = new CloudBackupSnapshot(\"testCloudBackupSnapshot\", CloudBackupSnapshotArgs.builder()        \n            .projectId(myCluster.projectId())\n            .clusterName(myCluster.name())\n            .description(\"myDescription\")\n            .retentionInDays(1)\n            .build());\n\n        var testCloudBackupSnapshotRestoreJob = new CloudBackupSnapshotRestoreJob(\"testCloudBackupSnapshotRestoreJob\", CloudBackupSnapshotRestoreJobArgs.builder()        \n            .projectId(testCloudBackupSnapshot.projectId())\n            .clusterName(testCloudBackupSnapshot.clusterName())\n            .snapshotId(testCloudBackupSnapshot.snapshotId())\n            .deliveryType(Map.of(\"download\", true))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myCluster:\n    type: mongodbatlas:Cluster\n    properties:\n      projectId: 5cf5a45a9ccf6400e60981b6\n      diskSizeGb: 5\n      # Provider Settings \"block\"\n      providerName: AWS\n      providerRegionName: EU_WEST_2\n      providerInstanceSizeName: M10\n      cloudBackup: true\n  testCloudBackupSnapshot:\n    type: mongodbatlas:CloudBackupSnapshot\n    properties:\n      projectId: ${myCluster.projectId}\n      clusterName: ${myCluster.name}\n      description: myDescription\n      retentionInDays: 1\n  testCloudBackupSnapshotRestoreJob:\n    type: mongodbatlas:CloudBackupSnapshotRestoreJob\n    properties:\n      projectId: ${testCloudBackupSnapshot.projectId}\n      clusterName: ${testCloudBackupSnapshot.clusterName}\n      snapshotId: ${testCloudBackupSnapshot.snapshotId}\n      deliveryType:\n        - download: true\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nCloud Backup Snapshot entries can be imported using project project_id, cluster_name and snapshot_id (Unique identifier of the snapshot), in the format `PROJECTID-CLUSTERNAME-SNAPSHOTID`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/cloudBackupSnapshot:CloudBackupSnapshot test 5d0f1f73cf09a29120e173cf-MyClusterTest-5d116d82014b764445b2f9b5\n```\n\n For more information see[MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/cloud-backup/backup/backups/) ",
            "properties": {
                "cloudProvider": {
                    "type": "string",
                    "description": "Cloud provider that stores this snapshot.\n"
                },
                "clusterName": {
                    "type": "string",
                    "description": "The name of the Atlas cluster that contains the snapshots you want to retrieve.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "UTC ISO 8601 formatted point in time when Atlas took the snapshot.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the on-demand snapshot.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "UTC ISO 8601 formatted point in time when Atlas will delete the snapshot.\n"
                },
                "masterKeyUuid": {
                    "type": "string",
                    "description": "Unique ID of the AWS KMS Customer Master Key used to encrypt the snapshot. Only visible for clusters using Encryption at Rest via Customer KMS.\n"
                },
                "members": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupSnapshotMember:CloudBackupSnapshotMember"
                    },
                    "description": "Block of List of snapshots and the cloud provider where the snapshots are stored. Atlas returns this parameter when `type` is `shardedCluster`. See below\n"
                },
                "mongodVersion": {
                    "type": "string",
                    "description": "Version of the MongoDB server.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier of the project for the Atlas cluster.\n"
                },
                "replicaSetName": {
                    "type": "string",
                    "description": "Label given to a shard or config server from which Atlas took this snapshot.\n"
                },
                "retentionInDays": {
                    "type": "integer",
                    "description": "The number of days that Atlas should retain the on-demand snapshot. Must be at least 1.\n"
                },
                "snapshotId": {
                    "type": "string",
                    "description": "Unique identifier of the snapshot.\n"
                },
                "snapshotIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Unique identifiers of the snapshots created for the shards and config server for a sharded cluster. Atlas returns this parameter when `type` is `shardedCluster`. These identifiers should match those given in the `members[n].id` parameters. This allows you to map a snapshot to its shard or config server name.\n"
                },
                "snapshotType": {
                    "type": "string",
                    "description": "Specified the type of snapshot. Valid values are onDemand and scheduled.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Current status of the snapshot. One of the following values will be returned: queued, inProgress, completed, failed.\n"
                },
                "storageSizeBytes": {
                    "type": "integer",
                    "description": "Specifies the size of the snapshot in bytes.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Specifies the type of cluster: replicaSet or shardedCluster.\n"
                }
            },
            "required": [
                "cloudProvider",
                "clusterName",
                "createdAt",
                "description",
                "expiresAt",
                "masterKeyUuid",
                "members",
                "mongodVersion",
                "projectId",
                "replicaSetName",
                "retentionInDays",
                "snapshotId",
                "snapshotIds",
                "snapshotType",
                "status",
                "storageSizeBytes",
                "type"
            ],
            "inputProperties": {
                "clusterName": {
                    "type": "string",
                    "description": "The name of the Atlas cluster that contains the snapshots you want to retrieve.\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "Description of the on-demand snapshot.\n",
                    "willReplaceOnChanges": true
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier of the project for the Atlas cluster.\n",
                    "willReplaceOnChanges": true
                },
                "retentionInDays": {
                    "type": "integer",
                    "description": "The number of days that Atlas should retain the on-demand snapshot. Must be at least 1.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "clusterName",
                "description",
                "projectId",
                "retentionInDays"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudBackupSnapshot resources.\n",
                "properties": {
                    "cloudProvider": {
                        "type": "string",
                        "description": "Cloud provider that stores this snapshot.\n"
                    },
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the Atlas cluster that contains the snapshots you want to retrieve.\n",
                        "willReplaceOnChanges": true
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "UTC ISO 8601 formatted point in time when Atlas took the snapshot.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the on-demand snapshot.\n",
                        "willReplaceOnChanges": true
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "UTC ISO 8601 formatted point in time when Atlas will delete the snapshot.\n"
                    },
                    "masterKeyUuid": {
                        "type": "string",
                        "description": "Unique ID of the AWS KMS Customer Master Key used to encrypt the snapshot. Only visible for clusters using Encryption at Rest via Customer KMS.\n"
                    },
                    "members": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/CloudBackupSnapshotMember:CloudBackupSnapshotMember"
                        },
                        "description": "Block of List of snapshots and the cloud provider where the snapshots are stored. Atlas returns this parameter when `type` is `shardedCluster`. See below\n"
                    },
                    "mongodVersion": {
                        "type": "string",
                        "description": "Version of the MongoDB server.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster.\n",
                        "willReplaceOnChanges": true
                    },
                    "replicaSetName": {
                        "type": "string",
                        "description": "Label given to a shard or config server from which Atlas took this snapshot.\n"
                    },
                    "retentionInDays": {
                        "type": "integer",
                        "description": "The number of days that Atlas should retain the on-demand snapshot. Must be at least 1.\n",
                        "willReplaceOnChanges": true
                    },
                    "snapshotId": {
                        "type": "string",
                        "description": "Unique identifier of the snapshot.\n"
                    },
                    "snapshotIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Unique identifiers of the snapshots created for the shards and config server for a sharded cluster. Atlas returns this parameter when `type` is `shardedCluster`. These identifiers should match those given in the `members[n].id` parameters. This allows you to map a snapshot to its shard or config server name.\n"
                    },
                    "snapshotType": {
                        "type": "string",
                        "description": "Specified the type of snapshot. Valid values are onDemand and scheduled.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Current status of the snapshot. One of the following values will be returned: queued, inProgress, completed, failed.\n"
                    },
                    "storageSizeBytes": {
                        "type": "integer",
                        "description": "Specifies the size of the snapshot in bytes.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Specifies the type of cluster: replicaSet or shardedCluster.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/cloudBackupSnapshotExportBucket:CloudBackupSnapshotExportBucket": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.CloudBackupSnapshotExportBucket(\"test\", {\n    bucketName: \"example-bucket\",\n    cloudProvider: \"AWS\",\n    iamRoleId: \"{IAM_ROLE_ID}\",\n    projectId: \"{PROJECT_ID}\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.CloudBackupSnapshotExportBucket(\"test\",\n    bucket_name=\"example-bucket\",\n    cloud_provider=\"AWS\",\n    iam_role_id=\"{IAM_ROLE_ID}\",\n    project_id=\"{PROJECT_ID}\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.CloudBackupSnapshotExportBucket(\"test\", new()\n    {\n        BucketName = \"example-bucket\",\n        CloudProvider = \"AWS\",\n        IamRoleId = \"{IAM_ROLE_ID}\",\n        ProjectId = \"{PROJECT_ID}\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewCloudBackupSnapshotExportBucket(ctx, \"test\", \u0026mongodbatlas.CloudBackupSnapshotExportBucketArgs{\n\t\t\tBucketName:    pulumi.String(\"example-bucket\"),\n\t\t\tCloudProvider: pulumi.String(\"AWS\"),\n\t\t\tIamRoleId:     pulumi.String(\"{IAM_ROLE_ID}\"),\n\t\t\tProjectId:     pulumi.String(\"{PROJECT_ID}\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportBucket;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportBucketArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new CloudBackupSnapshotExportBucket(\"test\", CloudBackupSnapshotExportBucketArgs.builder()        \n            .bucketName(\"example-bucket\")\n            .cloudProvider(\"AWS\")\n            .iamRoleId(\"{IAM_ROLE_ID}\")\n            .projectId(\"{PROJECT_ID}\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:CloudBackupSnapshotExportBucket\n    properties:\n      bucketName: example-bucket\n      cloudProvider: AWS\n      iamRoleId: '{IAM_ROLE_ID}'\n      projectId: '{PROJECT_ID}'\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nCloud Backup Snapshot Export Backup entries can be imported using project project_id, and bucket_id (Unique identifier of the snapshot export bucket), in the format `PROJECTID-BUCKETID`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/cloudBackupSnapshotExportBucket:CloudBackupSnapshotExportBucket test 5d0f1f73cf09a29120e173cf-5d116d82014b764445b2f9b5\n```\n\n For more information see[MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/cloud-backup/export/create-one-export-bucket/) ",
            "properties": {
                "bucketName": {
                    "type": "string",
                    "description": "Name of the bucket that the provided role ID is authorized to access. You must also specify the `iam_role_id`.\n"
                },
                "cloudProvider": {
                    "type": "string",
                    "description": "Name of the provider of the cloud service where Atlas can access the S3 bucket. Atlas only supports `AWS`.\n"
                },
                "exportBucketId": {
                    "type": "string",
                    "description": "Unique identifier of the snapshot export bucket.\n"
                },
                "iamRoleId": {
                    "type": "string",
                    "description": "Unique identifier of the role that Atlas can use to access the bucket. You must also specify the `bucket_name`.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier of the project for the Atlas cluster.\n"
                }
            },
            "required": [
                "bucketName",
                "cloudProvider",
                "exportBucketId",
                "iamRoleId",
                "projectId"
            ],
            "inputProperties": {
                "bucketName": {
                    "type": "string",
                    "description": "Name of the bucket that the provided role ID is authorized to access. You must also specify the `iam_role_id`.\n",
                    "willReplaceOnChanges": true
                },
                "cloudProvider": {
                    "type": "string",
                    "description": "Name of the provider of the cloud service where Atlas can access the S3 bucket. Atlas only supports `AWS`.\n",
                    "willReplaceOnChanges": true
                },
                "iamRoleId": {
                    "type": "string",
                    "description": "Unique identifier of the role that Atlas can use to access the bucket. You must also specify the `bucket_name`.\n",
                    "willReplaceOnChanges": true
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier of the project for the Atlas cluster.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "bucketName",
                "cloudProvider",
                "iamRoleId",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudBackupSnapshotExportBucket resources.\n",
                "properties": {
                    "bucketName": {
                        "type": "string",
                        "description": "Name of the bucket that the provided role ID is authorized to access. You must also specify the `iam_role_id`.\n",
                        "willReplaceOnChanges": true
                    },
                    "cloudProvider": {
                        "type": "string",
                        "description": "Name of the provider of the cloud service where Atlas can access the S3 bucket. Atlas only supports `AWS`.\n",
                        "willReplaceOnChanges": true
                    },
                    "exportBucketId": {
                        "type": "string",
                        "description": "Unique identifier of the snapshot export bucket.\n"
                    },
                    "iamRoleId": {
                        "type": "string",
                        "description": "Unique identifier of the role that Atlas can use to access the bucket. You must also specify the `bucket_name`.\n",
                        "willReplaceOnChanges": true
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/cloudBackupSnapshotExportJob:CloudBackupSnapshotExportJob": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testCloudBackupSnapshotExportBucket = new mongodbatlas.CloudBackupSnapshotExportBucket(\"testCloudBackupSnapshotExportBucket\", {\n    projectId: \"{PROJECT_ID}\",\n    iamRoleId: \"{IAM_ROLE_ID}\",\n    bucketName: \"example_bucket\",\n    cloudProvider: \"AWS\",\n});\nconst testCloudBackupSnapshotExportJob = new mongodbatlas.CloudBackupSnapshotExportJob(\"testCloudBackupSnapshotExportJob\", {\n    projectId: \"{PROJECT_ID}\",\n    clusterName: \"{CLUSTER_NAME}\",\n    snapshotId: \"{SNAPSHOT_ID}\",\n    exportBucketId: testCloudBackupSnapshotExportBucket.exportBucketId,\n    customDatas: [{\n        key: \"exported by\",\n        value: \"myName\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_cloud_backup_snapshot_export_bucket = mongodbatlas.CloudBackupSnapshotExportBucket(\"testCloudBackupSnapshotExportBucket\",\n    project_id=\"{PROJECT_ID}\",\n    iam_role_id=\"{IAM_ROLE_ID}\",\n    bucket_name=\"example_bucket\",\n    cloud_provider=\"AWS\")\ntest_cloud_backup_snapshot_export_job = mongodbatlas.CloudBackupSnapshotExportJob(\"testCloudBackupSnapshotExportJob\",\n    project_id=\"{PROJECT_ID}\",\n    cluster_name=\"{CLUSTER_NAME}\",\n    snapshot_id=\"{SNAPSHOT_ID}\",\n    export_bucket_id=test_cloud_backup_snapshot_export_bucket.export_bucket_id,\n    custom_datas=[mongodbatlas.CloudBackupSnapshotExportJobCustomDataArgs(\n        key=\"exported by\",\n        value=\"myName\",\n    )])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testCloudBackupSnapshotExportBucket = new Mongodbatlas.CloudBackupSnapshotExportBucket(\"testCloudBackupSnapshotExportBucket\", new()\n    {\n        ProjectId = \"{PROJECT_ID}\",\n        IamRoleId = \"{IAM_ROLE_ID}\",\n        BucketName = \"example_bucket\",\n        CloudProvider = \"AWS\",\n    });\n\n    var testCloudBackupSnapshotExportJob = new Mongodbatlas.CloudBackupSnapshotExportJob(\"testCloudBackupSnapshotExportJob\", new()\n    {\n        ProjectId = \"{PROJECT_ID}\",\n        ClusterName = \"{CLUSTER_NAME}\",\n        SnapshotId = \"{SNAPSHOT_ID}\",\n        ExportBucketId = testCloudBackupSnapshotExportBucket.ExportBucketId,\n        CustomDatas = new[]\n        {\n            new Mongodbatlas.Inputs.CloudBackupSnapshotExportJobCustomDataArgs\n            {\n                Key = \"exported by\",\n                Value = \"myName\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestCloudBackupSnapshotExportBucket, err := mongodbatlas.NewCloudBackupSnapshotExportBucket(ctx, \"testCloudBackupSnapshotExportBucket\", \u0026mongodbatlas.CloudBackupSnapshotExportBucketArgs{\n\t\t\tProjectId:     pulumi.String(\"{PROJECT_ID}\"),\n\t\t\tIamRoleId:     pulumi.String(\"{IAM_ROLE_ID}\"),\n\t\t\tBucketName:    pulumi.String(\"example_bucket\"),\n\t\t\tCloudProvider: pulumi.String(\"AWS\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewCloudBackupSnapshotExportJob(ctx, \"testCloudBackupSnapshotExportJob\", \u0026mongodbatlas.CloudBackupSnapshotExportJobArgs{\n\t\t\tProjectId:      pulumi.String(\"{PROJECT_ID}\"),\n\t\t\tClusterName:    pulumi.String(\"{CLUSTER_NAME}\"),\n\t\t\tSnapshotId:     pulumi.String(\"{SNAPSHOT_ID}\"),\n\t\t\tExportBucketId: testCloudBackupSnapshotExportBucket.ExportBucketId,\n\t\t\tCustomDatas: mongodbatlas.CloudBackupSnapshotExportJobCustomDataArray{\n\t\t\t\t\u0026mongodbatlas.CloudBackupSnapshotExportJobCustomDataArgs{\n\t\t\t\t\tKey:   pulumi.String(\"exported by\"),\n\t\t\t\t\tValue: pulumi.String(\"myName\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportBucket;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportBucketArgs;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportJob;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportJobArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudBackupSnapshotExportJobCustomDataArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testCloudBackupSnapshotExportBucket = new CloudBackupSnapshotExportBucket(\"testCloudBackupSnapshotExportBucket\", CloudBackupSnapshotExportBucketArgs.builder()        \n            .projectId(\"{PROJECT_ID}\")\n            .iamRoleId(\"{IAM_ROLE_ID}\")\n            .bucketName(\"example_bucket\")\n            .cloudProvider(\"AWS\")\n            .build());\n\n        var testCloudBackupSnapshotExportJob = new CloudBackupSnapshotExportJob(\"testCloudBackupSnapshotExportJob\", CloudBackupSnapshotExportJobArgs.builder()        \n            .projectId(\"{PROJECT_ID}\")\n            .clusterName(\"{CLUSTER_NAME}\")\n            .snapshotId(\"{SNAPSHOT_ID}\")\n            .exportBucketId(testCloudBackupSnapshotExportBucket.exportBucketId())\n            .customDatas(CloudBackupSnapshotExportJobCustomDataArgs.builder()\n                .key(\"exported by\")\n                .value(\"myName\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testCloudBackupSnapshotExportBucket:\n    type: mongodbatlas:CloudBackupSnapshotExportBucket\n    properties:\n      projectId: '{PROJECT_ID}'\n      iamRoleId: '{IAM_ROLE_ID}'\n      bucketName: example_bucket\n      cloudProvider: AWS\n  testCloudBackupSnapshotExportJob:\n    type: mongodbatlas:CloudBackupSnapshotExportJob\n    properties:\n      projectId: '{PROJECT_ID}'\n      clusterName: '{CLUSTER_NAME}'\n      snapshotId: '{SNAPSHOT_ID}'\n      exportBucketId: ${testCloudBackupSnapshotExportBucket.exportBucketId}\n      customDatas:\n        - key: exported by\n          value: myName\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nCloud Backup Snapshot Export Backup entries can be imported using project project_id, cluster_name and export_job_id (Unique identifier of the snapshot export job), in the format `PROJECTID-CLUSTERNAME-EXPORTJOBID`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/cloudBackupSnapshotExportJob:CloudBackupSnapshotExportJob test 5d0f1f73cf09a29120e173cf-5d116d82014b764445b2f9b5-5d116d82014b764445b2f9b5\n```\n\n For more information see[MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/cloud-backup/export/create-one-export-job/) ",
            "properties": {
                "clusterName": {
                    "type": "string",
                    "description": "Name of the Atlas cluster whose snapshot you want to export.\n"
                },
                "components": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupSnapshotExportJobComponent:CloudBackupSnapshotExportJobComponent"
                    },
                    "description": "_Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when the export job was created.\n"
                },
                "customDatas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupSnapshotExportJobCustomData:CloudBackupSnapshotExportJobCustomData"
                    },
                    "description": "Custom data to include in the metadata file named `.complete` that Atlas uploads to the bucket when the export job finishes. Custom data can be specified as key and value pairs.\n"
                },
                "errMsg": {
                    "type": "string",
                    "description": "Error message, only if the export job failed.\n"
                },
                "exportBucketId": {
                    "type": "string"
                },
                "exportJobId": {
                    "type": "string",
                    "description": "Unique identifier of the export job.\n* `prefix ` - Full path on the cloud provider bucket to the folder where the snapshot is exported. The path is in the following format:`/exported_snapshots/{ORG-NAME}/{PROJECT-NAME}/{CLUSTER-NAME}/{SNAPSHOT-INITIATION-DATE}/{TIMESTAMP}`\n"
                },
                "exportStatusExportedCollections": {
                    "type": "integer"
                },
                "exportStatusTotalCollections": {
                    "type": "integer"
                },
                "finishedAt": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when the export job completes.\n"
                },
                "prefix": {
                    "type": "string"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the project which contains the Atlas cluster whose snapshot you want to export.\n"
                },
                "snapshotId": {
                    "type": "string"
                },
                "state": {
                    "type": "string",
                    "description": "Status of the export job. Value can be one of the following:\n"
                }
            },
            "required": [
                "clusterName",
                "components",
                "createdAt",
                "customDatas",
                "errMsg",
                "exportBucketId",
                "exportJobId",
                "exportStatusExportedCollections",
                "exportStatusTotalCollections",
                "finishedAt",
                "prefix",
                "projectId",
                "snapshotId",
                "state"
            ],
            "inputProperties": {
                "clusterName": {
                    "type": "string",
                    "description": "Name of the Atlas cluster whose snapshot you want to export.\n",
                    "willReplaceOnChanges": true
                },
                "customDatas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupSnapshotExportJobCustomData:CloudBackupSnapshotExportJobCustomData"
                    },
                    "description": "Custom data to include in the metadata file named `.complete` that Atlas uploads to the bucket when the export job finishes. Custom data can be specified as key and value pairs.\n",
                    "willReplaceOnChanges": true
                },
                "exportBucketId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the project which contains the Atlas cluster whose snapshot you want to export.\n",
                    "willReplaceOnChanges": true
                },
                "snapshotId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "clusterName",
                "customDatas",
                "exportBucketId",
                "projectId",
                "snapshotId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudBackupSnapshotExportJob resources.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "Name of the Atlas cluster whose snapshot you want to export.\n",
                        "willReplaceOnChanges": true
                    },
                    "components": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/CloudBackupSnapshotExportJobComponent:CloudBackupSnapshotExportJobComponent"
                        },
                        "description": "_Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when the export job was created.\n"
                    },
                    "customDatas": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/CloudBackupSnapshotExportJobCustomData:CloudBackupSnapshotExportJobCustomData"
                        },
                        "description": "Custom data to include in the metadata file named `.complete` that Atlas uploads to the bucket when the export job finishes. Custom data can be specified as key and value pairs.\n",
                        "willReplaceOnChanges": true
                    },
                    "errMsg": {
                        "type": "string",
                        "description": "Error message, only if the export job failed.\n"
                    },
                    "exportBucketId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "exportJobId": {
                        "type": "string",
                        "description": "Unique identifier of the export job.\n* `prefix ` - Full path on the cloud provider bucket to the folder where the snapshot is exported. The path is in the following format:`/exported_snapshots/{ORG-NAME}/{PROJECT-NAME}/{CLUSTER-NAME}/{SNAPSHOT-INITIATION-DATE}/{TIMESTAMP}`\n"
                    },
                    "exportStatusExportedCollections": {
                        "type": "integer"
                    },
                    "exportStatusTotalCollections": {
                        "type": "integer"
                    },
                    "finishedAt": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when the export job completes.\n"
                    },
                    "prefix": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the project which contains the Atlas cluster whose snapshot you want to export.\n",
                        "willReplaceOnChanges": true
                    },
                    "snapshotId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "state": {
                        "type": "string",
                        "description": "Status of the export job. Value can be one of the following:\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/cloudBackupSnapshotRestoreJob:CloudBackupSnapshotRestoreJob": {
            "description": "\n\n\n## Import\n\nCloud Backup Snapshot Restore Job entries can be imported using project project_id, cluster_name and snapshot_id (Unique identifier of the snapshot), in the format `PROJECTID-CLUSTERNAME-JOBID`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/cloudBackupSnapshotRestoreJob:CloudBackupSnapshotRestoreJob test 5cf5a45a9ccf6400e60981b6-MyCluster-5d1b654ecf09a24b888f4c79\n```\n\n For more information see[MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/cloud-backup/restore/restores/) ",
            "properties": {
                "cancelled": {
                    "type": "boolean",
                    "description": "Indicates whether the restore job was canceled.\n"
                },
                "clusterName": {
                    "type": "string",
                    "description": "The name of the Atlas cluster whose snapshot you want to restore.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "UTC ISO 8601 formatted point in time when Atlas created the restore job.\n"
                },
                "deliveryType": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "deprecationMessage": "use delivery_type_config instead"
                },
                "deliveryTypeConfig": {
                    "$ref": "#/types/mongodbatlas:index/CloudBackupSnapshotRestoreJobDeliveryTypeConfig:CloudBackupSnapshotRestoreJobDeliveryTypeConfig",
                    "description": "Type of restore job to create. Possible configurations are: **download**, **automated**, or **pointInTime** only one must be set it in ``true``.\n* `delivery_type_config.automated` - Set to `true` to use the automated configuration.\n* `delivery_type_config.download` - Set to `true` to use the download configuration.\n* `delivery_type_config.pointInTime` - Set to `true` to use the pointInTime configuration. If using pointInTime configuration, you must also specify either `oplog_ts` and `oplog_inc`, or `point_in_time_utc_seconds`.\n* `delivery_type_config.target_cluster_name` - Name of the target Atlas cluster to which the restore job restores the snapshot. Required for **automated** and **pointInTime**.\n* `delivery_type_config.target_project_id` - Name of the target Atlas cluster to which the restore job restores the snapshot. Required for **automated** and **pointInTime**.\n* `delivery_type_config.oplog_ts` - Optional setting for **pointInTime** configuration. Timestamp in the number of seconds that have elapsed since the UNIX epoch from which to you want to restore this snapshot. This is the first part of an Oplog timestamp.\n* `delivery_type_config.oplog_inc` - Optional setting for **pointInTime** configuration. Oplog operation number from which to you want to restore this snapshot. This is the second part of an Oplog timestamp. Used in conjunction with `oplog_ts`.\n* `delivery_type_config.point_in_time_utc_seconds` - Optional setting for **pointInTime** configuration. Timestamp in the number of seconds that have elapsed since the UNIX epoch from which you want to restore this snapshot. Used instead of oplog settings.\n"
                },
                "deliveryUrls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "One or more URLs for the compressed snapshot files for manual download. Only visible if deliveryType is download.\n"
                },
                "expired": {
                    "type": "boolean",
                    "description": "Indicates whether the restore job expired.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "UTC ISO 8601 formatted point in time when the restore job expires.\n"
                },
                "finishedAt": {
                    "type": "string",
                    "description": "UTC ISO 8601 formatted point in time when the restore job completed.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier of the project for the Atlas cluster whose snapshot you want to restore.\n"
                },
                "snapshotId": {
                    "type": "string",
                    "description": "Unique identifier of the snapshot to restore.\n"
                },
                "snapshotRestoreJobId": {
                    "type": "string",
                    "description": "The unique identifier of the restore job.\n"
                },
                "timestamp": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when the snapshot associated to snapshotId was taken.\n"
                }
            },
            "required": [
                "cancelled",
                "clusterName",
                "createdAt",
                "deliveryUrls",
                "expired",
                "expiresAt",
                "finishedAt",
                "projectId",
                "snapshotId",
                "snapshotRestoreJobId",
                "timestamp"
            ],
            "inputProperties": {
                "clusterName": {
                    "type": "string",
                    "description": "The name of the Atlas cluster whose snapshot you want to restore.\n",
                    "willReplaceOnChanges": true
                },
                "deliveryType": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "deprecationMessage": "use delivery_type_config instead",
                    "willReplaceOnChanges": true
                },
                "deliveryTypeConfig": {
                    "$ref": "#/types/mongodbatlas:index/CloudBackupSnapshotRestoreJobDeliveryTypeConfig:CloudBackupSnapshotRestoreJobDeliveryTypeConfig",
                    "description": "Type of restore job to create. Possible configurations are: **download**, **automated**, or **pointInTime** only one must be set it in ``true``.\n* `delivery_type_config.automated` - Set to `true` to use the automated configuration.\n* `delivery_type_config.download` - Set to `true` to use the download configuration.\n* `delivery_type_config.pointInTime` - Set to `true` to use the pointInTime configuration. If using pointInTime configuration, you must also specify either `oplog_ts` and `oplog_inc`, or `point_in_time_utc_seconds`.\n* `delivery_type_config.target_cluster_name` - Name of the target Atlas cluster to which the restore job restores the snapshot. Required for **automated** and **pointInTime**.\n* `delivery_type_config.target_project_id` - Name of the target Atlas cluster to which the restore job restores the snapshot. Required for **automated** and **pointInTime**.\n* `delivery_type_config.oplog_ts` - Optional setting for **pointInTime** configuration. Timestamp in the number of seconds that have elapsed since the UNIX epoch from which to you want to restore this snapshot. This is the first part of an Oplog timestamp.\n* `delivery_type_config.oplog_inc` - Optional setting for **pointInTime** configuration. Oplog operation number from which to you want to restore this snapshot. This is the second part of an Oplog timestamp. Used in conjunction with `oplog_ts`.\n* `delivery_type_config.point_in_time_utc_seconds` - Optional setting for **pointInTime** configuration. Timestamp in the number of seconds that have elapsed since the UNIX epoch from which you want to restore this snapshot. Used instead of oplog settings.\n",
                    "willReplaceOnChanges": true
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier of the project for the Atlas cluster whose snapshot you want to restore.\n",
                    "willReplaceOnChanges": true
                },
                "snapshotId": {
                    "type": "string",
                    "description": "Unique identifier of the snapshot to restore.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "clusterName",
                "projectId",
                "snapshotId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudBackupSnapshotRestoreJob resources.\n",
                "properties": {
                    "cancelled": {
                        "type": "boolean",
                        "description": "Indicates whether the restore job was canceled.\n"
                    },
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the Atlas cluster whose snapshot you want to restore.\n",
                        "willReplaceOnChanges": true
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "UTC ISO 8601 formatted point in time when Atlas created the restore job.\n"
                    },
                    "deliveryType": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "deprecationMessage": "use delivery_type_config instead",
                        "willReplaceOnChanges": true
                    },
                    "deliveryTypeConfig": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupSnapshotRestoreJobDeliveryTypeConfig:CloudBackupSnapshotRestoreJobDeliveryTypeConfig",
                        "description": "Type of restore job to create. Possible configurations are: **download**, **automated**, or **pointInTime** only one must be set it in ``true``.\n* `delivery_type_config.automated` - Set to `true` to use the automated configuration.\n* `delivery_type_config.download` - Set to `true` to use the download configuration.\n* `delivery_type_config.pointInTime` - Set to `true` to use the pointInTime configuration. If using pointInTime configuration, you must also specify either `oplog_ts` and `oplog_inc`, or `point_in_time_utc_seconds`.\n* `delivery_type_config.target_cluster_name` - Name of the target Atlas cluster to which the restore job restores the snapshot. Required for **automated** and **pointInTime**.\n* `delivery_type_config.target_project_id` - Name of the target Atlas cluster to which the restore job restores the snapshot. Required for **automated** and **pointInTime**.\n* `delivery_type_config.oplog_ts` - Optional setting for **pointInTime** configuration. Timestamp in the number of seconds that have elapsed since the UNIX epoch from which to you want to restore this snapshot. This is the first part of an Oplog timestamp.\n* `delivery_type_config.oplog_inc` - Optional setting for **pointInTime** configuration. Oplog operation number from which to you want to restore this snapshot. This is the second part of an Oplog timestamp. Used in conjunction with `oplog_ts`.\n* `delivery_type_config.point_in_time_utc_seconds` - Optional setting for **pointInTime** configuration. Timestamp in the number of seconds that have elapsed since the UNIX epoch from which you want to restore this snapshot. Used instead of oplog settings.\n",
                        "willReplaceOnChanges": true
                    },
                    "deliveryUrls": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "One or more URLs for the compressed snapshot files for manual download. Only visible if deliveryType is download.\n"
                    },
                    "expired": {
                        "type": "boolean",
                        "description": "Indicates whether the restore job expired.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "UTC ISO 8601 formatted point in time when the restore job expires.\n"
                    },
                    "finishedAt": {
                        "type": "string",
                        "description": "UTC ISO 8601 formatted point in time when the restore job completed.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster whose snapshot you want to restore.\n",
                        "willReplaceOnChanges": true
                    },
                    "snapshotId": {
                        "type": "string",
                        "description": "Unique identifier of the snapshot to restore.\n",
                        "willReplaceOnChanges": true
                    },
                    "snapshotRestoreJobId": {
                        "type": "string",
                        "description": "The unique identifier of the restore job.\n"
                    },
                    "timestamp": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when the snapshot associated to snapshotId was taken.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/cloudProviderAccess:CloudProviderAccess": {
            "description": "\n\n\n## Import\n\nThe Cloud Provider Access resource can be imported using project ID and the provider name and mongodbatlas role id, in the format `project_id`-`provider_name`-`role_id`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/cloudProviderAccess:CloudProviderAccess my_role 1112222b3bf99403840e8934-AWS-5fc17d476f7a33224f5b224e\n```\n\n ",
            "properties": {
                "atlasAssumedRoleExternalId": {
                    "type": "string",
                    "description": "Unique external ID Atlas uses when assuming the IAM role in your AWS account.\n"
                },
                "atlasAwsAccountArn": {
                    "type": "string",
                    "description": "ARN associated with the Atlas AWS account used to assume IAM roles in your AWS account.\n"
                },
                "authorizedDate": {
                    "type": "string",
                    "description": "Date on which this role was authorized.\n"
                },
                "createdDate": {
                    "type": "string",
                    "description": "Date on which this role was created.\n"
                },
                "featureUsages": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudProviderAccessFeatureUsage:CloudProviderAccessFeatureUsage"
                    },
                    "description": "Atlas features this AWS IAM role is linked to.\n"
                },
                "iamAssumedRoleArn": {
                    "type": "string",
                    "description": "ARN of the IAM Role that Atlas assumes when accessing resources in your AWS account. This value is required after the creation (register of the role) as part of [Set Up Unified AWS Access](https://docs.atlas.mongodb.com/security/set-up-unified-aws-access/#set-up-unified-aws-access).\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project\n"
                },
                "providerName": {
                    "type": "string",
                    "description": "The cloud provider for which to create a new role. Currently only AWS is supported.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "Unique ID of this role returned by mongodb atlas api\n"
                }
            },
            "required": [
                "atlasAssumedRoleExternalId",
                "atlasAwsAccountArn",
                "authorizedDate",
                "createdDate",
                "featureUsages",
                "projectId",
                "providerName",
                "roleId"
            ],
            "inputProperties": {
                "iamAssumedRoleArn": {
                    "type": "string",
                    "description": "ARN of the IAM Role that Atlas assumes when accessing resources in your AWS account. This value is required after the creation (register of the role) as part of [Set Up Unified AWS Access](https://docs.atlas.mongodb.com/security/set-up-unified-aws-access/#set-up-unified-aws-access).\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project\n"
                },
                "providerName": {
                    "type": "string",
                    "description": "The cloud provider for which to create a new role. Currently only AWS is supported.\n"
                }
            },
            "requiredInputs": [
                "projectId",
                "providerName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudProviderAccess resources.\n",
                "properties": {
                    "atlasAssumedRoleExternalId": {
                        "type": "string",
                        "description": "Unique external ID Atlas uses when assuming the IAM role in your AWS account.\n"
                    },
                    "atlasAwsAccountArn": {
                        "type": "string",
                        "description": "ARN associated with the Atlas AWS account used to assume IAM roles in your AWS account.\n"
                    },
                    "authorizedDate": {
                        "type": "string",
                        "description": "Date on which this role was authorized.\n"
                    },
                    "createdDate": {
                        "type": "string",
                        "description": "Date on which this role was created.\n"
                    },
                    "featureUsages": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/CloudProviderAccessFeatureUsage:CloudProviderAccessFeatureUsage"
                        },
                        "description": "Atlas features this AWS IAM role is linked to.\n"
                    },
                    "iamAssumedRoleArn": {
                        "type": "string",
                        "description": "ARN of the IAM Role that Atlas assumes when accessing resources in your AWS account. This value is required after the creation (register of the role) as part of [Set Up Unified AWS Access](https://docs.atlas.mongodb.com/security/set-up-unified-aws-access/#set-up-unified-aws-access).\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project\n"
                    },
                    "providerName": {
                        "type": "string",
                        "description": "The cloud provider for which to create a new role. Currently only AWS is supported.\n"
                    },
                    "roleId": {
                        "type": "string",
                        "description": "Unique ID of this role returned by mongodb atlas api\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/cloudProviderAccessAuthorization:CloudProviderAccessAuthorization": {
            "properties": {
                "authorizedDate": {
                    "type": "string"
                },
                "aws": {
                    "$ref": "#/types/mongodbatlas:index/CloudProviderAccessAuthorizationAws:CloudProviderAccessAuthorizationAws"
                },
                "featureUsages": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudProviderAccessAuthorizationFeatureUsage:CloudProviderAccessAuthorizationFeatureUsage"
                    }
                },
                "projectId": {
                    "type": "string"
                },
                "roleId": {
                    "type": "string"
                }
            },
            "required": [
                "authorizedDate",
                "featureUsages",
                "projectId",
                "roleId"
            ],
            "inputProperties": {
                "aws": {
                    "$ref": "#/types/mongodbatlas:index/CloudProviderAccessAuthorizationAws:CloudProviderAccessAuthorizationAws"
                },
                "projectId": {
                    "type": "string"
                },
                "roleId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "projectId",
                "roleId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudProviderAccessAuthorization resources.\n",
                "properties": {
                    "authorizedDate": {
                        "type": "string"
                    },
                    "aws": {
                        "$ref": "#/types/mongodbatlas:index/CloudProviderAccessAuthorizationAws:CloudProviderAccessAuthorizationAws"
                    },
                    "featureUsages": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/CloudProviderAccessAuthorizationFeatureUsage:CloudProviderAccessAuthorizationFeatureUsage"
                        }
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "roleId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/cloudProviderAccessSetup:CloudProviderAccessSetup": {
            "properties": {
                "aws": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "deprecationMessage": "use aws_config instead"
                },
                "awsConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudProviderAccessSetupAwsConfig:CloudProviderAccessSetupAwsConfig"
                    }
                },
                "createdDate": {
                    "type": "string"
                },
                "projectId": {
                    "type": "string"
                },
                "providerName": {
                    "type": "string"
                },
                "roleId": {
                    "type": "string"
                }
            },
            "required": [
                "aws",
                "awsConfigs",
                "createdDate",
                "projectId",
                "providerName",
                "roleId"
            ],
            "inputProperties": {
                "projectId": {
                    "type": "string"
                },
                "providerName": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "projectId",
                "providerName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudProviderAccessSetup resources.\n",
                "properties": {
                    "aws": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "deprecationMessage": "use aws_config instead"
                    },
                    "awsConfigs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/CloudProviderAccessSetupAwsConfig:CloudProviderAccessSetupAwsConfig"
                        }
                    },
                    "createdDate": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "providerName": {
                        "type": "string"
                    },
                    "roleId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/cloudProviderSnapshot:CloudProviderSnapshot": {
            "description": "**WARNING:** This resource is deprecated, use `mongodbatlas.CloudBackupSnapshot`\n\n`mongodbatlas.CloudProviderSnapshot` provides a resource to take a cloud backup snapshot on demand.\nOn-demand snapshots happen immediately, unlike scheduled snapshots which occur at regular intervals. If there is already an on-demand snapshot with a status of queued or inProgress, you must wait until Atlas has completed the on-demand snapshot before taking another.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Cluster;\nimport com.pulumi.mongodbatlas.ClusterArgs;\nimport com.pulumi.mongodbatlas.CloudProviderSnapshot;\nimport com.pulumi.mongodbatlas.CloudProviderSnapshotArgs;\nimport com.pulumi.mongodbatlas.CloudProviderSnapshotRestoreJob;\nimport com.pulumi.mongodbatlas.CloudProviderSnapshotRestoreJobArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myCluster = new Cluster(\"myCluster\", ClusterArgs.builder()        \n            .projectId(\"5cf5a45a9ccf6400e60981b6\")\n            .diskSizeGb(5)\n            .providerName(\"AWS\")\n            .providerRegionName(\"EU_WEST_2\")\n            .providerInstanceSizeName(\"M10\")\n            .cloudBackup(true)\n            .build());\n\n        var testCloudProviderSnapshot = new CloudProviderSnapshot(\"testCloudProviderSnapshot\", CloudProviderSnapshotArgs.builder()        \n            .projectId(myCluster.projectId())\n            .clusterName(myCluster.name())\n            .description(\"myDescription\")\n            .retentionInDays(1)\n            .timeout(\"10m\")\n            .build());\n\n        var testCloudProviderSnapshotRestoreJob = new CloudProviderSnapshotRestoreJob(\"testCloudProviderSnapshotRestoreJob\", CloudProviderSnapshotRestoreJobArgs.builder()        \n            .projectId(testCloudProviderSnapshot.projectId())\n            .clusterName(testCloudProviderSnapshot.clusterName())\n            .snapshotId(testCloudProviderSnapshot.snapshotId())\n            .deliveryType(Map.of(\"download\", true))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myCluster:\n    type: mongodbatlas:Cluster\n    properties:\n      projectId: 5cf5a45a9ccf6400e60981b6\n      diskSizeGb: 5\n      # Provider Settings \"block\"\n      providerName: AWS\n      providerRegionName: EU_WEST_2\n      providerInstanceSizeName: M10\n      cloudBackup: true\n  testCloudProviderSnapshot:\n    type: mongodbatlas:CloudProviderSnapshot\n    properties:\n      projectId: ${myCluster.projectId}\n      clusterName: ${myCluster.name}\n      description: myDescription\n      retentionInDays: 1\n      timeout: 10m\n  testCloudProviderSnapshotRestoreJob:\n    type: mongodbatlas:CloudProviderSnapshotRestoreJob\n    properties:\n      projectId: ${testCloudProviderSnapshot.projectId}\n      clusterName: ${testCloudProviderSnapshot.clusterName}\n      snapshotId: ${testCloudProviderSnapshot.snapshotId}\n      deliveryType:\n        - download: true\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nCloud Backup Snapshot entries can be imported using project project_id, cluster_name and snapshot_id (Unique identifier of the snapshot), in the format `PROJECTID-CLUSTERNAME-SNAPSHOTID`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/cloudProviderSnapshot:CloudProviderSnapshot test 5d0f1f73cf09a29120e173cf-MyClusterTest-5d116d82014b764445b2f9b5\n```\n\n For more information see[MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/cloud-backup/backup/backups/) ",
            "properties": {
                "clusterName": {
                    "type": "string",
                    "description": "The name of the Atlas cluster that contains the snapshots you want to retrieve.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "UTC ISO 8601 formatted point in time when Atlas took the snapshot.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the on-demand snapshot.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "UTC ISO 8601 formatted point in time when Atlas will delete the snapshot.\n"
                },
                "masterKeyUuid": {
                    "type": "string",
                    "description": "Unique ID of the AWS KMS Customer Master Key used to encrypt the snapshot. Only visible for clusters using Encryption at Rest via Customer KMS.\n"
                },
                "mongodVersion": {
                    "type": "string",
                    "description": "Version of the MongoDB server.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier of the project for the Atlas cluster.\n"
                },
                "retentionInDays": {
                    "type": "integer",
                    "description": "The number of days that Atlas should retain the on-demand snapshot. Must be at least 1.\n"
                },
                "snapshotId": {
                    "type": "string",
                    "description": "Unique identifier of the snapshot.\n"
                },
                "snapshotType": {
                    "type": "string",
                    "description": "Specified the type of snapshot. Valid values are onDemand and scheduled.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Current status of the snapshot. One of the following values will be returned: queued, inProgress, completed, failed.\n"
                },
                "storageSizeBytes": {
                    "type": "integer",
                    "description": "Specifies the size of the snapshot in bytes.\n"
                },
                "timeout": {
                    "type": "string",
                    "description": "The duration of time to wait to finish the on-demand snapshot. The timeout value is defined by a signed sequence of decimal numbers with an time unit suffix such as: `1h45m`, `300s`, `10m`, .... The valid time units are:  `ns`, `us` (or `µs`), `ms`, `s`, `m`, `h`. Default value for the timeout is `10m`\n"
                },
                "type": {
                    "type": "string",
                    "description": "Specifies the type of cluster: replicaSet or shardedCluster.\n"
                }
            },
            "required": [
                "clusterName",
                "createdAt",
                "description",
                "expiresAt",
                "masterKeyUuid",
                "mongodVersion",
                "projectId",
                "retentionInDays",
                "snapshotId",
                "snapshotType",
                "status",
                "storageSizeBytes",
                "type"
            ],
            "inputProperties": {
                "clusterName": {
                    "type": "string",
                    "description": "The name of the Atlas cluster that contains the snapshots you want to retrieve.\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "Description of the on-demand snapshot.\n",
                    "willReplaceOnChanges": true
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier of the project for the Atlas cluster.\n",
                    "willReplaceOnChanges": true
                },
                "retentionInDays": {
                    "type": "integer",
                    "description": "The number of days that Atlas should retain the on-demand snapshot. Must be at least 1.\n",
                    "willReplaceOnChanges": true
                },
                "timeout": {
                    "type": "string",
                    "description": "The duration of time to wait to finish the on-demand snapshot. The timeout value is defined by a signed sequence of decimal numbers with an time unit suffix such as: `1h45m`, `300s`, `10m`, .... The valid time units are:  `ns`, `us` (or `µs`), `ms`, `s`, `m`, `h`. Default value for the timeout is `10m`\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "clusterName",
                "description",
                "projectId",
                "retentionInDays"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudProviderSnapshot resources.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the Atlas cluster that contains the snapshots you want to retrieve.\n",
                        "willReplaceOnChanges": true
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "UTC ISO 8601 formatted point in time when Atlas took the snapshot.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the on-demand snapshot.\n",
                        "willReplaceOnChanges": true
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "UTC ISO 8601 formatted point in time when Atlas will delete the snapshot.\n"
                    },
                    "masterKeyUuid": {
                        "type": "string",
                        "description": "Unique ID of the AWS KMS Customer Master Key used to encrypt the snapshot. Only visible for clusters using Encryption at Rest via Customer KMS.\n"
                    },
                    "mongodVersion": {
                        "type": "string",
                        "description": "Version of the MongoDB server.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster.\n",
                        "willReplaceOnChanges": true
                    },
                    "retentionInDays": {
                        "type": "integer",
                        "description": "The number of days that Atlas should retain the on-demand snapshot. Must be at least 1.\n",
                        "willReplaceOnChanges": true
                    },
                    "snapshotId": {
                        "type": "string",
                        "description": "Unique identifier of the snapshot.\n"
                    },
                    "snapshotType": {
                        "type": "string",
                        "description": "Specified the type of snapshot. Valid values are onDemand and scheduled.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Current status of the snapshot. One of the following values will be returned: queued, inProgress, completed, failed.\n"
                    },
                    "storageSizeBytes": {
                        "type": "integer",
                        "description": "Specifies the size of the snapshot in bytes.\n"
                    },
                    "timeout": {
                        "type": "string",
                        "description": "The duration of time to wait to finish the on-demand snapshot. The timeout value is defined by a signed sequence of decimal numbers with an time unit suffix such as: `1h45m`, `300s`, `10m`, .... The valid time units are:  `ns`, `us` (or `µs`), `ms`, `s`, `m`, `h`. Default value for the timeout is `10m`\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "Specifies the type of cluster: replicaSet or shardedCluster.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/cloudProviderSnapshotBackupPolicy:CloudProviderSnapshotBackupPolicy": {
            "description": "\n\n\n## Import\n\nCloud Backup Snapshot Policy entries can be imported using project project_id and cluster_name, in the format `PROJECTID-CLUSTERNAME`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/cloudProviderSnapshotBackupPolicy:CloudProviderSnapshotBackupPolicy test 5d0f1f73cf09a29120e173cf-MyClusterTest\n```\n\n For more information see[MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/cloud-backup/schedule/modify-one-schedule/) ",
            "properties": {
                "clusterId": {
                    "type": "string",
                    "description": "Unique identifier of the Atlas cluster.\n"
                },
                "clusterName": {
                    "type": "string",
                    "description": "The name of the Atlas cluster that contains the snapshot backup policy you want to retrieve.\n"
                },
                "nextSnapshot": {
                    "type": "string",
                    "description": "Timestamp in the number of seconds that have elapsed since the UNIX epoch when Atlas takes the next snapshot.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudProviderSnapshotBackupPolicyPolicy:CloudProviderSnapshotBackupPolicyPolicy"
                    }
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier of the project for the Atlas cluster.\n"
                },
                "referenceHourOfDay": {
                    "type": "integer",
                    "description": "UTC Hour of day between 0 and 23, inclusive, representing which hour of the day that Atlas takes snapshots for backup policy items.\n"
                },
                "referenceMinuteOfHour": {
                    "type": "integer",
                    "description": "UTC Minutes after referenceHourOfDay that Atlas takes snapshots for backup policy items. Must be between 0 and 59, inclusive.\n"
                },
                "restoreWindowDays": {
                    "type": "integer",
                    "description": "Number of days back in time you can restore to with point-in-time accuracy. Must be a positive, non-zero integer.\n"
                },
                "updateSnapshots": {
                    "type": "boolean",
                    "description": "Specify true to apply the retention changes in the updated backup policy to snapshots that Atlas took previously.\n"
                }
            },
            "required": [
                "clusterId",
                "clusterName",
                "nextSnapshot",
                "policies",
                "projectId",
                "referenceHourOfDay",
                "referenceMinuteOfHour",
                "restoreWindowDays",
                "updateSnapshots"
            ],
            "inputProperties": {
                "clusterName": {
                    "type": "string",
                    "description": "The name of the Atlas cluster that contains the snapshot backup policy you want to retrieve.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudProviderSnapshotBackupPolicyPolicy:CloudProviderSnapshotBackupPolicyPolicy"
                    }
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier of the project for the Atlas cluster.\n",
                    "willReplaceOnChanges": true
                },
                "referenceHourOfDay": {
                    "type": "integer",
                    "description": "UTC Hour of day between 0 and 23, inclusive, representing which hour of the day that Atlas takes snapshots for backup policy items.\n"
                },
                "referenceMinuteOfHour": {
                    "type": "integer",
                    "description": "UTC Minutes after referenceHourOfDay that Atlas takes snapshots for backup policy items. Must be between 0 and 59, inclusive.\n"
                },
                "restoreWindowDays": {
                    "type": "integer",
                    "description": "Number of days back in time you can restore to with point-in-time accuracy. Must be a positive, non-zero integer.\n"
                },
                "updateSnapshots": {
                    "type": "boolean",
                    "description": "Specify true to apply the retention changes in the updated backup policy to snapshots that Atlas took previously.\n"
                }
            },
            "requiredInputs": [
                "clusterName",
                "policies",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudProviderSnapshotBackupPolicy resources.\n",
                "properties": {
                    "clusterId": {
                        "type": "string",
                        "description": "Unique identifier of the Atlas cluster.\n"
                    },
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the Atlas cluster that contains the snapshot backup policy you want to retrieve.\n"
                    },
                    "nextSnapshot": {
                        "type": "string",
                        "description": "Timestamp in the number of seconds that have elapsed since the UNIX epoch when Atlas takes the next snapshot.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/CloudProviderSnapshotBackupPolicyPolicy:CloudProviderSnapshotBackupPolicyPolicy"
                        }
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster.\n",
                        "willReplaceOnChanges": true
                    },
                    "referenceHourOfDay": {
                        "type": "integer",
                        "description": "UTC Hour of day between 0 and 23, inclusive, representing which hour of the day that Atlas takes snapshots for backup policy items.\n"
                    },
                    "referenceMinuteOfHour": {
                        "type": "integer",
                        "description": "UTC Minutes after referenceHourOfDay that Atlas takes snapshots for backup policy items. Must be between 0 and 59, inclusive.\n"
                    },
                    "restoreWindowDays": {
                        "type": "integer",
                        "description": "Number of days back in time you can restore to with point-in-time accuracy. Must be a positive, non-zero integer.\n"
                    },
                    "updateSnapshots": {
                        "type": "boolean",
                        "description": "Specify true to apply the retention changes in the updated backup policy to snapshots that Atlas took previously.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/cloudProviderSnapshotRestoreJob:CloudProviderSnapshotRestoreJob": {
            "description": "**WARNING:** This resource is deprecated, use `mongodbatlas.CloudBackupSnapshotRestoreJob`\n\n`mongodbatlas.CloudProviderSnapshotRestoreJob` provides a resource to create a new restore job from a cloud backup snapshot of a specified cluster. The restore job can be one of three types: \n* **automated:** Atlas automatically restores the snapshot with snapshotId to the Atlas cluster with name targetClusterName in the Atlas project with targetGroupId.\n\n* **download:** Atlas provides a URL to download a .tar.gz of the snapshot with snapshotId. The contents of the archive contain the data files for your Atlas cluster.\n\n* **pointInTime:**  Atlas performs a Continuous Cloud Backup restore.\n\n\u003e **Important:** If you specify `deliveryType` : `automated` or `deliveryType` : `pointInTime` in your request body to create an automated restore job, Atlas removes all existing data on the target cluster prior to the restore.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Example automated delivery type.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst myCluster = new mongodbatlas.Cluster(\"myCluster\", {\n    projectId: \"5cf5a45a9ccf6400e60981b6\",\n    diskSizeGb: 5,\n    providerName: \"AWS\",\n    providerRegionName: \"EU_WEST_2\",\n    providerInstanceSizeName: \"M10\",\n    cloudBackup: true,\n});\n// enable cloud backup snapshots\nconst testCloudProviderSnapshot = new mongodbatlas.CloudProviderSnapshot(\"testCloudProviderSnapshot\", {\n    projectId: myCluster.projectId,\n    clusterName: myCluster.name,\n    description: \"myDescription\",\n    retentionInDays: 1,\n});\nconst testCloudProviderSnapshotRestoreJob = new mongodbatlas.CloudProviderSnapshotRestoreJob(\"testCloudProviderSnapshotRestoreJob\", {\n    projectId: testCloudProviderSnapshot.projectId,\n    clusterName: testCloudProviderSnapshot.clusterName,\n    snapshotId: testCloudProviderSnapshot.snapshotId,\n    deliveryTypeConfig: {\n        automated: true,\n        targetClusterName: \"MyCluster\",\n        targetProjectId: \"5cf5a45a9ccf6400e60981b6\",\n    },\n}, {\n    dependsOn: [testCloudProviderSnapshot],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nmy_cluster = mongodbatlas.Cluster(\"myCluster\",\n    project_id=\"5cf5a45a9ccf6400e60981b6\",\n    disk_size_gb=5,\n    provider_name=\"AWS\",\n    provider_region_name=\"EU_WEST_2\",\n    provider_instance_size_name=\"M10\",\n    cloud_backup=True)\n# enable cloud backup snapshots\ntest_cloud_provider_snapshot = mongodbatlas.CloudProviderSnapshot(\"testCloudProviderSnapshot\",\n    project_id=my_cluster.project_id,\n    cluster_name=my_cluster.name,\n    description=\"myDescription\",\n    retention_in_days=1)\ntest_cloud_provider_snapshot_restore_job = mongodbatlas.CloudProviderSnapshotRestoreJob(\"testCloudProviderSnapshotRestoreJob\",\n    project_id=test_cloud_provider_snapshot.project_id,\n    cluster_name=test_cloud_provider_snapshot.cluster_name,\n    snapshot_id=test_cloud_provider_snapshot.snapshot_id,\n    delivery_type_config=mongodbatlas.CloudProviderSnapshotRestoreJobDeliveryTypeConfigArgs(\n        automated=True,\n        target_cluster_name=\"MyCluster\",\n        target_project_id=\"5cf5a45a9ccf6400e60981b6\",\n    ),\n    opts=pulumi.ResourceOptions(depends_on=[test_cloud_provider_snapshot]))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myCluster = new Mongodbatlas.Cluster(\"myCluster\", new()\n    {\n        ProjectId = \"5cf5a45a9ccf6400e60981b6\",\n        DiskSizeGb = 5,\n        ProviderName = \"AWS\",\n        ProviderRegionName = \"EU_WEST_2\",\n        ProviderInstanceSizeName = \"M10\",\n        CloudBackup = true,\n    });\n\n    // enable cloud backup snapshots\n    var testCloudProviderSnapshot = new Mongodbatlas.CloudProviderSnapshot(\"testCloudProviderSnapshot\", new()\n    {\n        ProjectId = myCluster.ProjectId,\n        ClusterName = myCluster.Name,\n        Description = \"myDescription\",\n        RetentionInDays = 1,\n    });\n\n    var testCloudProviderSnapshotRestoreJob = new Mongodbatlas.CloudProviderSnapshotRestoreJob(\"testCloudProviderSnapshotRestoreJob\", new()\n    {\n        ProjectId = testCloudProviderSnapshot.ProjectId,\n        ClusterName = testCloudProviderSnapshot.ClusterName,\n        SnapshotId = testCloudProviderSnapshot.SnapshotId,\n        DeliveryTypeConfig = new Mongodbatlas.Inputs.CloudProviderSnapshotRestoreJobDeliveryTypeConfigArgs\n        {\n            Automated = true,\n            TargetClusterName = \"MyCluster\",\n            TargetProjectId = \"5cf5a45a9ccf6400e60981b6\",\n        },\n    }, new CustomResourceOptions\n    {\n        DependsOn = new[]\n        {\n            testCloudProviderSnapshot,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmyCluster, err := mongodbatlas.NewCluster(ctx, \"myCluster\", \u0026mongodbatlas.ClusterArgs{\n\t\t\tProjectId:                pulumi.String(\"5cf5a45a9ccf6400e60981b6\"),\n\t\t\tDiskSizeGb:               pulumi.Float64(5),\n\t\t\tProviderName:             pulumi.String(\"AWS\"),\n\t\t\tProviderRegionName:       pulumi.String(\"EU_WEST_2\"),\n\t\t\tProviderInstanceSizeName: pulumi.String(\"M10\"),\n\t\t\tCloudBackup:              pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestCloudProviderSnapshot, err := mongodbatlas.NewCloudProviderSnapshot(ctx, \"testCloudProviderSnapshot\", \u0026mongodbatlas.CloudProviderSnapshotArgs{\n\t\t\tProjectId:       myCluster.ProjectId,\n\t\t\tClusterName:     myCluster.Name,\n\t\t\tDescription:     pulumi.String(\"myDescription\"),\n\t\t\tRetentionInDays: pulumi.Int(1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewCloudProviderSnapshotRestoreJob(ctx, \"testCloudProviderSnapshotRestoreJob\", \u0026mongodbatlas.CloudProviderSnapshotRestoreJobArgs{\n\t\t\tProjectId:   testCloudProviderSnapshot.ProjectId,\n\t\t\tClusterName: testCloudProviderSnapshot.ClusterName,\n\t\t\tSnapshotId:  testCloudProviderSnapshot.SnapshotId,\n\t\t\tDeliveryTypeConfig: \u0026mongodbatlas.CloudProviderSnapshotRestoreJobDeliveryTypeConfigArgs{\n\t\t\t\tAutomated:         pulumi.Bool(true),\n\t\t\t\tTargetClusterName: pulumi.String(\"MyCluster\"),\n\t\t\t\tTargetProjectId:   pulumi.String(\"5cf5a45a9ccf6400e60981b6\"),\n\t\t\t},\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\ttestCloudProviderSnapshot,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Cluster;\nimport com.pulumi.mongodbatlas.ClusterArgs;\nimport com.pulumi.mongodbatlas.CloudProviderSnapshot;\nimport com.pulumi.mongodbatlas.CloudProviderSnapshotArgs;\nimport com.pulumi.mongodbatlas.CloudProviderSnapshotRestoreJob;\nimport com.pulumi.mongodbatlas.CloudProviderSnapshotRestoreJobArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudProviderSnapshotRestoreJobDeliveryTypeConfigArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myCluster = new Cluster(\"myCluster\", ClusterArgs.builder()        \n            .projectId(\"5cf5a45a9ccf6400e60981b6\")\n            .diskSizeGb(5)\n            .providerName(\"AWS\")\n            .providerRegionName(\"EU_WEST_2\")\n            .providerInstanceSizeName(\"M10\")\n            .cloudBackup(true)\n            .build());\n\n        var testCloudProviderSnapshot = new CloudProviderSnapshot(\"testCloudProviderSnapshot\", CloudProviderSnapshotArgs.builder()        \n            .projectId(myCluster.projectId())\n            .clusterName(myCluster.name())\n            .description(\"myDescription\")\n            .retentionInDays(1)\n            .build());\n\n        var testCloudProviderSnapshotRestoreJob = new CloudProviderSnapshotRestoreJob(\"testCloudProviderSnapshotRestoreJob\", CloudProviderSnapshotRestoreJobArgs.builder()        \n            .projectId(testCloudProviderSnapshot.projectId())\n            .clusterName(testCloudProviderSnapshot.clusterName())\n            .snapshotId(testCloudProviderSnapshot.snapshotId())\n            .deliveryTypeConfig(CloudProviderSnapshotRestoreJobDeliveryTypeConfigArgs.builder()\n                .automated(true)\n                .targetClusterName(\"MyCluster\")\n                .targetProjectId(\"5cf5a45a9ccf6400e60981b6\")\n                .build())\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(testCloudProviderSnapshot)\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myCluster:\n    type: mongodbatlas:Cluster\n    properties:\n      projectId: 5cf5a45a9ccf6400e60981b6\n      diskSizeGb: 5\n      # Provider Settings \"block\"\n      providerName: AWS\n      providerRegionName: EU_WEST_2\n      providerInstanceSizeName: M10\n      cloudBackup: true\n  testCloudProviderSnapshot:\n    type: mongodbatlas:CloudProviderSnapshot\n    properties:\n      projectId: ${myCluster.projectId}\n      clusterName: ${myCluster.name}\n      description: myDescription\n      retentionInDays: 1\n  testCloudProviderSnapshotRestoreJob:\n    type: mongodbatlas:CloudProviderSnapshotRestoreJob\n    properties:\n      projectId: ${testCloudProviderSnapshot.projectId}\n      clusterName: ${testCloudProviderSnapshot.clusterName}\n      snapshotId: ${testCloudProviderSnapshot.snapshotId}\n      deliveryTypeConfig:\n        automated: true\n        targetClusterName: MyCluster\n        targetProjectId: 5cf5a45a9ccf6400e60981b6\n    options:\n      dependson:\n        - ${testCloudProviderSnapshot}\n```\n{{% /example %}}\n{{% example %}}\n### Example download delivery type.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst myCluster = new mongodbatlas.Cluster(\"myCluster\", {\n    projectId: \"5cf5a45a9ccf6400e60981b6\",\n    diskSizeGb: 5,\n    providerName: \"AWS\",\n    providerRegionName: \"EU_WEST_2\",\n    providerInstanceSizeName: \"M10\",\n    cloudBackup: true,\n});\n// enable cloud backup snapshots\nconst testCloudProviderSnapshot = new mongodbatlas.CloudProviderSnapshot(\"testCloudProviderSnapshot\", {\n    projectId: myCluster.projectId,\n    clusterName: myCluster.name,\n    description: \"myDescription\",\n    retentionInDays: 1,\n});\nconst testCloudProviderSnapshotRestoreJob = new mongodbatlas.CloudProviderSnapshotRestoreJob(\"testCloudProviderSnapshotRestoreJob\", {\n    projectId: testCloudProviderSnapshot.projectId,\n    clusterName: testCloudProviderSnapshot.clusterName,\n    snapshotId: testCloudProviderSnapshot.snapshotId,\n    deliveryTypeConfig: {\n        download: true,\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nmy_cluster = mongodbatlas.Cluster(\"myCluster\",\n    project_id=\"5cf5a45a9ccf6400e60981b6\",\n    disk_size_gb=5,\n    provider_name=\"AWS\",\n    provider_region_name=\"EU_WEST_2\",\n    provider_instance_size_name=\"M10\",\n    cloud_backup=True)\n# enable cloud backup snapshots\ntest_cloud_provider_snapshot = mongodbatlas.CloudProviderSnapshot(\"testCloudProviderSnapshot\",\n    project_id=my_cluster.project_id,\n    cluster_name=my_cluster.name,\n    description=\"myDescription\",\n    retention_in_days=1)\ntest_cloud_provider_snapshot_restore_job = mongodbatlas.CloudProviderSnapshotRestoreJob(\"testCloudProviderSnapshotRestoreJob\",\n    project_id=test_cloud_provider_snapshot.project_id,\n    cluster_name=test_cloud_provider_snapshot.cluster_name,\n    snapshot_id=test_cloud_provider_snapshot.snapshot_id,\n    delivery_type_config=mongodbatlas.CloudProviderSnapshotRestoreJobDeliveryTypeConfigArgs(\n        download=True,\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myCluster = new Mongodbatlas.Cluster(\"myCluster\", new()\n    {\n        ProjectId = \"5cf5a45a9ccf6400e60981b6\",\n        DiskSizeGb = 5,\n        ProviderName = \"AWS\",\n        ProviderRegionName = \"EU_WEST_2\",\n        ProviderInstanceSizeName = \"M10\",\n        CloudBackup = true,\n    });\n\n    // enable cloud backup snapshots\n    var testCloudProviderSnapshot = new Mongodbatlas.CloudProviderSnapshot(\"testCloudProviderSnapshot\", new()\n    {\n        ProjectId = myCluster.ProjectId,\n        ClusterName = myCluster.Name,\n        Description = \"myDescription\",\n        RetentionInDays = 1,\n    });\n\n    var testCloudProviderSnapshotRestoreJob = new Mongodbatlas.CloudProviderSnapshotRestoreJob(\"testCloudProviderSnapshotRestoreJob\", new()\n    {\n        ProjectId = testCloudProviderSnapshot.ProjectId,\n        ClusterName = testCloudProviderSnapshot.ClusterName,\n        SnapshotId = testCloudProviderSnapshot.SnapshotId,\n        DeliveryTypeConfig = new Mongodbatlas.Inputs.CloudProviderSnapshotRestoreJobDeliveryTypeConfigArgs\n        {\n            Download = true,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmyCluster, err := mongodbatlas.NewCluster(ctx, \"myCluster\", \u0026mongodbatlas.ClusterArgs{\n\t\t\tProjectId:                pulumi.String(\"5cf5a45a9ccf6400e60981b6\"),\n\t\t\tDiskSizeGb:               pulumi.Float64(5),\n\t\t\tProviderName:             pulumi.String(\"AWS\"),\n\t\t\tProviderRegionName:       pulumi.String(\"EU_WEST_2\"),\n\t\t\tProviderInstanceSizeName: pulumi.String(\"M10\"),\n\t\t\tCloudBackup:              pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestCloudProviderSnapshot, err := mongodbatlas.NewCloudProviderSnapshot(ctx, \"testCloudProviderSnapshot\", \u0026mongodbatlas.CloudProviderSnapshotArgs{\n\t\t\tProjectId:       myCluster.ProjectId,\n\t\t\tClusterName:     myCluster.Name,\n\t\t\tDescription:     pulumi.String(\"myDescription\"),\n\t\t\tRetentionInDays: pulumi.Int(1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewCloudProviderSnapshotRestoreJob(ctx, \"testCloudProviderSnapshotRestoreJob\", \u0026mongodbatlas.CloudProviderSnapshotRestoreJobArgs{\n\t\t\tProjectId:   testCloudProviderSnapshot.ProjectId,\n\t\t\tClusterName: testCloudProviderSnapshot.ClusterName,\n\t\t\tSnapshotId:  testCloudProviderSnapshot.SnapshotId,\n\t\t\tDeliveryTypeConfig: \u0026mongodbatlas.CloudProviderSnapshotRestoreJobDeliveryTypeConfigArgs{\n\t\t\t\tDownload: pulumi.Bool(true),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Cluster;\nimport com.pulumi.mongodbatlas.ClusterArgs;\nimport com.pulumi.mongodbatlas.CloudProviderSnapshot;\nimport com.pulumi.mongodbatlas.CloudProviderSnapshotArgs;\nimport com.pulumi.mongodbatlas.CloudProviderSnapshotRestoreJob;\nimport com.pulumi.mongodbatlas.CloudProviderSnapshotRestoreJobArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudProviderSnapshotRestoreJobDeliveryTypeConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myCluster = new Cluster(\"myCluster\", ClusterArgs.builder()        \n            .projectId(\"5cf5a45a9ccf6400e60981b6\")\n            .diskSizeGb(5)\n            .providerName(\"AWS\")\n            .providerRegionName(\"EU_WEST_2\")\n            .providerInstanceSizeName(\"M10\")\n            .cloudBackup(true)\n            .build());\n\n        var testCloudProviderSnapshot = new CloudProviderSnapshot(\"testCloudProviderSnapshot\", CloudProviderSnapshotArgs.builder()        \n            .projectId(myCluster.projectId())\n            .clusterName(myCluster.name())\n            .description(\"myDescription\")\n            .retentionInDays(1)\n            .build());\n\n        var testCloudProviderSnapshotRestoreJob = new CloudProviderSnapshotRestoreJob(\"testCloudProviderSnapshotRestoreJob\", CloudProviderSnapshotRestoreJobArgs.builder()        \n            .projectId(testCloudProviderSnapshot.projectId())\n            .clusterName(testCloudProviderSnapshot.clusterName())\n            .snapshotId(testCloudProviderSnapshot.snapshotId())\n            .deliveryTypeConfig(CloudProviderSnapshotRestoreJobDeliveryTypeConfigArgs.builder()\n                .download(true)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myCluster:\n    type: mongodbatlas:Cluster\n    properties:\n      projectId: 5cf5a45a9ccf6400e60981b6\n      diskSizeGb: 5\n      # Provider Settings \"block\"\n      providerName: AWS\n      providerRegionName: EU_WEST_2\n      providerInstanceSizeName: M10\n      cloudBackup: true\n  testCloudProviderSnapshot:\n    type: mongodbatlas:CloudProviderSnapshot\n    properties:\n      projectId: ${myCluster.projectId}\n      clusterName: ${myCluster.name}\n      description: myDescription\n      retentionInDays: 1\n  testCloudProviderSnapshotRestoreJob:\n    type: mongodbatlas:CloudProviderSnapshotRestoreJob\n    properties:\n      projectId: ${testCloudProviderSnapshot.projectId}\n      clusterName: ${testCloudProviderSnapshot.clusterName}\n      snapshotId: ${testCloudProviderSnapshot.snapshotId}\n      deliveryTypeConfig:\n        download: true\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nCloud Backup Snapshot Restore Job entries can be imported using project project_id, cluster_name and snapshot_id (Unique identifier of the snapshot), in the format `PROJECTID-CLUSTERNAME-JOBID`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/cloudProviderSnapshotRestoreJob:CloudProviderSnapshotRestoreJob test 5cf5a45a9ccf6400e60981b6-MyCluster-5d1b654ecf09a24b888f4c79\n```\n\n For more information see[MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/cloud-backup/restore/restores/) ",
            "properties": {
                "cancelled": {
                    "type": "boolean",
                    "description": "Indicates whether the restore job was canceled.\n"
                },
                "clusterName": {
                    "type": "string",
                    "description": "The name of the Atlas cluster whose snapshot you want to restore.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "UTC ISO 8601 formatted point in time when Atlas created the restore job.\n"
                },
                "deliveryType": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Type of restore job to create. Possible values are: **download** or **automated**, only one must be set it in ``true``.\n",
                    "deprecationMessage": "use delivery_type_config instead"
                },
                "deliveryTypeConfig": {
                    "$ref": "#/types/mongodbatlas:index/CloudProviderSnapshotRestoreJobDeliveryTypeConfig:CloudProviderSnapshotRestoreJobDeliveryTypeConfig",
                    "description": "Type of restore job to create. Possible values are: automated and download.\n"
                },
                "deliveryUrls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "One or more URLs for the compressed snapshot files for manual download. Only visible if deliveryType is download.\n"
                },
                "expired": {
                    "type": "boolean",
                    "description": "Indicates whether the restore job expired.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "UTC ISO 8601 formatted point in time when the restore job expires.\n"
                },
                "finishedAt": {
                    "type": "string",
                    "description": "UTC ISO 8601 formatted point in time when the restore job completed.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier of the project for the Atlas cluster whose snapshot you want to restore.\n"
                },
                "snapshotId": {
                    "type": "string",
                    "description": "Unique identifier of the snapshot to restore.\n"
                },
                "snapshotRestoreJobId": {
                    "type": "string",
                    "description": "The unique identifier of the restore job.\n"
                },
                "timestamp": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when the snapshot associated to snapshotId was taken.\n"
                }
            },
            "required": [
                "cancelled",
                "clusterName",
                "createdAt",
                "deliveryUrls",
                "expired",
                "expiresAt",
                "finishedAt",
                "projectId",
                "snapshotId",
                "snapshotRestoreJobId",
                "timestamp"
            ],
            "inputProperties": {
                "clusterName": {
                    "type": "string",
                    "description": "The name of the Atlas cluster whose snapshot you want to restore.\n",
                    "willReplaceOnChanges": true
                },
                "deliveryType": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Type of restore job to create. Possible values are: **download** or **automated**, only one must be set it in ``true``.\n",
                    "deprecationMessage": "use delivery_type_config instead",
                    "willReplaceOnChanges": true
                },
                "deliveryTypeConfig": {
                    "$ref": "#/types/mongodbatlas:index/CloudProviderSnapshotRestoreJobDeliveryTypeConfig:CloudProviderSnapshotRestoreJobDeliveryTypeConfig",
                    "description": "Type of restore job to create. Possible values are: automated and download.\n",
                    "willReplaceOnChanges": true
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier of the project for the Atlas cluster whose snapshot you want to restore.\n",
                    "willReplaceOnChanges": true
                },
                "snapshotId": {
                    "type": "string",
                    "description": "Unique identifier of the snapshot to restore.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "clusterName",
                "projectId",
                "snapshotId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudProviderSnapshotRestoreJob resources.\n",
                "properties": {
                    "cancelled": {
                        "type": "boolean",
                        "description": "Indicates whether the restore job was canceled.\n"
                    },
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the Atlas cluster whose snapshot you want to restore.\n",
                        "willReplaceOnChanges": true
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "UTC ISO 8601 formatted point in time when Atlas created the restore job.\n"
                    },
                    "deliveryType": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Type of restore job to create. Possible values are: **download** or **automated**, only one must be set it in ``true``.\n",
                        "deprecationMessage": "use delivery_type_config instead",
                        "willReplaceOnChanges": true
                    },
                    "deliveryTypeConfig": {
                        "$ref": "#/types/mongodbatlas:index/CloudProviderSnapshotRestoreJobDeliveryTypeConfig:CloudProviderSnapshotRestoreJobDeliveryTypeConfig",
                        "description": "Type of restore job to create. Possible values are: automated and download.\n",
                        "willReplaceOnChanges": true
                    },
                    "deliveryUrls": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "One or more URLs for the compressed snapshot files for manual download. Only visible if deliveryType is download.\n"
                    },
                    "expired": {
                        "type": "boolean",
                        "description": "Indicates whether the restore job expired.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "UTC ISO 8601 formatted point in time when the restore job expires.\n"
                    },
                    "finishedAt": {
                        "type": "string",
                        "description": "UTC ISO 8601 formatted point in time when the restore job completed.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster whose snapshot you want to restore.\n",
                        "willReplaceOnChanges": true
                    },
                    "snapshotId": {
                        "type": "string",
                        "description": "Unique identifier of the snapshot to restore.\n",
                        "willReplaceOnChanges": true
                    },
                    "snapshotRestoreJobId": {
                        "type": "string",
                        "description": "The unique identifier of the restore job.\n"
                    },
                    "timestamp": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when the snapshot associated to snapshotId was taken.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/cluster:Cluster": {
            "description": "\n\n\n## Import\n\nClusters can be imported using project ID and cluster name, in the format `PROJECTID-CLUSTERNAME`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/cluster:Cluster my_cluster 1112222b3bf99403840e8934-Cluster0\n```\n\n See detailed information for arguments and attributes[MongoDB API Clusters](https://docs.atlas.mongodb.com/reference/api/clusters-create-one/) ",
            "properties": {
                "advancedConfiguration": {
                    "$ref": "#/types/mongodbatlas:index/ClusterAdvancedConfiguration:ClusterAdvancedConfiguration"
                },
                "autoScalingComputeEnabled": {
                    "type": "boolean",
                    "description": "Specifies whether cluster tier auto-scaling is enabled. The default is false.\n- Set to `true` to enable cluster tier auto-scaling. If enabled, you must specify a value for `providerSettings.autoScaling.compute.maxInstanceSize`.\n- Set to `false` to disable cluster tier auto-scaling.\n"
                },
                "autoScalingComputeScaleDownEnabled": {
                    "type": "boolean",
                    "description": "Set to `true` to enable the cluster tier to scale down. This option is only available if `autoScaling.compute.enabled` is `true`.\n- If this option is enabled, you must specify a value for `providerSettings.autoScaling.compute.minInstanceSize`\n"
                },
                "autoScalingDiskGbEnabled": {
                    "type": "boolean",
                    "description": "Specifies whether disk auto-scaling is enabled. The default is true.\n- Set to `true` to enable disk auto-scaling.\n- Set to `false` to disable disk auto-scaling.\n"
                },
                "backingProviderName": {
                    "type": "string",
                    "description": "Cloud service provider on which the server for a multi-tenant cluster is provisioned.\n"
                },
                "backupEnabled": {
                    "type": "boolean",
                    "description": "Clusters running MongoDB FCV 4.2 or later and any new Atlas clusters of any type do not support this parameter\n"
                },
                "biConnector": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies BI Connector for Atlas configuration on this cluster. BI Connector for Atlas is only available for M10+ clusters. See BI Connector below for more details. **DEPRECATED** Use `bi_connector_config` instead.\n",
                    "deprecationMessage": "use bi_connector_config instead"
                },
                "biConnectorConfig": {
                    "$ref": "#/types/mongodbatlas:index/ClusterBiConnectorConfig:ClusterBiConnectorConfig",
                    "description": "Specifies BI Connector for Atlas configuration on this cluster. BI Connector for Atlas is only available for M10+ clusters. See BI Connector below for more details.\n"
                },
                "cloudBackup": {
                    "type": "boolean",
                    "description": "Flag indicating if the cluster uses Cloud Backup for backups.\n"
                },
                "clusterId": {
                    "type": "string",
                    "description": "The cluster ID.\n"
                },
                "clusterType": {
                    "type": "string",
                    "description": "Specifies the type of the cluster that you want to modify. You cannot convert a sharded cluster deployment to a replica set deployment.\n"
                },
                "connectionStrings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ClusterConnectionString:ClusterConnectionString"
                    },
                    "description": "Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.\n"
                },
                "containerId": {
                    "type": "string",
                    "description": "The Container ID is the id of the container created when the first cluster in the region (AWS/Azure) or project (GCP) was created.\n"
                },
                "diskSizeGb": {
                    "type": "number",
                    "description": "Capacity, in gigabytes, of the host’s root volume. Increase this number to add capacity, up to a maximum possible value of 4096 (i.e., 4 TB). This value must be a positive integer.\n* The minimum disk size for dedicated clusters is 10GB for AWS and GCP. If you specify diskSizeGB with a lower disk size, Atlas defaults to the minimum disk size value.\n* Note: The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require additional storage space beyond this limitation, consider upgrading your cluster to a higher tier.\n* Cannot be used with clusters with local NVMe SSDs\n* Cannot be used with Azure clusters\n"
                },
                "encryptionAtRestProvider": {
                    "type": "string",
                    "description": "Possible values are AWS, GCP, AZURE or NONE.  Only needed if you desire to manage the keys, see [Encryption at Rest using Customer Key Management](https://docs.atlas.mongodb.com/security-aws-kms/) for complete documentation.  You must configure encryption at rest for the Atlas project before enabling it on any cluster in the project. For complete documentation on configuring Encryption at Rest, see Encryption at Rest using Customer Key Management. Requires M10 or greater. and for legacy backups, backup_enabled, to be false or omitted. **Note: Atlas encrypts all cluster storage and snapshot volumes, securing all cluster data on disk: a concept known as encryption at rest, by default**.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ClusterLabel:ClusterLabel"
                    }
                },
                "mongoDbMajorVersion": {
                    "type": "string",
                    "description": "Version of the cluster to deploy. Atlas supports the following MongoDB versions for M10+ clusters: `4.2`, `4.4`, `5.0`, or `6.0`. If omitted, Atlas deploys a cluster that runs MongoDB 5.0. If `provider_instance_size_name`: `M0`, `M2` or `M5`, Atlas deploys MongoDB 5.0. Atlas always deploys the cluster with the latest stable release of the specified version. See [Release Notes](https://www.mongodb.com/docs/upcoming/release-notes/) for latest Current Stable Release.\n"
                },
                "mongoDbVersion": {
                    "type": "string",
                    "description": "Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.\n"
                },
                "mongoUri": {
                    "type": "string",
                    "description": "Base connection string for the cluster. Atlas only displays this field after the cluster is operational, not while it builds the cluster.\n"
                },
                "mongoUriUpdated": {
                    "type": "string",
                    "description": "Lists when the connection string was last updated. The connection string changes, for example, if you change a replica set to a sharded cluster.\n"
                },
                "mongoUriWithOptions": {
                    "type": "string",
                    "description": "connection string for connecting to the Atlas cluster. Includes the replicaSet, ssl, and authSource query parameters in the connection string with values appropriate for the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the cluster as it appears in Atlas. Once the cluster is created, its name cannot be changed. **WARNING** Changing the name will result in destruction of the existing cluster and the creation of a new cluster.\n"
                },
                "numShards": {
                    "type": "integer",
                    "description": "Selects whether the cluster is a replica set or a sharded cluster. If you use the replicationSpecs parameter, you must set num_shards.\n"
                },
                "paused": {
                    "type": "boolean"
                },
                "pitEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates if the cluster uses Continuous Cloud Backup. If set to true, cloud_backup must also be set to true.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create the database user.\n"
                },
                "providerAutoScalingComputeMaxInstanceSize": {
                    "type": "string",
                    "description": "Maximum instance size to which your cluster can automatically scale (e.g., M40). Required if `autoScaling.compute.enabled` is `true`.\n"
                },
                "providerAutoScalingComputeMinInstanceSize": {
                    "type": "string",
                    "description": "Minimum instance size to which your cluster can automatically scale (e.g., M10). Required if `autoScaling.compute.scaleDownEnabled` is `true`.\n"
                },
                "providerBackupEnabled": {
                    "type": "boolean",
                    "description": "Flag indicating if the cluster uses Cloud Backup for backups. **Deprecated** use `cloud_backup` instead.\n",
                    "deprecationMessage": "This field is deprecated,please use cloud_backup instead"
                },
                "providerDiskIops": {
                    "type": "integer",
                    "description": "The maximum input/output operations per second (IOPS) the system can perform. The possible values depend on the selected `provider_instance_size_name` and `disk_size_gb`.  This setting requires that `provider_instance_size_name` to be M30 or greater and cannot be used with clusters with local NVMe SSDs.  The default value for `provider_disk_iops` is the same as the cluster tier's Standard IOPS value, as viewable in the Atlas console.  It is used in cases where a higher number of IOPS is needed and possible.  If a value is submitted that is lower or equal to the default IOPS value for the cluster tier Atlas ignores the requested value and uses the default.  More details available under the providerSettings.diskIOPS parameter: [MongoDB API Clusters](https://docs.atlas.mongodb.com/reference/api/clusters-create-one/)\n* You do not need to configure IOPS for a STANDARD disk configuration but only for a PROVISIONED configuration.\n"
                },
                "providerDiskTypeName": {
                    "type": "string",
                    "description": "Azure disk type of the server’s root volume. If omitted, Atlas uses the default disk type for the selected providerSettings.instanceSizeName.  Example disk types and associated storage sizes: P4 - 32GB, P6 - 64GB, P10 - 128GB, P15 - 256GB, P20 - 512GB, P30 - 1024GB, P40 - 2048GB, P50 - 4095GB.  More information and the most update to date disk types/storage sizes can be located at https://docs.atlas.mongodb.com/reference/api/clusters-create-one/.\n"
                },
                "providerEncryptEbsVolume": {
                    "type": "boolean",
                    "description": "**(Deprecated) The Flag is always true.** Flag that indicates whether the Amazon EBS encryption feature encrypts the host's root volume for both data at rest within the volume and for data moving between the volume and the cluster. Note: This setting is always enabled for clusters with local NVMe SSDs. **Atlas encrypts all cluster storage and snapshot volumes, securing all cluster data on disk: a concept known as encryption at rest, by default.**.\n",
                    "deprecationMessage": "All EBS volumes are encrypted by default, the option to disable encryption has been removed"
                },
                "providerEncryptEbsVolumeFlag": {
                    "type": "boolean"
                },
                "providerInstanceSizeName": {
                    "type": "string",
                    "description": "Atlas provides different instance sizes, each with a default storage capacity and RAM size. The instance size you select is used for all the data-bearing servers in your cluster. See [Create a Cluster](https://docs.atlas.mongodb.com/reference/api/clusters-create-one/) `providerSettings.instanceSizeName` for valid values and default resources.\n"
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud service provider on which the servers are provisioned.\n"
                },
                "providerRegionName": {
                    "type": "string",
                    "description": "Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).\nDo not specify this field when creating a multi-region cluster using the replicationSpec document or a Global Cluster with the replicationSpecs array.\n"
                },
                "providerVolumeType": {
                    "type": "string",
                    "description": "The type of the volume. The possible values are: `STANDARD` and `PROVISIONED`.  `PROVISIONED` is ONLY required if setting IOPS higher than the default instance IOPS.\n"
                },
                "replicationFactor": {
                    "type": "integer",
                    "description": "Number of replica set members. Each member keeps a copy of your databases, providing high availability and data redundancy. The possible values are 3, 5, or 7. The default value is 3.\n"
                },
                "replicationSpecs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ClusterReplicationSpec:ClusterReplicationSpec"
                    },
                    "description": "Configuration for cluster regions.  See Replication Spec below for more details.\n"
                },
                "snapshotBackupPolicies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ClusterSnapshotBackupPolicy:ClusterSnapshotBackupPolicy"
                    },
                    "description": "current snapshot schedule and retention settings for the cluster.\n"
                },
                "srvAddress": {
                    "type": "string",
                    "description": "Connection string for connecting to the Atlas cluster. The +srv modifier forces the connection to use TLS/SSL. See the mongoURI for additional options.\n"
                },
                "stateName": {
                    "type": "string",
                    "description": "Current state of the cluster. The possible states are:\n- IDLE\n- CREATING\n- UPDATING\n- DELETING\n- DELETED\n- REPAIRING\n"
                },
                "terminationProtectionEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n"
                },
                "versionReleaseSystem": {
                    "type": "string",
                    "description": "Release cadence that Atlas uses for this cluster. This parameter defaults to `LTS`. If you set this field to `CONTINUOUS`, you must omit the `mongo_db_major_version` field. Atlas accepts:\n"
                }
            },
            "required": [
                "advancedConfiguration",
                "autoScalingComputeEnabled",
                "autoScalingComputeScaleDownEnabled",
                "backingProviderName",
                "biConnectorConfig",
                "clusterId",
                "clusterType",
                "connectionStrings",
                "containerId",
                "diskSizeGb",
                "encryptionAtRestProvider",
                "labels",
                "mongoDbMajorVersion",
                "mongoDbVersion",
                "mongoUri",
                "mongoUriUpdated",
                "mongoUriWithOptions",
                "name",
                "pitEnabled",
                "projectId",
                "providerAutoScalingComputeMaxInstanceSize",
                "providerAutoScalingComputeMinInstanceSize",
                "providerDiskIops",
                "providerDiskTypeName",
                "providerEncryptEbsVolume",
                "providerEncryptEbsVolumeFlag",
                "providerInstanceSizeName",
                "providerName",
                "providerRegionName",
                "providerVolumeType",
                "replicationFactor",
                "replicationSpecs",
                "snapshotBackupPolicies",
                "srvAddress",
                "stateName",
                "terminationProtectionEnabled"
            ],
            "inputProperties": {
                "advancedConfiguration": {
                    "$ref": "#/types/mongodbatlas:index/ClusterAdvancedConfiguration:ClusterAdvancedConfiguration"
                },
                "autoScalingComputeEnabled": {
                    "type": "boolean",
                    "description": "Specifies whether cluster tier auto-scaling is enabled. The default is false.\n- Set to `true` to enable cluster tier auto-scaling. If enabled, you must specify a value for `providerSettings.autoScaling.compute.maxInstanceSize`.\n- Set to `false` to disable cluster tier auto-scaling.\n"
                },
                "autoScalingComputeScaleDownEnabled": {
                    "type": "boolean",
                    "description": "Set to `true` to enable the cluster tier to scale down. This option is only available if `autoScaling.compute.enabled` is `true`.\n- If this option is enabled, you must specify a value for `providerSettings.autoScaling.compute.minInstanceSize`\n"
                },
                "autoScalingDiskGbEnabled": {
                    "type": "boolean",
                    "description": "Specifies whether disk auto-scaling is enabled. The default is true.\n- Set to `true` to enable disk auto-scaling.\n- Set to `false` to disable disk auto-scaling.\n"
                },
                "backingProviderName": {
                    "type": "string",
                    "description": "Cloud service provider on which the server for a multi-tenant cluster is provisioned.\n"
                },
                "backupEnabled": {
                    "type": "boolean",
                    "description": "Clusters running MongoDB FCV 4.2 or later and any new Atlas clusters of any type do not support this parameter\n"
                },
                "biConnector": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies BI Connector for Atlas configuration on this cluster. BI Connector for Atlas is only available for M10+ clusters. See BI Connector below for more details. **DEPRECATED** Use `bi_connector_config` instead.\n",
                    "deprecationMessage": "use bi_connector_config instead"
                },
                "biConnectorConfig": {
                    "$ref": "#/types/mongodbatlas:index/ClusterBiConnectorConfig:ClusterBiConnectorConfig",
                    "description": "Specifies BI Connector for Atlas configuration on this cluster. BI Connector for Atlas is only available for M10+ clusters. See BI Connector below for more details.\n"
                },
                "cloudBackup": {
                    "type": "boolean",
                    "description": "Flag indicating if the cluster uses Cloud Backup for backups.\n"
                },
                "clusterType": {
                    "type": "string",
                    "description": "Specifies the type of the cluster that you want to modify. You cannot convert a sharded cluster deployment to a replica set deployment.\n"
                },
                "diskSizeGb": {
                    "type": "number",
                    "description": "Capacity, in gigabytes, of the host’s root volume. Increase this number to add capacity, up to a maximum possible value of 4096 (i.e., 4 TB). This value must be a positive integer.\n* The minimum disk size for dedicated clusters is 10GB for AWS and GCP. If you specify diskSizeGB with a lower disk size, Atlas defaults to the minimum disk size value.\n* Note: The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require additional storage space beyond this limitation, consider upgrading your cluster to a higher tier.\n* Cannot be used with clusters with local NVMe SSDs\n* Cannot be used with Azure clusters\n"
                },
                "encryptionAtRestProvider": {
                    "type": "string",
                    "description": "Possible values are AWS, GCP, AZURE or NONE.  Only needed if you desire to manage the keys, see [Encryption at Rest using Customer Key Management](https://docs.atlas.mongodb.com/security-aws-kms/) for complete documentation.  You must configure encryption at rest for the Atlas project before enabling it on any cluster in the project. For complete documentation on configuring Encryption at Rest, see Encryption at Rest using Customer Key Management. Requires M10 or greater. and for legacy backups, backup_enabled, to be false or omitted. **Note: Atlas encrypts all cluster storage and snapshot volumes, securing all cluster data on disk: a concept known as encryption at rest, by default**.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ClusterLabel:ClusterLabel"
                    }
                },
                "mongoDbMajorVersion": {
                    "type": "string",
                    "description": "Version of the cluster to deploy. Atlas supports the following MongoDB versions for M10+ clusters: `4.2`, `4.4`, `5.0`, or `6.0`. If omitted, Atlas deploys a cluster that runs MongoDB 5.0. If `provider_instance_size_name`: `M0`, `M2` or `M5`, Atlas deploys MongoDB 5.0. Atlas always deploys the cluster with the latest stable release of the specified version. See [Release Notes](https://www.mongodb.com/docs/upcoming/release-notes/) for latest Current Stable Release.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the cluster as it appears in Atlas. Once the cluster is created, its name cannot be changed. **WARNING** Changing the name will result in destruction of the existing cluster and the creation of a new cluster.\n",
                    "willReplaceOnChanges": true
                },
                "numShards": {
                    "type": "integer",
                    "description": "Selects whether the cluster is a replica set or a sharded cluster. If you use the replicationSpecs parameter, you must set num_shards.\n"
                },
                "paused": {
                    "type": "boolean"
                },
                "pitEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates if the cluster uses Continuous Cloud Backup. If set to true, cloud_backup must also be set to true.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create the database user.\n",
                    "willReplaceOnChanges": true
                },
                "providerAutoScalingComputeMaxInstanceSize": {
                    "type": "string",
                    "description": "Maximum instance size to which your cluster can automatically scale (e.g., M40). Required if `autoScaling.compute.enabled` is `true`.\n"
                },
                "providerAutoScalingComputeMinInstanceSize": {
                    "type": "string",
                    "description": "Minimum instance size to which your cluster can automatically scale (e.g., M10). Required if `autoScaling.compute.scaleDownEnabled` is `true`.\n"
                },
                "providerBackupEnabled": {
                    "type": "boolean",
                    "description": "Flag indicating if the cluster uses Cloud Backup for backups. **Deprecated** use `cloud_backup` instead.\n",
                    "deprecationMessage": "This field is deprecated,please use cloud_backup instead"
                },
                "providerDiskIops": {
                    "type": "integer",
                    "description": "The maximum input/output operations per second (IOPS) the system can perform. The possible values depend on the selected `provider_instance_size_name` and `disk_size_gb`.  This setting requires that `provider_instance_size_name` to be M30 or greater and cannot be used with clusters with local NVMe SSDs.  The default value for `provider_disk_iops` is the same as the cluster tier's Standard IOPS value, as viewable in the Atlas console.  It is used in cases where a higher number of IOPS is needed and possible.  If a value is submitted that is lower or equal to the default IOPS value for the cluster tier Atlas ignores the requested value and uses the default.  More details available under the providerSettings.diskIOPS parameter: [MongoDB API Clusters](https://docs.atlas.mongodb.com/reference/api/clusters-create-one/)\n* You do not need to configure IOPS for a STANDARD disk configuration but only for a PROVISIONED configuration.\n"
                },
                "providerDiskTypeName": {
                    "type": "string",
                    "description": "Azure disk type of the server’s root volume. If omitted, Atlas uses the default disk type for the selected providerSettings.instanceSizeName.  Example disk types and associated storage sizes: P4 - 32GB, P6 - 64GB, P10 - 128GB, P15 - 256GB, P20 - 512GB, P30 - 1024GB, P40 - 2048GB, P50 - 4095GB.  More information and the most update to date disk types/storage sizes can be located at https://docs.atlas.mongodb.com/reference/api/clusters-create-one/.\n"
                },
                "providerEncryptEbsVolume": {
                    "type": "boolean",
                    "description": "**(Deprecated) The Flag is always true.** Flag that indicates whether the Amazon EBS encryption feature encrypts the host's root volume for both data at rest within the volume and for data moving between the volume and the cluster. Note: This setting is always enabled for clusters with local NVMe SSDs. **Atlas encrypts all cluster storage and snapshot volumes, securing all cluster data on disk: a concept known as encryption at rest, by default.**.\n",
                    "deprecationMessage": "All EBS volumes are encrypted by default, the option to disable encryption has been removed"
                },
                "providerInstanceSizeName": {
                    "type": "string",
                    "description": "Atlas provides different instance sizes, each with a default storage capacity and RAM size. The instance size you select is used for all the data-bearing servers in your cluster. See [Create a Cluster](https://docs.atlas.mongodb.com/reference/api/clusters-create-one/) `providerSettings.instanceSizeName` for valid values and default resources.\n"
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud service provider on which the servers are provisioned.\n"
                },
                "providerRegionName": {
                    "type": "string",
                    "description": "Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).\nDo not specify this field when creating a multi-region cluster using the replicationSpec document or a Global Cluster with the replicationSpecs array.\n"
                },
                "providerVolumeType": {
                    "type": "string",
                    "description": "The type of the volume. The possible values are: `STANDARD` and `PROVISIONED`.  `PROVISIONED` is ONLY required if setting IOPS higher than the default instance IOPS.\n"
                },
                "replicationFactor": {
                    "type": "integer",
                    "description": "Number of replica set members. Each member keeps a copy of your databases, providing high availability and data redundancy. The possible values are 3, 5, or 7. The default value is 3.\n"
                },
                "replicationSpecs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ClusterReplicationSpec:ClusterReplicationSpec"
                    },
                    "description": "Configuration for cluster regions.  See Replication Spec below for more details.\n"
                },
                "terminationProtectionEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n"
                },
                "versionReleaseSystem": {
                    "type": "string",
                    "description": "Release cadence that Atlas uses for this cluster. This parameter defaults to `LTS`. If you set this field to `CONTINUOUS`, you must omit the `mongo_db_major_version` field. Atlas accepts:\n"
                }
            },
            "requiredInputs": [
                "projectId",
                "providerInstanceSizeName",
                "providerName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Cluster resources.\n",
                "properties": {
                    "advancedConfiguration": {
                        "$ref": "#/types/mongodbatlas:index/ClusterAdvancedConfiguration:ClusterAdvancedConfiguration"
                    },
                    "autoScalingComputeEnabled": {
                        "type": "boolean",
                        "description": "Specifies whether cluster tier auto-scaling is enabled. The default is false.\n- Set to `true` to enable cluster tier auto-scaling. If enabled, you must specify a value for `providerSettings.autoScaling.compute.maxInstanceSize`.\n- Set to `false` to disable cluster tier auto-scaling.\n"
                    },
                    "autoScalingComputeScaleDownEnabled": {
                        "type": "boolean",
                        "description": "Set to `true` to enable the cluster tier to scale down. This option is only available if `autoScaling.compute.enabled` is `true`.\n- If this option is enabled, you must specify a value for `providerSettings.autoScaling.compute.minInstanceSize`\n"
                    },
                    "autoScalingDiskGbEnabled": {
                        "type": "boolean",
                        "description": "Specifies whether disk auto-scaling is enabled. The default is true.\n- Set to `true` to enable disk auto-scaling.\n- Set to `false` to disable disk auto-scaling.\n"
                    },
                    "backingProviderName": {
                        "type": "string",
                        "description": "Cloud service provider on which the server for a multi-tenant cluster is provisioned.\n"
                    },
                    "backupEnabled": {
                        "type": "boolean",
                        "description": "Clusters running MongoDB FCV 4.2 or later and any new Atlas clusters of any type do not support this parameter\n"
                    },
                    "biConnector": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Specifies BI Connector for Atlas configuration on this cluster. BI Connector for Atlas is only available for M10+ clusters. See BI Connector below for more details. **DEPRECATED** Use `bi_connector_config` instead.\n",
                        "deprecationMessage": "use bi_connector_config instead"
                    },
                    "biConnectorConfig": {
                        "$ref": "#/types/mongodbatlas:index/ClusterBiConnectorConfig:ClusterBiConnectorConfig",
                        "description": "Specifies BI Connector for Atlas configuration on this cluster. BI Connector for Atlas is only available for M10+ clusters. See BI Connector below for more details.\n"
                    },
                    "cloudBackup": {
                        "type": "boolean",
                        "description": "Flag indicating if the cluster uses Cloud Backup for backups.\n"
                    },
                    "clusterId": {
                        "type": "string",
                        "description": "The cluster ID.\n"
                    },
                    "clusterType": {
                        "type": "string",
                        "description": "Specifies the type of the cluster that you want to modify. You cannot convert a sharded cluster deployment to a replica set deployment.\n"
                    },
                    "connectionStrings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/ClusterConnectionString:ClusterConnectionString"
                        },
                        "description": "Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.\n"
                    },
                    "containerId": {
                        "type": "string",
                        "description": "The Container ID is the id of the container created when the first cluster in the region (AWS/Azure) or project (GCP) was created.\n"
                    },
                    "diskSizeGb": {
                        "type": "number",
                        "description": "Capacity, in gigabytes, of the host’s root volume. Increase this number to add capacity, up to a maximum possible value of 4096 (i.e., 4 TB). This value must be a positive integer.\n* The minimum disk size for dedicated clusters is 10GB for AWS and GCP. If you specify diskSizeGB with a lower disk size, Atlas defaults to the minimum disk size value.\n* Note: The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require additional storage space beyond this limitation, consider upgrading your cluster to a higher tier.\n* Cannot be used with clusters with local NVMe SSDs\n* Cannot be used with Azure clusters\n"
                    },
                    "encryptionAtRestProvider": {
                        "type": "string",
                        "description": "Possible values are AWS, GCP, AZURE or NONE.  Only needed if you desire to manage the keys, see [Encryption at Rest using Customer Key Management](https://docs.atlas.mongodb.com/security-aws-kms/) for complete documentation.  You must configure encryption at rest for the Atlas project before enabling it on any cluster in the project. For complete documentation on configuring Encryption at Rest, see Encryption at Rest using Customer Key Management. Requires M10 or greater. and for legacy backups, backup_enabled, to be false or omitted. **Note: Atlas encrypts all cluster storage and snapshot volumes, securing all cluster data on disk: a concept known as encryption at rest, by default**.\n"
                    },
                    "labels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/ClusterLabel:ClusterLabel"
                        }
                    },
                    "mongoDbMajorVersion": {
                        "type": "string",
                        "description": "Version of the cluster to deploy. Atlas supports the following MongoDB versions for M10+ clusters: `4.2`, `4.4`, `5.0`, or `6.0`. If omitted, Atlas deploys a cluster that runs MongoDB 5.0. If `provider_instance_size_name`: `M0`, `M2` or `M5`, Atlas deploys MongoDB 5.0. Atlas always deploys the cluster with the latest stable release of the specified version. See [Release Notes](https://www.mongodb.com/docs/upcoming/release-notes/) for latest Current Stable Release.\n"
                    },
                    "mongoDbVersion": {
                        "type": "string",
                        "description": "Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.\n"
                    },
                    "mongoUri": {
                        "type": "string",
                        "description": "Base connection string for the cluster. Atlas only displays this field after the cluster is operational, not while it builds the cluster.\n"
                    },
                    "mongoUriUpdated": {
                        "type": "string",
                        "description": "Lists when the connection string was last updated. The connection string changes, for example, if you change a replica set to a sharded cluster.\n"
                    },
                    "mongoUriWithOptions": {
                        "type": "string",
                        "description": "connection string for connecting to the Atlas cluster. Includes the replicaSet, ssl, and authSource query parameters in the connection string with values appropriate for the cluster.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the cluster as it appears in Atlas. Once the cluster is created, its name cannot be changed. **WARNING** Changing the name will result in destruction of the existing cluster and the creation of a new cluster.\n",
                        "willReplaceOnChanges": true
                    },
                    "numShards": {
                        "type": "integer",
                        "description": "Selects whether the cluster is a replica set or a sharded cluster. If you use the replicationSpecs parameter, you must set num_shards.\n"
                    },
                    "paused": {
                        "type": "boolean"
                    },
                    "pitEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates if the cluster uses Continuous Cloud Backup. If set to true, cloud_backup must also be set to true.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the database user.\n",
                        "willReplaceOnChanges": true
                    },
                    "providerAutoScalingComputeMaxInstanceSize": {
                        "type": "string",
                        "description": "Maximum instance size to which your cluster can automatically scale (e.g., M40). Required if `autoScaling.compute.enabled` is `true`.\n"
                    },
                    "providerAutoScalingComputeMinInstanceSize": {
                        "type": "string",
                        "description": "Minimum instance size to which your cluster can automatically scale (e.g., M10). Required if `autoScaling.compute.scaleDownEnabled` is `true`.\n"
                    },
                    "providerBackupEnabled": {
                        "type": "boolean",
                        "description": "Flag indicating if the cluster uses Cloud Backup for backups. **Deprecated** use `cloud_backup` instead.\n",
                        "deprecationMessage": "This field is deprecated,please use cloud_backup instead"
                    },
                    "providerDiskIops": {
                        "type": "integer",
                        "description": "The maximum input/output operations per second (IOPS) the system can perform. The possible values depend on the selected `provider_instance_size_name` and `disk_size_gb`.  This setting requires that `provider_instance_size_name` to be M30 or greater and cannot be used with clusters with local NVMe SSDs.  The default value for `provider_disk_iops` is the same as the cluster tier's Standard IOPS value, as viewable in the Atlas console.  It is used in cases where a higher number of IOPS is needed and possible.  If a value is submitted that is lower or equal to the default IOPS value for the cluster tier Atlas ignores the requested value and uses the default.  More details available under the providerSettings.diskIOPS parameter: [MongoDB API Clusters](https://docs.atlas.mongodb.com/reference/api/clusters-create-one/)\n* You do not need to configure IOPS for a STANDARD disk configuration but only for a PROVISIONED configuration.\n"
                    },
                    "providerDiskTypeName": {
                        "type": "string",
                        "description": "Azure disk type of the server’s root volume. If omitted, Atlas uses the default disk type for the selected providerSettings.instanceSizeName.  Example disk types and associated storage sizes: P4 - 32GB, P6 - 64GB, P10 - 128GB, P15 - 256GB, P20 - 512GB, P30 - 1024GB, P40 - 2048GB, P50 - 4095GB.  More information and the most update to date disk types/storage sizes can be located at https://docs.atlas.mongodb.com/reference/api/clusters-create-one/.\n"
                    },
                    "providerEncryptEbsVolume": {
                        "type": "boolean",
                        "description": "**(Deprecated) The Flag is always true.** Flag that indicates whether the Amazon EBS encryption feature encrypts the host's root volume for both data at rest within the volume and for data moving between the volume and the cluster. Note: This setting is always enabled for clusters with local NVMe SSDs. **Atlas encrypts all cluster storage and snapshot volumes, securing all cluster data on disk: a concept known as encryption at rest, by default.**.\n",
                        "deprecationMessage": "All EBS volumes are encrypted by default, the option to disable encryption has been removed"
                    },
                    "providerEncryptEbsVolumeFlag": {
                        "type": "boolean"
                    },
                    "providerInstanceSizeName": {
                        "type": "string",
                        "description": "Atlas provides different instance sizes, each with a default storage capacity and RAM size. The instance size you select is used for all the data-bearing servers in your cluster. See [Create a Cluster](https://docs.atlas.mongodb.com/reference/api/clusters-create-one/) `providerSettings.instanceSizeName` for valid values and default resources.\n"
                    },
                    "providerName": {
                        "type": "string",
                        "description": "Cloud service provider on which the servers are provisioned.\n"
                    },
                    "providerRegionName": {
                        "type": "string",
                        "description": "Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).\nDo not specify this field when creating a multi-region cluster using the replicationSpec document or a Global Cluster with the replicationSpecs array.\n"
                    },
                    "providerVolumeType": {
                        "type": "string",
                        "description": "The type of the volume. The possible values are: `STANDARD` and `PROVISIONED`.  `PROVISIONED` is ONLY required if setting IOPS higher than the default instance IOPS.\n"
                    },
                    "replicationFactor": {
                        "type": "integer",
                        "description": "Number of replica set members. Each member keeps a copy of your databases, providing high availability and data redundancy. The possible values are 3, 5, or 7. The default value is 3.\n"
                    },
                    "replicationSpecs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/ClusterReplicationSpec:ClusterReplicationSpec"
                        },
                        "description": "Configuration for cluster regions.  See Replication Spec below for more details.\n"
                    },
                    "snapshotBackupPolicies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/ClusterSnapshotBackupPolicy:ClusterSnapshotBackupPolicy"
                        },
                        "description": "current snapshot schedule and retention settings for the cluster.\n"
                    },
                    "srvAddress": {
                        "type": "string",
                        "description": "Connection string for connecting to the Atlas cluster. The +srv modifier forces the connection to use TLS/SSL. See the mongoURI for additional options.\n"
                    },
                    "stateName": {
                        "type": "string",
                        "description": "Current state of the cluster. The possible states are:\n- IDLE\n- CREATING\n- UPDATING\n- DELETING\n- DELETED\n- REPAIRING\n"
                    },
                    "terminationProtectionEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n"
                    },
                    "versionReleaseSystem": {
                        "type": "string",
                        "description": "Release cadence that Atlas uses for this cluster. This parameter defaults to `LTS`. If you set this field to `CONTINUOUS`, you must omit the `mongo_db_major_version` field. Atlas accepts:\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/customDbRole:CustomDbRole": {
            "description": "`mongodbatlas.CustomDbRole` provides a Custom DB Role resource. The customDBRoles resource lets you retrieve, create and modify the custom MongoDB roles in your cluster. Use custom MongoDB roles to specify custom sets of actions which cannot be described by the built-in Atlas database user privileges.\n\n\u003e **IMPORTANT**  You define custom roles at the project level for all clusters in the project. The `mongodbatlas.CustomDbRole` resource supports a subset of MongoDB privilege actions. For a complete list of [privilege actions](https://docs.mongodb.com/manual/reference/privilege-actions/) available for this resource, see [Custom Role actions](https://docs.atlas.mongodb.com/reference/api/custom-role-actions/). Custom roles must include actions that all project's clusters support, and that are compatible with each MongoDB version used by your project's clusters. For example, if your project has MongoDB 4.2 clusters, you can't create custom roles that use actions introduced in MongoDB 4.4.\n\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testRole = new mongodbatlas.CustomDbRole(\"testRole\", {\n    actions: [\n        {\n            action: \"UPDATE\",\n            resources: [{\n                collectionName: \"\",\n                databaseName: \"anyDatabase\",\n            }],\n        },\n        {\n            action: \"INSERT\",\n            resources: [{\n                collectionName: \"\",\n                databaseName: \"anyDatabase\",\n            }],\n        },\n        {\n            action: \"REMOVE\",\n            resources: [{\n                collectionName: \"\",\n                databaseName: \"anyDatabase\",\n            }],\n        },\n    ],\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    roleName: \"myCustomRole\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_role = mongodbatlas.CustomDbRole(\"testRole\",\n    actions=[\n        mongodbatlas.CustomDbRoleActionArgs(\n            action=\"UPDATE\",\n            resources=[mongodbatlas.CustomDbRoleActionResourceArgs(\n                collection_name=\"\",\n                database_name=\"anyDatabase\",\n            )],\n        ),\n        mongodbatlas.CustomDbRoleActionArgs(\n            action=\"INSERT\",\n            resources=[mongodbatlas.CustomDbRoleActionResourceArgs(\n                collection_name=\"\",\n                database_name=\"anyDatabase\",\n            )],\n        ),\n        mongodbatlas.CustomDbRoleActionArgs(\n            action=\"REMOVE\",\n            resources=[mongodbatlas.CustomDbRoleActionResourceArgs(\n                collection_name=\"\",\n                database_name=\"anyDatabase\",\n            )],\n        ),\n    ],\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    role_name=\"myCustomRole\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testRole = new Mongodbatlas.CustomDbRole(\"testRole\", new()\n    {\n        Actions = new[]\n        {\n            new Mongodbatlas.Inputs.CustomDbRoleActionArgs\n            {\n                Action = \"UPDATE\",\n                Resources = new[]\n                {\n                    new Mongodbatlas.Inputs.CustomDbRoleActionResourceArgs\n                    {\n                        CollectionName = \"\",\n                        DatabaseName = \"anyDatabase\",\n                    },\n                },\n            },\n            new Mongodbatlas.Inputs.CustomDbRoleActionArgs\n            {\n                Action = \"INSERT\",\n                Resources = new[]\n                {\n                    new Mongodbatlas.Inputs.CustomDbRoleActionResourceArgs\n                    {\n                        CollectionName = \"\",\n                        DatabaseName = \"anyDatabase\",\n                    },\n                },\n            },\n            new Mongodbatlas.Inputs.CustomDbRoleActionArgs\n            {\n                Action = \"REMOVE\",\n                Resources = new[]\n                {\n                    new Mongodbatlas.Inputs.CustomDbRoleActionResourceArgs\n                    {\n                        CollectionName = \"\",\n                        DatabaseName = \"anyDatabase\",\n                    },\n                },\n            },\n        },\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        RoleName = \"myCustomRole\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewCustomDbRole(ctx, \"testRole\", \u0026mongodbatlas.CustomDbRoleArgs{\n\t\t\tActions: mongodbatlas.CustomDbRoleActionArray{\n\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionArgs{\n\t\t\t\t\tAction: pulumi.String(\"UPDATE\"),\n\t\t\t\t\tResources: mongodbatlas.CustomDbRoleActionResourceArray{\n\t\t\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionResourceArgs{\n\t\t\t\t\t\t\tCollectionName: pulumi.String(\"\"),\n\t\t\t\t\t\t\tDatabaseName:   pulumi.String(\"anyDatabase\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionArgs{\n\t\t\t\t\tAction: pulumi.String(\"INSERT\"),\n\t\t\t\t\tResources: mongodbatlas.CustomDbRoleActionResourceArray{\n\t\t\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionResourceArgs{\n\t\t\t\t\t\t\tCollectionName: pulumi.String(\"\"),\n\t\t\t\t\t\t\tDatabaseName:   pulumi.String(\"anyDatabase\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionArgs{\n\t\t\t\t\tAction: pulumi.String(\"REMOVE\"),\n\t\t\t\t\tResources: mongodbatlas.CustomDbRoleActionResourceArray{\n\t\t\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionResourceArgs{\n\t\t\t\t\t\t\tCollectionName: pulumi.String(\"\"),\n\t\t\t\t\t\t\tDatabaseName:   pulumi.String(\"anyDatabase\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tRoleName:  pulumi.String(\"myCustomRole\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CustomDbRole;\nimport com.pulumi.mongodbatlas.CustomDbRoleArgs;\nimport com.pulumi.mongodbatlas.inputs.CustomDbRoleActionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testRole = new CustomDbRole(\"testRole\", CustomDbRoleArgs.builder()        \n            .actions(            \n                CustomDbRoleActionArgs.builder()\n                    .action(\"UPDATE\")\n                    .resources(CustomDbRoleActionResourceArgs.builder()\n                        .collectionName(\"\")\n                        .databaseName(\"anyDatabase\")\n                        .build())\n                    .build(),\n                CustomDbRoleActionArgs.builder()\n                    .action(\"INSERT\")\n                    .resources(CustomDbRoleActionResourceArgs.builder()\n                        .collectionName(\"\")\n                        .databaseName(\"anyDatabase\")\n                        .build())\n                    .build(),\n                CustomDbRoleActionArgs.builder()\n                    .action(\"REMOVE\")\n                    .resources(CustomDbRoleActionResourceArgs.builder()\n                        .collectionName(\"\")\n                        .databaseName(\"anyDatabase\")\n                        .build())\n                    .build())\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .roleName(\"myCustomRole\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testRole:\n    type: mongodbatlas:CustomDbRole\n    properties:\n      actions:\n        - action: UPDATE\n          resources:\n            - collectionName:\n              databaseName: anyDatabase\n        - action: INSERT\n          resources:\n            - collectionName:\n              databaseName: anyDatabase\n        - action: REMOVE\n          resources:\n            - collectionName:\n              databaseName: anyDatabase\n      projectId: \u003cPROJECT-ID\u003e\n      roleName: myCustomRole\n```\n\n{{% /example %}}\n{{% example %}}\n### With Inherited Roles\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst inheritedRoleOne = new mongodbatlas.CustomDbRole(\"inheritedRoleOne\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    roleName: \"insertRole\",\n    actions: [{\n        action: \"INSERT\",\n        resources: [{\n            collectionName: \"\",\n            databaseName: \"anyDatabase\",\n        }],\n    }],\n});\nconst inheritedRoleTwo = new mongodbatlas.CustomDbRole(\"inheritedRoleTwo\", {\n    projectId: inheritedRoleOne.projectId,\n    roleName: \"statusServerRole\",\n    actions: [{\n        action: \"SERVER_STATUS\",\n        resources: [{\n            cluster: true,\n        }],\n    }],\n});\nconst testRole = new mongodbatlas.CustomDbRole(\"testRole\", {\n    projectId: inheritedRoleOne.projectId,\n    roleName: \"myCustomRole\",\n    actions: [\n        {\n            action: \"UPDATE\",\n            resources: [{\n                collectionName: \"\",\n                databaseName: \"anyDatabase\",\n            }],\n        },\n        {\n            action: \"REMOVE\",\n            resources: [{\n                collectionName: \"\",\n                databaseName: \"anyDatabase\",\n            }],\n        },\n    ],\n    inheritedRoles: [\n        {\n            roleName: inheritedRoleOne.roleName,\n            databaseName: \"admin\",\n        },\n        {\n            roleName: inheritedRoleTwo.roleName,\n            databaseName: \"admin\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ninherited_role_one = mongodbatlas.CustomDbRole(\"inheritedRoleOne\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    role_name=\"insertRole\",\n    actions=[mongodbatlas.CustomDbRoleActionArgs(\n        action=\"INSERT\",\n        resources=[mongodbatlas.CustomDbRoleActionResourceArgs(\n            collection_name=\"\",\n            database_name=\"anyDatabase\",\n        )],\n    )])\ninherited_role_two = mongodbatlas.CustomDbRole(\"inheritedRoleTwo\",\n    project_id=inherited_role_one.project_id,\n    role_name=\"statusServerRole\",\n    actions=[mongodbatlas.CustomDbRoleActionArgs(\n        action=\"SERVER_STATUS\",\n        resources=[mongodbatlas.CustomDbRoleActionResourceArgs(\n            cluster=True,\n        )],\n    )])\ntest_role = mongodbatlas.CustomDbRole(\"testRole\",\n    project_id=inherited_role_one.project_id,\n    role_name=\"myCustomRole\",\n    actions=[\n        mongodbatlas.CustomDbRoleActionArgs(\n            action=\"UPDATE\",\n            resources=[mongodbatlas.CustomDbRoleActionResourceArgs(\n                collection_name=\"\",\n                database_name=\"anyDatabase\",\n            )],\n        ),\n        mongodbatlas.CustomDbRoleActionArgs(\n            action=\"REMOVE\",\n            resources=[mongodbatlas.CustomDbRoleActionResourceArgs(\n                collection_name=\"\",\n                database_name=\"anyDatabase\",\n            )],\n        ),\n    ],\n    inherited_roles=[\n        mongodbatlas.CustomDbRoleInheritedRoleArgs(\n            role_name=inherited_role_one.role_name,\n            database_name=\"admin\",\n        ),\n        mongodbatlas.CustomDbRoleInheritedRoleArgs(\n            role_name=inherited_role_two.role_name,\n            database_name=\"admin\",\n        ),\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var inheritedRoleOne = new Mongodbatlas.CustomDbRole(\"inheritedRoleOne\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        RoleName = \"insertRole\",\n        Actions = new[]\n        {\n            new Mongodbatlas.Inputs.CustomDbRoleActionArgs\n            {\n                Action = \"INSERT\",\n                Resources = new[]\n                {\n                    new Mongodbatlas.Inputs.CustomDbRoleActionResourceArgs\n                    {\n                        CollectionName = \"\",\n                        DatabaseName = \"anyDatabase\",\n                    },\n                },\n            },\n        },\n    });\n\n    var inheritedRoleTwo = new Mongodbatlas.CustomDbRole(\"inheritedRoleTwo\", new()\n    {\n        ProjectId = inheritedRoleOne.ProjectId,\n        RoleName = \"statusServerRole\",\n        Actions = new[]\n        {\n            new Mongodbatlas.Inputs.CustomDbRoleActionArgs\n            {\n                Action = \"SERVER_STATUS\",\n                Resources = new[]\n                {\n                    new Mongodbatlas.Inputs.CustomDbRoleActionResourceArgs\n                    {\n                        Cluster = true,\n                    },\n                },\n            },\n        },\n    });\n\n    var testRole = new Mongodbatlas.CustomDbRole(\"testRole\", new()\n    {\n        ProjectId = inheritedRoleOne.ProjectId,\n        RoleName = \"myCustomRole\",\n        Actions = new[]\n        {\n            new Mongodbatlas.Inputs.CustomDbRoleActionArgs\n            {\n                Action = \"UPDATE\",\n                Resources = new[]\n                {\n                    new Mongodbatlas.Inputs.CustomDbRoleActionResourceArgs\n                    {\n                        CollectionName = \"\",\n                        DatabaseName = \"anyDatabase\",\n                    },\n                },\n            },\n            new Mongodbatlas.Inputs.CustomDbRoleActionArgs\n            {\n                Action = \"REMOVE\",\n                Resources = new[]\n                {\n                    new Mongodbatlas.Inputs.CustomDbRoleActionResourceArgs\n                    {\n                        CollectionName = \"\",\n                        DatabaseName = \"anyDatabase\",\n                    },\n                },\n            },\n        },\n        InheritedRoles = new[]\n        {\n            new Mongodbatlas.Inputs.CustomDbRoleInheritedRoleArgs\n            {\n                RoleName = inheritedRoleOne.RoleName,\n                DatabaseName = \"admin\",\n            },\n            new Mongodbatlas.Inputs.CustomDbRoleInheritedRoleArgs\n            {\n                RoleName = inheritedRoleTwo.RoleName,\n                DatabaseName = \"admin\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tinheritedRoleOne, err := mongodbatlas.NewCustomDbRole(ctx, \"inheritedRoleOne\", \u0026mongodbatlas.CustomDbRoleArgs{\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tRoleName:  pulumi.String(\"insertRole\"),\n\t\t\tActions: mongodbatlas.CustomDbRoleActionArray{\n\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionArgs{\n\t\t\t\t\tAction: pulumi.String(\"INSERT\"),\n\t\t\t\t\tResources: mongodbatlas.CustomDbRoleActionResourceArray{\n\t\t\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionResourceArgs{\n\t\t\t\t\t\t\tCollectionName: pulumi.String(\"\"),\n\t\t\t\t\t\t\tDatabaseName:   pulumi.String(\"anyDatabase\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tinheritedRoleTwo, err := mongodbatlas.NewCustomDbRole(ctx, \"inheritedRoleTwo\", \u0026mongodbatlas.CustomDbRoleArgs{\n\t\t\tProjectId: inheritedRoleOne.ProjectId,\n\t\t\tRoleName:  pulumi.String(\"statusServerRole\"),\n\t\t\tActions: mongodbatlas.CustomDbRoleActionArray{\n\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionArgs{\n\t\t\t\t\tAction: pulumi.String(\"SERVER_STATUS\"),\n\t\t\t\t\tResources: mongodbatlas.CustomDbRoleActionResourceArray{\n\t\t\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionResourceArgs{\n\t\t\t\t\t\t\tCluster: pulumi.Bool(true),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewCustomDbRole(ctx, \"testRole\", \u0026mongodbatlas.CustomDbRoleArgs{\n\t\t\tProjectId: inheritedRoleOne.ProjectId,\n\t\t\tRoleName:  pulumi.String(\"myCustomRole\"),\n\t\t\tActions: mongodbatlas.CustomDbRoleActionArray{\n\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionArgs{\n\t\t\t\t\tAction: pulumi.String(\"UPDATE\"),\n\t\t\t\t\tResources: mongodbatlas.CustomDbRoleActionResourceArray{\n\t\t\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionResourceArgs{\n\t\t\t\t\t\t\tCollectionName: pulumi.String(\"\"),\n\t\t\t\t\t\t\tDatabaseName:   pulumi.String(\"anyDatabase\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionArgs{\n\t\t\t\t\tAction: pulumi.String(\"REMOVE\"),\n\t\t\t\t\tResources: mongodbatlas.CustomDbRoleActionResourceArray{\n\t\t\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionResourceArgs{\n\t\t\t\t\t\t\tCollectionName: pulumi.String(\"\"),\n\t\t\t\t\t\t\tDatabaseName:   pulumi.String(\"anyDatabase\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tInheritedRoles: mongodbatlas.CustomDbRoleInheritedRoleArray{\n\t\t\t\t\u0026mongodbatlas.CustomDbRoleInheritedRoleArgs{\n\t\t\t\t\tRoleName:     inheritedRoleOne.RoleName,\n\t\t\t\t\tDatabaseName: pulumi.String(\"admin\"),\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.CustomDbRoleInheritedRoleArgs{\n\t\t\t\t\tRoleName:     inheritedRoleTwo.RoleName,\n\t\t\t\t\tDatabaseName: pulumi.String(\"admin\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CustomDbRole;\nimport com.pulumi.mongodbatlas.CustomDbRoleArgs;\nimport com.pulumi.mongodbatlas.inputs.CustomDbRoleActionArgs;\nimport com.pulumi.mongodbatlas.inputs.CustomDbRoleInheritedRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var inheritedRoleOne = new CustomDbRole(\"inheritedRoleOne\", CustomDbRoleArgs.builder()        \n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .roleName(\"insertRole\")\n            .actions(CustomDbRoleActionArgs.builder()\n                .action(\"INSERT\")\n                .resources(CustomDbRoleActionResourceArgs.builder()\n                    .collectionName(\"\")\n                    .databaseName(\"anyDatabase\")\n                    .build())\n                .build())\n            .build());\n\n        var inheritedRoleTwo = new CustomDbRole(\"inheritedRoleTwo\", CustomDbRoleArgs.builder()        \n            .projectId(inheritedRoleOne.projectId())\n            .roleName(\"statusServerRole\")\n            .actions(CustomDbRoleActionArgs.builder()\n                .action(\"SERVER_STATUS\")\n                .resources(CustomDbRoleActionResourceArgs.builder()\n                    .cluster(true)\n                    .build())\n                .build())\n            .build());\n\n        var testRole = new CustomDbRole(\"testRole\", CustomDbRoleArgs.builder()        \n            .projectId(inheritedRoleOne.projectId())\n            .roleName(\"myCustomRole\")\n            .actions(            \n                CustomDbRoleActionArgs.builder()\n                    .action(\"UPDATE\")\n                    .resources(CustomDbRoleActionResourceArgs.builder()\n                        .collectionName(\"\")\n                        .databaseName(\"anyDatabase\")\n                        .build())\n                    .build(),\n                CustomDbRoleActionArgs.builder()\n                    .action(\"REMOVE\")\n                    .resources(CustomDbRoleActionResourceArgs.builder()\n                        .collectionName(\"\")\n                        .databaseName(\"anyDatabase\")\n                        .build())\n                    .build())\n            .inheritedRoles(            \n                CustomDbRoleInheritedRoleArgs.builder()\n                    .roleName(inheritedRoleOne.roleName())\n                    .databaseName(\"admin\")\n                    .build(),\n                CustomDbRoleInheritedRoleArgs.builder()\n                    .roleName(inheritedRoleTwo.roleName())\n                    .databaseName(\"admin\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  inheritedRoleOne:\n    type: mongodbatlas:CustomDbRole\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      roleName: insertRole\n      actions:\n        - action: INSERT\n          resources:\n            - collectionName:\n              databaseName: anyDatabase\n  inheritedRoleTwo:\n    type: mongodbatlas:CustomDbRole\n    properties:\n      projectId: ${inheritedRoleOne.projectId}\n      roleName: statusServerRole\n      actions:\n        - action: SERVER_STATUS\n          resources:\n            - cluster: true\n  testRole:\n    type: mongodbatlas:CustomDbRole\n    properties:\n      projectId: ${inheritedRoleOne.projectId}\n      roleName: myCustomRole\n      actions:\n        - action: UPDATE\n          resources:\n            - collectionName:\n              databaseName: anyDatabase\n        - action: REMOVE\n          resources:\n            - collectionName:\n              databaseName: anyDatabase\n      inheritedRoles:\n        - roleName: ${inheritedRoleOne.roleName}\n          databaseName: admin\n        - roleName: ${inheritedRoleTwo.roleName}\n          databaseName: admin\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nDatabase users can be imported using project ID and username, in the format `PROJECTID-ROLENAME`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/customDbRole:CustomDbRole my_role 1112222b3bf99403840e8934-MyCustomRole\n```\n\n For more information see[MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/custom-roles/) ",
            "properties": {
                "actions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CustomDbRoleAction:CustomDbRoleAction"
                    }
                },
                "inheritedRoles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CustomDbRoleInheritedRole:CustomDbRoleInheritedRole"
                    }
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create the database user.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "Name of the custom role.\n"
                }
            },
            "required": [
                "projectId",
                "roleName"
            ],
            "inputProperties": {
                "actions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CustomDbRoleAction:CustomDbRoleAction"
                    }
                },
                "inheritedRoles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CustomDbRoleInheritedRole:CustomDbRoleInheritedRole"
                    }
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create the database user.\n",
                    "willReplaceOnChanges": true
                },
                "roleName": {
                    "type": "string",
                    "description": "Name of the custom role.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "projectId",
                "roleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomDbRole resources.\n",
                "properties": {
                    "actions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/CustomDbRoleAction:CustomDbRoleAction"
                        }
                    },
                    "inheritedRoles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/CustomDbRoleInheritedRole:CustomDbRoleInheritedRole"
                        }
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the database user.\n",
                        "willReplaceOnChanges": true
                    },
                    "roleName": {
                        "type": "string",
                        "description": "Name of the custom role.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/customDnsConfigurationClusterAws:CustomDnsConfigurationClusterAws": {
            "description": "`mongodbatlas.CustomDnsConfigurationClusterAws` provides a Custom DNS Configuration for Atlas Clusters on AWS resource. This represents a Custom DNS Configuration for Atlas Clusters on AWS that can be updated in an Atlas project.\n\n\u003e **IMPORTANT:**You must have one of the following roles to successfully handle the resource:\n  * Organization Owner\n  * Project Owner\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.CustomDnsConfigurationClusterAws(\"test\", {\n    enabled: true,\n    projectId: \"\u003cPROJECT-ID\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.CustomDnsConfigurationClusterAws(\"test\",\n    enabled=True,\n    project_id=\"\u003cPROJECT-ID\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.CustomDnsConfigurationClusterAws(\"test\", new()\n    {\n        Enabled = true,\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewCustomDnsConfigurationClusterAws(ctx, \"test\", \u0026mongodbatlas.CustomDnsConfigurationClusterAwsArgs{\n\t\t\tEnabled:   pulumi.Bool(true),\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CustomDnsConfigurationClusterAws;\nimport com.pulumi.mongodbatlas.CustomDnsConfigurationClusterAwsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new CustomDnsConfigurationClusterAws(\"test\", CustomDnsConfigurationClusterAwsArgs.builder()        \n            .enabled(true)\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:CustomDnsConfigurationClusterAws\n    properties:\n      enabled: true\n      projectId: \u003cPROJECT-ID\u003e\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nCustom DNS Configuration for Atlas Clusters on AWS must be imported using Project ID, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/customDnsConfigurationClusterAws:CustomDnsConfigurationClusterAws test 1112222b3bf99403840e8934\n```\n\n See detailed information for arguments and attributes[MongoDB API Custom DNS Configuration for Atlas Clusters on AWS](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Custom-DNS-for-Atlas-Clusters-Deployed-to-AWS) ",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Indicates whether the project's clusters deployed to AWS use custom DNS. If `true`, the `Get All Clusters` and `Get One Cluster` endpoints return the `connectionStrings.private` and `connectionStrings.privateSrv` fields for clusters deployed to AWS .\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Required \tUnique identifier for the project.\n"
                }
            },
            "required": [
                "enabled",
                "projectId"
            ],
            "inputProperties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Indicates whether the project's clusters deployed to AWS use custom DNS. If `true`, the `Get All Clusters` and `Get One Cluster` endpoints return the `connectionStrings.private` and `connectionStrings.privateSrv` fields for clusters deployed to AWS .\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Required \tUnique identifier for the project.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "enabled",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomDnsConfigurationClusterAws resources.\n",
                "properties": {
                    "enabled": {
                        "type": "boolean",
                        "description": "Indicates whether the project's clusters deployed to AWS use custom DNS. If `true`, the `Get All Clusters` and `Get One Cluster` endpoints return the `connectionStrings.private` and `connectionStrings.privateSrv` fields for clusters deployed to AWS .\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Required \tUnique identifier for the project.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/dataLake:DataLake": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n### S\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testProject = new mongodbatlas.Project(\"testProject\", {orgId: \"ORGANIZATION ID\"});\nconst testCloudProviderAccess = new mongodbatlas.CloudProviderAccess(\"testCloudProviderAccess\", {\n    projectId: testProject.id,\n    providerName: \"AWS\",\n    iamAssumedRoleArn: \"AWS ROLE ID\",\n});\nconst basicDs = new mongodbatlas.DataLake(\"basicDs\", {\n    projectId: testProject.id,\n    aws: {\n        roleId: testCloudProviderAccess.roleId,\n        testS3Bucket: \"TEST S3 BUCKET NAME\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_project = mongodbatlas.Project(\"testProject\", org_id=\"ORGANIZATION ID\")\ntest_cloud_provider_access = mongodbatlas.CloudProviderAccess(\"testCloudProviderAccess\",\n    project_id=test_project.id,\n    provider_name=\"AWS\",\n    iam_assumed_role_arn=\"AWS ROLE ID\")\nbasic_ds = mongodbatlas.DataLake(\"basicDs\",\n    project_id=test_project.id,\n    aws=mongodbatlas.DataLakeAwsArgs(\n        role_id=test_cloud_provider_access.role_id,\n        test_s3_bucket=\"TEST S3 BUCKET NAME\",\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testProject = new Mongodbatlas.Project(\"testProject\", new()\n    {\n        OrgId = \"ORGANIZATION ID\",\n    });\n\n    var testCloudProviderAccess = new Mongodbatlas.CloudProviderAccess(\"testCloudProviderAccess\", new()\n    {\n        ProjectId = testProject.Id,\n        ProviderName = \"AWS\",\n        IamAssumedRoleArn = \"AWS ROLE ID\",\n    });\n\n    var basicDs = new Mongodbatlas.DataLake(\"basicDs\", new()\n    {\n        ProjectId = testProject.Id,\n        Aws = new Mongodbatlas.Inputs.DataLakeAwsArgs\n        {\n            RoleId = testCloudProviderAccess.RoleId,\n            TestS3Bucket = \"TEST S3 BUCKET NAME\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestProject, err := mongodbatlas.NewProject(ctx, \"testProject\", \u0026mongodbatlas.ProjectArgs{\n\t\t\tOrgId: pulumi.String(\"ORGANIZATION ID\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestCloudProviderAccess, err := mongodbatlas.NewCloudProviderAccess(ctx, \"testCloudProviderAccess\", \u0026mongodbatlas.CloudProviderAccessArgs{\n\t\t\tProjectId:         testProject.ID(),\n\t\t\tProviderName:      pulumi.String(\"AWS\"),\n\t\t\tIamAssumedRoleArn: pulumi.String(\"AWS ROLE ID\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewDataLake(ctx, \"basicDs\", \u0026mongodbatlas.DataLakeArgs{\n\t\t\tProjectId: testProject.ID(),\n\t\t\tAws: \u0026mongodbatlas.DataLakeAwsArgs{\n\t\t\t\tRoleId:       testCloudProviderAccess.RoleId,\n\t\t\t\tTestS3Bucket: pulumi.String(\"TEST S3 BUCKET NAME\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Project;\nimport com.pulumi.mongodbatlas.ProjectArgs;\nimport com.pulumi.mongodbatlas.CloudProviderAccess;\nimport com.pulumi.mongodbatlas.CloudProviderAccessArgs;\nimport com.pulumi.mongodbatlas.DataLake;\nimport com.pulumi.mongodbatlas.DataLakeArgs;\nimport com.pulumi.mongodbatlas.inputs.DataLakeAwsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testProject = new Project(\"testProject\", ProjectArgs.builder()        \n            .orgId(\"ORGANIZATION ID\")\n            .build());\n\n        var testCloudProviderAccess = new CloudProviderAccess(\"testCloudProviderAccess\", CloudProviderAccessArgs.builder()        \n            .projectId(testProject.id())\n            .providerName(\"AWS\")\n            .iamAssumedRoleArn(\"AWS ROLE ID\")\n            .build());\n\n        var basicDs = new DataLake(\"basicDs\", DataLakeArgs.builder()        \n            .projectId(testProject.id())\n            .aws(DataLakeAwsArgs.builder()\n                .roleId(testCloudProviderAccess.roleId())\n                .testS3Bucket(\"TEST S3 BUCKET NAME\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testProject:\n    type: mongodbatlas:Project\n    properties:\n      orgId: ORGANIZATION ID\n  testCloudProviderAccess:\n    type: mongodbatlas:CloudProviderAccess\n    properties:\n      projectId: ${testProject.id}\n      providerName: AWS\n      iamAssumedRoleArn: AWS ROLE ID\n  basicDs:\n    type: mongodbatlas:DataLake\n    properties:\n      projectId: ${testProject.id}\n      aws:\n        roleId: ${testCloudProviderAccess.roleId}\n        testS3Bucket: TEST S3 BUCKET NAME\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nData Lake can be imported using project ID, name of the data lake and name of the AWS s3 bucket, in the format `project_id`--`name`--`aws_test_s3_bucket`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/dataLake:DataLake example 1112222b3bf99403840e8934--test-data-lake--s3-test\n```\n\n See [MongoDB Atlas API](https://docs.mongodb.com/datalake/reference/api/dataLakes-create-one-tenant) Documentation for more information. ",
            "properties": {
                "aws": {
                    "$ref": "#/types/mongodbatlas:index/DataLakeAws:DataLakeAws",
                    "description": "AWS provider of the cloud service where Data Lake can access the S3 Bucket.\n* `aws.0.role_id` - (Required) Unique identifier of the role that Data Lake can use to access the data stores. If necessary, use the Atlas [UI](https://docs.atlas.mongodb.com/security/manage-iam-roles/) or [API](https://docs.atlas.mongodb.com/reference/api/cloud-provider-access-get-roles/) to retrieve the role ID. You must also specify the `aws.0.test_s3_bucket`.\n* `aws.0.test_s3_bucket` - (Required) Name of the S3 data bucket that the provided role ID is authorized to access. You must also specify the `aws.0.role_id`.\n"
                },
                "dataProcessRegion": {
                    "$ref": "#/types/mongodbatlas:index/DataLakeDataProcessRegion:DataLakeDataProcessRegion",
                    "description": "The cloud provider region to which Atlas Data Lake routes client connections for data processing. Set to `null` to direct Atlas Data Lake to route client connections to the region nearest to the client based on DNS resolution.\n* `data_process_region.0.cloud_provider` - (Required) Name of the cloud service provider. Atlas Data Lake only supports AWS.\n* `data_process_region.0.region` - (Required). Name of the region to which Data Lake routes client connections for data processing. Atlas Data Lake only supports the following regions:\n"
                },
                "hostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of hostnames assigned to the Atlas Data Lake. Each string in the array is a hostname assigned to the Atlas Data Lake.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the Atlas Data Lake.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create a data lake.\n"
                },
                "state": {
                    "type": "string",
                    "description": "Current state of the Atlas Data Lake:\n"
                },
                "storageDatabases": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/DataLakeStorageDatabase:DataLakeStorageDatabase"
                    },
                    "description": "Configuration details for mapping each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [databases](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-databases-reference). An empty object indicates that the Data Lake has no mapping configuration for any data store.\n* `storage_databases.#.name` - Name of the database to which Data Lake maps the data contained in the data store.\n* `storage_databases.#.collections` -     Array of objects where each object represents a collection and data sources that map to a [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#mongodb-datalakeconf-datalakeconf.stores) data store.\n* `storage_databases.#.collections.#.name` - Name of the collection.\n* `storage_databases.#.collections.#.data_sources` -     Array of objects where each object represents a stores data store to map with the collection.\n* `storage_databases.#.collections.#.data_sources.#.store_name` -     Name of a data store to map to the `\u003ccollection\u003e`. Must match the name of an object in the stores array.\n* `storage_databases.#.collections.#.data_sources.#.default_format` - Default format that Data Lake assumes if it encounters a file without an extension while searching the storeName.\n* `storage_databases.#.collections.#.data_sources.#.path` - Controls how Atlas Data Lake searches for and parses files in the storeName before mapping them to the `\u003ccollection\u003e`.\n* `storage_databases.#.views` -     Array of objects where each object represents an [aggregation pipeline](https://docs.mongodb.com/manual/core/aggregation-pipeline/#id1) on a collection. To learn more about views, see [Views](https://docs.mongodb.com/manual/core/views/).\n* `storage_databases.#.views.#.name` - Name of the view.\n* `storage_databases.#.views.#.source` -  Name of the source collection for the view.\n* `storage_databases.#.views.#.pipeline`- Aggregation pipeline stage(s) to apply to the source collection.\n"
                },
                "storageStores": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/DataLakeStorageStore:DataLakeStorageStore"
                    },
                    "description": "Each object in the array represents a data store. Data Lake uses the storage.databases configuration details to map data in each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-stores-reference). An empty object indicates that the Data Lake has no configured data stores.\n* `storage_stores.#.name` - Name of the data store.\n* `storage_stores.#.provider` - Defines where the data is stored.\n* `storage_stores.#.region` - Name of the AWS region in which the S3 bucket is hosted.\n* `storage_stores.#.bucket` - Name of the AWS S3 bucket.\n* `storage_stores.#.prefix` - Prefix Data Lake applies when searching for files in the S3 bucket .\n* `storage_stores.#.delimiter` - The delimiter that separates `storage_databases.#.collections.#.data_sources.#.path` segments in the data store.\n* `storage_stores.#.include_tags` - Determines whether or not to use S3 tags on the files in the given path as additional partition attributes.\n"
                }
            },
            "required": [
                "aws",
                "dataProcessRegion",
                "hostnames",
                "name",
                "projectId",
                "state",
                "storageDatabases",
                "storageStores"
            ],
            "inputProperties": {
                "aws": {
                    "$ref": "#/types/mongodbatlas:index/DataLakeAws:DataLakeAws",
                    "description": "AWS provider of the cloud service where Data Lake can access the S3 Bucket.\n* `aws.0.role_id` - (Required) Unique identifier of the role that Data Lake can use to access the data stores. If necessary, use the Atlas [UI](https://docs.atlas.mongodb.com/security/manage-iam-roles/) or [API](https://docs.atlas.mongodb.com/reference/api/cloud-provider-access-get-roles/) to retrieve the role ID. You must also specify the `aws.0.test_s3_bucket`.\n* `aws.0.test_s3_bucket` - (Required) Name of the S3 data bucket that the provided role ID is authorized to access. You must also specify the `aws.0.role_id`.\n"
                },
                "dataProcessRegion": {
                    "$ref": "#/types/mongodbatlas:index/DataLakeDataProcessRegion:DataLakeDataProcessRegion",
                    "description": "The cloud provider region to which Atlas Data Lake routes client connections for data processing. Set to `null` to direct Atlas Data Lake to route client connections to the region nearest to the client based on DNS resolution.\n* `data_process_region.0.cloud_provider` - (Required) Name of the cloud service provider. Atlas Data Lake only supports AWS.\n* `data_process_region.0.region` - (Required). Name of the region to which Data Lake routes client connections for data processing. Atlas Data Lake only supports the following regions:\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the Atlas Data Lake.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create a data lake.\n"
                }
            },
            "requiredInputs": [
                "aws",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DataLake resources.\n",
                "properties": {
                    "aws": {
                        "$ref": "#/types/mongodbatlas:index/DataLakeAws:DataLakeAws",
                        "description": "AWS provider of the cloud service where Data Lake can access the S3 Bucket.\n* `aws.0.role_id` - (Required) Unique identifier of the role that Data Lake can use to access the data stores. If necessary, use the Atlas [UI](https://docs.atlas.mongodb.com/security/manage-iam-roles/) or [API](https://docs.atlas.mongodb.com/reference/api/cloud-provider-access-get-roles/) to retrieve the role ID. You must also specify the `aws.0.test_s3_bucket`.\n* `aws.0.test_s3_bucket` - (Required) Name of the S3 data bucket that the provided role ID is authorized to access. You must also specify the `aws.0.role_id`.\n"
                    },
                    "dataProcessRegion": {
                        "$ref": "#/types/mongodbatlas:index/DataLakeDataProcessRegion:DataLakeDataProcessRegion",
                        "description": "The cloud provider region to which Atlas Data Lake routes client connections for data processing. Set to `null` to direct Atlas Data Lake to route client connections to the region nearest to the client based on DNS resolution.\n* `data_process_region.0.cloud_provider` - (Required) Name of the cloud service provider. Atlas Data Lake only supports AWS.\n* `data_process_region.0.region` - (Required). Name of the region to which Data Lake routes client connections for data processing. Atlas Data Lake only supports the following regions:\n"
                    },
                    "hostnames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of hostnames assigned to the Atlas Data Lake. Each string in the array is a hostname assigned to the Atlas Data Lake.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the Atlas Data Lake.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create a data lake.\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "Current state of the Atlas Data Lake:\n"
                    },
                    "storageDatabases": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/DataLakeStorageDatabase:DataLakeStorageDatabase"
                        },
                        "description": "Configuration details for mapping each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [databases](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-databases-reference). An empty object indicates that the Data Lake has no mapping configuration for any data store.\n* `storage_databases.#.name` - Name of the database to which Data Lake maps the data contained in the data store.\n* `storage_databases.#.collections` -     Array of objects where each object represents a collection and data sources that map to a [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#mongodb-datalakeconf-datalakeconf.stores) data store.\n* `storage_databases.#.collections.#.name` - Name of the collection.\n* `storage_databases.#.collections.#.data_sources` -     Array of objects where each object represents a stores data store to map with the collection.\n* `storage_databases.#.collections.#.data_sources.#.store_name` -     Name of a data store to map to the `\u003ccollection\u003e`. Must match the name of an object in the stores array.\n* `storage_databases.#.collections.#.data_sources.#.default_format` - Default format that Data Lake assumes if it encounters a file without an extension while searching the storeName.\n* `storage_databases.#.collections.#.data_sources.#.path` - Controls how Atlas Data Lake searches for and parses files in the storeName before mapping them to the `\u003ccollection\u003e`.\n* `storage_databases.#.views` -     Array of objects where each object represents an [aggregation pipeline](https://docs.mongodb.com/manual/core/aggregation-pipeline/#id1) on a collection. To learn more about views, see [Views](https://docs.mongodb.com/manual/core/views/).\n* `storage_databases.#.views.#.name` - Name of the view.\n* `storage_databases.#.views.#.source` -  Name of the source collection for the view.\n* `storage_databases.#.views.#.pipeline`- Aggregation pipeline stage(s) to apply to the source collection.\n"
                    },
                    "storageStores": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/DataLakeStorageStore:DataLakeStorageStore"
                        },
                        "description": "Each object in the array represents a data store. Data Lake uses the storage.databases configuration details to map data in each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-stores-reference). An empty object indicates that the Data Lake has no configured data stores.\n* `storage_stores.#.name` - Name of the data store.\n* `storage_stores.#.provider` - Defines where the data is stored.\n* `storage_stores.#.region` - Name of the AWS region in which the S3 bucket is hosted.\n* `storage_stores.#.bucket` - Name of the AWS S3 bucket.\n* `storage_stores.#.prefix` - Prefix Data Lake applies when searching for files in the S3 bucket .\n* `storage_stores.#.delimiter` - The delimiter that separates `storage_databases.#.collections.#.data_sources.#.path` segments in the data store.\n* `storage_stores.#.include_tags` - Determines whether or not to use S3 tags on the files in the given path as additional partition attributes.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/databaseUser:DatabaseUser": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n### S\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.DatabaseUser(\"test\", {\n    authDatabaseName: \"admin\",\n    labels: [{\n        key: \"My Key\",\n        value: \"My Value\",\n    }],\n    password: \"test-acc-password\",\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    roles: [\n        {\n            databaseName: \"dbforApp\",\n            roleName: \"readWrite\",\n        },\n        {\n            databaseName: \"admin\",\n            roleName: \"readAnyDatabase\",\n        },\n    ],\n    scopes: [\n        {\n            name: \"My cluster name\",\n            type: \"CLUSTER\",\n        },\n        {\n            name: \"My second cluster name\",\n            type: \"CLUSTER\",\n        },\n    ],\n    username: \"test-acc-username\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.DatabaseUser(\"test\",\n    auth_database_name=\"admin\",\n    labels=[mongodbatlas.DatabaseUserLabelArgs(\n        key=\"My Key\",\n        value=\"My Value\",\n    )],\n    password=\"test-acc-password\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    roles=[\n        mongodbatlas.DatabaseUserRoleArgs(\n            database_name=\"dbforApp\",\n            role_name=\"readWrite\",\n        ),\n        mongodbatlas.DatabaseUserRoleArgs(\n            database_name=\"admin\",\n            role_name=\"readAnyDatabase\",\n        ),\n    ],\n    scopes=[\n        mongodbatlas.DatabaseUserScopeArgs(\n            name=\"My cluster name\",\n            type=\"CLUSTER\",\n        ),\n        mongodbatlas.DatabaseUserScopeArgs(\n            name=\"My second cluster name\",\n            type=\"CLUSTER\",\n        ),\n    ],\n    username=\"test-acc-username\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.DatabaseUser(\"test\", new()\n    {\n        AuthDatabaseName = \"admin\",\n        Labels = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserLabelArgs\n            {\n                Key = \"My Key\",\n                Value = \"My Value\",\n            },\n        },\n        Password = \"test-acc-password\",\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        Roles = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserRoleArgs\n            {\n                DatabaseName = \"dbforApp\",\n                RoleName = \"readWrite\",\n            },\n            new Mongodbatlas.Inputs.DatabaseUserRoleArgs\n            {\n                DatabaseName = \"admin\",\n                RoleName = \"readAnyDatabase\",\n            },\n        },\n        Scopes = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserScopeArgs\n            {\n                Name = \"My cluster name\",\n                Type = \"CLUSTER\",\n            },\n            new Mongodbatlas.Inputs.DatabaseUserScopeArgs\n            {\n                Name = \"My second cluster name\",\n                Type = \"CLUSTER\",\n            },\n        },\n        Username = \"test-acc-username\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewDatabaseUser(ctx, \"test\", \u0026mongodbatlas.DatabaseUserArgs{\n\t\t\tAuthDatabaseName: pulumi.String(\"admin\"),\n\t\t\tLabels: mongodbatlas.DatabaseUserLabelArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserLabelArgs{\n\t\t\t\t\tKey:   pulumi.String(\"My Key\"),\n\t\t\t\t\tValue: pulumi.String(\"My Value\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tPassword:  pulumi.String(\"test-acc-password\"),\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tRoles: mongodbatlas.DatabaseUserRoleArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserRoleArgs{\n\t\t\t\t\tDatabaseName: pulumi.String(\"dbforApp\"),\n\t\t\t\t\tRoleName:     pulumi.String(\"readWrite\"),\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.DatabaseUserRoleArgs{\n\t\t\t\t\tDatabaseName: pulumi.String(\"admin\"),\n\t\t\t\t\tRoleName:     pulumi.String(\"readAnyDatabase\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tScopes: mongodbatlas.DatabaseUserScopeArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserScopeArgs{\n\t\t\t\t\tName: pulumi.String(\"My cluster name\"),\n\t\t\t\t\tType: pulumi.String(\"CLUSTER\"),\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.DatabaseUserScopeArgs{\n\t\t\t\t\tName: pulumi.String(\"My second cluster name\"),\n\t\t\t\t\tType: pulumi.String(\"CLUSTER\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tUsername: pulumi.String(\"test-acc-username\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.DatabaseUser;\nimport com.pulumi.mongodbatlas.DatabaseUserArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserLabelArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserRoleArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserScopeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new DatabaseUser(\"test\", DatabaseUserArgs.builder()        \n            .authDatabaseName(\"admin\")\n            .labels(DatabaseUserLabelArgs.builder()\n                .key(\"My Key\")\n                .value(\"My Value\")\n                .build())\n            .password(\"test-acc-password\")\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .roles(            \n                DatabaseUserRoleArgs.builder()\n                    .databaseName(\"dbforApp\")\n                    .roleName(\"readWrite\")\n                    .build(),\n                DatabaseUserRoleArgs.builder()\n                    .databaseName(\"admin\")\n                    .roleName(\"readAnyDatabase\")\n                    .build())\n            .scopes(            \n                DatabaseUserScopeArgs.builder()\n                    .name(\"My cluster name\")\n                    .type(\"CLUSTER\")\n                    .build(),\n                DatabaseUserScopeArgs.builder()\n                    .name(\"My second cluster name\")\n                    .type(\"CLUSTER\")\n                    .build())\n            .username(\"test-acc-username\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:DatabaseUser\n    properties:\n      authDatabaseName: admin\n      labels:\n        - key: My Key\n          value: My Value\n      password: test-acc-password\n      projectId: \u003cPROJECT-ID\u003e\n      roles:\n        - databaseName: dbforApp\n          roleName: readWrite\n        - databaseName: admin\n          roleName: readAnyDatabase\n      scopes:\n        - name: My cluster name\n          type: CLUSTER\n        - name: My second cluster name\n          type: CLUSTER\n      username: test-acc-username\n```\n\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.DatabaseUser(\"test\", {\n    authDatabaseName: \"$external\",\n    labels: [{\n        key: \"%s\",\n        value: \"%s\",\n    }],\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    roles: [{\n        databaseName: \"admin\",\n        roleName: \"readAnyDatabase\",\n    }],\n    scopes: [{\n        name: \"My cluster name\",\n        type: \"CLUSTER\",\n    }],\n    username: \"test-acc-username\",\n    x509Type: \"MANAGED\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.DatabaseUser(\"test\",\n    auth_database_name=\"$external\",\n    labels=[mongodbatlas.DatabaseUserLabelArgs(\n        key=\"%s\",\n        value=\"%s\",\n    )],\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    roles=[mongodbatlas.DatabaseUserRoleArgs(\n        database_name=\"admin\",\n        role_name=\"readAnyDatabase\",\n    )],\n    scopes=[mongodbatlas.DatabaseUserScopeArgs(\n        name=\"My cluster name\",\n        type=\"CLUSTER\",\n    )],\n    username=\"test-acc-username\",\n    x509_type=\"MANAGED\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.DatabaseUser(\"test\", new()\n    {\n        AuthDatabaseName = \"$external\",\n        Labels = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserLabelArgs\n            {\n                Key = \"%s\",\n                Value = \"%s\",\n            },\n        },\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        Roles = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserRoleArgs\n            {\n                DatabaseName = \"admin\",\n                RoleName = \"readAnyDatabase\",\n            },\n        },\n        Scopes = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserScopeArgs\n            {\n                Name = \"My cluster name\",\n                Type = \"CLUSTER\",\n            },\n        },\n        Username = \"test-acc-username\",\n        X509Type = \"MANAGED\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewDatabaseUser(ctx, \"test\", \u0026mongodbatlas.DatabaseUserArgs{\n\t\t\tAuthDatabaseName: pulumi.String(\"$external\"),\n\t\t\tLabels: mongodbatlas.DatabaseUserLabelArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserLabelArgs{\n\t\t\t\t\tKey:   pulumi.String(\"%s\"),\n\t\t\t\t\tValue: pulumi.String(\"%s\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tRoles: mongodbatlas.DatabaseUserRoleArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserRoleArgs{\n\t\t\t\t\tDatabaseName: pulumi.String(\"admin\"),\n\t\t\t\t\tRoleName:     pulumi.String(\"readAnyDatabase\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tScopes: mongodbatlas.DatabaseUserScopeArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserScopeArgs{\n\t\t\t\t\tName: pulumi.String(\"My cluster name\"),\n\t\t\t\t\tType: pulumi.String(\"CLUSTER\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tUsername: pulumi.String(\"test-acc-username\"),\n\t\t\tX509Type: pulumi.String(\"MANAGED\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.DatabaseUser;\nimport com.pulumi.mongodbatlas.DatabaseUserArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserLabelArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserRoleArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserScopeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new DatabaseUser(\"test\", DatabaseUserArgs.builder()        \n            .authDatabaseName(\"$external\")\n            .labels(DatabaseUserLabelArgs.builder()\n                .key(\"%s\")\n                .value(\"%s\")\n                .build())\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .roles(DatabaseUserRoleArgs.builder()\n                .databaseName(\"admin\")\n                .roleName(\"readAnyDatabase\")\n                .build())\n            .scopes(DatabaseUserScopeArgs.builder()\n                .name(\"My cluster name\")\n                .type(\"CLUSTER\")\n                .build())\n            .username(\"test-acc-username\")\n            .x509Type(\"MANAGED\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:DatabaseUser\n    properties:\n      authDatabaseName: $external\n      labels:\n        - key: '%s'\n          value: '%s'\n      projectId: \u003cPROJECT-ID\u003e\n      roles:\n        - databaseName: admin\n          roleName: readAnyDatabase\n      scopes:\n        - name: My cluster name\n          type: CLUSTER\n      username: test-acc-username\n      x509Type: MANAGED\n```\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.DatabaseUser(\"test\", {\n    username: aws_iam_role.test.arn,\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    authDatabaseName: \"$external\",\n    awsIamType: \"ROLE\",\n    roles: [{\n        roleName: \"readAnyDatabase\",\n        databaseName: \"admin\",\n    }],\n    labels: [{\n        key: \"%s\",\n        value: \"%s\",\n    }],\n    scopes: [{\n        name: \"My cluster name\",\n        type: \"CLUSTER\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.DatabaseUser(\"test\",\n    username=aws_iam_role[\"test\"][\"arn\"],\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    auth_database_name=\"$external\",\n    aws_iam_type=\"ROLE\",\n    roles=[mongodbatlas.DatabaseUserRoleArgs(\n        role_name=\"readAnyDatabase\",\n        database_name=\"admin\",\n    )],\n    labels=[mongodbatlas.DatabaseUserLabelArgs(\n        key=\"%s\",\n        value=\"%s\",\n    )],\n    scopes=[mongodbatlas.DatabaseUserScopeArgs(\n        name=\"My cluster name\",\n        type=\"CLUSTER\",\n    )])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.DatabaseUser(\"test\", new()\n    {\n        Username = aws_iam_role.Test.Arn,\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        AuthDatabaseName = \"$external\",\n        AwsIamType = \"ROLE\",\n        Roles = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserRoleArgs\n            {\n                RoleName = \"readAnyDatabase\",\n                DatabaseName = \"admin\",\n            },\n        },\n        Labels = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserLabelArgs\n            {\n                Key = \"%s\",\n                Value = \"%s\",\n            },\n        },\n        Scopes = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserScopeArgs\n            {\n                Name = \"My cluster name\",\n                Type = \"CLUSTER\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewDatabaseUser(ctx, \"test\", \u0026mongodbatlas.DatabaseUserArgs{\n\t\t\tUsername:         pulumi.Any(aws_iam_role.Test.Arn),\n\t\t\tProjectId:        pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tAuthDatabaseName: pulumi.String(\"$external\"),\n\t\t\tAwsIamType:       pulumi.String(\"ROLE\"),\n\t\t\tRoles: mongodbatlas.DatabaseUserRoleArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserRoleArgs{\n\t\t\t\t\tRoleName:     pulumi.String(\"readAnyDatabase\"),\n\t\t\t\t\tDatabaseName: pulumi.String(\"admin\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tLabels: mongodbatlas.DatabaseUserLabelArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserLabelArgs{\n\t\t\t\t\tKey:   pulumi.String(\"%s\"),\n\t\t\t\t\tValue: pulumi.String(\"%s\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tScopes: mongodbatlas.DatabaseUserScopeArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserScopeArgs{\n\t\t\t\t\tName: pulumi.String(\"My cluster name\"),\n\t\t\t\t\tType: pulumi.String(\"CLUSTER\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.DatabaseUser;\nimport com.pulumi.mongodbatlas.DatabaseUserArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserRoleArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserLabelArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserScopeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new DatabaseUser(\"test\", DatabaseUserArgs.builder()        \n            .username(aws_iam_role.test().arn())\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .authDatabaseName(\"$external\")\n            .awsIamType(\"ROLE\")\n            .roles(DatabaseUserRoleArgs.builder()\n                .roleName(\"readAnyDatabase\")\n                .databaseName(\"admin\")\n                .build())\n            .labels(DatabaseUserLabelArgs.builder()\n                .key(\"%s\")\n                .value(\"%s\")\n                .build())\n            .scopes(DatabaseUserScopeArgs.builder()\n                .name(\"My cluster name\")\n                .type(\"CLUSTER\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:DatabaseUser\n    properties:\n      username: ${aws_iam_role.test.arn}\n      projectId: \u003cPROJECT-ID\u003e\n      authDatabaseName: $external\n      awsIamType: ROLE\n      roles:\n        - roleName: readAnyDatabase\n          databaseName: admin\n      labels:\n        - key: '%s'\n          value: '%s'\n      scopes:\n        - name: My cluster name\n          type: CLUSTER\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nDatabase users can be imported using project ID and username, in the format `project_id`-`username`-`auth_database_name`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/databaseUser:DatabaseUser my_user 1112222b3bf99403840e8934-my_user-admin\n```\n\n ",
            "properties": {
                "authDatabaseName": {
                    "type": "string",
                    "description": "Database against which Atlas authenticates the user. A user must provide both a username and authentication database to log into MongoDB.\nAccepted values include:\n"
                },
                "awsIamType": {
                    "type": "string",
                    "description": "If this value is set, the new database user authenticates with AWS IAM credentials. If no value is given, Atlas uses the default value of NONE. The accepted types are:\n"
                },
                "databaseName": {
                    "type": "string",
                    "description": "Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.\n",
                    "deprecationMessage": "use auth_database_name instead"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/DatabaseUserLabel:DatabaseUserLabel"
                    }
                },
                "ldapAuthType": {
                    "type": "string",
                    "description": "Method by which the provided `username` is authenticated. If no value is given, Atlas uses the default value of `NONE`.\n"
                },
                "password": {
                    "type": "string",
                    "secret": true
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create the database user.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/DatabaseUserRole:DatabaseUserRole"
                    },
                    "description": "List of user’s roles and the databases / collections on which the roles apply. A role allows the user to perform particular actions on the specified database. A role on the admin database can include privileges that apply to the other databases as well. See Roles below for more details.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/DatabaseUserScope:DatabaseUserScope"
                    }
                },
                "username": {
                    "type": "string",
                    "description": "Username for authenticating to MongoDB. USER_ARN or ROLE_ARN if `aws_iam_type` is USER or ROLE.\n"
                },
                "x509Type": {
                    "type": "string",
                    "description": "X.509 method by which the provided username is authenticated. If no value is given, Atlas uses the default value of NONE. The accepted types are:\n"
                }
            },
            "required": [
                "labels",
                "projectId",
                "roles",
                "username"
            ],
            "inputProperties": {
                "authDatabaseName": {
                    "type": "string",
                    "description": "Database against which Atlas authenticates the user. A user must provide both a username and authentication database to log into MongoDB.\nAccepted values include:\n"
                },
                "awsIamType": {
                    "type": "string",
                    "description": "If this value is set, the new database user authenticates with AWS IAM credentials. If no value is given, Atlas uses the default value of NONE. The accepted types are:\n"
                },
                "databaseName": {
                    "type": "string",
                    "description": "Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.\n",
                    "deprecationMessage": "use auth_database_name instead"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/DatabaseUserLabel:DatabaseUserLabel"
                    }
                },
                "ldapAuthType": {
                    "type": "string",
                    "description": "Method by which the provided `username` is authenticated. If no value is given, Atlas uses the default value of `NONE`.\n"
                },
                "password": {
                    "type": "string",
                    "secret": true
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create the database user.\n",
                    "willReplaceOnChanges": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/DatabaseUserRole:DatabaseUserRole"
                    },
                    "description": "List of user’s roles and the databases / collections on which the roles apply. A role allows the user to perform particular actions on the specified database. A role on the admin database can include privileges that apply to the other databases as well. See Roles below for more details.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/DatabaseUserScope:DatabaseUserScope"
                    }
                },
                "username": {
                    "type": "string",
                    "description": "Username for authenticating to MongoDB. USER_ARN or ROLE_ARN if `aws_iam_type` is USER or ROLE.\n",
                    "willReplaceOnChanges": true
                },
                "x509Type": {
                    "type": "string",
                    "description": "X.509 method by which the provided username is authenticated. If no value is given, Atlas uses the default value of NONE. The accepted types are:\n"
                }
            },
            "requiredInputs": [
                "projectId",
                "roles",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DatabaseUser resources.\n",
                "properties": {
                    "authDatabaseName": {
                        "type": "string",
                        "description": "Database against which Atlas authenticates the user. A user must provide both a username and authentication database to log into MongoDB.\nAccepted values include:\n"
                    },
                    "awsIamType": {
                        "type": "string",
                        "description": "If this value is set, the new database user authenticates with AWS IAM credentials. If no value is given, Atlas uses the default value of NONE. The accepted types are:\n"
                    },
                    "databaseName": {
                        "type": "string",
                        "description": "Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.\n",
                        "deprecationMessage": "use auth_database_name instead"
                    },
                    "labels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/DatabaseUserLabel:DatabaseUserLabel"
                        }
                    },
                    "ldapAuthType": {
                        "type": "string",
                        "description": "Method by which the provided `username` is authenticated. If no value is given, Atlas uses the default value of `NONE`.\n"
                    },
                    "password": {
                        "type": "string",
                        "secret": true
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the database user.\n",
                        "willReplaceOnChanges": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/DatabaseUserRole:DatabaseUserRole"
                        },
                        "description": "List of user’s roles and the databases / collections on which the roles apply. A role allows the user to perform particular actions on the specified database. A role on the admin database can include privileges that apply to the other databases as well. See Roles below for more details.\n"
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/DatabaseUserScope:DatabaseUserScope"
                        }
                    },
                    "username": {
                        "type": "string",
                        "description": "Username for authenticating to MongoDB. USER_ARN or ROLE_ARN if `aws_iam_type` is USER or ROLE.\n",
                        "willReplaceOnChanges": true
                    },
                    "x509Type": {
                        "type": "string",
                        "description": "X.509 method by which the provided username is authenticated. If no value is given, Atlas uses the default value of NONE. The accepted types are:\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/encryptionAtRest:EncryptionAtRest": {
            "description": "\n\n\n## Import\n\nEncryption at Rest Settings can be imported using project ID, in the format `project_id`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/encryptionAtRest:EncryptionAtRest example 1112222b3bf99403840e8934\n```\n\n For more information see[MongoDB Atlas API Reference for Encryption at Rest using Customer Key Management.](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Encryption-at-Rest-using-Customer-Key-Management) ",
            "properties": {
                "awsKms": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies AWS KMS configuration details and whether Encryption at Rest is enabled for an Atlas project.\n",
                    "deprecationMessage": "use aws_kms_config instead",
                    "secret": true
                },
                "awsKmsConfig": {
                    "$ref": "#/types/mongodbatlas:index/EncryptionAtRestAwsKmsConfig:EncryptionAtRestAwsKmsConfig",
                    "secret": true
                },
                "azureKeyVault": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies Azure Key Vault configuration details and whether Encryption at Rest is enabled for an Atlas project.\n",
                    "deprecationMessage": "use azure_key_vault_config instead",
                    "secret": true
                },
                "azureKeyVaultConfig": {
                    "$ref": "#/types/mongodbatlas:index/EncryptionAtRestAzureKeyVaultConfig:EncryptionAtRestAzureKeyVaultConfig",
                    "secret": true
                },
                "googleCloudKms": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies GCP KMS configuration details and whether Encryption at Rest is enabled for an Atlas project.\n",
                    "deprecationMessage": "use google_cloud_kms_config instead",
                    "secret": true
                },
                "googleCloudKmsConfig": {
                    "$ref": "#/types/mongodbatlas:index/EncryptionAtRestGoogleCloudKmsConfig:EncryptionAtRestGoogleCloudKmsConfig",
                    "secret": true
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier for the project.\n"
                }
            },
            "required": [
                "projectId"
            ],
            "inputProperties": {
                "awsKms": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies AWS KMS configuration details and whether Encryption at Rest is enabled for an Atlas project.\n",
                    "deprecationMessage": "use aws_kms_config instead",
                    "secret": true
                },
                "awsKmsConfig": {
                    "$ref": "#/types/mongodbatlas:index/EncryptionAtRestAwsKmsConfig:EncryptionAtRestAwsKmsConfig",
                    "secret": true
                },
                "azureKeyVault": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies Azure Key Vault configuration details and whether Encryption at Rest is enabled for an Atlas project.\n",
                    "deprecationMessage": "use azure_key_vault_config instead",
                    "secret": true
                },
                "azureKeyVaultConfig": {
                    "$ref": "#/types/mongodbatlas:index/EncryptionAtRestAzureKeyVaultConfig:EncryptionAtRestAzureKeyVaultConfig",
                    "secret": true
                },
                "googleCloudKms": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies GCP KMS configuration details and whether Encryption at Rest is enabled for an Atlas project.\n",
                    "deprecationMessage": "use google_cloud_kms_config instead",
                    "secret": true
                },
                "googleCloudKmsConfig": {
                    "$ref": "#/types/mongodbatlas:index/EncryptionAtRestGoogleCloudKmsConfig:EncryptionAtRestGoogleCloudKmsConfig",
                    "secret": true
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier for the project.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EncryptionAtRest resources.\n",
                "properties": {
                    "awsKms": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Specifies AWS KMS configuration details and whether Encryption at Rest is enabled for an Atlas project.\n",
                        "deprecationMessage": "use aws_kms_config instead",
                        "secret": true
                    },
                    "awsKmsConfig": {
                        "$ref": "#/types/mongodbatlas:index/EncryptionAtRestAwsKmsConfig:EncryptionAtRestAwsKmsConfig",
                        "secret": true
                    },
                    "azureKeyVault": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Specifies Azure Key Vault configuration details and whether Encryption at Rest is enabled for an Atlas project.\n",
                        "deprecationMessage": "use azure_key_vault_config instead",
                        "secret": true
                    },
                    "azureKeyVaultConfig": {
                        "$ref": "#/types/mongodbatlas:index/EncryptionAtRestAzureKeyVaultConfig:EncryptionAtRestAzureKeyVaultConfig",
                        "secret": true
                    },
                    "googleCloudKms": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Specifies GCP KMS configuration details and whether Encryption at Rest is enabled for an Atlas project.\n",
                        "deprecationMessage": "use google_cloud_kms_config instead",
                        "secret": true
                    },
                    "googleCloudKmsConfig": {
                        "$ref": "#/types/mongodbatlas:index/EncryptionAtRestGoogleCloudKmsConfig:EncryptionAtRestGoogleCloudKmsConfig",
                        "secret": true
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier for the project.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/eventTrigger:EventTrigger": {
            "description": "`mongodbatlas.EventTrigger` provides a Event Trigger resource. \n\n{{% examples %}}\n## Example Usage\n\n### S\n{{% example %}}\n### Example Usage: Database Trigger with Function\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.EventTrigger(\"test\", {\n    projectId: \"PROJECT ID\",\n    appId: \"APPLICATION ID\",\n    type: \"DATABASE\",\n    functionId: \"FUNCTION ID\",\n    disabled: false,\n    configOperationTypes: [\n        \"INSERT\",\n        \"UPDATE\",\n    ],\n    configDatabase: \"DATABASE NAME\",\n    configCollection: \"COLLECTION NAME\",\n    configServiceId: \"SERVICE ID\",\n    configMatch: `{\n  \"updateDescription.updatedFields\": {\n    \"status\": \"blocked\"\n  }\n}\n`,\n    configProject: \"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\",\n    configFullDocument: false,\n    configFullDocumentBefore: false,\n    eventProcessors: {\n        awsEventbridge: {\n            configAccountId: \"AWS ACCOUNT ID\",\n            configRegion: \"AWS REGIOn\",\n        },\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.EventTrigger(\"test\",\n    project_id=\"PROJECT ID\",\n    app_id=\"APPLICATION ID\",\n    type=\"DATABASE\",\n    function_id=\"FUNCTION ID\",\n    disabled=False,\n    config_operation_types=[\n        \"INSERT\",\n        \"UPDATE\",\n    ],\n    config_database=\"DATABASE NAME\",\n    config_collection=\"COLLECTION NAME\",\n    config_service_id=\"SERVICE ID\",\n    config_match=\"\"\"{\n  \"updateDescription.updatedFields\": {\n    \"status\": \"blocked\"\n  }\n}\n\"\"\",\n    config_project=\"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\",\n    config_full_document=False,\n    config_full_document_before=False,\n    event_processors=mongodbatlas.EventTriggerEventProcessorsArgs(\n        aws_eventbridge=mongodbatlas.EventTriggerEventProcessorsAwsEventbridgeArgs(\n            config_account_id=\"AWS ACCOUNT ID\",\n            config_region=\"AWS REGIOn\",\n        ),\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.EventTrigger(\"test\", new()\n    {\n        ProjectId = \"PROJECT ID\",\n        AppId = \"APPLICATION ID\",\n        Type = \"DATABASE\",\n        FunctionId = \"FUNCTION ID\",\n        Disabled = false,\n        ConfigOperationTypes = new[]\n        {\n            \"INSERT\",\n            \"UPDATE\",\n        },\n        ConfigDatabase = \"DATABASE NAME\",\n        ConfigCollection = \"COLLECTION NAME\",\n        ConfigServiceId = \"SERVICE ID\",\n        ConfigMatch = @\"{\n  \"\"updateDescription.updatedFields\"\": {\n    \"\"status\"\": \"\"blocked\"\"\n  }\n}\n\",\n        ConfigProject = \"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\",\n        ConfigFullDocument = false,\n        ConfigFullDocumentBefore = false,\n        EventProcessors = new Mongodbatlas.Inputs.EventTriggerEventProcessorsArgs\n        {\n            AwsEventbridge = new Mongodbatlas.Inputs.EventTriggerEventProcessorsAwsEventbridgeArgs\n            {\n                ConfigAccountId = \"AWS ACCOUNT ID\",\n                ConfigRegion = \"AWS REGIOn\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewEventTrigger(ctx, \"test\", \u0026mongodbatlas.EventTriggerArgs{\n\t\t\tProjectId:  pulumi.String(\"PROJECT ID\"),\n\t\t\tAppId:      pulumi.String(\"APPLICATION ID\"),\n\t\t\tType:       pulumi.String(\"DATABASE\"),\n\t\t\tFunctionId: pulumi.String(\"FUNCTION ID\"),\n\t\t\tDisabled:   pulumi.Bool(false),\n\t\t\tConfigOperationTypes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"INSERT\"),\n\t\t\t\tpulumi.String(\"UPDATE\"),\n\t\t\t},\n\t\t\tConfigDatabase:           pulumi.String(\"DATABASE NAME\"),\n\t\t\tConfigCollection:         pulumi.String(\"COLLECTION NAME\"),\n\t\t\tConfigServiceId:          pulumi.String(\"SERVICE ID\"),\n\t\t\tConfigMatch:              pulumi.String(\"{\\n  \\\"updateDescription.updatedFields\\\": {\\n    \\\"status\\\": \\\"blocked\\\"\\n  }\\n}\\n\"),\n\t\t\tConfigProject:            pulumi.String(\"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\"),\n\t\t\tConfigFullDocument:       pulumi.Bool(false),\n\t\t\tConfigFullDocumentBefore: pulumi.Bool(false),\n\t\t\tEventProcessors: \u0026mongodbatlas.EventTriggerEventProcessorsArgs{\n\t\t\t\tAwsEventbridge: \u0026mongodbatlas.EventTriggerEventProcessorsAwsEventbridgeArgs{\n\t\t\t\t\tConfigAccountId: pulumi.String(\"AWS ACCOUNT ID\"),\n\t\t\t\t\tConfigRegion:    pulumi.String(\"AWS REGIOn\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.EventTrigger;\nimport com.pulumi.mongodbatlas.EventTriggerArgs;\nimport com.pulumi.mongodbatlas.inputs.EventTriggerEventProcessorsArgs;\nimport com.pulumi.mongodbatlas.inputs.EventTriggerEventProcessorsAwsEventbridgeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new EventTrigger(\"test\", EventTriggerArgs.builder()        \n            .projectId(\"PROJECT ID\")\n            .appId(\"APPLICATION ID\")\n            .type(\"DATABASE\")\n            .functionId(\"FUNCTION ID\")\n            .disabled(false)\n            .configOperationTypes(            \n                \"INSERT\",\n                \"UPDATE\")\n            .configDatabase(\"DATABASE NAME\")\n            .configCollection(\"COLLECTION NAME\")\n            .configServiceId(\"SERVICE ID\")\n            .configMatch(\"\"\"\n{\n  \"updateDescription.updatedFields\": {\n    \"status\": \"blocked\"\n  }\n}\n            \"\"\")\n            .configProject(\"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\")\n            .configFullDocument(false)\n            .configFullDocumentBefore(false)\n            .eventProcessors(EventTriggerEventProcessorsArgs.builder()\n                .awsEventbridge(EventTriggerEventProcessorsAwsEventbridgeArgs.builder()\n                    .configAccountId(\"AWS ACCOUNT ID\")\n                    .configRegion(\"AWS REGIOn\")\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:EventTrigger\n    properties:\n      projectId: PROJECT ID\n      appId: APPLICATION ID\n      type: DATABASE\n      functionId: FUNCTION ID\n      disabled: false\n      configOperationTypes:\n        - INSERT\n        - UPDATE\n      configDatabase: DATABASE NAME\n      configCollection: COLLECTION NAME\n      configServiceId: SERVICE ID\n      configMatch: |\n        {\n          \"updateDescription.updatedFields\": {\n            \"status\": \"blocked\"\n          }\n        }\n      configProject: '{\"updateDescription.updatedFields\":{\"status\":\"blocked\"}}'\n      configFullDocument: false\n      configFullDocumentBefore: false\n      eventProcessors:\n        awsEventbridge:\n          configAccountId: AWS ACCOUNT ID\n          configRegion: AWS REGIOn\n```\n{{% /example %}}\n{{% example %}}\n### Example Usage: Database Trigger with EventBridge\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.EventTrigger(\"test\", {\n    appId: \"APPLICATION ID\",\n    configCollection: \"COLLECTION NAME\",\n    configDatabase: \"DATABASE NAME\",\n    configFullDocument: false,\n    configFullDocumentBefore: false,\n    configMatch: \"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\",\n    configOperationType: \"LOGIN\",\n    configOperationTypes: [\n        \"INSERT\",\n        \"UPDATE\",\n    ],\n    configProject: \"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\",\n    configProviders: [\"anon-user\"],\n    configSchedule: \"*\",\n    configServiceId: \"1\",\n    disabled: false,\n    eventProcessors: {\n        awsEventbridge: {\n            configAccountId: \"AWS ACCOUNT ID\",\n            configRegion: \"AWS REGIOn\",\n        },\n    },\n    projectId: \"PROJECT ID\",\n    type: \"DATABASE\",\n    unordered: false,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.EventTrigger(\"test\",\n    app_id=\"APPLICATION ID\",\n    config_collection=\"COLLECTION NAME\",\n    config_database=\"DATABASE NAME\",\n    config_full_document=False,\n    config_full_document_before=False,\n    config_match=\"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\",\n    config_operation_type=\"LOGIN\",\n    config_operation_types=[\n        \"INSERT\",\n        \"UPDATE\",\n    ],\n    config_project=\"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\",\n    config_providers=[\"anon-user\"],\n    config_schedule=\"*\",\n    config_service_id=\"1\",\n    disabled=False,\n    event_processors=mongodbatlas.EventTriggerEventProcessorsArgs(\n        aws_eventbridge=mongodbatlas.EventTriggerEventProcessorsAwsEventbridgeArgs(\n            config_account_id=\"AWS ACCOUNT ID\",\n            config_region=\"AWS REGIOn\",\n        ),\n    ),\n    project_id=\"PROJECT ID\",\n    type=\"DATABASE\",\n    unordered=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.EventTrigger(\"test\", new()\n    {\n        AppId = \"APPLICATION ID\",\n        ConfigCollection = \"COLLECTION NAME\",\n        ConfigDatabase = \"DATABASE NAME\",\n        ConfigFullDocument = false,\n        ConfigFullDocumentBefore = false,\n        ConfigMatch = \"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\",\n        ConfigOperationType = \"LOGIN\",\n        ConfigOperationTypes = new[]\n        {\n            \"INSERT\",\n            \"UPDATE\",\n        },\n        ConfigProject = \"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\",\n        ConfigProviders = new[]\n        {\n            \"anon-user\",\n        },\n        ConfigSchedule = \"*\",\n        ConfigServiceId = \"1\",\n        Disabled = false,\n        EventProcessors = new Mongodbatlas.Inputs.EventTriggerEventProcessorsArgs\n        {\n            AwsEventbridge = new Mongodbatlas.Inputs.EventTriggerEventProcessorsAwsEventbridgeArgs\n            {\n                ConfigAccountId = \"AWS ACCOUNT ID\",\n                ConfigRegion = \"AWS REGIOn\",\n            },\n        },\n        ProjectId = \"PROJECT ID\",\n        Type = \"DATABASE\",\n        Unordered = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewEventTrigger(ctx, \"test\", \u0026mongodbatlas.EventTriggerArgs{\n\t\t\tAppId:                    pulumi.String(\"APPLICATION ID\"),\n\t\t\tConfigCollection:         pulumi.String(\"COLLECTION NAME\"),\n\t\t\tConfigDatabase:           pulumi.String(\"DATABASE NAME\"),\n\t\t\tConfigFullDocument:       pulumi.Bool(false),\n\t\t\tConfigFullDocumentBefore: pulumi.Bool(false),\n\t\t\tConfigMatch:              pulumi.String(\"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\"),\n\t\t\tConfigOperationType:      pulumi.String(\"LOGIN\"),\n\t\t\tConfigOperationTypes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"INSERT\"),\n\t\t\t\tpulumi.String(\"UPDATE\"),\n\t\t\t},\n\t\t\tConfigProject: pulumi.String(\"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\"),\n\t\t\tConfigProviders: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"anon-user\"),\n\t\t\t},\n\t\t\tConfigSchedule:  pulumi.String(\"*\"),\n\t\t\tConfigServiceId: pulumi.String(\"1\"),\n\t\t\tDisabled:        pulumi.Bool(false),\n\t\t\tEventProcessors: \u0026mongodbatlas.EventTriggerEventProcessorsArgs{\n\t\t\t\tAwsEventbridge: \u0026mongodbatlas.EventTriggerEventProcessorsAwsEventbridgeArgs{\n\t\t\t\t\tConfigAccountId: pulumi.String(\"AWS ACCOUNT ID\"),\n\t\t\t\t\tConfigRegion:    pulumi.String(\"AWS REGIOn\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tProjectId: pulumi.String(\"PROJECT ID\"),\n\t\t\tType:      pulumi.String(\"DATABASE\"),\n\t\t\tUnordered: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.EventTrigger;\nimport com.pulumi.mongodbatlas.EventTriggerArgs;\nimport com.pulumi.mongodbatlas.inputs.EventTriggerEventProcessorsArgs;\nimport com.pulumi.mongodbatlas.inputs.EventTriggerEventProcessorsAwsEventbridgeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new EventTrigger(\"test\", EventTriggerArgs.builder()        \n            .appId(\"APPLICATION ID\")\n            .configCollection(\"COLLECTION NAME\")\n            .configDatabase(\"DATABASE NAME\")\n            .configFullDocument(false)\n            .configFullDocumentBefore(false)\n            .configMatch(\"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\")\n            .configOperationType(\"LOGIN\")\n            .configOperationTypes(            \n                \"INSERT\",\n                \"UPDATE\")\n            .configProject(\"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\")\n            .configProviders(\"anon-user\")\n            .configSchedule(\"*\")\n            .configServiceId(\"1\")\n            .disabled(false)\n            .eventProcessors(EventTriggerEventProcessorsArgs.builder()\n                .awsEventbridge(EventTriggerEventProcessorsAwsEventbridgeArgs.builder()\n                    .configAccountId(\"AWS ACCOUNT ID\")\n                    .configRegion(\"AWS REGIOn\")\n                    .build())\n                .build())\n            .projectId(\"PROJECT ID\")\n            .type(\"DATABASE\")\n            .unordered(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:EventTrigger\n    properties:\n      appId: APPLICATION ID\n      configCollection: COLLECTION NAME\n      configDatabase: DATABASE NAME\n      configFullDocument: false\n      configFullDocumentBefore: false\n      configMatch: '{\"updateDescription.updatedFields\":{\"status\":\"blocked\"}}'\n      configOperationType: LOGIN\n      configOperationTypes:\n        - INSERT\n        - UPDATE\n      configProject: '{\"updateDescription.updatedFields\":{\"status\":\"blocked\"}}'\n      configProviders:\n        - anon-user\n      configSchedule: '*'\n      configServiceId: '1'\n      disabled: false\n      eventProcessors:\n        awsEventbridge:\n          configAccountId: AWS ACCOUNT ID\n          configRegion: AWS REGIOn\n      projectId: PROJECT ID\n      type: DATABASE\n      unordered: false\n```\n{{% /example %}}\n{{% example %}}\n### Example Usage: Authentication Trigger\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.EventTrigger(\"test\", {\n    appId: \"APPLICATION ID\",\n    configOperationType: \"LOGIN\",\n    configProviders: [\"anon-user\"],\n    disabled: false,\n    functionId: \"1\",\n    projectId: \"PROJECT ID\",\n    type: \"AUTHENTICATION\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.EventTrigger(\"test\",\n    app_id=\"APPLICATION ID\",\n    config_operation_type=\"LOGIN\",\n    config_providers=[\"anon-user\"],\n    disabled=False,\n    function_id=\"1\",\n    project_id=\"PROJECT ID\",\n    type=\"AUTHENTICATION\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.EventTrigger(\"test\", new()\n    {\n        AppId = \"APPLICATION ID\",\n        ConfigOperationType = \"LOGIN\",\n        ConfigProviders = new[]\n        {\n            \"anon-user\",\n        },\n        Disabled = false,\n        FunctionId = \"1\",\n        ProjectId = \"PROJECT ID\",\n        Type = \"AUTHENTICATION\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewEventTrigger(ctx, \"test\", \u0026mongodbatlas.EventTriggerArgs{\n\t\t\tAppId:               pulumi.String(\"APPLICATION ID\"),\n\t\t\tConfigOperationType: pulumi.String(\"LOGIN\"),\n\t\t\tConfigProviders: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"anon-user\"),\n\t\t\t},\n\t\t\tDisabled:   pulumi.Bool(false),\n\t\t\tFunctionId: pulumi.String(\"1\"),\n\t\t\tProjectId:  pulumi.String(\"PROJECT ID\"),\n\t\t\tType:       pulumi.String(\"AUTHENTICATION\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.EventTrigger;\nimport com.pulumi.mongodbatlas.EventTriggerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new EventTrigger(\"test\", EventTriggerArgs.builder()        \n            .appId(\"APPLICATION ID\")\n            .configOperationType(\"LOGIN\")\n            .configProviders(\"anon-user\")\n            .disabled(false)\n            .functionId(\"1\")\n            .projectId(\"PROJECT ID\")\n            .type(\"AUTHENTICATION\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:EventTrigger\n    properties:\n      appId: APPLICATION ID\n      configOperationType: LOGIN\n      configProviders:\n        - anon-user\n      disabled: false\n      functionId: '1'\n      projectId: PROJECT ID\n      type: AUTHENTICATION\n```\n{{% /example %}}\n{{% example %}}\n### Example Usage: Scheduled Trigger\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.EventTrigger(\"test\", {\n    appId: \"APPLICATION ID\",\n    configSchedule: \"*\",\n    disabled: false,\n    functionId: \"1\",\n    projectId: \"PROJECT ID\",\n    type: \"SCHEDULED\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.EventTrigger(\"test\",\n    app_id=\"APPLICATION ID\",\n    config_schedule=\"*\",\n    disabled=False,\n    function_id=\"1\",\n    project_id=\"PROJECT ID\",\n    type=\"SCHEDULED\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.EventTrigger(\"test\", new()\n    {\n        AppId = \"APPLICATION ID\",\n        ConfigSchedule = \"*\",\n        Disabled = false,\n        FunctionId = \"1\",\n        ProjectId = \"PROJECT ID\",\n        Type = \"SCHEDULED\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewEventTrigger(ctx, \"test\", \u0026mongodbatlas.EventTriggerArgs{\n\t\t\tAppId:          pulumi.String(\"APPLICATION ID\"),\n\t\t\tConfigSchedule: pulumi.String(\"*\"),\n\t\t\tDisabled:       pulumi.Bool(false),\n\t\t\tFunctionId:     pulumi.String(\"1\"),\n\t\t\tProjectId:      pulumi.String(\"PROJECT ID\"),\n\t\t\tType:           pulumi.String(\"SCHEDULED\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.EventTrigger;\nimport com.pulumi.mongodbatlas.EventTriggerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new EventTrigger(\"test\", EventTriggerArgs.builder()        \n            .appId(\"APPLICATION ID\")\n            .configSchedule(\"*\")\n            .disabled(false)\n            .functionId(\"1\")\n            .projectId(\"PROJECT ID\")\n            .type(\"SCHEDULED\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:EventTrigger\n    properties:\n      appId: APPLICATION ID\n      configSchedule: '*'\n      disabled: false\n      functionId: '1'\n      projectId: PROJECT ID\n      type: SCHEDULED\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nEvent trigger can be imported using project ID, App ID and Trigger ID, in the format `project_id`--`app_id`-`trigger_id`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/eventTrigger:EventTrigger test 1112222b3bf99403840e8934--testing-example--1112222b3bf99403840e8934\n```\n\n ",
            "properties": {
                "appId": {
                    "type": "string",
                    "description": "The ObjectID of your application.\n"
                },
                "configCollection": {
                    "type": "string",
                    "description": "Required for `DATABASE` type. The name of the MongoDB collection that the trigger watches for change events. The collection must be part of the specified database.\n"
                },
                "configDatabase": {
                    "type": "string",
                    "description": "Required for `DATABASE` type. The name of the MongoDB database that contains the watched collection.\n"
                },
                "configFullDocument": {
                    "type": "boolean",
                    "description": "Optional for `DATABASE` type. If true, indicates that `UPDATE` change events should include the most current [majority-committed](https://docs.mongodb.com/manual/reference/read-concern-majority/) version of the modified document in the fullDocument field.\n"
                },
                "configFullDocumentBefore": {
                    "type": "boolean"
                },
                "configMatch": {
                    "type": "string",
                    "description": "Optional for `DATABASE` type. A [$match](https://docs.mongodb.com/manual/reference/operator/aggregation/match/) expression document that MongoDB Realm includes in the underlying change stream pipeline for the trigger. This is useful when you want to filter change events beyond their operation type. The trigger will only fire if the expression evaluates to true for a given change event.\n"
                },
                "configOperationType": {
                    "type": "string",
                    "description": "Required for `AUTHENTICATION` type. The [authentication operation type](https://docs.mongodb.com/realm/triggers/authentication-triggers/#std-label-authentication-event-operation-types) to listen for. Possible Values: `LOGIN`, `CREATE`, `DELETE`\n"
                },
                "configOperationTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Required for `DATABASE` type. The [database event operation types](https://docs.mongodb.com/realm/triggers/database-triggers/#std-label-database-events) to listen for. This must contain at least one value. Possible Values: `INSERT`, `UPDATE`, `REPLACE`, `DELETE`\n"
                },
                "configProject": {
                    "type": "string",
                    "description": "Optional for `DATABASE` type. A [$project](https://docs.mongodb.com/manual/reference/operator/aggregation/project/) expression document that Realm uses to filter the fields that appear in change event objects.\n"
                },
                "configProviders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Required for `AUTHENTICATION` type. A list of one or more [authentication provider](https://docs.mongodb.com/realm/authentication/providers/) id values. The trigger will only listen for authentication events produced by these providers.\n"
                },
                "configSchedule": {
                    "type": "string",
                    "description": "Required for `SCHEDULED` type. A [cron expression](https://docs.mongodb.com/realm/triggers/cron-expressions/) that defines the trigger schedule.\n"
                },
                "configScheduleType": {
                    "type": "string"
                },
                "configServiceId": {
                    "type": "string",
                    "description": "Required for `DATABASE` type. The ID of the MongoDB Service associated with the trigger.\n"
                },
                "disabled": {
                    "type": "boolean",
                    "description": "Default: `false` If `true`, the trigger is disabled.\n"
                },
                "eventProcessors": {
                    "$ref": "#/types/mongodbatlas:index/EventTriggerEventProcessors:EventTriggerEventProcessors",
                    "description": "An object where each field name is an event processor ID and each value is an object that configures its corresponding event processor. The following event processors are supported: `AWS_EVENTBRIDGE` For an example configuration object, see [Send Trigger Events to AWS EventBridge](https://docs.mongodb.com/realm/triggers/eventbridge/#std-label-event_processor_example).\n* `event_processors.0.aws_eventbridge.config_account_id` - (Optional) AWS Account ID.\n* `event_processors.0.aws_eventbridge.config_region` - (Optional) Region of AWS Account.\n"
                },
                "functionId": {
                    "type": "string",
                    "description": "The ID of the function associated with the trigger.\n"
                },
                "functionName": {
                    "type": "string",
                    "description": "The name of the function associated with the trigger.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the trigger.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create the trigger.\n"
                },
                "triggerId": {
                    "type": "string",
                    "description": "The unique ID of the trigger.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the trigger. Possible Values: `DATABASE`, `AUTHENTICATION`,`SCHEDULED`\n"
                },
                "unordered": {
                    "type": "boolean",
                    "description": "Only Available for Database Triggers. If true, event ordering is disabled and this trigger can process events in parallel. If false, event ordering is enabled and the trigger executes serially.\n"
                }
            },
            "required": [
                "appId",
                "configCollection",
                "configDatabase",
                "configFullDocument",
                "configFullDocumentBefore",
                "configMatch",
                "configOperationType",
                "configOperationTypes",
                "configProject",
                "configProviders",
                "configSchedule",
                "configScheduleType",
                "configServiceId",
                "disabled",
                "functionName",
                "name",
                "projectId",
                "triggerId",
                "type",
                "unordered"
            ],
            "inputProperties": {
                "appId": {
                    "type": "string",
                    "description": "The ObjectID of your application.\n"
                },
                "configCollection": {
                    "type": "string",
                    "description": "Required for `DATABASE` type. The name of the MongoDB collection that the trigger watches for change events. The collection must be part of the specified database.\n"
                },
                "configDatabase": {
                    "type": "string",
                    "description": "Required for `DATABASE` type. The name of the MongoDB database that contains the watched collection.\n"
                },
                "configFullDocument": {
                    "type": "boolean",
                    "description": "Optional for `DATABASE` type. If true, indicates that `UPDATE` change events should include the most current [majority-committed](https://docs.mongodb.com/manual/reference/read-concern-majority/) version of the modified document in the fullDocument field.\n"
                },
                "configFullDocumentBefore": {
                    "type": "boolean"
                },
                "configMatch": {
                    "type": "string",
                    "description": "Optional for `DATABASE` type. A [$match](https://docs.mongodb.com/manual/reference/operator/aggregation/match/) expression document that MongoDB Realm includes in the underlying change stream pipeline for the trigger. This is useful when you want to filter change events beyond their operation type. The trigger will only fire if the expression evaluates to true for a given change event.\n"
                },
                "configOperationType": {
                    "type": "string",
                    "description": "Required for `AUTHENTICATION` type. The [authentication operation type](https://docs.mongodb.com/realm/triggers/authentication-triggers/#std-label-authentication-event-operation-types) to listen for. Possible Values: `LOGIN`, `CREATE`, `DELETE`\n"
                },
                "configOperationTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Required for `DATABASE` type. The [database event operation types](https://docs.mongodb.com/realm/triggers/database-triggers/#std-label-database-events) to listen for. This must contain at least one value. Possible Values: `INSERT`, `UPDATE`, `REPLACE`, `DELETE`\n"
                },
                "configProject": {
                    "type": "string",
                    "description": "Optional for `DATABASE` type. A [$project](https://docs.mongodb.com/manual/reference/operator/aggregation/project/) expression document that Realm uses to filter the fields that appear in change event objects.\n"
                },
                "configProviders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Required for `AUTHENTICATION` type. A list of one or more [authentication provider](https://docs.mongodb.com/realm/authentication/providers/) id values. The trigger will only listen for authentication events produced by these providers.\n"
                },
                "configSchedule": {
                    "type": "string",
                    "description": "Required for `SCHEDULED` type. A [cron expression](https://docs.mongodb.com/realm/triggers/cron-expressions/) that defines the trigger schedule.\n"
                },
                "configServiceId": {
                    "type": "string",
                    "description": "Required for `DATABASE` type. The ID of the MongoDB Service associated with the trigger.\n"
                },
                "disabled": {
                    "type": "boolean",
                    "description": "Default: `false` If `true`, the trigger is disabled.\n"
                },
                "eventProcessors": {
                    "$ref": "#/types/mongodbatlas:index/EventTriggerEventProcessors:EventTriggerEventProcessors",
                    "description": "An object where each field name is an event processor ID and each value is an object that configures its corresponding event processor. The following event processors are supported: `AWS_EVENTBRIDGE` For an example configuration object, see [Send Trigger Events to AWS EventBridge](https://docs.mongodb.com/realm/triggers/eventbridge/#std-label-event_processor_example).\n* `event_processors.0.aws_eventbridge.config_account_id` - (Optional) AWS Account ID.\n* `event_processors.0.aws_eventbridge.config_region` - (Optional) Region of AWS Account.\n"
                },
                "functionId": {
                    "type": "string",
                    "description": "The ID of the function associated with the trigger.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the trigger.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create the trigger.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the trigger. Possible Values: `DATABASE`, `AUTHENTICATION`,`SCHEDULED`\n"
                },
                "unordered": {
                    "type": "boolean",
                    "description": "Only Available for Database Triggers. If true, event ordering is disabled and this trigger can process events in parallel. If false, event ordering is enabled and the trigger executes serially.\n"
                }
            },
            "requiredInputs": [
                "appId",
                "projectId",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EventTrigger resources.\n",
                "properties": {
                    "appId": {
                        "type": "string",
                        "description": "The ObjectID of your application.\n"
                    },
                    "configCollection": {
                        "type": "string",
                        "description": "Required for `DATABASE` type. The name of the MongoDB collection that the trigger watches for change events. The collection must be part of the specified database.\n"
                    },
                    "configDatabase": {
                        "type": "string",
                        "description": "Required for `DATABASE` type. The name of the MongoDB database that contains the watched collection.\n"
                    },
                    "configFullDocument": {
                        "type": "boolean",
                        "description": "Optional for `DATABASE` type. If true, indicates that `UPDATE` change events should include the most current [majority-committed](https://docs.mongodb.com/manual/reference/read-concern-majority/) version of the modified document in the fullDocument field.\n"
                    },
                    "configFullDocumentBefore": {
                        "type": "boolean"
                    },
                    "configMatch": {
                        "type": "string",
                        "description": "Optional for `DATABASE` type. A [$match](https://docs.mongodb.com/manual/reference/operator/aggregation/match/) expression document that MongoDB Realm includes in the underlying change stream pipeline for the trigger. This is useful when you want to filter change events beyond their operation type. The trigger will only fire if the expression evaluates to true for a given change event.\n"
                    },
                    "configOperationType": {
                        "type": "string",
                        "description": "Required for `AUTHENTICATION` type. The [authentication operation type](https://docs.mongodb.com/realm/triggers/authentication-triggers/#std-label-authentication-event-operation-types) to listen for. Possible Values: `LOGIN`, `CREATE`, `DELETE`\n"
                    },
                    "configOperationTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Required for `DATABASE` type. The [database event operation types](https://docs.mongodb.com/realm/triggers/database-triggers/#std-label-database-events) to listen for. This must contain at least one value. Possible Values: `INSERT`, `UPDATE`, `REPLACE`, `DELETE`\n"
                    },
                    "configProject": {
                        "type": "string",
                        "description": "Optional for `DATABASE` type. A [$project](https://docs.mongodb.com/manual/reference/operator/aggregation/project/) expression document that Realm uses to filter the fields that appear in change event objects.\n"
                    },
                    "configProviders": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Required for `AUTHENTICATION` type. A list of one or more [authentication provider](https://docs.mongodb.com/realm/authentication/providers/) id values. The trigger will only listen for authentication events produced by these providers.\n"
                    },
                    "configSchedule": {
                        "type": "string",
                        "description": "Required for `SCHEDULED` type. A [cron expression](https://docs.mongodb.com/realm/triggers/cron-expressions/) that defines the trigger schedule.\n"
                    },
                    "configScheduleType": {
                        "type": "string"
                    },
                    "configServiceId": {
                        "type": "string",
                        "description": "Required for `DATABASE` type. The ID of the MongoDB Service associated with the trigger.\n"
                    },
                    "disabled": {
                        "type": "boolean",
                        "description": "Default: `false` If `true`, the trigger is disabled.\n"
                    },
                    "eventProcessors": {
                        "$ref": "#/types/mongodbatlas:index/EventTriggerEventProcessors:EventTriggerEventProcessors",
                        "description": "An object where each field name is an event processor ID and each value is an object that configures its corresponding event processor. The following event processors are supported: `AWS_EVENTBRIDGE` For an example configuration object, see [Send Trigger Events to AWS EventBridge](https://docs.mongodb.com/realm/triggers/eventbridge/#std-label-event_processor_example).\n* `event_processors.0.aws_eventbridge.config_account_id` - (Optional) AWS Account ID.\n* `event_processors.0.aws_eventbridge.config_region` - (Optional) Region of AWS Account.\n"
                    },
                    "functionId": {
                        "type": "string",
                        "description": "The ID of the function associated with the trigger.\n"
                    },
                    "functionName": {
                        "type": "string",
                        "description": "The name of the function associated with the trigger.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the trigger.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the trigger.\n"
                    },
                    "triggerId": {
                        "type": "string",
                        "description": "The unique ID of the trigger.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of the trigger. Possible Values: `DATABASE`, `AUTHENTICATION`,`SCHEDULED`\n"
                    },
                    "unordered": {
                        "type": "boolean",
                        "description": "Only Available for Database Triggers. If true, event ordering is disabled and this trigger can process events in parallel. If false, event ordering is enabled and the trigger executes serially.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/federatedSettingsIdentityProvider:FederatedSettingsIdentityProvider": {
            "description": "`mongodbatlas.FederatedSettingsIdentityProvider` provides an Atlas federated settings identity provider resource provides a subset of settings to be maintained post import of the existing resource.\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n\u003e **IMPORTANT** You **MUST** import this resource before you can manage it with this provider. \n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst identityProvider = new mongodbatlas.FederatedSettingsIdentityProvider(\"identityProvider\", {\n    associatedDomains: [\"yourdomain.com\"],\n    federationSettingsId: \"627a9687f7f7f7f774de306f14\",\n    issuerUri: \"http://www.okta.com/exk17q7f7f7f7fp50h8\",\n    requestBinding: \"HTTP-POST\",\n    responseSignatureAlgorithm: \"SHA-256\",\n    ssoDebugEnabled: true,\n    ssoUrl: \"https://mysso.oktapreview.com/app/mysso_terraformtestsso/exk17q7f7f7f7f50h8/sso/saml\",\n    status: \"ACTIVE\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nidentity_provider = mongodbatlas.FederatedSettingsIdentityProvider(\"identityProvider\",\n    associated_domains=[\"yourdomain.com\"],\n    federation_settings_id=\"627a9687f7f7f7f774de306f14\",\n    issuer_uri=\"http://www.okta.com/exk17q7f7f7f7fp50h8\",\n    request_binding=\"HTTP-POST\",\n    response_signature_algorithm=\"SHA-256\",\n    sso_debug_enabled=True,\n    sso_url=\"https://mysso.oktapreview.com/app/mysso_terraformtestsso/exk17q7f7f7f7f50h8/sso/saml\",\n    status=\"ACTIVE\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var identityProvider = new Mongodbatlas.FederatedSettingsIdentityProvider(\"identityProvider\", new()\n    {\n        AssociatedDomains = new[]\n        {\n            \"yourdomain.com\",\n        },\n        FederationSettingsId = \"627a9687f7f7f7f774de306f14\",\n        IssuerUri = \"http://www.okta.com/exk17q7f7f7f7fp50h8\",\n        RequestBinding = \"HTTP-POST\",\n        ResponseSignatureAlgorithm = \"SHA-256\",\n        SsoDebugEnabled = true,\n        SsoUrl = \"https://mysso.oktapreview.com/app/mysso_terraformtestsso/exk17q7f7f7f7f50h8/sso/saml\",\n        Status = \"ACTIVE\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewFederatedSettingsIdentityProvider(ctx, \"identityProvider\", \u0026mongodbatlas.FederatedSettingsIdentityProviderArgs{\n\t\t\tAssociatedDomains: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"yourdomain.com\"),\n\t\t\t},\n\t\t\tFederationSettingsId:       pulumi.String(\"627a9687f7f7f7f774de306f14\"),\n\t\t\tIssuerUri:                  pulumi.String(\"http://www.okta.com/exk17q7f7f7f7fp50h8\"),\n\t\t\tRequestBinding:             pulumi.String(\"HTTP-POST\"),\n\t\t\tResponseSignatureAlgorithm: pulumi.String(\"SHA-256\"),\n\t\t\tSsoDebugEnabled:            pulumi.Bool(true),\n\t\t\tSsoUrl:                     pulumi.String(\"https://mysso.oktapreview.com/app/mysso_terraformtestsso/exk17q7f7f7f7f50h8/sso/saml\"),\n\t\t\tStatus:                     pulumi.String(\"ACTIVE\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.FederatedSettingsIdentityProvider;\nimport com.pulumi.mongodbatlas.FederatedSettingsIdentityProviderArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var identityProvider = new FederatedSettingsIdentityProvider(\"identityProvider\", FederatedSettingsIdentityProviderArgs.builder()        \n            .associatedDomains(\"yourdomain.com\")\n            .federationSettingsId(\"627a9687f7f7f7f774de306f14\")\n            .issuerUri(\"http://www.okta.com/exk17q7f7f7f7fp50h8\")\n            .requestBinding(\"HTTP-POST\")\n            .responseSignatureAlgorithm(\"SHA-256\")\n            .ssoDebugEnabled(true)\n            .ssoUrl(\"https://mysso.oktapreview.com/app/mysso_terraformtestsso/exk17q7f7f7f7f50h8/sso/saml\")\n            .status(\"ACTIVE\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  identityProvider:\n    type: mongodbatlas:FederatedSettingsIdentityProvider\n    properties:\n      associatedDomains:\n        - yourdomain.com\n      federationSettingsId: 627a9687f7f7f7f774de306f14\n      issuerUri: http://www.okta.com/exk17q7f7f7f7fp50h8\n      requestBinding: HTTP-POST\n      responseSignatureAlgorithm: SHA-256\n      ssoDebugEnabled: true\n      ssoUrl: https://mysso.oktapreview.com/app/mysso_terraformtestsso/exk17q7f7f7f7f50h8/sso/saml\n      status: ACTIVE\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nIdentity Provider **must** be imported before using federation_settings_id-idp_id, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/federatedSettingsIdentityProvider:FederatedSettingsIdentityProvider identity_provider 6287a663c660f52b1c441c6c-0oad4fas87jL5Xnk1297\n```\n\n For more information see[MongoDB Atlas API Reference.](https://www.mongodb.com/docs/atlas/reference/api/federation-configuration/) ",
            "properties": {
                "associatedDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List that contains the domains associated with the identity provider.\n"
                },
                "federationSettingsId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                },
                "issuerUri": {
                    "type": "string",
                    "description": "Unique string that identifies the issuer of the SAML\n"
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable label that identifies the identity provider.\n"
                },
                "oktaIdpId": {
                    "type": "string",
                    "description": "Unique 20-hexadecimal digit string that identifies the IdP.\n"
                },
                "requestBinding": {
                    "type": "string",
                    "description": "SAML Authentication Request Protocol HTTP method binding (POST or REDIRECT) that Federated Authentication uses to send the authentication request. Atlas supports the following binding values:\n- HTTP POST\n- HTTP REDIRECT\n"
                },
                "responseSignatureAlgorithm": {
                    "type": "string",
                    "description": "Signature algorithm that Federated Authentication uses to encrypt the identity provider signature.  Valid values include SHA-1 and SHA-256.\n"
                },
                "ssoDebugEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the identity provider has SSO debug enabled.\n"
                },
                "ssoUrl": {
                    "type": "string",
                    "description": "Unique string that identifies the intended audience of the SAML assertion.\n"
                },
                "status": {
                    "type": "string",
                    "description": "String enum that indicates whether the identity provider is active or not. Accepted values are ACTIVE or INACTIVE.\n"
                }
            },
            "required": [
                "federationSettingsId",
                "issuerUri",
                "name",
                "oktaIdpId",
                "requestBinding",
                "responseSignatureAlgorithm",
                "ssoDebugEnabled",
                "ssoUrl",
                "status"
            ],
            "inputProperties": {
                "associatedDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List that contains the domains associated with the identity provider.\n"
                },
                "federationSettingsId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                },
                "issuerUri": {
                    "type": "string",
                    "description": "Unique string that identifies the issuer of the SAML\n"
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable label that identifies the identity provider.\n"
                },
                "requestBinding": {
                    "type": "string",
                    "description": "SAML Authentication Request Protocol HTTP method binding (POST or REDIRECT) that Federated Authentication uses to send the authentication request. Atlas supports the following binding values:\n- HTTP POST\n- HTTP REDIRECT\n"
                },
                "responseSignatureAlgorithm": {
                    "type": "string",
                    "description": "Signature algorithm that Federated Authentication uses to encrypt the identity provider signature.  Valid values include SHA-1 and SHA-256.\n"
                },
                "ssoDebugEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the identity provider has SSO debug enabled.\n"
                },
                "ssoUrl": {
                    "type": "string",
                    "description": "Unique string that identifies the intended audience of the SAML assertion.\n"
                },
                "status": {
                    "type": "string",
                    "description": "String enum that indicates whether the identity provider is active or not. Accepted values are ACTIVE or INACTIVE.\n"
                }
            },
            "requiredInputs": [
                "federationSettingsId",
                "issuerUri",
                "requestBinding",
                "responseSignatureAlgorithm",
                "ssoDebugEnabled",
                "ssoUrl",
                "status"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FederatedSettingsIdentityProvider resources.\n",
                "properties": {
                    "associatedDomains": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List that contains the domains associated with the identity provider.\n"
                    },
                    "federationSettingsId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                    },
                    "issuerUri": {
                        "type": "string",
                        "description": "Unique string that identifies the issuer of the SAML\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Human-readable label that identifies the identity provider.\n"
                    },
                    "oktaIdpId": {
                        "type": "string",
                        "description": "Unique 20-hexadecimal digit string that identifies the IdP.\n"
                    },
                    "requestBinding": {
                        "type": "string",
                        "description": "SAML Authentication Request Protocol HTTP method binding (POST or REDIRECT) that Federated Authentication uses to send the authentication request. Atlas supports the following binding values:\n- HTTP POST\n- HTTP REDIRECT\n"
                    },
                    "responseSignatureAlgorithm": {
                        "type": "string",
                        "description": "Signature algorithm that Federated Authentication uses to encrypt the identity provider signature.  Valid values include SHA-1 and SHA-256.\n"
                    },
                    "ssoDebugEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether the identity provider has SSO debug enabled.\n"
                    },
                    "ssoUrl": {
                        "type": "string",
                        "description": "Unique string that identifies the intended audience of the SAML assertion.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "String enum that indicates whether the identity provider is active or not. Accepted values are ACTIVE or INACTIVE.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/federatedSettingsOrgConfig:FederatedSettingsOrgConfig": {
            "properties": {
                "domainAllowLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "domainRestrictionEnabled": {
                    "type": "boolean"
                },
                "federationSettingsId": {
                    "type": "string"
                },
                "identityProviderId": {
                    "type": "string"
                },
                "orgId": {
                    "type": "string"
                },
                "postAuthRoleGrants": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "domainRestrictionEnabled",
                "federationSettingsId",
                "identityProviderId",
                "orgId"
            ],
            "inputProperties": {
                "domainAllowLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "domainRestrictionEnabled": {
                    "type": "boolean"
                },
                "federationSettingsId": {
                    "type": "string"
                },
                "identityProviderId": {
                    "type": "string"
                },
                "orgId": {
                    "type": "string"
                },
                "postAuthRoleGrants": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "requiredInputs": [
                "domainRestrictionEnabled",
                "federationSettingsId",
                "identityProviderId",
                "orgId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FederatedSettingsOrgConfig resources.\n",
                "properties": {
                    "domainAllowLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "domainRestrictionEnabled": {
                        "type": "boolean"
                    },
                    "federationSettingsId": {
                        "type": "string"
                    },
                    "identityProviderId": {
                        "type": "string"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "postAuthRoleGrants": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/federatedSettingsOrgRoleMapping:FederatedSettingsOrgRoleMapping": {
            "description": "`mongodbatlas.FederatedSettingsOrgRoleMapping` provides an Role Mapping resource. This allows organization role mapping to be created.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst orgGroupRoleMappingImport = new mongodbatlas.FederatedSettingsOrgRoleMapping(\"orgGroupRoleMappingImport\", {\n    externalGroupName: \"myGrouptest\",\n    federationSettingsId: \"627a9687f7f7f7f774de306f14\",\n    orgId: \"627a9683e7f7f7ff7fe306f14\",\n    roleAssignments: [\n        {\n            orgId: \"627a9683e7f7f7ff7fe306f14\",\n            roles: [\n                \"ORG_MEMBER\",\n                \"ORG_GROUP_CREATOR\",\n                \"ORG_BILLING_ADMIN\",\n            ],\n        },\n        {\n            groupId: \"628aa20d7f7f7f7f7098b81b8\",\n            roles: [\n                \"GROUP_OWNER\",\n                \"GROUP_DATA_ACCESS_ADMIN\",\n                \"GROUP_SEARCH_INDEX_EDITOR\",\n                \"GROUP_DATA_ACCESS_READ_ONLY\",\n            ],\n        },\n        {\n            groupId: \"628aa20d7f7f7f7f7078b81b8\",\n            roles: [\n                \"GROUP_OWNER\",\n                \"GROUP_DATA_ACCESS_ADMIN\",\n                \"GROUP_SEARCH_INDEX_EDITOR\",\n                \"GROUP_DATA_ACCESS_READ_ONLY\",\n                \"GROUP_DATA_ACCESS_READ_WRITE\",\n            ],\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\norg_group_role_mapping_import = mongodbatlas.FederatedSettingsOrgRoleMapping(\"orgGroupRoleMappingImport\",\n    external_group_name=\"myGrouptest\",\n    federation_settings_id=\"627a9687f7f7f7f774de306f14\",\n    org_id=\"627a9683e7f7f7ff7fe306f14\",\n    role_assignments=[\n        mongodbatlas.FederatedSettingsOrgRoleMappingRoleAssignmentArgs(\n            org_id=\"627a9683e7f7f7ff7fe306f14\",\n            roles=[\n                \"ORG_MEMBER\",\n                \"ORG_GROUP_CREATOR\",\n                \"ORG_BILLING_ADMIN\",\n            ],\n        ),\n        mongodbatlas.FederatedSettingsOrgRoleMappingRoleAssignmentArgs(\n            group_id=\"628aa20d7f7f7f7f7098b81b8\",\n            roles=[\n                \"GROUP_OWNER\",\n                \"GROUP_DATA_ACCESS_ADMIN\",\n                \"GROUP_SEARCH_INDEX_EDITOR\",\n                \"GROUP_DATA_ACCESS_READ_ONLY\",\n            ],\n        ),\n        mongodbatlas.FederatedSettingsOrgRoleMappingRoleAssignmentArgs(\n            group_id=\"628aa20d7f7f7f7f7078b81b8\",\n            roles=[\n                \"GROUP_OWNER\",\n                \"GROUP_DATA_ACCESS_ADMIN\",\n                \"GROUP_SEARCH_INDEX_EDITOR\",\n                \"GROUP_DATA_ACCESS_READ_ONLY\",\n                \"GROUP_DATA_ACCESS_READ_WRITE\",\n            ],\n        ),\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var orgGroupRoleMappingImport = new Mongodbatlas.FederatedSettingsOrgRoleMapping(\"orgGroupRoleMappingImport\", new()\n    {\n        ExternalGroupName = \"myGrouptest\",\n        FederationSettingsId = \"627a9687f7f7f7f774de306f14\",\n        OrgId = \"627a9683e7f7f7ff7fe306f14\",\n        RoleAssignments = new[]\n        {\n            new Mongodbatlas.Inputs.FederatedSettingsOrgRoleMappingRoleAssignmentArgs\n            {\n                OrgId = \"627a9683e7f7f7ff7fe306f14\",\n                Roles = new[]\n                {\n                    \"ORG_MEMBER\",\n                    \"ORG_GROUP_CREATOR\",\n                    \"ORG_BILLING_ADMIN\",\n                },\n            },\n            new Mongodbatlas.Inputs.FederatedSettingsOrgRoleMappingRoleAssignmentArgs\n            {\n                GroupId = \"628aa20d7f7f7f7f7098b81b8\",\n                Roles = new[]\n                {\n                    \"GROUP_OWNER\",\n                    \"GROUP_DATA_ACCESS_ADMIN\",\n                    \"GROUP_SEARCH_INDEX_EDITOR\",\n                    \"GROUP_DATA_ACCESS_READ_ONLY\",\n                },\n            },\n            new Mongodbatlas.Inputs.FederatedSettingsOrgRoleMappingRoleAssignmentArgs\n            {\n                GroupId = \"628aa20d7f7f7f7f7078b81b8\",\n                Roles = new[]\n                {\n                    \"GROUP_OWNER\",\n                    \"GROUP_DATA_ACCESS_ADMIN\",\n                    \"GROUP_SEARCH_INDEX_EDITOR\",\n                    \"GROUP_DATA_ACCESS_READ_ONLY\",\n                    \"GROUP_DATA_ACCESS_READ_WRITE\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewFederatedSettingsOrgRoleMapping(ctx, \"orgGroupRoleMappingImport\", \u0026mongodbatlas.FederatedSettingsOrgRoleMappingArgs{\n\t\t\tExternalGroupName:    pulumi.String(\"myGrouptest\"),\n\t\t\tFederationSettingsId: pulumi.String(\"627a9687f7f7f7f774de306f14\"),\n\t\t\tOrgId:                pulumi.String(\"627a9683e7f7f7ff7fe306f14\"),\n\t\t\tRoleAssignments: mongodbatlas.FederatedSettingsOrgRoleMappingRoleAssignmentArray{\n\t\t\t\t\u0026mongodbatlas.FederatedSettingsOrgRoleMappingRoleAssignmentArgs{\n\t\t\t\t\tOrgId: pulumi.String(\"627a9683e7f7f7ff7fe306f14\"),\n\t\t\t\t\tRoles: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"ORG_MEMBER\"),\n\t\t\t\t\t\tpulumi.String(\"ORG_GROUP_CREATOR\"),\n\t\t\t\t\t\tpulumi.String(\"ORG_BILLING_ADMIN\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.FederatedSettingsOrgRoleMappingRoleAssignmentArgs{\n\t\t\t\t\tGroupId: pulumi.String(\"628aa20d7f7f7f7f7098b81b8\"),\n\t\t\t\t\tRoles: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_OWNER\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_ADMIN\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_SEARCH_INDEX_EDITOR\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_READ_ONLY\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.FederatedSettingsOrgRoleMappingRoleAssignmentArgs{\n\t\t\t\t\tGroupId: pulumi.String(\"628aa20d7f7f7f7f7078b81b8\"),\n\t\t\t\t\tRoles: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_OWNER\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_ADMIN\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_SEARCH_INDEX_EDITOR\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_READ_ONLY\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_READ_WRITE\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.FederatedSettingsOrgRoleMapping;\nimport com.pulumi.mongodbatlas.FederatedSettingsOrgRoleMappingArgs;\nimport com.pulumi.mongodbatlas.inputs.FederatedSettingsOrgRoleMappingRoleAssignmentArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var orgGroupRoleMappingImport = new FederatedSettingsOrgRoleMapping(\"orgGroupRoleMappingImport\", FederatedSettingsOrgRoleMappingArgs.builder()        \n            .externalGroupName(\"myGrouptest\")\n            .federationSettingsId(\"627a9687f7f7f7f774de306f14\")\n            .orgId(\"627a9683e7f7f7ff7fe306f14\")\n            .roleAssignments(            \n                FederatedSettingsOrgRoleMappingRoleAssignmentArgs.builder()\n                    .orgId(\"627a9683e7f7f7ff7fe306f14\")\n                    .roles(                    \n                        \"ORG_MEMBER\",\n                        \"ORG_GROUP_CREATOR\",\n                        \"ORG_BILLING_ADMIN\")\n                    .build(),\n                FederatedSettingsOrgRoleMappingRoleAssignmentArgs.builder()\n                    .groupId(\"628aa20d7f7f7f7f7098b81b8\")\n                    .roles(                    \n                        \"GROUP_OWNER\",\n                        \"GROUP_DATA_ACCESS_ADMIN\",\n                        \"GROUP_SEARCH_INDEX_EDITOR\",\n                        \"GROUP_DATA_ACCESS_READ_ONLY\")\n                    .build(),\n                FederatedSettingsOrgRoleMappingRoleAssignmentArgs.builder()\n                    .groupId(\"628aa20d7f7f7f7f7078b81b8\")\n                    .roles(                    \n                        \"GROUP_OWNER\",\n                        \"GROUP_DATA_ACCESS_ADMIN\",\n                        \"GROUP_SEARCH_INDEX_EDITOR\",\n                        \"GROUP_DATA_ACCESS_READ_ONLY\",\n                        \"GROUP_DATA_ACCESS_READ_WRITE\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  orgGroupRoleMappingImport:\n    type: mongodbatlas:FederatedSettingsOrgRoleMapping\n    properties:\n      externalGroupName: myGrouptest\n      federationSettingsId: 627a9687f7f7f7f774de306f14\n      orgId: 627a9683e7f7f7ff7fe306f14\n      roleAssignments:\n        - orgId: 627a9683e7f7f7ff7fe306f14\n          roles:\n            - ORG_MEMBER\n            - ORG_GROUP_CREATOR\n            - ORG_BILLING_ADMIN\n        - groupId: 628aa20d7f7f7f7f7098b81b8\n          roles:\n            - GROUP_OWNER\n            - GROUP_DATA_ACCESS_ADMIN\n            - GROUP_SEARCH_INDEX_EDITOR\n            - GROUP_DATA_ACCESS_READ_ONLY\n        - groupId: 628aa20d7f7f7f7f7078b81b8\n          roles:\n            - GROUP_OWNER\n            - GROUP_DATA_ACCESS_ADMIN\n            - GROUP_SEARCH_INDEX_EDITOR\n            - GROUP_DATA_ACCESS_READ_ONLY\n            - GROUP_DATA_ACCESS_READ_WRITE\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nFederatedSettingsOrgRoleMapping can be imported using federation_settings_id-org_id-role_mapping_id, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/federatedSettingsOrgRoleMapping:FederatedSettingsOrgRoleMapping org_group_role_mapping_import 6287a663c7f7f7f71c441c6c-627a96837f7f7f7e306f14-628ae97f7f7468ea3727\n```\n\n For more information see[MongoDB Atlas API Reference.](https://www.mongodb.com/docs/atlas/reference/api/federation-configuration/) ",
            "properties": {
                "externalGroupName": {
                    "type": "string",
                    "description": "Unique human-readable label that identifies the identity provider group to which this role mapping applies.\n"
                },
                "federationSettingsId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                },
                "roleAssignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/FederatedSettingsOrgRoleMappingRoleAssignment:FederatedSettingsOrgRoleMappingRoleAssignment"
                    },
                    "description": "Atlas roles and the unique identifiers of the groups and organizations associated with each role.\n"
                }
            },
            "required": [
                "externalGroupName",
                "federationSettingsId",
                "orgId",
                "roleAssignments"
            ],
            "inputProperties": {
                "externalGroupName": {
                    "type": "string",
                    "description": "Unique human-readable label that identifies the identity provider group to which this role mapping applies.\n"
                },
                "federationSettingsId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                },
                "roleAssignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/FederatedSettingsOrgRoleMappingRoleAssignment:FederatedSettingsOrgRoleMappingRoleAssignment"
                    },
                    "description": "Atlas roles and the unique identifiers of the groups and organizations associated with each role.\n"
                }
            },
            "requiredInputs": [
                "externalGroupName",
                "federationSettingsId",
                "orgId",
                "roleAssignments"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FederatedSettingsOrgRoleMapping resources.\n",
                "properties": {
                    "externalGroupName": {
                        "type": "string",
                        "description": "Unique human-readable label that identifies the identity provider group to which this role mapping applies.\n"
                    },
                    "federationSettingsId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                    },
                    "roleAssignments": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/FederatedSettingsOrgRoleMappingRoleAssignment:FederatedSettingsOrgRoleMappingRoleAssignment"
                        },
                        "description": "Atlas roles and the unique identifiers of the groups and organizations associated with each role.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/globalClusterConfig:GlobalClusterConfig": {
            "description": "`mongodbatlas.GlobalClusterConfig` provides a Global Cluster Configuration resource.\n\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n\n## Examples Usage\n\n### Example Global cluster\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.Cluster(\"test\", {\n    projectId: \"\u003cYOUR-PROJECT-ID\u003e\",\n    diskSizeGb: 80,\n    cloudBackup: true,\n    clusterType: \"GEOSHARDED\",\n    providerName: \"AWS\",\n    providerInstanceSizeName: \"M30\",\n    replicationSpecs: [\n        {\n            zoneName: \"Zone 1\",\n            numShards: 1,\n            regionsConfigs: [{\n                regionName: \"EU_CENTRAL_1\",\n                electableNodes: 3,\n                priority: 7,\n                readOnlyNodes: 0,\n            }],\n        },\n        {\n            zoneName: \"Zone 2\",\n            numShards: 1,\n            regionsConfigs: [{\n                regionName: \"US_EAST_2\",\n                electableNodes: 3,\n                priority: 7,\n                readOnlyNodes: 0,\n            }],\n        },\n    ],\n});\nconst config = new mongodbatlas.GlobalClusterConfig(\"config\", {\n    projectId: test.projectId,\n    clusterName: test.name,\n    managedNamespaces: [{\n        db: \"mydata\",\n        collection: \"publishers\",\n        customShardKey: \"city\",\n        isCustomShardKeyHashed: false,\n        isShardKeyUnique: false,\n    }],\n    customZoneMappings: [{\n        location: \"CA\",\n        zone: \"Zone 1\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.Cluster(\"test\",\n    project_id=\"\u003cYOUR-PROJECT-ID\u003e\",\n    disk_size_gb=80,\n    cloud_backup=True,\n    cluster_type=\"GEOSHARDED\",\n    provider_name=\"AWS\",\n    provider_instance_size_name=\"M30\",\n    replication_specs=[\n        mongodbatlas.ClusterReplicationSpecArgs(\n            zone_name=\"Zone 1\",\n            num_shards=1,\n            regions_configs=[mongodbatlas.ClusterReplicationSpecRegionsConfigArgs(\n                region_name=\"EU_CENTRAL_1\",\n                electable_nodes=3,\n                priority=7,\n                read_only_nodes=0,\n            )],\n        ),\n        mongodbatlas.ClusterReplicationSpecArgs(\n            zone_name=\"Zone 2\",\n            num_shards=1,\n            regions_configs=[mongodbatlas.ClusterReplicationSpecRegionsConfigArgs(\n                region_name=\"US_EAST_2\",\n                electable_nodes=3,\n                priority=7,\n                read_only_nodes=0,\n            )],\n        ),\n    ])\nconfig = mongodbatlas.GlobalClusterConfig(\"config\",\n    project_id=test.project_id,\n    cluster_name=test.name,\n    managed_namespaces=[mongodbatlas.GlobalClusterConfigManagedNamespaceArgs(\n        db=\"mydata\",\n        collection=\"publishers\",\n        custom_shard_key=\"city\",\n        is_custom_shard_key_hashed=False,\n        is_shard_key_unique=False,\n    )],\n    custom_zone_mappings=[mongodbatlas.GlobalClusterConfigCustomZoneMappingArgs(\n        location=\"CA\",\n        zone=\"Zone 1\",\n    )])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.Cluster(\"test\", new()\n    {\n        ProjectId = \"\u003cYOUR-PROJECT-ID\u003e\",\n        DiskSizeGb = 80,\n        CloudBackup = true,\n        ClusterType = \"GEOSHARDED\",\n        ProviderName = \"AWS\",\n        ProviderInstanceSizeName = \"M30\",\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.ClusterReplicationSpecArgs\n            {\n                ZoneName = \"Zone 1\",\n                NumShards = 1,\n                RegionsConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.ClusterReplicationSpecRegionsConfigArgs\n                    {\n                        RegionName = \"EU_CENTRAL_1\",\n                        ElectableNodes = 3,\n                        Priority = 7,\n                        ReadOnlyNodes = 0,\n                    },\n                },\n            },\n            new Mongodbatlas.Inputs.ClusterReplicationSpecArgs\n            {\n                ZoneName = \"Zone 2\",\n                NumShards = 1,\n                RegionsConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.ClusterReplicationSpecRegionsConfigArgs\n                    {\n                        RegionName = \"US_EAST_2\",\n                        ElectableNodes = 3,\n                        Priority = 7,\n                        ReadOnlyNodes = 0,\n                    },\n                },\n            },\n        },\n    });\n\n    var config = new Mongodbatlas.GlobalClusterConfig(\"config\", new()\n    {\n        ProjectId = test.ProjectId,\n        ClusterName = test.Name,\n        ManagedNamespaces = new[]\n        {\n            new Mongodbatlas.Inputs.GlobalClusterConfigManagedNamespaceArgs\n            {\n                Db = \"mydata\",\n                Collection = \"publishers\",\n                CustomShardKey = \"city\",\n                IsCustomShardKeyHashed = false,\n                IsShardKeyUnique = false,\n            },\n        },\n        CustomZoneMappings = new[]\n        {\n            new Mongodbatlas.Inputs.GlobalClusterConfigCustomZoneMappingArgs\n            {\n                Location = \"CA\",\n                Zone = \"Zone 1\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := mongodbatlas.NewCluster(ctx, \"test\", \u0026mongodbatlas.ClusterArgs{\n\t\t\tProjectId:                pulumi.String(\"\u003cYOUR-PROJECT-ID\u003e\"),\n\t\t\tDiskSizeGb:               pulumi.Float64(80),\n\t\t\tCloudBackup:              pulumi.Bool(true),\n\t\t\tClusterType:              pulumi.String(\"GEOSHARDED\"),\n\t\t\tProviderName:             pulumi.String(\"AWS\"),\n\t\t\tProviderInstanceSizeName: pulumi.String(\"M30\"),\n\t\t\tReplicationSpecs: mongodbatlas.ClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecArgs{\n\t\t\t\t\tZoneName:  pulumi.String(\"Zone 1\"),\n\t\t\t\t\tNumShards: pulumi.Int(1),\n\t\t\t\t\tRegionsConfigs: mongodbatlas.ClusterReplicationSpecRegionsConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecRegionsConfigArgs{\n\t\t\t\t\t\t\tRegionName:     pulumi.String(\"EU_CENTRAL_1\"),\n\t\t\t\t\t\t\tElectableNodes: pulumi.Int(3),\n\t\t\t\t\t\t\tPriority:       pulumi.Int(7),\n\t\t\t\t\t\t\tReadOnlyNodes:  pulumi.Int(0),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecArgs{\n\t\t\t\t\tZoneName:  pulumi.String(\"Zone 2\"),\n\t\t\t\t\tNumShards: pulumi.Int(1),\n\t\t\t\t\tRegionsConfigs: mongodbatlas.ClusterReplicationSpecRegionsConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecRegionsConfigArgs{\n\t\t\t\t\t\t\tRegionName:     pulumi.String(\"US_EAST_2\"),\n\t\t\t\t\t\t\tElectableNodes: pulumi.Int(3),\n\t\t\t\t\t\t\tPriority:       pulumi.Int(7),\n\t\t\t\t\t\t\tReadOnlyNodes:  pulumi.Int(0),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewGlobalClusterConfig(ctx, \"config\", \u0026mongodbatlas.GlobalClusterConfigArgs{\n\t\t\tProjectId:   test.ProjectId,\n\t\t\tClusterName: test.Name,\n\t\t\tManagedNamespaces: mongodbatlas.GlobalClusterConfigManagedNamespaceArray{\n\t\t\t\t\u0026mongodbatlas.GlobalClusterConfigManagedNamespaceArgs{\n\t\t\t\t\tDb:                     pulumi.String(\"mydata\"),\n\t\t\t\t\tCollection:             pulumi.String(\"publishers\"),\n\t\t\t\t\tCustomShardKey:         pulumi.String(\"city\"),\n\t\t\t\t\tIsCustomShardKeyHashed: pulumi.Bool(false),\n\t\t\t\t\tIsShardKeyUnique:       pulumi.Bool(false),\n\t\t\t\t},\n\t\t\t},\n\t\t\tCustomZoneMappings: mongodbatlas.GlobalClusterConfigCustomZoneMappingArray{\n\t\t\t\t\u0026mongodbatlas.GlobalClusterConfigCustomZoneMappingArgs{\n\t\t\t\t\tLocation: pulumi.String(\"CA\"),\n\t\t\t\t\tZone:     pulumi.String(\"Zone 1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Cluster;\nimport com.pulumi.mongodbatlas.ClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.ClusterReplicationSpecArgs;\nimport com.pulumi.mongodbatlas.GlobalClusterConfig;\nimport com.pulumi.mongodbatlas.GlobalClusterConfigArgs;\nimport com.pulumi.mongodbatlas.inputs.GlobalClusterConfigManagedNamespaceArgs;\nimport com.pulumi.mongodbatlas.inputs.GlobalClusterConfigCustomZoneMappingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new Cluster(\"test\", ClusterArgs.builder()        \n            .projectId(\"\u003cYOUR-PROJECT-ID\u003e\")\n            .diskSizeGb(80)\n            .cloudBackup(true)\n            .clusterType(\"GEOSHARDED\")\n            .providerName(\"AWS\")\n            .providerInstanceSizeName(\"M30\")\n            .replicationSpecs(            \n                ClusterReplicationSpecArgs.builder()\n                    .zoneName(\"Zone 1\")\n                    .numShards(1)\n                    .regionsConfigs(ClusterReplicationSpecRegionsConfigArgs.builder()\n                        .regionName(\"EU_CENTRAL_1\")\n                        .electableNodes(3)\n                        .priority(7)\n                        .readOnlyNodes(0)\n                        .build())\n                    .build(),\n                ClusterReplicationSpecArgs.builder()\n                    .zoneName(\"Zone 2\")\n                    .numShards(1)\n                    .regionsConfigs(ClusterReplicationSpecRegionsConfigArgs.builder()\n                        .regionName(\"US_EAST_2\")\n                        .electableNodes(3)\n                        .priority(7)\n                        .readOnlyNodes(0)\n                        .build())\n                    .build())\n            .build());\n\n        var config = new GlobalClusterConfig(\"config\", GlobalClusterConfigArgs.builder()        \n            .projectId(test.projectId())\n            .clusterName(test.name())\n            .managedNamespaces(GlobalClusterConfigManagedNamespaceArgs.builder()\n                .db(\"mydata\")\n                .collection(\"publishers\")\n                .customShardKey(\"city\")\n                .isCustomShardKeyHashed(false)\n                .isShardKeyUnique(false)\n                .build())\n            .customZoneMappings(GlobalClusterConfigCustomZoneMappingArgs.builder()\n                .location(\"CA\")\n                .zone(\"Zone 1\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:Cluster\n    properties:\n      projectId: \u003cYOUR-PROJECT-ID\u003e\n      diskSizeGb: 80\n      cloudBackup: true\n      clusterType: GEOSHARDED\n      # Provider Settings \"block\"\n      providerName: AWS\n      providerInstanceSizeName: M30\n      replicationSpecs:\n        - zoneName: Zone 1\n          numShards: 1\n          regionsConfigs:\n            - regionName: EU_CENTRAL_1\n              electableNodes: 3\n              priority: 7\n              readOnlyNodes: 0\n        - zoneName: Zone 2\n          numShards: 1\n          regionsConfigs:\n            - regionName: US_EAST_2\n              electableNodes: 3\n              priority: 7\n              readOnlyNodes: 0\n  config:\n    type: mongodbatlas:GlobalClusterConfig\n    properties:\n      projectId: ${test.projectId}\n      clusterName: ${test.name}\n      managedNamespaces:\n        - db: mydata\n          collection: publishers\n          customShardKey: city\n          isCustomShardKeyHashed: false\n          isShardKeyUnique: false\n      customZoneMappings:\n        - location: CA\n          zone: Zone 1\n```\n\n### Example Global cluster config\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst cluster_test = new mongodbatlas.Cluster(\"cluster-test\", {\n    projectId: \"\u003cYOUR-PROJECT-ID\u003e\",\n    clusterType: \"REPLICASET\",\n    replicationSpecs: [{\n        numShards: 1,\n        regionsConfigs: [{\n            regionName: \"US_EAST_1\",\n            electableNodes: 3,\n            priority: 7,\n            readOnlyNodes: 0,\n        }],\n    }],\n    backupEnabled: true,\n    autoScalingDiskGbEnabled: true,\n    mongoDbMajorVersion: \"4.0\",\n    providerName: \"AWS\",\n    diskSizeGb: 100,\n    providerInstanceSizeName: \"M40\",\n});\nconst config = new mongodbatlas.GlobalClusterConfig(\"config\", {\n    projectId: mongodbatlas_cluster.test.project_id,\n    clusterName: mongodbatlas_cluster.test.name,\n    managedNamespaces: [{\n        db: \"mydata\",\n        collection: \"publishers\",\n        customShardKey: \"city\",\n    }],\n    customZoneMappings: [{\n        location: \"CA\",\n        zone: \"Zone 1\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ncluster_test = mongodbatlas.Cluster(\"cluster-test\",\n    project_id=\"\u003cYOUR-PROJECT-ID\u003e\",\n    cluster_type=\"REPLICASET\",\n    replication_specs=[mongodbatlas.ClusterReplicationSpecArgs(\n        num_shards=1,\n        regions_configs=[mongodbatlas.ClusterReplicationSpecRegionsConfigArgs(\n            region_name=\"US_EAST_1\",\n            electable_nodes=3,\n            priority=7,\n            read_only_nodes=0,\n        )],\n    )],\n    backup_enabled=True,\n    auto_scaling_disk_gb_enabled=True,\n    mongo_db_major_version=\"4.0\",\n    provider_name=\"AWS\",\n    disk_size_gb=100,\n    provider_instance_size_name=\"M40\")\nconfig = mongodbatlas.GlobalClusterConfig(\"config\",\n    project_id=mongodbatlas_cluster[\"test\"][\"project_id\"],\n    cluster_name=mongodbatlas_cluster[\"test\"][\"name\"],\n    managed_namespaces=[mongodbatlas.GlobalClusterConfigManagedNamespaceArgs(\n        db=\"mydata\",\n        collection=\"publishers\",\n        custom_shard_key=\"city\",\n    )],\n    custom_zone_mappings=[mongodbatlas.GlobalClusterConfigCustomZoneMappingArgs(\n        location=\"CA\",\n        zone=\"Zone 1\",\n    )])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var cluster_test = new Mongodbatlas.Cluster(\"cluster-test\", new()\n    {\n        ProjectId = \"\u003cYOUR-PROJECT-ID\u003e\",\n        ClusterType = \"REPLICASET\",\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.ClusterReplicationSpecArgs\n            {\n                NumShards = 1,\n                RegionsConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.ClusterReplicationSpecRegionsConfigArgs\n                    {\n                        RegionName = \"US_EAST_1\",\n                        ElectableNodes = 3,\n                        Priority = 7,\n                        ReadOnlyNodes = 0,\n                    },\n                },\n            },\n        },\n        BackupEnabled = true,\n        AutoScalingDiskGbEnabled = true,\n        MongoDbMajorVersion = \"4.0\",\n        ProviderName = \"AWS\",\n        DiskSizeGb = 100,\n        ProviderInstanceSizeName = \"M40\",\n    });\n\n    var config = new Mongodbatlas.GlobalClusterConfig(\"config\", new()\n    {\n        ProjectId = mongodbatlas_cluster.Test.Project_id,\n        ClusterName = mongodbatlas_cluster.Test.Name,\n        ManagedNamespaces = new[]\n        {\n            new Mongodbatlas.Inputs.GlobalClusterConfigManagedNamespaceArgs\n            {\n                Db = \"mydata\",\n                Collection = \"publishers\",\n                CustomShardKey = \"city\",\n            },\n        },\n        CustomZoneMappings = new[]\n        {\n            new Mongodbatlas.Inputs.GlobalClusterConfigCustomZoneMappingArgs\n            {\n                Location = \"CA\",\n                Zone = \"Zone 1\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewCluster(ctx, \"cluster-test\", \u0026mongodbatlas.ClusterArgs{\n\t\t\tProjectId:   pulumi.String(\"\u003cYOUR-PROJECT-ID\u003e\"),\n\t\t\tClusterType: pulumi.String(\"REPLICASET\"),\n\t\t\tReplicationSpecs: mongodbatlas.ClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecArgs{\n\t\t\t\t\tNumShards: pulumi.Int(1),\n\t\t\t\t\tRegionsConfigs: mongodbatlas.ClusterReplicationSpecRegionsConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecRegionsConfigArgs{\n\t\t\t\t\t\t\tRegionName:     pulumi.String(\"US_EAST_1\"),\n\t\t\t\t\t\t\tElectableNodes: pulumi.Int(3),\n\t\t\t\t\t\t\tPriority:       pulumi.Int(7),\n\t\t\t\t\t\t\tReadOnlyNodes:  pulumi.Int(0),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tBackupEnabled:            pulumi.Bool(true),\n\t\t\tAutoScalingDiskGbEnabled: pulumi.Bool(true),\n\t\t\tMongoDbMajorVersion:      pulumi.String(\"4.0\"),\n\t\t\tProviderName:             pulumi.String(\"AWS\"),\n\t\t\tDiskSizeGb:               pulumi.Float64(100),\n\t\t\tProviderInstanceSizeName: pulumi.String(\"M40\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewGlobalClusterConfig(ctx, \"config\", \u0026mongodbatlas.GlobalClusterConfigArgs{\n\t\t\tProjectId:   pulumi.Any(mongodbatlas_cluster.Test.Project_id),\n\t\t\tClusterName: pulumi.Any(mongodbatlas_cluster.Test.Name),\n\t\t\tManagedNamespaces: mongodbatlas.GlobalClusterConfigManagedNamespaceArray{\n\t\t\t\t\u0026mongodbatlas.GlobalClusterConfigManagedNamespaceArgs{\n\t\t\t\t\tDb:             pulumi.String(\"mydata\"),\n\t\t\t\t\tCollection:     pulumi.String(\"publishers\"),\n\t\t\t\t\tCustomShardKey: pulumi.String(\"city\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tCustomZoneMappings: mongodbatlas.GlobalClusterConfigCustomZoneMappingArray{\n\t\t\t\t\u0026mongodbatlas.GlobalClusterConfigCustomZoneMappingArgs{\n\t\t\t\t\tLocation: pulumi.String(\"CA\"),\n\t\t\t\t\tZone:     pulumi.String(\"Zone 1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Cluster;\nimport com.pulumi.mongodbatlas.ClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.ClusterReplicationSpecArgs;\nimport com.pulumi.mongodbatlas.GlobalClusterConfig;\nimport com.pulumi.mongodbatlas.GlobalClusterConfigArgs;\nimport com.pulumi.mongodbatlas.inputs.GlobalClusterConfigManagedNamespaceArgs;\nimport com.pulumi.mongodbatlas.inputs.GlobalClusterConfigCustomZoneMappingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var cluster_test = new Cluster(\"cluster-test\", ClusterArgs.builder()        \n            .projectId(\"\u003cYOUR-PROJECT-ID\u003e\")\n            .clusterType(\"REPLICASET\")\n            .replicationSpecs(ClusterReplicationSpecArgs.builder()\n                .numShards(1)\n                .regionsConfigs(ClusterReplicationSpecRegionsConfigArgs.builder()\n                    .regionName(\"US_EAST_1\")\n                    .electableNodes(3)\n                    .priority(7)\n                    .readOnlyNodes(0)\n                    .build())\n                .build())\n            .backupEnabled(true)\n            .autoScalingDiskGbEnabled(true)\n            .mongoDbMajorVersion(\"4.0\")\n            .providerName(\"AWS\")\n            .diskSizeGb(100)\n            .providerInstanceSizeName(\"M40\")\n            .build());\n\n        var config = new GlobalClusterConfig(\"config\", GlobalClusterConfigArgs.builder()        \n            .projectId(mongodbatlas_cluster.test().project_id())\n            .clusterName(mongodbatlas_cluster.test().name())\n            .managedNamespaces(GlobalClusterConfigManagedNamespaceArgs.builder()\n                .db(\"mydata\")\n                .collection(\"publishers\")\n                .customShardKey(\"city\")\n                .build())\n            .customZoneMappings(GlobalClusterConfigCustomZoneMappingArgs.builder()\n                .location(\"CA\")\n                .zone(\"Zone 1\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  cluster-test:\n    type: mongodbatlas:Cluster\n    properties:\n      projectId: \u003cYOUR-PROJECT-ID\u003e\n      clusterType: REPLICASET\n      replicationSpecs:\n        - numShards: 1\n          regionsConfigs:\n            - regionName: US_EAST_1\n              electableNodes: 3\n              priority: 7\n              readOnlyNodes: 0\n      backupEnabled: true\n      autoScalingDiskGbEnabled: true\n      mongoDbMajorVersion: '4.0'\n      # Provider Settings \"block\"\n      providerName: AWS\n      diskSizeGb: 100\n      providerInstanceSizeName: M40\n  config:\n    type: mongodbatlas:GlobalClusterConfig\n    properties:\n      projectId: ${mongodbatlas_cluster.test.project_id}\n      clusterName: ${mongodbatlas_cluster.test.name}\n      managedNamespaces:\n        - db: mydata\n          collection: publishers\n          customShardKey: city\n      customZoneMappings:\n        - location: CA\n          zone: Zone 1\n```\n\n\n## Import\n\nGlobal Clusters can be imported using project ID and cluster name, in the format `PROJECTID-CLUSTER_NAME`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/globalClusterConfig:GlobalClusterConfig config 1112222b3bf99403840e8934-Cluster0\n```\n\n See detailed information for arguments and attributes[MongoDB API Global Clusters](https://docs.atlas.mongodb.com/reference/api/global-clusters/) ",
            "properties": {
                "clusterName": {
                    "type": "string",
                    "description": "The name of the Global Cluster.\n"
                },
                "customZoneMapping": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "A map of all custom zone mappings defined for the Global Cluster. Atlas automatically maps each location code to the closest geographical zone. Custom zone mappings allow administrators to override these automatic mappings. If your Global Cluster does not have any custom zone mappings, this document is empty.\n"
                },
                "customZoneMappings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/GlobalClusterConfigCustomZoneMapping:GlobalClusterConfigCustomZoneMapping"
                    },
                    "description": "Each element in the list maps one ISO location code to a zone in your Global Cluster. See Custom Zone Mapping below for more details.\n"
                },
                "managedNamespaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/GlobalClusterConfigManagedNamespace:GlobalClusterConfigManagedNamespace"
                    },
                    "description": "Add a managed namespaces to a Global Cluster. For more information about managed namespaces, see [Global Clusters](https://docs.atlas.mongodb.com/reference/api/global-clusters/). See Managed Namespace below for more details.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create the database user.\n"
                }
            },
            "required": [
                "clusterName",
                "customZoneMapping",
                "managedNamespaces",
                "projectId"
            ],
            "inputProperties": {
                "clusterName": {
                    "type": "string",
                    "description": "The name of the Global Cluster.\n",
                    "willReplaceOnChanges": true
                },
                "customZoneMappings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/GlobalClusterConfigCustomZoneMapping:GlobalClusterConfigCustomZoneMapping"
                    },
                    "description": "Each element in the list maps one ISO location code to a zone in your Global Cluster. See Custom Zone Mapping below for more details.\n"
                },
                "managedNamespaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/GlobalClusterConfigManagedNamespace:GlobalClusterConfigManagedNamespace"
                    },
                    "description": "Add a managed namespaces to a Global Cluster. For more information about managed namespaces, see [Global Clusters](https://docs.atlas.mongodb.com/reference/api/global-clusters/). See Managed Namespace below for more details.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create the database user.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "clusterName",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GlobalClusterConfig resources.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the Global Cluster.\n",
                        "willReplaceOnChanges": true
                    },
                    "customZoneMapping": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A map of all custom zone mappings defined for the Global Cluster. Atlas automatically maps each location code to the closest geographical zone. Custom zone mappings allow administrators to override these automatic mappings. If your Global Cluster does not have any custom zone mappings, this document is empty.\n"
                    },
                    "customZoneMappings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/GlobalClusterConfigCustomZoneMapping:GlobalClusterConfigCustomZoneMapping"
                        },
                        "description": "Each element in the list maps one ISO location code to a zone in your Global Cluster. See Custom Zone Mapping below for more details.\n"
                    },
                    "managedNamespaces": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/GlobalClusterConfigManagedNamespace:GlobalClusterConfigManagedNamespace"
                        },
                        "description": "Add a managed namespaces to a Global Cluster. For more information about managed namespaces, see [Global Clusters](https://docs.atlas.mongodb.com/reference/api/global-clusters/). See Managed Namespace below for more details.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the database user.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/ldapConfiguration:LdapConfiguration": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testProject = new mongodbatlas.Project(\"testProject\", {orgId: \"ORG ID\"});\nconst testLdapConfiguration = new mongodbatlas.LdapConfiguration(\"testLdapConfiguration\", {\n    projectId: testProject.id,\n    authenticationEnabled: true,\n    hostname: \"HOSTNAME\",\n    port: 636,\n    bindUsername: \"USERNAME\",\n    bindPassword: \"PASSWORD\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_project = mongodbatlas.Project(\"testProject\", org_id=\"ORG ID\")\ntest_ldap_configuration = mongodbatlas.LdapConfiguration(\"testLdapConfiguration\",\n    project_id=test_project.id,\n    authentication_enabled=True,\n    hostname=\"HOSTNAME\",\n    port=636,\n    bind_username=\"USERNAME\",\n    bind_password=\"PASSWORD\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testProject = new Mongodbatlas.Project(\"testProject\", new()\n    {\n        OrgId = \"ORG ID\",\n    });\n\n    var testLdapConfiguration = new Mongodbatlas.LdapConfiguration(\"testLdapConfiguration\", new()\n    {\n        ProjectId = testProject.Id,\n        AuthenticationEnabled = true,\n        Hostname = \"HOSTNAME\",\n        Port = 636,\n        BindUsername = \"USERNAME\",\n        BindPassword = \"PASSWORD\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestProject, err := mongodbatlas.NewProject(ctx, \"testProject\", \u0026mongodbatlas.ProjectArgs{\n\t\t\tOrgId: pulumi.String(\"ORG ID\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewLdapConfiguration(ctx, \"testLdapConfiguration\", \u0026mongodbatlas.LdapConfigurationArgs{\n\t\t\tProjectId:             testProject.ID(),\n\t\t\tAuthenticationEnabled: pulumi.Bool(true),\n\t\t\tHostname:              pulumi.String(\"HOSTNAME\"),\n\t\t\tPort:                  pulumi.Int(636),\n\t\t\tBindUsername:          pulumi.String(\"USERNAME\"),\n\t\t\tBindPassword:          pulumi.String(\"PASSWORD\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Project;\nimport com.pulumi.mongodbatlas.ProjectArgs;\nimport com.pulumi.mongodbatlas.LdapConfiguration;\nimport com.pulumi.mongodbatlas.LdapConfigurationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testProject = new Project(\"testProject\", ProjectArgs.builder()        \n            .orgId(\"ORG ID\")\n            .build());\n\n        var testLdapConfiguration = new LdapConfiguration(\"testLdapConfiguration\", LdapConfigurationArgs.builder()        \n            .projectId(testProject.id())\n            .authenticationEnabled(true)\n            .hostname(\"HOSTNAME\")\n            .port(636)\n            .bindUsername(\"USERNAME\")\n            .bindPassword(\"PASSWORD\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testProject:\n    type: mongodbatlas:Project\n    properties:\n      orgId: ORG ID\n  testLdapConfiguration:\n    type: mongodbatlas:LdapConfiguration\n    properties:\n      projectId: ${testProject.id}\n      authenticationEnabled: true\n      hostname: HOSTNAME\n      port: 636\n      bindUsername: USERNAME\n      bindPassword: PASSWORD\n```\n\n{{% /example %}}\n{{% example %}}\n### LDAP With User To DN Mapping\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testProject = new mongodbatlas.Project(\"testProject\", {orgId: \"ORG ID\"});\nconst testLdapConfiguration = new mongodbatlas.LdapConfiguration(\"testLdapConfiguration\", {\n    projectId: testProject.id,\n    authenticationEnabled: true,\n    hostname: \"HOSTNAME\",\n    port: 636,\n    bindUsername: \"USERNAME\",\n    bindPassword: \"PASSWORD\",\n    caCertificate: \"CA CERTIFICATE\",\n    authzQueryTemplate: \"{USER}?memberOf?base\",\n    userToDnMappings: [{\n        match: \"(.+)\",\n        ldapQuery: \"DC=example,DC=com??sub?(userPrincipalName={0})\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_project = mongodbatlas.Project(\"testProject\", org_id=\"ORG ID\")\ntest_ldap_configuration = mongodbatlas.LdapConfiguration(\"testLdapConfiguration\",\n    project_id=test_project.id,\n    authentication_enabled=True,\n    hostname=\"HOSTNAME\",\n    port=636,\n    bind_username=\"USERNAME\",\n    bind_password=\"PASSWORD\",\n    ca_certificate=\"CA CERTIFICATE\",\n    authz_query_template=\"{USER}?memberOf?base\",\n    user_to_dn_mappings=[mongodbatlas.LdapConfigurationUserToDnMappingArgs(\n        match=\"(.+)\",\n        ldap_query=\"DC=example,DC=com??sub?(userPrincipalName={0})\",\n    )])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testProject = new Mongodbatlas.Project(\"testProject\", new()\n    {\n        OrgId = \"ORG ID\",\n    });\n\n    var testLdapConfiguration = new Mongodbatlas.LdapConfiguration(\"testLdapConfiguration\", new()\n    {\n        ProjectId = testProject.Id,\n        AuthenticationEnabled = true,\n        Hostname = \"HOSTNAME\",\n        Port = 636,\n        BindUsername = \"USERNAME\",\n        BindPassword = \"PASSWORD\",\n        CaCertificate = \"CA CERTIFICATE\",\n        AuthzQueryTemplate = \"{USER}?memberOf?base\",\n        UserToDnMappings = new[]\n        {\n            new Mongodbatlas.Inputs.LdapConfigurationUserToDnMappingArgs\n            {\n                Match = \"(.+)\",\n                LdapQuery = \"DC=example,DC=com??sub?(userPrincipalName={0})\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestProject, err := mongodbatlas.NewProject(ctx, \"testProject\", \u0026mongodbatlas.ProjectArgs{\n\t\t\tOrgId: pulumi.String(\"ORG ID\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewLdapConfiguration(ctx, \"testLdapConfiguration\", \u0026mongodbatlas.LdapConfigurationArgs{\n\t\t\tProjectId:             testProject.ID(),\n\t\t\tAuthenticationEnabled: pulumi.Bool(true),\n\t\t\tHostname:              pulumi.String(\"HOSTNAME\"),\n\t\t\tPort:                  pulumi.Int(636),\n\t\t\tBindUsername:          pulumi.String(\"USERNAME\"),\n\t\t\tBindPassword:          pulumi.String(\"PASSWORD\"),\n\t\t\tCaCertificate:         pulumi.String(\"CA CERTIFICATE\"),\n\t\t\tAuthzQueryTemplate:    pulumi.String(\"{USER}?memberOf?base\"),\n\t\t\tUserToDnMappings: mongodbatlas.LdapConfigurationUserToDnMappingArray{\n\t\t\t\t\u0026mongodbatlas.LdapConfigurationUserToDnMappingArgs{\n\t\t\t\t\tMatch:     pulumi.String(\"(.+)\"),\n\t\t\t\t\tLdapQuery: pulumi.String(\"DC=example,DC=com??sub?(userPrincipalName={0})\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Project;\nimport com.pulumi.mongodbatlas.ProjectArgs;\nimport com.pulumi.mongodbatlas.LdapConfiguration;\nimport com.pulumi.mongodbatlas.LdapConfigurationArgs;\nimport com.pulumi.mongodbatlas.inputs.LdapConfigurationUserToDnMappingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testProject = new Project(\"testProject\", ProjectArgs.builder()        \n            .orgId(\"ORG ID\")\n            .build());\n\n        var testLdapConfiguration = new LdapConfiguration(\"testLdapConfiguration\", LdapConfigurationArgs.builder()        \n            .projectId(testProject.id())\n            .authenticationEnabled(true)\n            .hostname(\"HOSTNAME\")\n            .port(636)\n            .bindUsername(\"USERNAME\")\n            .bindPassword(\"PASSWORD\")\n            .caCertificate(\"CA CERTIFICATE\")\n            .authzQueryTemplate(\"{USER}?memberOf?base\")\n            .userToDnMappings(LdapConfigurationUserToDnMappingArgs.builder()\n                .match(\"(.+)\")\n                .ldapQuery(\"DC=example,DC=com??sub?(userPrincipalName={0})\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testProject:\n    type: mongodbatlas:Project\n    properties:\n      orgId: ORG ID\n  testLdapConfiguration:\n    type: mongodbatlas:LdapConfiguration\n    properties:\n      projectId: ${testProject.id}\n      authenticationEnabled: true\n      hostname: HOSTNAME\n      port: 636\n      bindUsername: USERNAME\n      bindPassword: PASSWORD\n      caCertificate: CA CERTIFICATE\n      authzQueryTemplate: '{USER}?memberOf?base'\n      userToDnMappings:\n        - match: (.+)\n          ldapQuery: DC=example,DC=com??sub?(userPrincipalName={0})\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nLDAP Configuration must be imported using project ID, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/ldapConfiguration:LdapConfiguration test 5d09d6a59ccf6445652a444a\n```\n\n For more information see[MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/ldaps-configuration-save) ",
            "properties": {
                "authenticationEnabled": {
                    "type": "boolean",
                    "description": "Specifies whether user authentication with LDAP is enabled.\n"
                },
                "authorizationEnabled": {
                    "type": "boolean",
                    "description": "Specifies whether user authorization with LDAP is enabled. You cannot enable user authorization with LDAP without first enabling user authentication with LDAP.\n"
                },
                "authzQueryTemplate": {
                    "type": "string",
                    "description": "An LDAP query template that Atlas executes to obtain the LDAP groups to which the authenticated user belongs. Used only for user authorization. Use the {USER} placeholder in the URL to substitute the authenticated username. The query is relative to the host specified with hostname. The formatting for the query must conform to RFC4515 and RFC 4516. If you do not provide a query template, Atlas attempts to use the default value: `{USER}?memberOf?base`.\n"
                },
                "bindPassword": {
                    "type": "string",
                    "description": "The password used to authenticate the `bind_username`.\n",
                    "secret": true
                },
                "bindUsername": {
                    "type": "string",
                    "description": "The user DN that Atlas uses to connect to the LDAP server. Must be the full DN, such as `CN=BindUser,CN=Users,DC=myldapserver,DC=mycompany,DC=com`.\n"
                },
                "caCertificate": {
                    "type": "string",
                    "description": "CA certificate used to verify the identify of the LDAP server. Self-signed certificates are allowed.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "The hostname or IP address of the LDAP server. The server must be visible to the internet or connected to your Atlas cluster with VPC Peering.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "The port to which the LDAP server listens for client connections. Default: `636`\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to configure LDAP.\n"
                },
                "userToDnMappings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/LdapConfigurationUserToDnMapping:LdapConfigurationUserToDnMapping"
                    },
                    "description": "Maps an LDAP username for authentication to an LDAP Distinguished Name (DN). Each document contains a `match` regular expression and either a `substitution` or `ldap_query` template used to transform the LDAP username extracted from the regular expression. Atlas steps through the each document in the array in the given order, checking the authentication username against the `match` filter. If a match is found, Atlas applies the transformation and uses the output to authenticate the user. Atlas does not check the remaining documents in the array. For more details and examples see the [MongoDB Atlas API Reference](https://docs.atlas.mongodb.com/reference/api/ldaps-configuration-save/).\n* `user_to_dn_mapping.0.match` - (Optional) A regular expression to match against a provided LDAP username. Each parenthesis-enclosed section represents a regular expression capture group used by the `substitution` or `ldap_query` template.\n* `user_to_dn_mapping.0.substitution` - (Optional) An LDAP Distinguished Name (DN) formatting template that converts the LDAP name matched by the `match` regular expression into an LDAP Distinguished Name. Each bracket-enclosed numeric value is replaced by the corresponding regular expression capture group extracted from the LDAP username that matched the `match` regular expression.\n* `user_to_dn_mapping.0.ldap_query` - (Optional) An LDAP query formatting template that inserts the LDAP name matched by the `match` regular expression into an LDAP query URI as specified by RFC 4515 and RFC 4516. Each numeric value is replaced by the corresponding regular expression capture group extracted from the LDAP username that matched the `match` regular expression.\n"
                }
            },
            "required": [
                "authenticationEnabled",
                "authorizationEnabled",
                "authzQueryTemplate",
                "bindPassword",
                "bindUsername",
                "caCertificate",
                "hostname",
                "projectId",
                "userToDnMappings"
            ],
            "inputProperties": {
                "authenticationEnabled": {
                    "type": "boolean",
                    "description": "Specifies whether user authentication with LDAP is enabled.\n"
                },
                "authorizationEnabled": {
                    "type": "boolean",
                    "description": "Specifies whether user authorization with LDAP is enabled. You cannot enable user authorization with LDAP without first enabling user authentication with LDAP.\n"
                },
                "authzQueryTemplate": {
                    "type": "string",
                    "description": "An LDAP query template that Atlas executes to obtain the LDAP groups to which the authenticated user belongs. Used only for user authorization. Use the {USER} placeholder in the URL to substitute the authenticated username. The query is relative to the host specified with hostname. The formatting for the query must conform to RFC4515 and RFC 4516. If you do not provide a query template, Atlas attempts to use the default value: `{USER}?memberOf?base`.\n"
                },
                "bindPassword": {
                    "type": "string",
                    "description": "The password used to authenticate the `bind_username`.\n",
                    "secret": true
                },
                "bindUsername": {
                    "type": "string",
                    "description": "The user DN that Atlas uses to connect to the LDAP server. Must be the full DN, such as `CN=BindUser,CN=Users,DC=myldapserver,DC=mycompany,DC=com`.\n"
                },
                "caCertificate": {
                    "type": "string",
                    "description": "CA certificate used to verify the identify of the LDAP server. Self-signed certificates are allowed.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "The hostname or IP address of the LDAP server. The server must be visible to the internet or connected to your Atlas cluster with VPC Peering.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "The port to which the LDAP server listens for client connections. Default: `636`\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to configure LDAP.\n"
                },
                "userToDnMappings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/LdapConfigurationUserToDnMapping:LdapConfigurationUserToDnMapping"
                    },
                    "description": "Maps an LDAP username for authentication to an LDAP Distinguished Name (DN). Each document contains a `match` regular expression and either a `substitution` or `ldap_query` template used to transform the LDAP username extracted from the regular expression. Atlas steps through the each document in the array in the given order, checking the authentication username against the `match` filter. If a match is found, Atlas applies the transformation and uses the output to authenticate the user. Atlas does not check the remaining documents in the array. For more details and examples see the [MongoDB Atlas API Reference](https://docs.atlas.mongodb.com/reference/api/ldaps-configuration-save/).\n* `user_to_dn_mapping.0.match` - (Optional) A regular expression to match against a provided LDAP username. Each parenthesis-enclosed section represents a regular expression capture group used by the `substitution` or `ldap_query` template.\n* `user_to_dn_mapping.0.substitution` - (Optional) An LDAP Distinguished Name (DN) formatting template that converts the LDAP name matched by the `match` regular expression into an LDAP Distinguished Name. Each bracket-enclosed numeric value is replaced by the corresponding regular expression capture group extracted from the LDAP username that matched the `match` regular expression.\n* `user_to_dn_mapping.0.ldap_query` - (Optional) An LDAP query formatting template that inserts the LDAP name matched by the `match` regular expression into an LDAP query URI as specified by RFC 4515 and RFC 4516. Each numeric value is replaced by the corresponding regular expression capture group extracted from the LDAP username that matched the `match` regular expression.\n"
                }
            },
            "requiredInputs": [
                "authenticationEnabled",
                "bindPassword",
                "bindUsername",
                "hostname",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LdapConfiguration resources.\n",
                "properties": {
                    "authenticationEnabled": {
                        "type": "boolean",
                        "description": "Specifies whether user authentication with LDAP is enabled.\n"
                    },
                    "authorizationEnabled": {
                        "type": "boolean",
                        "description": "Specifies whether user authorization with LDAP is enabled. You cannot enable user authorization with LDAP without first enabling user authentication with LDAP.\n"
                    },
                    "authzQueryTemplate": {
                        "type": "string",
                        "description": "An LDAP query template that Atlas executes to obtain the LDAP groups to which the authenticated user belongs. Used only for user authorization. Use the {USER} placeholder in the URL to substitute the authenticated username. The query is relative to the host specified with hostname. The formatting for the query must conform to RFC4515 and RFC 4516. If you do not provide a query template, Atlas attempts to use the default value: `{USER}?memberOf?base`.\n"
                    },
                    "bindPassword": {
                        "type": "string",
                        "description": "The password used to authenticate the `bind_username`.\n",
                        "secret": true
                    },
                    "bindUsername": {
                        "type": "string",
                        "description": "The user DN that Atlas uses to connect to the LDAP server. Must be the full DN, such as `CN=BindUser,CN=Users,DC=myldapserver,DC=mycompany,DC=com`.\n"
                    },
                    "caCertificate": {
                        "type": "string",
                        "description": "CA certificate used to verify the identify of the LDAP server. Self-signed certificates are allowed.\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "The hostname or IP address of the LDAP server. The server must be visible to the internet or connected to your Atlas cluster with VPC Peering.\n"
                    },
                    "port": {
                        "type": "integer",
                        "description": "The port to which the LDAP server listens for client connections. Default: `636`\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to configure LDAP.\n"
                    },
                    "userToDnMappings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/LdapConfigurationUserToDnMapping:LdapConfigurationUserToDnMapping"
                        },
                        "description": "Maps an LDAP username for authentication to an LDAP Distinguished Name (DN). Each document contains a `match` regular expression and either a `substitution` or `ldap_query` template used to transform the LDAP username extracted from the regular expression. Atlas steps through the each document in the array in the given order, checking the authentication username against the `match` filter. If a match is found, Atlas applies the transformation and uses the output to authenticate the user. Atlas does not check the remaining documents in the array. For more details and examples see the [MongoDB Atlas API Reference](https://docs.atlas.mongodb.com/reference/api/ldaps-configuration-save/).\n* `user_to_dn_mapping.0.match` - (Optional) A regular expression to match against a provided LDAP username. Each parenthesis-enclosed section represents a regular expression capture group used by the `substitution` or `ldap_query` template.\n* `user_to_dn_mapping.0.substitution` - (Optional) An LDAP Distinguished Name (DN) formatting template that converts the LDAP name matched by the `match` regular expression into an LDAP Distinguished Name. Each bracket-enclosed numeric value is replaced by the corresponding regular expression capture group extracted from the LDAP username that matched the `match` regular expression.\n* `user_to_dn_mapping.0.ldap_query` - (Optional) An LDAP query formatting template that inserts the LDAP name matched by the `match` regular expression into an LDAP query URI as specified by RFC 4515 and RFC 4516. Each numeric value is replaced by the corresponding regular expression capture group extracted from the LDAP username that matched the `match` regular expression.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/ldapVerify:LdapVerify": {
            "description": "`mongodbatlas.LdapVerify` provides an LDAP Verify resource. This allows a a verification of an LDAP configuration over TLS for an Atlas project. Atlas retains only the most recent request for each project.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testProject = new mongodbatlas.Project(\"testProject\", {orgId: \"ORG ID\"});\nconst testCluster = new mongodbatlas.Cluster(\"testCluster\", {\n    projectId: testProject.id,\n    diskSizeGb: 5,\n    providerName: \"AWS\",\n    providerRegionName: \"US_EAST_2\",\n    providerInstanceSizeName: \"M10\",\n    cloudBackup: true,\n});\n//enable cloud provider snapshots\nconst testLdapVerify = new mongodbatlas.LdapVerify(\"testLdapVerify\", {\n    projectId: testProject.id,\n    hostname: \"HOSTNAME\",\n    port: 636,\n    bindUsername: \"USERNAME\",\n    bindPassword: \"PASSWORD\",\n}, {\n    dependsOn: [testCluster],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_project = mongodbatlas.Project(\"testProject\", org_id=\"ORG ID\")\ntest_cluster = mongodbatlas.Cluster(\"testCluster\",\n    project_id=test_project.id,\n    disk_size_gb=5,\n    provider_name=\"AWS\",\n    provider_region_name=\"US_EAST_2\",\n    provider_instance_size_name=\"M10\",\n    cloud_backup=True)\n#enable cloud provider snapshots\ntest_ldap_verify = mongodbatlas.LdapVerify(\"testLdapVerify\",\n    project_id=test_project.id,\n    hostname=\"HOSTNAME\",\n    port=636,\n    bind_username=\"USERNAME\",\n    bind_password=\"PASSWORD\",\n    opts=pulumi.ResourceOptions(depends_on=[test_cluster]))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testProject = new Mongodbatlas.Project(\"testProject\", new()\n    {\n        OrgId = \"ORG ID\",\n    });\n\n    var testCluster = new Mongodbatlas.Cluster(\"testCluster\", new()\n    {\n        ProjectId = testProject.Id,\n        DiskSizeGb = 5,\n        ProviderName = \"AWS\",\n        ProviderRegionName = \"US_EAST_2\",\n        ProviderInstanceSizeName = \"M10\",\n        CloudBackup = true,\n    });\n\n    //enable cloud provider snapshots\n    var testLdapVerify = new Mongodbatlas.LdapVerify(\"testLdapVerify\", new()\n    {\n        ProjectId = testProject.Id,\n        Hostname = \"HOSTNAME\",\n        Port = 636,\n        BindUsername = \"USERNAME\",\n        BindPassword = \"PASSWORD\",\n    }, new CustomResourceOptions\n    {\n        DependsOn = new[]\n        {\n            testCluster,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestProject, err := mongodbatlas.NewProject(ctx, \"testProject\", \u0026mongodbatlas.ProjectArgs{\n\t\t\tOrgId: pulumi.String(\"ORG ID\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestCluster, err := mongodbatlas.NewCluster(ctx, \"testCluster\", \u0026mongodbatlas.ClusterArgs{\n\t\t\tProjectId:                testProject.ID(),\n\t\t\tDiskSizeGb:               pulumi.Float64(5),\n\t\t\tProviderName:             pulumi.String(\"AWS\"),\n\t\t\tProviderRegionName:       pulumi.String(\"US_EAST_2\"),\n\t\t\tProviderInstanceSizeName: pulumi.String(\"M10\"),\n\t\t\tCloudBackup:              pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewLdapVerify(ctx, \"testLdapVerify\", \u0026mongodbatlas.LdapVerifyArgs{\n\t\t\tProjectId:    testProject.ID(),\n\t\t\tHostname:     pulumi.String(\"HOSTNAME\"),\n\t\t\tPort:         pulumi.Int(636),\n\t\t\tBindUsername: pulumi.String(\"USERNAME\"),\n\t\t\tBindPassword: pulumi.String(\"PASSWORD\"),\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\ttestCluster,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Project;\nimport com.pulumi.mongodbatlas.ProjectArgs;\nimport com.pulumi.mongodbatlas.Cluster;\nimport com.pulumi.mongodbatlas.ClusterArgs;\nimport com.pulumi.mongodbatlas.LdapVerify;\nimport com.pulumi.mongodbatlas.LdapVerifyArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testProject = new Project(\"testProject\", ProjectArgs.builder()        \n            .orgId(\"ORG ID\")\n            .build());\n\n        var testCluster = new Cluster(\"testCluster\", ClusterArgs.builder()        \n            .projectId(testProject.id())\n            .diskSizeGb(5)\n            .providerName(\"AWS\")\n            .providerRegionName(\"US_EAST_2\")\n            .providerInstanceSizeName(\"M10\")\n            .cloudBackup(true)\n            .build());\n\n        var testLdapVerify = new LdapVerify(\"testLdapVerify\", LdapVerifyArgs.builder()        \n            .projectId(testProject.id())\n            .hostname(\"HOSTNAME\")\n            .port(636)\n            .bindUsername(\"USERNAME\")\n            .bindPassword(\"PASSWORD\")\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(testCluster)\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testProject:\n    type: mongodbatlas:Project\n    properties:\n      orgId: ORG ID\n  testCluster:\n    type: mongodbatlas:Cluster\n    properties:\n      projectId: ${testProject.id}\n      diskSizeGb: 5\n      # Provider Settings \"block\"\n      providerName: AWS\n      providerRegionName: US_EAST_2\n      providerInstanceSizeName: M10\n      cloudBackup: true\n  testLdapVerify:\n    type: mongodbatlas:LdapVerify\n    properties:\n      projectId: ${testProject.id}\n      hostname: HOSTNAME\n      port: 636\n      bindUsername: USERNAME\n      bindPassword: PASSWORD\n    options:\n      dependson:\n        - ${testCluster}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nLDAP Configuration must be imported using project ID and request ID, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/ldapVerify:LdapVerify test 5d09d6a59ccf6445652a444a-5d09d6a59ccf6445652a444a\n```\n\n For more information see[MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/ldaps-configuration-request-verification) ",
            "properties": {
                "authzQueryTemplate": {
                    "type": "string",
                    "description": "An LDAP query template that Atlas executes to obtain the LDAP groups to which the authenticated user belongs. Used only for user authorization. Use the {USER} placeholder in the URL to substitute the authenticated username. The query is relative to the host specified with hostname. The formatting for the query must conform to RFC4515 and RFC 4516. If you do not provide a query template, Atlas attempts to use the default value: `{USER}?memberOf?base`.\n"
                },
                "bindPassword": {
                    "type": "string",
                    "description": "The password used to authenticate the `bind_username`.\n"
                },
                "bindUsername": {
                    "type": "string",
                    "description": "The user DN that Atlas uses to connect to the LDAP server. Must be the full DN, such as `CN=BindUser,CN=Users,DC=myldapserver,DC=mycompany,DC=com`.\n"
                },
                "caCertificate": {
                    "type": "string",
                    "description": "CA certificate used to verify the identify of the LDAP server. Self-signed certificates are allowed.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "The hostname or IP address of the LDAP server. The server must be visible to the internet or connected to your Atlas cluster with VPC Peering.\n"
                },
                "links": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/LdapVerifyLink:LdapVerifyLink"
                    },
                    "description": "One or more links to sub-resources. The relations in the URLs are explained in the Web Linking Specification.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "The port to which the LDAP server listens for client connections. Default: `636`\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to configure LDAP.\n"
                },
                "requestId": {
                    "type": "string",
                    "description": "The unique identifier for the request to verify the LDAP over TLS/SSL configuration.\n"
                },
                "status": {
                    "type": "string",
                    "description": "The current status of the LDAP over TLS/SSL configuration. One of the following values: `PENDING`, `SUCCESS`, and `FAILED`.\n"
                },
                "validations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/LdapVerifyValidation:LdapVerifyValidation"
                    },
                    "description": "Array of validation messages related to the verification of the provided LDAP over TLS/SSL configuration details. The array contains a document for each test that Atlas runs. Atlas stops running tests after the first failure. The following return values can be seen here: [Values](https://docs.atlas.mongodb.com/reference/api/ldaps-configuration-request-verification)\n"
                }
            },
            "required": [
                "authzQueryTemplate",
                "bindPassword",
                "bindUsername",
                "caCertificate",
                "hostname",
                "links",
                "port",
                "projectId",
                "requestId",
                "status",
                "validations"
            ],
            "inputProperties": {
                "authzQueryTemplate": {
                    "type": "string",
                    "description": "An LDAP query template that Atlas executes to obtain the LDAP groups to which the authenticated user belongs. Used only for user authorization. Use the {USER} placeholder in the URL to substitute the authenticated username. The query is relative to the host specified with hostname. The formatting for the query must conform to RFC4515 and RFC 4516. If you do not provide a query template, Atlas attempts to use the default value: `{USER}?memberOf?base`.\n",
                    "willReplaceOnChanges": true
                },
                "bindPassword": {
                    "type": "string",
                    "description": "The password used to authenticate the `bind_username`.\n",
                    "willReplaceOnChanges": true
                },
                "bindUsername": {
                    "type": "string",
                    "description": "The user DN that Atlas uses to connect to the LDAP server. Must be the full DN, such as `CN=BindUser,CN=Users,DC=myldapserver,DC=mycompany,DC=com`.\n",
                    "willReplaceOnChanges": true
                },
                "caCertificate": {
                    "type": "string",
                    "description": "CA certificate used to verify the identify of the LDAP server. Self-signed certificates are allowed.\n",
                    "willReplaceOnChanges": true
                },
                "hostname": {
                    "type": "string",
                    "description": "The hostname or IP address of the LDAP server. The server must be visible to the internet or connected to your Atlas cluster with VPC Peering.\n",
                    "willReplaceOnChanges": true
                },
                "port": {
                    "type": "integer",
                    "description": "The port to which the LDAP server listens for client connections. Default: `636`\n",
                    "willReplaceOnChanges": true
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to configure LDAP.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "bindPassword",
                "bindUsername",
                "hostname",
                "port",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LdapVerify resources.\n",
                "properties": {
                    "authzQueryTemplate": {
                        "type": "string",
                        "description": "An LDAP query template that Atlas executes to obtain the LDAP groups to which the authenticated user belongs. Used only for user authorization. Use the {USER} placeholder in the URL to substitute the authenticated username. The query is relative to the host specified with hostname. The formatting for the query must conform to RFC4515 and RFC 4516. If you do not provide a query template, Atlas attempts to use the default value: `{USER}?memberOf?base`.\n",
                        "willReplaceOnChanges": true
                    },
                    "bindPassword": {
                        "type": "string",
                        "description": "The password used to authenticate the `bind_username`.\n",
                        "willReplaceOnChanges": true
                    },
                    "bindUsername": {
                        "type": "string",
                        "description": "The user DN that Atlas uses to connect to the LDAP server. Must be the full DN, such as `CN=BindUser,CN=Users,DC=myldapserver,DC=mycompany,DC=com`.\n",
                        "willReplaceOnChanges": true
                    },
                    "caCertificate": {
                        "type": "string",
                        "description": "CA certificate used to verify the identify of the LDAP server. Self-signed certificates are allowed.\n",
                        "willReplaceOnChanges": true
                    },
                    "hostname": {
                        "type": "string",
                        "description": "The hostname or IP address of the LDAP server. The server must be visible to the internet or connected to your Atlas cluster with VPC Peering.\n",
                        "willReplaceOnChanges": true
                    },
                    "links": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/LdapVerifyLink:LdapVerifyLink"
                        },
                        "description": "One or more links to sub-resources. The relations in the URLs are explained in the Web Linking Specification.\n"
                    },
                    "port": {
                        "type": "integer",
                        "description": "The port to which the LDAP server listens for client connections. Default: `636`\n",
                        "willReplaceOnChanges": true
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to configure LDAP.\n",
                        "willReplaceOnChanges": true
                    },
                    "requestId": {
                        "type": "string",
                        "description": "The unique identifier for the request to verify the LDAP over TLS/SSL configuration.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "The current status of the LDAP over TLS/SSL configuration. One of the following values: `PENDING`, `SUCCESS`, and `FAILED`.\n"
                    },
                    "validations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/LdapVerifyValidation:LdapVerifyValidation"
                        },
                        "description": "Array of validation messages related to the verification of the provided LDAP over TLS/SSL configuration details. The array contains a document for each test that Atlas runs. Atlas stops running tests after the first failure. The following return values can be seen here: [Values](https://docs.atlas.mongodb.com/reference/api/ldaps-configuration-request-verification)\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/maintenanceWindow:MaintenanceWindow": {
            "description": "`mongodbatlas.MaintenanceWindow` provides a resource to schedule a maintenance window for your MongoDB Atlas Project and/or set to defer a scheduled maintenance up to two times.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n## Maintenance Window Considerations:\n\n- Urgent Maintenance Activities Cannot Wait: Urgent maintenance activities such as security patches cannot wait for your chosen window. Atlas will start those maintenance activities when needed.\n\nOnce maintenance is scheduled for your cluster, you cannot change your maintenance window until the current maintenance efforts have completed.\n- Maintenance Requires Replica Set Elections: Atlas performs maintenance the same way as the manual maintenance procedure. This requires at least one replica set election during the maintenance window per replica set.\n- Maintenance Starts As Close to the Hour As Possible: Maintenance always begins as close to the scheduled hour as possible, but in-progress cluster updates or expected system issues could delay the start time.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.MaintenanceWindow(\"test\", {\n    dayOfWeek: 3,\n    hourOfDay: 4,\n    projectId: \"\u003cyour-project-id\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.MaintenanceWindow(\"test\",\n    day_of_week=3,\n    hour_of_day=4,\n    project_id=\"\u003cyour-project-id\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.MaintenanceWindow(\"test\", new()\n    {\n        DayOfWeek = 3,\n        HourOfDay = 4,\n        ProjectId = \"\u003cyour-project-id\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewMaintenanceWindow(ctx, \"test\", \u0026mongodbatlas.MaintenanceWindowArgs{\n\t\t\tDayOfWeek: pulumi.Int(3),\n\t\t\tHourOfDay: pulumi.Int(4),\n\t\t\tProjectId: pulumi.String(\"\u003cyour-project-id\u003e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MaintenanceWindow;\nimport com.pulumi.mongodbatlas.MaintenanceWindowArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new MaintenanceWindow(\"test\", MaintenanceWindowArgs.builder()        \n            .dayOfWeek(3)\n            .hourOfDay(4)\n            .projectId(\"\u003cyour-project-id\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:MaintenanceWindow\n    properties:\n      dayOfWeek: 3\n      hourOfDay: 4\n      projectId: \u003cyour-project-id\u003e\n```\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.MaintenanceWindow(\"test\", {\n    defer: true,\n    projectId: \"\u003cyour-project-id\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.MaintenanceWindow(\"test\",\n    defer=True,\n    project_id=\"\u003cyour-project-id\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.MaintenanceWindow(\"test\", new()\n    {\n        Defer = true,\n        ProjectId = \"\u003cyour-project-id\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewMaintenanceWindow(ctx, \"test\", \u0026mongodbatlas.MaintenanceWindowArgs{\n\t\t\tDefer:     pulumi.Bool(true),\n\t\t\tProjectId: pulumi.String(\"\u003cyour-project-id\u003e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MaintenanceWindow;\nimport com.pulumi.mongodbatlas.MaintenanceWindowArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new MaintenanceWindow(\"test\", MaintenanceWindowArgs.builder()        \n            .defer(true)\n            .projectId(\"\u003cyour-project-id\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:MaintenanceWindow\n    properties:\n      defer: true\n      projectId: \u003cyour-project-id\u003e\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nMaintenance Window entries can be imported using project project_id, in the format `PROJECTID`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/maintenanceWindow:MaintenanceWindow test 5d0f1f73cf09a29120e173cf\n```\n\n For more information see[MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/maintenance-windows/) ",
            "properties": {
                "autoDefer": {
                    "type": "boolean",
                    "description": "Defer any scheduled maintenance for the given project for one week.\n"
                },
                "autoDeferOnceEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether you want to defer all maintenance windows one week they would be triggered.\n"
                },
                "dayOfWeek": {
                    "type": "integer",
                    "description": "Day of the week when you would like the maintenance window to start as a 1-based integer: S=1, M=2, T=3, W=4, T=5, F=6, S=7.\n"
                },
                "defer": {
                    "type": "boolean",
                    "description": "Defer the next scheduled maintenance for the given project for one week.\n"
                },
                "hourOfDay": {
                    "type": "integer",
                    "description": "Hour of the day when you would like the maintenance window to start. This parameter uses the 24-hour clock, where midnight is 0, noon is 12 (Time zone is UTC).\n"
                },
                "numberOfDeferrals": {
                    "type": "integer",
                    "description": "Number of times the current maintenance event for this project has been deferred, you can set a maximum of 2 deferrals.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier of the project for the Maintenance Window.\n"
                },
                "startAsap": {
                    "type": "boolean",
                    "description": "Flag indicating whether project maintenance has been directed to start immediately. If you request that maintenance begin immediately, this field returns true from the time the request was made until the time the maintenance event completes.\n"
                }
            },
            "required": [
                "autoDefer",
                "autoDeferOnceEnabled",
                "dayOfWeek",
                "defer",
                "hourOfDay",
                "numberOfDeferrals",
                "projectId",
                "startAsap"
            ],
            "inputProperties": {
                "autoDefer": {
                    "type": "boolean",
                    "description": "Defer any scheduled maintenance for the given project for one week.\n"
                },
                "autoDeferOnceEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether you want to defer all maintenance windows one week they would be triggered.\n"
                },
                "dayOfWeek": {
                    "type": "integer",
                    "description": "Day of the week when you would like the maintenance window to start as a 1-based integer: S=1, M=2, T=3, W=4, T=5, F=6, S=7.\n"
                },
                "defer": {
                    "type": "boolean",
                    "description": "Defer the next scheduled maintenance for the given project for one week.\n"
                },
                "hourOfDay": {
                    "type": "integer",
                    "description": "Hour of the day when you would like the maintenance window to start. This parameter uses the 24-hour clock, where midnight is 0, noon is 12 (Time zone is UTC).\n"
                },
                "numberOfDeferrals": {
                    "type": "integer",
                    "description": "Number of times the current maintenance event for this project has been deferred, you can set a maximum of 2 deferrals.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier of the project for the Maintenance Window.\n"
                }
            },
            "requiredInputs": [
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MaintenanceWindow resources.\n",
                "properties": {
                    "autoDefer": {
                        "type": "boolean",
                        "description": "Defer any scheduled maintenance for the given project for one week.\n"
                    },
                    "autoDeferOnceEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether you want to defer all maintenance windows one week they would be triggered.\n"
                    },
                    "dayOfWeek": {
                        "type": "integer",
                        "description": "Day of the week when you would like the maintenance window to start as a 1-based integer: S=1, M=2, T=3, W=4, T=5, F=6, S=7.\n"
                    },
                    "defer": {
                        "type": "boolean",
                        "description": "Defer the next scheduled maintenance for the given project for one week.\n"
                    },
                    "hourOfDay": {
                        "type": "integer",
                        "description": "Hour of the day when you would like the maintenance window to start. This parameter uses the 24-hour clock, where midnight is 0, noon is 12 (Time zone is UTC).\n"
                    },
                    "numberOfDeferrals": {
                        "type": "integer",
                        "description": "Number of times the current maintenance event for this project has been deferred, you can set a maximum of 2 deferrals.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Maintenance Window.\n"
                    },
                    "startAsap": {
                        "type": "boolean",
                        "description": "Flag indicating whether project maintenance has been directed to start immediately. If you request that maintenance begin immediately, this field returns true from the time the request was made until the time the maintenance event completes.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/networkContainer:NetworkContainer": {
            "description": "`mongodbatlas.NetworkContainer` provides a Network Peering Container resource. The resource lets you create, edit and delete network peering containers. The resource requires your Project ID.  Each cloud provider requires slightly different attributes so read the argument reference carefully.\n\n Network peering container is a general term used to describe any cloud providers' VPC/VNet concept.  Containers only need to be created if the peering connection to the cloud provider will be created before the first cluster that requires the container.  If the cluster has been/will be created first Atlas automatically creates the required container per the \"containers per cloud provider\" information that follows (in this case you can obtain the container id from the cluster resource attribute `container_id`).\n\nThe following is the maximum number of Network Peering containers per cloud provider:\n\u003cbr\u003e \u0026#8226;  GCP -  One container per project.\n\u003cbr\u003e \u0026#8226;  AWS and Azure - One container per cloud provider region.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find **group_id** in the official documentation.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Example with AWS\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.NetworkContainer(\"test\", {\n    atlasCidrBlock: \"10.8.0.0/21\",\n    projectId: \"\u003cYOUR-PROJECT-ID\u003e\",\n    providerName: \"AWS\",\n    regionName: \"US_EAST_1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.NetworkContainer(\"test\",\n    atlas_cidr_block=\"10.8.0.0/21\",\n    project_id=\"\u003cYOUR-PROJECT-ID\u003e\",\n    provider_name=\"AWS\",\n    region_name=\"US_EAST_1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.NetworkContainer(\"test\", new()\n    {\n        AtlasCidrBlock = \"10.8.0.0/21\",\n        ProjectId = \"\u003cYOUR-PROJECT-ID\u003e\",\n        ProviderName = \"AWS\",\n        RegionName = \"US_EAST_1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewNetworkContainer(ctx, \"test\", \u0026mongodbatlas.NetworkContainerArgs{\n\t\t\tAtlasCidrBlock: pulumi.String(\"10.8.0.0/21\"),\n\t\t\tProjectId:      pulumi.String(\"\u003cYOUR-PROJECT-ID\u003e\"),\n\t\t\tProviderName:   pulumi.String(\"AWS\"),\n\t\t\tRegionName:     pulumi.String(\"US_EAST_1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.NetworkContainer;\nimport com.pulumi.mongodbatlas.NetworkContainerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new NetworkContainer(\"test\", NetworkContainerArgs.builder()        \n            .atlasCidrBlock(\"10.8.0.0/21\")\n            .projectId(\"\u003cYOUR-PROJECT-ID\u003e\")\n            .providerName(\"AWS\")\n            .regionName(\"US_EAST_1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:NetworkContainer\n    properties:\n      atlasCidrBlock: 10.8.0.0/21\n      projectId: \u003cYOUR-PROJECT-ID\u003e\n      providerName: AWS\n      regionName: US_EAST_1\n```\n{{% /example %}}\n{{% example %}}\n### Example with GCP\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.NetworkContainer(\"test\", {\n    atlasCidrBlock: \"10.8.0.0/21\",\n    projectId: \"\u003cYOUR-PROJECT-ID\u003e\",\n    providerName: \"GCP\",\n    regions: [\n        \"US_EAST_4\",\n        \"US_WEST_3\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.NetworkContainer(\"test\",\n    atlas_cidr_block=\"10.8.0.0/21\",\n    project_id=\"\u003cYOUR-PROJECT-ID\u003e\",\n    provider_name=\"GCP\",\n    regions=[\n        \"US_EAST_4\",\n        \"US_WEST_3\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.NetworkContainer(\"test\", new()\n    {\n        AtlasCidrBlock = \"10.8.0.0/21\",\n        ProjectId = \"\u003cYOUR-PROJECT-ID\u003e\",\n        ProviderName = \"GCP\",\n        Regions = new[]\n        {\n            \"US_EAST_4\",\n            \"US_WEST_3\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewNetworkContainer(ctx, \"test\", \u0026mongodbatlas.NetworkContainerArgs{\n\t\t\tAtlasCidrBlock: pulumi.String(\"10.8.0.0/21\"),\n\t\t\tProjectId:      pulumi.String(\"\u003cYOUR-PROJECT-ID\u003e\"),\n\t\t\tProviderName:   pulumi.String(\"GCP\"),\n\t\t\tRegions: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"US_EAST_4\"),\n\t\t\t\tpulumi.String(\"US_WEST_3\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.NetworkContainer;\nimport com.pulumi.mongodbatlas.NetworkContainerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new NetworkContainer(\"test\", NetworkContainerArgs.builder()        \n            .atlasCidrBlock(\"10.8.0.0/21\")\n            .projectId(\"\u003cYOUR-PROJECT-ID\u003e\")\n            .providerName(\"GCP\")\n            .regions(            \n                \"US_EAST_4\",\n                \"US_WEST_3\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:NetworkContainer\n    properties:\n      atlasCidrBlock: 10.8.0.0/21\n      projectId: \u003cYOUR-PROJECT-ID\u003e\n      providerName: GCP\n      regions:\n        - US_EAST_4\n        - US_WEST_3\n```\n{{% /example %}}\n{{% example %}}\n### Example with Azure\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.NetworkContainer(\"test\", {\n    atlasCidrBlock: \"10.8.0.0/21\",\n    projectId: \"\u003cYOUR-PROJECT-ID\u003e\",\n    providerName: \"AZURE\",\n    region: \"US_EAST_2\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.NetworkContainer(\"test\",\n    atlas_cidr_block=\"10.8.0.0/21\",\n    project_id=\"\u003cYOUR-PROJECT-ID\u003e\",\n    provider_name=\"AZURE\",\n    region=\"US_EAST_2\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.NetworkContainer(\"test\", new()\n    {\n        AtlasCidrBlock = \"10.8.0.0/21\",\n        ProjectId = \"\u003cYOUR-PROJECT-ID\u003e\",\n        ProviderName = \"AZURE\",\n        Region = \"US_EAST_2\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewNetworkContainer(ctx, \"test\", \u0026mongodbatlas.NetworkContainerArgs{\n\t\t\tAtlasCidrBlock: pulumi.String(\"10.8.0.0/21\"),\n\t\t\tProjectId:      pulumi.String(\"\u003cYOUR-PROJECT-ID\u003e\"),\n\t\t\tProviderName:   pulumi.String(\"AZURE\"),\n\t\t\tRegion:         pulumi.String(\"US_EAST_2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.NetworkContainer;\nimport com.pulumi.mongodbatlas.NetworkContainerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new NetworkContainer(\"test\", NetworkContainerArgs.builder()        \n            .atlasCidrBlock(\"10.8.0.0/21\")\n            .projectId(\"\u003cYOUR-PROJECT-ID\u003e\")\n            .providerName(\"AZURE\")\n            .region(\"US_EAST_2\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:NetworkContainer\n    properties:\n      atlasCidrBlock: 10.8.0.0/21\n      projectId: \u003cYOUR-PROJECT-ID\u003e\n      providerName: AZURE\n      region: US_EAST_2\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nClusters can be imported using project ID and network peering container id, in the format `PROJECTID-CONTAINER-ID`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/networkContainer:NetworkContainer my_container 1112222b3bf99403840e8934-5cbf563d87d9d67253be590a\n```\n\n See detailed information for arguments and attributes[MongoDB API Network Peering Container](https://docs.atlas.mongodb.com/reference/api/vpc-create-container/) ",
            "properties": {
                "atlasCidrBlock": {
                    "type": "string",
                    "description": "CIDR block that Atlas uses for the Network Peering containers in your project.  Atlas uses the specified CIDR block for all other Network Peering connections created in the project. The Atlas CIDR block must be at least a /24 and at most a /21 in one of the following [private networks](https://tools.ietf.org/html/rfc1918.html#section-3):\n* Lower bound: 10.0.0.0 -\tUpper bound: 10.255.255.255 -\tPrefix: 10/8\n* Lower bound: 172.16.0.0 -\tUpper bound:172.31.255.255 -\tPrefix:\t172.16/12\n* Lower bound: 192.168.0.0 -\tUpper bound:192.168.255.255 -\tPrefix:\t192.168/16\n"
                },
                "azureSubscriptionId": {
                    "type": "string",
                    "description": "Unique identifier of the Azure subscription in which the VNet resides.\n"
                },
                "containerId": {
                    "type": "string",
                    "description": "The Network Peering Container ID.\n"
                },
                "gcpProjectId": {
                    "type": "string",
                    "description": "Unique identifier of the GCP project in which the network peer resides. Returns null. This value is populated once you create a new network peering connection with the network peering resource.\n"
                },
                "networkName": {
                    "type": "string",
                    "description": "Unique identifier of the Network Peering connection in the Atlas project. Returns null. This value is populated once you create a new network peering connection with the network peering resource.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique identifier for the Atlas project for this Network Peering Container.\n"
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud provider for this Network Peering connection.  Accepted values are GCP, AWS, AZURE. If omitted, Atlas sets this parameter to AWS.\n"
                },
                "provisioned": {
                    "type": "boolean",
                    "description": "Indicates whether the project has Network Peering connections deployed in the container.\n"
                },
                "region": {
                    "type": "string",
                    "description": "Atlas region where the container resides, see the reference list for Atlas Azure region names [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).\n"
                },
                "regionName": {
                    "type": "string",
                    "description": "The Atlas AWS region name for where this container will exist, see the reference list for Atlas AWS region names [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/).\n"
                },
                "regions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Atlas regions where the container resides. Provide this field only if you provide an `atlas_cidr_block` smaller than `/18`. [GCP Regions values](https://docs.atlas.mongodb.com/reference/api/vpc-create-container/#request-body-parameters).\n"
                },
                "vnetName": {
                    "type": "string",
                    "description": "The name of the Azure VNet. Returns null. This value is populated once you create a new network peering connection with the network peering resource.\n"
                },
                "vpcId": {
                    "type": "string",
                    "description": "Unique identifier of Atlas' AWS VPC.\n"
                }
            },
            "required": [
                "atlasCidrBlock",
                "azureSubscriptionId",
                "containerId",
                "gcpProjectId",
                "networkName",
                "projectId",
                "provisioned",
                "region",
                "regionName",
                "vnetName",
                "vpcId"
            ],
            "inputProperties": {
                "atlasCidrBlock": {
                    "type": "string",
                    "description": "CIDR block that Atlas uses for the Network Peering containers in your project.  Atlas uses the specified CIDR block for all other Network Peering connections created in the project. The Atlas CIDR block must be at least a /24 and at most a /21 in one of the following [private networks](https://tools.ietf.org/html/rfc1918.html#section-3):\n* Lower bound: 10.0.0.0 -\tUpper bound: 10.255.255.255 -\tPrefix: 10/8\n* Lower bound: 172.16.0.0 -\tUpper bound:172.31.255.255 -\tPrefix:\t172.16/12\n* Lower bound: 192.168.0.0 -\tUpper bound:192.168.255.255 -\tPrefix:\t192.168/16\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique identifier for the Atlas project for this Network Peering Container.\n",
                    "willReplaceOnChanges": true
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud provider for this Network Peering connection.  Accepted values are GCP, AWS, AZURE. If omitted, Atlas sets this parameter to AWS.\n"
                },
                "region": {
                    "type": "string",
                    "description": "Atlas region where the container resides, see the reference list for Atlas Azure region names [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).\n"
                },
                "regionName": {
                    "type": "string",
                    "description": "The Atlas AWS region name for where this container will exist, see the reference list for Atlas AWS region names [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/).\n"
                },
                "regions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Atlas regions where the container resides. Provide this field only if you provide an `atlas_cidr_block` smaller than `/18`. [GCP Regions values](https://docs.atlas.mongodb.com/reference/api/vpc-create-container/#request-body-parameters).\n"
                }
            },
            "requiredInputs": [
                "atlasCidrBlock",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NetworkContainer resources.\n",
                "properties": {
                    "atlasCidrBlock": {
                        "type": "string",
                        "description": "CIDR block that Atlas uses for the Network Peering containers in your project.  Atlas uses the specified CIDR block for all other Network Peering connections created in the project. The Atlas CIDR block must be at least a /24 and at most a /21 in one of the following [private networks](https://tools.ietf.org/html/rfc1918.html#section-3):\n* Lower bound: 10.0.0.0 -\tUpper bound: 10.255.255.255 -\tPrefix: 10/8\n* Lower bound: 172.16.0.0 -\tUpper bound:172.31.255.255 -\tPrefix:\t172.16/12\n* Lower bound: 192.168.0.0 -\tUpper bound:192.168.255.255 -\tPrefix:\t192.168/16\n"
                    },
                    "azureSubscriptionId": {
                        "type": "string",
                        "description": "Unique identifier of the Azure subscription in which the VNet resides.\n"
                    },
                    "containerId": {
                        "type": "string",
                        "description": "The Network Peering Container ID.\n"
                    },
                    "gcpProjectId": {
                        "type": "string",
                        "description": "Unique identifier of the GCP project in which the network peer resides. Returns null. This value is populated once you create a new network peering connection with the network peering resource.\n"
                    },
                    "networkName": {
                        "type": "string",
                        "description": "Unique identifier of the Network Peering connection in the Atlas project. Returns null. This value is populated once you create a new network peering connection with the network peering resource.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique identifier for the Atlas project for this Network Peering Container.\n",
                        "willReplaceOnChanges": true
                    },
                    "providerName": {
                        "type": "string",
                        "description": "Cloud provider for this Network Peering connection.  Accepted values are GCP, AWS, AZURE. If omitted, Atlas sets this parameter to AWS.\n"
                    },
                    "provisioned": {
                        "type": "boolean",
                        "description": "Indicates whether the project has Network Peering connections deployed in the container.\n"
                    },
                    "region": {
                        "type": "string",
                        "description": "Atlas region where the container resides, see the reference list for Atlas Azure region names [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).\n"
                    },
                    "regionName": {
                        "type": "string",
                        "description": "The Atlas AWS region name for where this container will exist, see the reference list for Atlas AWS region names [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/).\n"
                    },
                    "regions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Atlas regions where the container resides. Provide this field only if you provide an `atlas_cidr_block` smaller than `/18`. [GCP Regions values](https://docs.atlas.mongodb.com/reference/api/vpc-create-container/#request-body-parameters).\n"
                    },
                    "vnetName": {
                        "type": "string",
                        "description": "The name of the Azure VNet. Returns null. This value is populated once you create a new network peering connection with the network peering resource.\n"
                    },
                    "vpcId": {
                        "type": "string",
                        "description": "Unique identifier of Atlas' AWS VPC.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/networkPeering:NetworkPeering": {
            "description": "{{% examples %}}\n## Example Usage\n\n### Container \u0026 Peering Connection\n{{% example %}}\n### Example with AWS\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\n// Container example provided but not always required, \n// see network_container documentation for details. \nconst testNetworkContainer = new mongodbatlas.NetworkContainer(\"testNetworkContainer\", {\n    projectId: local.project_id,\n    atlasCidrBlock: \"10.8.0.0/21\",\n    providerName: \"AWS\",\n    regionName: \"US_EAST_1\",\n});\n// Create the peering connection request\nconst testNetworkPeering = new mongodbatlas.NetworkPeering(\"testNetworkPeering\", {\n    accepterRegionName: \"us-east-1\",\n    projectId: local.project_id,\n    containerId: \"507f1f77bcf86cd799439011\",\n    providerName: \"AWS\",\n    routeTableCidrBlock: \"192.168.0.0/24\",\n    vpcId: \"vpc-abc123abc123\",\n    awsAccountId: \"abc123abc123\",\n});\n// the following assumes an AWS provider is configured\n// Accept the peering connection request\nconst peer = new aws.ec2.VpcPeeringConnectionAccepter(\"peer\", {\n    vpcPeeringConnectionId: testNetworkPeering.connectionId,\n    autoAccept: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\nimport pulumi_mongodbatlas as mongodbatlas\n\n# Container example provided but not always required, \n# see network_container documentation for details. \ntest_network_container = mongodbatlas.NetworkContainer(\"testNetworkContainer\",\n    project_id=local[\"project_id\"],\n    atlas_cidr_block=\"10.8.0.0/21\",\n    provider_name=\"AWS\",\n    region_name=\"US_EAST_1\")\n# Create the peering connection request\ntest_network_peering = mongodbatlas.NetworkPeering(\"testNetworkPeering\",\n    accepter_region_name=\"us-east-1\",\n    project_id=local[\"project_id\"],\n    container_id=\"507f1f77bcf86cd799439011\",\n    provider_name=\"AWS\",\n    route_table_cidr_block=\"192.168.0.0/24\",\n    vpc_id=\"vpc-abc123abc123\",\n    aws_account_id=\"abc123abc123\")\n# the following assumes an AWS provider is configured\n# Accept the peering connection request\npeer = aws.ec2.VpcPeeringConnectionAccepter(\"peer\",\n    vpc_peering_connection_id=test_network_peering.connection_id,\n    auto_accept=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Container example provided but not always required, \n    // see network_container documentation for details. \n    var testNetworkContainer = new Mongodbatlas.NetworkContainer(\"testNetworkContainer\", new()\n    {\n        ProjectId = local.Project_id,\n        AtlasCidrBlock = \"10.8.0.0/21\",\n        ProviderName = \"AWS\",\n        RegionName = \"US_EAST_1\",\n    });\n\n    // Create the peering connection request\n    var testNetworkPeering = new Mongodbatlas.NetworkPeering(\"testNetworkPeering\", new()\n    {\n        AccepterRegionName = \"us-east-1\",\n        ProjectId = local.Project_id,\n        ContainerId = \"507f1f77bcf86cd799439011\",\n        ProviderName = \"AWS\",\n        RouteTableCidrBlock = \"192.168.0.0/24\",\n        VpcId = \"vpc-abc123abc123\",\n        AwsAccountId = \"abc123abc123\",\n    });\n\n    // the following assumes an AWS provider is configured\n    // Accept the peering connection request\n    var peer = new Aws.Ec2.VpcPeeringConnectionAccepter(\"peer\", new()\n    {\n        VpcPeeringConnectionId = testNetworkPeering.ConnectionId,\n        AutoAccept = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/ec2\"\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewNetworkContainer(ctx, \"testNetworkContainer\", \u0026mongodbatlas.NetworkContainerArgs{\n\t\t\tProjectId:      pulumi.Any(local.Project_id),\n\t\t\tAtlasCidrBlock: pulumi.String(\"10.8.0.0/21\"),\n\t\t\tProviderName:   pulumi.String(\"AWS\"),\n\t\t\tRegionName:     pulumi.String(\"US_EAST_1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestNetworkPeering, err := mongodbatlas.NewNetworkPeering(ctx, \"testNetworkPeering\", \u0026mongodbatlas.NetworkPeeringArgs{\n\t\t\tAccepterRegionName:  pulumi.String(\"us-east-1\"),\n\t\t\tProjectId:           pulumi.Any(local.Project_id),\n\t\t\tContainerId:         pulumi.String(\"507f1f77bcf86cd799439011\"),\n\t\t\tProviderName:        pulumi.String(\"AWS\"),\n\t\t\tRouteTableCidrBlock: pulumi.String(\"192.168.0.0/24\"),\n\t\t\tVpcId:               pulumi.String(\"vpc-abc123abc123\"),\n\t\t\tAwsAccountId:        pulumi.String(\"abc123abc123\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ec2.NewVpcPeeringConnectionAccepter(ctx, \"peer\", \u0026ec2.VpcPeeringConnectionAccepterArgs{\n\t\t\tVpcPeeringConnectionId: testNetworkPeering.ConnectionId,\n\t\t\tAutoAccept:             pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.NetworkContainer;\nimport com.pulumi.mongodbatlas.NetworkContainerArgs;\nimport com.pulumi.mongodbatlas.NetworkPeering;\nimport com.pulumi.mongodbatlas.NetworkPeeringArgs;\nimport com.pulumi.aws.ec2.VpcPeeringConnectionAccepter;\nimport com.pulumi.aws.ec2.VpcPeeringConnectionAccepterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testNetworkContainer = new NetworkContainer(\"testNetworkContainer\", NetworkContainerArgs.builder()        \n            .projectId(local.project_id())\n            .atlasCidrBlock(\"10.8.0.0/21\")\n            .providerName(\"AWS\")\n            .regionName(\"US_EAST_1\")\n            .build());\n\n        var testNetworkPeering = new NetworkPeering(\"testNetworkPeering\", NetworkPeeringArgs.builder()        \n            .accepterRegionName(\"us-east-1\")\n            .projectId(local.project_id())\n            .containerId(\"507f1f77bcf86cd799439011\")\n            .providerName(\"AWS\")\n            .routeTableCidrBlock(\"192.168.0.0/24\")\n            .vpcId(\"vpc-abc123abc123\")\n            .awsAccountId(\"abc123abc123\")\n            .build());\n\n        var peer = new VpcPeeringConnectionAccepter(\"peer\", VpcPeeringConnectionAccepterArgs.builder()        \n            .vpcPeeringConnectionId(testNetworkPeering.connectionId())\n            .autoAccept(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Container example provided but not always required, \n  # see network_container documentation for details.\n  testNetworkContainer:\n    type: mongodbatlas:NetworkContainer\n    properties:\n      projectId: ${local.project_id}\n      atlasCidrBlock: 10.8.0.0/21\n      providerName: AWS\n      regionName: US_EAST_1\n  # Create the peering connection request\n  testNetworkPeering:\n    type: mongodbatlas:NetworkPeering\n    properties:\n      accepterRegionName: us-east-1\n      projectId: ${local.project_id}\n      containerId: 507f1f77bcf86cd799439011\n      providerName: AWS\n      routeTableCidrBlock: 192.168.0.0/24\n      vpcId: vpc-abc123abc123\n      awsAccountId: abc123abc123\n  # the following assumes an AWS provider is configured\n  # Accept the peering connection request\n  peer:\n    type: aws:ec2:VpcPeeringConnectionAccepter\n    properties:\n      vpcPeeringConnectionId: ${testNetworkPeering.connectionId}\n      autoAccept: true\n```\n{{% /example %}}\n{{% example %}}\n### Example with GCP\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\n// Container example provided but not always required, \n// see network_container documentation for details. \nconst testNetworkContainer = new mongodbatlas.NetworkContainer(\"testNetworkContainer\", {\n    projectId: local.project_id,\n    atlasCidrBlock: \"10.8.0.0/21\",\n    providerName: \"GCP\",\n});\n// Create the peering connection request\nconst testNetworkPeering = new mongodbatlas.NetworkPeering(\"testNetworkPeering\", {\n    projectId: local.project_id,\n    containerId: testNetworkContainer.containerId,\n    providerName: \"GCP\",\n    gcpProjectId: local.GCP_PROJECT_ID,\n    networkName: \"default\",\n});\nconst default = gcp.compute.getNetwork({\n    name: \"default\",\n});\n// Create the GCP peer\nconst peering = new gcp.compute.NetworkPeering(\"peering\", {\n    network: _default.then(_default =\u003e _default.selfLink),\n    peerNetwork: pulumi.interpolate`https://www.googleapis.com/compute/v1/projects/${testNetworkPeering.atlasGcpProjectId}/global/networks/${testNetworkPeering.atlasVpcName}`,\n});\n// Create the cluster once the peering connection is completed\nconst testCluster = new mongodbatlas.Cluster(\"testCluster\", {\n    projectId: local.project_id,\n    numShards: 1,\n    diskSizeGb: 5,\n    clusterType: \"REPLICASET\",\n    replicationSpecs: [{\n        numShards: 1,\n        regionsConfigs: [{\n            regionName: \"US_EAST_4\",\n            electableNodes: 3,\n            priority: 7,\n            readOnlyNodes: 0,\n        }],\n    }],\n    autoScalingDiskGbEnabled: true,\n    mongoDbMajorVersion: \"4.2\",\n    providerName: \"GCP\",\n    providerInstanceSizeName: \"M10\",\n}, {\n    dependsOn: [\"google_compute_network_peering.peering\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\nimport pulumi_mongodbatlas as mongodbatlas\n\n# Container example provided but not always required, \n# see network_container documentation for details. \ntest_network_container = mongodbatlas.NetworkContainer(\"testNetworkContainer\",\n    project_id=local[\"project_id\"],\n    atlas_cidr_block=\"10.8.0.0/21\",\n    provider_name=\"GCP\")\n# Create the peering connection request\ntest_network_peering = mongodbatlas.NetworkPeering(\"testNetworkPeering\",\n    project_id=local[\"project_id\"],\n    container_id=test_network_container.container_id,\n    provider_name=\"GCP\",\n    gcp_project_id=local[\"GCP_PROJECT_ID\"],\n    network_name=\"default\")\ndefault = gcp.compute.get_network(name=\"default\")\n# Create the GCP peer\npeering = gcp.compute.NetworkPeering(\"peering\",\n    network=default.self_link,\n    peer_network=pulumi.Output.all(test_network_peering.atlas_gcp_project_id, test_network_peering.atlas_vpc_name).apply(lambda atlas_gcp_project_id, atlas_vpc_name: f\"https://www.googleapis.com/compute/v1/projects/{atlas_gcp_project_id}/global/networks/{atlas_vpc_name}\"))\n# Create the cluster once the peering connection is completed\ntest_cluster = mongodbatlas.Cluster(\"testCluster\",\n    project_id=local[\"project_id\"],\n    num_shards=1,\n    disk_size_gb=5,\n    cluster_type=\"REPLICASET\",\n    replication_specs=[mongodbatlas.ClusterReplicationSpecArgs(\n        num_shards=1,\n        regions_configs=[mongodbatlas.ClusterReplicationSpecRegionsConfigArgs(\n            region_name=\"US_EAST_4\",\n            electable_nodes=3,\n            priority=7,\n            read_only_nodes=0,\n        )],\n    )],\n    auto_scaling_disk_gb_enabled=True,\n    mongo_db_major_version=\"4.2\",\n    provider_name=\"GCP\",\n    provider_instance_size_name=\"M10\",\n    opts=pulumi.ResourceOptions(depends_on=[\"google_compute_network_peering.peering\"]))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Container example provided but not always required, \n    // see network_container documentation for details. \n    var testNetworkContainer = new Mongodbatlas.NetworkContainer(\"testNetworkContainer\", new()\n    {\n        ProjectId = local.Project_id,\n        AtlasCidrBlock = \"10.8.0.0/21\",\n        ProviderName = \"GCP\",\n    });\n\n    // Create the peering connection request\n    var testNetworkPeering = new Mongodbatlas.NetworkPeering(\"testNetworkPeering\", new()\n    {\n        ProjectId = local.Project_id,\n        ContainerId = testNetworkContainer.ContainerId,\n        ProviderName = \"GCP\",\n        GcpProjectId = local.GCP_PROJECT_ID,\n        NetworkName = \"default\",\n    });\n\n    var @default = Gcp.Compute.GetNetwork.Invoke(new()\n    {\n        Name = \"default\",\n    });\n\n    // Create the GCP peer\n    var peering = new Gcp.Compute.NetworkPeering(\"peering\", new()\n    {\n        Network = @default.Apply(@default =\u003e @default.Apply(getNetworkResult =\u003e getNetworkResult.SelfLink)),\n        PeerNetwork = Output.Tuple(testNetworkPeering.AtlasGcpProjectId, testNetworkPeering.AtlasVpcName).Apply(values =\u003e\n        {\n            var atlasGcpProjectId = values.Item1;\n            var atlasVpcName = values.Item2;\n            return $\"https://www.googleapis.com/compute/v1/projects/{atlasGcpProjectId}/global/networks/{atlasVpcName}\";\n        }),\n    });\n\n    // Create the cluster once the peering connection is completed\n    var testCluster = new Mongodbatlas.Cluster(\"testCluster\", new()\n    {\n        ProjectId = local.Project_id,\n        NumShards = 1,\n        DiskSizeGb = 5,\n        ClusterType = \"REPLICASET\",\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.ClusterReplicationSpecArgs\n            {\n                NumShards = 1,\n                RegionsConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.ClusterReplicationSpecRegionsConfigArgs\n                    {\n                        RegionName = \"US_EAST_4\",\n                        ElectableNodes = 3,\n                        Priority = 7,\n                        ReadOnlyNodes = 0,\n                    },\n                },\n            },\n        },\n        AutoScalingDiskGbEnabled = true,\n        MongoDbMajorVersion = \"4.2\",\n        ProviderName = \"GCP\",\n        ProviderInstanceSizeName = \"M10\",\n    }, new CustomResourceOptions\n    {\n        DependsOn = new[]\n        {\n            \"google_compute_network_peering.peering\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-gcp/sdk/v5/go/gcp/compute\"\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestNetworkContainer, err := mongodbatlas.NewNetworkContainer(ctx, \"testNetworkContainer\", \u0026mongodbatlas.NetworkContainerArgs{\n\t\t\tProjectId:      pulumi.Any(local.Project_id),\n\t\t\tAtlasCidrBlock: pulumi.String(\"10.8.0.0/21\"),\n\t\t\tProviderName:   pulumi.String(\"GCP\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestNetworkPeering, err := mongodbatlas.NewNetworkPeering(ctx, \"testNetworkPeering\", \u0026mongodbatlas.NetworkPeeringArgs{\n\t\t\tProjectId:    pulumi.Any(local.Project_id),\n\t\t\tContainerId:  testNetworkContainer.ContainerId,\n\t\t\tProviderName: pulumi.String(\"GCP\"),\n\t\t\tGcpProjectId: pulumi.Any(local.GCP_PROJECT_ID),\n\t\t\tNetworkName:  pulumi.String(\"default\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_default, err := compute.LookupNetwork(ctx, \u0026compute.LookupNetworkArgs{\n\t\t\tName: \"default\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewNetworkPeering(ctx, \"peering\", \u0026compute.NetworkPeeringArgs{\n\t\t\tNetwork: *pulumi.String(_default.SelfLink),\n\t\t\tPeerNetwork: pulumi.All(testNetworkPeering.AtlasGcpProjectId, testNetworkPeering.AtlasVpcName).ApplyT(func(_args []interface{}) (string, error) {\n\t\t\t\tatlasGcpProjectId := _args[0].(string)\n\t\t\t\tatlasVpcName := _args[1].(string)\n\t\t\t\treturn fmt.Sprintf(\"https://www.googleapis.com/compute/v1/projects/%v/global/networks/%v\", atlasGcpProjectId, atlasVpcName), nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewCluster(ctx, \"testCluster\", \u0026mongodbatlas.ClusterArgs{\n\t\t\tProjectId:   pulumi.Any(local.Project_id),\n\t\t\tNumShards:   pulumi.Int(1),\n\t\t\tDiskSizeGb:  pulumi.Float64(5),\n\t\t\tClusterType: pulumi.String(\"REPLICASET\"),\n\t\t\tReplicationSpecs: mongodbatlas.ClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecArgs{\n\t\t\t\t\tNumShards: pulumi.Int(1),\n\t\t\t\t\tRegionsConfigs: mongodbatlas.ClusterReplicationSpecRegionsConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecRegionsConfigArgs{\n\t\t\t\t\t\t\tRegionName:     pulumi.String(\"US_EAST_4\"),\n\t\t\t\t\t\t\tElectableNodes: pulumi.Int(3),\n\t\t\t\t\t\t\tPriority:       pulumi.Int(7),\n\t\t\t\t\t\t\tReadOnlyNodes:  pulumi.Int(0),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tAutoScalingDiskGbEnabled: pulumi.Bool(true),\n\t\t\tMongoDbMajorVersion:      pulumi.String(\"4.2\"),\n\t\t\tProviderName:             pulumi.String(\"GCP\"),\n\t\t\tProviderInstanceSizeName: pulumi.String(\"M10\"),\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\tpulumi.Resource(\"google_compute_network_peering.peering\"),\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.NetworkContainer;\nimport com.pulumi.mongodbatlas.NetworkContainerArgs;\nimport com.pulumi.mongodbatlas.NetworkPeering;\nimport com.pulumi.mongodbatlas.NetworkPeeringArgs;\nimport com.pulumi.gcp.compute.ComputeFunctions;\nimport com.pulumi.gcp.compute.inputs.GetNetworkArgs;\nimport com.pulumi.gcp.compute.NetworkPeering;\nimport com.pulumi.gcp.compute.NetworkPeeringArgs;\nimport com.pulumi.mongodbatlas.Cluster;\nimport com.pulumi.mongodbatlas.ClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.ClusterReplicationSpecArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testNetworkContainer = new NetworkContainer(\"testNetworkContainer\", NetworkContainerArgs.builder()        \n            .projectId(local.project_id())\n            .atlasCidrBlock(\"10.8.0.0/21\")\n            .providerName(\"GCP\")\n            .build());\n\n        var testNetworkPeering = new NetworkPeering(\"testNetworkPeering\", NetworkPeeringArgs.builder()        \n            .projectId(local.project_id())\n            .containerId(testNetworkContainer.containerId())\n            .providerName(\"GCP\")\n            .gcpProjectId(local.GCP_PROJECT_ID())\n            .networkName(\"default\")\n            .build());\n\n        final var default = ComputeFunctions.getNetwork(GetNetworkArgs.builder()\n            .name(\"default\")\n            .build());\n\n        var peering = new NetworkPeering(\"peering\", NetworkPeeringArgs.builder()        \n            .network(default_.selfLink())\n            .peerNetwork(Output.tuple(testNetworkPeering.atlasGcpProjectId(), testNetworkPeering.atlasVpcName()).applyValue(values -\u003e {\n                var atlasGcpProjectId = values.t1;\n                var atlasVpcName = values.t2;\n                return String.format(\"https://www.googleapis.com/compute/v1/projects/%s/global/networks/%s\", atlasGcpProjectId,atlasVpcName);\n            }))\n            .build());\n\n        var testCluster = new Cluster(\"testCluster\", ClusterArgs.builder()        \n            .projectId(local.project_id())\n            .numShards(1)\n            .diskSizeGb(5)\n            .clusterType(\"REPLICASET\")\n            .replicationSpecs(ClusterReplicationSpecArgs.builder()\n                .numShards(1)\n                .regionsConfigs(ClusterReplicationSpecRegionsConfigArgs.builder()\n                    .regionName(\"US_EAST_4\")\n                    .electableNodes(3)\n                    .priority(7)\n                    .readOnlyNodes(0)\n                    .build())\n                .build())\n            .autoScalingDiskGbEnabled(true)\n            .mongoDbMajorVersion(\"4.2\")\n            .providerName(\"GCP\")\n            .providerInstanceSizeName(\"M10\")\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(\"google_compute_network_peering.peering\")\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Container example provided but not always required, \n  # see network_container documentation for details.\n  testNetworkContainer:\n    type: mongodbatlas:NetworkContainer\n    properties:\n      projectId: ${local.project_id}\n      atlasCidrBlock: 10.8.0.0/21\n      providerName: GCP\n  # Create the peering connection request\n  testNetworkPeering:\n    type: mongodbatlas:NetworkPeering\n    properties:\n      projectId: ${local.project_id}\n      containerId: ${testNetworkContainer.containerId}\n      providerName: GCP\n      gcpProjectId: ${local.GCP_PROJECT_ID}\n      networkName: default\n  # Create the GCP peer\n  peering:\n    type: gcp:compute:NetworkPeering\n    properties:\n      network: ${default.selfLink}\n      peerNetwork: https://www.googleapis.com/compute/v1/projects/${testNetworkPeering.atlasGcpProjectId}/global/networks/${testNetworkPeering.atlasVpcName}\n  # Create the cluster once the peering connection is completed\n  testCluster:\n    type: mongodbatlas:Cluster\n    properties:\n      projectId: ${local.project_id}\n      numShards: 1\n      diskSizeGb: 5\n      clusterType: REPLICASET\n      replicationSpecs:\n        - numShards: 1\n          regionsConfigs:\n            - regionName: US_EAST_4\n              electableNodes: 3\n              priority: 7\n              readOnlyNodes: 0\n      autoScalingDiskGbEnabled: true\n      mongoDbMajorVersion: '4.2'\n      # Provider Settings \"block\"\n      providerName: GCP\n      providerInstanceSizeName: M10\n    options:\n      dependson:\n        - google_compute_network_peering.peering\nvariables:\n  default:\n    fn::invoke:\n      Function: gcp:compute:getNetwork\n      Arguments:\n        name: default\n```\n{{% /example %}}\n{{% example %}}\n### Example with Azure\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\n// Ensure you have created the required Azure service principal first, see\n// see https://docs.atlas.mongodb.com/security-vpc-peering/\n// Container example provided but not always required, \n// see network_container documentation for details. \nconst testNetworkContainer = new mongodbatlas.NetworkContainer(\"testNetworkContainer\", {\n    projectId: local.project_id,\n    atlasCidrBlock: local.ATLAS_CIDR_BLOCK,\n    providerName: \"AZURE\",\n    region: \"US_EAST_2\",\n});\n// Create the peering connection request\nconst testNetworkPeering = new mongodbatlas.NetworkPeering(\"testNetworkPeering\", {\n    projectId: local.project_id,\n    containerId: testNetworkContainer.containerId,\n    providerName: \"AZURE\",\n    azureDirectoryId: local.AZURE_DIRECTORY_ID,\n    azureSubscriptionId: local.AZURE_SUBSCRIPTION_ID,\n    resourceGroupName: local.AZURE_RESOURCES_GROUP_NAME,\n    vnetName: local.AZURE_VNET_NAME,\n});\n// Create the cluster once the peering connection is completed\nconst testCluster = new mongodbatlas.Cluster(\"testCluster\", {\n    projectId: local.project_id,\n    clusterType: \"REPLICASET\",\n    replicationSpecs: [{\n        numShards: 1,\n        regionsConfigs: [{\n            regionName: \"US_EAST_2\",\n            electableNodes: 3,\n            priority: 7,\n            readOnlyNodes: 0,\n        }],\n    }],\n    autoScalingDiskGbEnabled: true,\n    mongoDbMajorVersion: \"4.2\",\n    providerName: \"AZURE\",\n    providerDiskTypeName: \"P4\",\n    providerInstanceSizeName: \"M10\",\n}, {\n    dependsOn: [\"mongodbatlas_network_peering.test\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\n# Ensure you have created the required Azure service principal first, see\n# see https://docs.atlas.mongodb.com/security-vpc-peering/\n# Container example provided but not always required, \n# see network_container documentation for details. \ntest_network_container = mongodbatlas.NetworkContainer(\"testNetworkContainer\",\n    project_id=local[\"project_id\"],\n    atlas_cidr_block=local[\"ATLAS_CIDR_BLOCK\"],\n    provider_name=\"AZURE\",\n    region=\"US_EAST_2\")\n# Create the peering connection request\ntest_network_peering = mongodbatlas.NetworkPeering(\"testNetworkPeering\",\n    project_id=local[\"project_id\"],\n    container_id=test_network_container.container_id,\n    provider_name=\"AZURE\",\n    azure_directory_id=local[\"AZURE_DIRECTORY_ID\"],\n    azure_subscription_id=local[\"AZURE_SUBSCRIPTION_ID\"],\n    resource_group_name=local[\"AZURE_RESOURCES_GROUP_NAME\"],\n    vnet_name=local[\"AZURE_VNET_NAME\"])\n# Create the cluster once the peering connection is completed\ntest_cluster = mongodbatlas.Cluster(\"testCluster\",\n    project_id=local[\"project_id\"],\n    cluster_type=\"REPLICASET\",\n    replication_specs=[mongodbatlas.ClusterReplicationSpecArgs(\n        num_shards=1,\n        regions_configs=[mongodbatlas.ClusterReplicationSpecRegionsConfigArgs(\n            region_name=\"US_EAST_2\",\n            electable_nodes=3,\n            priority=7,\n            read_only_nodes=0,\n        )],\n    )],\n    auto_scaling_disk_gb_enabled=True,\n    mongo_db_major_version=\"4.2\",\n    provider_name=\"AZURE\",\n    provider_disk_type_name=\"P4\",\n    provider_instance_size_name=\"M10\",\n    opts=pulumi.ResourceOptions(depends_on=[\"mongodbatlas_network_peering.test\"]))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Ensure you have created the required Azure service principal first, see\n    // see https://docs.atlas.mongodb.com/security-vpc-peering/\n    // Container example provided but not always required, \n    // see network_container documentation for details. \n    var testNetworkContainer = new Mongodbatlas.NetworkContainer(\"testNetworkContainer\", new()\n    {\n        ProjectId = local.Project_id,\n        AtlasCidrBlock = local.ATLAS_CIDR_BLOCK,\n        ProviderName = \"AZURE\",\n        Region = \"US_EAST_2\",\n    });\n\n    // Create the peering connection request\n    var testNetworkPeering = new Mongodbatlas.NetworkPeering(\"testNetworkPeering\", new()\n    {\n        ProjectId = local.Project_id,\n        ContainerId = testNetworkContainer.ContainerId,\n        ProviderName = \"AZURE\",\n        AzureDirectoryId = local.AZURE_DIRECTORY_ID,\n        AzureSubscriptionId = local.AZURE_SUBSCRIPTION_ID,\n        ResourceGroupName = local.AZURE_RESOURCES_GROUP_NAME,\n        VnetName = local.AZURE_VNET_NAME,\n    });\n\n    // Create the cluster once the peering connection is completed\n    var testCluster = new Mongodbatlas.Cluster(\"testCluster\", new()\n    {\n        ProjectId = local.Project_id,\n        ClusterType = \"REPLICASET\",\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.ClusterReplicationSpecArgs\n            {\n                NumShards = 1,\n                RegionsConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.ClusterReplicationSpecRegionsConfigArgs\n                    {\n                        RegionName = \"US_EAST_2\",\n                        ElectableNodes = 3,\n                        Priority = 7,\n                        ReadOnlyNodes = 0,\n                    },\n                },\n            },\n        },\n        AutoScalingDiskGbEnabled = true,\n        MongoDbMajorVersion = \"4.2\",\n        ProviderName = \"AZURE\",\n        ProviderDiskTypeName = \"P4\",\n        ProviderInstanceSizeName = \"M10\",\n    }, new CustomResourceOptions\n    {\n        DependsOn = new[]\n        {\n            \"mongodbatlas_network_peering.test\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestNetworkContainer, err := mongodbatlas.NewNetworkContainer(ctx, \"testNetworkContainer\", \u0026mongodbatlas.NetworkContainerArgs{\n\t\t\tProjectId:      pulumi.Any(local.Project_id),\n\t\t\tAtlasCidrBlock: pulumi.Any(local.ATLAS_CIDR_BLOCK),\n\t\t\tProviderName:   pulumi.String(\"AZURE\"),\n\t\t\tRegion:         pulumi.String(\"US_EAST_2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewNetworkPeering(ctx, \"testNetworkPeering\", \u0026mongodbatlas.NetworkPeeringArgs{\n\t\t\tProjectId:           pulumi.Any(local.Project_id),\n\t\t\tContainerId:         testNetworkContainer.ContainerId,\n\t\t\tProviderName:        pulumi.String(\"AZURE\"),\n\t\t\tAzureDirectoryId:    pulumi.Any(local.AZURE_DIRECTORY_ID),\n\t\t\tAzureSubscriptionId: pulumi.Any(local.AZURE_SUBSCRIPTION_ID),\n\t\t\tResourceGroupName:   pulumi.Any(local.AZURE_RESOURCES_GROUP_NAME),\n\t\t\tVnetName:            pulumi.Any(local.AZURE_VNET_NAME),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewCluster(ctx, \"testCluster\", \u0026mongodbatlas.ClusterArgs{\n\t\t\tProjectId:   pulumi.Any(local.Project_id),\n\t\t\tClusterType: pulumi.String(\"REPLICASET\"),\n\t\t\tReplicationSpecs: mongodbatlas.ClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecArgs{\n\t\t\t\t\tNumShards: pulumi.Int(1),\n\t\t\t\t\tRegionsConfigs: mongodbatlas.ClusterReplicationSpecRegionsConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecRegionsConfigArgs{\n\t\t\t\t\t\t\tRegionName:     pulumi.String(\"US_EAST_2\"),\n\t\t\t\t\t\t\tElectableNodes: pulumi.Int(3),\n\t\t\t\t\t\t\tPriority:       pulumi.Int(7),\n\t\t\t\t\t\t\tReadOnlyNodes:  pulumi.Int(0),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tAutoScalingDiskGbEnabled: pulumi.Bool(true),\n\t\t\tMongoDbMajorVersion:      pulumi.String(\"4.2\"),\n\t\t\tProviderName:             pulumi.String(\"AZURE\"),\n\t\t\tProviderDiskTypeName:     pulumi.String(\"P4\"),\n\t\t\tProviderInstanceSizeName: pulumi.String(\"M10\"),\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\tpulumi.Resource(\"mongodbatlas_network_peering.test\"),\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.NetworkContainer;\nimport com.pulumi.mongodbatlas.NetworkContainerArgs;\nimport com.pulumi.mongodbatlas.NetworkPeering;\nimport com.pulumi.mongodbatlas.NetworkPeeringArgs;\nimport com.pulumi.mongodbatlas.Cluster;\nimport com.pulumi.mongodbatlas.ClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.ClusterReplicationSpecArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testNetworkContainer = new NetworkContainer(\"testNetworkContainer\", NetworkContainerArgs.builder()        \n            .projectId(local.project_id())\n            .atlasCidrBlock(local.ATLAS_CIDR_BLOCK())\n            .providerName(\"AZURE\")\n            .region(\"US_EAST_2\")\n            .build());\n\n        var testNetworkPeering = new NetworkPeering(\"testNetworkPeering\", NetworkPeeringArgs.builder()        \n            .projectId(local.project_id())\n            .containerId(testNetworkContainer.containerId())\n            .providerName(\"AZURE\")\n            .azureDirectoryId(local.AZURE_DIRECTORY_ID())\n            .azureSubscriptionId(local.AZURE_SUBSCRIPTION_ID())\n            .resourceGroupName(local.AZURE_RESOURCES_GROUP_NAME())\n            .vnetName(local.AZURE_VNET_NAME())\n            .build());\n\n        var testCluster = new Cluster(\"testCluster\", ClusterArgs.builder()        \n            .projectId(local.project_id())\n            .clusterType(\"REPLICASET\")\n            .replicationSpecs(ClusterReplicationSpecArgs.builder()\n                .numShards(1)\n                .regionsConfigs(ClusterReplicationSpecRegionsConfigArgs.builder()\n                    .regionName(\"US_EAST_2\")\n                    .electableNodes(3)\n                    .priority(7)\n                    .readOnlyNodes(0)\n                    .build())\n                .build())\n            .autoScalingDiskGbEnabled(true)\n            .mongoDbMajorVersion(\"4.2\")\n            .providerName(\"AZURE\")\n            .providerDiskTypeName(\"P4\")\n            .providerInstanceSizeName(\"M10\")\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(\"mongodbatlas_network_peering.test\")\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Ensure you have created the required Azure service principal first, see\n  # see https://docs.atlas.mongodb.com/security-vpc-peering/\n\n  # Container example provided but not always required, \n  # see network_container documentation for details.\n  testNetworkContainer:\n    type: mongodbatlas:NetworkContainer\n    properties:\n      projectId: ${local.project_id}\n      atlasCidrBlock: ${local.ATLAS_CIDR_BLOCK}\n      providerName: AZURE\n      region: US_EAST_2\n  # Create the peering connection request\n  testNetworkPeering:\n    type: mongodbatlas:NetworkPeering\n    properties:\n      projectId: ${local.project_id}\n      containerId: ${testNetworkContainer.containerId}\n      providerName: AZURE\n      azureDirectoryId: ${local.AZURE_DIRECTORY_ID}\n      azureSubscriptionId: ${local.AZURE_SUBSCRIPTION_ID}\n      resourceGroupName: ${local.AZURE_RESOURCES_GROUP_NAME}\n      vnetName: ${local.AZURE_VNET_NAME}\n  # Create the cluster once the peering connection is completed\n  testCluster:\n    type: mongodbatlas:Cluster\n    properties:\n      projectId: ${local.project_id}\n      clusterType: REPLICASET\n      replicationSpecs:\n        - numShards: 1\n          regionsConfigs:\n            - regionName: US_EAST_2\n              electableNodes: 3\n              priority: 7\n              readOnlyNodes: 0\n      autoScalingDiskGbEnabled: true\n      mongoDbMajorVersion: '4.2'\n      # Provider Settings \"block\"\n      providerName: AZURE\n      providerDiskTypeName: P4\n      providerInstanceSizeName: M10\n    options:\n      dependson:\n        - mongodbatlas_network_peering.test\n```\n{{% /example %}}\n### Peering Connection Only, Container Exists\nYou can create a peering connection if an appropriate container for your cloud provider already exists in your project (see the network_container resource for more information).  A container may already exist if you have already created a cluster in your project, if so you may obtain the `container_id` from the cluster resource as shown in the examples below.\n{{% example %}}\n### Example with AWS\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\n// Create an Atlas cluster, this creates a container if one\n// does not yet exist for this AWS region\nconst test = new mongodbatlas.Cluster(\"test\", {\n    projectId: local.project_id,\n    diskSizeGb: 5,\n    clusterType: \"REPLICASET\",\n    replicationSpecs: [{\n        numShards: 1,\n        regionsConfigs: [{\n            regionName: \"US_EAST_2\",\n            electableNodes: 3,\n            priority: 7,\n            readOnlyNodes: 0,\n        }],\n    }],\n    autoScalingDiskGbEnabled: false,\n    mongoDbMajorVersion: \"4.2\",\n    providerName: \"AWS\",\n    providerInstanceSizeName: \"M10\",\n});\n// the following assumes an AWS provider is configured\nconst _default = new aws.ec2.DefaultVpc(\"default\", {tags: {\n    Name: \"Default VPC\",\n}});\n// Create the peering connection request\nconst mongoPeer = new mongodbatlas.NetworkPeering(\"mongoPeer\", {\n    accepterRegionName: \"us-east-2\",\n    projectId: local.project_id,\n    containerId: test.containerId,\n    providerName: \"AWS\",\n    routeTableCidrBlock: \"172.31.0.0/16\",\n    vpcId: _default.id,\n    awsAccountId: local.AWS_ACCOUNT_ID,\n});\n// Accept the connection \nconst awsPeer = new aws.ec2.VpcPeeringConnectionAccepter(\"awsPeer\", {\n    vpcPeeringConnectionId: mongoPeer.connectionId,\n    autoAccept: true,\n    tags: {\n        Side: \"Accepter\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\nimport pulumi_mongodbatlas as mongodbatlas\n\n# Create an Atlas cluster, this creates a container if one\n# does not yet exist for this AWS region\ntest = mongodbatlas.Cluster(\"test\",\n    project_id=local[\"project_id\"],\n    disk_size_gb=5,\n    cluster_type=\"REPLICASET\",\n    replication_specs=[mongodbatlas.ClusterReplicationSpecArgs(\n        num_shards=1,\n        regions_configs=[mongodbatlas.ClusterReplicationSpecRegionsConfigArgs(\n            region_name=\"US_EAST_2\",\n            electable_nodes=3,\n            priority=7,\n            read_only_nodes=0,\n        )],\n    )],\n    auto_scaling_disk_gb_enabled=False,\n    mongo_db_major_version=\"4.2\",\n    provider_name=\"AWS\",\n    provider_instance_size_name=\"M10\")\n# the following assumes an AWS provider is configured\ndefault = aws.ec2.DefaultVpc(\"default\", tags={\n    \"Name\": \"Default VPC\",\n})\n# Create the peering connection request\nmongo_peer = mongodbatlas.NetworkPeering(\"mongoPeer\",\n    accepter_region_name=\"us-east-2\",\n    project_id=local[\"project_id\"],\n    container_id=test.container_id,\n    provider_name=\"AWS\",\n    route_table_cidr_block=\"172.31.0.0/16\",\n    vpc_id=default.id,\n    aws_account_id=local[\"AWS_ACCOUNT_ID\"])\n# Accept the connection \naws_peer = aws.ec2.VpcPeeringConnectionAccepter(\"awsPeer\",\n    vpc_peering_connection_id=mongo_peer.connection_id,\n    auto_accept=True,\n    tags={\n        \"Side\": \"Accepter\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create an Atlas cluster, this creates a container if one\n    // does not yet exist for this AWS region\n    var test = new Mongodbatlas.Cluster(\"test\", new()\n    {\n        ProjectId = local.Project_id,\n        DiskSizeGb = 5,\n        ClusterType = \"REPLICASET\",\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.ClusterReplicationSpecArgs\n            {\n                NumShards = 1,\n                RegionsConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.ClusterReplicationSpecRegionsConfigArgs\n                    {\n                        RegionName = \"US_EAST_2\",\n                        ElectableNodes = 3,\n                        Priority = 7,\n                        ReadOnlyNodes = 0,\n                    },\n                },\n            },\n        },\n        AutoScalingDiskGbEnabled = false,\n        MongoDbMajorVersion = \"4.2\",\n        ProviderName = \"AWS\",\n        ProviderInstanceSizeName = \"M10\",\n    });\n\n    // the following assumes an AWS provider is configured\n    var @default = new Aws.Ec2.DefaultVpc(\"default\", new()\n    {\n        Tags = \n        {\n            { \"Name\", \"Default VPC\" },\n        },\n    });\n\n    // Create the peering connection request\n    var mongoPeer = new Mongodbatlas.NetworkPeering(\"mongoPeer\", new()\n    {\n        AccepterRegionName = \"us-east-2\",\n        ProjectId = local.Project_id,\n        ContainerId = test.ContainerId,\n        ProviderName = \"AWS\",\n        RouteTableCidrBlock = \"172.31.0.0/16\",\n        VpcId = @default.Id,\n        AwsAccountId = local.AWS_ACCOUNT_ID,\n    });\n\n    // Accept the connection \n    var awsPeer = new Aws.Ec2.VpcPeeringConnectionAccepter(\"awsPeer\", new()\n    {\n        VpcPeeringConnectionId = mongoPeer.ConnectionId,\n        AutoAccept = true,\n        Tags = \n        {\n            { \"Side\", \"Accepter\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/ec2\"\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := mongodbatlas.NewCluster(ctx, \"test\", \u0026mongodbatlas.ClusterArgs{\n\t\t\tProjectId:   pulumi.Any(local.Project_id),\n\t\t\tDiskSizeGb:  pulumi.Float64(5),\n\t\t\tClusterType: pulumi.String(\"REPLICASET\"),\n\t\t\tReplicationSpecs: mongodbatlas.ClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecArgs{\n\t\t\t\t\tNumShards: pulumi.Int(1),\n\t\t\t\t\tRegionsConfigs: mongodbatlas.ClusterReplicationSpecRegionsConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecRegionsConfigArgs{\n\t\t\t\t\t\t\tRegionName:     pulumi.String(\"US_EAST_2\"),\n\t\t\t\t\t\t\tElectableNodes: pulumi.Int(3),\n\t\t\t\t\t\t\tPriority:       pulumi.Int(7),\n\t\t\t\t\t\t\tReadOnlyNodes:  pulumi.Int(0),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tAutoScalingDiskGbEnabled: pulumi.Bool(false),\n\t\t\tMongoDbMajorVersion:      pulumi.String(\"4.2\"),\n\t\t\tProviderName:             pulumi.String(\"AWS\"),\n\t\t\tProviderInstanceSizeName: pulumi.String(\"M10\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ec2.NewDefaultVpc(ctx, \"default\", \u0026ec2.DefaultVpcArgs{\n\t\t\tTags: pulumi.StringMap{\n\t\t\t\t\"Name\": pulumi.String(\"Default VPC\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmongoPeer, err := mongodbatlas.NewNetworkPeering(ctx, \"mongoPeer\", \u0026mongodbatlas.NetworkPeeringArgs{\n\t\t\tAccepterRegionName:  pulumi.String(\"us-east-2\"),\n\t\t\tProjectId:           pulumi.Any(local.Project_id),\n\t\t\tContainerId:         test.ContainerId,\n\t\t\tProviderName:        pulumi.String(\"AWS\"),\n\t\t\tRouteTableCidrBlock: pulumi.String(\"172.31.0.0/16\"),\n\t\t\tVpcId:               _default.ID(),\n\t\t\tAwsAccountId:        pulumi.Any(local.AWS_ACCOUNT_ID),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ec2.NewVpcPeeringConnectionAccepter(ctx, \"awsPeer\", \u0026ec2.VpcPeeringConnectionAccepterArgs{\n\t\t\tVpcPeeringConnectionId: mongoPeer.ConnectionId,\n\t\t\tAutoAccept:             pulumi.Bool(true),\n\t\t\tTags: pulumi.StringMap{\n\t\t\t\t\"Side\": pulumi.String(\"Accepter\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Cluster;\nimport com.pulumi.mongodbatlas.ClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.ClusterReplicationSpecArgs;\nimport com.pulumi.aws.ec2.DefaultVpc;\nimport com.pulumi.aws.ec2.DefaultVpcArgs;\nimport com.pulumi.mongodbatlas.NetworkPeering;\nimport com.pulumi.mongodbatlas.NetworkPeeringArgs;\nimport com.pulumi.aws.ec2.VpcPeeringConnectionAccepter;\nimport com.pulumi.aws.ec2.VpcPeeringConnectionAccepterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new Cluster(\"test\", ClusterArgs.builder()        \n            .projectId(local.project_id())\n            .diskSizeGb(5)\n            .clusterType(\"REPLICASET\")\n            .replicationSpecs(ClusterReplicationSpecArgs.builder()\n                .numShards(1)\n                .regionsConfigs(ClusterReplicationSpecRegionsConfigArgs.builder()\n                    .regionName(\"US_EAST_2\")\n                    .electableNodes(3)\n                    .priority(7)\n                    .readOnlyNodes(0)\n                    .build())\n                .build())\n            .autoScalingDiskGbEnabled(false)\n            .mongoDbMajorVersion(\"4.2\")\n            .providerName(\"AWS\")\n            .providerInstanceSizeName(\"M10\")\n            .build());\n\n        var default_ = new DefaultVpc(\"default\", DefaultVpcArgs.builder()        \n            .tags(Map.of(\"Name\", \"Default VPC\"))\n            .build());\n\n        var mongoPeer = new NetworkPeering(\"mongoPeer\", NetworkPeeringArgs.builder()        \n            .accepterRegionName(\"us-east-2\")\n            .projectId(local.project_id())\n            .containerId(test.containerId())\n            .providerName(\"AWS\")\n            .routeTableCidrBlock(\"172.31.0.0/16\")\n            .vpcId(default_.id())\n            .awsAccountId(local.AWS_ACCOUNT_ID())\n            .build());\n\n        var awsPeer = new VpcPeeringConnectionAccepter(\"awsPeer\", VpcPeeringConnectionAccepterArgs.builder()        \n            .vpcPeeringConnectionId(mongoPeer.connectionId())\n            .autoAccept(true)\n            .tags(Map.of(\"Side\", \"Accepter\"))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create an Atlas cluster, this creates a container if one\n  # does not yet exist for this AWS region\n  test:\n    type: mongodbatlas:Cluster\n    properties:\n      projectId: ${local.project_id}\n      diskSizeGb: 5\n      clusterType: REPLICASET\n      replicationSpecs:\n        - numShards: 1\n          regionsConfigs:\n            - regionName: US_EAST_2\n              electableNodes: 3\n              priority: 7\n              readOnlyNodes: 0\n      autoScalingDiskGbEnabled: false\n      mongoDbMajorVersion: '4.2'\n      # Provider Settings \"block\"\n      providerName: AWS\n      providerInstanceSizeName: M10\n  # the following assumes an AWS provider is configured\n  default:\n    type: aws:ec2:DefaultVpc\n    properties:\n      tags:\n        Name: Default VPC\n  # Create the peering connection request\n  mongoPeer:\n    type: mongodbatlas:NetworkPeering\n    properties:\n      accepterRegionName: us-east-2\n      projectId: ${local.project_id}\n      containerId: ${test.containerId}\n      providerName: AWS\n      routeTableCidrBlock: 172.31.0.0/16\n      vpcId: ${default.id}\n      awsAccountId: ${local.AWS_ACCOUNT_ID}\n  # Accept the connection\n  awsPeer:\n    type: aws:ec2:VpcPeeringConnectionAccepter\n    properties:\n      vpcPeeringConnectionId: ${mongoPeer.connectionId}\n      autoAccept: true\n      tags:\n        Side: Accepter\n```\n{{% /example %}}\n{{% example %}}\n### Example with GCP\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as gcp from \"@pulumi/gcp\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\n// Create an Atlas cluster, this creates a container if one\n// does not yet exist for this GCP \nconst testCluster = new mongodbatlas.Cluster(\"testCluster\", {\n    projectId: local.project_id,\n    diskSizeGb: 5,\n    clusterType: \"REPLICASET\",\n    replicationSpecs: [{\n        numShards: 1,\n        regionsConfigs: [{\n            regionName: \"US_EAST_2\",\n            electableNodes: 3,\n            priority: 7,\n            readOnlyNodes: 0,\n        }],\n    }],\n    autoScalingDiskGbEnabled: true,\n    mongoDbMajorVersion: \"4.2\",\n    providerName: \"GCP\",\n    providerInstanceSizeName: \"M10\",\n});\n// Create the peering connection request\nconst testNetworkPeering = new mongodbatlas.NetworkPeering(\"testNetworkPeering\", {\n    projectId: local.project_id,\n    atlasCidrBlock: \"192.168.0.0/18\",\n    containerId: testCluster.containerId,\n    providerName: \"GCP\",\n    gcpProjectId: local.GCP_PROJECT_ID,\n    networkName: \"default\",\n});\nconst default = gcp.compute.getNetwork({\n    name: \"default\",\n});\n// Create the GCP peer\nconst peering = new gcp.compute.NetworkPeering(\"peering\", {\n    network: _default.then(_default =\u003e _default.selfLink),\n    peerNetwork: pulumi.interpolate`https://www.googleapis.com/compute/v1/projects/${testNetworkPeering.atlasGcpProjectId}/global/networks/${testNetworkPeering.atlasVpcName}`,\n});\n```\n```python\nimport pulumi\nimport pulumi_gcp as gcp\nimport pulumi_mongodbatlas as mongodbatlas\n\n# Create an Atlas cluster, this creates a container if one\n# does not yet exist for this GCP \ntest_cluster = mongodbatlas.Cluster(\"testCluster\",\n    project_id=local[\"project_id\"],\n    disk_size_gb=5,\n    cluster_type=\"REPLICASET\",\n    replication_specs=[mongodbatlas.ClusterReplicationSpecArgs(\n        num_shards=1,\n        regions_configs=[mongodbatlas.ClusterReplicationSpecRegionsConfigArgs(\n            region_name=\"US_EAST_2\",\n            electable_nodes=3,\n            priority=7,\n            read_only_nodes=0,\n        )],\n    )],\n    auto_scaling_disk_gb_enabled=True,\n    mongo_db_major_version=\"4.2\",\n    provider_name=\"GCP\",\n    provider_instance_size_name=\"M10\")\n# Create the peering connection request\ntest_network_peering = mongodbatlas.NetworkPeering(\"testNetworkPeering\",\n    project_id=local[\"project_id\"],\n    atlas_cidr_block=\"192.168.0.0/18\",\n    container_id=test_cluster.container_id,\n    provider_name=\"GCP\",\n    gcp_project_id=local[\"GCP_PROJECT_ID\"],\n    network_name=\"default\")\ndefault = gcp.compute.get_network(name=\"default\")\n# Create the GCP peer\npeering = gcp.compute.NetworkPeering(\"peering\",\n    network=default.self_link,\n    peer_network=pulumi.Output.all(test_network_peering.atlas_gcp_project_id, test_network_peering.atlas_vpc_name).apply(lambda atlas_gcp_project_id, atlas_vpc_name: f\"https://www.googleapis.com/compute/v1/projects/{atlas_gcp_project_id}/global/networks/{atlas_vpc_name}\"))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Gcp = Pulumi.Gcp;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Create an Atlas cluster, this creates a container if one\n    // does not yet exist for this GCP \n    var testCluster = new Mongodbatlas.Cluster(\"testCluster\", new()\n    {\n        ProjectId = local.Project_id,\n        DiskSizeGb = 5,\n        ClusterType = \"REPLICASET\",\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.ClusterReplicationSpecArgs\n            {\n                NumShards = 1,\n                RegionsConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.ClusterReplicationSpecRegionsConfigArgs\n                    {\n                        RegionName = \"US_EAST_2\",\n                        ElectableNodes = 3,\n                        Priority = 7,\n                        ReadOnlyNodes = 0,\n                    },\n                },\n            },\n        },\n        AutoScalingDiskGbEnabled = true,\n        MongoDbMajorVersion = \"4.2\",\n        ProviderName = \"GCP\",\n        ProviderInstanceSizeName = \"M10\",\n    });\n\n    // Create the peering connection request\n    var testNetworkPeering = new Mongodbatlas.NetworkPeering(\"testNetworkPeering\", new()\n    {\n        ProjectId = local.Project_id,\n        AtlasCidrBlock = \"192.168.0.0/18\",\n        ContainerId = testCluster.ContainerId,\n        ProviderName = \"GCP\",\n        GcpProjectId = local.GCP_PROJECT_ID,\n        NetworkName = \"default\",\n    });\n\n    var @default = Gcp.Compute.GetNetwork.Invoke(new()\n    {\n        Name = \"default\",\n    });\n\n    // Create the GCP peer\n    var peering = new Gcp.Compute.NetworkPeering(\"peering\", new()\n    {\n        Network = @default.Apply(@default =\u003e @default.Apply(getNetworkResult =\u003e getNetworkResult.SelfLink)),\n        PeerNetwork = Output.Tuple(testNetworkPeering.AtlasGcpProjectId, testNetworkPeering.AtlasVpcName).Apply(values =\u003e\n        {\n            var atlasGcpProjectId = values.Item1;\n            var atlasVpcName = values.Item2;\n            return $\"https://www.googleapis.com/compute/v1/projects/{atlasGcpProjectId}/global/networks/{atlasVpcName}\";\n        }),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-gcp/sdk/v5/go/gcp/compute\"\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestCluster, err := mongodbatlas.NewCluster(ctx, \"testCluster\", \u0026mongodbatlas.ClusterArgs{\n\t\t\tProjectId:   pulumi.Any(local.Project_id),\n\t\t\tDiskSizeGb:  pulumi.Float64(5),\n\t\t\tClusterType: pulumi.String(\"REPLICASET\"),\n\t\t\tReplicationSpecs: mongodbatlas.ClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecArgs{\n\t\t\t\t\tNumShards: pulumi.Int(1),\n\t\t\t\t\tRegionsConfigs: mongodbatlas.ClusterReplicationSpecRegionsConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecRegionsConfigArgs{\n\t\t\t\t\t\t\tRegionName:     pulumi.String(\"US_EAST_2\"),\n\t\t\t\t\t\t\tElectableNodes: pulumi.Int(3),\n\t\t\t\t\t\t\tPriority:       pulumi.Int(7),\n\t\t\t\t\t\t\tReadOnlyNodes:  pulumi.Int(0),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tAutoScalingDiskGbEnabled: pulumi.Bool(true),\n\t\t\tMongoDbMajorVersion:      pulumi.String(\"4.2\"),\n\t\t\tProviderName:             pulumi.String(\"GCP\"),\n\t\t\tProviderInstanceSizeName: pulumi.String(\"M10\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestNetworkPeering, err := mongodbatlas.NewNetworkPeering(ctx, \"testNetworkPeering\", \u0026mongodbatlas.NetworkPeeringArgs{\n\t\t\tProjectId:      pulumi.Any(local.Project_id),\n\t\t\tAtlasCidrBlock: pulumi.String(\"192.168.0.0/18\"),\n\t\t\tContainerId:    testCluster.ContainerId,\n\t\t\tProviderName:   pulumi.String(\"GCP\"),\n\t\t\tGcpProjectId:   pulumi.Any(local.GCP_PROJECT_ID),\n\t\t\tNetworkName:    pulumi.String(\"default\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_default, err := compute.LookupNetwork(ctx, \u0026compute.LookupNetworkArgs{\n\t\t\tName: \"default\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = compute.NewNetworkPeering(ctx, \"peering\", \u0026compute.NetworkPeeringArgs{\n\t\t\tNetwork: *pulumi.String(_default.SelfLink),\n\t\t\tPeerNetwork: pulumi.All(testNetworkPeering.AtlasGcpProjectId, testNetworkPeering.AtlasVpcName).ApplyT(func(_args []interface{}) (string, error) {\n\t\t\t\tatlasGcpProjectId := _args[0].(string)\n\t\t\t\tatlasVpcName := _args[1].(string)\n\t\t\t\treturn fmt.Sprintf(\"https://www.googleapis.com/compute/v1/projects/%v/global/networks/%v\", atlasGcpProjectId, atlasVpcName), nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Cluster;\nimport com.pulumi.mongodbatlas.ClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.ClusterReplicationSpecArgs;\nimport com.pulumi.mongodbatlas.NetworkPeering;\nimport com.pulumi.mongodbatlas.NetworkPeeringArgs;\nimport com.pulumi.gcp.compute.ComputeFunctions;\nimport com.pulumi.gcp.compute.inputs.GetNetworkArgs;\nimport com.pulumi.gcp.compute.NetworkPeering;\nimport com.pulumi.gcp.compute.NetworkPeeringArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testCluster = new Cluster(\"testCluster\", ClusterArgs.builder()        \n            .projectId(local.project_id())\n            .diskSizeGb(5)\n            .clusterType(\"REPLICASET\")\n            .replicationSpecs(ClusterReplicationSpecArgs.builder()\n                .numShards(1)\n                .regionsConfigs(ClusterReplicationSpecRegionsConfigArgs.builder()\n                    .regionName(\"US_EAST_2\")\n                    .electableNodes(3)\n                    .priority(7)\n                    .readOnlyNodes(0)\n                    .build())\n                .build())\n            .autoScalingDiskGbEnabled(true)\n            .mongoDbMajorVersion(\"4.2\")\n            .providerName(\"GCP\")\n            .providerInstanceSizeName(\"M10\")\n            .build());\n\n        var testNetworkPeering = new NetworkPeering(\"testNetworkPeering\", NetworkPeeringArgs.builder()        \n            .projectId(local.project_id())\n            .atlasCidrBlock(\"192.168.0.0/18\")\n            .containerId(testCluster.containerId())\n            .providerName(\"GCP\")\n            .gcpProjectId(local.GCP_PROJECT_ID())\n            .networkName(\"default\")\n            .build());\n\n        final var default = ComputeFunctions.getNetwork(GetNetworkArgs.builder()\n            .name(\"default\")\n            .build());\n\n        var peering = new NetworkPeering(\"peering\", NetworkPeeringArgs.builder()        \n            .network(default_.selfLink())\n            .peerNetwork(Output.tuple(testNetworkPeering.atlasGcpProjectId(), testNetworkPeering.atlasVpcName()).applyValue(values -\u003e {\n                var atlasGcpProjectId = values.t1;\n                var atlasVpcName = values.t2;\n                return String.format(\"https://www.googleapis.com/compute/v1/projects/%s/global/networks/%s\", atlasGcpProjectId,atlasVpcName);\n            }))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Create an Atlas cluster, this creates a container if one\n  # does not yet exist for this GCP\n  testCluster:\n    type: mongodbatlas:Cluster\n    properties:\n      projectId: ${local.project_id}\n      diskSizeGb: 5\n      clusterType: REPLICASET\n      replicationSpecs:\n        - numShards: 1\n          regionsConfigs:\n            - regionName: US_EAST_2\n              electableNodes: 3\n              priority: 7\n              readOnlyNodes: 0\n      autoScalingDiskGbEnabled: true\n      mongoDbMajorVersion: '4.2'\n      # Provider Settings \"block\"\n      providerName: GCP\n      providerInstanceSizeName: M10\n  # Create the peering connection request\n  testNetworkPeering:\n    type: mongodbatlas:NetworkPeering\n    properties:\n      projectId: ${local.project_id}\n      atlasCidrBlock: 192.168.0.0/18\n      containerId: ${testCluster.containerId}\n      providerName: GCP\n      gcpProjectId: ${local.GCP_PROJECT_ID}\n      networkName: default\n  # Create the GCP peer\n  peering:\n    type: gcp:compute:NetworkPeering\n    properties:\n      network: ${default.selfLink}\n      peerNetwork: https://www.googleapis.com/compute/v1/projects/${testNetworkPeering.atlasGcpProjectId}/global/networks/${testNetworkPeering.atlasVpcName}\nvariables:\n  default:\n    fn::invoke:\n      Function: gcp:compute:getNetwork\n      Arguments:\n        name: default\n```\n{{% /example %}}\n{{% example %}}\n### Example with Azure\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\n// Ensure you have created the required Azure service principal first, see\n// see https://docs.atlas.mongodb.com/security-vpc-peering/\n// Create an Atlas cluster, this creates a container if one\n// does not yet exist for this AZURE region\nconst testCluster = new mongodbatlas.Cluster(\"testCluster\", {\n    projectId: local.project_id,\n    clusterType: \"REPLICASET\",\n    replicationSpecs: [{\n        numShards: 1,\n        regionsConfigs: [{\n            regionName: \"US_EAST_2\",\n            electableNodes: 3,\n            priority: 7,\n            readOnlyNodes: 0,\n        }],\n    }],\n    autoScalingDiskGbEnabled: false,\n    mongoDbMajorVersion: \"4.2\",\n    providerName: \"AZURE\",\n    providerInstanceSizeName: \"M10\",\n});\n// Create the peering connection request\nconst testNetworkPeering = new mongodbatlas.NetworkPeering(\"testNetworkPeering\", {\n    projectId: local.project_id,\n    containerId: testCluster.containerId,\n    providerName: \"AZURE\",\n    azureDirectoryId: local.AZURE_DIRECTORY_ID,\n    azureSubscriptionId: local.AZURE_SUBSCRIPTION_ID,\n    resourceGroupName: local.AZURE_RESOURCE_GROUP_NAME,\n    vnetName: local.AZURE_VNET_NAME,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\n# Ensure you have created the required Azure service principal first, see\n# see https://docs.atlas.mongodb.com/security-vpc-peering/\n# Create an Atlas cluster, this creates a container if one\n# does not yet exist for this AZURE region\ntest_cluster = mongodbatlas.Cluster(\"testCluster\",\n    project_id=local[\"project_id\"],\n    cluster_type=\"REPLICASET\",\n    replication_specs=[mongodbatlas.ClusterReplicationSpecArgs(\n        num_shards=1,\n        regions_configs=[mongodbatlas.ClusterReplicationSpecRegionsConfigArgs(\n            region_name=\"US_EAST_2\",\n            electable_nodes=3,\n            priority=7,\n            read_only_nodes=0,\n        )],\n    )],\n    auto_scaling_disk_gb_enabled=False,\n    mongo_db_major_version=\"4.2\",\n    provider_name=\"AZURE\",\n    provider_instance_size_name=\"M10\")\n# Create the peering connection request\ntest_network_peering = mongodbatlas.NetworkPeering(\"testNetworkPeering\",\n    project_id=local[\"project_id\"],\n    container_id=test_cluster.container_id,\n    provider_name=\"AZURE\",\n    azure_directory_id=local[\"AZURE_DIRECTORY_ID\"],\n    azure_subscription_id=local[\"AZURE_SUBSCRIPTION_ID\"],\n    resource_group_name=local[\"AZURE_RESOURCE_GROUP_NAME\"],\n    vnet_name=local[\"AZURE_VNET_NAME\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Ensure you have created the required Azure service principal first, see\n    // see https://docs.atlas.mongodb.com/security-vpc-peering/\n    // Create an Atlas cluster, this creates a container if one\n    // does not yet exist for this AZURE region\n    var testCluster = new Mongodbatlas.Cluster(\"testCluster\", new()\n    {\n        ProjectId = local.Project_id,\n        ClusterType = \"REPLICASET\",\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.ClusterReplicationSpecArgs\n            {\n                NumShards = 1,\n                RegionsConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.ClusterReplicationSpecRegionsConfigArgs\n                    {\n                        RegionName = \"US_EAST_2\",\n                        ElectableNodes = 3,\n                        Priority = 7,\n                        ReadOnlyNodes = 0,\n                    },\n                },\n            },\n        },\n        AutoScalingDiskGbEnabled = false,\n        MongoDbMajorVersion = \"4.2\",\n        ProviderName = \"AZURE\",\n        ProviderInstanceSizeName = \"M10\",\n    });\n\n    // Create the peering connection request\n    var testNetworkPeering = new Mongodbatlas.NetworkPeering(\"testNetworkPeering\", new()\n    {\n        ProjectId = local.Project_id,\n        ContainerId = testCluster.ContainerId,\n        ProviderName = \"AZURE\",\n        AzureDirectoryId = local.AZURE_DIRECTORY_ID,\n        AzureSubscriptionId = local.AZURE_SUBSCRIPTION_ID,\n        ResourceGroupName = local.AZURE_RESOURCE_GROUP_NAME,\n        VnetName = local.AZURE_VNET_NAME,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestCluster, err := mongodbatlas.NewCluster(ctx, \"testCluster\", \u0026mongodbatlas.ClusterArgs{\n\t\t\tProjectId:   pulumi.Any(local.Project_id),\n\t\t\tClusterType: pulumi.String(\"REPLICASET\"),\n\t\t\tReplicationSpecs: mongodbatlas.ClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecArgs{\n\t\t\t\t\tNumShards: pulumi.Int(1),\n\t\t\t\t\tRegionsConfigs: mongodbatlas.ClusterReplicationSpecRegionsConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecRegionsConfigArgs{\n\t\t\t\t\t\t\tRegionName:     pulumi.String(\"US_EAST_2\"),\n\t\t\t\t\t\t\tElectableNodes: pulumi.Int(3),\n\t\t\t\t\t\t\tPriority:       pulumi.Int(7),\n\t\t\t\t\t\t\tReadOnlyNodes:  pulumi.Int(0),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tAutoScalingDiskGbEnabled: pulumi.Bool(false),\n\t\t\tMongoDbMajorVersion:      pulumi.String(\"4.2\"),\n\t\t\tProviderName:             pulumi.String(\"AZURE\"),\n\t\t\tProviderInstanceSizeName: pulumi.String(\"M10\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewNetworkPeering(ctx, \"testNetworkPeering\", \u0026mongodbatlas.NetworkPeeringArgs{\n\t\t\tProjectId:           pulumi.Any(local.Project_id),\n\t\t\tContainerId:         testCluster.ContainerId,\n\t\t\tProviderName:        pulumi.String(\"AZURE\"),\n\t\t\tAzureDirectoryId:    pulumi.Any(local.AZURE_DIRECTORY_ID),\n\t\t\tAzureSubscriptionId: pulumi.Any(local.AZURE_SUBSCRIPTION_ID),\n\t\t\tResourceGroupName:   pulumi.Any(local.AZURE_RESOURCE_GROUP_NAME),\n\t\t\tVnetName:            pulumi.Any(local.AZURE_VNET_NAME),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Cluster;\nimport com.pulumi.mongodbatlas.ClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.ClusterReplicationSpecArgs;\nimport com.pulumi.mongodbatlas.NetworkPeering;\nimport com.pulumi.mongodbatlas.NetworkPeeringArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testCluster = new Cluster(\"testCluster\", ClusterArgs.builder()        \n            .projectId(local.project_id())\n            .clusterType(\"REPLICASET\")\n            .replicationSpecs(ClusterReplicationSpecArgs.builder()\n                .numShards(1)\n                .regionsConfigs(ClusterReplicationSpecRegionsConfigArgs.builder()\n                    .regionName(\"US_EAST_2\")\n                    .electableNodes(3)\n                    .priority(7)\n                    .readOnlyNodes(0)\n                    .build())\n                .build())\n            .autoScalingDiskGbEnabled(false)\n            .mongoDbMajorVersion(\"4.2\")\n            .providerName(\"AZURE\")\n            .providerInstanceSizeName(\"M10\")\n            .build());\n\n        var testNetworkPeering = new NetworkPeering(\"testNetworkPeering\", NetworkPeeringArgs.builder()        \n            .projectId(local.project_id())\n            .containerId(testCluster.containerId())\n            .providerName(\"AZURE\")\n            .azureDirectoryId(local.AZURE_DIRECTORY_ID())\n            .azureSubscriptionId(local.AZURE_SUBSCRIPTION_ID())\n            .resourceGroupName(local.AZURE_RESOURCE_GROUP_NAME())\n            .vnetName(local.AZURE_VNET_NAME())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Ensure you have created the required Azure service principal first, see\n  # see https://docs.atlas.mongodb.com/security-vpc-peering/\n\n  # Create an Atlas cluster, this creates a container if one\n  # does not yet exist for this AZURE region\n  testCluster:\n    type: mongodbatlas:Cluster\n    properties:\n      projectId: ${local.project_id}\n      clusterType: REPLICASET\n      replicationSpecs:\n        - numShards: 1\n          regionsConfigs:\n            - regionName: US_EAST_2\n              electableNodes: 3\n              priority: 7\n              readOnlyNodes: 0\n      autoScalingDiskGbEnabled: false\n      mongoDbMajorVersion: '4.2'\n      # Provider Settings \"block\"\n      providerName: AZURE\n      providerInstanceSizeName: M10\n  # Create the peering connection request\n  testNetworkPeering:\n    type: mongodbatlas:NetworkPeering\n    properties:\n      projectId: ${local.project_id}\n      containerId: ${testCluster.containerId}\n      providerName: AZURE\n      azureDirectoryId: ${local.AZURE_DIRECTORY_ID}\n      azureSubscriptionId: ${local.AZURE_SUBSCRIPTION_ID}\n      resourceGroupName: ${local.AZURE_RESOURCE_GROUP_NAME}\n      vnetName: ${local.AZURE_VNET_NAME}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nClusters can be imported using project ID and network peering id, in the format `PROJECTID-PEERID-PROVIDERNAME`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/networkPeering:NetworkPeering my_peering 1112222b3bf99403840e8934-5cbf563d87d9d67253be590a-AWS\n```\n\n See detailed information for arguments and attributes[MongoDB API Network Peering Connection](https://docs.atlas.mongodb.com/reference/api/vpc-create-peering-connection/) ",
            "properties": {
                "accepterRegionName": {
                    "type": "string",
                    "description": "Specifies the AWS region where the peer VPC resides. For complete lists of supported regions, see [Amazon Web Services](https://docs.atlas.mongodb.com/reference/amazon-aws/).\n"
                },
                "atlasCidrBlock": {
                    "type": "string"
                },
                "atlasGcpProjectId": {
                    "type": "string",
                    "description": "The Atlas GCP Project ID for the GCP VPC used by your atlas cluster that it is need to set up the reciprocal connection.\n"
                },
                "atlasId": {
                    "type": "string"
                },
                "atlasVpcName": {
                    "type": "string"
                },
                "awsAccountId": {
                    "type": "string",
                    "description": "AWS Account ID of the owner of the peer VPC.\n"
                },
                "azureDirectoryId": {
                    "type": "string",
                    "description": "Unique identifier for an Azure AD directory.\n"
                },
                "azureSubscriptionId": {
                    "type": "string",
                    "description": "Unique identifier of the Azure subscription in which the VNet resides.\n"
                },
                "connectionId": {
                    "type": "string",
                    "description": "Unique identifier of the Atlas network peering container.\n"
                },
                "containerId": {
                    "type": "string",
                    "description": "Unique identifier of the MongoDB Atlas container for the provider (GCP) or provider/region (AWS, AZURE). You can create an MongoDB Atlas container using the network_container resource or it can be obtained from the cluster returned values if a cluster has been created before the first container.\n"
                },
                "errorMessage": {
                    "type": "string",
                    "description": "When `\"status\" : \"FAILED\"`, Atlas provides a description of the error.\n"
                },
                "errorState": {
                    "type": "string",
                    "description": "Description of the Atlas error when `status` is `Failed`, Otherwise, Atlas returns `null`.\n"
                },
                "errorStateName": {
                    "type": "string",
                    "description": "Error state, if any. The VPC peering connection error state value can be one of the following: `REJECTED`, `EXPIRED`, `INVALID_ARGUMENT`.\n"
                },
                "gcpProjectId": {
                    "type": "string",
                    "description": "GCP project ID of the owner of the network peer.\n"
                },
                "networkName": {
                    "type": "string",
                    "description": "Name of the network peer to which Atlas connects.\n"
                },
                "peerId": {
                    "type": "string",
                    "description": "Unique identifier of the Atlas network peer.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the MongoDB Atlas project to create the database user.\n"
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud provider to whom the peering connection is being made. (Possible Values `AWS`, `AZURE`, `GCP`).\n"
                },
                "resourceGroupName": {
                    "type": "string",
                    "description": "Name of your Azure resource group.\n"
                },
                "routeTableCidrBlock": {
                    "type": "string",
                    "description": "AWS VPC CIDR block or subnet.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Status of the Atlas network peering connection.  Azure/GCP: `ADDING_PEER`, `AVAILABLE`, `FAILED`, `DELETING` GCP Only:  `WAITING_FOR_USER`.\n"
                },
                "statusName": {
                    "type": "string",
                    "description": "(AWS Only) The VPC peering connection status value can be one of the following: `INITIATING`, `PENDING_ACCEPTANCE`, `FAILED`, `FINALIZING`, `AVAILABLE`, `TERMINATING`.\n"
                },
                "vnetName": {
                    "type": "string",
                    "description": "Name of your Azure VNet.\n"
                },
                "vpcId": {
                    "type": "string",
                    "description": "Unique identifier of the AWS peer VPC (Note: this is **not** the same as the Atlas AWS VPC that is returned by the network_container resource).\n"
                }
            },
            "required": [
                "accepterRegionName",
                "atlasCidrBlock",
                "atlasGcpProjectId",
                "atlasId",
                "atlasVpcName",
                "awsAccountId",
                "azureDirectoryId",
                "azureSubscriptionId",
                "connectionId",
                "containerId",
                "errorMessage",
                "errorState",
                "errorStateName",
                "gcpProjectId",
                "networkName",
                "peerId",
                "projectId",
                "providerName",
                "resourceGroupName",
                "routeTableCidrBlock",
                "status",
                "statusName",
                "vnetName",
                "vpcId"
            ],
            "inputProperties": {
                "accepterRegionName": {
                    "type": "string",
                    "description": "Specifies the AWS region where the peer VPC resides. For complete lists of supported regions, see [Amazon Web Services](https://docs.atlas.mongodb.com/reference/amazon-aws/).\n"
                },
                "atlasCidrBlock": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "atlasGcpProjectId": {
                    "type": "string",
                    "description": "The Atlas GCP Project ID for the GCP VPC used by your atlas cluster that it is need to set up the reciprocal connection.\n"
                },
                "atlasVpcName": {
                    "type": "string"
                },
                "awsAccountId": {
                    "type": "string",
                    "description": "AWS Account ID of the owner of the peer VPC.\n"
                },
                "azureDirectoryId": {
                    "type": "string",
                    "description": "Unique identifier for an Azure AD directory.\n"
                },
                "azureSubscriptionId": {
                    "type": "string",
                    "description": "Unique identifier of the Azure subscription in which the VNet resides.\n"
                },
                "containerId": {
                    "type": "string",
                    "description": "Unique identifier of the MongoDB Atlas container for the provider (GCP) or provider/region (AWS, AZURE). You can create an MongoDB Atlas container using the network_container resource or it can be obtained from the cluster returned values if a cluster has been created before the first container.\n",
                    "willReplaceOnChanges": true
                },
                "gcpProjectId": {
                    "type": "string",
                    "description": "GCP project ID of the owner of the network peer.\n"
                },
                "networkName": {
                    "type": "string",
                    "description": "Name of the network peer to which Atlas connects.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the MongoDB Atlas project to create the database user.\n",
                    "willReplaceOnChanges": true
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud provider to whom the peering connection is being made. (Possible Values `AWS`, `AZURE`, `GCP`).\n"
                },
                "resourceGroupName": {
                    "type": "string",
                    "description": "Name of your Azure resource group.\n"
                },
                "routeTableCidrBlock": {
                    "type": "string",
                    "description": "AWS VPC CIDR block or subnet.\n"
                },
                "vnetName": {
                    "type": "string",
                    "description": "Name of your Azure VNet.\n"
                },
                "vpcId": {
                    "type": "string",
                    "description": "Unique identifier of the AWS peer VPC (Note: this is **not** the same as the Atlas AWS VPC that is returned by the network_container resource).\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "containerId",
                "projectId",
                "providerName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NetworkPeering resources.\n",
                "properties": {
                    "accepterRegionName": {
                        "type": "string",
                        "description": "Specifies the AWS region where the peer VPC resides. For complete lists of supported regions, see [Amazon Web Services](https://docs.atlas.mongodb.com/reference/amazon-aws/).\n"
                    },
                    "atlasCidrBlock": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "atlasGcpProjectId": {
                        "type": "string",
                        "description": "The Atlas GCP Project ID for the GCP VPC used by your atlas cluster that it is need to set up the reciprocal connection.\n"
                    },
                    "atlasId": {
                        "type": "string"
                    },
                    "atlasVpcName": {
                        "type": "string"
                    },
                    "awsAccountId": {
                        "type": "string",
                        "description": "AWS Account ID of the owner of the peer VPC.\n"
                    },
                    "azureDirectoryId": {
                        "type": "string",
                        "description": "Unique identifier for an Azure AD directory.\n"
                    },
                    "azureSubscriptionId": {
                        "type": "string",
                        "description": "Unique identifier of the Azure subscription in which the VNet resides.\n"
                    },
                    "connectionId": {
                        "type": "string",
                        "description": "Unique identifier of the Atlas network peering container.\n"
                    },
                    "containerId": {
                        "type": "string",
                        "description": "Unique identifier of the MongoDB Atlas container for the provider (GCP) or provider/region (AWS, AZURE). You can create an MongoDB Atlas container using the network_container resource or it can be obtained from the cluster returned values if a cluster has been created before the first container.\n",
                        "willReplaceOnChanges": true
                    },
                    "errorMessage": {
                        "type": "string",
                        "description": "When `\"status\" : \"FAILED\"`, Atlas provides a description of the error.\n"
                    },
                    "errorState": {
                        "type": "string",
                        "description": "Description of the Atlas error when `status` is `Failed`, Otherwise, Atlas returns `null`.\n"
                    },
                    "errorStateName": {
                        "type": "string",
                        "description": "Error state, if any. The VPC peering connection error state value can be one of the following: `REJECTED`, `EXPIRED`, `INVALID_ARGUMENT`.\n"
                    },
                    "gcpProjectId": {
                        "type": "string",
                        "description": "GCP project ID of the owner of the network peer.\n"
                    },
                    "networkName": {
                        "type": "string",
                        "description": "Name of the network peer to which Atlas connects.\n"
                    },
                    "peerId": {
                        "type": "string",
                        "description": "Unique identifier of the Atlas network peer.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the MongoDB Atlas project to create the database user.\n",
                        "willReplaceOnChanges": true
                    },
                    "providerName": {
                        "type": "string",
                        "description": "Cloud provider to whom the peering connection is being made. (Possible Values `AWS`, `AZURE`, `GCP`).\n"
                    },
                    "resourceGroupName": {
                        "type": "string",
                        "description": "Name of your Azure resource group.\n"
                    },
                    "routeTableCidrBlock": {
                        "type": "string",
                        "description": "AWS VPC CIDR block or subnet.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Status of the Atlas network peering connection.  Azure/GCP: `ADDING_PEER`, `AVAILABLE`, `FAILED`, `DELETING` GCP Only:  `WAITING_FOR_USER`.\n"
                    },
                    "statusName": {
                        "type": "string",
                        "description": "(AWS Only) The VPC peering connection status value can be one of the following: `INITIATING`, `PENDING_ACCEPTANCE`, `FAILED`, `FINALIZING`, `AVAILABLE`, `TERMINATING`.\n"
                    },
                    "vnetName": {
                        "type": "string",
                        "description": "Name of your Azure VNet.\n"
                    },
                    "vpcId": {
                        "type": "string",
                        "description": "Unique identifier of the AWS peer VPC (Note: this is **not** the same as the Atlas AWS VPC that is returned by the network_container resource).\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/onlineArchive:OnlineArchive": {
            "description": "`mongodbatlas.OnlineArchive` resource provides access to create, edit, pause and resume an online archive for a collection. \n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n\u003e **IMPORTANT:** The collection must exists before performing an online archive.\n\n\u003e **IMPORTANT:** There are fields that are immutable after creation, i.e if `date_field` value does not exist in the collection, the online archive state will be pending forever, and this field cannot be updated, that means a destroy is required, known error `ONLINE_ARCHIVE_CANNOT_MODIFY_FIELD`\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### S\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.OnlineArchive(\"test\", {\n    projectId: _var.project_id,\n    clusterName: _var.cluster_name,\n    collName: _var.collection_name,\n    dbName: _var.database_name,\n    partitionFields: [\n        {\n            fieldName: \"firstName\",\n            order: 0,\n        },\n        {\n            fieldName: \"lastName\",\n            order: 1,\n        },\n    ],\n    criteria: {\n        type: \"DATE\",\n        dateField: \"created\",\n        expireAfterDays: 5,\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.OnlineArchive(\"test\",\n    project_id=var[\"project_id\"],\n    cluster_name=var[\"cluster_name\"],\n    coll_name=var[\"collection_name\"],\n    db_name=var[\"database_name\"],\n    partition_fields=[\n        mongodbatlas.OnlineArchivePartitionFieldArgs(\n            field_name=\"firstName\",\n            order=0,\n        ),\n        mongodbatlas.OnlineArchivePartitionFieldArgs(\n            field_name=\"lastName\",\n            order=1,\n        ),\n    ],\n    criteria=mongodbatlas.OnlineArchiveCriteriaArgs(\n        type=\"DATE\",\n        date_field=\"created\",\n        expire_after_days=5,\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.OnlineArchive(\"test\", new()\n    {\n        ProjectId = @var.Project_id,\n        ClusterName = @var.Cluster_name,\n        CollName = @var.Collection_name,\n        DbName = @var.Database_name,\n        PartitionFields = new[]\n        {\n            new Mongodbatlas.Inputs.OnlineArchivePartitionFieldArgs\n            {\n                FieldName = \"firstName\",\n                Order = 0,\n            },\n            new Mongodbatlas.Inputs.OnlineArchivePartitionFieldArgs\n            {\n                FieldName = \"lastName\",\n                Order = 1,\n            },\n        },\n        Criteria = new Mongodbatlas.Inputs.OnlineArchiveCriteriaArgs\n        {\n            Type = \"DATE\",\n            DateField = \"created\",\n            ExpireAfterDays = 5,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewOnlineArchive(ctx, \"test\", \u0026mongodbatlas.OnlineArchiveArgs{\n\t\t\tProjectId:   pulumi.Any(_var.Project_id),\n\t\t\tClusterName: pulumi.Any(_var.Cluster_name),\n\t\t\tCollName:    pulumi.Any(_var.Collection_name),\n\t\t\tDbName:      pulumi.Any(_var.Database_name),\n\t\t\tPartitionFields: mongodbatlas.OnlineArchivePartitionFieldArray{\n\t\t\t\t\u0026mongodbatlas.OnlineArchivePartitionFieldArgs{\n\t\t\t\t\tFieldName: pulumi.String(\"firstName\"),\n\t\t\t\t\tOrder:     pulumi.Int(0),\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.OnlineArchivePartitionFieldArgs{\n\t\t\t\t\tFieldName: pulumi.String(\"lastName\"),\n\t\t\t\t\tOrder:     pulumi.Int(1),\n\t\t\t\t},\n\t\t\t},\n\t\t\tCriteria: \u0026mongodbatlas.OnlineArchiveCriteriaArgs{\n\t\t\t\tType:            pulumi.String(\"DATE\"),\n\t\t\t\tDateField:       pulumi.String(\"created\"),\n\t\t\t\tExpireAfterDays: pulumi.Int(5),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.OnlineArchive;\nimport com.pulumi.mongodbatlas.OnlineArchiveArgs;\nimport com.pulumi.mongodbatlas.inputs.OnlineArchivePartitionFieldArgs;\nimport com.pulumi.mongodbatlas.inputs.OnlineArchiveCriteriaArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new OnlineArchive(\"test\", OnlineArchiveArgs.builder()        \n            .projectId(var_.project_id())\n            .clusterName(var_.cluster_name())\n            .collName(var_.collection_name())\n            .dbName(var_.database_name())\n            .partitionFields(            \n                OnlineArchivePartitionFieldArgs.builder()\n                    .fieldName(\"firstName\")\n                    .order(0)\n                    .build(),\n                OnlineArchivePartitionFieldArgs.builder()\n                    .fieldName(\"lastName\")\n                    .order(1)\n                    .build())\n            .criteria(OnlineArchiveCriteriaArgs.builder()\n                .type(\"DATE\")\n                .dateField(\"created\")\n                .expireAfterDays(5)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:OnlineArchive\n    properties:\n      projectId: ${var.project_id}\n      clusterName: ${var.cluster_name}\n      collName: ${var.collection_name}\n      dbName: ${var.database_name}\n      partitionFields:\n        - fieldName: firstName\n          order: 0\n        - fieldName: lastName\n          order: 1\n      criteria:\n        type: DATE\n        dateField: created\n        expireAfterDays: 5\n```\n\nFor custom criteria example\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.OnlineArchive;\nimport com.pulumi.mongodbatlas.OnlineArchiveArgs;\nimport com.pulumi.mongodbatlas.inputs.OnlineArchivePartitionFieldArgs;\nimport com.pulumi.mongodbatlas.inputs.OnlineArchiveCriteriaArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new OnlineArchive(\"test\", OnlineArchiveArgs.builder()        \n            .projectId(var_.project_id())\n            .clusterName(var_.cluster_name())\n            .collName(var_.collection_name())\n            .dbName(var_.database_name())\n            .partitionFields(OnlineArchivePartitionFieldArgs.builder()\n                .fieldName(\"firstName\")\n                .order(0)\n                .build())\n            .partitionsFields(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n            .criteria(OnlineArchiveCriteriaArgs.builder()\n                .type(\"CUSTOM\")\n                .query(\"{ \\\"department\\\": \\\"engineering\\\" }\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:OnlineArchive\n    properties:\n      projectId: ${var.project_id}\n      clusterName: ${var.cluster_name}\n      collName: ${var.collection_name}\n      dbName: ${var.database_name}\n      partitionFields:\n        - fieldName: firstName\n          order: 0\n      partitionsFields:\n        - fieldName: secondName\n          order: 1\n      criteria:\n        type: CUSTOM\n        query: '{ \"department\": \"engineering\" }'\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "archiveId": {
                    "type": "string",
                    "description": "ID of the online archive.\n"
                },
                "clusterName": {
                    "type": "string",
                    "description": "Name of the cluster that contains the collection.\n"
                },
                "collName": {
                    "type": "string",
                    "description": "Name of the collection.\n"
                },
                "criteria": {
                    "$ref": "#/types/mongodbatlas:index/OnlineArchiveCriteria:OnlineArchiveCriteria",
                    "description": "Criteria to use for archiving data.\n"
                },
                "dbName": {
                    "type": "string",
                    "description": "Name of the database that contains the collection.\n"
                },
                "partitionFields": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/OnlineArchivePartitionField:OnlineArchivePartitionField"
                    },
                    "description": "Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Note that queries that don’t contain the specified fields will require a full collection scan of all archived documents, which will take longer and increase your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "State of the online archive. This is required for pausing an active or resume a paused online archive. The resume request will fail if the collection has another active online archive.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project\n"
                },
                "state": {
                    "type": "string",
                    "description": "Status of the online archive. Valid values are: Pending, Archiving, Idle, Pausing, Paused, Orphaned and Deleted\n"
                },
                "syncCreation": {
                    "type": "boolean"
                }
            },
            "required": [
                "archiveId",
                "clusterName",
                "collName",
                "criteria",
                "dbName",
                "partitionFields",
                "paused",
                "projectId",
                "state"
            ],
            "inputProperties": {
                "clusterName": {
                    "type": "string",
                    "description": "Name of the cluster that contains the collection.\n",
                    "willReplaceOnChanges": true
                },
                "collName": {
                    "type": "string",
                    "description": "Name of the collection.\n"
                },
                "criteria": {
                    "$ref": "#/types/mongodbatlas:index/OnlineArchiveCriteria:OnlineArchiveCriteria",
                    "description": "Criteria to use for archiving data.\n"
                },
                "dbName": {
                    "type": "string",
                    "description": "Name of the database that contains the collection.\n"
                },
                "partitionFields": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/OnlineArchivePartitionField:OnlineArchivePartitionField"
                    },
                    "description": "Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Note that queries that don’t contain the specified fields will require a full collection scan of all archived documents, which will take longer and increase your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "State of the online archive. This is required for pausing an active or resume a paused online archive. The resume request will fail if the collection has another active online archive.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project\n",
                    "willReplaceOnChanges": true
                },
                "syncCreation": {
                    "type": "boolean"
                }
            },
            "requiredInputs": [
                "clusterName",
                "collName",
                "criteria",
                "dbName",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OnlineArchive resources.\n",
                "properties": {
                    "archiveId": {
                        "type": "string",
                        "description": "ID of the online archive.\n"
                    },
                    "clusterName": {
                        "type": "string",
                        "description": "Name of the cluster that contains the collection.\n",
                        "willReplaceOnChanges": true
                    },
                    "collName": {
                        "type": "string",
                        "description": "Name of the collection.\n"
                    },
                    "criteria": {
                        "$ref": "#/types/mongodbatlas:index/OnlineArchiveCriteria:OnlineArchiveCriteria",
                        "description": "Criteria to use for archiving data.\n"
                    },
                    "dbName": {
                        "type": "string",
                        "description": "Name of the database that contains the collection.\n"
                    },
                    "partitionFields": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/OnlineArchivePartitionField:OnlineArchivePartitionField"
                        },
                        "description": "Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Note that queries that don’t contain the specified fields will require a full collection scan of all archived documents, which will take longer and increase your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived.\n"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "State of the online archive. This is required for pausing an active or resume a paused online archive. The resume request will fail if the collection has another active online archive.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project\n",
                        "willReplaceOnChanges": true
                    },
                    "state": {
                        "type": "string",
                        "description": "Status of the online archive. Valid values are: Pending, Archiving, Idle, Pausing, Paused, Orphaned and Deleted\n"
                    },
                    "syncCreation": {
                        "type": "boolean"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/orgInvitation:OrgInvitation": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n### S\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test0 = new mongodbatlas.OrgInvitation(\"test0\", {\n    orgId: \"\u003cORG-ID\u003e\",\n    roles: [\"ORG_OWNER\"],\n    username: \"test0-acc-username\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest0 = mongodbatlas.OrgInvitation(\"test0\",\n    org_id=\"\u003cORG-ID\u003e\",\n    roles=[\"ORG_OWNER\"],\n    username=\"test0-acc-username\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test0 = new Mongodbatlas.OrgInvitation(\"test0\", new()\n    {\n        OrgId = \"\u003cORG-ID\u003e\",\n        Roles = new[]\n        {\n            \"ORG_OWNER\",\n        },\n        Username = \"test0-acc-username\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewOrgInvitation(ctx, \"test0\", \u0026mongodbatlas.OrgInvitationArgs{\n\t\t\tOrgId: pulumi.String(\"\u003cORG-ID\u003e\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"ORG_OWNER\"),\n\t\t\t},\n\t\t\tUsername: pulumi.String(\"test0-acc-username\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.OrgInvitation;\nimport com.pulumi.mongodbatlas.OrgInvitationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test0 = new OrgInvitation(\"test0\", OrgInvitationArgs.builder()        \n            .orgId(\"\u003cORG-ID\u003e\")\n            .roles(\"ORG_OWNER\")\n            .username(\"test0-acc-username\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test0:\n    type: mongodbatlas:OrgInvitation\n    properties:\n      orgId: \u003cORG-ID\u003e\n      roles:\n        - ORG_OWNER\n      username: test0-acc-username\n```\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test0 = new mongodbatlas.OrgInvitation(\"test0\", {\n    orgId: \"\u003cORG-ID\u003e\",\n    roles: [\n        \"ORG_MEMBER\",\n        \"ORG_BILLING_ADMIN\",\n    ],\n    username: \"test0-acc-username\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest0 = mongodbatlas.OrgInvitation(\"test0\",\n    org_id=\"\u003cORG-ID\u003e\",\n    roles=[\n        \"ORG_MEMBER\",\n        \"ORG_BILLING_ADMIN\",\n    ],\n    username=\"test0-acc-username\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test0 = new Mongodbatlas.OrgInvitation(\"test0\", new()\n    {\n        OrgId = \"\u003cORG-ID\u003e\",\n        Roles = new[]\n        {\n            \"ORG_MEMBER\",\n            \"ORG_BILLING_ADMIN\",\n        },\n        Username = \"test0-acc-username\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewOrgInvitation(ctx, \"test0\", \u0026mongodbatlas.OrgInvitationArgs{\n\t\t\tOrgId: pulumi.String(\"\u003cORG-ID\u003e\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"ORG_MEMBER\"),\n\t\t\t\tpulumi.String(\"ORG_BILLING_ADMIN\"),\n\t\t\t},\n\t\t\tUsername: pulumi.String(\"test0-acc-username\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.OrgInvitation;\nimport com.pulumi.mongodbatlas.OrgInvitationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test0 = new OrgInvitation(\"test0\", OrgInvitationArgs.builder()        \n            .orgId(\"\u003cORG-ID\u003e\")\n            .roles(            \n                \"ORG_MEMBER\",\n                \"ORG_BILLING_ADMIN\")\n            .username(\"test0-acc-username\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test0:\n    type: mongodbatlas:OrgInvitation\n    properties:\n      orgId: \u003cORG-ID\u003e\n      roles:\n        - ORG_MEMBER\n        - ORG_BILLING_ADMIN\n      username: test0-acc-username\n```\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test1 = new mongodbatlas.OrgInvitation(\"test1\", {\n    orgId: \"\u003cORG-ID\u003e\",\n    roles: [\"ORG_MEMBER\"],\n    teamsIds: [\n        \"\u003cTEAM-0-ID\u003e\",\n        \"\u003cTEAM-1-ID\u003e\",\n    ],\n    username: \"test1-acc-username\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest1 = mongodbatlas.OrgInvitation(\"test1\",\n    org_id=\"\u003cORG-ID\u003e\",\n    roles=[\"ORG_MEMBER\"],\n    teams_ids=[\n        \"\u003cTEAM-0-ID\u003e\",\n        \"\u003cTEAM-1-ID\u003e\",\n    ],\n    username=\"test1-acc-username\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test1 = new Mongodbatlas.OrgInvitation(\"test1\", new()\n    {\n        OrgId = \"\u003cORG-ID\u003e\",\n        Roles = new[]\n        {\n            \"ORG_MEMBER\",\n        },\n        TeamsIds = new[]\n        {\n            \"\u003cTEAM-0-ID\u003e\",\n            \"\u003cTEAM-1-ID\u003e\",\n        },\n        Username = \"test1-acc-username\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewOrgInvitation(ctx, \"test1\", \u0026mongodbatlas.OrgInvitationArgs{\n\t\t\tOrgId: pulumi.String(\"\u003cORG-ID\u003e\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"ORG_MEMBER\"),\n\t\t\t},\n\t\t\tTeamsIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"\u003cTEAM-0-ID\u003e\"),\n\t\t\t\tpulumi.String(\"\u003cTEAM-1-ID\u003e\"),\n\t\t\t},\n\t\t\tUsername: pulumi.String(\"test1-acc-username\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.OrgInvitation;\nimport com.pulumi.mongodbatlas.OrgInvitationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test1 = new OrgInvitation(\"test1\", OrgInvitationArgs.builder()        \n            .orgId(\"\u003cORG-ID\u003e\")\n            .roles(\"ORG_MEMBER\")\n            .teamsIds(            \n                \"\u003cTEAM-0-ID\u003e\",\n                \"\u003cTEAM-1-ID\u003e\")\n            .username(\"test1-acc-username\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test1:\n    type: mongodbatlas:OrgInvitation\n    properties:\n      orgId: \u003cORG-ID\u003e\n      roles:\n        - ORG_MEMBER\n      teamsIds:\n        - \u003cTEAM-0-ID\u003e\n        - \u003cTEAM-1-ID\u003e\n      username: test1-acc-username\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n~\u003e **IMPORTANT:** An organization invitation can **not** be imported once it has been accepted. Import a user's invitation to an organization by separating the `org_id` and the `username` with a hyphen\n\n```sh\n $ pulumi import mongodbatlas:index/orgInvitation:OrgInvitation my_user 1112222b3bf99403840e8934-my_user@mongodb.com\n```\n\n ",
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when Atlas sent the invitation.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when the invitation expires. Users have 30 days to accept an invitation.\n"
                },
                "invitationId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the invitation in Atlas.\n"
                },
                "inviterUsername": {
                    "type": "string",
                    "description": "Atlas user who invited `username` to the organization.\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization to which you want to invite a user.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Atlas roles to assign to the invited user. If the user accepts the invitation, Atlas assigns these roles to them. The following options are available:\n* ORG_OWNER\n* ORG_GROUP_CREATOR\n* ORG_BILLING_ADMIN\n* ORG_READ_ONLY\n* ORG_MEMBER\n"
                },
                "teamsIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of unique 24-hexadecimal digit strings that identify the teams that the user was invited to join.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Email address of the invited user. This is the address to which Atlas sends the invite. If the user accepts the invitation, they log in to Atlas with this username.\n"
                }
            },
            "required": [
                "createdAt",
                "expiresAt",
                "invitationId",
                "inviterUsername",
                "orgId",
                "roles",
                "username"
            ],
            "inputProperties": {
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization to which you want to invite a user.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Atlas roles to assign to the invited user. If the user accepts the invitation, Atlas assigns these roles to them. The following options are available:\n* ORG_OWNER\n* ORG_GROUP_CREATOR\n* ORG_BILLING_ADMIN\n* ORG_READ_ONLY\n* ORG_MEMBER\n"
                },
                "teamsIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of unique 24-hexadecimal digit strings that identify the teams that the user was invited to join.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Email address of the invited user. This is the address to which Atlas sends the invite. If the user accepts the invitation, they log in to Atlas with this username.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "orgId",
                "roles",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OrgInvitation resources.\n",
                "properties": {
                    "createdAt": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when Atlas sent the invitation.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when the invitation expires. Users have 30 days to accept an invitation.\n"
                    },
                    "invitationId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the invitation in Atlas.\n"
                    },
                    "inviterUsername": {
                        "type": "string",
                        "description": "Atlas user who invited `username` to the organization.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the organization to which you want to invite a user.\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Atlas roles to assign to the invited user. If the user accepts the invitation, Atlas assigns these roles to them. The following options are available:\n* ORG_OWNER\n* ORG_GROUP_CREATOR\n* ORG_BILLING_ADMIN\n* ORG_READ_ONLY\n* ORG_MEMBER\n"
                    },
                    "teamsIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of unique 24-hexadecimal digit strings that identify the teams that the user was invited to join.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Email address of the invited user. This is the address to which Atlas sends the invite. If the user accepts the invitation, they log in to Atlas with this username.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/privateEndpointRegionalMode:PrivateEndpointRegionalMode": {
            "description": "\n\n\n## Import\n\nPrivate Endpoint Regional Mode can be imported using project id in format `{project_id}`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/privateEndpointRegionalMode:PrivateEndpointRegionalMode test 1112222b3bf99403840e8934\n```\n\n See detailed information for arguments and attributes**Private Endpoints** [Get Regional Mode](https://www.mongodb.com/docs/atlas/reference/api/private-endpoints-get-regional-mode/) | [Update Regional Mode](https://www.mongodb.com/docs/atlas/reference/api/private-endpoints-update-regional-mode/) ",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the regionalized private endpoint setting is enabled for the project.   Set this value to true to create more than one private endpoint in a cloud provider region to connect to multi-region and global Atlas sharded clusters. You can enable this setting only if your Atlas project contains no replica sets. You can't disable this setting if you have:\n* More than one private endpoint in more than one region, or\n* More than one private endpoint in one region and one private endpoint in one or more regions.\nYou can create only sharded clusters when you enable the regionalized private endpoint setting. You can't create replica sets.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique identifier for the project.\n"
                }
            },
            "required": [
                "projectId"
            ],
            "inputProperties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the regionalized private endpoint setting is enabled for the project.   Set this value to true to create more than one private endpoint in a cloud provider region to connect to multi-region and global Atlas sharded clusters. You can enable this setting only if your Atlas project contains no replica sets. You can't disable this setting if you have:\n* More than one private endpoint in more than one region, or\n* More than one private endpoint in one region and one private endpoint in one or more regions.\nYou can create only sharded clusters when you enable the regionalized private endpoint setting. You can't create replica sets.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique identifier for the project.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PrivateEndpointRegionalMode resources.\n",
                "properties": {
                    "enabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether the regionalized private endpoint setting is enabled for the project.   Set this value to true to create more than one private endpoint in a cloud provider region to connect to multi-region and global Atlas sharded clusters. You can enable this setting only if your Atlas project contains no replica sets. You can't disable this setting if you have:\n* More than one private endpoint in more than one region, or\n* More than one private endpoint in one region and one private endpoint in one or more regions.\nYou can create only sharded clusters when you enable the regionalized private endpoint setting. You can't create replica sets.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique identifier for the project.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/privateIpMode:PrivateIpMode": {
            "description": "`mongodbatlas.PrivateIpMode` provides a Private IP Mode resource. This allows one to disable Connect via Peering Only mode for a MongoDB Atlas Project.\n\n\u003e **Deprecated Feature**: \u003cbr\u003e This feature has been deprecated. Use [Split Horizon connection strings](https://dochub.mongodb.org/core/atlas-horizon-faq) to connect to your cluster. These connection strings allow you to connect using both VPC/VNet Peering and whitelisted public IP addresses. To learn more about support for Split Horizon, see [this FAQ](https://dochub.mongodb.org/core/atlas-horizon-faq). You need this endpoint to [disable Peering Only](https://docs.atlas.mongodb.com/reference/faq/connection-changes/#disable-peering-mode).\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst myPrivateIpMode = new mongodbatlas.PrivateIpMode(\"myPrivateIpMode\", {\n    enabled: false,\n    projectId: \"\u003cYOUR PROJECT ID\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nmy_private_ip_mode = mongodbatlas.PrivateIpMode(\"myPrivateIpMode\",\n    enabled=False,\n    project_id=\"\u003cYOUR PROJECT ID\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myPrivateIpMode = new Mongodbatlas.PrivateIpMode(\"myPrivateIpMode\", new()\n    {\n        Enabled = false,\n        ProjectId = \"\u003cYOUR PROJECT ID\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewPrivateIpMode(ctx, \"myPrivateIpMode\", \u0026mongodbatlas.PrivateIpModeArgs{\n\t\t\tEnabled:   pulumi.Bool(false),\n\t\t\tProjectId: pulumi.String(\"\u003cYOUR PROJECT ID\u003e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.PrivateIpMode;\nimport com.pulumi.mongodbatlas.PrivateIpModeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myPrivateIpMode = new PrivateIpMode(\"myPrivateIpMode\", PrivateIpModeArgs.builder()        \n            .enabled(false)\n            .projectId(\"\u003cYOUR PROJECT ID\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myPrivateIpMode:\n    type: mongodbatlas:PrivateIpMode\n    properties:\n      enabled: false\n      projectId: \u003cYOUR PROJECT ID\u003e\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nProject must be imported using project ID, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/privateIpMode:PrivateIpMode my_private_ip_mode 5d09d6a59ccf6445652a444a\n```\n\n For more information see[MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/get-private-ip-mode-for-project/) ",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Indicates whether Connect via Peering Only mode is enabled or disabled for an Atlas project\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to enable Only Private IP Mode.\n"
                }
            },
            "required": [
                "enabled",
                "projectId"
            ],
            "inputProperties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Indicates whether Connect via Peering Only mode is enabled or disabled for an Atlas project\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to enable Only Private IP Mode.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "enabled",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PrivateIpMode resources.\n",
                "properties": {
                    "enabled": {
                        "type": "boolean",
                        "description": "Indicates whether Connect via Peering Only mode is enabled or disabled for an Atlas project\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to enable Only Private IP Mode.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/privateLinkEndpoint:PrivateLinkEndpoint": {
            "description": "`mongodbatlas.PrivateLinkEndpoint` provides a Private Endpoint resource. This represents a Private Endpoint Service that can be created in an Atlas project.\n\n\u003e **IMPORTANT:**You must have one of the following roles to successfully handle the resource:\n  * Organization Owner\n  * Project Owner\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n\u003e **NOTE:** A network container is created for a private endpoint to reside in if one does not yet exist in the project.  \n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.PrivateLinkEndpoint(\"test\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    providerName: \"AWS/AZURE\",\n    region: \"US_EAST_1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.PrivateLinkEndpoint(\"test\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    provider_name=\"AWS/AZURE\",\n    region=\"US_EAST_1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.PrivateLinkEndpoint(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        ProviderName = \"AWS/AZURE\",\n        Region = \"US_EAST_1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewPrivateLinkEndpoint(ctx, \"test\", \u0026mongodbatlas.PrivateLinkEndpointArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tProviderName: pulumi.String(\"AWS/AZURE\"),\n\t\t\tRegion:       pulumi.String(\"US_EAST_1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.PrivateLinkEndpoint;\nimport com.pulumi.mongodbatlas.PrivateLinkEndpointArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new PrivateLinkEndpoint(\"test\", PrivateLinkEndpointArgs.builder()        \n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .providerName(\"AWS/AZURE\")\n            .region(\"US_EAST_1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:PrivateLinkEndpoint\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      providerName: AWS/AZURE\n      region: US_EAST_1\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nPrivate Endpoint Service can be imported using project ID, private link ID, provider name and region, in the format `{project_id}-{private_link_id}-{provider_name}-{region}`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/privateLinkEndpoint:PrivateLinkEndpoint test 1112222b3bf99403840e8934-3242342343112-AWS-us-east-1\n```\n\n See detailed information for arguments and attributes[MongoDB API Private Endpoint Service](https://docs.atlas.mongodb.com/reference/api/private-endpoints-service-create-one//) ",
            "properties": {
                "endpointGroupNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "GCP network endpoint groups corresponding to the Private Service Connect endpoint service.\n"
                },
                "endpointServiceName": {
                    "type": "string",
                    "description": "Name of the PrivateLink endpoint service in AWS. Returns null while the endpoint service is being created.\n"
                },
                "errorMessage": {
                    "type": "string",
                    "description": "Error message pertaining to the AWS PrivateLink connection. Returns null if there are no errors.\nAWS:\n"
                },
                "interfaceEndpoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Unique identifiers of the interface endpoints in your VPC that you added to the AWS PrivateLink connection.\nAZURE:\n"
                },
                "privateEndpoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "All private endpoints that you have added to this Azure Private Link Service.\n"
                },
                "privateLinkId": {
                    "type": "string",
                    "description": "Unique identifier of the AWS PrivateLink connection.\n"
                },
                "privateLinkServiceName": {
                    "type": "string",
                    "description": "Name of the Azure Private Link Service that Atlas manages.\nGCP:\n"
                },
                "privateLinkServiceResourceId": {
                    "type": "string"
                },
                "projectId": {
                    "type": "string",
                    "description": "Required \tUnique identifier for the project.\n"
                },
                "providerName": {
                    "type": "string",
                    "description": "Name of the cloud provider for which you want to create the private endpoint service. Atlas accepts `AWS`, `AZURE` or `GCP`.\n"
                },
                "region": {
                    "type": "string",
                    "description": "Cloud provider region in which you want to create the private endpoint connection.\nAccepted values are: [AWS regions](https://docs.atlas.mongodb.com/reference/amazon-aws/#amazon-aws), [AZURE regions](https://docs.atlas.mongodb.com/reference/microsoft-azure/#microsoft-azure) and [GCP regions](https://docs.atlas.mongodb.com/reference/google-gcp/#std-label-google-gcp)\n"
                },
                "regionName": {
                    "type": "string",
                    "description": "GCP region for the Private Service Connect endpoint service.\n"
                },
                "serviceAttachmentNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Unique alphanumeric and special character strings that identify the service attachments associated with the GCP Private Service Connect endpoint service. Returns an empty list while Atlas creates the service attachments.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Status of the AWS PrivateLink connection or Status of the Azure Private Link Service. Atlas returns one of the following values:\nAWS:\n"
                }
            },
            "required": [
                "endpointGroupNames",
                "endpointServiceName",
                "errorMessage",
                "interfaceEndpoints",
                "privateEndpoints",
                "privateLinkId",
                "privateLinkServiceName",
                "privateLinkServiceResourceId",
                "projectId",
                "providerName",
                "region",
                "regionName",
                "serviceAttachmentNames",
                "status"
            ],
            "inputProperties": {
                "projectId": {
                    "type": "string",
                    "description": "Required \tUnique identifier for the project.\n",
                    "willReplaceOnChanges": true
                },
                "providerName": {
                    "type": "string",
                    "description": "Name of the cloud provider for which you want to create the private endpoint service. Atlas accepts `AWS`, `AZURE` or `GCP`.\n",
                    "willReplaceOnChanges": true
                },
                "region": {
                    "type": "string",
                    "description": "Cloud provider region in which you want to create the private endpoint connection.\nAccepted values are: [AWS regions](https://docs.atlas.mongodb.com/reference/amazon-aws/#amazon-aws), [AZURE regions](https://docs.atlas.mongodb.com/reference/microsoft-azure/#microsoft-azure) and [GCP regions](https://docs.atlas.mongodb.com/reference/google-gcp/#std-label-google-gcp)\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "projectId",
                "providerName",
                "region"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PrivateLinkEndpoint resources.\n",
                "properties": {
                    "endpointGroupNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "GCP network endpoint groups corresponding to the Private Service Connect endpoint service.\n"
                    },
                    "endpointServiceName": {
                        "type": "string",
                        "description": "Name of the PrivateLink endpoint service in AWS. Returns null while the endpoint service is being created.\n"
                    },
                    "errorMessage": {
                        "type": "string",
                        "description": "Error message pertaining to the AWS PrivateLink connection. Returns null if there are no errors.\nAWS:\n"
                    },
                    "interfaceEndpoints": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Unique identifiers of the interface endpoints in your VPC that you added to the AWS PrivateLink connection.\nAZURE:\n"
                    },
                    "privateEndpoints": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "All private endpoints that you have added to this Azure Private Link Service.\n"
                    },
                    "privateLinkId": {
                        "type": "string",
                        "description": "Unique identifier of the AWS PrivateLink connection.\n"
                    },
                    "privateLinkServiceName": {
                        "type": "string",
                        "description": "Name of the Azure Private Link Service that Atlas manages.\nGCP:\n"
                    },
                    "privateLinkServiceResourceId": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Required \tUnique identifier for the project.\n",
                        "willReplaceOnChanges": true
                    },
                    "providerName": {
                        "type": "string",
                        "description": "Name of the cloud provider for which you want to create the private endpoint service. Atlas accepts `AWS`, `AZURE` or `GCP`.\n",
                        "willReplaceOnChanges": true
                    },
                    "region": {
                        "type": "string",
                        "description": "Cloud provider region in which you want to create the private endpoint connection.\nAccepted values are: [AWS regions](https://docs.atlas.mongodb.com/reference/amazon-aws/#amazon-aws), [AZURE regions](https://docs.atlas.mongodb.com/reference/microsoft-azure/#microsoft-azure) and [GCP regions](https://docs.atlas.mongodb.com/reference/google-gcp/#std-label-google-gcp)\n",
                        "willReplaceOnChanges": true
                    },
                    "regionName": {
                        "type": "string",
                        "description": "GCP region for the Private Service Connect endpoint service.\n"
                    },
                    "serviceAttachmentNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Unique alphanumeric and special character strings that identify the service attachments associated with the GCP Private Service Connect endpoint service. Returns an empty list while Atlas creates the service attachments.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Status of the AWS PrivateLink connection or Status of the Azure Private Link Service. Atlas returns one of the following values:\nAWS:\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/privateLinkEndpointService:PrivateLinkEndpointService": {
            "description": "`mongodbatlas.PrivateLinkEndpointService` provides a Private Endpoint Interface Link resource. This represents a Private Endpoint Interface Link, which adds one interface endpoint to a private endpoint connection in an Atlas project.\n\n\u003e **IMPORTANT:**You must have one of the following roles to successfully handle the resource:\n  * Organization Owner\n  * Project Owner\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\u003e **NOTE:** Create and delete wait for all clusters on the project to IDLE in order for their operations to complete. This ensures the latest connection strings can be retrieved following creation or deletion of this resource. Default timeout is 2hrs.\n\n## Example with AWS\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testPrivateLinkEndpoint = new mongodbatlas.PrivateLinkEndpoint(\"testPrivateLinkEndpoint\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    providerName: \"AWS\",\n    region: \"US_EAST_1\",\n});\nconst ptfeService = new aws.ec2.VpcEndpoint(\"ptfeService\", {\n    vpcId: \"vpc-7fc0a543\",\n    serviceName: testPrivateLinkEndpoint.endpointServiceName,\n    vpcEndpointType: \"Interface\",\n    subnetIds: [\"subnet-de0406d2\"],\n    securityGroupIds: [\"sg-3f238186\"],\n});\nconst testPrivateLinkEndpointService = new mongodbatlas.PrivateLinkEndpointService(\"testPrivateLinkEndpointService\", {\n    projectId: testPrivateLinkEndpoint.projectId,\n    privateLinkId: testPrivateLinkEndpoint.privateLinkId,\n    endpointServiceId: ptfeService.id,\n    providerName: \"AWS\",\n});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_private_link_endpoint = mongodbatlas.PrivateLinkEndpoint(\"testPrivateLinkEndpoint\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    provider_name=\"AWS\",\n    region=\"US_EAST_1\")\nptfe_service = aws.ec2.VpcEndpoint(\"ptfeService\",\n    vpc_id=\"vpc-7fc0a543\",\n    service_name=test_private_link_endpoint.endpoint_service_name,\n    vpc_endpoint_type=\"Interface\",\n    subnet_ids=[\"subnet-de0406d2\"],\n    security_group_ids=[\"sg-3f238186\"])\ntest_private_link_endpoint_service = mongodbatlas.PrivateLinkEndpointService(\"testPrivateLinkEndpointService\",\n    project_id=test_private_link_endpoint.project_id,\n    private_link_id=test_private_link_endpoint.private_link_id,\n    endpoint_service_id=ptfe_service.id,\n    provider_name=\"AWS\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testPrivateLinkEndpoint = new Mongodbatlas.PrivateLinkEndpoint(\"testPrivateLinkEndpoint\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        ProviderName = \"AWS\",\n        Region = \"US_EAST_1\",\n    });\n\n    var ptfeService = new Aws.Ec2.VpcEndpoint(\"ptfeService\", new()\n    {\n        VpcId = \"vpc-7fc0a543\",\n        ServiceName = testPrivateLinkEndpoint.EndpointServiceName,\n        VpcEndpointType = \"Interface\",\n        SubnetIds = new[]\n        {\n            \"subnet-de0406d2\",\n        },\n        SecurityGroupIds = new[]\n        {\n            \"sg-3f238186\",\n        },\n    });\n\n    var testPrivateLinkEndpointService = new Mongodbatlas.PrivateLinkEndpointService(\"testPrivateLinkEndpointService\", new()\n    {\n        ProjectId = testPrivateLinkEndpoint.ProjectId,\n        PrivateLinkId = testPrivateLinkEndpoint.PrivateLinkId,\n        EndpointServiceId = ptfeService.Id,\n        ProviderName = \"AWS\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/ec2\"\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestPrivateLinkEndpoint, err := mongodbatlas.NewPrivateLinkEndpoint(ctx, \"testPrivateLinkEndpoint\", \u0026mongodbatlas.PrivateLinkEndpointArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\tRegion:       pulumi.String(\"US_EAST_1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tptfeService, err := ec2.NewVpcEndpoint(ctx, \"ptfeService\", \u0026ec2.VpcEndpointArgs{\n\t\t\tVpcId:           pulumi.String(\"vpc-7fc0a543\"),\n\t\t\tServiceName:     testPrivateLinkEndpoint.EndpointServiceName,\n\t\t\tVpcEndpointType: pulumi.String(\"Interface\"),\n\t\t\tSubnetIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"subnet-de0406d2\"),\n\t\t\t},\n\t\t\tSecurityGroupIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"sg-3f238186\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewPrivateLinkEndpointService(ctx, \"testPrivateLinkEndpointService\", \u0026mongodbatlas.PrivateLinkEndpointServiceArgs{\n\t\t\tProjectId:         testPrivateLinkEndpoint.ProjectId,\n\t\t\tPrivateLinkId:     testPrivateLinkEndpoint.PrivateLinkId,\n\t\t\tEndpointServiceId: ptfeService.ID(),\n\t\t\tProviderName:      pulumi.String(\"AWS\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.PrivateLinkEndpoint;\nimport com.pulumi.mongodbatlas.PrivateLinkEndpointArgs;\nimport com.pulumi.aws.ec2.VpcEndpoint;\nimport com.pulumi.aws.ec2.VpcEndpointArgs;\nimport com.pulumi.mongodbatlas.PrivateLinkEndpointService;\nimport com.pulumi.mongodbatlas.PrivateLinkEndpointServiceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testPrivateLinkEndpoint = new PrivateLinkEndpoint(\"testPrivateLinkEndpoint\", PrivateLinkEndpointArgs.builder()        \n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .providerName(\"AWS\")\n            .region(\"US_EAST_1\")\n            .build());\n\n        var ptfeService = new VpcEndpoint(\"ptfeService\", VpcEndpointArgs.builder()        \n            .vpcId(\"vpc-7fc0a543\")\n            .serviceName(testPrivateLinkEndpoint.endpointServiceName())\n            .vpcEndpointType(\"Interface\")\n            .subnetIds(\"subnet-de0406d2\")\n            .securityGroupIds(\"sg-3f238186\")\n            .build());\n\n        var testPrivateLinkEndpointService = new PrivateLinkEndpointService(\"testPrivateLinkEndpointService\", PrivateLinkEndpointServiceArgs.builder()        \n            .projectId(testPrivateLinkEndpoint.projectId())\n            .privateLinkId(testPrivateLinkEndpoint.privateLinkId())\n            .endpointServiceId(ptfeService.id())\n            .providerName(\"AWS\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testPrivateLinkEndpoint:\n    type: mongodbatlas:PrivateLinkEndpoint\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      providerName: AWS\n      region: US_EAST_1\n  ptfeService:\n    type: aws:ec2:VpcEndpoint\n    properties:\n      vpcId: vpc-7fc0a543\n      serviceName: ${testPrivateLinkEndpoint.endpointServiceName}\n      vpcEndpointType: Interface\n      subnetIds:\n        - subnet-de0406d2\n      securityGroupIds:\n        - sg-3f238186\n  testPrivateLinkEndpointService:\n    type: mongodbatlas:PrivateLinkEndpointService\n    properties:\n      projectId: ${testPrivateLinkEndpoint.projectId}\n      privateLinkId: ${testPrivateLinkEndpoint.privateLinkId}\n      endpointServiceId: ${ptfeService.id}\n      providerName: AWS\n```\n\n## Example with Azure\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as azure from \"@pulumi/azure\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testPrivateLinkEndpoint = new mongodbatlas.PrivateLinkEndpoint(\"testPrivateLinkEndpoint\", {\n    projectId: _var.project_id,\n    providerName: \"AZURE\",\n    region: \"eastus2\",\n});\nconst testEndpoint = new azure.privatelink.Endpoint(\"testEndpoint\", {\n    location: data.azurerm_resource_group.test.location,\n    resourceGroupName: _var.resource_group_name,\n    subnetId: azurerm_subnet.test.id,\n    privateServiceConnection: {\n        name: testPrivateLinkEndpoint.privateLinkServiceName,\n        privateConnectionResourceId: testPrivateLinkEndpoint.privateLinkServiceResourceId,\n        isManualConnection: true,\n        requestMessage: \"Azure Private Link test\",\n    },\n});\nconst testPrivateLinkEndpointService = new mongodbatlas.PrivateLinkEndpointService(\"testPrivateLinkEndpointService\", {\n    projectId: testPrivateLinkEndpoint.projectId,\n    privateLinkId: testPrivateLinkEndpoint.privateLinkId,\n    endpointServiceId: testEndpoint.id,\n    privateEndpointIpAddress: testEndpoint.privateServiceConnection.apply(privateServiceConnection =\u003e privateServiceConnection.privateIpAddress),\n    providerName: \"AZURE\",\n});\n```\n```python\nimport pulumi\nimport pulumi_azure as azure\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_private_link_endpoint = mongodbatlas.PrivateLinkEndpoint(\"testPrivateLinkEndpoint\",\n    project_id=var[\"project_id\"],\n    provider_name=\"AZURE\",\n    region=\"eastus2\")\ntest_endpoint = azure.privatelink.Endpoint(\"testEndpoint\",\n    location=data[\"azurerm_resource_group\"][\"test\"][\"location\"],\n    resource_group_name=var[\"resource_group_name\"],\n    subnet_id=azurerm_subnet[\"test\"][\"id\"],\n    private_service_connection=azure.privatelink.EndpointPrivateServiceConnectionArgs(\n        name=test_private_link_endpoint.private_link_service_name,\n        private_connection_resource_id=test_private_link_endpoint.private_link_service_resource_id,\n        is_manual_connection=True,\n        request_message=\"Azure Private Link test\",\n    ))\ntest_private_link_endpoint_service = mongodbatlas.PrivateLinkEndpointService(\"testPrivateLinkEndpointService\",\n    project_id=test_private_link_endpoint.project_id,\n    private_link_id=test_private_link_endpoint.private_link_id,\n    endpoint_service_id=test_endpoint.id,\n    private_endpoint_ip_address=test_endpoint.private_service_connection.private_ip_address,\n    provider_name=\"AZURE\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Azure = Pulumi.Azure;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testPrivateLinkEndpoint = new Mongodbatlas.PrivateLinkEndpoint(\"testPrivateLinkEndpoint\", new()\n    {\n        ProjectId = @var.Project_id,\n        ProviderName = \"AZURE\",\n        Region = \"eastus2\",\n    });\n\n    var testEndpoint = new Azure.PrivateLink.Endpoint(\"testEndpoint\", new()\n    {\n        Location = data.Azurerm_resource_group.Test.Location,\n        ResourceGroupName = @var.Resource_group_name,\n        SubnetId = azurerm_subnet.Test.Id,\n        PrivateServiceConnection = new Azure.PrivateLink.Inputs.EndpointPrivateServiceConnectionArgs\n        {\n            Name = testPrivateLinkEndpoint.PrivateLinkServiceName,\n            PrivateConnectionResourceId = testPrivateLinkEndpoint.PrivateLinkServiceResourceId,\n            IsManualConnection = true,\n            RequestMessage = \"Azure Private Link test\",\n        },\n    });\n\n    var testPrivateLinkEndpointService = new Mongodbatlas.PrivateLinkEndpointService(\"testPrivateLinkEndpointService\", new()\n    {\n        ProjectId = testPrivateLinkEndpoint.ProjectId,\n        PrivateLinkId = testPrivateLinkEndpoint.PrivateLinkId,\n        EndpointServiceId = testEndpoint.Id,\n        PrivateEndpointIpAddress = testEndpoint.PrivateServiceConnection.Apply(privateServiceConnection =\u003e privateServiceConnection.PrivateIpAddress),\n        ProviderName = \"AZURE\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-azure/sdk/v4/go/azure/privatelink\"\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestPrivateLinkEndpoint, err := mongodbatlas.NewPrivateLinkEndpoint(ctx, \"testPrivateLinkEndpoint\", \u0026mongodbatlas.PrivateLinkEndpointArgs{\n\t\t\tProjectId:    pulumi.Any(_var.Project_id),\n\t\t\tProviderName: pulumi.String(\"AZURE\"),\n\t\t\tRegion:       pulumi.String(\"eastus2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestEndpoint, err := privatelink.NewEndpoint(ctx, \"testEndpoint\", \u0026privatelink.EndpointArgs{\n\t\t\tLocation:          pulumi.Any(data.Azurerm_resource_group.Test.Location),\n\t\t\tResourceGroupName: pulumi.Any(_var.Resource_group_name),\n\t\t\tSubnetId:          pulumi.Any(azurerm_subnet.Test.Id),\n\t\t\tPrivateServiceConnection: \u0026privatelink.EndpointPrivateServiceConnectionArgs{\n\t\t\t\tName:                        testPrivateLinkEndpoint.PrivateLinkServiceName,\n\t\t\t\tPrivateConnectionResourceId: testPrivateLinkEndpoint.PrivateLinkServiceResourceId,\n\t\t\t\tIsManualConnection:          pulumi.Bool(true),\n\t\t\t\tRequestMessage:              pulumi.String(\"Azure Private Link test\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewPrivateLinkEndpointService(ctx, \"testPrivateLinkEndpointService\", \u0026mongodbatlas.PrivateLinkEndpointServiceArgs{\n\t\t\tProjectId:         testPrivateLinkEndpoint.ProjectId,\n\t\t\tPrivateLinkId:     testPrivateLinkEndpoint.PrivateLinkId,\n\t\t\tEndpointServiceId: testEndpoint.ID(),\n\t\t\tPrivateEndpointIpAddress: testEndpoint.PrivateServiceConnection.ApplyT(func(privateServiceConnection privatelink.EndpointPrivateServiceConnection) (*string, error) {\n\t\t\t\treturn \u0026privateServiceConnection.PrivateIpAddress, nil\n\t\t\t}).(pulumi.StringPtrOutput),\n\t\t\tProviderName: pulumi.String(\"AZURE\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.PrivateLinkEndpoint;\nimport com.pulumi.mongodbatlas.PrivateLinkEndpointArgs;\nimport com.pulumi.azure.privatelink.Endpoint;\nimport com.pulumi.azure.privatelink.EndpointArgs;\nimport com.pulumi.azure.privatelink.inputs.EndpointPrivateServiceConnectionArgs;\nimport com.pulumi.mongodbatlas.PrivateLinkEndpointService;\nimport com.pulumi.mongodbatlas.PrivateLinkEndpointServiceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testPrivateLinkEndpoint = new PrivateLinkEndpoint(\"testPrivateLinkEndpoint\", PrivateLinkEndpointArgs.builder()        \n            .projectId(var_.project_id())\n            .providerName(\"AZURE\")\n            .region(\"eastus2\")\n            .build());\n\n        var testEndpoint = new Endpoint(\"testEndpoint\", EndpointArgs.builder()        \n            .location(data.azurerm_resource_group().test().location())\n            .resourceGroupName(var_.resource_group_name())\n            .subnetId(azurerm_subnet.test().id())\n            .privateServiceConnection(EndpointPrivateServiceConnectionArgs.builder()\n                .name(testPrivateLinkEndpoint.privateLinkServiceName())\n                .privateConnectionResourceId(testPrivateLinkEndpoint.privateLinkServiceResourceId())\n                .isManualConnection(true)\n                .requestMessage(\"Azure Private Link test\")\n                .build())\n            .build());\n\n        var testPrivateLinkEndpointService = new PrivateLinkEndpointService(\"testPrivateLinkEndpointService\", PrivateLinkEndpointServiceArgs.builder()        \n            .projectId(testPrivateLinkEndpoint.projectId())\n            .privateLinkId(testPrivateLinkEndpoint.privateLinkId())\n            .endpointServiceId(testEndpoint.id())\n            .privateEndpointIpAddress(testEndpoint.privateServiceConnection().applyValue(privateServiceConnection -\u003e privateServiceConnection.privateIpAddress()))\n            .providerName(\"AZURE\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testPrivateLinkEndpoint:\n    type: mongodbatlas:PrivateLinkEndpoint\n    properties:\n      projectId: ${var.project_id}\n      providerName: AZURE\n      region: eastus2\n  testEndpoint:\n    type: azure:privatelink:Endpoint\n    properties:\n      location: ${data.azurerm_resource_group.test.location}\n      resourceGroupName: ${var.resource_group_name}\n      subnetId: ${azurerm_subnet.test.id}\n      privateServiceConnection:\n        name: ${testPrivateLinkEndpoint.privateLinkServiceName}\n        privateConnectionResourceId: ${testPrivateLinkEndpoint.privateLinkServiceResourceId}\n        isManualConnection: true\n        requestMessage: Azure Private Link test\n  testPrivateLinkEndpointService:\n    type: mongodbatlas:PrivateLinkEndpointService\n    properties:\n      projectId: ${testPrivateLinkEndpoint.projectId}\n      privateLinkId: ${testPrivateLinkEndpoint.privateLinkId}\n      endpointServiceId: ${testEndpoint.id}\n      privateEndpointIpAddress: ${testEndpoint.privateServiceConnection.privateIpAddress}\n      providerName: AZURE\n```\n\n## Example with GCP\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.PrivateLinkEndpoint;\nimport com.pulumi.mongodbatlas.PrivateLinkEndpointArgs;\nimport com.pulumi.gcp.compute.Network;\nimport com.pulumi.gcp.compute.NetworkArgs;\nimport com.pulumi.gcp.compute.Subnetwork;\nimport com.pulumi.gcp.compute.SubnetworkArgs;\nimport com.pulumi.gcp.compute.Address;\nimport com.pulumi.gcp.compute.AddressArgs;\nimport com.pulumi.gcp.compute.ForwardingRule;\nimport com.pulumi.gcp.compute.ForwardingRuleArgs;\nimport com.pulumi.mongodbatlas.PrivateLinkEndpointService;\nimport com.pulumi.mongodbatlas.PrivateLinkEndpointServiceArgs;\nimport com.pulumi.codegen.internal.KeyedValue;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testPrivateLinkEndpoint = new PrivateLinkEndpoint(\"testPrivateLinkEndpoint\", PrivateLinkEndpointArgs.builder()        \n            .projectId(var_.project_id())\n            .providerName(\"GCP\")\n            .region(var_.gcp_region())\n            .build());\n\n        var defaultNetwork = new Network(\"defaultNetwork\", NetworkArgs.builder()        \n            .project(var_.gcp_project())\n            .build());\n\n        var defaultSubnetwork = new Subnetwork(\"defaultSubnetwork\", SubnetworkArgs.builder()        \n            .project(defaultNetwork.project())\n            .ipCidrRange(\"10.0.0.0/16\")\n            .region(var_.gcp_region())\n            .network(defaultNetwork.id())\n            .build());\n\n        for (var i = 0; i \u003c 50; i++) {\n            new Address(\"defaultAddress-\" + i, AddressArgs.builder()            \n                .project(defaultSubnetwork.project())\n                .subnetwork(defaultSubnetwork.id())\n                .addressType(\"INTERNAL\")\n                .address(String.format(\"10.0.42.%s\", range.value()))\n                .region(var_.gcp_region())\n                .build(), CustomResourceOptions.builder()\n                    .dependsOn(testPrivateLinkEndpoint)\n                    .build());\n\n        \n}\n        for (var i = 0; i \u003c 50; i++) {\n            new ForwardingRule(\"defaultForwardingRule-\" + i, ForwardingRuleArgs.builder()            \n                .target(testPrivateLinkEndpoint.serviceAttachmentNames().applyValue(serviceAttachmentNames -\u003e serviceAttachmentNames[range.value()]))\n                .project(defaultAddress[range.value()].project())\n                .region(defaultAddress[range.value()].region())\n                .ipAddress(defaultAddress[range.value()].id())\n                .network(defaultNetwork.id())\n                .loadBalancingScheme(\"\")\n                .build());\n\n        \n}\n        var testPrivateLinkEndpointService = new PrivateLinkEndpointService(\"testPrivateLinkEndpointService\", PrivateLinkEndpointServiceArgs.builder()        \n            .projectId(testPrivateLinkEndpoint.projectId())\n            .privateLinkId(testPrivateLinkEndpoint.privateLinkId())\n            .providerName(\"GCP\")\n            .endpointServiceId(defaultNetwork.name())\n            .gcpProjectId(var_.gcp_project())\n            .dynamic(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(defaultForwardingRule)\n                .build());\n\n    }\n}\n```\n\n\n## Import\n\nPrivate Endpoint Link Connection can be imported using project ID and username, in the format `{project_id}--{private_link_id}--{endpoint_service_id}--{provider_name}`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/privateLinkEndpointService:PrivateLinkEndpointService test 1112222b3bf99403840e8934--3242342343112--vpce-4242342343--AWS\n```\n\n See detailed information for arguments and attributes[MongoDB API Private Endpoint Link Connection](https://docs.atlas.mongodb.com/reference/api/private-endpoints-endpoint-create-one/) ",
            "properties": {
                "awsConnectionStatus": {
                    "type": "string",
                    "description": "Status of the interface endpoint for AWS.\nReturns one of the following values:\n"
                },
                "azureStatus": {
                    "type": "string",
                    "description": "Status of the interface endpoint for AZURE.\nReturns one of the following values:\n"
                },
                "deleteRequested": {
                    "type": "boolean",
                    "description": "Indicates if Atlas received a request to remove the interface endpoint from the private endpoint connection.\n"
                },
                "endpointGroupName": {
                    "type": "string",
                    "description": "(Optional) Unique identifier of the endpoint group. The endpoint group encompasses all of the endpoints that you created in GCP.\n"
                },
                "endpointServiceId": {
                    "type": "string",
                    "description": "Unique identifier of the interface endpoint you created in your VPC with the `AWS`, `AZURE` or `GCP` resource.\n"
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/PrivateLinkEndpointServiceEndpoint:PrivateLinkEndpointServiceEndpoint"
                    },
                    "description": "Collection of individual private endpoints that comprise your endpoint group. Only for `GCP`. See below.\n"
                },
                "errorMessage": {
                    "type": "string",
                    "description": "Error message pertaining to the interface endpoint. Returns null if there are no errors.\n"
                },
                "gcpProjectId": {
                    "type": "string",
                    "description": "Unique identifier of the GCP project in which you created your endpoints. Only for `GCP`.\n"
                },
                "gcpStatus": {
                    "type": "string",
                    "description": "Status of the interface endpoint for GCP.\nReturns one of the following values:\n"
                },
                "interfaceEndpointId": {
                    "type": "string",
                    "description": "Unique identifier of the interface endpoint.\n"
                },
                "privateEndpointConnectionName": {
                    "type": "string",
                    "description": "Name of the connection for this private endpoint that Atlas generates.\n"
                },
                "privateEndpointIpAddress": {
                    "type": "string",
                    "description": "Private IP address of the private endpoint network interface you created in your Azure VNet. Only for `AZURE`.\n"
                },
                "privateEndpointResourceId": {
                    "type": "string",
                    "description": "Unique identifier of the private endpoint.\n"
                },
                "privateLinkId": {
                    "type": "string",
                    "description": "Unique identifier of the `AWS` or `AZURE` PrivateLink connection which is created by `mongodbatlas.PrivateLinkEndpoint` resource.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique identifier for the project.\n"
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud provider for which you want to create a private endpoint. Atlas accepts `AWS`, `AZURE` or `GCP`.\n"
                }
            },
            "required": [
                "awsConnectionStatus",
                "azureStatus",
                "deleteRequested",
                "endpointGroupName",
                "endpointServiceId",
                "endpoints",
                "errorMessage",
                "gcpStatus",
                "interfaceEndpointId",
                "privateEndpointConnectionName",
                "privateEndpointIpAddress",
                "privateEndpointResourceId",
                "privateLinkId",
                "projectId",
                "providerName"
            ],
            "inputProperties": {
                "endpointServiceId": {
                    "type": "string",
                    "description": "Unique identifier of the interface endpoint you created in your VPC with the `AWS`, `AZURE` or `GCP` resource.\n",
                    "willReplaceOnChanges": true
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/PrivateLinkEndpointServiceEndpoint:PrivateLinkEndpointServiceEndpoint"
                    },
                    "description": "Collection of individual private endpoints that comprise your endpoint group. Only for `GCP`. See below.\n"
                },
                "gcpProjectId": {
                    "type": "string",
                    "description": "Unique identifier of the GCP project in which you created your endpoints. Only for `GCP`.\n",
                    "willReplaceOnChanges": true
                },
                "privateEndpointIpAddress": {
                    "type": "string",
                    "description": "Private IP address of the private endpoint network interface you created in your Azure VNet. Only for `AZURE`.\n"
                },
                "privateLinkId": {
                    "type": "string",
                    "description": "Unique identifier of the `AWS` or `AZURE` PrivateLink connection which is created by `mongodbatlas.PrivateLinkEndpoint` resource.\n",
                    "willReplaceOnChanges": true
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique identifier for the project.\n",
                    "willReplaceOnChanges": true
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud provider for which you want to create a private endpoint. Atlas accepts `AWS`, `AZURE` or `GCP`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "endpointServiceId",
                "privateLinkId",
                "projectId",
                "providerName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PrivateLinkEndpointService resources.\n",
                "properties": {
                    "awsConnectionStatus": {
                        "type": "string",
                        "description": "Status of the interface endpoint for AWS.\nReturns one of the following values:\n"
                    },
                    "azureStatus": {
                        "type": "string",
                        "description": "Status of the interface endpoint for AZURE.\nReturns one of the following values:\n"
                    },
                    "deleteRequested": {
                        "type": "boolean",
                        "description": "Indicates if Atlas received a request to remove the interface endpoint from the private endpoint connection.\n"
                    },
                    "endpointGroupName": {
                        "type": "string",
                        "description": "(Optional) Unique identifier of the endpoint group. The endpoint group encompasses all of the endpoints that you created in GCP.\n"
                    },
                    "endpointServiceId": {
                        "type": "string",
                        "description": "Unique identifier of the interface endpoint you created in your VPC with the `AWS`, `AZURE` or `GCP` resource.\n",
                        "willReplaceOnChanges": true
                    },
                    "endpoints": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/PrivateLinkEndpointServiceEndpoint:PrivateLinkEndpointServiceEndpoint"
                        },
                        "description": "Collection of individual private endpoints that comprise your endpoint group. Only for `GCP`. See below.\n"
                    },
                    "errorMessage": {
                        "type": "string",
                        "description": "Error message pertaining to the interface endpoint. Returns null if there are no errors.\n"
                    },
                    "gcpProjectId": {
                        "type": "string",
                        "description": "Unique identifier of the GCP project in which you created your endpoints. Only for `GCP`.\n",
                        "willReplaceOnChanges": true
                    },
                    "gcpStatus": {
                        "type": "string",
                        "description": "Status of the interface endpoint for GCP.\nReturns one of the following values:\n"
                    },
                    "interfaceEndpointId": {
                        "type": "string",
                        "description": "Unique identifier of the interface endpoint.\n"
                    },
                    "privateEndpointConnectionName": {
                        "type": "string",
                        "description": "Name of the connection for this private endpoint that Atlas generates.\n"
                    },
                    "privateEndpointIpAddress": {
                        "type": "string",
                        "description": "Private IP address of the private endpoint network interface you created in your Azure VNet. Only for `AZURE`.\n"
                    },
                    "privateEndpointResourceId": {
                        "type": "string",
                        "description": "Unique identifier of the private endpoint.\n"
                    },
                    "privateLinkId": {
                        "type": "string",
                        "description": "Unique identifier of the `AWS` or `AZURE` PrivateLink connection which is created by `mongodbatlas.PrivateLinkEndpoint` resource.\n",
                        "willReplaceOnChanges": true
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique identifier for the project.\n",
                        "willReplaceOnChanges": true
                    },
                    "providerName": {
                        "type": "string",
                        "description": "Cloud provider for which you want to create a private endpoint. Atlas accepts `AWS`, `AZURE` or `GCP`.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/privatelinkEndpointServerless:PrivatelinkEndpointServerless": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n### AWS Example\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testServerlessInstance = new mongodbatlas.ServerlessInstance(\"testServerlessInstance\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    providerSettingsBackingProviderName: \"AWS\",\n    providerSettingsProviderName: \"SERVERLESS\",\n    providerSettingsRegionName: \"US_EAST_1\",\n    continuousBackupEnabled: true,\n});\nconst testPrivatelinkEndpointServerless = new mongodbatlas.PrivatelinkEndpointServerless(\"testPrivatelinkEndpointServerless\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: testServerlessInstance.name,\n    providerName: \"AWS\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_serverless_instance = mongodbatlas.ServerlessInstance(\"testServerlessInstance\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    provider_settings_backing_provider_name=\"AWS\",\n    provider_settings_provider_name=\"SERVERLESS\",\n    provider_settings_region_name=\"US_EAST_1\",\n    continuous_backup_enabled=True)\ntest_privatelink_endpoint_serverless = mongodbatlas.PrivatelinkEndpointServerless(\"testPrivatelinkEndpointServerless\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=test_serverless_instance.name,\n    provider_name=\"AWS\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testServerlessInstance = new Mongodbatlas.ServerlessInstance(\"testServerlessInstance\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        ProviderSettingsBackingProviderName = \"AWS\",\n        ProviderSettingsProviderName = \"SERVERLESS\",\n        ProviderSettingsRegionName = \"US_EAST_1\",\n        ContinuousBackupEnabled = true,\n    });\n\n    var testPrivatelinkEndpointServerless = new Mongodbatlas.PrivatelinkEndpointServerless(\"testPrivatelinkEndpointServerless\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = testServerlessInstance.Name,\n        ProviderName = \"AWS\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestServerlessInstance, err := mongodbatlas.NewServerlessInstance(ctx, \"testServerlessInstance\", \u0026mongodbatlas.ServerlessInstanceArgs{\n\t\t\tProjectId:                           pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tProviderSettingsBackingProviderName: pulumi.String(\"AWS\"),\n\t\t\tProviderSettingsProviderName:        pulumi.String(\"SERVERLESS\"),\n\t\t\tProviderSettingsRegionName:          pulumi.String(\"US_EAST_1\"),\n\t\t\tContinuousBackupEnabled:             pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewPrivatelinkEndpointServerless(ctx, \"testPrivatelinkEndpointServerless\", \u0026mongodbatlas.PrivatelinkEndpointServerlessArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tInstanceName: testServerlessInstance.Name,\n\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ServerlessInstance;\nimport com.pulumi.mongodbatlas.ServerlessInstanceArgs;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServerless;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServerlessArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testServerlessInstance = new ServerlessInstance(\"testServerlessInstance\", ServerlessInstanceArgs.builder()        \n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .providerSettingsBackingProviderName(\"AWS\")\n            .providerSettingsProviderName(\"SERVERLESS\")\n            .providerSettingsRegionName(\"US_EAST_1\")\n            .continuousBackupEnabled(true)\n            .build());\n\n        var testPrivatelinkEndpointServerless = new PrivatelinkEndpointServerless(\"testPrivatelinkEndpointServerless\", PrivatelinkEndpointServerlessArgs.builder()        \n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(testServerlessInstance.name())\n            .providerName(\"AWS\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testPrivatelinkEndpointServerless:\n    type: mongodbatlas:PrivatelinkEndpointServerless\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      instanceName: ${testServerlessInstance.name}\n      providerName: AWS\n  testServerlessInstance:\n    type: mongodbatlas:ServerlessInstance\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      providerSettingsBackingProviderName: AWS\n      providerSettingsProviderName: SERVERLESS\n      providerSettingsRegionName: US_EAST_1\n      continuousBackupEnabled: true\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nServerless privatelink endpoint can be imported using project ID and endpoint ID, in the format `project_id`--`endpoint_id`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/privatelinkEndpointServerless:PrivatelinkEndpointServerless test 1112222b3bf99403840e8934--serverless_name--vpce-jjg5e24qp93513h03\n```\n\n For more information see[MongoDB Atlas API - Serverless Private Endpoints](https://www.mongodb.com/docs/atlas/reference/api/serverless-private-endpoints-get-one/). ",
            "properties": {
                "endpointId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the private endpoint.\n"
                },
                "endpointServiceName": {
                    "type": "string",
                    "description": "Unique string that identifies the PrivateLink endpoint service.\n"
                },
                "instanceName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the serverless instance.\n"
                },
                "privateLinkServiceResourceId": {
                    "type": "string",
                    "description": "Root-relative path that identifies the Azure Private Link Service that MongoDB Cloud manages.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-digit hexadecimal string that identifies the project.\n"
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud provider name; AWS is currently supported\n"
                },
                "status": {
                    "type": "string",
                    "description": "Human-readable label that indicates the current operating status of the private endpoint. Values include: RESERVATION_REQUESTED, RESERVED, INITIATING, AVAILABLE, FAILED, DELETING.\n"
                }
            },
            "required": [
                "endpointId",
                "endpointServiceName",
                "instanceName",
                "privateLinkServiceResourceId",
                "projectId",
                "providerName",
                "status"
            ],
            "inputProperties": {
                "instanceName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the serverless instance.\n",
                    "willReplaceOnChanges": true
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-digit hexadecimal string that identifies the project.\n",
                    "willReplaceOnChanges": true
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud provider name; AWS is currently supported\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "instanceName",
                "projectId",
                "providerName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PrivatelinkEndpointServerless resources.\n",
                "properties": {
                    "endpointId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the private endpoint.\n"
                    },
                    "endpointServiceName": {
                        "type": "string",
                        "description": "Unique string that identifies the PrivateLink endpoint service.\n"
                    },
                    "instanceName": {
                        "type": "string",
                        "description": "Human-readable label that identifies the serverless instance.\n",
                        "willReplaceOnChanges": true
                    },
                    "privateLinkServiceResourceId": {
                        "type": "string",
                        "description": "Root-relative path that identifies the Azure Private Link Service that MongoDB Cloud manages.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-digit hexadecimal string that identifies the project.\n",
                        "willReplaceOnChanges": true
                    },
                    "providerName": {
                        "type": "string",
                        "description": "Cloud provider name; AWS is currently supported\n",
                        "willReplaceOnChanges": true
                    },
                    "status": {
                        "type": "string",
                        "description": "Human-readable label that indicates the current operating status of the private endpoint. Values include: RESERVATION_REQUESTED, RESERVED, INITIATING, AVAILABLE, FAILED, DELETING.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/privatelinkEndpointServiceAdl:PrivatelinkEndpointServiceAdl": {
            "description": "`privatelink_endpoint_service_adl` Provides an Atlas Data Lake (ADL) and Online Archive PrivateLink endpoint resource.   The same configuration will provide a PrivateLink connection for either Atlas Data Lake or Online Archive.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Basic\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst adlTest = new mongodbatlas.PrivatelinkEndpointServiceAdl(\"adlTest\", {\n    comment: \"comments for private link endpoint adl\",\n    endpointId: \"\u003cENDPOINT_ID\u003e\",\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    providerName: \"AWS\",\n    type: \"DATA_LAKE\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nadl_test = mongodbatlas.PrivatelinkEndpointServiceAdl(\"adlTest\",\n    comment=\"comments for private link endpoint adl\",\n    endpoint_id=\"\u003cENDPOINT_ID\u003e\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    provider_name=\"AWS\",\n    type=\"DATA_LAKE\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var adlTest = new Mongodbatlas.PrivatelinkEndpointServiceAdl(\"adlTest\", new()\n    {\n        Comment = \"comments for private link endpoint adl\",\n        EndpointId = \"\u003cENDPOINT_ID\u003e\",\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        ProviderName = \"AWS\",\n        Type = \"DATA_LAKE\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewPrivatelinkEndpointServiceAdl(ctx, \"adlTest\", \u0026mongodbatlas.PrivatelinkEndpointServiceAdlArgs{\n\t\t\tComment:      pulumi.String(\"comments for private link endpoint adl\"),\n\t\t\tEndpointId:   pulumi.String(\"\u003cENDPOINT_ID\u003e\"),\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\tType:         pulumi.String(\"DATA_LAKE\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceAdl;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceAdlArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var adlTest = new PrivatelinkEndpointServiceAdl(\"adlTest\", PrivatelinkEndpointServiceAdlArgs.builder()        \n            .comment(\"comments for private link endpoint adl\")\n            .endpointId(\"\u003cENDPOINT_ID\u003e\")\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .providerName(\"AWS\")\n            .type(\"DATA_LAKE\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  adlTest:\n    type: mongodbatlas:PrivatelinkEndpointServiceAdl\n    properties:\n      comment: comments for private link endpoint adl\n      endpointId: \u003cENDPOINT_ID\u003e\n      projectId: \u003cPROJECT_ID\u003e\n      providerName: AWS\n      type: DATA_LAKE\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nADL privatelink endpoint can be imported using project ID and endpoint ID, in the format `project_id`--`endpoint_id`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/privatelinkEndpointServiceAdl:PrivatelinkEndpointServiceAdl test 1112222b3bf99403840e8934--vpce-jjg5e24qp93513h03\n```\n\n For more information see[MongoDB Atlas API - DataLake](https://docs.mongodb.com/datalake/reference/api/datalakes-api/)\n\nand [MongoDB Atlas API - Online Archive](https://docs.atlas.mongodb.com/reference/api/online-archive/) Documentation. ",
            "properties": {
                "comment": {
                    "type": "string",
                    "description": "Human-readable string to associate with this private endpoint.\n"
                },
                "endpointId": {
                    "type": "string",
                    "description": "Unique 22-character alphanumeric string that identifies the private endpoint. Atlas supports AWS private endpoints using the [|aws| PrivateLink](https://aws.amazon.com/privatelink/) feature.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-digit hexadecimal string that identifies the project.\n"
                },
                "providerName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the cloud provider for this endpoint. Atlas supports AWS only. If empty, defaults to AWS.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Human-readable label that identifies the type of resource to associate with this private endpoint. Atlas supports `DATA_LAKE` only. If empty, defaults to `DATA_LAKE`.\n"
                }
            },
            "required": [
                "endpointId",
                "projectId",
                "providerName",
                "type"
            ],
            "inputProperties": {
                "comment": {
                    "type": "string",
                    "description": "Human-readable string to associate with this private endpoint.\n"
                },
                "endpointId": {
                    "type": "string",
                    "description": "Unique 22-character alphanumeric string that identifies the private endpoint. Atlas supports AWS private endpoints using the [|aws| PrivateLink](https://aws.amazon.com/privatelink/) feature.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-digit hexadecimal string that identifies the project.\n",
                    "willReplaceOnChanges": true
                },
                "providerName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the cloud provider for this endpoint. Atlas supports AWS only. If empty, defaults to AWS.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Human-readable label that identifies the type of resource to associate with this private endpoint. Atlas supports `DATA_LAKE` only. If empty, defaults to `DATA_LAKE`.\n"
                }
            },
            "requiredInputs": [
                "endpointId",
                "projectId",
                "providerName",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PrivatelinkEndpointServiceAdl resources.\n",
                "properties": {
                    "comment": {
                        "type": "string",
                        "description": "Human-readable string to associate with this private endpoint.\n"
                    },
                    "endpointId": {
                        "type": "string",
                        "description": "Unique 22-character alphanumeric string that identifies the private endpoint. Atlas supports AWS private endpoints using the [|aws| PrivateLink](https://aws.amazon.com/privatelink/) feature.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-digit hexadecimal string that identifies the project.\n",
                        "willReplaceOnChanges": true
                    },
                    "providerName": {
                        "type": "string",
                        "description": "Human-readable label that identifies the cloud provider for this endpoint. Atlas supports AWS only. If empty, defaults to AWS.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Human-readable label that identifies the type of resource to associate with this private endpoint. Atlas supports `DATA_LAKE` only. If empty, defaults to `DATA_LAKE`.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/privatelinkEndpointServiceServerless:PrivatelinkEndpointServiceServerless": {
            "description": "\n\n\n## Import\n\nServerless privatelink endpoint can be imported using project ID and endpoint ID, in the format `project_id`--`endpoint_id`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/privatelinkEndpointServiceServerless:PrivatelinkEndpointServiceServerless test 1112222b3bf99403840e8934--serverless_name--vpce-jjg5e24qp93513h03\n```\n\n For more information see[MongoDB Atlas API - Serverless Private Endpoints](https://www.mongodb.com/docs/atlas/reference/api/serverless-private-endpoints-get-one/). ",
            "properties": {
                "cloudProviderEndpointId": {
                    "type": "string",
                    "description": "Unique string that identifies the private endpoint's network interface.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Human-readable string to associate with this private endpoint.\n"
                },
                "endpointId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the private endpoint.\n"
                },
                "instanceName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the serverless instance.\n"
                },
                "privateEndpointIpAddress": {
                    "type": "string",
                    "description": "IPv4 address of the private endpoint in your Azure VNet that someone added to this private endpoint service.\n"
                },
                "privateLinkServiceResourceId": {
                    "type": "string",
                    "description": "Root-relative path that identifies the Azure Private Link Service that MongoDB Cloud manages.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-digit hexadecimal string that identifies the project.\n"
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud provider for which you want to create a private endpoint. Atlas accepts `AWS`, `AZURE`.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Human-readable label that indicates the current operating status of the private endpoint. Values include: RESERVATION_REQUESTED, RESERVED, INITIATING, AVAILABLE, FAILED, DELETING.\n"
                }
            },
            "required": [
                "cloudProviderEndpointId",
                "endpointId",
                "instanceName",
                "privateEndpointIpAddress",
                "privateLinkServiceResourceId",
                "projectId",
                "providerName",
                "status"
            ],
            "inputProperties": {
                "cloudProviderEndpointId": {
                    "type": "string",
                    "description": "Unique string that identifies the private endpoint's network interface.\n",
                    "willReplaceOnChanges": true
                },
                "comment": {
                    "type": "string",
                    "description": "Human-readable string to associate with this private endpoint.\n",
                    "willReplaceOnChanges": true
                },
                "endpointId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the private endpoint.\n",
                    "willReplaceOnChanges": true
                },
                "instanceName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the serverless instance.\n",
                    "willReplaceOnChanges": true
                },
                "privateEndpointIpAddress": {
                    "type": "string",
                    "description": "IPv4 address of the private endpoint in your Azure VNet that someone added to this private endpoint service.\n",
                    "willReplaceOnChanges": true
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-digit hexadecimal string that identifies the project.\n",
                    "willReplaceOnChanges": true
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud provider for which you want to create a private endpoint. Atlas accepts `AWS`, `AZURE`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "endpointId",
                "instanceName",
                "projectId",
                "providerName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PrivatelinkEndpointServiceServerless resources.\n",
                "properties": {
                    "cloudProviderEndpointId": {
                        "type": "string",
                        "description": "Unique string that identifies the private endpoint's network interface.\n",
                        "willReplaceOnChanges": true
                    },
                    "comment": {
                        "type": "string",
                        "description": "Human-readable string to associate with this private endpoint.\n",
                        "willReplaceOnChanges": true
                    },
                    "endpointId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the private endpoint.\n",
                        "willReplaceOnChanges": true
                    },
                    "instanceName": {
                        "type": "string",
                        "description": "Human-readable label that identifies the serverless instance.\n",
                        "willReplaceOnChanges": true
                    },
                    "privateEndpointIpAddress": {
                        "type": "string",
                        "description": "IPv4 address of the private endpoint in your Azure VNet that someone added to this private endpoint service.\n",
                        "willReplaceOnChanges": true
                    },
                    "privateLinkServiceResourceId": {
                        "type": "string",
                        "description": "Root-relative path that identifies the Azure Private Link Service that MongoDB Cloud manages.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-digit hexadecimal string that identifies the project.\n",
                        "willReplaceOnChanges": true
                    },
                    "providerName": {
                        "type": "string",
                        "description": "Cloud provider for which you want to create a private endpoint. Atlas accepts `AWS`, `AZURE`.\n",
                        "willReplaceOnChanges": true
                    },
                    "status": {
                        "type": "string",
                        "description": "Human-readable label that indicates the current operating status of the private endpoint. Values include: RESERVATION_REQUESTED, RESERVED, INITIATING, AVAILABLE, FAILED, DELETING.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/project:Project": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testRolesOrgId = mongodbatlas.getRolesOrgId({});\nconst testProject = new mongodbatlas.Project(\"testProject\", {\n    orgId: testRolesOrgId.then(testRolesOrgId =\u003e testRolesOrgId.orgId),\n    projectOwnerId: \"\u003cOWNER_ACCOUNT_ID\u003e\",\n    teams: [\n        {\n            teamId: \"5e0fa8c99ccf641c722fe645\",\n            roleNames: [\"GROUP_OWNER\"],\n        },\n        {\n            teamId: \"5e1dd7b4f2a30ba80a70cd4rw\",\n            roleNames: [\n                \"GROUP_READ_ONLY\",\n                \"GROUP_DATA_ACCESS_READ_WRITE\",\n            ],\n        },\n    ],\n    apiKeys: [{\n        apiKeyId: \"61003b299dda8d54a9d7d10c\",\n        roleNames: [\"GROUP_READ_ONLY\"],\n    }],\n    isCollectDatabaseSpecificsStatisticsEnabled: true,\n    isDataExplorerEnabled: true,\n    isPerformanceAdvisorEnabled: true,\n    isRealtimePerformancePanelEnabled: true,\n    isSchemaAdvisorEnabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_roles_org_id = mongodbatlas.get_roles_org_id()\ntest_project = mongodbatlas.Project(\"testProject\",\n    org_id=test_roles_org_id.org_id,\n    project_owner_id=\"\u003cOWNER_ACCOUNT_ID\u003e\",\n    teams=[\n        mongodbatlas.ProjectTeamArgs(\n            team_id=\"5e0fa8c99ccf641c722fe645\",\n            role_names=[\"GROUP_OWNER\"],\n        ),\n        mongodbatlas.ProjectTeamArgs(\n            team_id=\"5e1dd7b4f2a30ba80a70cd4rw\",\n            role_names=[\n                \"GROUP_READ_ONLY\",\n                \"GROUP_DATA_ACCESS_READ_WRITE\",\n            ],\n        ),\n    ],\n    api_keys=[mongodbatlas.ProjectApiKeyArgs(\n        api_key_id=\"61003b299dda8d54a9d7d10c\",\n        role_names=[\"GROUP_READ_ONLY\"],\n    )],\n    is_collect_database_specifics_statistics_enabled=True,\n    is_data_explorer_enabled=True,\n    is_performance_advisor_enabled=True,\n    is_realtime_performance_panel_enabled=True,\n    is_schema_advisor_enabled=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testRolesOrgId = Mongodbatlas.GetRolesOrgId.Invoke();\n\n    var testProject = new Mongodbatlas.Project(\"testProject\", new()\n    {\n        OrgId = testRolesOrgId.Apply(getRolesOrgIdResult =\u003e getRolesOrgIdResult.OrgId),\n        ProjectOwnerId = \"\u003cOWNER_ACCOUNT_ID\u003e\",\n        Teams = new[]\n        {\n            new Mongodbatlas.Inputs.ProjectTeamArgs\n            {\n                TeamId = \"5e0fa8c99ccf641c722fe645\",\n                RoleNames = new[]\n                {\n                    \"GROUP_OWNER\",\n                },\n            },\n            new Mongodbatlas.Inputs.ProjectTeamArgs\n            {\n                TeamId = \"5e1dd7b4f2a30ba80a70cd4rw\",\n                RoleNames = new[]\n                {\n                    \"GROUP_READ_ONLY\",\n                    \"GROUP_DATA_ACCESS_READ_WRITE\",\n                },\n            },\n        },\n        ApiKeys = new[]\n        {\n            new Mongodbatlas.Inputs.ProjectApiKeyArgs\n            {\n                ApiKeyId = \"61003b299dda8d54a9d7d10c\",\n                RoleNames = new[]\n                {\n                    \"GROUP_READ_ONLY\",\n                },\n            },\n        },\n        IsCollectDatabaseSpecificsStatisticsEnabled = true,\n        IsDataExplorerEnabled = true,\n        IsPerformanceAdvisorEnabled = true,\n        IsRealtimePerformancePanelEnabled = true,\n        IsSchemaAdvisorEnabled = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestRolesOrgId, err := mongodbatlas.GetRolesOrgId(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewProject(ctx, \"testProject\", \u0026mongodbatlas.ProjectArgs{\n\t\t\tOrgId:          *pulumi.String(testRolesOrgId.OrgId),\n\t\t\tProjectOwnerId: pulumi.String(\"\u003cOWNER_ACCOUNT_ID\u003e\"),\n\t\t\tTeams: mongodbatlas.ProjectTeamArray{\n\t\t\t\t\u0026mongodbatlas.ProjectTeamArgs{\n\t\t\t\t\tTeamId: pulumi.String(\"5e0fa8c99ccf641c722fe645\"),\n\t\t\t\t\tRoleNames: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_OWNER\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.ProjectTeamArgs{\n\t\t\t\t\tTeamId: pulumi.String(\"5e1dd7b4f2a30ba80a70cd4rw\"),\n\t\t\t\t\tRoleNames: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_READ_ONLY\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_READ_WRITE\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tApiKeys: mongodbatlas.ProjectApiKeyTypeArray{\n\t\t\t\t\u0026mongodbatlas.ProjectApiKeyTypeArgs{\n\t\t\t\t\tApiKeyId: pulumi.String(\"61003b299dda8d54a9d7d10c\"),\n\t\t\t\t\tRoleNames: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_READ_ONLY\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tIsCollectDatabaseSpecificsStatisticsEnabled: pulumi.Bool(true),\n\t\t\tIsDataExplorerEnabled:                       pulumi.Bool(true),\n\t\t\tIsPerformanceAdvisorEnabled:                 pulumi.Bool(true),\n\t\t\tIsRealtimePerformancePanelEnabled:           pulumi.Bool(true),\n\t\t\tIsSchemaAdvisorEnabled:                      pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.Project;\nimport com.pulumi.mongodbatlas.ProjectArgs;\nimport com.pulumi.mongodbatlas.inputs.ProjectTeamArgs;\nimport com.pulumi.mongodbatlas.inputs.ProjectApiKeyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var testRolesOrgId = MongodbatlasFunctions.getRolesOrgId();\n\n        var testProject = new Project(\"testProject\", ProjectArgs.builder()        \n            .orgId(testRolesOrgId.applyValue(getRolesOrgIdResult -\u003e getRolesOrgIdResult.orgId()))\n            .projectOwnerId(\"\u003cOWNER_ACCOUNT_ID\u003e\")\n            .teams(            \n                ProjectTeamArgs.builder()\n                    .teamId(\"5e0fa8c99ccf641c722fe645\")\n                    .roleNames(\"GROUP_OWNER\")\n                    .build(),\n                ProjectTeamArgs.builder()\n                    .teamId(\"5e1dd7b4f2a30ba80a70cd4rw\")\n                    .roleNames(                    \n                        \"GROUP_READ_ONLY\",\n                        \"GROUP_DATA_ACCESS_READ_WRITE\")\n                    .build())\n            .apiKeys(ProjectApiKeyArgs.builder()\n                .apiKeyId(\"61003b299dda8d54a9d7d10c\")\n                .roleNames(\"GROUP_READ_ONLY\")\n                .build())\n            .isCollectDatabaseSpecificsStatisticsEnabled(true)\n            .isDataExplorerEnabled(true)\n            .isPerformanceAdvisorEnabled(true)\n            .isRealtimePerformancePanelEnabled(true)\n            .isSchemaAdvisorEnabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testProject:\n    type: mongodbatlas:Project\n    properties:\n      orgId: ${testRolesOrgId.orgId}\n      projectOwnerId: \u003cOWNER_ACCOUNT_ID\u003e\n      teams:\n        - teamId: 5e0fa8c99ccf641c722fe645\n          roleNames:\n            - GROUP_OWNER\n        - teamId: 5e1dd7b4f2a30ba80a70cd4rw\n          roleNames:\n            - GROUP_READ_ONLY\n            - GROUP_DATA_ACCESS_READ_WRITE\n      apiKeys:\n        - apiKeyId: 61003b299dda8d54a9d7d10c\n          roleNames:\n            - GROUP_READ_ONLY\n      isCollectDatabaseSpecificsStatisticsEnabled: true\n      isDataExplorerEnabled: true\n      isPerformanceAdvisorEnabled: true\n      isRealtimePerformancePanelEnabled: true\n      isSchemaAdvisorEnabled: true\nvariables:\n  testRolesOrgId:\n    fn::invoke:\n      Function: mongodbatlas:getRolesOrgId\n      Arguments: {}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nProject must be imported using project ID, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/project:Project my_project 5d09d6a59ccf6445652a444a\n```\n\n For more information see[MongoDB Atlas Admin API Projects](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Projects) and [MongoDB Atlas Admin API Teams](https://docs.atlas.mongodb.com/reference/api/teams/) Documentation for more information. ",
            "properties": {
                "apiKeys": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ProjectApiKey:ProjectApiKey"
                    }
                },
                "clusterCount": {
                    "type": "integer",
                    "description": "The number of Atlas clusters deployed in the project..\n"
                },
                "created": {
                    "type": "string",
                    "description": "The ISO-8601-formatted timestamp of when Atlas created the project..\n"
                },
                "isCollectDatabaseSpecificsStatisticsEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable statistics in [cluster metrics](https://www.mongodb.com/docs/atlas/monitor-cluster-metrics/) collection for the project.\n"
                },
                "isDataExplorerEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable Data Explorer for the project. If enabled, you can query your database with an easy to use interface.  When Data Explorer is disabled, you cannot terminate slow operations from the [Real-Time Performance Panel](https://www.mongodb.com/docs/atlas/real-time-performance-panel/#std-label-real-time-metrics-status-tab) or create indexes from the [Performance Advisor](https://www.mongodb.com/docs/atlas/performance-advisor/#std-label-performance-advisor). You can still view Performance Advisor recommendations, but you must create those indexes from [mongosh](https://www.mongodb.com/docs/mongodb-shell/#mongodb-binary-bin.mongosh).\n"
                },
                "isPerformanceAdvisorEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable Performance Advisor and Profiler for the project. If enabled, you can analyze database logs to recommend performance improvements.\n"
                },
                "isRealtimePerformancePanelEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable Real Time Performance Panel for the project. If enabled, you can see real time metrics from your MongoDB database.\n"
                },
                "isSchemaAdvisorEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable Schema Advisor for the project. If enabled, you receive customized recommendations to optimize your data model and enhance performance. Disable this setting to disable schema suggestions in the [Performance Advisor](https://www.mongodb.com/docs/atlas/performance-advisor/#std-label-performance-advisor) and the [Data Explorer](https://www.mongodb.com/docs/atlas/atlas-ui/#std-label-atlas-ui).\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the project you want to create. (Cannot be changed via this Provider after creation.)\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "The ID of the organization you want to create the project within.\n"
                },
                "projectOwnerId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the Atlas user account to be granted the [Project Owner](https://docs.atlas.mongodb.com/reference/user-roles/#mongodb-authrole-Project-Owner) role on the specified project. If you set this parameter, it overrides the default value of the oldest [Organization Owner](https://docs.atlas.mongodb.com/reference/user-roles/#mongodb-authrole-Organization-Owner).\n"
                },
                "regionUsageRestrictions": {
                    "type": "string",
                    "description": "Designates that this project can be used for government regions only.  If not set the project will default to standard regions.   You cannot deploy clusters across government and standard regions in the same project. AWS is the only cloud provider for AtlasGov.  For more information see [MongoDB Atlas for Government](https://www.mongodb.com/docs/atlas/government/api/#creating-a-project).\n"
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ProjectTeam:ProjectTeam"
                    }
                },
                "withDefaultAlertsSettings": {
                    "type": "boolean",
                    "description": "It allows users to disable the creation of the default alert settings. By default, this flag is set to true.\n"
                }
            },
            "required": [
                "apiKeys",
                "clusterCount",
                "created",
                "isCollectDatabaseSpecificsStatisticsEnabled",
                "isDataExplorerEnabled",
                "isPerformanceAdvisorEnabled",
                "isRealtimePerformancePanelEnabled",
                "isSchemaAdvisorEnabled",
                "name",
                "orgId",
                "regionUsageRestrictions"
            ],
            "inputProperties": {
                "apiKeys": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ProjectApiKey:ProjectApiKey"
                    }
                },
                "isCollectDatabaseSpecificsStatisticsEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable statistics in [cluster metrics](https://www.mongodb.com/docs/atlas/monitor-cluster-metrics/) collection for the project.\n"
                },
                "isDataExplorerEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable Data Explorer for the project. If enabled, you can query your database with an easy to use interface.  When Data Explorer is disabled, you cannot terminate slow operations from the [Real-Time Performance Panel](https://www.mongodb.com/docs/atlas/real-time-performance-panel/#std-label-real-time-metrics-status-tab) or create indexes from the [Performance Advisor](https://www.mongodb.com/docs/atlas/performance-advisor/#std-label-performance-advisor). You can still view Performance Advisor recommendations, but you must create those indexes from [mongosh](https://www.mongodb.com/docs/mongodb-shell/#mongodb-binary-bin.mongosh).\n"
                },
                "isPerformanceAdvisorEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable Performance Advisor and Profiler for the project. If enabled, you can analyze database logs to recommend performance improvements.\n"
                },
                "isRealtimePerformancePanelEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable Real Time Performance Panel for the project. If enabled, you can see real time metrics from your MongoDB database.\n"
                },
                "isSchemaAdvisorEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable Schema Advisor for the project. If enabled, you receive customized recommendations to optimize your data model and enhance performance. Disable this setting to disable schema suggestions in the [Performance Advisor](https://www.mongodb.com/docs/atlas/performance-advisor/#std-label-performance-advisor) and the [Data Explorer](https://www.mongodb.com/docs/atlas/atlas-ui/#std-label-atlas-ui).\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the project you want to create. (Cannot be changed via this Provider after creation.)\n",
                    "willReplaceOnChanges": true
                },
                "orgId": {
                    "type": "string",
                    "description": "The ID of the organization you want to create the project within.\n",
                    "willReplaceOnChanges": true
                },
                "projectOwnerId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the Atlas user account to be granted the [Project Owner](https://docs.atlas.mongodb.com/reference/user-roles/#mongodb-authrole-Project-Owner) role on the specified project. If you set this parameter, it overrides the default value of the oldest [Organization Owner](https://docs.atlas.mongodb.com/reference/user-roles/#mongodb-authrole-Organization-Owner).\n"
                },
                "regionUsageRestrictions": {
                    "type": "string",
                    "description": "Designates that this project can be used for government regions only.  If not set the project will default to standard regions.   You cannot deploy clusters across government and standard regions in the same project. AWS is the only cloud provider for AtlasGov.  For more information see [MongoDB Atlas for Government](https://www.mongodb.com/docs/atlas/government/api/#creating-a-project).\n"
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ProjectTeam:ProjectTeam"
                    }
                },
                "withDefaultAlertsSettings": {
                    "type": "boolean",
                    "description": "It allows users to disable the creation of the default alert settings. By default, this flag is set to true.\n"
                }
            },
            "requiredInputs": [
                "orgId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Project resources.\n",
                "properties": {
                    "apiKeys": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/ProjectApiKey:ProjectApiKey"
                        }
                    },
                    "clusterCount": {
                        "type": "integer",
                        "description": "The number of Atlas clusters deployed in the project..\n"
                    },
                    "created": {
                        "type": "string",
                        "description": "The ISO-8601-formatted timestamp of when Atlas created the project..\n"
                    },
                    "isCollectDatabaseSpecificsStatisticsEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether to enable statistics in [cluster metrics](https://www.mongodb.com/docs/atlas/monitor-cluster-metrics/) collection for the project.\n"
                    },
                    "isDataExplorerEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether to enable Data Explorer for the project. If enabled, you can query your database with an easy to use interface.  When Data Explorer is disabled, you cannot terminate slow operations from the [Real-Time Performance Panel](https://www.mongodb.com/docs/atlas/real-time-performance-panel/#std-label-real-time-metrics-status-tab) or create indexes from the [Performance Advisor](https://www.mongodb.com/docs/atlas/performance-advisor/#std-label-performance-advisor). You can still view Performance Advisor recommendations, but you must create those indexes from [mongosh](https://www.mongodb.com/docs/mongodb-shell/#mongodb-binary-bin.mongosh).\n"
                    },
                    "isPerformanceAdvisorEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether to enable Performance Advisor and Profiler for the project. If enabled, you can analyze database logs to recommend performance improvements.\n"
                    },
                    "isRealtimePerformancePanelEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether to enable Real Time Performance Panel for the project. If enabled, you can see real time metrics from your MongoDB database.\n"
                    },
                    "isSchemaAdvisorEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether to enable Schema Advisor for the project. If enabled, you receive customized recommendations to optimize your data model and enhance performance. Disable this setting to disable schema suggestions in the [Performance Advisor](https://www.mongodb.com/docs/atlas/performance-advisor/#std-label-performance-advisor) and the [Data Explorer](https://www.mongodb.com/docs/atlas/atlas-ui/#std-label-atlas-ui).\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the project you want to create. (Cannot be changed via this Provider after creation.)\n",
                        "willReplaceOnChanges": true
                    },
                    "orgId": {
                        "type": "string",
                        "description": "The ID of the organization you want to create the project within.\n",
                        "willReplaceOnChanges": true
                    },
                    "projectOwnerId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the Atlas user account to be granted the [Project Owner](https://docs.atlas.mongodb.com/reference/user-roles/#mongodb-authrole-Project-Owner) role on the specified project. If you set this parameter, it overrides the default value of the oldest [Organization Owner](https://docs.atlas.mongodb.com/reference/user-roles/#mongodb-authrole-Organization-Owner).\n"
                    },
                    "regionUsageRestrictions": {
                        "type": "string",
                        "description": "Designates that this project can be used for government regions only.  If not set the project will default to standard regions.   You cannot deploy clusters across government and standard regions in the same project. AWS is the only cloud provider for AtlasGov.  For more information see [MongoDB Atlas for Government](https://www.mongodb.com/docs/atlas/government/api/#creating-a-project).\n"
                    },
                    "teams": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/ProjectTeam:ProjectTeam"
                        }
                    },
                    "withDefaultAlertsSettings": {
                        "type": "boolean",
                        "description": "It allows users to disable the creation of the default alert settings. By default, this flag is set to true.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/projectApiKey:ProjectApiKey": {
            "description": "\n\n## Import\n\nAPI Keys must be imported using org ID, API Key ID e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/projectApiKey:ProjectApiKey test 5d09d6a59ccf6445652a444a-6576974933969669\n```\n\n See [MongoDB Atlas API - API Key](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Programmatic-API-Keys/operation/createAndAssignOneOrganizationApiKeyToOneProject) - Documentation for more information. ",
            "properties": {
                "apiKeyId": {
                    "type": "string",
                    "description": "The unique identifier of the Programmatic API key you want to associate with the Project.  The Programmatic API key and Project must share the same parent organization.  Note: this is not the `publicKey` of the Programmatic API key but the `id` of the key. See [Programmatic API Keys](https://docs.atlas.mongodb.com/reference/api/apiKeys/) for more.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of this Organization API key.\n"
                },
                "privateKey": {
                    "type": "string",
                    "secret": true
                },
                "projectId": {
                    "type": "string"
                },
                "publicKey": {
                    "type": "string"
                },
                "roleNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project.  You must specify an array even if you are only associating a single role with the Programmatic API key.\nThe following are valid roles:\n"
                }
            },
            "required": [
                "apiKeyId",
                "description",
                "privateKey",
                "projectId",
                "publicKey",
                "roleNames"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Description of this Organization API key.\n"
                },
                "projectId": {
                    "type": "string"
                },
                "roleNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project.  You must specify an array even if you are only associating a single role with the Programmatic API key.\nThe following are valid roles:\n"
                }
            },
            "requiredInputs": [
                "description",
                "projectId",
                "roleNames"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectApiKey resources.\n",
                "properties": {
                    "apiKeyId": {
                        "type": "string",
                        "description": "The unique identifier of the Programmatic API key you want to associate with the Project.  The Programmatic API key and Project must share the same parent organization.  Note: this is not the `publicKey` of the Programmatic API key but the `id` of the key. See [Programmatic API Keys](https://docs.atlas.mongodb.com/reference/api/apiKeys/) for more.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of this Organization API key.\n"
                    },
                    "privateKey": {
                        "type": "string",
                        "secret": true
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "publicKey": {
                        "type": "string"
                    },
                    "roleNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project.  You must specify an array even if you are only associating a single role with the Programmatic API key.\nThe following are valid roles:\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/projectInvitation:ProjectInvitation": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n### S\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.ProjectInvitation(\"test\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    roles: [\"GROUP_DATA_ACCESS_READ_WRITE\"],\n    username: \"test-acc-username\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.ProjectInvitation(\"test\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    roles=[\"GROUP_DATA_ACCESS_READ_WRITE\"],\n    username=\"test-acc-username\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.ProjectInvitation(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        Roles = new[]\n        {\n            \"GROUP_DATA_ACCESS_READ_WRITE\",\n        },\n        Username = \"test-acc-username\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewProjectInvitation(ctx, \"test\", \u0026mongodbatlas.ProjectInvitationArgs{\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_READ_WRITE\"),\n\t\t\t},\n\t\t\tUsername: pulumi.String(\"test-acc-username\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ProjectInvitation;\nimport com.pulumi.mongodbatlas.ProjectInvitationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new ProjectInvitation(\"test\", ProjectInvitationArgs.builder()        \n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .roles(\"GROUP_DATA_ACCESS_READ_WRITE\")\n            .username(\"test-acc-username\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:ProjectInvitation\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      roles:\n        - GROUP_DATA_ACCESS_READ_WRITE\n      username: test-acc-username\n```\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.ProjectInvitation(\"test\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    roles: [\n        \"GROUP_READ_ONLY\",\n        \"GROUP_DATA_ACCESS_READ_ONLY\",\n    ],\n    username: \"test-acc-username\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.ProjectInvitation(\"test\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    roles=[\n        \"GROUP_READ_ONLY\",\n        \"GROUP_DATA_ACCESS_READ_ONLY\",\n    ],\n    username=\"test-acc-username\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.ProjectInvitation(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        Roles = new[]\n        {\n            \"GROUP_READ_ONLY\",\n            \"GROUP_DATA_ACCESS_READ_ONLY\",\n        },\n        Username = \"test-acc-username\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewProjectInvitation(ctx, \"test\", \u0026mongodbatlas.ProjectInvitationArgs{\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"GROUP_READ_ONLY\"),\n\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_READ_ONLY\"),\n\t\t\t},\n\t\t\tUsername: pulumi.String(\"test-acc-username\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ProjectInvitation;\nimport com.pulumi.mongodbatlas.ProjectInvitationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new ProjectInvitation(\"test\", ProjectInvitationArgs.builder()        \n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .roles(            \n                \"GROUP_READ_ONLY\",\n                \"GROUP_DATA_ACCESS_READ_ONLY\")\n            .username(\"test-acc-username\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:ProjectInvitation\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      roles:\n        - GROUP_READ_ONLY\n        - GROUP_DATA_ACCESS_READ_ONLY\n      username: test-acc-username\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n~\u003e **IMPORTANT:** A project invitation can **not** be imported once it has been accepted. Import a user's invitation to a project by separating the `project_id` and the `username` with a hyphen\n\n```sh\n $ pulumi import mongodbatlas:index/projectInvitation:ProjectInvitation my_user 1112222b3bf99403840e8934-my_user@mongodb.com\n```\n\n ",
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when Atlas sent the invitation.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when the invitation expires. Users have 30 days to accept an invitation.\n"
                },
                "invitationId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the invitation in Atlas.\n"
                },
                "inviterUsername": {
                    "type": "string",
                    "description": "Atlas user who invited `username` to the project.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the project to which you want to invite a user.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Atlas roles to assign to the invited user. If the user accepts the invitation, Atlas assigns these roles to them. Refer to the [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) for information on valid roles.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Email address to which Atlas sent the invitation. The user uses this email address as their Atlas username if they accept this invitation.\n"
                }
            },
            "required": [
                "createdAt",
                "expiresAt",
                "invitationId",
                "inviterUsername",
                "projectId",
                "roles",
                "username"
            ],
            "inputProperties": {
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the project to which you want to invite a user.\n",
                    "willReplaceOnChanges": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Atlas roles to assign to the invited user. If the user accepts the invitation, Atlas assigns these roles to them. Refer to the [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) for information on valid roles.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Email address to which Atlas sent the invitation. The user uses this email address as their Atlas username if they accept this invitation.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "projectId",
                "roles",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectInvitation resources.\n",
                "properties": {
                    "createdAt": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when Atlas sent the invitation.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when the invitation expires. Users have 30 days to accept an invitation.\n"
                    },
                    "invitationId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the invitation in Atlas.\n"
                    },
                    "inviterUsername": {
                        "type": "string",
                        "description": "Atlas user who invited `username` to the project.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the project to which you want to invite a user.\n",
                        "willReplaceOnChanges": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Atlas roles to assign to the invited user. If the user accepts the invitation, Atlas assigns these roles to them. Refer to the [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) for information on valid roles.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Email address to which Atlas sent the invitation. The user uses this email address as their Atlas username if they accept this invitation.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/projectIpAccessList:ProjectIpAccessList": {
            "description": "`mongodbatlas.ProjectIpAccessList` provides an IP Access List entry resource. The access list grants access from IPs, CIDRs or AWS Security Groups (if VPC Peering is enabled) to clusters within the Project.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n\u003e **IMPORTANT:**\nWhen you remove an entry from the access list, existing connections from the removed address(es) may remain open for a variable amount of time. How much time passes before Atlas closes the connection depends on several factors, including how the connection was established, the particular behavior of the application or driver using the address, and the connection protocol (e.g., TCP or UDP). This is particularly important to consider when changing an existing IP address or CIDR block as they cannot be updated via the Provider (comments can however), hence a change will force the destruction and recreation of entries.   \n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Using CIDR Block\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.ProjectIpAccessList(\"test\", {\n    cidrBlock: \"1.2.3.4/32\",\n    comment: \"cidr block for tf acc testing\",\n    projectId: \"\u003cPROJECT-ID\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.ProjectIpAccessList(\"test\",\n    cidr_block=\"1.2.3.4/32\",\n    comment=\"cidr block for tf acc testing\",\n    project_id=\"\u003cPROJECT-ID\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.ProjectIpAccessList(\"test\", new()\n    {\n        CidrBlock = \"1.2.3.4/32\",\n        Comment = \"cidr block for tf acc testing\",\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewProjectIpAccessList(ctx, \"test\", \u0026mongodbatlas.ProjectIpAccessListArgs{\n\t\t\tCidrBlock: pulumi.String(\"1.2.3.4/32\"),\n\t\t\tComment:   pulumi.String(\"cidr block for tf acc testing\"),\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ProjectIpAccessList;\nimport com.pulumi.mongodbatlas.ProjectIpAccessListArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new ProjectIpAccessList(\"test\", ProjectIpAccessListArgs.builder()        \n            .cidrBlock(\"1.2.3.4/32\")\n            .comment(\"cidr block for tf acc testing\")\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:ProjectIpAccessList\n    properties:\n      cidrBlock: 1.2.3.4/32\n      comment: cidr block for tf acc testing\n      projectId: \u003cPROJECT-ID\u003e\n```\n{{% /example %}}\n{{% example %}}\n### Using IP Address\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.ProjectIpAccessList(\"test\", {\n    comment: \"ip address for tf acc testing\",\n    ipAddress: \"2.3.4.5\",\n    projectId: \"\u003cPROJECT-ID\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.ProjectIpAccessList(\"test\",\n    comment=\"ip address for tf acc testing\",\n    ip_address=\"2.3.4.5\",\n    project_id=\"\u003cPROJECT-ID\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.ProjectIpAccessList(\"test\", new()\n    {\n        Comment = \"ip address for tf acc testing\",\n        IpAddress = \"2.3.4.5\",\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewProjectIpAccessList(ctx, \"test\", \u0026mongodbatlas.ProjectIpAccessListArgs{\n\t\t\tComment:   pulumi.String(\"ip address for tf acc testing\"),\n\t\t\tIpAddress: pulumi.String(\"2.3.4.5\"),\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ProjectIpAccessList;\nimport com.pulumi.mongodbatlas.ProjectIpAccessListArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new ProjectIpAccessList(\"test\", ProjectIpAccessListArgs.builder()        \n            .comment(\"ip address for tf acc testing\")\n            .ipAddress(\"2.3.4.5\")\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:ProjectIpAccessList\n    properties:\n      comment: ip address for tf acc testing\n      ipAddress: 2.3.4.5\n      projectId: \u003cPROJECT-ID\u003e\n```\n{{% /example %}}\n{{% example %}}\n### Using an AWS Security Group\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testNetworkContainer = new mongodbatlas.NetworkContainer(\"testNetworkContainer\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    atlasCidrBlock: \"192.168.208.0/21\",\n    providerName: \"AWS\",\n    regionName: \"US_EAST_1\",\n});\nconst testNetworkPeering = new mongodbatlas.NetworkPeering(\"testNetworkPeering\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    containerId: testNetworkContainer.containerId,\n    accepterRegionName: \"us-east-1\",\n    providerName: \"AWS\",\n    routeTableCidrBlock: \"172.31.0.0/16\",\n    vpcId: \"vpc-0d93d6f69f1578bd8\",\n    awsAccountId: \"232589400519\",\n});\nconst testProjectIpAccessList = new mongodbatlas.ProjectIpAccessList(\"testProjectIpAccessList\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    awsSecurityGroup: \"sg-0026348ec11780bd1\",\n    comment: \"TestAcc for awsSecurityGroup\",\n}, {\n    dependsOn: [\"mongodbatlas_network_peering.test\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_network_container = mongodbatlas.NetworkContainer(\"testNetworkContainer\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    atlas_cidr_block=\"192.168.208.0/21\",\n    provider_name=\"AWS\",\n    region_name=\"US_EAST_1\")\ntest_network_peering = mongodbatlas.NetworkPeering(\"testNetworkPeering\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    container_id=test_network_container.container_id,\n    accepter_region_name=\"us-east-1\",\n    provider_name=\"AWS\",\n    route_table_cidr_block=\"172.31.0.0/16\",\n    vpc_id=\"vpc-0d93d6f69f1578bd8\",\n    aws_account_id=\"232589400519\")\ntest_project_ip_access_list = mongodbatlas.ProjectIpAccessList(\"testProjectIpAccessList\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    aws_security_group=\"sg-0026348ec11780bd1\",\n    comment=\"TestAcc for awsSecurityGroup\",\n    opts=pulumi.ResourceOptions(depends_on=[\"mongodbatlas_network_peering.test\"]))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testNetworkContainer = new Mongodbatlas.NetworkContainer(\"testNetworkContainer\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        AtlasCidrBlock = \"192.168.208.0/21\",\n        ProviderName = \"AWS\",\n        RegionName = \"US_EAST_1\",\n    });\n\n    var testNetworkPeering = new Mongodbatlas.NetworkPeering(\"testNetworkPeering\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        ContainerId = testNetworkContainer.ContainerId,\n        AccepterRegionName = \"us-east-1\",\n        ProviderName = \"AWS\",\n        RouteTableCidrBlock = \"172.31.0.0/16\",\n        VpcId = \"vpc-0d93d6f69f1578bd8\",\n        AwsAccountId = \"232589400519\",\n    });\n\n    var testProjectIpAccessList = new Mongodbatlas.ProjectIpAccessList(\"testProjectIpAccessList\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        AwsSecurityGroup = \"sg-0026348ec11780bd1\",\n        Comment = \"TestAcc for awsSecurityGroup\",\n    }, new CustomResourceOptions\n    {\n        DependsOn = new[]\n        {\n            \"mongodbatlas_network_peering.test\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestNetworkContainer, err := mongodbatlas.NewNetworkContainer(ctx, \"testNetworkContainer\", \u0026mongodbatlas.NetworkContainerArgs{\n\t\t\tProjectId:      pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tAtlasCidrBlock: pulumi.String(\"192.168.208.0/21\"),\n\t\t\tProviderName:   pulumi.String(\"AWS\"),\n\t\t\tRegionName:     pulumi.String(\"US_EAST_1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewNetworkPeering(ctx, \"testNetworkPeering\", \u0026mongodbatlas.NetworkPeeringArgs{\n\t\t\tProjectId:           pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tContainerId:         testNetworkContainer.ContainerId,\n\t\t\tAccepterRegionName:  pulumi.String(\"us-east-1\"),\n\t\t\tProviderName:        pulumi.String(\"AWS\"),\n\t\t\tRouteTableCidrBlock: pulumi.String(\"172.31.0.0/16\"),\n\t\t\tVpcId:               pulumi.String(\"vpc-0d93d6f69f1578bd8\"),\n\t\t\tAwsAccountId:        pulumi.String(\"232589400519\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewProjectIpAccessList(ctx, \"testProjectIpAccessList\", \u0026mongodbatlas.ProjectIpAccessListArgs{\n\t\t\tProjectId:        pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tAwsSecurityGroup: pulumi.String(\"sg-0026348ec11780bd1\"),\n\t\t\tComment:          pulumi.String(\"TestAcc for awsSecurityGroup\"),\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\tpulumi.Resource(\"mongodbatlas_network_peering.test\"),\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.NetworkContainer;\nimport com.pulumi.mongodbatlas.NetworkContainerArgs;\nimport com.pulumi.mongodbatlas.NetworkPeering;\nimport com.pulumi.mongodbatlas.NetworkPeeringArgs;\nimport com.pulumi.mongodbatlas.ProjectIpAccessList;\nimport com.pulumi.mongodbatlas.ProjectIpAccessListArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testNetworkContainer = new NetworkContainer(\"testNetworkContainer\", NetworkContainerArgs.builder()        \n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .atlasCidrBlock(\"192.168.208.0/21\")\n            .providerName(\"AWS\")\n            .regionName(\"US_EAST_1\")\n            .build());\n\n        var testNetworkPeering = new NetworkPeering(\"testNetworkPeering\", NetworkPeeringArgs.builder()        \n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .containerId(testNetworkContainer.containerId())\n            .accepterRegionName(\"us-east-1\")\n            .providerName(\"AWS\")\n            .routeTableCidrBlock(\"172.31.0.0/16\")\n            .vpcId(\"vpc-0d93d6f69f1578bd8\")\n            .awsAccountId(\"232589400519\")\n            .build());\n\n        var testProjectIpAccessList = new ProjectIpAccessList(\"testProjectIpAccessList\", ProjectIpAccessListArgs.builder()        \n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .awsSecurityGroup(\"sg-0026348ec11780bd1\")\n            .comment(\"TestAcc for awsSecurityGroup\")\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(\"mongodbatlas_network_peering.test\")\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testNetworkContainer:\n    type: mongodbatlas:NetworkContainer\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      atlasCidrBlock: 192.168.208.0/21\n      providerName: AWS\n      regionName: US_EAST_1\n  testNetworkPeering:\n    type: mongodbatlas:NetworkPeering\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      containerId: ${testNetworkContainer.containerId}\n      accepterRegionName: us-east-1\n      providerName: AWS\n      routeTableCidrBlock: 172.31.0.0/16\n      vpcId: vpc-0d93d6f69f1578bd8\n      awsAccountId: '232589400519'\n  testProjectIpAccessList:\n    type: mongodbatlas:ProjectIpAccessList\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      awsSecurityGroup: sg-0026348ec11780bd1\n      comment: TestAcc for awsSecurityGroup\n    options:\n      dependson:\n        - mongodbatlas_network_peering.test\n```\n\n\u003e **IMPORTANT:** In order to use AWS Security Group(s) VPC Peering must be enabled like above example.\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nIP Access List entries can be imported using the `project_id` and `cidr_block` or `ip_address`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/projectIpAccessList:ProjectIpAccessList test 5d0f1f74cf09a29120e123cd-10.242.88.0/21\n```\n\n For more information see[MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/access-lists/) ",
            "properties": {
                "awsSecurityGroup": {
                    "type": "string",
                    "description": "Unique identifier of the AWS security group to add to the access list. Your access list entry can include only one `awsSecurityGroup`, one `cidrBlock`, or one `ipAddress`.\n"
                },
                "cidrBlock": {
                    "type": "string",
                    "description": "Range of IP addresses in CIDR notation to be added to the access list. Your access list entry can include only one `awsSecurityGroup`, one `cidrBlock`, or one `ipAddress`.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Comment to add to the access list entry.\n"
                },
                "ipAddress": {
                    "type": "string",
                    "description": "Single IP address to be added to the access list. Mutually exclusive with `awsSecurityGroup` and `cidrBlock`.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique identifier for the project to which you want to add one or more access list entries.\n"
                }
            },
            "required": [
                "awsSecurityGroup",
                "cidrBlock",
                "comment",
                "ipAddress",
                "projectId"
            ],
            "inputProperties": {
                "awsSecurityGroup": {
                    "type": "string",
                    "description": "Unique identifier of the AWS security group to add to the access list. Your access list entry can include only one `awsSecurityGroup`, one `cidrBlock`, or one `ipAddress`.\n",
                    "willReplaceOnChanges": true
                },
                "cidrBlock": {
                    "type": "string",
                    "description": "Range of IP addresses in CIDR notation to be added to the access list. Your access list entry can include only one `awsSecurityGroup`, one `cidrBlock`, or one `ipAddress`.\n",
                    "willReplaceOnChanges": true
                },
                "comment": {
                    "type": "string",
                    "description": "Comment to add to the access list entry.\n",
                    "willReplaceOnChanges": true
                },
                "ipAddress": {
                    "type": "string",
                    "description": "Single IP address to be added to the access list. Mutually exclusive with `awsSecurityGroup` and `cidrBlock`.\n",
                    "willReplaceOnChanges": true
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique identifier for the project to which you want to add one or more access list entries.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectIpAccessList resources.\n",
                "properties": {
                    "awsSecurityGroup": {
                        "type": "string",
                        "description": "Unique identifier of the AWS security group to add to the access list. Your access list entry can include only one `awsSecurityGroup`, one `cidrBlock`, or one `ipAddress`.\n",
                        "willReplaceOnChanges": true
                    },
                    "cidrBlock": {
                        "type": "string",
                        "description": "Range of IP addresses in CIDR notation to be added to the access list. Your access list entry can include only one `awsSecurityGroup`, one `cidrBlock`, or one `ipAddress`.\n",
                        "willReplaceOnChanges": true
                    },
                    "comment": {
                        "type": "string",
                        "description": "Comment to add to the access list entry.\n",
                        "willReplaceOnChanges": true
                    },
                    "ipAddress": {
                        "type": "string",
                        "description": "Single IP address to be added to the access list. Mutually exclusive with `awsSecurityGroup` and `cidrBlock`.\n",
                        "willReplaceOnChanges": true
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique identifier for the project to which you want to add one or more access list entries.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/searchIndex:SearchIndex": {
            "description": "`mongodbatlas.SearchIndex` provides a Search Index resource. This allows indexes to be created.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Basic \n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.SearchIndex(\"test\", {\n    analyzer: \"lucene.standard\",\n    clusterName: \"\u003cCLUSTER_NAME\u003e\",\n    collectionName: \"collection_test\",\n    database: \"database_test\",\n    mappingsDynamic: true,\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    searchAnalyzer: \"lucene.standard\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.SearchIndex(\"test\",\n    analyzer=\"lucene.standard\",\n    cluster_name=\"\u003cCLUSTER_NAME\u003e\",\n    collection_name=\"collection_test\",\n    database=\"database_test\",\n    mappings_dynamic=True,\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    search_analyzer=\"lucene.standard\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.SearchIndex(\"test\", new()\n    {\n        Analyzer = \"lucene.standard\",\n        ClusterName = \"\u003cCLUSTER_NAME\u003e\",\n        CollectionName = \"collection_test\",\n        Database = \"database_test\",\n        MappingsDynamic = true,\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        SearchAnalyzer = \"lucene.standard\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewSearchIndex(ctx, \"test\", \u0026mongodbatlas.SearchIndexArgs{\n\t\t\tAnalyzer:        pulumi.String(\"lucene.standard\"),\n\t\t\tClusterName:     pulumi.String(\"\u003cCLUSTER_NAME\u003e\"),\n\t\t\tCollectionName:  pulumi.String(\"collection_test\"),\n\t\t\tDatabase:        pulumi.String(\"database_test\"),\n\t\t\tMappingsDynamic: pulumi.Bool(true),\n\t\t\tProjectId:       pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tSearchAnalyzer:  pulumi.String(\"lucene.standard\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.SearchIndex;\nimport com.pulumi.mongodbatlas.SearchIndexArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new SearchIndex(\"test\", SearchIndexArgs.builder()        \n            .analyzer(\"lucene.standard\")\n            .clusterName(\"\u003cCLUSTER_NAME\u003e\")\n            .collectionName(\"collection_test\")\n            .database(\"database_test\")\n            .mappingsDynamic(true)\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .searchAnalyzer(\"lucene.standard\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:SearchIndex\n    properties:\n      analyzer: lucene.standard\n      clusterName: \u003cCLUSTER_NAME\u003e\n      collectionName: collection_test\n      database: database_test\n      mappingsDynamic: true\n      projectId: \u003cPROJECT_ID\u003e\n      searchAnalyzer: lucene.standard\n```\n{{% /example %}}\n{{% example %}}\n### Advanced (with custom analyzers)\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.SearchIndex(\"test\", {\n    projectId: \"%[1]s\",\n    clusterName: \"%[2]s\",\n    analyzer: \"lucene.standard\",\n    collectionName: \"collection_test\",\n    database: \"database_test\",\n    mappingsDynamic: false,\n    mappingsFields: `{\n      \"address\": {\n        \"type\": \"document\",\n        \"fields\": {\n          \"city\": {\n            \"type\": \"string\",\n            \"analyzer\": \"lucene.simple\",\n            \"ignoreAbove\": 255\n          },\n          \"state\": {\n            \"type\": \"string\",\n            \"analyzer\": \"lucene.english\"\n          }\n        }\n      },\n      \"company\": {\n        \"type\": \"string\",\n        \"analyzer\": \"lucene.whitespace\",\n        \"multi\": {\n          \"mySecondaryAnalyzer\": {\n            \"type\": \"string\",\n            \"analyzer\": \"lucene.french\"\n          }\n        }\n      },\n      \"employees\": {\n        \"type\": \"string\",\n        \"analyzer\": \"lucene.standard\"\n      }\n}\n`,\n    searchAnalyzer: \"lucene.standard\",\n    analyzers: ` [{\n \"name\": \"index_analyzer_test_name\",\n \"charFilters\": {\n\"type\": \"mapping\",\n\"mappings\": {\"\\\\\\\\\" : \"/\"}\n   \t},\n \"tokenizer\": {\n \"type\": \"nGram\",\n \"minGram\": 2,\n \"maxGram\": 5\n\t},\n \"tokenFilters\": {\n\"type\": \"length\",\n\"min\": 20,\n\"max\": 33\n   \t}\n }]\n`,\n    synonyms: [{\n        analyzer: \"lucene.simple\",\n        name: \"synonym_test\",\n        sourceCollection: \"collection_test\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.SearchIndex(\"test\",\n    project_id=\"%[1]s\",\n    cluster_name=\"%[2]s\",\n    analyzer=\"lucene.standard\",\n    collection_name=\"collection_test\",\n    database=\"database_test\",\n    mappings_dynamic=False,\n    mappings_fields=\"\"\"{\n      \"address\": {\n        \"type\": \"document\",\n        \"fields\": {\n          \"city\": {\n            \"type\": \"string\",\n            \"analyzer\": \"lucene.simple\",\n            \"ignoreAbove\": 255\n          },\n          \"state\": {\n            \"type\": \"string\",\n            \"analyzer\": \"lucene.english\"\n          }\n        }\n      },\n      \"company\": {\n        \"type\": \"string\",\n        \"analyzer\": \"lucene.whitespace\",\n        \"multi\": {\n          \"mySecondaryAnalyzer\": {\n            \"type\": \"string\",\n            \"analyzer\": \"lucene.french\"\n          }\n        }\n      },\n      \"employees\": {\n        \"type\": \"string\",\n        \"analyzer\": \"lucene.standard\"\n      }\n}\n\"\"\",\n    search_analyzer=\"lucene.standard\",\n    analyzers=\"\"\" [{\n \"name\": \"index_analyzer_test_name\",\n \"charFilters\": {\n\"type\": \"mapping\",\n\"mappings\": {\"\\\\\" : \"/\"}\n   \t},\n \"tokenizer\": {\n \"type\": \"nGram\",\n \"minGram\": 2,\n \"maxGram\": 5\n\t},\n \"tokenFilters\": {\n\"type\": \"length\",\n\"min\": 20,\n\"max\": 33\n   \t}\n }]\n\"\"\",\n    synonyms=[mongodbatlas.SearchIndexSynonymArgs(\n        analyzer=\"lucene.simple\",\n        name=\"synonym_test\",\n        source_collection=\"collection_test\",\n    )])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.SearchIndex(\"test\", new()\n    {\n        ProjectId = \"%[1]s\",\n        ClusterName = \"%[2]s\",\n        Analyzer = \"lucene.standard\",\n        CollectionName = \"collection_test\",\n        Database = \"database_test\",\n        MappingsDynamic = false,\n        MappingsFields = @\"{\n      \"\"address\"\": {\n        \"\"type\"\": \"\"document\"\",\n        \"\"fields\"\": {\n          \"\"city\"\": {\n            \"\"type\"\": \"\"string\"\",\n            \"\"analyzer\"\": \"\"lucene.simple\"\",\n            \"\"ignoreAbove\"\": 255\n          },\n          \"\"state\"\": {\n            \"\"type\"\": \"\"string\"\",\n            \"\"analyzer\"\": \"\"lucene.english\"\"\n          }\n        }\n      },\n      \"\"company\"\": {\n        \"\"type\"\": \"\"string\"\",\n        \"\"analyzer\"\": \"\"lucene.whitespace\"\",\n        \"\"multi\"\": {\n          \"\"mySecondaryAnalyzer\"\": {\n            \"\"type\"\": \"\"string\"\",\n            \"\"analyzer\"\": \"\"lucene.french\"\"\n          }\n        }\n      },\n      \"\"employees\"\": {\n        \"\"type\"\": \"\"string\"\",\n        \"\"analyzer\"\": \"\"lucene.standard\"\"\n      }\n}\n\",\n        SearchAnalyzer = \"lucene.standard\",\n        Analyzers = @\" [{\n \"\"name\"\": \"\"index_analyzer_test_name\"\",\n \"\"charFilters\"\": {\n\"\"type\"\": \"\"mapping\"\",\n\"\"mappings\"\": {\"\"\\\\\"\" : \"\"/\"\"}\n   \t},\n \"\"tokenizer\"\": {\n \"\"type\"\": \"\"nGram\"\",\n \"\"minGram\"\": 2,\n \"\"maxGram\"\": 5\n\t},\n \"\"tokenFilters\"\": {\n\"\"type\"\": \"\"length\"\",\n\"\"min\"\": 20,\n\"\"max\"\": 33\n   \t}\n }]\n\",\n        Synonyms = new[]\n        {\n            new Mongodbatlas.Inputs.SearchIndexSynonymArgs\n            {\n                Analyzer = \"lucene.simple\",\n                Name = \"synonym_test\",\n                SourceCollection = \"collection_test\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewSearchIndex(ctx, \"test\", \u0026mongodbatlas.SearchIndexArgs{\n\t\t\tProjectId:       pulumi.String(\"%[1]s\"),\n\t\t\tClusterName:     pulumi.String(\"%[2]s\"),\n\t\t\tAnalyzer:        pulumi.String(\"lucene.standard\"),\n\t\t\tCollectionName:  pulumi.String(\"collection_test\"),\n\t\t\tDatabase:        pulumi.String(\"database_test\"),\n\t\t\tMappingsDynamic: pulumi.Bool(false),\n\t\t\tMappingsFields:  pulumi.String(\"{\\n      \\\"address\\\": {\\n        \\\"type\\\": \\\"document\\\",\\n        \\\"fields\\\": {\\n          \\\"city\\\": {\\n            \\\"type\\\": \\\"string\\\",\\n            \\\"analyzer\\\": \\\"lucene.simple\\\",\\n            \\\"ignoreAbove\\\": 255\\n          },\\n          \\\"state\\\": {\\n            \\\"type\\\": \\\"string\\\",\\n            \\\"analyzer\\\": \\\"lucene.english\\\"\\n          }\\n        }\\n      },\\n      \\\"company\\\": {\\n        \\\"type\\\": \\\"string\\\",\\n        \\\"analyzer\\\": \\\"lucene.whitespace\\\",\\n        \\\"multi\\\": {\\n          \\\"mySecondaryAnalyzer\\\": {\\n            \\\"type\\\": \\\"string\\\",\\n            \\\"analyzer\\\": \\\"lucene.french\\\"\\n          }\\n        }\\n      },\\n      \\\"employees\\\": {\\n        \\\"type\\\": \\\"string\\\",\\n        \\\"analyzer\\\": \\\"lucene.standard\\\"\\n      }\\n}\\n\"),\n\t\t\tSearchAnalyzer:  pulumi.String(\"lucene.standard\"),\n\t\t\tAnalyzers:       pulumi.String(\" [{\\n \\\"name\\\": \\\"index_analyzer_test_name\\\",\\n \\\"charFilters\\\": {\\n\\\"type\\\": \\\"mapping\\\",\\n\\\"mappings\\\": {\\\"\\\\\\\\\\\" : \\\"/\\\"}\\n   \t},\\n \\\"tokenizer\\\": {\\n \\\"type\\\": \\\"nGram\\\",\\n \\\"minGram\\\": 2,\\n \\\"maxGram\\\": 5\\n\t},\\n \\\"tokenFilters\\\": {\\n\\\"type\\\": \\\"length\\\",\\n\\\"min\\\": 20,\\n\\\"max\\\": 33\\n   \t}\\n }]\\n\"),\n\t\t\tSynonyms: mongodbatlas.SearchIndexSynonymArray{\n\t\t\t\t\u0026mongodbatlas.SearchIndexSynonymArgs{\n\t\t\t\t\tAnalyzer:         pulumi.String(\"lucene.simple\"),\n\t\t\t\t\tName:             pulumi.String(\"synonym_test\"),\n\t\t\t\t\tSourceCollection: pulumi.String(\"collection_test\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.SearchIndex;\nimport com.pulumi.mongodbatlas.SearchIndexArgs;\nimport com.pulumi.mongodbatlas.inputs.SearchIndexSynonymArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new SearchIndex(\"test\", SearchIndexArgs.builder()        \n            .projectId(\"%[1]s\")\n            .clusterName(\"%[2]s\")\n            .analyzer(\"lucene.standard\")\n            .collectionName(\"collection_test\")\n            .database(\"database_test\")\n            .mappingsDynamic(false)\n            .mappingsFields(\"\"\"\n{\n      \"address\": {\n        \"type\": \"document\",\n        \"fields\": {\n          \"city\": {\n            \"type\": \"string\",\n            \"analyzer\": \"lucene.simple\",\n            \"ignoreAbove\": 255\n          },\n          \"state\": {\n            \"type\": \"string\",\n            \"analyzer\": \"lucene.english\"\n          }\n        }\n      },\n      \"company\": {\n        \"type\": \"string\",\n        \"analyzer\": \"lucene.whitespace\",\n        \"multi\": {\n          \"mySecondaryAnalyzer\": {\n            \"type\": \"string\",\n            \"analyzer\": \"lucene.french\"\n          }\n        }\n      },\n      \"employees\": {\n        \"type\": \"string\",\n        \"analyzer\": \"lucene.standard\"\n      }\n}\n            \"\"\")\n            .searchAnalyzer(\"lucene.standard\")\n            .analyzers(\"\"\"\n [{\n \"name\": \"index_analyzer_test_name\",\n \"charFilters\": {\n\"type\": \"mapping\",\n\"mappings\": {\"\\\\\" : \"/\"}\n   \t},\n \"tokenizer\": {\n \"type\": \"nGram\",\n \"minGram\": 2,\n \"maxGram\": 5\n\t},\n \"tokenFilters\": {\n\"type\": \"length\",\n\"min\": 20,\n\"max\": 33\n   \t}\n }]\n            \"\"\")\n            .synonyms(SearchIndexSynonymArgs.builder()\n                .analyzer(\"lucene.simple\")\n                .name(\"synonym_test\")\n                .sourceCollection(\"collection_test\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:SearchIndex\n    properties:\n      projectId: '%[1]s'\n      clusterName: '%[2]s'\n      analyzer: lucene.standard\n      collectionName: collection_test\n      database: database_test\n      mappingsDynamic: false\n      mappingsFields: |\n        {\n              \"address\": {\n                \"type\": \"document\",\n                \"fields\": {\n                  \"city\": {\n                    \"type\": \"string\",\n                    \"analyzer\": \"lucene.simple\",\n                    \"ignoreAbove\": 255\n                  },\n                  \"state\": {\n                    \"type\": \"string\",\n                    \"analyzer\": \"lucene.english\"\n                  }\n                }\n              },\n              \"company\": {\n                \"type\": \"string\",\n                \"analyzer\": \"lucene.whitespace\",\n                \"multi\": {\n                  \"mySecondaryAnalyzer\": {\n                    \"type\": \"string\",\n                    \"analyzer\": \"lucene.french\"\n                  }\n                }\n              },\n              \"employees\": {\n                \"type\": \"string\",\n                \"analyzer\": \"lucene.standard\"\n              }\n        }\n      searchAnalyzer: lucene.standard\n      analyzers: |2\n         [{\n         \"name\": \"index_analyzer_test_name\",\n         \"charFilters\": {\n        \"type\": \"mapping\",\n        \"mappings\": {\"\\\\\" : \"/\"}\n           \t},\n         \"tokenizer\": {\n         \"type\": \"nGram\",\n         \"minGram\": 2,\n         \"maxGram\": 5\n        \t},\n         \"tokenFilters\": {\n        \"type\": \"length\",\n        \"min\": 20,\n        \"max\": 33\n           \t}\n         }]\n      synonyms:\n        - analyzer: lucene.simple\n          name: synonym_test\n          sourceCollection: collection_test\n```\n{{% /example %}}\n{{% /examples %}}",
            "properties": {
                "analyzer": {
                    "type": "string",
                    "description": "[Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index. Defaults to [lucene.standard](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/standard/#std-label-ref-standard-analyzer)\n"
                },
                "analyzers": {
                    "type": "string",
                    "description": "[Custom analyzers](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-custom-analyzers) to use in this index. This is an array of JSON objects.\n"
                },
                "clusterName": {
                    "type": "string",
                    "description": "The name of the cluster where you want to create the search index within.\n"
                },
                "collectionName": {
                    "type": "string",
                    "description": "Name of the collection the index is on.\n"
                },
                "database": {
                    "type": "string",
                    "description": "Name of the database the collection is in.\n"
                },
                "indexId": {
                    "type": "string"
                },
                "mappingsDynamic": {
                    "type": "boolean",
                    "description": "Indicates whether the index uses dynamic or static mapping. For dynamic mapping, set the value to `true`. For static mapping, specify the fields to index using `mappings_fields`\n"
                },
                "mappingsFields": {
                    "type": "string",
                    "description": "attribute is required when `mappings_dynamic` is true. This field needs to be a JSON string in order to be decoded correctly.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the search index you want to create.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The ID of the organization or project you want to create the search index within.\n"
                },
                "searchAnalyzer": {
                    "type": "string",
                    "description": "[Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when searching the index. Defaults to [lucene.standard](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/standard/#std-label-ref-standard-analyzer)\n"
                },
                "status": {
                    "type": "string"
                },
                "synonyms": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/SearchIndexSynonym:SearchIndexSynonym"
                    },
                    "description": "Synonyms mapping definition to use in this index.\n"
                }
            },
            "required": [
                "analyzer",
                "clusterName",
                "collectionName",
                "database",
                "indexId",
                "name",
                "projectId",
                "status"
            ],
            "inputProperties": {
                "analyzer": {
                    "type": "string",
                    "description": "[Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index. Defaults to [lucene.standard](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/standard/#std-label-ref-standard-analyzer)\n"
                },
                "analyzers": {
                    "type": "string",
                    "description": "[Custom analyzers](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-custom-analyzers) to use in this index. This is an array of JSON objects.\n"
                },
                "clusterName": {
                    "type": "string",
                    "description": "The name of the cluster where you want to create the search index within.\n"
                },
                "collectionName": {
                    "type": "string",
                    "description": "Name of the collection the index is on.\n"
                },
                "database": {
                    "type": "string",
                    "description": "Name of the database the collection is in.\n"
                },
                "mappingsDynamic": {
                    "type": "boolean",
                    "description": "Indicates whether the index uses dynamic or static mapping. For dynamic mapping, set the value to `true`. For static mapping, specify the fields to index using `mappings_fields`\n"
                },
                "mappingsFields": {
                    "type": "string",
                    "description": "attribute is required when `mappings_dynamic` is true. This field needs to be a JSON string in order to be decoded correctly.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the search index you want to create.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The ID of the organization or project you want to create the search index within.\n"
                },
                "searchAnalyzer": {
                    "type": "string",
                    "description": "[Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when searching the index. Defaults to [lucene.standard](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/standard/#std-label-ref-standard-analyzer)\n"
                },
                "status": {
                    "type": "string"
                },
                "synonyms": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/SearchIndexSynonym:SearchIndexSynonym"
                    },
                    "description": "Synonyms mapping definition to use in this index.\n"
                }
            },
            "requiredInputs": [
                "analyzer",
                "clusterName",
                "collectionName",
                "database",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SearchIndex resources.\n",
                "properties": {
                    "analyzer": {
                        "type": "string",
                        "description": "[Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index. Defaults to [lucene.standard](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/standard/#std-label-ref-standard-analyzer)\n"
                    },
                    "analyzers": {
                        "type": "string",
                        "description": "[Custom analyzers](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-custom-analyzers) to use in this index. This is an array of JSON objects.\n"
                    },
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the cluster where you want to create the search index within.\n"
                    },
                    "collectionName": {
                        "type": "string",
                        "description": "Name of the collection the index is on.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "Name of the database the collection is in.\n"
                    },
                    "indexId": {
                        "type": "string"
                    },
                    "mappingsDynamic": {
                        "type": "boolean",
                        "description": "Indicates whether the index uses dynamic or static mapping. For dynamic mapping, set the value to `true`. For static mapping, specify the fields to index using `mappings_fields`\n"
                    },
                    "mappingsFields": {
                        "type": "string",
                        "description": "attribute is required when `mappings_dynamic` is true. This field needs to be a JSON string in order to be decoded correctly.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the search index you want to create.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The ID of the organization or project you want to create the search index within.\n"
                    },
                    "searchAnalyzer": {
                        "type": "string",
                        "description": "[Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when searching the index. Defaults to [lucene.standard](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/standard/#std-label-ref-standard-analyzer)\n"
                    },
                    "status": {
                        "type": "string"
                    },
                    "synonyms": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/SearchIndexSynonym:SearchIndexSynonym"
                        },
                        "description": "Synonyms mapping definition to use in this index.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/serverlessInstance:ServerlessInstance": {
            "description": "`mongodbatlas.ServerlessInstance` provides a Serverless Instance resource. This allows serverless instances to be created.\n\n\u003e **NOTE:**  Serverless instances do not support some Atlas features at this time.\nFor a full list of unsupported features, see [Serverless Instance Limitations](https://docs.atlas.mongodb.com/reference/serverless-instance-limitations/).\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Basic\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.ServerlessInstance(\"test\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    providerSettingsBackingProviderName: \"AWS\",\n    providerSettingsProviderName: \"SERVERLESS\",\n    providerSettingsRegionName: \"US_EAST_1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.ServerlessInstance(\"test\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    provider_settings_backing_provider_name=\"AWS\",\n    provider_settings_provider_name=\"SERVERLESS\",\n    provider_settings_region_name=\"US_EAST_1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.ServerlessInstance(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        ProviderSettingsBackingProviderName = \"AWS\",\n        ProviderSettingsProviderName = \"SERVERLESS\",\n        ProviderSettingsRegionName = \"US_EAST_1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewServerlessInstance(ctx, \"test\", \u0026mongodbatlas.ServerlessInstanceArgs{\n\t\t\tProjectId:                           pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tProviderSettingsBackingProviderName: pulumi.String(\"AWS\"),\n\t\t\tProviderSettingsProviderName:        pulumi.String(\"SERVERLESS\"),\n\t\t\tProviderSettingsRegionName:          pulumi.String(\"US_EAST_1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ServerlessInstance;\nimport com.pulumi.mongodbatlas.ServerlessInstanceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new ServerlessInstance(\"test\", ServerlessInstanceArgs.builder()        \n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .providerSettingsBackingProviderName(\"AWS\")\n            .providerSettingsProviderName(\"SERVERLESS\")\n            .providerSettingsRegionName(\"US_EAST_1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:ServerlessInstance\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      providerSettingsBackingProviderName: AWS\n      providerSettingsProviderName: SERVERLESS\n      providerSettingsRegionName: US_EAST_1\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nServerless Instance can be imported using the group ID and serverless instance name, in the format `GROUP_ID-SERVERLESS_INSTANCE_NAME`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/serverlessInstance:ServerlessInstance my_serverless_instance 1112222b3bf99403840e8934-My Serverless Instance\n```\n\n For more information see[MongoDB Atlas API - Serverless Instance](https://docs.atlas.mongodb.com/reference/api/serverless-instances/) Documentation. ",
            "properties": {
                "connectionStringsPrivateEndpointSrvs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Serverless Private Endpoint Connections\n"
                },
                "connectionStringsStandardSrv": {
                    "type": "string",
                    "description": "Public `mongodb+srv://` connection string that you can use to connect to this serverless instance.\n"
                },
                "continuousBackupEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the serverless instance uses [Serverless Continuous Backup](https://www.mongodb.com/docs/atlas/configure-serverless-backup). If this parameter is false or not used, the serverless instance uses [Basic Backup](https://www.mongodb.com/docs/atlas/configure-serverless-backup).\n"
                },
                "createDate": {
                    "type": "string",
                    "description": "Timestamp that indicates when MongoDB Cloud created the serverless instance. The timestamp displays in the ISO 8601 date and time format in UTC.\n"
                },
                "links": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ServerlessInstanceLink:ServerlessInstanceLink"
                    }
                },
                "mongoDbVersion": {
                    "type": "string",
                    "description": "Version of MongoDB that the serverless instance runs, in `\u003cmajor version\u003e`.`\u003cminor version\u003e` format.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable label that identifies the serverless instance.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The ID of the organization or project you want to create the serverless instance within.\n"
                },
                "providerSettingsBackingProviderName": {
                    "type": "string",
                    "description": "Cloud service provider on which MongoDB Cloud provisioned the serverless instance.\n"
                },
                "providerSettingsProviderName": {
                    "type": "string",
                    "description": "Cloud service provider that applies to the provisioned the serverless instance.\n"
                },
                "providerSettingsRegionName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the physical location of your MongoDB serverless instance. The region you choose can affect network latency for clients accessing your databases.\n"
                },
                "stateName": {
                    "type": "string",
                    "description": "Stage of deployment of this serverless instance when the resource made its request.\n"
                },
                "terminationProtectionEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n"
                }
            },
            "required": [
                "connectionStringsPrivateEndpointSrvs",
                "connectionStringsStandardSrv",
                "continuousBackupEnabled",
                "createDate",
                "links",
                "mongoDbVersion",
                "name",
                "projectId",
                "providerSettingsBackingProviderName",
                "providerSettingsProviderName",
                "providerSettingsRegionName",
                "stateName",
                "terminationProtectionEnabled"
            ],
            "inputProperties": {
                "continuousBackupEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the serverless instance uses [Serverless Continuous Backup](https://www.mongodb.com/docs/atlas/configure-serverless-backup). If this parameter is false or not used, the serverless instance uses [Basic Backup](https://www.mongodb.com/docs/atlas/configure-serverless-backup).\n"
                },
                "links": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ServerlessInstanceLink:ServerlessInstanceLink"
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable label that identifies the serverless instance.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The ID of the organization or project you want to create the serverless instance within.\n"
                },
                "providerSettingsBackingProviderName": {
                    "type": "string",
                    "description": "Cloud service provider on which MongoDB Cloud provisioned the serverless instance.\n"
                },
                "providerSettingsProviderName": {
                    "type": "string",
                    "description": "Cloud service provider that applies to the provisioned the serverless instance.\n"
                },
                "providerSettingsRegionName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the physical location of your MongoDB serverless instance. The region you choose can affect network latency for clients accessing your databases.\n"
                },
                "stateName": {
                    "type": "string",
                    "description": "Stage of deployment of this serverless instance when the resource made its request.\n"
                },
                "terminationProtectionEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n"
                }
            },
            "requiredInputs": [
                "projectId",
                "providerSettingsBackingProviderName",
                "providerSettingsProviderName",
                "providerSettingsRegionName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ServerlessInstance resources.\n",
                "properties": {
                    "connectionStringsPrivateEndpointSrvs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Serverless Private Endpoint Connections\n"
                    },
                    "connectionStringsStandardSrv": {
                        "type": "string",
                        "description": "Public `mongodb+srv://` connection string that you can use to connect to this serverless instance.\n"
                    },
                    "continuousBackupEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether the serverless instance uses [Serverless Continuous Backup](https://www.mongodb.com/docs/atlas/configure-serverless-backup). If this parameter is false or not used, the serverless instance uses [Basic Backup](https://www.mongodb.com/docs/atlas/configure-serverless-backup).\n"
                    },
                    "createDate": {
                        "type": "string",
                        "description": "Timestamp that indicates when MongoDB Cloud created the serverless instance. The timestamp displays in the ISO 8601 date and time format in UTC.\n"
                    },
                    "links": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/ServerlessInstanceLink:ServerlessInstanceLink"
                        }
                    },
                    "mongoDbVersion": {
                        "type": "string",
                        "description": "Version of MongoDB that the serverless instance runs, in `\u003cmajor version\u003e`.`\u003cminor version\u003e` format.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Human-readable label that identifies the serverless instance.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The ID of the organization or project you want to create the serverless instance within.\n"
                    },
                    "providerSettingsBackingProviderName": {
                        "type": "string",
                        "description": "Cloud service provider on which MongoDB Cloud provisioned the serverless instance.\n"
                    },
                    "providerSettingsProviderName": {
                        "type": "string",
                        "description": "Cloud service provider that applies to the provisioned the serverless instance.\n"
                    },
                    "providerSettingsRegionName": {
                        "type": "string",
                        "description": "Human-readable label that identifies the physical location of your MongoDB serverless instance. The region you choose can affect network latency for clients accessing your databases.\n"
                    },
                    "stateName": {
                        "type": "string",
                        "description": "Stage of deployment of this serverless instance when the resource made its request.\n"
                    },
                    "terminationProtectionEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/team:Team": {
            "properties": {
                "name": {
                    "type": "string"
                },
                "orgId": {
                    "type": "string"
                },
                "teamId": {
                    "type": "string"
                },
                "usernames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "name",
                "orgId",
                "teamId",
                "usernames"
            ],
            "inputProperties": {
                "name": {
                    "type": "string"
                },
                "orgId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "usernames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "requiredInputs": [
                "orgId",
                "usernames"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Team resources.\n",
                "properties": {
                    "name": {
                        "type": "string"
                    },
                    "orgId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "teamId": {
                        "type": "string"
                    },
                    "usernames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/teams:Teams": {
            "properties": {
                "name": {
                    "type": "string"
                },
                "orgId": {
                    "type": "string"
                },
                "teamId": {
                    "type": "string"
                },
                "usernames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "name",
                "orgId",
                "teamId",
                "usernames"
            ],
            "inputProperties": {
                "name": {
                    "type": "string"
                },
                "orgId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "usernames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "requiredInputs": [
                "orgId",
                "usernames"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Teams resources.\n",
                "properties": {
                    "name": {
                        "type": "string"
                    },
                    "orgId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "teamId": {
                        "type": "string"
                    },
                    "usernames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/thirdPartyIntegration:ThirdPartyIntegration": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testFlowdock = new mongodbatlas.ThirdPartyIntegration(\"testFlowdock\", {\n    apiToken: \"\u003cAPI-TOKEN\u003e\",\n    flowName: \"\u003cFLOW-NAME\u003e\",\n    orgName: \"\u003cORG-NAME\u003e\",\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    type: \"FLOWDOCK\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_flowdock = mongodbatlas.ThirdPartyIntegration(\"testFlowdock\",\n    api_token=\"\u003cAPI-TOKEN\u003e\",\n    flow_name=\"\u003cFLOW-NAME\u003e\",\n    org_name=\"\u003cORG-NAME\u003e\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    type=\"FLOWDOCK\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testFlowdock = new Mongodbatlas.ThirdPartyIntegration(\"testFlowdock\", new()\n    {\n        ApiToken = \"\u003cAPI-TOKEN\u003e\",\n        FlowName = \"\u003cFLOW-NAME\u003e\",\n        OrgName = \"\u003cORG-NAME\u003e\",\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        Type = \"FLOWDOCK\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewThirdPartyIntegration(ctx, \"testFlowdock\", \u0026mongodbatlas.ThirdPartyIntegrationArgs{\n\t\t\tApiToken:  pulumi.String(\"\u003cAPI-TOKEN\u003e\"),\n\t\t\tFlowName:  pulumi.String(\"\u003cFLOW-NAME\u003e\"),\n\t\t\tOrgName:   pulumi.String(\"\u003cORG-NAME\u003e\"),\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tType:      pulumi.String(\"FLOWDOCK\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ThirdPartyIntegration;\nimport com.pulumi.mongodbatlas.ThirdPartyIntegrationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testFlowdock = new ThirdPartyIntegration(\"testFlowdock\", ThirdPartyIntegrationArgs.builder()        \n            .apiToken(\"\u003cAPI-TOKEN\u003e\")\n            .flowName(\"\u003cFLOW-NAME\u003e\")\n            .orgName(\"\u003cORG-NAME\u003e\")\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .type(\"FLOWDOCK\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testFlowdock:\n    type: mongodbatlas:ThirdPartyIntegration\n    properties:\n      apiToken: \u003cAPI-TOKEN\u003e\n      flowName: \u003cFLOW-NAME\u003e\n      orgName: \u003cORG-NAME\u003e\n      projectId: \u003cPROJECT-ID\u003e\n      type: FLOWDOCK\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nThird-Party Integration Settings can be imported using project ID and the integration type, in the format `project_id`-`type`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/thirdPartyIntegration:ThirdPartyIntegration my_user 1112222b3bf99403840e8934-OPS_GENIE\n```\n\n See [MongoDB Atlas API](https://docs.atlas.mongodb.com/reference/api/third-party-integration-settings-create/) Documentation for more information. ",
            "properties": {
                "accountId": {
                    "type": "string",
                    "description": "Unique identifier of your New Relic account.\n"
                },
                "apiKey": {
                    "type": "string",
                    "description": "Your API Key.\n",
                    "secret": true
                },
                "apiToken": {
                    "type": "string",
                    "description": "Your API Token.\n",
                    "secret": true
                },
                "channelName": {
                    "type": "string"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether your cluster has Prometheus enabled.\n"
                },
                "flowName": {
                    "type": "string",
                    "description": "Your Flowdock Flow name.\n"
                },
                "licenseKey": {
                    "type": "string",
                    "description": "Your License Key.\n",
                    "secret": true
                },
                "microsoftTeamsWebhookUrl": {
                    "type": "string",
                    "description": "Your Microsoft Teams incoming webhook URL.\n",
                    "secret": true
                },
                "orgName": {
                    "type": "string",
                    "description": "Your Flowdock organization name.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Your Prometheus password.\n",
                    "secret": true
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to get all Third-Party service integrations\n"
                },
                "readToken": {
                    "type": "string",
                    "description": "Your Insights Query Key.\n",
                    "secret": true
                },
                "region": {
                    "type": "string",
                    "description": "Indicates which API URL to use, either US or EU. Opsgenie will use US by default.\n"
                },
                "routingKey": {
                    "type": "string",
                    "description": "An optional field for your Routing Key.\n",
                    "secret": true
                },
                "scheme": {
                    "type": "string",
                    "description": "Your Prometheus protocol scheme configured for requests.\n"
                },
                "secret": {
                    "type": "string",
                    "description": "An optional field for your webhook secret.\n",
                    "secret": true
                },
                "serviceDiscovery": {
                    "type": "string",
                    "description": "Indicates which service discovery method is used, either file or http.\n",
                    "secret": true
                },
                "serviceKey": {
                    "type": "string",
                    "description": "Your Service Key.\n",
                    "secret": true
                },
                "teamName": {
                    "type": "string"
                },
                "type": {
                    "type": "string",
                    "description": "Third-Party Integration Settings type \n* PAGER_DUTY\n* DATADOG\n* NEW_RELIC*\n* OPS_GENIE\n* VICTOR_OPS\n* FLOWDOCK*\n* WEBHOOK\n* MICROSOFT_TEAMS\n* PROMETHEUS\n",
                    "deprecationMessage": "This field type has values (NEW_RELIC, FLOWDOCK) that are deprecated and will be removed in 1.9.0 release "
                },
                "url": {
                    "type": "string",
                    "description": "Your webhook URL.\n"
                },
                "userName": {
                    "type": "string",
                    "description": "Your Prometheus username.\n",
                    "secret": true
                },
                "writeToken": {
                    "type": "string",
                    "description": "Your Insights Insert Key.\n",
                    "secret": true
                }
            },
            "required": [
                "projectId",
                "type"
            ],
            "inputProperties": {
                "accountId": {
                    "type": "string",
                    "description": "Unique identifier of your New Relic account.\n"
                },
                "apiKey": {
                    "type": "string",
                    "description": "Your API Key.\n",
                    "secret": true
                },
                "apiToken": {
                    "type": "string",
                    "description": "Your API Token.\n",
                    "secret": true
                },
                "channelName": {
                    "type": "string"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether your cluster has Prometheus enabled.\n"
                },
                "flowName": {
                    "type": "string",
                    "description": "Your Flowdock Flow name.\n"
                },
                "licenseKey": {
                    "type": "string",
                    "description": "Your License Key.\n",
                    "secret": true
                },
                "microsoftTeamsWebhookUrl": {
                    "type": "string",
                    "description": "Your Microsoft Teams incoming webhook URL.\n",
                    "secret": true
                },
                "orgName": {
                    "type": "string",
                    "description": "Your Flowdock organization name.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Your Prometheus password.\n",
                    "secret": true
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to get all Third-Party service integrations\n",
                    "willReplaceOnChanges": true
                },
                "readToken": {
                    "type": "string",
                    "description": "Your Insights Query Key.\n",
                    "secret": true
                },
                "region": {
                    "type": "string",
                    "description": "Indicates which API URL to use, either US or EU. Opsgenie will use US by default.\n"
                },
                "routingKey": {
                    "type": "string",
                    "description": "An optional field for your Routing Key.\n",
                    "secret": true
                },
                "scheme": {
                    "type": "string",
                    "description": "Your Prometheus protocol scheme configured for requests.\n"
                },
                "secret": {
                    "type": "string",
                    "description": "An optional field for your webhook secret.\n",
                    "secret": true
                },
                "serviceDiscovery": {
                    "type": "string",
                    "description": "Indicates which service discovery method is used, either file or http.\n",
                    "secret": true
                },
                "serviceKey": {
                    "type": "string",
                    "description": "Your Service Key.\n",
                    "secret": true
                },
                "teamName": {
                    "type": "string"
                },
                "type": {
                    "type": "string",
                    "description": "Third-Party Integration Settings type \n* PAGER_DUTY\n* DATADOG\n* NEW_RELIC*\n* OPS_GENIE\n* VICTOR_OPS\n* FLOWDOCK*\n* WEBHOOK\n* MICROSOFT_TEAMS\n* PROMETHEUS\n",
                    "deprecationMessage": "This field type has values (NEW_RELIC, FLOWDOCK) that are deprecated and will be removed in 1.9.0 release ",
                    "willReplaceOnChanges": true
                },
                "url": {
                    "type": "string",
                    "description": "Your webhook URL.\n"
                },
                "userName": {
                    "type": "string",
                    "description": "Your Prometheus username.\n",
                    "secret": true
                },
                "writeToken": {
                    "type": "string",
                    "description": "Your Insights Insert Key.\n",
                    "secret": true
                }
            },
            "requiredInputs": [
                "projectId",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ThirdPartyIntegration resources.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "Unique identifier of your New Relic account.\n"
                    },
                    "apiKey": {
                        "type": "string",
                        "description": "Your API Key.\n",
                        "secret": true
                    },
                    "apiToken": {
                        "type": "string",
                        "description": "Your API Token.\n",
                        "secret": true
                    },
                    "channelName": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Whether your cluster has Prometheus enabled.\n"
                    },
                    "flowName": {
                        "type": "string",
                        "description": "Your Flowdock Flow name.\n"
                    },
                    "licenseKey": {
                        "type": "string",
                        "description": "Your License Key.\n",
                        "secret": true
                    },
                    "microsoftTeamsWebhookUrl": {
                        "type": "string",
                        "description": "Your Microsoft Teams incoming webhook URL.\n",
                        "secret": true
                    },
                    "orgName": {
                        "type": "string",
                        "description": "Your Flowdock organization name.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "Your Prometheus password.\n",
                        "secret": true
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to get all Third-Party service integrations\n",
                        "willReplaceOnChanges": true
                    },
                    "readToken": {
                        "type": "string",
                        "description": "Your Insights Query Key.\n",
                        "secret": true
                    },
                    "region": {
                        "type": "string",
                        "description": "Indicates which API URL to use, either US or EU. Opsgenie will use US by default.\n"
                    },
                    "routingKey": {
                        "type": "string",
                        "description": "An optional field for your Routing Key.\n",
                        "secret": true
                    },
                    "scheme": {
                        "type": "string",
                        "description": "Your Prometheus protocol scheme configured for requests.\n"
                    },
                    "secret": {
                        "type": "string",
                        "description": "An optional field for your webhook secret.\n",
                        "secret": true
                    },
                    "serviceDiscovery": {
                        "type": "string",
                        "description": "Indicates which service discovery method is used, either file or http.\n",
                        "secret": true
                    },
                    "serviceKey": {
                        "type": "string",
                        "description": "Your Service Key.\n",
                        "secret": true
                    },
                    "teamName": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string",
                        "description": "Third-Party Integration Settings type \n* PAGER_DUTY\n* DATADOG\n* NEW_RELIC*\n* OPS_GENIE\n* VICTOR_OPS\n* FLOWDOCK*\n* WEBHOOK\n* MICROSOFT_TEAMS\n* PROMETHEUS\n",
                        "deprecationMessage": "This field type has values (NEW_RELIC, FLOWDOCK) that are deprecated and will be removed in 1.9.0 release ",
                        "willReplaceOnChanges": true
                    },
                    "url": {
                        "type": "string",
                        "description": "Your webhook URL.\n"
                    },
                    "userName": {
                        "type": "string",
                        "description": "Your Prometheus username.\n",
                        "secret": true
                    },
                    "writeToken": {
                        "type": "string",
                        "description": "Your Insights Insert Key.\n",
                        "secret": true
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/x509AuthenticationDatabaseUser:X509AuthenticationDatabaseUser": {
            "description": "`mongodbatlas.X509AuthenticationDatabaseUser` provides a X509 Authentication Database User resource. The mongodbatlas.X509AuthenticationDatabaseUser resource lets you manage MongoDB users who authenticate using X.509 certificates. You can manage these X.509 certificates or let Atlas do it for you.\n\n| Management  | Description  |\n|---|---|\n| Atlas  | Atlas manages your Certificate Authority and can generate certificates for your MongoDB users. No additional X.509 configuration is required.  |\n| Customer  |  You must provide a Certificate Authority and generate certificates for your MongoDB users. |\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n{{% examples %}}\n## Example Usage\n\n### S\n{{% example %}}\n### Example Usage: Generate an Atlas-managed X.509 certificate for a MongoDB user\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst user = new mongodbatlas.DatabaseUser(\"user\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    username: \"myUsername\",\n    x509Type: \"MANAGED\",\n    databaseName: \"$external\",\n    roles: [{\n        roleName: \"atlasAdmin\",\n        databaseName: \"admin\",\n    }],\n    labels: [{\n        key: \"My Key\",\n        value: \"My Value\",\n    }],\n});\nconst test = new mongodbatlas.X509AuthenticationDatabaseUser(\"test\", {\n    projectId: user.projectId,\n    username: user.username,\n    monthsUntilExpiration: 2,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nuser = mongodbatlas.DatabaseUser(\"user\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    username=\"myUsername\",\n    x509_type=\"MANAGED\",\n    database_name=\"$external\",\n    roles=[mongodbatlas.DatabaseUserRoleArgs(\n        role_name=\"atlasAdmin\",\n        database_name=\"admin\",\n    )],\n    labels=[mongodbatlas.DatabaseUserLabelArgs(\n        key=\"My Key\",\n        value=\"My Value\",\n    )])\ntest = mongodbatlas.X509AuthenticationDatabaseUser(\"test\",\n    project_id=user.project_id,\n    username=user.username,\n    months_until_expiration=2)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var user = new Mongodbatlas.DatabaseUser(\"user\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        Username = \"myUsername\",\n        X509Type = \"MANAGED\",\n        DatabaseName = \"$external\",\n        Roles = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserRoleArgs\n            {\n                RoleName = \"atlasAdmin\",\n                DatabaseName = \"admin\",\n            },\n        },\n        Labels = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserLabelArgs\n            {\n                Key = \"My Key\",\n                Value = \"My Value\",\n            },\n        },\n    });\n\n    var test = new Mongodbatlas.X509AuthenticationDatabaseUser(\"test\", new()\n    {\n        ProjectId = user.ProjectId,\n        Username = user.Username,\n        MonthsUntilExpiration = 2,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tuser, err := mongodbatlas.NewDatabaseUser(ctx, \"user\", \u0026mongodbatlas.DatabaseUserArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tUsername:     pulumi.String(\"myUsername\"),\n\t\t\tX509Type:     pulumi.String(\"MANAGED\"),\n\t\t\tDatabaseName: pulumi.String(\"$external\"),\n\t\t\tRoles: mongodbatlas.DatabaseUserRoleArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserRoleArgs{\n\t\t\t\t\tRoleName:     pulumi.String(\"atlasAdmin\"),\n\t\t\t\t\tDatabaseName: pulumi.String(\"admin\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tLabels: mongodbatlas.DatabaseUserLabelArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserLabelArgs{\n\t\t\t\t\tKey:   pulumi.String(\"My Key\"),\n\t\t\t\t\tValue: pulumi.String(\"My Value\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewX509AuthenticationDatabaseUser(ctx, \"test\", \u0026mongodbatlas.X509AuthenticationDatabaseUserArgs{\n\t\t\tProjectId:             user.ProjectId,\n\t\t\tUsername:              user.Username,\n\t\t\tMonthsUntilExpiration: pulumi.Int(2),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.DatabaseUser;\nimport com.pulumi.mongodbatlas.DatabaseUserArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserRoleArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserLabelArgs;\nimport com.pulumi.mongodbatlas.X509AuthenticationDatabaseUser;\nimport com.pulumi.mongodbatlas.X509AuthenticationDatabaseUserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var user = new DatabaseUser(\"user\", DatabaseUserArgs.builder()        \n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .username(\"myUsername\")\n            .x509Type(\"MANAGED\")\n            .databaseName(\"$external\")\n            .roles(DatabaseUserRoleArgs.builder()\n                .roleName(\"atlasAdmin\")\n                .databaseName(\"admin\")\n                .build())\n            .labels(DatabaseUserLabelArgs.builder()\n                .key(\"My Key\")\n                .value(\"My Value\")\n                .build())\n            .build());\n\n        var test = new X509AuthenticationDatabaseUser(\"test\", X509AuthenticationDatabaseUserArgs.builder()        \n            .projectId(user.projectId())\n            .username(user.username())\n            .monthsUntilExpiration(2)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  user:\n    type: mongodbatlas:DatabaseUser\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      username: myUsername\n      x509Type: MANAGED\n      databaseName: $external\n      roles:\n        - roleName: atlasAdmin\n          databaseName: admin\n      labels:\n        - key: My Key\n          value: My Value\n  test:\n    type: mongodbatlas:X509AuthenticationDatabaseUser\n    properties:\n      projectId: ${user.projectId}\n      username: ${user.username}\n      monthsUntilExpiration: 2\n```\n{{% /example %}}\n{{% example %}}\n### Example Usage: Save a customer-managed X.509 configuration for an Atlas project\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.X509AuthenticationDatabaseUser(\"test\", {\n    customerX509Cas: `  -----BEGIN CERTIFICATE-----\n  MIICmTCCAgICCQDZnHzklxsT9TANBgkqhkiG9w0BAQsFADCBkDELMAkGA1UEBhMC\n  VVMxDjAMBgNVBAgMBVRleGFzMQ8wDQYDVQQHDAZBdXN0aW4xETAPBgNVBAoMCHRl\n  c3QuY29tMQ0wCwYDVQQLDARUZXN0MREwDwYDVQQDDAh0ZXN0LmNvbTErMCkGCSqG\n  SIb3DQEJARYcbWVsaXNzYS5wbHVua2V0dEBtb25nb2RiLmNvbTAeFw0yMDAyMDQy\n  MDQ2MDFaFw0yMTAyMDMyMDQ2MDFaMIGQMQswCQYDVQQGEwJVUzEOMAwGA1UECAwF\n  VGV4YXMxDzANBgNVBAcMBkF1c3RpbjERMA8GA1UECgwIdGVzdC5jb20xDTALBgNV\n  BAsMBFRlc3QxETAPBgNVBAMMCHRlc3QuY29tMSswKQYJKoZIhvcNAQkBFhxtZWxp\n  c3NhLnBsdW5rZXR0QG1vbmdvZGIuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB\n  iQKBgQCf1LRqr1zftzdYx2Aj9G76tb0noMPtj6faGLlPji1+m6Rn7RWD9L0ntWAr\n  cURxvypa9jZ9MXFzDtLevvd3tHEmfrUT3ukNDX6+Jtc4kWm+Dh2A70Pd+deKZ2/O\n  Fh8audEKAESGXnTbeJCeQa1XKlIkjqQHBNwES5h1b9vJtFoLJwIDAQABMA0GCSqG\n  SIb3DQEBCwUAA4GBADMUncjEPV/MiZUcVNGmktP6BPmEqMXQWUDpdGW2+Tg2JtUA\n  7MMILtepBkFzLO+GlpZxeAlXO0wxiNgEmCRONgh4+t2w3e7a8GFijYQ99FHrAC5A\n  iul59bdl18gVqXia1Yeq/iK7Ohfy/Jwd7Hsm530elwkM/ZEkYDjBlZSXYdyz\n  -----END CERTIFICATE-----\"\n\n`,\n    projectId: \"\u003cPROJECT-ID\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.X509AuthenticationDatabaseUser(\"test\",\n    customer_x509_cas=\"\"\"  -----BEGIN CERTIFICATE-----\n  MIICmTCCAgICCQDZnHzklxsT9TANBgkqhkiG9w0BAQsFADCBkDELMAkGA1UEBhMC\n  VVMxDjAMBgNVBAgMBVRleGFzMQ8wDQYDVQQHDAZBdXN0aW4xETAPBgNVBAoMCHRl\n  c3QuY29tMQ0wCwYDVQQLDARUZXN0MREwDwYDVQQDDAh0ZXN0LmNvbTErMCkGCSqG\n  SIb3DQEJARYcbWVsaXNzYS5wbHVua2V0dEBtb25nb2RiLmNvbTAeFw0yMDAyMDQy\n  MDQ2MDFaFw0yMTAyMDMyMDQ2MDFaMIGQMQswCQYDVQQGEwJVUzEOMAwGA1UECAwF\n  VGV4YXMxDzANBgNVBAcMBkF1c3RpbjERMA8GA1UECgwIdGVzdC5jb20xDTALBgNV\n  BAsMBFRlc3QxETAPBgNVBAMMCHRlc3QuY29tMSswKQYJKoZIhvcNAQkBFhxtZWxp\n  c3NhLnBsdW5rZXR0QG1vbmdvZGIuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB\n  iQKBgQCf1LRqr1zftzdYx2Aj9G76tb0noMPtj6faGLlPji1+m6Rn7RWD9L0ntWAr\n  cURxvypa9jZ9MXFzDtLevvd3tHEmfrUT3ukNDX6+Jtc4kWm+Dh2A70Pd+deKZ2/O\n  Fh8audEKAESGXnTbeJCeQa1XKlIkjqQHBNwES5h1b9vJtFoLJwIDAQABMA0GCSqG\n  SIb3DQEBCwUAA4GBADMUncjEPV/MiZUcVNGmktP6BPmEqMXQWUDpdGW2+Tg2JtUA\n  7MMILtepBkFzLO+GlpZxeAlXO0wxiNgEmCRONgh4+t2w3e7a8GFijYQ99FHrAC5A\n  iul59bdl18gVqXia1Yeq/iK7Ohfy/Jwd7Hsm530elwkM/ZEkYDjBlZSXYdyz\n  -----END CERTIFICATE-----\"\n\n\"\"\",\n    project_id=\"\u003cPROJECT-ID\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.X509AuthenticationDatabaseUser(\"test\", new()\n    {\n        CustomerX509Cas = @\"  -----BEGIN CERTIFICATE-----\n  MIICmTCCAgICCQDZnHzklxsT9TANBgkqhkiG9w0BAQsFADCBkDELMAkGA1UEBhMC\n  VVMxDjAMBgNVBAgMBVRleGFzMQ8wDQYDVQQHDAZBdXN0aW4xETAPBgNVBAoMCHRl\n  c3QuY29tMQ0wCwYDVQQLDARUZXN0MREwDwYDVQQDDAh0ZXN0LmNvbTErMCkGCSqG\n  SIb3DQEJARYcbWVsaXNzYS5wbHVua2V0dEBtb25nb2RiLmNvbTAeFw0yMDAyMDQy\n  MDQ2MDFaFw0yMTAyMDMyMDQ2MDFaMIGQMQswCQYDVQQGEwJVUzEOMAwGA1UECAwF\n  VGV4YXMxDzANBgNVBAcMBkF1c3RpbjERMA8GA1UECgwIdGVzdC5jb20xDTALBgNV\n  BAsMBFRlc3QxETAPBgNVBAMMCHRlc3QuY29tMSswKQYJKoZIhvcNAQkBFhxtZWxp\n  c3NhLnBsdW5rZXR0QG1vbmdvZGIuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB\n  iQKBgQCf1LRqr1zftzdYx2Aj9G76tb0noMPtj6faGLlPji1+m6Rn7RWD9L0ntWAr\n  cURxvypa9jZ9MXFzDtLevvd3tHEmfrUT3ukNDX6+Jtc4kWm+Dh2A70Pd+deKZ2/O\n  Fh8audEKAESGXnTbeJCeQa1XKlIkjqQHBNwES5h1b9vJtFoLJwIDAQABMA0GCSqG\n  SIb3DQEBCwUAA4GBADMUncjEPV/MiZUcVNGmktP6BPmEqMXQWUDpdGW2+Tg2JtUA\n  7MMILtepBkFzLO+GlpZxeAlXO0wxiNgEmCRONgh4+t2w3e7a8GFijYQ99FHrAC5A\n  iul59bdl18gVqXia1Yeq/iK7Ohfy/Jwd7Hsm530elwkM/ZEkYDjBlZSXYdyz\n  -----END CERTIFICATE-----\"\"\n\n\",\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewX509AuthenticationDatabaseUser(ctx, \"test\", \u0026mongodbatlas.X509AuthenticationDatabaseUserArgs{\n\t\t\tCustomerX509Cas: pulumi.String(\"  -----BEGIN CERTIFICATE-----\\n  MIICmTCCAgICCQDZnHzklxsT9TANBgkqhkiG9w0BAQsFADCBkDELMAkGA1UEBhMC\\n  VVMxDjAMBgNVBAgMBVRleGFzMQ8wDQYDVQQHDAZBdXN0aW4xETAPBgNVBAoMCHRl\\n  c3QuY29tMQ0wCwYDVQQLDARUZXN0MREwDwYDVQQDDAh0ZXN0LmNvbTErMCkGCSqG\\n  SIb3DQEJARYcbWVsaXNzYS5wbHVua2V0dEBtb25nb2RiLmNvbTAeFw0yMDAyMDQy\\n  MDQ2MDFaFw0yMTAyMDMyMDQ2MDFaMIGQMQswCQYDVQQGEwJVUzEOMAwGA1UECAwF\\n  VGV4YXMxDzANBgNVBAcMBkF1c3RpbjERMA8GA1UECgwIdGVzdC5jb20xDTALBgNV\\n  BAsMBFRlc3QxETAPBgNVBAMMCHRlc3QuY29tMSswKQYJKoZIhvcNAQkBFhxtZWxp\\n  c3NhLnBsdW5rZXR0QG1vbmdvZGIuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB\\n  iQKBgQCf1LRqr1zftzdYx2Aj9G76tb0noMPtj6faGLlPji1+m6Rn7RWD9L0ntWAr\\n  cURxvypa9jZ9MXFzDtLevvd3tHEmfrUT3ukNDX6+Jtc4kWm+Dh2A70Pd+deKZ2/O\\n  Fh8audEKAESGXnTbeJCeQa1XKlIkjqQHBNwES5h1b9vJtFoLJwIDAQABMA0GCSqG\\n  SIb3DQEBCwUAA4GBADMUncjEPV/MiZUcVNGmktP6BPmEqMXQWUDpdGW2+Tg2JtUA\\n  7MMILtepBkFzLO+GlpZxeAlXO0wxiNgEmCRONgh4+t2w3e7a8GFijYQ99FHrAC5A\\n  iul59bdl18gVqXia1Yeq/iK7Ohfy/Jwd7Hsm530elwkM/ZEkYDjBlZSXYdyz\\n  -----END CERTIFICATE-----\\\"\\n\\n\"),\n\t\t\tProjectId:       pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.X509AuthenticationDatabaseUser;\nimport com.pulumi.mongodbatlas.X509AuthenticationDatabaseUserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new X509AuthenticationDatabaseUser(\"test\", X509AuthenticationDatabaseUserArgs.builder()        \n            .customerX509Cas(\"\"\"\n  -----BEGIN CERTIFICATE-----\n  MIICmTCCAgICCQDZnHzklxsT9TANBgkqhkiG9w0BAQsFADCBkDELMAkGA1UEBhMC\n  VVMxDjAMBgNVBAgMBVRleGFzMQ8wDQYDVQQHDAZBdXN0aW4xETAPBgNVBAoMCHRl\n  c3QuY29tMQ0wCwYDVQQLDARUZXN0MREwDwYDVQQDDAh0ZXN0LmNvbTErMCkGCSqG\n  SIb3DQEJARYcbWVsaXNzYS5wbHVua2V0dEBtb25nb2RiLmNvbTAeFw0yMDAyMDQy\n  MDQ2MDFaFw0yMTAyMDMyMDQ2MDFaMIGQMQswCQYDVQQGEwJVUzEOMAwGA1UECAwF\n  VGV4YXMxDzANBgNVBAcMBkF1c3RpbjERMA8GA1UECgwIdGVzdC5jb20xDTALBgNV\n  BAsMBFRlc3QxETAPBgNVBAMMCHRlc3QuY29tMSswKQYJKoZIhvcNAQkBFhxtZWxp\n  c3NhLnBsdW5rZXR0QG1vbmdvZGIuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB\n  iQKBgQCf1LRqr1zftzdYx2Aj9G76tb0noMPtj6faGLlPji1+m6Rn7RWD9L0ntWAr\n  cURxvypa9jZ9MXFzDtLevvd3tHEmfrUT3ukNDX6+Jtc4kWm+Dh2A70Pd+deKZ2/O\n  Fh8audEKAESGXnTbeJCeQa1XKlIkjqQHBNwES5h1b9vJtFoLJwIDAQABMA0GCSqG\n  SIb3DQEBCwUAA4GBADMUncjEPV/MiZUcVNGmktP6BPmEqMXQWUDpdGW2+Tg2JtUA\n  7MMILtepBkFzLO+GlpZxeAlXO0wxiNgEmCRONgh4+t2w3e7a8GFijYQ99FHrAC5A\n  iul59bdl18gVqXia1Yeq/iK7Ohfy/Jwd7Hsm530elwkM/ZEkYDjBlZSXYdyz\n  -----END CERTIFICATE-----\"\n\n            \"\"\")\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:X509AuthenticationDatabaseUser\n    properties:\n      customerX509Cas: |2+\n          -----BEGIN CERTIFICATE-----\n          MIICmTCCAgICCQDZnHzklxsT9TANBgkqhkiG9w0BAQsFADCBkDELMAkGA1UEBhMC\n          VVMxDjAMBgNVBAgMBVRleGFzMQ8wDQYDVQQHDAZBdXN0aW4xETAPBgNVBAoMCHRl\n          c3QuY29tMQ0wCwYDVQQLDARUZXN0MREwDwYDVQQDDAh0ZXN0LmNvbTErMCkGCSqG\n          SIb3DQEJARYcbWVsaXNzYS5wbHVua2V0dEBtb25nb2RiLmNvbTAeFw0yMDAyMDQy\n          MDQ2MDFaFw0yMTAyMDMyMDQ2MDFaMIGQMQswCQYDVQQGEwJVUzEOMAwGA1UECAwF\n          VGV4YXMxDzANBgNVBAcMBkF1c3RpbjERMA8GA1UECgwIdGVzdC5jb20xDTALBgNV\n          BAsMBFRlc3QxETAPBgNVBAMMCHRlc3QuY29tMSswKQYJKoZIhvcNAQkBFhxtZWxp\n          c3NhLnBsdW5rZXR0QG1vbmdvZGIuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB\n          iQKBgQCf1LRqr1zftzdYx2Aj9G76tb0noMPtj6faGLlPji1+m6Rn7RWD9L0ntWAr\n          cURxvypa9jZ9MXFzDtLevvd3tHEmfrUT3ukNDX6+Jtc4kWm+Dh2A70Pd+deKZ2/O\n          Fh8audEKAESGXnTbeJCeQa1XKlIkjqQHBNwES5h1b9vJtFoLJwIDAQABMA0GCSqG\n          SIb3DQEBCwUAA4GBADMUncjEPV/MiZUcVNGmktP6BPmEqMXQWUDpdGW2+Tg2JtUA\n          7MMILtepBkFzLO+GlpZxeAlXO0wxiNgEmCRONgh4+t2w3e7a8GFijYQ99FHrAC5A\n          iul59bdl18gVqXia1Yeq/iK7Ohfy/Jwd7Hsm530elwkM/ZEkYDjBlZSXYdyz\n          -----END CERTIFICATE-----\"\n\n      projectId: \u003cPROJECT-ID\u003e\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nX.509 Certificates for a User can be imported using project ID and username, in the format `project_id-username`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/x509AuthenticationDatabaseUser:X509AuthenticationDatabaseUser test 1112222b3bf99403840e8934-myUsername\n```\n\n For more information see[MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/x509-configuration-get-certificates/) Current X.509 Configuration can be imported using project ID, in the format `project_id`, e.g.\n\n```sh\n $ pulumi import mongodbatlas:index/x509AuthenticationDatabaseUser:X509AuthenticationDatabaseUser test 1112222b3bf99403840e8934\n```\n\n For more information see[MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/x509-configuration-get-certificates/) ",
            "properties": {
                "certificates": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/X509AuthenticationDatabaseUserCertificate:X509AuthenticationDatabaseUserCertificate"
                    },
                    "description": "Array of objects where each details one unexpired database user certificate.\n"
                },
                "currentCertificate": {
                    "type": "string",
                    "description": "Contains the last X.509 certificate and private key created for a database user.\n",
                    "secret": true
                },
                "customerX509Cas": {
                    "type": "string",
                    "description": "PEM string containing one or more customer CAs for database user authentication.\n",
                    "secret": true
                },
                "monthsUntilExpiration": {
                    "type": "integer",
                    "description": "A number of months that the created certificate is valid for before expiry, up to 24 months. By default is 3.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Identifier for the Atlas project associated with the X.509 configuration.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username of the database user to create a certificate for.\n"
                }
            },
            "required": [
                "certificates",
                "currentCertificate",
                "projectId"
            ],
            "inputProperties": {
                "customerX509Cas": {
                    "type": "string",
                    "description": "PEM string containing one or more customer CAs for database user authentication.\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                },
                "monthsUntilExpiration": {
                    "type": "integer",
                    "description": "A number of months that the created certificate is valid for before expiry, up to 24 months. By default is 3.\n",
                    "willReplaceOnChanges": true
                },
                "projectId": {
                    "type": "string",
                    "description": "Identifier for the Atlas project associated with the X.509 configuration.\n",
                    "willReplaceOnChanges": true
                },
                "username": {
                    "type": "string",
                    "description": "Username of the database user to create a certificate for.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering X509AuthenticationDatabaseUser resources.\n",
                "properties": {
                    "certificates": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/X509AuthenticationDatabaseUserCertificate:X509AuthenticationDatabaseUserCertificate"
                        },
                        "description": "Array of objects where each details one unexpired database user certificate.\n"
                    },
                    "currentCertificate": {
                        "type": "string",
                        "description": "Contains the last X.509 certificate and private key created for a database user.\n",
                        "secret": true
                    },
                    "customerX509Cas": {
                        "type": "string",
                        "description": "PEM string containing one or more customer CAs for database user authentication.\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "monthsUntilExpiration": {
                        "type": "integer",
                        "description": "A number of months that the created certificate is valid for before expiry, up to 24 months. By default is 3.\n",
                        "willReplaceOnChanges": true
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Identifier for the Atlas project associated with the X.509 configuration.\n",
                        "willReplaceOnChanges": true
                    },
                    "username": {
                        "type": "string",
                        "description": "Username of the database user to create a certificate for.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "mongodbatlas:index/get509AuthenticationDatabaseUser:get509AuthenticationDatabaseUser": {
            "description": "`mongodbatlas.X509AuthenticationDatabaseUser` describe a X509 Authentication Database User. This represents a X509 Authentication Database User.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n{{% examples %}}\n## Example Usage\n\n### S\n{{% example %}}\n### Example Usage: Generate an Atlas-managed X.509 certificate for a MongoDB user\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst user = new mongodbatlas.DatabaseUser(\"user\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    username: \"myUsername\",\n    x509Type: \"MANAGED\",\n    databaseName: \"$external\",\n    roles: [{\n        roleName: \"atlasAdmin\",\n        databaseName: \"admin\",\n    }],\n    labels: [{\n        key: \"My Key\",\n        value: \"My Value\",\n    }],\n});\nconst testX509AuthenticationDatabaseUser = new mongodbatlas.X509AuthenticationDatabaseUser(\"testX509AuthenticationDatabaseUser\", {\n    projectId: user.projectId,\n    username: user.username,\n    monthsUntilExpiration: 2,\n});\nconst test509AuthenticationDatabaseUser = pulumi.all([testX509AuthenticationDatabaseUser.projectId, testX509AuthenticationDatabaseUser.username]).apply(([projectId, username]) =\u003e mongodbatlas.get509AuthenticationDatabaseUserOutput({\n    projectId: projectId,\n    username: username,\n}));\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nuser = mongodbatlas.DatabaseUser(\"user\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    username=\"myUsername\",\n    x509_type=\"MANAGED\",\n    database_name=\"$external\",\n    roles=[mongodbatlas.DatabaseUserRoleArgs(\n        role_name=\"atlasAdmin\",\n        database_name=\"admin\",\n    )],\n    labels=[mongodbatlas.DatabaseUserLabelArgs(\n        key=\"My Key\",\n        value=\"My Value\",\n    )])\ntest_x509_authentication_database_user = mongodbatlas.X509AuthenticationDatabaseUser(\"testX509AuthenticationDatabaseUser\",\n    project_id=user.project_id,\n    username=user.username,\n    months_until_expiration=2)\ntest509_authentication_database_user = pulumi.Output.all(test_x509_authentication_database_user.project_id, test_x509_authentication_database_user.username).apply(lambda project_id, username: mongodbatlas.get509_authentication_database_user_output(project_id=project_id,\n    username=username))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var user = new Mongodbatlas.DatabaseUser(\"user\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        Username = \"myUsername\",\n        X509Type = \"MANAGED\",\n        DatabaseName = \"$external\",\n        Roles = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserRoleArgs\n            {\n                RoleName = \"atlasAdmin\",\n                DatabaseName = \"admin\",\n            },\n        },\n        Labels = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserLabelArgs\n            {\n                Key = \"My Key\",\n                Value = \"My Value\",\n            },\n        },\n    });\n\n    var testX509AuthenticationDatabaseUser = new Mongodbatlas.X509AuthenticationDatabaseUser(\"testX509AuthenticationDatabaseUser\", new()\n    {\n        ProjectId = user.ProjectId,\n        Username = user.Username,\n        MonthsUntilExpiration = 2,\n    });\n\n    var test509AuthenticationDatabaseUser = Mongodbatlas.Get509AuthenticationDatabaseUser.Invoke(new()\n    {\n        ProjectId = testX509AuthenticationDatabaseUser.ProjectId,\n        Username = testX509AuthenticationDatabaseUser.Username,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tuser, err := mongodbatlas.NewDatabaseUser(ctx, \"user\", \u0026mongodbatlas.DatabaseUserArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tUsername:     pulumi.String(\"myUsername\"),\n\t\t\tX509Type:     pulumi.String(\"MANAGED\"),\n\t\t\tDatabaseName: pulumi.String(\"$external\"),\n\t\t\tRoles: mongodbatlas.DatabaseUserRoleArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserRoleArgs{\n\t\t\t\t\tRoleName:     pulumi.String(\"atlasAdmin\"),\n\t\t\t\t\tDatabaseName: pulumi.String(\"admin\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tLabels: mongodbatlas.DatabaseUserLabelArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserLabelArgs{\n\t\t\t\t\tKey:   pulumi.String(\"My Key\"),\n\t\t\t\t\tValue: pulumi.String(\"My Value\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestX509AuthenticationDatabaseUser, err := mongodbatlas.NewX509AuthenticationDatabaseUser(ctx, \"testX509AuthenticationDatabaseUser\", \u0026mongodbatlas.X509AuthenticationDatabaseUserArgs{\n\t\t\tProjectId:             user.ProjectId,\n\t\t\tUsername:              user.Username,\n\t\t\tMonthsUntilExpiration: pulumi.Int(2),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = pulumi.All(testX509AuthenticationDatabaseUser.ProjectId, testX509AuthenticationDatabaseUser.Username).ApplyT(func(_args []interface{}) (mongodbatlas.Get509AuthenticationDatabaseUserResult, error) {\n\t\t\tprojectId := _args[0].(string)\n\t\t\tusername := _args[1].(*string)\n\t\t\treturn mongodbatlas.Get509AuthenticationDatabaseUserOutput(ctx, mongodbatlas.Get509AuthenticationDatabaseUserOutputArgs{\n\t\t\t\tProjectId: projectId,\n\t\t\t\tUsername:  username,\n\t\t\t}, nil), nil\n\t\t}).(mongodbatlas.Get509AuthenticationDatabaseUserResultOutput)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.DatabaseUser;\nimport com.pulumi.mongodbatlas.DatabaseUserArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserRoleArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserLabelArgs;\nimport com.pulumi.mongodbatlas.X509AuthenticationDatabaseUser;\nimport com.pulumi.mongodbatlas.X509AuthenticationDatabaseUserArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.Get509AuthenticationDatabaseUserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var user = new DatabaseUser(\"user\", DatabaseUserArgs.builder()        \n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .username(\"myUsername\")\n            .x509Type(\"MANAGED\")\n            .databaseName(\"$external\")\n            .roles(DatabaseUserRoleArgs.builder()\n                .roleName(\"atlasAdmin\")\n                .databaseName(\"admin\")\n                .build())\n            .labels(DatabaseUserLabelArgs.builder()\n                .key(\"My Key\")\n                .value(\"My Value\")\n                .build())\n            .build());\n\n        var testX509AuthenticationDatabaseUser = new X509AuthenticationDatabaseUser(\"testX509AuthenticationDatabaseUser\", X509AuthenticationDatabaseUserArgs.builder()        \n            .projectId(user.projectId())\n            .username(user.username())\n            .monthsUntilExpiration(2)\n            .build());\n\n        final var test509AuthenticationDatabaseUser = MongodbatlasFunctions.get509AuthenticationDatabaseUser(Get509AuthenticationDatabaseUserArgs.builder()\n            .projectId(testX509AuthenticationDatabaseUser.projectId())\n            .username(testX509AuthenticationDatabaseUser.username())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  user:\n    type: mongodbatlas:DatabaseUser\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      username: myUsername\n      x509Type: MANAGED\n      databaseName: $external\n      roles:\n        - roleName: atlasAdmin\n          databaseName: admin\n      labels:\n        - key: My Key\n          value: My Value\n  testX509AuthenticationDatabaseUser:\n    type: mongodbatlas:X509AuthenticationDatabaseUser\n    properties:\n      projectId: ${user.projectId}\n      username: ${user.username}\n      monthsUntilExpiration: 2\nvariables:\n  test509AuthenticationDatabaseUser:\n    fn::invoke:\n      Function: mongodbatlas:get509AuthenticationDatabaseUser\n      Arguments:\n        projectId: ${testX509AuthenticationDatabaseUser.projectId}\n        username: ${testX509AuthenticationDatabaseUser.username}\n```\n{{% /example %}}\n{{% example %}}\n### Example Usage: Save a customer-managed X.509 configuration for an Atlas project\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testX509AuthenticationDatabaseUser = new mongodbatlas.X509AuthenticationDatabaseUser(\"testX509AuthenticationDatabaseUser\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    customerX509Cas: `-----BEGIN CERTIFICATE-----\nMIICmTCCAgICCQDZnHzklxsT9TANBgkqhkiG9w0BAQsFADCBkDELMAkGA1UEBhMC\nVVMxDjAMBgNVBAgMBVRleGFzMQ8wDQYDVQQHDAZBdXN0aW4xETAPBgNVBAoMCHRl\nc3QuY29tMQ0wCwYDVQQLDARUZXN0MREwDwYDVQQDDAh0ZXN0LmNvbTErMCkGCSqG\nSIb3DQEJARYcbWVsaXNzYS5wbHVua2V0dEBtb25nb2RiLmNvbTAeFw0yMDAyMDQy\nMDQ2MDFaFw0yMTAyMDMyMDQ2MDFaMIGQMQswCQYDVQQGEwJVUzEOMAwGA1UECAwF\nVGV4YXMxDzANBgNVBAcMBkF1c3RpbjERMA8GA1UECgwIdGVzdC5jb20xDTALBgNV\nBAsMBFRlc3QxETAPBgNVBAMMCHRlc3QuY29tMSswKQYJKoZIhvcNAQkBFhxtZWxp\nc3NhLnBsdW5rZXR0QG1vbmdvZGIuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB\niQKBgQCf1LRqr1zftzdYx2Aj9G76tb0noMPtj6faGLlPji1+m6Rn7RWD9L0ntWAr\ncURxvypa9jZ9MXFzDtLevvd3tHEmfrUT3ukNDX6+Jtc4kWm+Dh2A70Pd+deKZ2/O\nFh8audEKAESGXnTbeJCeQa1XKlIkjqQHBNwES5h1b9vJtFoLJwIDAQABMA0GCSqG\nSIb3DQEBCwUAA4GBADMUncjEPV/MiZUcVNGmktP6BPmEqMXQWUDpdGW2+Tg2JtUA\n7MMILtepBkFzLO+GlpZxeAlXO0wxiNgEmCRONgh4+t2w3e7a8GFijYQ99FHrAC5A\niul59bdl18gVqXia1Yeq/iK7Ohfy/Jwd7Hsm530elwkM/ZEkYDjBlZSXYdyz\n-----END CERTIFICATE-----\"\n`,\n});\nconst test509AuthenticationDatabaseUser = mongodbatlas.get509AuthenticationDatabaseUserOutput({\n    projectId: testX509AuthenticationDatabaseUser.projectId,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_x509_authentication_database_user = mongodbatlas.X509AuthenticationDatabaseUser(\"testX509AuthenticationDatabaseUser\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    customer_x509_cas=\"\"\"-----BEGIN CERTIFICATE-----\nMIICmTCCAgICCQDZnHzklxsT9TANBgkqhkiG9w0BAQsFADCBkDELMAkGA1UEBhMC\nVVMxDjAMBgNVBAgMBVRleGFzMQ8wDQYDVQQHDAZBdXN0aW4xETAPBgNVBAoMCHRl\nc3QuY29tMQ0wCwYDVQQLDARUZXN0MREwDwYDVQQDDAh0ZXN0LmNvbTErMCkGCSqG\nSIb3DQEJARYcbWVsaXNzYS5wbHVua2V0dEBtb25nb2RiLmNvbTAeFw0yMDAyMDQy\nMDQ2MDFaFw0yMTAyMDMyMDQ2MDFaMIGQMQswCQYDVQQGEwJVUzEOMAwGA1UECAwF\nVGV4YXMxDzANBgNVBAcMBkF1c3RpbjERMA8GA1UECgwIdGVzdC5jb20xDTALBgNV\nBAsMBFRlc3QxETAPBgNVBAMMCHRlc3QuY29tMSswKQYJKoZIhvcNAQkBFhxtZWxp\nc3NhLnBsdW5rZXR0QG1vbmdvZGIuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB\niQKBgQCf1LRqr1zftzdYx2Aj9G76tb0noMPtj6faGLlPji1+m6Rn7RWD9L0ntWAr\ncURxvypa9jZ9MXFzDtLevvd3tHEmfrUT3ukNDX6+Jtc4kWm+Dh2A70Pd+deKZ2/O\nFh8audEKAESGXnTbeJCeQa1XKlIkjqQHBNwES5h1b9vJtFoLJwIDAQABMA0GCSqG\nSIb3DQEBCwUAA4GBADMUncjEPV/MiZUcVNGmktP6BPmEqMXQWUDpdGW2+Tg2JtUA\n7MMILtepBkFzLO+GlpZxeAlXO0wxiNgEmCRONgh4+t2w3e7a8GFijYQ99FHrAC5A\niul59bdl18gVqXia1Yeq/iK7Ohfy/Jwd7Hsm530elwkM/ZEkYDjBlZSXYdyz\n-----END CERTIFICATE-----\"\n\"\"\")\ntest509_authentication_database_user = mongodbatlas.get509_authentication_database_user_output(project_id=test_x509_authentication_database_user.project_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testX509AuthenticationDatabaseUser = new Mongodbatlas.X509AuthenticationDatabaseUser(\"testX509AuthenticationDatabaseUser\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        CustomerX509Cas = @\"-----BEGIN CERTIFICATE-----\nMIICmTCCAgICCQDZnHzklxsT9TANBgkqhkiG9w0BAQsFADCBkDELMAkGA1UEBhMC\nVVMxDjAMBgNVBAgMBVRleGFzMQ8wDQYDVQQHDAZBdXN0aW4xETAPBgNVBAoMCHRl\nc3QuY29tMQ0wCwYDVQQLDARUZXN0MREwDwYDVQQDDAh0ZXN0LmNvbTErMCkGCSqG\nSIb3DQEJARYcbWVsaXNzYS5wbHVua2V0dEBtb25nb2RiLmNvbTAeFw0yMDAyMDQy\nMDQ2MDFaFw0yMTAyMDMyMDQ2MDFaMIGQMQswCQYDVQQGEwJVUzEOMAwGA1UECAwF\nVGV4YXMxDzANBgNVBAcMBkF1c3RpbjERMA8GA1UECgwIdGVzdC5jb20xDTALBgNV\nBAsMBFRlc3QxETAPBgNVBAMMCHRlc3QuY29tMSswKQYJKoZIhvcNAQkBFhxtZWxp\nc3NhLnBsdW5rZXR0QG1vbmdvZGIuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB\niQKBgQCf1LRqr1zftzdYx2Aj9G76tb0noMPtj6faGLlPji1+m6Rn7RWD9L0ntWAr\ncURxvypa9jZ9MXFzDtLevvd3tHEmfrUT3ukNDX6+Jtc4kWm+Dh2A70Pd+deKZ2/O\nFh8audEKAESGXnTbeJCeQa1XKlIkjqQHBNwES5h1b9vJtFoLJwIDAQABMA0GCSqG\nSIb3DQEBCwUAA4GBADMUncjEPV/MiZUcVNGmktP6BPmEqMXQWUDpdGW2+Tg2JtUA\n7MMILtepBkFzLO+GlpZxeAlXO0wxiNgEmCRONgh4+t2w3e7a8GFijYQ99FHrAC5A\niul59bdl18gVqXia1Yeq/iK7Ohfy/Jwd7Hsm530elwkM/ZEkYDjBlZSXYdyz\n-----END CERTIFICATE-----\"\"\n\",\n    });\n\n    var test509AuthenticationDatabaseUser = Mongodbatlas.Get509AuthenticationDatabaseUser.Invoke(new()\n    {\n        ProjectId = testX509AuthenticationDatabaseUser.ProjectId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestX509AuthenticationDatabaseUser, err := mongodbatlas.NewX509AuthenticationDatabaseUser(ctx, \"testX509AuthenticationDatabaseUser\", \u0026mongodbatlas.X509AuthenticationDatabaseUserArgs{\n\t\t\tProjectId:       pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tCustomerX509Cas: pulumi.String(\"-----BEGIN CERTIFICATE-----\\nMIICmTCCAgICCQDZnHzklxsT9TANBgkqhkiG9w0BAQsFADCBkDELMAkGA1UEBhMC\\nVVMxDjAMBgNVBAgMBVRleGFzMQ8wDQYDVQQHDAZBdXN0aW4xETAPBgNVBAoMCHRl\\nc3QuY29tMQ0wCwYDVQQLDARUZXN0MREwDwYDVQQDDAh0ZXN0LmNvbTErMCkGCSqG\\nSIb3DQEJARYcbWVsaXNzYS5wbHVua2V0dEBtb25nb2RiLmNvbTAeFw0yMDAyMDQy\\nMDQ2MDFaFw0yMTAyMDMyMDQ2MDFaMIGQMQswCQYDVQQGEwJVUzEOMAwGA1UECAwF\\nVGV4YXMxDzANBgNVBAcMBkF1c3RpbjERMA8GA1UECgwIdGVzdC5jb20xDTALBgNV\\nBAsMBFRlc3QxETAPBgNVBAMMCHRlc3QuY29tMSswKQYJKoZIhvcNAQkBFhxtZWxp\\nc3NhLnBsdW5rZXR0QG1vbmdvZGIuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB\\niQKBgQCf1LRqr1zftzdYx2Aj9G76tb0noMPtj6faGLlPji1+m6Rn7RWD9L0ntWAr\\ncURxvypa9jZ9MXFzDtLevvd3tHEmfrUT3ukNDX6+Jtc4kWm+Dh2A70Pd+deKZ2/O\\nFh8audEKAESGXnTbeJCeQa1XKlIkjqQHBNwES5h1b9vJtFoLJwIDAQABMA0GCSqG\\nSIb3DQEBCwUAA4GBADMUncjEPV/MiZUcVNGmktP6BPmEqMXQWUDpdGW2+Tg2JtUA\\n7MMILtepBkFzLO+GlpZxeAlXO0wxiNgEmCRONgh4+t2w3e7a8GFijYQ99FHrAC5A\\niul59bdl18gVqXia1Yeq/iK7Ohfy/Jwd7Hsm530elwkM/ZEkYDjBlZSXYdyz\\n-----END CERTIFICATE-----\\\"\\n\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.Get509AuthenticationDatabaseUserOutput(ctx, mongodbatlas.Get509AuthenticationDatabaseUserOutputArgs{\n\t\t\tProjectId: testX509AuthenticationDatabaseUser.ProjectId,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.X509AuthenticationDatabaseUser;\nimport com.pulumi.mongodbatlas.X509AuthenticationDatabaseUserArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.Get509AuthenticationDatabaseUserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testX509AuthenticationDatabaseUser = new X509AuthenticationDatabaseUser(\"testX509AuthenticationDatabaseUser\", X509AuthenticationDatabaseUserArgs.builder()        \n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .customerX509Cas(\"\"\"\n-----BEGIN CERTIFICATE-----\nMIICmTCCAgICCQDZnHzklxsT9TANBgkqhkiG9w0BAQsFADCBkDELMAkGA1UEBhMC\nVVMxDjAMBgNVBAgMBVRleGFzMQ8wDQYDVQQHDAZBdXN0aW4xETAPBgNVBAoMCHRl\nc3QuY29tMQ0wCwYDVQQLDARUZXN0MREwDwYDVQQDDAh0ZXN0LmNvbTErMCkGCSqG\nSIb3DQEJARYcbWVsaXNzYS5wbHVua2V0dEBtb25nb2RiLmNvbTAeFw0yMDAyMDQy\nMDQ2MDFaFw0yMTAyMDMyMDQ2MDFaMIGQMQswCQYDVQQGEwJVUzEOMAwGA1UECAwF\nVGV4YXMxDzANBgNVBAcMBkF1c3RpbjERMA8GA1UECgwIdGVzdC5jb20xDTALBgNV\nBAsMBFRlc3QxETAPBgNVBAMMCHRlc3QuY29tMSswKQYJKoZIhvcNAQkBFhxtZWxp\nc3NhLnBsdW5rZXR0QG1vbmdvZGIuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB\niQKBgQCf1LRqr1zftzdYx2Aj9G76tb0noMPtj6faGLlPji1+m6Rn7RWD9L0ntWAr\ncURxvypa9jZ9MXFzDtLevvd3tHEmfrUT3ukNDX6+Jtc4kWm+Dh2A70Pd+deKZ2/O\nFh8audEKAESGXnTbeJCeQa1XKlIkjqQHBNwES5h1b9vJtFoLJwIDAQABMA0GCSqG\nSIb3DQEBCwUAA4GBADMUncjEPV/MiZUcVNGmktP6BPmEqMXQWUDpdGW2+Tg2JtUA\n7MMILtepBkFzLO+GlpZxeAlXO0wxiNgEmCRONgh4+t2w3e7a8GFijYQ99FHrAC5A\niul59bdl18gVqXia1Yeq/iK7Ohfy/Jwd7Hsm530elwkM/ZEkYDjBlZSXYdyz\n-----END CERTIFICATE-----\"\n            \"\"\")\n            .build());\n\n        final var test509AuthenticationDatabaseUser = MongodbatlasFunctions.get509AuthenticationDatabaseUser(Get509AuthenticationDatabaseUserArgs.builder()\n            .projectId(testX509AuthenticationDatabaseUser.projectId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testX509AuthenticationDatabaseUser:\n    type: mongodbatlas:X509AuthenticationDatabaseUser\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      customerX509Cas: |\n        -----BEGIN CERTIFICATE-----\n        MIICmTCCAgICCQDZnHzklxsT9TANBgkqhkiG9w0BAQsFADCBkDELMAkGA1UEBhMC\n        VVMxDjAMBgNVBAgMBVRleGFzMQ8wDQYDVQQHDAZBdXN0aW4xETAPBgNVBAoMCHRl\n        c3QuY29tMQ0wCwYDVQQLDARUZXN0MREwDwYDVQQDDAh0ZXN0LmNvbTErMCkGCSqG\n        SIb3DQEJARYcbWVsaXNzYS5wbHVua2V0dEBtb25nb2RiLmNvbTAeFw0yMDAyMDQy\n        MDQ2MDFaFw0yMTAyMDMyMDQ2MDFaMIGQMQswCQYDVQQGEwJVUzEOMAwGA1UECAwF\n        VGV4YXMxDzANBgNVBAcMBkF1c3RpbjERMA8GA1UECgwIdGVzdC5jb20xDTALBgNV\n        BAsMBFRlc3QxETAPBgNVBAMMCHRlc3QuY29tMSswKQYJKoZIhvcNAQkBFhxtZWxp\n        c3NhLnBsdW5rZXR0QG1vbmdvZGIuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB\n        iQKBgQCf1LRqr1zftzdYx2Aj9G76tb0noMPtj6faGLlPji1+m6Rn7RWD9L0ntWAr\n        cURxvypa9jZ9MXFzDtLevvd3tHEmfrUT3ukNDX6+Jtc4kWm+Dh2A70Pd+deKZ2/O\n        Fh8audEKAESGXnTbeJCeQa1XKlIkjqQHBNwES5h1b9vJtFoLJwIDAQABMA0GCSqG\n        SIb3DQEBCwUAA4GBADMUncjEPV/MiZUcVNGmktP6BPmEqMXQWUDpdGW2+Tg2JtUA\n        7MMILtepBkFzLO+GlpZxeAlXO0wxiNgEmCRONgh4+t2w3e7a8GFijYQ99FHrAC5A\n        iul59bdl18gVqXia1Yeq/iK7Ohfy/Jwd7Hsm530elwkM/ZEkYDjBlZSXYdyz\n        -----END CERTIFICATE-----\"\nvariables:\n  test509AuthenticationDatabaseUser:\n    fn::invoke:\n      Function: mongodbatlas:get509AuthenticationDatabaseUser\n      Arguments:\n        projectId: ${testX509AuthenticationDatabaseUser.projectId}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking get509AuthenticationDatabaseUser.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "Identifier for the Atlas project associated with the X.509 configuration.\n",
                        "willReplaceOnChanges": true
                    },
                    "username": {
                        "type": "string",
                        "description": "Username of the database user to create a certificate for.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by get509AuthenticationDatabaseUser.\n",
                "properties": {
                    "certificates": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/get509AuthenticationDatabaseUserCertificate:get509AuthenticationDatabaseUserCertificate"
                        },
                        "description": "Array of objects where each details one unexpired database user certificate.\n"
                    },
                    "customerX509Cas": {
                        "type": "string",
                        "secret": true
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "username": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "certificates",
                    "customerX509Cas",
                    "projectId",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getAccessListApiKey:getAccessListApiKey": {
            "description": "{{% examples %}}\n## Example Usage\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getAccessListApiKey.\n",
                "properties": {
                    "apiKeyId": {
                        "type": "string",
                        "description": "Unique identifier for the Organization API Key for which you want to retrieve an access list entry.\n*\n\u003e **NOTE:** One of the following attributes must set: `cidr_block`  or `ip_address`.\n"
                    },
                    "ipAddress": {
                        "type": "string",
                        "description": "Single IP address to be added to the access list.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Unique identifier for the Organization to which you want to retrieve one or more access list entries.\n"
                    }
                },
                "type": "object",
                "required": [
                    "apiKeyId",
                    "ipAddress",
                    "orgId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAccessListApiKey.\n",
                "properties": {
                    "accessCount": {
                        "type": "integer"
                    },
                    "apiKeyId": {
                        "type": "string"
                    },
                    "cidrBlock": {
                        "type": "string"
                    },
                    "created": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "ipAddress": {
                        "type": "string"
                    },
                    "lastUsed": {
                        "type": "string"
                    },
                    "lastUsedAddress": {
                        "type": "string"
                    },
                    "orgId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "accessCount",
                    "apiKeyId",
                    "cidrBlock",
                    "created",
                    "ipAddress",
                    "lastUsed",
                    "lastUsedAddress",
                    "orgId",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getAccessListApiKeys:getAccessListApiKeys": {
            "description": "{{% examples %}}\n## Example Usage\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getAccessListApiKeys.\n",
                "properties": {
                    "apiKeyId": {
                        "type": "string",
                        "description": "Unique identifier for the Organization API Key for which you want to retrieve an access list entry.\n*\n\u003e **NOTE:** One of the following attributes must set: `cidr_block`  or `ip_address`.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer",
                        "description": "Number of items to return per page, up to a maximum of 500. Defaults to `100`.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Unique identifier for the Organization to which you want to retrieve one or more access list entries.\n"
                    },
                    "pageNum": {
                        "type": "integer",
                        "description": "The page to return. Defaults to `1`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "apiKeyId",
                    "orgId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAccessListApiKeys.\n",
                "properties": {
                    "apiKeyId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "results": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAccessListApiKeysResult:getAccessListApiKeysResult"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "apiKeyId",
                    "orgId",
                    "results",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getAdvancedCluster:getAdvancedCluster": {
            "description": "`mongodbatlas.AdvancedCluster` describes an Advanced Cluster. The data source requires your Project ID.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n\u003e **IMPORTANT:**\n\u003cbr\u003e \u0026#8226; Changes to cluster configurations can affect costs. Before making changes, please see [Billing](https://docs.atlas.mongodb.com/billing/).\n\u003cbr\u003e \u0026#8226; If your Atlas project contains a custom role that uses actions introduced in a specific MongoDB version, you cannot create a cluster with a MongoDB version less than that version unless you delete the custom role.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAdvancedCluster.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Name of the cluster as it appears in Atlas. Once the cluster is created, its name cannot be changed.\n"
                    },
                    "pitEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates if the cluster uses Continuous Cloud Backup.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the database user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAdvancedCluster.\n",
                "properties": {
                    "advancedConfigurations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAdvancedClusterAdvancedConfiguration:getAdvancedClusterAdvancedConfiguration"
                        },
                        "description": "Get the advanced configuration options. See Advanced Configuration below for more details.\n"
                    },
                    "backupEnabled": {
                        "type": "boolean"
                    },
                    "biConnectorConfigs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAdvancedClusterBiConnectorConfig:getAdvancedClusterBiConnectorConfig"
                        },
                        "description": "Configuration settings applied to BI Connector for Atlas on this cluster. See below. **NOTE** Prior version of provider had parameter as `bi_connector`\n"
                    },
                    "clusterType": {
                        "type": "string",
                        "description": "Type of the cluster that you want to create.\n"
                    },
                    "connectionStrings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAdvancedClusterConnectionString:getAdvancedClusterConnectionString"
                        },
                        "description": "Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.\n"
                    },
                    "createDate": {
                        "type": "string"
                    },
                    "diskSizeGb": {
                        "type": "number",
                        "description": "Capacity, in gigabytes, of the host's root volume.\n"
                    },
                    "encryptionAtRestProvider": {
                        "type": "string",
                        "description": "Possible values are AWS, GCP, AZURE or NONE.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "labels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAdvancedClusterLabel:getAdvancedClusterLabel"
                        },
                        "description": "Configuration for the collection of key-value pairs that tag and categorize the cluster. See below.\n"
                    },
                    "mongoDbMajorVersion": {
                        "type": "string",
                        "description": "Version of the cluster to deploy.\n"
                    },
                    "mongoDbVersion": {
                        "type": "string",
                        "description": "Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "Flag that indicates whether the cluster is paused or not.\n"
                    },
                    "pitEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates if the cluster uses Continuous Cloud Backup.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "replicationSpecs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAdvancedClusterReplicationSpec:getAdvancedClusterReplicationSpec"
                        },
                        "description": "Configuration for cluster regions and the hardware provisioned in them. See below\n"
                    },
                    "rootCertType": {
                        "type": "string",
                        "description": "Certificate Authority that MongoDB Atlas clusters use.\n"
                    },
                    "stateName": {
                        "type": "string",
                        "description": "Current state of the cluster. The possible states are:\n"
                    },
                    "terminationProtectionEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n"
                    },
                    "versionReleaseSystem": {
                        "type": "string",
                        "description": "Release cadence that Atlas uses for this cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "advancedConfigurations",
                    "backupEnabled",
                    "biConnectorConfigs",
                    "clusterType",
                    "connectionStrings",
                    "createDate",
                    "diskSizeGb",
                    "encryptionAtRestProvider",
                    "labels",
                    "mongoDbMajorVersion",
                    "mongoDbVersion",
                    "name",
                    "paused",
                    "pitEnabled",
                    "projectId",
                    "replicationSpecs",
                    "rootCertType",
                    "stateName",
                    "terminationProtectionEnabled",
                    "versionReleaseSystem",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getAdvancedClusters:getAdvancedClusters": {
            "description": "`mongodbatlas.Cluster` describes all Advanced Clusters by the provided project_id. The data source requires your Project ID.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n\u003e **IMPORTANT:**\n\u003cbr\u003e \u0026#8226; Changes to cluster configurations can affect costs. Before making changes, please see [Billing](https://docs.atlas.mongodb.com/billing/).\n\u003cbr\u003e \u0026#8226; If your Atlas project contains a custom role that uses actions introduced in a specific MongoDB version, you cannot create a cluster with a MongoDB version less than that version unless you delete the custom role.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Cluster;\nimport com.pulumi.mongodbatlas.ClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.ClusterReplicationSpecArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetClustersArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleCluster = new Cluster(\"exampleCluster\", ClusterArgs.builder()        \n            .projectId(\"\u003cYOUR-PROJECT-ID\u003e\")\n            .clusterType(\"REPLICASET\")\n            .replicationSpecs(ClusterReplicationSpecArgs.builder()\n                .regionConfigs(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n                .build())\n            .build());\n\n        final var exampleClusters = MongodbatlasFunctions.getClusters(GetClustersArgs.builder()\n            .projectId(exampleCluster.projectId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleCluster:\n    type: mongodbatlas:Cluster\n    properties:\n      projectId: \u003cYOUR-PROJECT-ID\u003e\n      clusterType: REPLICASET\n      replicationSpecs:\n        - regionConfigs:\n            - electableSpecs:\n                - instanceSize: M5\n              providerName: TENANT\n              backingProviderName: AWS\n              regionName: US_EAST_1\n              priority: 7\nvariables:\n  exampleClusters:\n    fn::invoke:\n      Function: mongodbatlas:getClusters\n      Arguments:\n        projectId: ${exampleCluster.projectId}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getAdvancedClusters.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to get the clusters.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAdvancedClusters.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResult:getAdvancedClustersResult"
                        },
                        "description": "A list where each represents a Cluster. See below for more details.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId",
                    "results",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getAlertConfiguration:getAlertConfiguration": {
            "inputs": {
                "description": "A collection of arguments for invoking getAlertConfiguration.\n",
                "properties": {
                    "alertConfigurationId": {
                        "type": "string",
                        "description": "Unique identifier for the alert configuration.\n",
                        "willReplaceOnChanges": true
                    },
                    "outputs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAlertConfigurationOutput:getAlertConfigurationOutput"
                        },
                        "description": "List of formatted output requested for this alert configuration\n* `output.#.type` - (Required) If the output is requested, you must specify its type. The format is computed as `output.#.value`, the following are the supported types:\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The ID of the project where the alert configuration will create.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "alertConfigurationId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAlertConfiguration.\n",
                "properties": {
                    "alertConfigurationId": {
                        "type": "string"
                    },
                    "created": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when this alert configuration was created.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "If set to true, the alert configuration is enabled. If enabled is not exported it is set to false.\n"
                    },
                    "eventType": {
                        "type": "string",
                        "description": "The type of event that will trigger an alert.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "matchers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAlertConfigurationMatcher:getAlertConfigurationMatcher"
                        }
                    },
                    "metricThreshold": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    },
                    "metricThresholdConfigs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAlertConfigurationMetricThresholdConfig:getAlertConfigurationMetricThresholdConfig"
                        }
                    },
                    "notifications": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAlertConfigurationNotification:getAlertConfigurationNotification"
                        }
                    },
                    "outputs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAlertConfigurationOutput:getAlertConfigurationOutput"
                        }
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "threshold": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Threshold value outside of which an alert will be triggered.\n"
                    },
                    "thresholdConfigs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAlertConfigurationThresholdConfig:getAlertConfigurationThresholdConfig"
                        }
                    },
                    "updated": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when this alert configuration was last updated.\n"
                    }
                },
                "type": "object",
                "required": [
                    "alertConfigurationId",
                    "created",
                    "enabled",
                    "eventType",
                    "matchers",
                    "metricThreshold",
                    "metricThresholdConfigs",
                    "notifications",
                    "projectId",
                    "threshold",
                    "thresholdConfigs",
                    "updated",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getAlertConfigurations:getAlertConfigurations": {
            "inputs": {
                "description": "A collection of arguments for invoking getAlertConfigurations.\n",
                "properties": {
                    "listOptions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAlertConfigurationsListOption:getAlertConfigurationsListOption"
                        },
                        "description": "Arguments that dictate how many and which results are returned by the data source\n* `list_options.page_num` - Which page of results to retrieve (default to first page)\n* `list_options.items_per_page` - How many alerts to retrieve per page (default 100)\n* `list_options.include_count` - Whether to include total count of results in the response (default false)\n"
                    },
                    "outputTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of requested string formatted output to be included on each individual result. Options are `resource_hcl` and `resource_import`. Available to make it easy to gather resource statements for existing alert configurations, and corresponding import statements to import said resource state into the statefile.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to get the alert configurations.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAlertConfigurations.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "listOptions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAlertConfigurationsListOption:getAlertConfigurationsListOption"
                        }
                    },
                    "outputTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The ID of the project where the alert configuration exists\n"
                    },
                    "results": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAlertConfigurationsResult:getAlertConfigurationsResult"
                        },
                        "description": "A list of alert configurations for the project_id, constrained by the `list_options`.\n"
                    },
                    "totalCount": {
                        "type": "integer",
                        "description": "Total count of results\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId",
                    "results",
                    "totalCount",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getApiKey:getApiKey": {
            "description": "{{% examples %}}\n## Example Usage\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getApiKey.\n",
                "properties": {
                    "apiKeyId": {
                        "type": "string"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "The unique ID for the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "apiKeyId",
                    "orgId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getApiKey.\n",
                "properties": {
                    "apiKeyId": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of this Organization API key.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Unique identifier for the organization whose API keys you want to retrieve. Use the /orgs endpoint to retrieve all organizations to which the authenticated user has access.\n"
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "Public key for this Organization API key.\n"
                    },
                    "roleNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Name of the role. This resource returns all the roles the user has in Atlas.\nThe following are valid roles:\n"
                    }
                },
                "type": "object",
                "required": [
                    "apiKeyId",
                    "description",
                    "orgId",
                    "publicKey",
                    "roleNames",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getApiKeys:getApiKeys": {
            "inputs": {
                "description": "A collection of arguments for invoking getApiKeys.\n",
                "properties": {
                    "itemsPerPage": {
                        "type": "integer",
                        "description": "Number of items to return per page, up to a maximum of 500. Defaults to `100`.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Unique identifier for the organization whose API keys you want to retrieve. Use the /orgs endpoint to retrieve all organizations to which the authenticated user has access.\n"
                    },
                    "pageNum": {
                        "type": "integer",
                        "description": "The page to return. Defaults to `1`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "orgId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getApiKeys.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "results": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getApiKeysResult:getApiKeysResult"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "orgId",
                    "results",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getAuditing:getAuditing": {
            "description": "`mongodbatlas.Auditing` describes a Auditing.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find **group_id** in the official documentation.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAuditing.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the database user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAuditing.\n",
                "properties": {
                    "auditAuthorizationSuccess": {
                        "type": "boolean",
                        "description": "JSON-formatted audit filter used by the project\n"
                    },
                    "auditFilter": {
                        "type": "string",
                        "description": "Indicates whether the auditing system captures successful authentication attempts for audit filters using the \"atype\" : \"authCheck\" auditing event. For more information, see auditAuthorizationSuccess\n"
                    },
                    "configurationType": {
                        "type": "string",
                        "description": "Denotes the configuration method for the audit filter. Possible values are: NONE - auditing not configured for the project.m FILTER_BUILDER - auditing configured via Atlas UI filter builderm FILTER_JSON - auditing configured via Atlas custom filter or API.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Denotes whether or not the project associated with the {GROUP-ID} has database auditing enabled.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "projectId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "auditAuthorizationSuccess",
                    "auditFilter",
                    "configurationType",
                    "enabled",
                    "projectId",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getCloudBackupSchedule:getCloudBackupSchedule": {
            "description": "`mongodbatlas.CloudBackupSchedule` provides a Cloud Backup Schedule datasource. An Atlas Cloud Backup Schedule provides the current cloud backup schedule for the cluster. \n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudBackupSchedule.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the Atlas cluster that contains the snapshots backup policy you want to retrieve.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudBackupSchedule.\n",
                "properties": {
                    "autoExportEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether automatic export of cloud backup snapshots to the AWS bucket is enabled. Value can be one of the following:\n"
                    },
                    "clusterId": {
                        "type": "string",
                        "description": "Unique identifier of the Atlas cluster.\n"
                    },
                    "clusterName": {
                        "type": "string"
                    },
                    "copySettings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudBackupScheduleCopySetting:getCloudBackupScheduleCopySetting"
                        }
                    },
                    "exports": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudBackupScheduleExport:getCloudBackupScheduleExport"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "idPolicy": {
                        "type": "string",
                        "description": "Unique identifier of the backup policy.\n"
                    },
                    "nextSnapshot": {
                        "type": "string",
                        "description": "UTC ISO 8601 formatted point in time when Atlas will take the next snapshot.\n"
                    },
                    "policyItemDailies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudBackupSchedulePolicyItemDaily:getCloudBackupSchedulePolicyItemDaily"
                        },
                        "description": "Daily policy item\n"
                    },
                    "policyItemHourlies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudBackupSchedulePolicyItemHourly:getCloudBackupSchedulePolicyItemHourly"
                        },
                        "description": "Hourly policy item\n"
                    },
                    "policyItemMonthlies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudBackupSchedulePolicyItemMonthly:getCloudBackupSchedulePolicyItemMonthly"
                        },
                        "description": "Monthly policy item\n"
                    },
                    "policyItemWeeklies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudBackupSchedulePolicyItemWeekly:getCloudBackupSchedulePolicyItemWeekly"
                        },
                        "description": "Weekly policy item\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "referenceHourOfDay": {
                        "type": "integer",
                        "description": "UTC Hour of day between 0 and 23 representing which hour of the day that Atlas takes a snapshot.\n"
                    },
                    "referenceMinuteOfHour": {
                        "type": "integer",
                        "description": "UTC Minute of day between 0 and 59 representing which minute of the `reference_hour_of_day` that Atlas takes the snapshot.\n"
                    },
                    "restoreWindowDays": {
                        "type": "integer",
                        "description": "Specifies a restore window in days for cloud backup to maintain.\n"
                    },
                    "useOrgAndGroupNamesInExportPrefix": {
                        "type": "boolean",
                        "description": "Specify true to use organization and project names instead of organization and project UUIDs in the path for the metadata files that Atlas uploads to your S3 bucket after it finishes exporting the snapshots. To learn more about the metadata files that Atlas uploads, see [Export Cloud Backup Snapshot](https://www.mongodb.com/docs/atlas/backup/cloud-backup/export/#std-label-cloud-provider-snapshot-export).\n"
                    }
                },
                "type": "object",
                "required": [
                    "autoExportEnabled",
                    "clusterId",
                    "clusterName",
                    "copySettings",
                    "exports",
                    "idPolicy",
                    "nextSnapshot",
                    "policyItemDailies",
                    "policyItemHourlies",
                    "policyItemMonthlies",
                    "policyItemWeeklies",
                    "projectId",
                    "referenceHourOfDay",
                    "referenceMinuteOfHour",
                    "restoreWindowDays",
                    "useOrgAndGroupNamesInExportPrefix",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshot:getCloudBackupSnapshot": {
            "description": "`mongodbatlas.CloudBackupSnapshot` provides an Cloud Backup Snapshot datasource. Atlas Cloud Backup Snapshots provide localized backup storage using the native snapshot functionality of the cluster’s cloud service.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudBackupSnapshot.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the Atlas cluster that contains the snapshot you want to retrieve.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "snapshotId": {
                        "type": "string",
                        "description": "The unique identifier of the snapshot you want to retrieve.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId",
                    "snapshotId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudBackupSnapshot.\n",
                "properties": {
                    "cloudProvider": {
                        "type": "string",
                        "description": "Cloud provider that stores this snapshot.\n"
                    },
                    "clusterName": {
                        "type": "string"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "UTC ISO 8601 formatted point in time when Atlas took the snapshot.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "UDescription of the snapshot. Only present for on-demand snapshots.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "UTC ISO 8601 formatted point in time when Atlas will delete the snapshot.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "masterKeyUuid": {
                        "type": "string",
                        "description": "Unique ID of the AWS KMS Customer Master Key used to encrypt the snapshot. Only visible for clusters using Encryption at Rest via Customer KMS.\n"
                    },
                    "members": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudBackupSnapshotMember:getCloudBackupSnapshotMember"
                        },
                        "description": "Block of List of snapshots and the cloud provider where the snapshots are stored. See below\n"
                    },
                    "mongodVersion": {
                        "type": "string",
                        "description": "Version of the MongoDB server.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "replicaSetName": {
                        "type": "string",
                        "description": "Label given to a shard or config server from which Atlas took this snapshot.\n"
                    },
                    "snapshotId": {
                        "type": "string"
                    },
                    "snapshotIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Unique identifiers of the snapshots created for the shards and config server for a sharded cluster.\n"
                    },
                    "snapshotType": {
                        "type": "string",
                        "description": "Specified the type of snapshot. Valid values are onDemand and scheduled.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Current status of the snapshot. One of the following values: queued, inProgress, completed, failed.\n"
                    },
                    "storageSizeBytes": {
                        "type": "integer",
                        "description": "Specifies the size of the snapshot in bytes.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Specifies the type of cluster: replicaSet or shardedCluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "cloudProvider",
                    "clusterName",
                    "createdAt",
                    "description",
                    "expiresAt",
                    "masterKeyUuid",
                    "members",
                    "mongodVersion",
                    "projectId",
                    "replicaSetName",
                    "snapshotId",
                    "snapshotIds",
                    "snapshotType",
                    "status",
                    "storageSizeBytes",
                    "type",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotExportBucket:getCloudBackupSnapshotExportBucket": {
            "description": "`mongodbatlas.CloudBackupSnapshotExportBucket` datasource allows you to retrieve all the buckets for the specified project.\n\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudBackupSnapshotExportBucket.\n",
                "properties": {
                    "exportBucketId": {
                        "type": "string",
                        "description": "Unique identifier of the snapshot export bucket.\n"
                    },
                    "id": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "exportBucketId",
                    "id",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudBackupSnapshotExportBucket.\n",
                "properties": {
                    "bucketName": {
                        "type": "string",
                        "description": "Name of the bucket that the provided role ID is authorized to access. You must also specify the `iam_role_id`.\n"
                    },
                    "cloudProvider": {
                        "type": "string",
                        "description": "Name of the provider of the cloud service where Atlas can access the S3 bucket. Atlas only supports `AWS`.\n"
                    },
                    "exportBucketId": {
                        "type": "string"
                    },
                    "iamRoleId": {
                        "type": "string",
                        "description": "Unique identifier of the role that Atlas can use to access the bucket. You must also specify the `bucket_name`.\n"
                    },
                    "id": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "bucketName",
                    "cloudProvider",
                    "exportBucketId",
                    "iamRoleId",
                    "id",
                    "projectId"
                ]
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotExportBuckets:getCloudBackupSnapshotExportBuckets": {
            "description": "`mongodbatlas.getCloudBackupSnapshotExportBuckets` datasource allows you to retrieve all the buckets for the specified project.\n\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testCloudBackupSnapshotExportBucket = new mongodbatlas.CloudBackupSnapshotExportBucket(\"testCloudBackupSnapshotExportBucket\", {\n    bucketName: \"example-bucket\",\n    cloudProvider: \"AWS\",\n    iamRoleId: \"{IAM_ROLE_ID}\",\n    projectId: \"{PROJECT_ID}\",\n});\nconst testCloudBackupSnapshotExportBuckets = mongodbatlas.getCloudBackupSnapshotExportBuckets({\n    projectId: \"{PROJECT_ID}\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_cloud_backup_snapshot_export_bucket = mongodbatlas.CloudBackupSnapshotExportBucket(\"testCloudBackupSnapshotExportBucket\",\n    bucket_name=\"example-bucket\",\n    cloud_provider=\"AWS\",\n    iam_role_id=\"{IAM_ROLE_ID}\",\n    project_id=\"{PROJECT_ID}\")\ntest_cloud_backup_snapshot_export_buckets = mongodbatlas.get_cloud_backup_snapshot_export_buckets(project_id=\"{PROJECT_ID}\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testCloudBackupSnapshotExportBucket = new Mongodbatlas.CloudBackupSnapshotExportBucket(\"testCloudBackupSnapshotExportBucket\", new()\n    {\n        BucketName = \"example-bucket\",\n        CloudProvider = \"AWS\",\n        IamRoleId = \"{IAM_ROLE_ID}\",\n        ProjectId = \"{PROJECT_ID}\",\n    });\n\n    var testCloudBackupSnapshotExportBuckets = Mongodbatlas.GetCloudBackupSnapshotExportBuckets.Invoke(new()\n    {\n        ProjectId = \"{PROJECT_ID}\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewCloudBackupSnapshotExportBucket(ctx, \"testCloudBackupSnapshotExportBucket\", \u0026mongodbatlas.CloudBackupSnapshotExportBucketArgs{\n\t\t\tBucketName:    pulumi.String(\"example-bucket\"),\n\t\t\tCloudProvider: pulumi.String(\"AWS\"),\n\t\t\tIamRoleId:     pulumi.String(\"{IAM_ROLE_ID}\"),\n\t\t\tProjectId:     pulumi.String(\"{PROJECT_ID}\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.LookupCloudBackupSnapshotExportBuckets(ctx, \u0026mongodbatlas.LookupCloudBackupSnapshotExportBucketsArgs{\n\t\t\tProjectId: \"{PROJECT_ID}\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportBucket;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportBucketArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetCloudBackupSnapshotExportBucketsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testCloudBackupSnapshotExportBucket = new CloudBackupSnapshotExportBucket(\"testCloudBackupSnapshotExportBucket\", CloudBackupSnapshotExportBucketArgs.builder()        \n            .bucketName(\"example-bucket\")\n            .cloudProvider(\"AWS\")\n            .iamRoleId(\"{IAM_ROLE_ID}\")\n            .projectId(\"{PROJECT_ID}\")\n            .build());\n\n        final var testCloudBackupSnapshotExportBuckets = MongodbatlasFunctions.getCloudBackupSnapshotExportBuckets(GetCloudBackupSnapshotExportBucketsArgs.builder()\n            .projectId(\"{PROJECT_ID}\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testCloudBackupSnapshotExportBucket:\n    type: mongodbatlas:CloudBackupSnapshotExportBucket\n    properties:\n      bucketName: example-bucket\n      cloudProvider: AWS\n      iamRoleId: '{IAM_ROLE_ID}'\n      projectId: '{PROJECT_ID}'\nvariables:\n  testCloudBackupSnapshotExportBuckets:\n    fn::invoke:\n      Function: mongodbatlas:getCloudBackupSnapshotExportBuckets\n      Arguments:\n        projectId: '{PROJECT_ID}'\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudBackupSnapshotExportBuckets.\n",
                "properties": {
                    "itemsPerPage": {
                        "type": "integer",
                        "description": "Number of items to return per page, up to a maximum of 500. Defaults to `100`.\n"
                    },
                    "pageNum": {
                        "type": "integer",
                        "description": "The page to return. Defaults to `1`.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudBackupSnapshotExportBuckets.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster.\n"
                    },
                    "results": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudBackupSnapshotExportBucketsResult:getCloudBackupSnapshotExportBucketsResult"
                        },
                        "description": "Includes CloudProviderSnapshotExportBucket object for each item detailed in the results array section.\n"
                    },
                    "totalCount": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "projectId",
                    "results",
                    "totalCount",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotExportJob:getCloudBackupSnapshotExportJob": {
            "description": "`mongodbatlas.CloudBackupSnapshotExportJob` datasource allows you to retrieve a snapshot export job for the specified project and cluster.\n\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudBackupSnapshotExportJob.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "Name of the Atlas cluster whose export job you want to retrieve.\n"
                    },
                    "exportJobId": {
                        "type": "string",
                        "description": "Unique identifier of the export job to retrieve.\n"
                    },
                    "id": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the project which contains the Atlas cluster whose snapshot you want to retrieve.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "exportJobId",
                    "id",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudBackupSnapshotExportJob.\n",
                "properties": {
                    "clusterName": {
                        "type": "string"
                    },
                    "components": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudBackupSnapshotExportJobComponent:getCloudBackupSnapshotExportJobComponent"
                        },
                        "description": "_Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when the export job was created.\n"
                    },
                    "customDatas": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudBackupSnapshotExportJobCustomData:getCloudBackupSnapshotExportJobCustomData"
                        },
                        "description": "Custom data to include in the metadata file named `.complete` that Atlas uploads to the bucket when the export job finishes. Custom data can be specified as key and value pairs.\n"
                    },
                    "errMsg": {
                        "type": "string",
                        "description": "Error message, only if the export job failed.\n"
                    },
                    "exportBucketId": {
                        "type": "string",
                        "description": "Unique identifier of the AWS bucket to export the Cloud Backup snapshot to.\n"
                    },
                    "exportJobId": {
                        "type": "string",
                        "description": "Unique identifier of the export job.\n* `prefix ` - Full path on the cloud provider bucket to the folder where the snapshot is exported. The path is in the following format:`/exported_snapshots/{ORG-NAME}/{PROJECT-NAME}/{CLUSTER-NAME}/{SNAPSHOT-INITIATION-DATE}/{TIMESTAMP}`\n"
                    },
                    "exportStatusExportedCollections": {
                        "type": "integer"
                    },
                    "exportStatusTotalCollections": {
                        "type": "integer"
                    },
                    "finishedAt": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when the export job completes.\n"
                    },
                    "id": {
                        "type": "string"
                    },
                    "prefix": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "snapshotId": {
                        "type": "string",
                        "description": "Unique identifier of the Cloud Backup snapshot to export.\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "Status of the export job. Value can be one of the following:\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "components",
                    "createdAt",
                    "customDatas",
                    "errMsg",
                    "exportBucketId",
                    "exportJobId",
                    "exportStatusExportedCollections",
                    "exportStatusTotalCollections",
                    "finishedAt",
                    "id",
                    "prefix",
                    "projectId",
                    "snapshotId",
                    "state"
                ]
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotExportJobs:getCloudBackupSnapshotExportJobs": {
            "description": "`mongodbatlas.getCloudBackupSnapshotExportJobs` datasource allows you to retrieve all the buckets for the specified project.\n\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testCloudBackupSnapshotExportBucket = new mongodbatlas.CloudBackupSnapshotExportBucket(\"testCloudBackupSnapshotExportBucket\", {\n    projectId: \"{PROJECT_ID}\",\n    iamRoleId: \"{IAM_ROLE_ID}\",\n    bucketName: \"example_bucket\",\n    cloudProvider: \"AWS\",\n});\nconst testCloudBackupSnapshotExportJob = new mongodbatlas.CloudBackupSnapshotExportJob(\"testCloudBackupSnapshotExportJob\", {\n    projectId: \"{PROJECT_ID}\",\n    clusterName: \"{CLUSTER_NAME}\",\n    snapshotId: \"{SNAPSHOT_ID}\",\n    exportBucketId: testCloudBackupSnapshotExportBucket.exportBucketId,\n    customDatas: [{\n        key: \"exported by\",\n        value: \"myName\",\n    }],\n});\nconst testCloudBackupSnapshotExportJobs = mongodbatlas.getCloudBackupSnapshotExportJobs({\n    projectId: \"{PROJECT_ID}\",\n    clusterName: \"{CLUSTER_NAME}\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_cloud_backup_snapshot_export_bucket = mongodbatlas.CloudBackupSnapshotExportBucket(\"testCloudBackupSnapshotExportBucket\",\n    project_id=\"{PROJECT_ID}\",\n    iam_role_id=\"{IAM_ROLE_ID}\",\n    bucket_name=\"example_bucket\",\n    cloud_provider=\"AWS\")\ntest_cloud_backup_snapshot_export_job = mongodbatlas.CloudBackupSnapshotExportJob(\"testCloudBackupSnapshotExportJob\",\n    project_id=\"{PROJECT_ID}\",\n    cluster_name=\"{CLUSTER_NAME}\",\n    snapshot_id=\"{SNAPSHOT_ID}\",\n    export_bucket_id=test_cloud_backup_snapshot_export_bucket.export_bucket_id,\n    custom_datas=[mongodbatlas.CloudBackupSnapshotExportJobCustomDataArgs(\n        key=\"exported by\",\n        value=\"myName\",\n    )])\ntest_cloud_backup_snapshot_export_jobs = mongodbatlas.get_cloud_backup_snapshot_export_jobs(project_id=\"{PROJECT_ID}\",\n    cluster_name=\"{CLUSTER_NAME}\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testCloudBackupSnapshotExportBucket = new Mongodbatlas.CloudBackupSnapshotExportBucket(\"testCloudBackupSnapshotExportBucket\", new()\n    {\n        ProjectId = \"{PROJECT_ID}\",\n        IamRoleId = \"{IAM_ROLE_ID}\",\n        BucketName = \"example_bucket\",\n        CloudProvider = \"AWS\",\n    });\n\n    var testCloudBackupSnapshotExportJob = new Mongodbatlas.CloudBackupSnapshotExportJob(\"testCloudBackupSnapshotExportJob\", new()\n    {\n        ProjectId = \"{PROJECT_ID}\",\n        ClusterName = \"{CLUSTER_NAME}\",\n        SnapshotId = \"{SNAPSHOT_ID}\",\n        ExportBucketId = testCloudBackupSnapshotExportBucket.ExportBucketId,\n        CustomDatas = new[]\n        {\n            new Mongodbatlas.Inputs.CloudBackupSnapshotExportJobCustomDataArgs\n            {\n                Key = \"exported by\",\n                Value = \"myName\",\n            },\n        },\n    });\n\n    var testCloudBackupSnapshotExportJobs = Mongodbatlas.GetCloudBackupSnapshotExportJobs.Invoke(new()\n    {\n        ProjectId = \"{PROJECT_ID}\",\n        ClusterName = \"{CLUSTER_NAME}\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestCloudBackupSnapshotExportBucket, err := mongodbatlas.NewCloudBackupSnapshotExportBucket(ctx, \"testCloudBackupSnapshotExportBucket\", \u0026mongodbatlas.CloudBackupSnapshotExportBucketArgs{\n\t\t\tProjectId:     pulumi.String(\"{PROJECT_ID}\"),\n\t\t\tIamRoleId:     pulumi.String(\"{IAM_ROLE_ID}\"),\n\t\t\tBucketName:    pulumi.String(\"example_bucket\"),\n\t\t\tCloudProvider: pulumi.String(\"AWS\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewCloudBackupSnapshotExportJob(ctx, \"testCloudBackupSnapshotExportJob\", \u0026mongodbatlas.CloudBackupSnapshotExportJobArgs{\n\t\t\tProjectId:      pulumi.String(\"{PROJECT_ID}\"),\n\t\t\tClusterName:    pulumi.String(\"{CLUSTER_NAME}\"),\n\t\t\tSnapshotId:     pulumi.String(\"{SNAPSHOT_ID}\"),\n\t\t\tExportBucketId: testCloudBackupSnapshotExportBucket.ExportBucketId,\n\t\t\tCustomDatas: mongodbatlas.CloudBackupSnapshotExportJobCustomDataArray{\n\t\t\t\t\u0026mongodbatlas.CloudBackupSnapshotExportJobCustomDataArgs{\n\t\t\t\t\tKey:   pulumi.String(\"exported by\"),\n\t\t\t\t\tValue: pulumi.String(\"myName\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.LookupCloudBackupSnapshotExportJobs(ctx, \u0026mongodbatlas.LookupCloudBackupSnapshotExportJobsArgs{\n\t\t\tProjectId:   \"{PROJECT_ID}\",\n\t\t\tClusterName: \"{CLUSTER_NAME}\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportBucket;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportBucketArgs;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportJob;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportJobArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudBackupSnapshotExportJobCustomDataArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetCloudBackupSnapshotExportJobsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testCloudBackupSnapshotExportBucket = new CloudBackupSnapshotExportBucket(\"testCloudBackupSnapshotExportBucket\", CloudBackupSnapshotExportBucketArgs.builder()        \n            .projectId(\"{PROJECT_ID}\")\n            .iamRoleId(\"{IAM_ROLE_ID}\")\n            .bucketName(\"example_bucket\")\n            .cloudProvider(\"AWS\")\n            .build());\n\n        var testCloudBackupSnapshotExportJob = new CloudBackupSnapshotExportJob(\"testCloudBackupSnapshotExportJob\", CloudBackupSnapshotExportJobArgs.builder()        \n            .projectId(\"{PROJECT_ID}\")\n            .clusterName(\"{CLUSTER_NAME}\")\n            .snapshotId(\"{SNAPSHOT_ID}\")\n            .exportBucketId(testCloudBackupSnapshotExportBucket.exportBucketId())\n            .customDatas(CloudBackupSnapshotExportJobCustomDataArgs.builder()\n                .key(\"exported by\")\n                .value(\"myName\")\n                .build())\n            .build());\n\n        final var testCloudBackupSnapshotExportJobs = MongodbatlasFunctions.getCloudBackupSnapshotExportJobs(GetCloudBackupSnapshotExportJobsArgs.builder()\n            .projectId(\"{PROJECT_ID}\")\n            .clusterName(\"{CLUSTER_NAME}\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testCloudBackupSnapshotExportBucket:\n    type: mongodbatlas:CloudBackupSnapshotExportBucket\n    properties:\n      projectId: '{PROJECT_ID}'\n      iamRoleId: '{IAM_ROLE_ID}'\n      bucketName: example_bucket\n      cloudProvider: AWS\n  testCloudBackupSnapshotExportJob:\n    type: mongodbatlas:CloudBackupSnapshotExportJob\n    properties:\n      projectId: '{PROJECT_ID}'\n      clusterName: '{CLUSTER_NAME}'\n      snapshotId: '{SNAPSHOT_ID}'\n      exportBucketId: ${testCloudBackupSnapshotExportBucket.exportBucketId}\n      customDatas:\n        - key: exported by\n          value: myName\nvariables:\n  testCloudBackupSnapshotExportJobs:\n    fn::invoke:\n      Function: mongodbatlas:getCloudBackupSnapshotExportJobs\n      Arguments:\n        projectId: '{PROJECT_ID}'\n        clusterName: '{CLUSTER_NAME}'\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudBackupSnapshotExportJobs.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "Name of the Atlas cluster whose export job you want to retrieve.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer",
                        "description": "Number of items to return per page, up to a maximum of 500. Defaults to `100`.\n"
                    },
                    "pageNum": {
                        "type": "integer",
                        "description": "The page to return. Defaults to `1`.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudBackupSnapshotExportJobs.\n",
                "properties": {
                    "clusterName": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster.\n"
                    },
                    "results": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudBackupSnapshotExportJobsResult:getCloudBackupSnapshotExportJobsResult"
                        },
                        "description": "Includes CloudProviderSnapshotExportJob object for each item detailed in the results array section.\n"
                    },
                    "totalCount": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId",
                    "results",
                    "totalCount",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotRestoreJob:getCloudBackupSnapshotRestoreJob": {
            "description": "`mongodbatlas.CloudBackupSnapshotRestoreJob` provides a Cloud Backup Snapshot Restore Job datasource. Gets all the cloud backup snapshot restore jobs for the specified cluster.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudBackupSnapshotRestoreJob.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the Atlas cluster for which you want to retrieve the restore job.\n",
                        "willReplaceOnChanges": true
                    },
                    "jobId": {
                        "type": "string",
                        "description": "The unique identifier of the restore job to retrieve.\n",
                        "willReplaceOnChanges": true
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "jobId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudBackupSnapshotRestoreJob.\n",
                "properties": {
                    "cancelled": {
                        "type": "boolean",
                        "description": "Indicates whether the restore job was canceled.\n"
                    },
                    "clusterName": {
                        "type": "string"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "UTC ISO 8601 formatted point in time when Atlas created the restore job.\n"
                    },
                    "deliveryType": {
                        "type": "string",
                        "description": "Type of restore job to create. Possible values are: automated and download.\n"
                    },
                    "deliveryUrls": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "One or more URLs for the compressed snapshot files for manual download. Only visible if deliveryType is download.\n"
                    },
                    "expired": {
                        "type": "boolean",
                        "description": "Indicates whether the restore job expired.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "UTC ISO 8601 formatted point in time when the restore job expires.\n"
                    },
                    "finishedAt": {
                        "type": "string",
                        "description": "UTC ISO 8601 formatted point in time when the restore job completed.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "jobId": {
                        "type": "string"
                    },
                    "oplogInc": {
                        "type": "integer"
                    },
                    "oplogTs": {
                        "type": "integer"
                    },
                    "pointInTimeUtcSeconds": {
                        "type": "integer"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "snapshotId": {
                        "type": "string",
                        "description": "Unique identifier of the source snapshot ID of the restore job.\n"
                    },
                    "targetClusterName": {
                        "type": "string",
                        "description": "Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.\n"
                    },
                    "targetProjectId": {
                        "type": "string",
                        "description": "Name of the target Atlas project of the restore job. Only visible if deliveryType is automated.\n"
                    },
                    "timestamp": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when the snapshot associated to snapshotId was taken.\n"
                    }
                },
                "type": "object",
                "required": [
                    "cancelled",
                    "clusterName",
                    "createdAt",
                    "deliveryType",
                    "deliveryUrls",
                    "expired",
                    "expiresAt",
                    "finishedAt",
                    "jobId",
                    "oplogInc",
                    "oplogTs",
                    "pointInTimeUtcSeconds",
                    "projectId",
                    "snapshotId",
                    "targetClusterName",
                    "targetProjectId",
                    "timestamp",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotRestoreJobs:getCloudBackupSnapshotRestoreJobs": {
            "description": "`mongodbatlas.getCloudBackupSnapshotRestoreJobs` provides a Cloud Backup Snapshot Restore Jobs datasource. Gets all the cloud backup snapshot restore jobs for the specified cluster.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nFirst create a snapshot of the desired cluster. Then request that snapshot be restored in an automated fashion to the designated cluster and project.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testCloudBackupSnapshot = new mongodbatlas.CloudBackupSnapshot(\"testCloudBackupSnapshot\", {\n    projectId: \"5cf5a45a9ccf6400e60981b6\",\n    clusterName: \"MyCluster\",\n    description: \"MyDescription\",\n    retentionInDays: 1,\n});\nconst testCloudBackupSnapshotRestoreJob = new mongodbatlas.CloudBackupSnapshotRestoreJob(\"testCloudBackupSnapshotRestoreJob\", {\n    projectId: \"5cf5a45a9ccf6400e60981b6\",\n    clusterName: \"MyCluster\",\n    snapshotId: testCloudBackupSnapshot.id,\n    deliveryTypeConfig: {\n        automated: true,\n        targetClusterName: \"MyCluster\",\n        targetProjectId: \"5cf5a45a9ccf6400e60981b6\",\n    },\n});\nconst testCloudBackupSnapshotRestoreJobs = pulumi.all([testCloudBackupSnapshotRestoreJob.projectId, testCloudBackupSnapshotRestoreJob.clusterName]).apply(([projectId, clusterName]) =\u003e mongodbatlas.getCloudBackupSnapshotRestoreJobsOutput({\n    projectId: projectId,\n    clusterName: clusterName,\n    pageNum: 1,\n    itemsPerPage: 5,\n}));\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_cloud_backup_snapshot = mongodbatlas.CloudBackupSnapshot(\"testCloudBackupSnapshot\",\n    project_id=\"5cf5a45a9ccf6400e60981b6\",\n    cluster_name=\"MyCluster\",\n    description=\"MyDescription\",\n    retention_in_days=1)\ntest_cloud_backup_snapshot_restore_job = mongodbatlas.CloudBackupSnapshotRestoreJob(\"testCloudBackupSnapshotRestoreJob\",\n    project_id=\"5cf5a45a9ccf6400e60981b6\",\n    cluster_name=\"MyCluster\",\n    snapshot_id=test_cloud_backup_snapshot.id,\n    delivery_type_config=mongodbatlas.CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs(\n        automated=True,\n        target_cluster_name=\"MyCluster\",\n        target_project_id=\"5cf5a45a9ccf6400e60981b6\",\n    ))\ntest_cloud_backup_snapshot_restore_jobs = pulumi.Output.all(test_cloud_backup_snapshot_restore_job.project_id, test_cloud_backup_snapshot_restore_job.cluster_name).apply(lambda project_id, cluster_name: mongodbatlas.get_cloud_backup_snapshot_restore_jobs_output(project_id=project_id,\n    cluster_name=cluster_name,\n    page_num=1,\n    items_per_page=5))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testCloudBackupSnapshot = new Mongodbatlas.CloudBackupSnapshot(\"testCloudBackupSnapshot\", new()\n    {\n        ProjectId = \"5cf5a45a9ccf6400e60981b6\",\n        ClusterName = \"MyCluster\",\n        Description = \"MyDescription\",\n        RetentionInDays = 1,\n    });\n\n    var testCloudBackupSnapshotRestoreJob = new Mongodbatlas.CloudBackupSnapshotRestoreJob(\"testCloudBackupSnapshotRestoreJob\", new()\n    {\n        ProjectId = \"5cf5a45a9ccf6400e60981b6\",\n        ClusterName = \"MyCluster\",\n        SnapshotId = testCloudBackupSnapshot.Id,\n        DeliveryTypeConfig = new Mongodbatlas.Inputs.CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs\n        {\n            Automated = true,\n            TargetClusterName = \"MyCluster\",\n            TargetProjectId = \"5cf5a45a9ccf6400e60981b6\",\n        },\n    });\n\n    var testCloudBackupSnapshotRestoreJobs = Mongodbatlas.GetCloudBackupSnapshotRestoreJobs.Invoke(new()\n    {\n        ProjectId = testCloudBackupSnapshotRestoreJob.ProjectId,\n        ClusterName = testCloudBackupSnapshotRestoreJob.ClusterName,\n        PageNum = 1,\n        ItemsPerPage = 5,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestCloudBackupSnapshot, err := mongodbatlas.NewCloudBackupSnapshot(ctx, \"testCloudBackupSnapshot\", \u0026mongodbatlas.CloudBackupSnapshotArgs{\n\t\t\tProjectId:       pulumi.String(\"5cf5a45a9ccf6400e60981b6\"),\n\t\t\tClusterName:     pulumi.String(\"MyCluster\"),\n\t\t\tDescription:     pulumi.String(\"MyDescription\"),\n\t\t\tRetentionInDays: pulumi.Int(1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestCloudBackupSnapshotRestoreJob, err := mongodbatlas.NewCloudBackupSnapshotRestoreJob(ctx, \"testCloudBackupSnapshotRestoreJob\", \u0026mongodbatlas.CloudBackupSnapshotRestoreJobArgs{\n\t\t\tProjectId:   pulumi.String(\"5cf5a45a9ccf6400e60981b6\"),\n\t\t\tClusterName: pulumi.String(\"MyCluster\"),\n\t\t\tSnapshotId:  testCloudBackupSnapshot.ID(),\n\t\t\tDeliveryTypeConfig: \u0026mongodbatlas.CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs{\n\t\t\t\tAutomated:         pulumi.Bool(true),\n\t\t\t\tTargetClusterName: pulumi.String(\"MyCluster\"),\n\t\t\t\tTargetProjectId:   pulumi.String(\"5cf5a45a9ccf6400e60981b6\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = pulumi.All(testCloudBackupSnapshotRestoreJob.ProjectId, testCloudBackupSnapshotRestoreJob.ClusterName).ApplyT(func(_args []interface{}) (mongodbatlas.GetCloudBackupSnapshotRestoreJobsResult, error) {\n\t\t\tprojectId := _args[0].(string)\n\t\t\tclusterName := _args[1].(string)\n\t\t\treturn mongodbatlas.LookupCloudBackupSnapshotRestoreJobsOutput(ctx, mongodbatlas.GetCloudBackupSnapshotRestoreJobsOutputArgs{\n\t\t\t\tProjectId:    projectId,\n\t\t\t\tClusterName:  clusterName,\n\t\t\t\tPageNum:      1,\n\t\t\t\tItemsPerPage: 5,\n\t\t\t}, nil), nil\n\t\t}).(mongodbatlas.GetCloudBackupSnapshotRestoreJobsResultOutput)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshot;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotArgs;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotRestoreJob;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotRestoreJobArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetCloudBackupSnapshotRestoreJobsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testCloudBackupSnapshot = new CloudBackupSnapshot(\"testCloudBackupSnapshot\", CloudBackupSnapshotArgs.builder()        \n            .projectId(\"5cf5a45a9ccf6400e60981b6\")\n            .clusterName(\"MyCluster\")\n            .description(\"MyDescription\")\n            .retentionInDays(1)\n            .build());\n\n        var testCloudBackupSnapshotRestoreJob = new CloudBackupSnapshotRestoreJob(\"testCloudBackupSnapshotRestoreJob\", CloudBackupSnapshotRestoreJobArgs.builder()        \n            .projectId(\"5cf5a45a9ccf6400e60981b6\")\n            .clusterName(\"MyCluster\")\n            .snapshotId(testCloudBackupSnapshot.id())\n            .deliveryTypeConfig(CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs.builder()\n                .automated(true)\n                .targetClusterName(\"MyCluster\")\n                .targetProjectId(\"5cf5a45a9ccf6400e60981b6\")\n                .build())\n            .build());\n\n        final var testCloudBackupSnapshotRestoreJobs = MongodbatlasFunctions.getCloudBackupSnapshotRestoreJobs(GetCloudBackupSnapshotRestoreJobsArgs.builder()\n            .projectId(testCloudBackupSnapshotRestoreJob.projectId())\n            .clusterName(testCloudBackupSnapshotRestoreJob.clusterName())\n            .pageNum(1)\n            .itemsPerPage(5)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testCloudBackupSnapshot:\n    type: mongodbatlas:CloudBackupSnapshot\n    properties:\n      projectId: 5cf5a45a9ccf6400e60981b6\n      clusterName: MyCluster\n      description: MyDescription\n      retentionInDays: 1\n  testCloudBackupSnapshotRestoreJob:\n    type: mongodbatlas:CloudBackupSnapshotRestoreJob\n    properties:\n      projectId: 5cf5a45a9ccf6400e60981b6\n      clusterName: MyCluster\n      snapshotId: ${testCloudBackupSnapshot.id}\n      deliveryTypeConfig:\n        automated: true\n        targetClusterName: MyCluster\n        targetProjectId: 5cf5a45a9ccf6400e60981b6\nvariables:\n  testCloudBackupSnapshotRestoreJobs:\n    fn::invoke:\n      Function: mongodbatlas:getCloudBackupSnapshotRestoreJobs\n      Arguments:\n        projectId: ${testCloudBackupSnapshotRestoreJob.projectId}\n        clusterName: ${testCloudBackupSnapshotRestoreJob.clusterName}\n        pageNum: 1\n        itemsPerPage: 5\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudBackupSnapshotRestoreJobs.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the Atlas cluster for which you want to retrieve restore jobs.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer",
                        "description": "Number of items to return per page, up to a maximum of 500. Defaults to `100`.\n"
                    },
                    "pageNum": {
                        "type": "integer",
                        "description": "The page to return. Defaults to `1`.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudBackupSnapshotRestoreJobs.\n",
                "properties": {
                    "clusterName": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudBackupSnapshotRestoreJobsResult:getCloudBackupSnapshotRestoreJobsResult"
                        },
                        "description": "Includes cloudProviderSnapshotRestoreJob object for each item detailed in the results array section.\n"
                    },
                    "totalCount": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId",
                    "results",
                    "totalCount",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshots:getCloudBackupSnapshots": {
            "description": "`mongodbatlas.getCloudBackupSnapshots` provides an Cloud Backup Snapshot datasource. Atlas Cloud Backup Snapshots provide localized backup storage using the native snapshot functionality of the cluster’s cloud service.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudBackupSnapshots.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the Atlas cluster that contains the snapshot you want to retrieve.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer",
                        "description": "Number of items to return per page, up to a maximum of 500. Defaults to `100`.\n"
                    },
                    "pageNum": {
                        "type": "integer",
                        "description": "The page to return. Defaults to `1`.\n"
                    },
                    "projectId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudBackupSnapshots.\n",
                "properties": {
                    "clusterName": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudBackupSnapshotsResult:getCloudBackupSnapshotsResult"
                        },
                        "description": "Includes cloudProviderSnapshot object for each item detailed in the results array section.\n"
                    },
                    "totalCount": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId",
                    "results",
                    "totalCount",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getCloudProviderAccess:getCloudProviderAccess": {
            "description": "`mongodbatlas.CloudProviderAccess` allows you to get the list of cloud provider access roles, currently only AWS is supported.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testRole = new mongodbatlas.CloudProviderAccess(\"testRole\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    providerName: \"AWS\",\n});\nconst all = mongodbatlas.getCloudProviderAccessOutput({\n    projectId: testRole.projectId,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_role = mongodbatlas.CloudProviderAccess(\"testRole\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    provider_name=\"AWS\")\nall = mongodbatlas.get_cloud_provider_access_output(project_id=test_role.project_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testRole = new Mongodbatlas.CloudProviderAccess(\"testRole\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        ProviderName = \"AWS\",\n    });\n\n    var all = Mongodbatlas.GetCloudProviderAccess.Invoke(new()\n    {\n        ProjectId = testRole.ProjectId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestRole, err := mongodbatlas.NewCloudProviderAccess(ctx, \"testRole\", \u0026mongodbatlas.CloudProviderAccessArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupCloudProviderAccessOutput(ctx, mongodbatlas.GetCloudProviderAccessOutputArgs{\n\t\t\tProjectId: testRole.ProjectId,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CloudProviderAccess;\nimport com.pulumi.mongodbatlas.CloudProviderAccessArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetCloudProviderAccessArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testRole = new CloudProviderAccess(\"testRole\", CloudProviderAccessArgs.builder()        \n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .providerName(\"AWS\")\n            .build());\n\n        final var all = MongodbatlasFunctions.getCloudProviderAccess(GetCloudProviderAccessArgs.builder()\n            .projectId(testRole.projectId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testRole:\n    type: mongodbatlas:CloudProviderAccess\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      providerName: AWS\nvariables:\n  all:\n    fn::invoke:\n      Function: mongodbatlas:getCloudProviderAccess\n      Arguments:\n        projectId: ${testRole.projectId}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudProviderAccess.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to get all Cloud Provider Access\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudProviderAccess.\n",
                "properties": {
                    "awsIamRoles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudProviderAccessAwsIamRole:getCloudProviderAccessAwsIamRole"
                        },
                        "description": "A list where each represents a Cloud Provider Access Role.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "projectId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "awsIamRoles",
                    "projectId",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getCloudProviderAccessSetup:getCloudProviderAccessSetup": {
            "description": "`mongodbatlas.CloudProviderAccess` allows you to get a single role for a provider access role setup, currently only AWS is supported.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testRole = new mongodbatlas.CloudProviderAccessSetup(\"testRole\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    providerName: \"AWS\",\n});\nconst singleSetup = mongodbatlas.getCloudProviderAccessSetupOutput({\n    projectId: testRole.projectId,\n    providerName: testRole.providerName,\n    roleId: testRole.roleId,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_role = mongodbatlas.CloudProviderAccessSetup(\"testRole\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    provider_name=\"AWS\")\nsingle_setup = mongodbatlas.get_cloud_provider_access_setup_output(project_id=test_role.project_id,\n    provider_name=test_role.provider_name,\n    role_id=test_role.role_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testRole = new Mongodbatlas.CloudProviderAccessSetup(\"testRole\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        ProviderName = \"AWS\",\n    });\n\n    var singleSetup = Mongodbatlas.GetCloudProviderAccessSetup.Invoke(new()\n    {\n        ProjectId = testRole.ProjectId,\n        ProviderName = testRole.ProviderName,\n        RoleId = testRole.RoleId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestRole, err := mongodbatlas.NewCloudProviderAccessSetup(ctx, \"testRole\", \u0026mongodbatlas.CloudProviderAccessSetupArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupCloudProviderAccessSetupOutput(ctx, mongodbatlas.GetCloudProviderAccessSetupOutputArgs{\n\t\t\tProjectId:    testRole.ProjectId,\n\t\t\tProviderName: testRole.ProviderName,\n\t\t\tRoleId:       testRole.RoleId,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CloudProviderAccessSetup;\nimport com.pulumi.mongodbatlas.CloudProviderAccessSetupArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetCloudProviderAccessSetupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testRole = new CloudProviderAccessSetup(\"testRole\", CloudProviderAccessSetupArgs.builder()        \n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .providerName(\"AWS\")\n            .build());\n\n        final var singleSetup = MongodbatlasFunctions.getCloudProviderAccessSetup(GetCloudProviderAccessSetupArgs.builder()\n            .projectId(testRole.projectId())\n            .providerName(testRole.providerName())\n            .roleId(testRole.roleId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testRole:\n    type: mongodbatlas:CloudProviderAccessSetup\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      providerName: AWS\nvariables:\n  singleSetup:\n    fn::invoke:\n      Function: mongodbatlas:getCloudProviderAccessSetup\n      Arguments:\n        projectId: ${testRole.projectId}\n        providerName: ${testRole.providerName}\n        roleId: ${testRole.roleId}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudProviderAccessSetup.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to get all Cloud Provider Access\n"
                    },
                    "providerName": {
                        "type": "string",
                        "description": "cloud provider name, currently only AWS is supported\n"
                    },
                    "roleId": {
                        "type": "string",
                        "description": "unique role id among all the aws roles provided by mongodb atlas\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId",
                    "providerName",
                    "roleId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudProviderAccessSetup.\n",
                "properties": {
                    "aws": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "aws related role information\n"
                    },
                    "awsConfigs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudProviderAccessSetupAwsConfig:getCloudProviderAccessSetupAwsConfig"
                        }
                    },
                    "createdDate": {
                        "type": "string",
                        "description": "Date on which this role was created.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "providerName": {
                        "type": "string"
                    },
                    "roleId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "aws",
                    "awsConfigs",
                    "createdDate",
                    "projectId",
                    "providerName",
                    "roleId",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getCloudProviderSnapshot:getCloudProviderSnapshot": {
            "description": "**WARNING:** This datasource is deprecated, use `mongodbatlas.CloudBackupSnapshot`\n\n`mongodbatlas.CloudProviderSnapshot` provides an Cloud Backup Snapshot datasource. Atlas Cloud Backup Snapshots provide localized backup storage using the native snapshot functionality of the cluster’s cloud service.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudProviderSnapshot.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the Atlas cluster that contains the snapshot you want to retrieve.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "snapshotId": {
                        "type": "string",
                        "description": "The unique identifier of the snapshot you want to retrieve.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId",
                    "snapshotId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudProviderSnapshot.\n",
                "properties": {
                    "clusterName": {
                        "type": "string"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "UTC ISO 8601 formatted point in time when Atlas took the snapshot.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "UDescription of the snapshot. Only present for on-demand snapshots.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "UTC ISO 8601 formatted point in time when Atlas will delete the snapshot.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "masterKeyUuid": {
                        "type": "string",
                        "description": "Unique ID of the AWS KMS Customer Master Key used to encrypt the snapshot. Only visible for clusters using Encryption at Rest via Customer KMS.\n"
                    },
                    "mongodVersion": {
                        "type": "string",
                        "description": "Version of the MongoDB server.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "snapshotId": {
                        "type": "string"
                    },
                    "snapshotType": {
                        "type": "string",
                        "description": "Specified the type of snapshot. Valid values are onDemand and scheduled.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Current status of the snapshot. One of the following values: queued, inProgress, completed, failed.\n"
                    },
                    "storageSizeBytes": {
                        "type": "integer",
                        "description": "Specifies the size of the snapshot in bytes.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Specifies the type of cluster: replicaSet or shardedCluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "createdAt",
                    "description",
                    "expiresAt",
                    "masterKeyUuid",
                    "mongodVersion",
                    "projectId",
                    "snapshotId",
                    "snapshotType",
                    "status",
                    "storageSizeBytes",
                    "type",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getCloudProviderSnapshotBackupPolicy:getCloudProviderSnapshotBackupPolicy": {
            "description": "**WARNING:** This data source is deprecated, use `mongodbatlas.CloudBackupSchedule`\n\n`mongodbatlas.CloudProviderSnapshotBackupPolicy` provides a Cloud Backup Snapshot Backup Policy datasource. An Atlas Cloud Backup Snapshot Policy provides the current snapshot schedule and retention settings for the cluster. \n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudProviderSnapshotBackupPolicy.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the Atlas cluster that contains the snapshots backup policy you want to retrieve.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudProviderSnapshotBackupPolicy.\n",
                "properties": {
                    "clusterId": {
                        "type": "string",
                        "description": "Unique identifier of the Atlas cluster.\n"
                    },
                    "clusterName": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "nextSnapshot": {
                        "type": "string",
                        "description": "UTC ISO 8601 formatted point in time when Atlas will take the next snapshot.\n"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudProviderSnapshotBackupPolicyPolicy:getCloudProviderSnapshotBackupPolicyPolicy"
                        },
                        "description": "A list of policy definitions for the cluster.\n* `policies.#.id` - Unique identifier of the backup policy.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "referenceHourOfDay": {
                        "type": "integer",
                        "description": "UTC Hour of day between 0 and 23 representing which hour of the day that Atlas takes a snapshot.\n"
                    },
                    "referenceMinuteOfHour": {
                        "type": "integer",
                        "description": "UTC Minute of day between 0 and 59 representing which minute of the referenceHourOfDay that Atlas takes the snapshot.\n"
                    },
                    "restoreWindowDays": {
                        "type": "integer",
                        "description": "Specifies a restore window in days for cloud backup to maintain.\n"
                    },
                    "updateSnapshots": {
                        "type": "boolean"
                    }
                },
                "type": "object",
                "required": [
                    "clusterId",
                    "clusterName",
                    "nextSnapshot",
                    "policies",
                    "projectId",
                    "referenceHourOfDay",
                    "referenceMinuteOfHour",
                    "restoreWindowDays",
                    "updateSnapshots",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getCloudProviderSnapshotRestoreJob:getCloudProviderSnapshotRestoreJob": {
            "description": "**WARNING:** This datasource is deprecated, use `mongodbatlas.CloudBackupSnapshotRestoreJob`\n\n`mongodbatlas.CloudProviderSnapshotRestoreJob` provides a Cloud Backup Snapshot Restore Job datasource. Gets all the cloud backup snapshot restore jobs for the specified cluster.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudProviderSnapshotRestoreJob.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the Atlas cluster for which you want to retrieve the restore job.\n",
                        "willReplaceOnChanges": true
                    },
                    "jobId": {
                        "type": "string",
                        "description": "The unique identifier of the restore job to retrieve.\n",
                        "willReplaceOnChanges": true
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "jobId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudProviderSnapshotRestoreJob.\n",
                "properties": {
                    "cancelled": {
                        "type": "boolean",
                        "description": "Indicates whether the restore job was canceled.\n"
                    },
                    "clusterName": {
                        "type": "string"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "UTC ISO 8601 formatted point in time when Atlas created the restore job.\n"
                    },
                    "deliveryType": {
                        "type": "string",
                        "description": "Type of restore job to create. Possible values are: automated and download.\n"
                    },
                    "deliveryUrls": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "One or more URLs for the compressed snapshot files for manual download. Only visible if deliveryType is download.\n"
                    },
                    "expired": {
                        "type": "boolean",
                        "description": "Indicates whether the restore job expired.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "UTC ISO 8601 formatted point in time when the restore job expires.\n"
                    },
                    "finishedAt": {
                        "type": "string",
                        "description": "UTC ISO 8601 formatted point in time when the restore job completed.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "jobId": {
                        "type": "string"
                    },
                    "oplogInc": {
                        "type": "integer"
                    },
                    "oplogTs": {
                        "type": "integer"
                    },
                    "pointInTimeUtcSeconds": {
                        "type": "integer"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "snapshotId": {
                        "type": "string",
                        "description": "Unique identifier of the source snapshot ID of the restore job.\n"
                    },
                    "targetClusterName": {
                        "type": "string",
                        "description": "Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.\n"
                    },
                    "targetProjectId": {
                        "type": "string",
                        "description": "Name of the target Atlas project of the restore job. Only visible if deliveryType is automated.\n"
                    },
                    "timestamp": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when the snapshot associated to snapshotId was taken.\n"
                    }
                },
                "type": "object",
                "required": [
                    "cancelled",
                    "clusterName",
                    "createdAt",
                    "deliveryType",
                    "deliveryUrls",
                    "expired",
                    "expiresAt",
                    "finishedAt",
                    "jobId",
                    "oplogInc",
                    "oplogTs",
                    "pointInTimeUtcSeconds",
                    "projectId",
                    "snapshotId",
                    "targetClusterName",
                    "targetProjectId",
                    "timestamp",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getCloudProviderSnapshotRestoreJobs:getCloudProviderSnapshotRestoreJobs": {
            "description": "**WARNING:** This datasource is deprecated, use `mongodbatlas_cloud_backup_snapshots_restore_jobs`\n\n`mongodbatlas.getCloudProviderSnapshotRestoreJobs` provides a Cloud Backup Snapshot Restore Jobs datasource. Gets all the cloud backup snapshot restore jobs for the specified cluster.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\nFirst create a snapshot of the desired cluster. Then request that snapshot be restored in an automated fashion to the designated cluster and project.\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CloudProviderSnapshot;\nimport com.pulumi.mongodbatlas.CloudProviderSnapshotArgs;\nimport com.pulumi.mongodbatlas.CloudProviderSnapshotRestoreJob;\nimport com.pulumi.mongodbatlas.CloudProviderSnapshotRestoreJobArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetCloudProviderSnapshotRestoreJobsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testCloudProviderSnapshot = new CloudProviderSnapshot(\"testCloudProviderSnapshot\", CloudProviderSnapshotArgs.builder()        \n            .projectId(\"5cf5a45a9ccf6400e60981b6\")\n            .clusterName(\"MyCluster\")\n            .description(\"MyDescription\")\n            .retentionInDays(1)\n            .build());\n\n        var testCloudProviderSnapshotRestoreJob = new CloudProviderSnapshotRestoreJob(\"testCloudProviderSnapshotRestoreJob\", CloudProviderSnapshotRestoreJobArgs.builder()        \n            .projectId(\"5cf5a45a9ccf6400e60981b6\")\n            .clusterName(\"MyCluster\")\n            .snapshotId(testCloudProviderSnapshot.id())\n            .deliveryType(Map.ofEntries(\n                Map.entry(\"automated\", true),\n                Map.entry(\"targetClusterName\", \"MyCluster\"),\n                Map.entry(\"targetProjectId\", \"5cf5a45a9ccf6400e60981b6\")\n            ))\n            .build());\n\n        final var testCloudProviderSnapshotRestoreJobs = MongodbatlasFunctions.getCloudProviderSnapshotRestoreJobs(GetCloudProviderSnapshotRestoreJobsArgs.builder()\n            .projectId(testCloudProviderSnapshotRestoreJob.projectId())\n            .clusterName(testCloudProviderSnapshotRestoreJob.clusterName())\n            .pageNum(1)\n            .itemsPerPage(5)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testCloudProviderSnapshot:\n    type: mongodbatlas:CloudProviderSnapshot\n    properties:\n      projectId: 5cf5a45a9ccf6400e60981b6\n      clusterName: MyCluster\n      description: MyDescription\n      retentionInDays: 1\n  testCloudProviderSnapshotRestoreJob:\n    type: mongodbatlas:CloudProviderSnapshotRestoreJob\n    properties:\n      projectId: 5cf5a45a9ccf6400e60981b6\n      clusterName: MyCluster\n      snapshotId: ${testCloudProviderSnapshot.id}\n      deliveryType:\n        - automated: true\n          targetClusterName: MyCluster\n          targetProjectId: 5cf5a45a9ccf6400e60981b6\nvariables:\n  testCloudProviderSnapshotRestoreJobs:\n    fn::invoke:\n      Function: mongodbatlas:getCloudProviderSnapshotRestoreJobs\n      Arguments:\n        projectId: ${testCloudProviderSnapshotRestoreJob.projectId}\n        clusterName: ${testCloudProviderSnapshotRestoreJob.clusterName}\n        pageNum: 1\n        itemsPerPage: 5\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudProviderSnapshotRestoreJobs.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the Atlas cluster for which you want to retrieve restore jobs.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer",
                        "description": "Number of items to return per page, up to a maximum of 500. Defaults to `100`.\n"
                    },
                    "pageNum": {
                        "type": "integer",
                        "description": "The page to return. Defaults to `1`.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudProviderSnapshotRestoreJobs.\n",
                "properties": {
                    "clusterName": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudProviderSnapshotRestoreJobsResult:getCloudProviderSnapshotRestoreJobsResult"
                        },
                        "description": "Includes cloudProviderSnapshotRestoreJob object for each item detailed in the results array section.\n"
                    },
                    "totalCount": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId",
                    "results",
                    "totalCount",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getCloudProviderSnapshots:getCloudProviderSnapshots": {
            "description": "**WARNING:** This datasource is deprecated, use `mongodbatlas.getCloudBackupSnapshots`\n\n`mongodbatlas.getCloudProviderSnapshots` provides an Cloud Backup Snapshot datasource. Atlas Cloud Backup Snapshots provide localized backup storage using the native snapshot functionality of the cluster’s cloud service.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CloudProviderSnapshot;\nimport com.pulumi.mongodbatlas.CloudProviderSnapshotArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetCloudProviderSnapshotsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testCloudProviderSnapshot = new CloudProviderSnapshot(\"testCloudProviderSnapshot\", CloudProviderSnapshotArgs.builder()        \n            .groupId(\"5d0f1f73cf09a29120e173cf\")\n            .clusterName(\"MyClusterTest\")\n            .description(\"SomeDescription\")\n            .retentionInDays(1)\n            .build());\n\n        final var testCloudProviderSnapshots = MongodbatlasFunctions.getCloudProviderSnapshots(GetCloudProviderSnapshotsArgs.builder()\n            .groupId(mongodbatlas_cloud_provider_snapshots.test().group_id())\n            .clusterName(mongodbatlas_cloud_provider_snapshots.test().cluster_name())\n            .pageNum(1)\n            .itemsPerPage(5)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testCloudProviderSnapshot:\n    type: mongodbatlas:CloudProviderSnapshot\n    properties:\n      groupId: 5d0f1f73cf09a29120e173cf\n      clusterName: MyClusterTest\n      description: SomeDescription\n      retentionInDays: 1\nvariables:\n  testCloudProviderSnapshots:\n    fn::invoke:\n      Function: mongodbatlas:getCloudProviderSnapshots\n      Arguments:\n        groupId: ${mongodbatlas_cloud_provider_snapshots.test.group_id}\n        clusterName: ${mongodbatlas_cloud_provider_snapshots.test.cluster_name}\n        pageNum: 1\n        itemsPerPage: 5\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudProviderSnapshots.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the Atlas cluster that contains the snapshot you want to retrieve.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer",
                        "description": "Number of items to return per page, up to a maximum of 500. Defaults to `100`.\n"
                    },
                    "pageNum": {
                        "type": "integer",
                        "description": "The page to return. Defaults to `1`.\n"
                    },
                    "projectId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudProviderSnapshots.\n",
                "properties": {
                    "clusterName": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudProviderSnapshotsResult:getCloudProviderSnapshotsResult"
                        },
                        "description": "Includes cloudProviderSnapshot object for each item detailed in the results array section.\n"
                    },
                    "totalCount": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId",
                    "results",
                    "totalCount",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getCluster:getCluster": {
            "description": "`mongodbatlas.Cluster` describes a Cluster. The data source requires your Project ID.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n\u003e **IMPORTANT:**\n\u003cbr\u003e \u0026#8226; Changes to cluster configurations can affect costs. Before making changes, please see [Billing](https://docs.atlas.mongodb.com/billing/).\n\u003cbr\u003e \u0026#8226; If your Atlas project contains a custom role that uses actions introduced in a specific MongoDB version, you cannot create a cluster with a MongoDB version less than that version unless you delete the custom role.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCluster.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Name of the cluster as it appears in Atlas. Once the cluster is created, its name cannot be changed.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the database user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCluster.\n",
                "properties": {
                    "advancedConfigurations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getClusterAdvancedConfiguration:getClusterAdvancedConfiguration"
                        },
                        "description": "Get the advanced configuration options. See Advanced Configuration below for more details.\n"
                    },
                    "autoScalingComputeEnabled": {
                        "type": "boolean",
                        "description": "Specifies whether cluster tier auto-scaling is enabled. The default is false.\n"
                    },
                    "autoScalingComputeScaleDownEnabled": {
                        "type": "boolean",
                        "description": "Specifies whether cluster tier auto-down-scaling is enabled.\n"
                    },
                    "autoScalingDiskGbEnabled": {
                        "type": "boolean",
                        "description": "Indicates whether disk auto-scaling is enabled.\n"
                    },
                    "backingProviderName": {
                        "type": "string",
                        "description": "Indicates Cloud service provider on which the server for a multi-tenant cluster is provisioned.\n"
                    },
                    "backupEnabled": {
                        "type": "boolean",
                        "description": "Legacy Option, Indicates whether Atlas continuous backups are enabled for the cluster.\n"
                    },
                    "biConnector": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Indicates BI Connector for Atlas configuration on this cluster. BI Connector for Atlas is only available for M10+ clusters. See BI Connector below for more details. **DEPRECATED** Use `bi_connector_config` instead.\n",
                        "deprecationMessage": "use bi_connector_config instead"
                    },
                    "biConnectorConfigs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getClusterBiConnectorConfig:getClusterBiConnectorConfig"
                        },
                        "description": "Indicates BI Connector for Atlas configuration on this cluster. BI Connector for Atlas is only available for M10+ clusters. See BI Connector below for more details.\n"
                    },
                    "clusterType": {
                        "type": "string",
                        "description": "Indicates the type of the cluster that you want to modify. You cannot convert a sharded cluster deployment to a replica set deployment.\n"
                    },
                    "connectionStrings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getClusterConnectionString:getClusterConnectionString"
                        },
                        "description": "Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.\n- `connection_strings.standard` -   Public mongodb:// connection string for this cluster.\n- `connection_strings.standard_srv` - Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t, use connectionStrings.standard.\n- `connection_strings.aws_private_link` -  [Private-endpoint-aware](https://docs.atlas.mongodb.com/security-private-endpoint/#private-endpoint-connection-strings) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a AWS PrivateLink connection to this cluster. **DEPRECATED** Use `connection_strings.private_endpoint[n].connection_string` instead.\n- `connection_strings.aws_private_link_srv` - [Private-endpoint-aware](https://docs.atlas.mongodb.com/security-private-endpoint/#private-endpoint-connection-strings) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a AWS PrivateLink connection to this cluster. Use this URI format if your driver supports it. If it doesn’t, use connectionStrings.awsPrivateLink. **DEPRECATED** Use `connection_strings.private_endpoint[n].srv_connection_string` instead.\n- `connection_strings.private` -   [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.\n- `connection_strings.private_srv` -  [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.\n- `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.\n- `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint.\n- `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.\n- `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`\n- `connection_strings.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.\n- `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.\n- `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.\n"
                    },
                    "containerId": {
                        "type": "string",
                        "description": "The Network Peering Container ID.\n"
                    },
                    "diskSizeGb": {
                        "type": "number",
                        "description": "Indicates the size in gigabytes of the server’s root volume (AWS/GCP Only).\n"
                    },
                    "encryptionAtRestProvider": {
                        "type": "string",
                        "description": "Indicates whether Encryption at Rest is enabled or disabled.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "labels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getClusterLabel:getClusterLabel"
                        }
                    },
                    "mongoDbMajorVersion": {
                        "type": "string",
                        "description": "Indicates the version of the cluster to deploy.\n"
                    },
                    "mongoDbVersion": {
                        "type": "string",
                        "description": "Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.\n"
                    },
                    "mongoUri": {
                        "type": "string",
                        "description": "Base connection string for the cluster. Atlas only displays this field after the cluster is operational, not while it builds the cluster.\n"
                    },
                    "mongoUriUpdated": {
                        "type": "string",
                        "description": "Lists when the connection string was last updated. The connection string changes, for example, if you change a replica set to a sharded cluster.\n"
                    },
                    "mongoUriWithOptions": {
                        "type": "string",
                        "description": "Describes connection string for connecting to the Atlas cluster. Includes the replicaSet, ssl, and authSource query parameters in the connection string with values appropriate for the cluster.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the current plugin\n"
                    },
                    "numShards": {
                        "type": "integer",
                        "description": "Number of shards to deploy in the specified zone.\n"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "Flag that indicates whether the cluster is paused or not.\n"
                    },
                    "pitEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates if the cluster uses Continuous Cloud Backup.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "providerAutoScalingComputeMaxInstanceSize": {
                        "type": "string",
                        "description": "Maximum instance size to which your cluster can automatically scale.\n"
                    },
                    "providerAutoScalingComputeMinInstanceSize": {
                        "type": "string",
                        "description": "Minimum instance size to which your cluster can automatically scale.\n"
                    },
                    "providerBackupEnabled": {
                        "type": "boolean",
                        "description": "**(DEPRECATED)** Flag indicating if the cluster uses Cloud Backup Snapshots for backups.\n"
                    },
                    "providerDiskIops": {
                        "type": "integer",
                        "description": "Indicates the maximum input/output operations per second (IOPS) the system can perform. The possible values depend on the selected providerSettings.instanceSizeName and diskSizeGB.\n"
                    },
                    "providerDiskTypeName": {
                        "type": "string",
                        "description": "Describes Azure disk type of the server’s root volume (Azure Only).\n"
                    },
                    "providerEncryptEbsVolume": {
                        "type": "boolean",
                        "description": "**(DEPRECATED)** Indicates whether the Amazon EBS encryption is enabled. This feature encrypts the server’s root volume for both data at rest within the volume and data moving between the volume and the instance. By default this attribute is always enabled, per deprecation process showing the real value at `provider_encrypt_ebs_volume_flag` computed attribute.\n"
                    },
                    "providerEncryptEbsVolumeFlag": {
                        "type": "boolean"
                    },
                    "providerInstanceSizeName": {
                        "type": "string",
                        "description": "Atlas provides different instance sizes, each with a default storage capacity and RAM size.\n"
                    },
                    "providerName": {
                        "type": "string",
                        "description": "Indicates the cloud service provider on which the servers are provisioned.\n"
                    },
                    "providerRegionName": {
                        "type": "string",
                        "description": "Indicates Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the Atlas Region name, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).\n"
                    },
                    "providerVolumeType": {
                        "type": "string",
                        "description": "Indicates the type of the volume. The possible values are: `STANDARD` and `PROVISIONED`.\n"
                    },
                    "replicationFactor": {
                        "type": "integer",
                        "description": "(Deprecated) Number of replica set members. Each member keeps a copy of your databases, providing high availability and data redundancy. The possible values are 3, 5, or 7. The default value is 3.\n"
                    },
                    "replicationSpecs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getClusterReplicationSpec:getClusterReplicationSpec"
                        },
                        "description": "Configuration for cluster regions.  See Replication Spec below for more details.\n"
                    },
                    "snapshotBackupPolicies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getClusterSnapshotBackupPolicy:getClusterSnapshotBackupPolicy"
                        },
                        "description": "current snapshot schedule and retention settings for the cluster.\n"
                    },
                    "srvAddress": {
                        "type": "string",
                        "description": "Connection string for connecting to the Atlas cluster. The +srv modifier forces the connection to use TLS/SSL. See the mongoURI for additional options.\n"
                    },
                    "stateName": {
                        "type": "string",
                        "description": "Indicates the current state of the cluster. The possible states are:\n- IDLE\n- CREATING\n- UPDATING\n- DELETING\n- DELETED\n- REPAIRING\n"
                    },
                    "terminationProtectionEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n"
                    },
                    "versionReleaseSystem": {
                        "type": "string",
                        "description": "Release cadence that Atlas uses for this cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "advancedConfigurations",
                    "autoScalingComputeEnabled",
                    "autoScalingComputeScaleDownEnabled",
                    "autoScalingDiskGbEnabled",
                    "backingProviderName",
                    "backupEnabled",
                    "biConnector",
                    "biConnectorConfigs",
                    "clusterType",
                    "connectionStrings",
                    "containerId",
                    "diskSizeGb",
                    "encryptionAtRestProvider",
                    "labels",
                    "mongoDbMajorVersion",
                    "mongoDbVersion",
                    "mongoUri",
                    "mongoUriUpdated",
                    "mongoUriWithOptions",
                    "name",
                    "numShards",
                    "paused",
                    "pitEnabled",
                    "projectId",
                    "providerAutoScalingComputeMaxInstanceSize",
                    "providerAutoScalingComputeMinInstanceSize",
                    "providerBackupEnabled",
                    "providerDiskIops",
                    "providerDiskTypeName",
                    "providerEncryptEbsVolume",
                    "providerEncryptEbsVolumeFlag",
                    "providerInstanceSizeName",
                    "providerName",
                    "providerRegionName",
                    "providerVolumeType",
                    "replicationFactor",
                    "replicationSpecs",
                    "snapshotBackupPolicies",
                    "srvAddress",
                    "stateName",
                    "terminationProtectionEnabled",
                    "versionReleaseSystem",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getClusters:getClusters": {
            "description": "`mongodbatlas.Cluster` describes all Clusters by the provided project_id. The data source requires your Project ID.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n\u003e **IMPORTANT:**\n\u003cbr\u003e \u0026#8226; Changes to cluster configurations can affect costs. Before making changes, please see [Billing](https://docs.atlas.mongodb.com/billing/).\n\u003cbr\u003e \u0026#8226; If your Atlas project contains a custom role that uses actions introduced in a specific MongoDB version, you cannot create a cluster with a MongoDB version less than that version unless you delete the custom role.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testCluster = new mongodbatlas.Cluster(\"testCluster\", {\n    projectId: \"\u003cYOUR-PROJECT-ID\u003e\",\n    diskSizeGb: 100,\n    clusterType: \"REPLICASET\",\n    replicationSpecs: [{\n        numShards: 1,\n        regionsConfigs: [{\n            regionName: \"US_EAST_1\",\n            electableNodes: 3,\n            priority: 7,\n            readOnlyNodes: 0,\n        }],\n    }],\n    cloudBackup: true,\n    autoScalingDiskGbEnabled: true,\n    providerName: \"AWS\",\n    providerInstanceSizeName: \"M40\",\n});\nconst testClusters = mongodbatlas.getClustersOutput({\n    projectId: testCluster.projectId,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_cluster = mongodbatlas.Cluster(\"testCluster\",\n    project_id=\"\u003cYOUR-PROJECT-ID\u003e\",\n    disk_size_gb=100,\n    cluster_type=\"REPLICASET\",\n    replication_specs=[mongodbatlas.ClusterReplicationSpecArgs(\n        num_shards=1,\n        regions_configs=[mongodbatlas.ClusterReplicationSpecRegionsConfigArgs(\n            region_name=\"US_EAST_1\",\n            electable_nodes=3,\n            priority=7,\n            read_only_nodes=0,\n        )],\n    )],\n    cloud_backup=True,\n    auto_scaling_disk_gb_enabled=True,\n    provider_name=\"AWS\",\n    provider_instance_size_name=\"M40\")\ntest_clusters = mongodbatlas.get_clusters_output(project_id=test_cluster.project_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testCluster = new Mongodbatlas.Cluster(\"testCluster\", new()\n    {\n        ProjectId = \"\u003cYOUR-PROJECT-ID\u003e\",\n        DiskSizeGb = 100,\n        ClusterType = \"REPLICASET\",\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.ClusterReplicationSpecArgs\n            {\n                NumShards = 1,\n                RegionsConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.ClusterReplicationSpecRegionsConfigArgs\n                    {\n                        RegionName = \"US_EAST_1\",\n                        ElectableNodes = 3,\n                        Priority = 7,\n                        ReadOnlyNodes = 0,\n                    },\n                },\n            },\n        },\n        CloudBackup = true,\n        AutoScalingDiskGbEnabled = true,\n        ProviderName = \"AWS\",\n        ProviderInstanceSizeName = \"M40\",\n    });\n\n    var testClusters = Mongodbatlas.GetClusters.Invoke(new()\n    {\n        ProjectId = testCluster.ProjectId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestCluster, err := mongodbatlas.NewCluster(ctx, \"testCluster\", \u0026mongodbatlas.ClusterArgs{\n\t\t\tProjectId:   pulumi.String(\"\u003cYOUR-PROJECT-ID\u003e\"),\n\t\t\tDiskSizeGb:  pulumi.Float64(100),\n\t\t\tClusterType: pulumi.String(\"REPLICASET\"),\n\t\t\tReplicationSpecs: mongodbatlas.ClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecArgs{\n\t\t\t\t\tNumShards: pulumi.Int(1),\n\t\t\t\t\tRegionsConfigs: mongodbatlas.ClusterReplicationSpecRegionsConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecRegionsConfigArgs{\n\t\t\t\t\t\t\tRegionName:     pulumi.String(\"US_EAST_1\"),\n\t\t\t\t\t\t\tElectableNodes: pulumi.Int(3),\n\t\t\t\t\t\t\tPriority:       pulumi.Int(7),\n\t\t\t\t\t\t\tReadOnlyNodes:  pulumi.Int(0),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tCloudBackup:              pulumi.Bool(true),\n\t\t\tAutoScalingDiskGbEnabled: pulumi.Bool(true),\n\t\t\tProviderName:             pulumi.String(\"AWS\"),\n\t\t\tProviderInstanceSizeName: pulumi.String(\"M40\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupClustersOutput(ctx, mongodbatlas.GetClustersOutputArgs{\n\t\t\tProjectId: testCluster.ProjectId,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Cluster;\nimport com.pulumi.mongodbatlas.ClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.ClusterReplicationSpecArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetClustersArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testCluster = new Cluster(\"testCluster\", ClusterArgs.builder()        \n            .projectId(\"\u003cYOUR-PROJECT-ID\u003e\")\n            .diskSizeGb(100)\n            .clusterType(\"REPLICASET\")\n            .replicationSpecs(ClusterReplicationSpecArgs.builder()\n                .numShards(1)\n                .regionsConfigs(ClusterReplicationSpecRegionsConfigArgs.builder()\n                    .regionName(\"US_EAST_1\")\n                    .electableNodes(3)\n                    .priority(7)\n                    .readOnlyNodes(0)\n                    .build())\n                .build())\n            .cloudBackup(true)\n            .autoScalingDiskGbEnabled(true)\n            .providerName(\"AWS\")\n            .providerInstanceSizeName(\"M40\")\n            .build());\n\n        final var testClusters = MongodbatlasFunctions.getClusters(GetClustersArgs.builder()\n            .projectId(testCluster.projectId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testCluster:\n    type: mongodbatlas:Cluster\n    properties:\n      projectId: \u003cYOUR-PROJECT-ID\u003e\n      diskSizeGb: 100\n      clusterType: REPLICASET\n      replicationSpecs:\n        - numShards: 1\n          regionsConfigs:\n            - regionName: US_EAST_1\n              electableNodes: 3\n              priority: 7\n              readOnlyNodes: 0\n      cloudBackup: true\n      autoScalingDiskGbEnabled: true\n      # Provider Settings \"block\"\n      providerName: AWS\n      providerInstanceSizeName: M40\nvariables:\n  testClusters:\n    fn::invoke:\n      Function: mongodbatlas:getClusters\n      Arguments:\n        projectId: ${testCluster.projectId}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getClusters.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to get the clusters.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getClusters.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getClustersResult:getClustersResult"
                        },
                        "description": "A list where each represents a Cluster. See Cluster below for more details.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId",
                    "results",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getCustomDbRole:getCustomDbRole": {
            "description": "`mongodbatlas.CustomDbRole` describe a Custom DB Role. This represents a custom db role.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testRole = new mongodbatlas.CustomDbRole(\"testRole\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    roleName: \"myCustomRole\",\n    actions: [\n        {\n            action: \"UPDATE\",\n            resources: [{\n                collectionName: \"\",\n                databaseName: \"anyDatabase\",\n            }],\n        },\n        {\n            action: \"INSERT\",\n            resources: [{\n                collectionName: \"\",\n                databaseName: \"anyDatabase\",\n            }],\n        },\n    ],\n});\nconst test = mongodbatlas.getCustomDbRoleOutput({\n    projectId: testRole.projectId,\n    roleName: testRole.roleName,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_role = mongodbatlas.CustomDbRole(\"testRole\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    role_name=\"myCustomRole\",\n    actions=[\n        mongodbatlas.CustomDbRoleActionArgs(\n            action=\"UPDATE\",\n            resources=[mongodbatlas.CustomDbRoleActionResourceArgs(\n                collection_name=\"\",\n                database_name=\"anyDatabase\",\n            )],\n        ),\n        mongodbatlas.CustomDbRoleActionArgs(\n            action=\"INSERT\",\n            resources=[mongodbatlas.CustomDbRoleActionResourceArgs(\n                collection_name=\"\",\n                database_name=\"anyDatabase\",\n            )],\n        ),\n    ])\ntest = mongodbatlas.get_custom_db_role_output(project_id=test_role.project_id,\n    role_name=test_role.role_name)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testRole = new Mongodbatlas.CustomDbRole(\"testRole\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        RoleName = \"myCustomRole\",\n        Actions = new[]\n        {\n            new Mongodbatlas.Inputs.CustomDbRoleActionArgs\n            {\n                Action = \"UPDATE\",\n                Resources = new[]\n                {\n                    new Mongodbatlas.Inputs.CustomDbRoleActionResourceArgs\n                    {\n                        CollectionName = \"\",\n                        DatabaseName = \"anyDatabase\",\n                    },\n                },\n            },\n            new Mongodbatlas.Inputs.CustomDbRoleActionArgs\n            {\n                Action = \"INSERT\",\n                Resources = new[]\n                {\n                    new Mongodbatlas.Inputs.CustomDbRoleActionResourceArgs\n                    {\n                        CollectionName = \"\",\n                        DatabaseName = \"anyDatabase\",\n                    },\n                },\n            },\n        },\n    });\n\n    var test = Mongodbatlas.GetCustomDbRole.Invoke(new()\n    {\n        ProjectId = testRole.ProjectId,\n        RoleName = testRole.RoleName,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestRole, err := mongodbatlas.NewCustomDbRole(ctx, \"testRole\", \u0026mongodbatlas.CustomDbRoleArgs{\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tRoleName:  pulumi.String(\"myCustomRole\"),\n\t\t\tActions: mongodbatlas.CustomDbRoleActionArray{\n\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionArgs{\n\t\t\t\t\tAction: pulumi.String(\"UPDATE\"),\n\t\t\t\t\tResources: mongodbatlas.CustomDbRoleActionResourceArray{\n\t\t\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionResourceArgs{\n\t\t\t\t\t\t\tCollectionName: pulumi.String(\"\"),\n\t\t\t\t\t\t\tDatabaseName:   pulumi.String(\"anyDatabase\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionArgs{\n\t\t\t\t\tAction: pulumi.String(\"INSERT\"),\n\t\t\t\t\tResources: mongodbatlas.CustomDbRoleActionResourceArray{\n\t\t\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionResourceArgs{\n\t\t\t\t\t\t\tCollectionName: pulumi.String(\"\"),\n\t\t\t\t\t\t\tDatabaseName:   pulumi.String(\"anyDatabase\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupCustomDbRoleOutput(ctx, mongodbatlas.GetCustomDbRoleOutputArgs{\n\t\t\tProjectId: testRole.ProjectId,\n\t\t\tRoleName:  testRole.RoleName,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CustomDbRole;\nimport com.pulumi.mongodbatlas.CustomDbRoleArgs;\nimport com.pulumi.mongodbatlas.inputs.CustomDbRoleActionArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetCustomDbRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testRole = new CustomDbRole(\"testRole\", CustomDbRoleArgs.builder()        \n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .roleName(\"myCustomRole\")\n            .actions(            \n                CustomDbRoleActionArgs.builder()\n                    .action(\"UPDATE\")\n                    .resources(CustomDbRoleActionResourceArgs.builder()\n                        .collectionName(\"\")\n                        .databaseName(\"anyDatabase\")\n                        .build())\n                    .build(),\n                CustomDbRoleActionArgs.builder()\n                    .action(\"INSERT\")\n                    .resources(CustomDbRoleActionResourceArgs.builder()\n                        .collectionName(\"\")\n                        .databaseName(\"anyDatabase\")\n                        .build())\n                    .build())\n            .build());\n\n        final var test = MongodbatlasFunctions.getCustomDbRole(GetCustomDbRoleArgs.builder()\n            .projectId(testRole.projectId())\n            .roleName(testRole.roleName())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testRole:\n    type: mongodbatlas:CustomDbRole\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      roleName: myCustomRole\n      actions:\n        - action: UPDATE\n          resources:\n            - collectionName:\n              databaseName: anyDatabase\n        - action: INSERT\n          resources:\n            - collectionName:\n              databaseName: anyDatabase\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getCustomDbRole\n      Arguments:\n        projectId: ${testRole.projectId}\n        roleName: ${testRole.roleName}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getCustomDbRole.\n",
                "properties": {
                    "inheritedRoles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCustomDbRoleInheritedRole:getCustomDbRoleInheritedRole"
                        }
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the database user.\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "Name of the custom role.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId",
                    "roleName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCustomDbRole.\n",
                "properties": {
                    "actions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCustomDbRoleAction:getCustomDbRoleAction"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "inheritedRoles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCustomDbRoleInheritedRole:getCustomDbRoleInheritedRole"
                        }
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "(Required) Name of the inherited role. This can either be another custom role or a built-in role.\n"
                    }
                },
                "type": "object",
                "required": [
                    "actions",
                    "projectId",
                    "roleName",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getCustomDbRoles:getCustomDbRoles": {
            "description": "`mongodbatlas.getCustomDbRoles` describe all Custom DB Roles. This represents a custom db roles.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testDatabaseUser = new mongodbatlas.DatabaseUser(\"testDatabaseUser\", {\n    username: \"test-acc-username\",\n    password: \"test-acc-password\",\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    databaseName: \"admin\",\n    roles: [\n        {\n            roleName: \"readWrite\",\n            databaseName: \"admin\",\n        },\n        {\n            roleName: \"atlasAdmin\",\n            databaseName: \"admin\",\n        },\n    ],\n});\nconst testCustomDbRoles = mongodbatlas.getCustomDbRoles({\n    projectId: mongodbatlas_custom_db_role.test.project_id,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_database_user = mongodbatlas.DatabaseUser(\"testDatabaseUser\",\n    username=\"test-acc-username\",\n    password=\"test-acc-password\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    database_name=\"admin\",\n    roles=[\n        mongodbatlas.DatabaseUserRoleArgs(\n            role_name=\"readWrite\",\n            database_name=\"admin\",\n        ),\n        mongodbatlas.DatabaseUserRoleArgs(\n            role_name=\"atlasAdmin\",\n            database_name=\"admin\",\n        ),\n    ])\ntest_custom_db_roles = mongodbatlas.get_custom_db_roles(project_id=mongodbatlas_custom_db_role[\"test\"][\"project_id\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testDatabaseUser = new Mongodbatlas.DatabaseUser(\"testDatabaseUser\", new()\n    {\n        Username = \"test-acc-username\",\n        Password = \"test-acc-password\",\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        DatabaseName = \"admin\",\n        Roles = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserRoleArgs\n            {\n                RoleName = \"readWrite\",\n                DatabaseName = \"admin\",\n            },\n            new Mongodbatlas.Inputs.DatabaseUserRoleArgs\n            {\n                RoleName = \"atlasAdmin\",\n                DatabaseName = \"admin\",\n            },\n        },\n    });\n\n    var testCustomDbRoles = Mongodbatlas.GetCustomDbRoles.Invoke(new()\n    {\n        ProjectId = mongodbatlas_custom_db_role.Test.Project_id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewDatabaseUser(ctx, \"testDatabaseUser\", \u0026mongodbatlas.DatabaseUserArgs{\n\t\t\tUsername:     pulumi.String(\"test-acc-username\"),\n\t\t\tPassword:     pulumi.String(\"test-acc-password\"),\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tDatabaseName: pulumi.String(\"admin\"),\n\t\t\tRoles: mongodbatlas.DatabaseUserRoleArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserRoleArgs{\n\t\t\t\t\tRoleName:     pulumi.String(\"readWrite\"),\n\t\t\t\t\tDatabaseName: pulumi.String(\"admin\"),\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.DatabaseUserRoleArgs{\n\t\t\t\t\tRoleName:     pulumi.String(\"atlasAdmin\"),\n\t\t\t\t\tDatabaseName: pulumi.String(\"admin\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.LookupCustomDbRoles(ctx, \u0026mongodbatlas.LookupCustomDbRolesArgs{\n\t\t\tProjectId: mongodbatlas_custom_db_role.Test.Project_id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.DatabaseUser;\nimport com.pulumi.mongodbatlas.DatabaseUserArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserRoleArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetCustomDbRolesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testDatabaseUser = new DatabaseUser(\"testDatabaseUser\", DatabaseUserArgs.builder()        \n            .username(\"test-acc-username\")\n            .password(\"test-acc-password\")\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .databaseName(\"admin\")\n            .roles(            \n                DatabaseUserRoleArgs.builder()\n                    .roleName(\"readWrite\")\n                    .databaseName(\"admin\")\n                    .build(),\n                DatabaseUserRoleArgs.builder()\n                    .roleName(\"atlasAdmin\")\n                    .databaseName(\"admin\")\n                    .build())\n            .build());\n\n        final var testCustomDbRoles = MongodbatlasFunctions.getCustomDbRoles(GetCustomDbRolesArgs.builder()\n            .projectId(mongodbatlas_custom_db_role.test().project_id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testDatabaseUser:\n    type: mongodbatlas:DatabaseUser\n    properties:\n      username: test-acc-username\n      password: test-acc-password\n      projectId: \u003cPROJECT-ID\u003e\n      databaseName: admin\n      roles:\n        - roleName: readWrite\n          databaseName: admin\n        - roleName: atlasAdmin\n          databaseName: admin\nvariables:\n  testCustomDbRoles:\n    fn::invoke:\n      Function: mongodbatlas:getCustomDbRoles\n      Arguments:\n        projectId: ${mongodbatlas_custom_db_role.test.project_id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getCustomDbRoles.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to get all custom db roles.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCustomDbRoles.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCustomDbRolesResult:getCustomDbRolesResult"
                        },
                        "description": "A list where each represents a custom db roles.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId",
                    "results",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getCustomDnsConfigurationClusterAws:getCustomDnsConfigurationClusterAws": {
            "description": "`mongodbatlas.CustomDnsConfigurationClusterAws` describes a Custom DNS Configuration for Atlas Clusters on AWS.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find **group_id** in the official documentation.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCustomDnsConfigurationClusterAws.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "Unique identifier for the project.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCustomDnsConfigurationClusterAws.\n",
                "properties": {
                    "enabled": {
                        "type": "boolean",
                        "description": "Indicates whether the project's clusters deployed to AWS use custom DNS.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "projectId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "enabled",
                    "projectId",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getDataLake:getDataLake": {
            "description": "`mongodbatlas.DataLake` describe a Data Lake.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDataLake.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Name of the data lake.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create a data lake.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDataLake.\n",
                "properties": {
                    "aws": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getDataLakeAw:getDataLakeAw"
                        },
                        "description": "AWS provider of the cloud service where Data Lake can access the S3 Bucket.\n* `aws.0.role_id` - Unique identifier of the role that Data Lake can use to access the data stores.\n* `aws.0.test_s3_bucket` - Name of the S3 data bucket that the provided role ID is authorized to access.\n* `aws.0.role_id` - Unique identifier of the role that Data Lake can use to access the data stores.\n* `aws.0.test_s3_bucket` - Name of the S3 data bucket that the provided role ID is authorized to access.\n* `aws.0.iam_assumed_role_arn` - Amazon Resource Name (ARN) of the IAM Role that Data Lake assumes when accessing S3 Bucket data stores.\n"
                    },
                    "dataProcessRegions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getDataLakeDataProcessRegion:getDataLakeDataProcessRegion"
                        },
                        "description": "The cloud provider region to which Atlas Data Lake routes client connections for data processing.\n* `data_process_region.0.cloud_provider` - Name of the cloud service provider.\n* `data_process_region.0.region` -Name of the region to which Data Lake routes client connections for data processing.\n"
                    },
                    "hostnames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of hostnames assigned to the Atlas Data Lake. Each string in the array is a hostname assigned to the Atlas Data Lake.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "state": {
                        "type": "string",
                        "description": "Current state of the Atlas Data Lake:\n"
                    },
                    "storageDatabases": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getDataLakeStorageDatabase:getDataLakeStorageDatabase"
                        },
                        "description": "Configuration details for mapping each data store to queryable databases and collections.\n* `storage_databases.#.name` - Name of the database to which Data Lake maps the data contained in the data store.\n* `storage_databases.#.collections` -     Array of objects where each object represents a collection and data sources that map to a [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#mongodb-datalakeconf-datalakeconf.stores) data store.\n* `storage_databases.#.collections.#.name` - Name of the collection.\n* `storage_databases.#.collections.#.data_sources` -     Array of objects where each object represents a stores data store to map with the collection.\n* `storage_databases.#.collections.#.data_sources.#.store_name` -     Name of a data store to map to the `\u003ccollection\u003e`.\n* `storage_databases.#.collections.#.data_sources.#.default_format` - Default format that Data Lake assumes if it encounters a file without an extension while searching the storeName.\n* `storage_databases.#.collections.#.data_sources.#.path` - Controls how Atlas Data Lake searches for and parses files in the storeName before mapping them to the `\u003ccollection\u003e`.\n* `storage_databases.#.views` -     Array of objects where each object represents an [aggregation pipeline](https://docs.mongodb.com/manual/core/aggregation-pipeline/#id1) on a collection.\n* `storage_databases.#.views.#.name` - Name of the view.\n* `storage_databases.#.views.#.source` -  Name of the source collection for the view.\n* `storage_databases.#.views.#.pipeline`- Aggregation pipeline stage(s) to apply to the source collection.\n"
                    },
                    "storageStores": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getDataLakeStorageStore:getDataLakeStorageStore"
                        },
                        "description": "Each object in the array represents a data store. Data Lake uses the storage.databases configuration details to map data in each data store to queryable databases and collections.\n* `storage_stores.#.name` - Name of the data store.\n* `storage_stores.#.provider` - Defines where the data is stored.\n* `storage_stores.#.region` - Name of the AWS region in which the S3 bucket is hosted.\n* `storage_stores.#.bucket` - Name of the AWS S3 bucket.\n* `storage_stores.#.prefix` - Prefix Data Lake applies when searching for files in the S3 bucket .\n* `storage_stores.#.delimiter` - The delimiter that separates `storage_databases.#.collections.#.data_sources.#.path` segments in the data store.\n* `storage_stores.#.include_tags` - Determines whether or not to use S3 tags on the files in the given path as additional partition attributes.\n"
                    }
                },
                "type": "object",
                "required": [
                    "aws",
                    "dataProcessRegions",
                    "hostnames",
                    "name",
                    "projectId",
                    "state",
                    "storageDatabases",
                    "storageStores",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getDataLakes:getDataLakes": {
            "description": "`mongodbatlas.getDataLakes` describe all Data Lakes.\n\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = mongodbatlas.getDataLakes({\n    projectId: \"PROJECT ID\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.get_data_lakes(project_id=\"PROJECT ID\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Mongodbatlas.GetDataLakes.Invoke(new()\n    {\n        ProjectId = \"PROJECT ID\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.LookupDataLakes(ctx, \u0026mongodbatlas.LookupDataLakesArgs{\n\t\t\tProjectId: \"PROJECT ID\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetDataLakesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getDataLakes(GetDataLakesArgs.builder()\n            .projectId(\"PROJECT ID\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getDataLakes\n      Arguments:\n        projectId: PROJECT ID\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getDataLakes.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to get all data lakes.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDataLakes.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getDataLakesResult:getDataLakesResult"
                        },
                        "description": "A list where each represents a Data lake.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId",
                    "results",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getDatabaseUser:getDatabaseUser": {
            "description": "`mongodbatlas.DatabaseUser` describe a Database User. This represents a database user which will be applied to all clusters within the project.\n\nEach user has a set of roles that provide access to the project’s databases. User's roles apply to all the clusters in the project: if two clusters have a `products` database and a user has a role granting `read` access on the products database, the user has that access on both clusters.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDatabaseUser.\n",
                "properties": {
                    "authDatabaseName": {
                        "type": "string",
                        "description": "The user’s authentication database. A user must provide both a username and authentication database to log into MongoDB. In Atlas deployments of MongoDB, the authentication database is almost always the admin database, for X509 it is $external.\n"
                    },
                    "databaseName": {
                        "type": "string",
                        "description": "Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.\n",
                        "deprecationMessage": "use auth_database_name instead"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the database user.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Username for authenticating to MongoDB.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId",
                    "username"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDatabaseUser.\n",
                "properties": {
                    "authDatabaseName": {
                        "type": "string"
                    },
                    "awsIamType": {
                        "type": "string",
                        "description": "The new database user authenticates with AWS IAM credentials. Default is `NONE`, `USER` means user has AWS IAM user credentials, `ROLE` - means user has credentials associated with an AWS IAM role.\n"
                    },
                    "databaseName": {
                        "type": "string",
                        "description": "Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.\n",
                        "deprecationMessage": "use auth_database_name instead"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "labels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getDatabaseUserLabel:getDatabaseUserLabel"
                        }
                    },
                    "ldapAuthType": {
                        "type": "string",
                        "description": "Method by which the provided username is authenticated. Default is `NONE`. Other valid values are: `USER`, `GROUP`.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getDatabaseUserRole:getDatabaseUserRole"
                        },
                        "description": "List of user’s roles and the databases / collections on which the roles apply. A role allows the user to perform particular actions on the specified database. A role on the admin database can include privileges that apply to the other databases as well. See Roles below for more details.\n"
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getDatabaseUserScope:getDatabaseUserScope"
                        },
                        "description": "Array of clusters and Atlas Data Lakes that this user has access to.\n"
                    },
                    "username": {
                        "type": "string"
                    },
                    "x509Type": {
                        "type": "string",
                        "description": "X.509 method by which the provided username is authenticated.\n"
                    }
                },
                "type": "object",
                "required": [
                    "awsIamType",
                    "labels",
                    "ldapAuthType",
                    "projectId",
                    "roles",
                    "scopes",
                    "username",
                    "x509Type",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getDatabaseUsers:getDatabaseUsers": {
            "description": "`mongodbatlas.getDatabaseUsers` describe all Database Users. This represents a database user which will be applied to all clusters within the project.\n\nEach user has a set of roles that provide access to the project’s databases. User's roles apply to all the clusters in the project: if two clusters have a `products` database and a user has a role granting `read` access on the products database, the user has that access on both clusters.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testDatabaseUser = new mongodbatlas.DatabaseUser(\"testDatabaseUser\", {\n    username: \"test-acc-username\",\n    password: \"test-acc-password\",\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    authDatabaseName: \"admin\",\n    roles: [\n        {\n            roleName: \"readWrite\",\n            databaseName: \"admin\",\n        },\n        {\n            roleName: \"atlasAdmin\",\n            databaseName: \"admin\",\n        },\n    ],\n    labels: [\n        {\n            key: \"key 1\",\n            value: \"value 1\",\n        },\n        {\n            key: \"key 2\",\n            value: \"value 2\",\n        },\n    ],\n});\nconst testDatabaseUsers = mongodbatlas.getDatabaseUsersOutput({\n    projectId: testDatabaseUser.projectId,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_database_user = mongodbatlas.DatabaseUser(\"testDatabaseUser\",\n    username=\"test-acc-username\",\n    password=\"test-acc-password\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    auth_database_name=\"admin\",\n    roles=[\n        mongodbatlas.DatabaseUserRoleArgs(\n            role_name=\"readWrite\",\n            database_name=\"admin\",\n        ),\n        mongodbatlas.DatabaseUserRoleArgs(\n            role_name=\"atlasAdmin\",\n            database_name=\"admin\",\n        ),\n    ],\n    labels=[\n        mongodbatlas.DatabaseUserLabelArgs(\n            key=\"key 1\",\n            value=\"value 1\",\n        ),\n        mongodbatlas.DatabaseUserLabelArgs(\n            key=\"key 2\",\n            value=\"value 2\",\n        ),\n    ])\ntest_database_users = mongodbatlas.get_database_users_output(project_id=test_database_user.project_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testDatabaseUser = new Mongodbatlas.DatabaseUser(\"testDatabaseUser\", new()\n    {\n        Username = \"test-acc-username\",\n        Password = \"test-acc-password\",\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        AuthDatabaseName = \"admin\",\n        Roles = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserRoleArgs\n            {\n                RoleName = \"readWrite\",\n                DatabaseName = \"admin\",\n            },\n            new Mongodbatlas.Inputs.DatabaseUserRoleArgs\n            {\n                RoleName = \"atlasAdmin\",\n                DatabaseName = \"admin\",\n            },\n        },\n        Labels = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserLabelArgs\n            {\n                Key = \"key 1\",\n                Value = \"value 1\",\n            },\n            new Mongodbatlas.Inputs.DatabaseUserLabelArgs\n            {\n                Key = \"key 2\",\n                Value = \"value 2\",\n            },\n        },\n    });\n\n    var testDatabaseUsers = Mongodbatlas.GetDatabaseUsers.Invoke(new()\n    {\n        ProjectId = testDatabaseUser.ProjectId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestDatabaseUser, err := mongodbatlas.NewDatabaseUser(ctx, \"testDatabaseUser\", \u0026mongodbatlas.DatabaseUserArgs{\n\t\t\tUsername:         pulumi.String(\"test-acc-username\"),\n\t\t\tPassword:         pulumi.String(\"test-acc-password\"),\n\t\t\tProjectId:        pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tAuthDatabaseName: pulumi.String(\"admin\"),\n\t\t\tRoles: mongodbatlas.DatabaseUserRoleArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserRoleArgs{\n\t\t\t\t\tRoleName:     pulumi.String(\"readWrite\"),\n\t\t\t\t\tDatabaseName: pulumi.String(\"admin\"),\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.DatabaseUserRoleArgs{\n\t\t\t\t\tRoleName:     pulumi.String(\"atlasAdmin\"),\n\t\t\t\t\tDatabaseName: pulumi.String(\"admin\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tLabels: mongodbatlas.DatabaseUserLabelArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserLabelArgs{\n\t\t\t\t\tKey:   pulumi.String(\"key 1\"),\n\t\t\t\t\tValue: pulumi.String(\"value 1\"),\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.DatabaseUserLabelArgs{\n\t\t\t\t\tKey:   pulumi.String(\"key 2\"),\n\t\t\t\t\tValue: pulumi.String(\"value 2\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupDatabaseUsersOutput(ctx, mongodbatlas.GetDatabaseUsersOutputArgs{\n\t\t\tProjectId: testDatabaseUser.ProjectId,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.DatabaseUser;\nimport com.pulumi.mongodbatlas.DatabaseUserArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserRoleArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserLabelArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetDatabaseUsersArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testDatabaseUser = new DatabaseUser(\"testDatabaseUser\", DatabaseUserArgs.builder()        \n            .username(\"test-acc-username\")\n            .password(\"test-acc-password\")\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .authDatabaseName(\"admin\")\n            .roles(            \n                DatabaseUserRoleArgs.builder()\n                    .roleName(\"readWrite\")\n                    .databaseName(\"admin\")\n                    .build(),\n                DatabaseUserRoleArgs.builder()\n                    .roleName(\"atlasAdmin\")\n                    .databaseName(\"admin\")\n                    .build())\n            .labels(            \n                DatabaseUserLabelArgs.builder()\n                    .key(\"key 1\")\n                    .value(\"value 1\")\n                    .build(),\n                DatabaseUserLabelArgs.builder()\n                    .key(\"key 2\")\n                    .value(\"value 2\")\n                    .build())\n            .build());\n\n        final var testDatabaseUsers = MongodbatlasFunctions.getDatabaseUsers(GetDatabaseUsersArgs.builder()\n            .projectId(testDatabaseUser.projectId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testDatabaseUser:\n    type: mongodbatlas:DatabaseUser\n    properties:\n      username: test-acc-username\n      password: test-acc-password\n      projectId: \u003cPROJECT-ID\u003e\n      authDatabaseName: admin\n      roles:\n        - roleName: readWrite\n          databaseName: admin\n        - roleName: atlasAdmin\n          databaseName: admin\n      labels:\n        - key: key 1\n          value: value 1\n        - key: key 2\n          value: value 2\nvariables:\n  testDatabaseUsers:\n    fn::invoke:\n      Function: mongodbatlas:getDatabaseUsers\n      Arguments:\n        projectId: ${testDatabaseUser.projectId}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getDatabaseUsers.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to get all database users.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDatabaseUsers.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "ID of the Atlas project the user belongs to.\n"
                    },
                    "results": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getDatabaseUsersResult:getDatabaseUsersResult"
                        },
                        "description": "A list where each represents a Database user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId",
                    "results",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getEventTrigger:getEventTrigger": {
            "description": "`mongodbatlas.EventTrigger` describe an Event Trigger. \n",
            "inputs": {
                "description": "A collection of arguments for invoking getEventTrigger.\n",
                "properties": {
                    "appId": {
                        "type": "string",
                        "description": "The ObjectID of your application.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the trigger.\n"
                    },
                    "triggerId": {
                        "type": "string",
                        "description": "The unique ID of the trigger.\n"
                    }
                },
                "type": "object",
                "required": [
                    "appId",
                    "projectId",
                    "triggerId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getEventTrigger.\n",
                "properties": {
                    "appId": {
                        "type": "string"
                    },
                    "configCollection": {
                        "type": "string",
                        "description": "The name of the MongoDB collection that the trigger watches for change events.\n"
                    },
                    "configDatabase": {
                        "type": "string",
                        "description": "The name of the MongoDB database that contains the watched collection.\n"
                    },
                    "configFullDocument": {
                        "type": "boolean",
                        "description": "If true, indicates that `UPDATE` change events should include the most current [majority-committed](https://docs.mongodb.com/manual/reference/read-concern-majority/) version of the modified document in the fullDocument field.\n"
                    },
                    "configFullDocumentBefore": {
                        "type": "boolean"
                    },
                    "configMatch": {
                        "type": "string",
                        "description": "A [$match](https://docs.mongodb.com/manual/reference/operator/aggregation/match/) expression document that MongoDB Realm includes in the underlying change stream pipeline for the trigger.\n"
                    },
                    "configOperationType": {
                        "type": "string",
                        "description": "The [authentication operation type](https://docs.mongodb.com/realm/triggers/authentication-triggers/#std-label-authentication-event-operation-types) to listen for.\n"
                    },
                    "configOperationTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The [database event operation types](https://docs.mongodb.com/realm/triggers/database-triggers/#std-label-database-events) to listen for.\n"
                    },
                    "configProject": {
                        "type": "string",
                        "description": "A [$project](https://docs.mongodb.com/manual/reference/operator/aggregation/project/) expression document that Realm uses to filter the fields that appear in change event objects.\n"
                    },
                    "configProviders": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of one or more [authentication provider](https://docs.mongodb.com/realm/authentication/providers/) id values. The trigger will only listen for authentication events produced by these providers.\n"
                    },
                    "configSchedule": {
                        "type": "string",
                        "description": "A [cron expression](https://docs.mongodb.com/realm/triggers/cron-expressions/) that defines the trigger schedule.\n"
                    },
                    "configScheduleType": {
                        "type": "string"
                    },
                    "configServiceId": {
                        "type": "string",
                        "description": "The ID of the MongoDB Service associated with the trigger.\n"
                    },
                    "disabled": {
                        "type": "boolean",
                        "description": "Status of a trigger.\n"
                    },
                    "eventProcessors": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getEventTriggerEventProcessor:getEventTriggerEventProcessor"
                        },
                        "description": "An object where each field name is an event processor ID and each value is an object that configures its corresponding event processor.\n* `event_processors.0.aws_eventbridge.config_account_id` - AWS Account ID.\n* `event_processors.0.aws_eventbridge.config_region` - Region of AWS Account.\n"
                    },
                    "functionId": {
                        "type": "string",
                        "description": "The ID of the function associated with the trigger.\n"
                    },
                    "functionName": {
                        "type": "string",
                        "description": "The name of the function associated with the trigger.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the trigger.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "triggerId": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of the trigger.\n"
                    },
                    "unordered": {
                        "type": "boolean",
                        "description": "Only Available for Database Triggers. If true, event ordering is disabled and this trigger can process events in parallel. If false, event ordering is enabled and the trigger executes serially.\n"
                    }
                },
                "type": "object",
                "required": [
                    "appId",
                    "configCollection",
                    "configDatabase",
                    "configFullDocument",
                    "configFullDocumentBefore",
                    "configMatch",
                    "configOperationType",
                    "configOperationTypes",
                    "configProject",
                    "configProviders",
                    "configSchedule",
                    "configScheduleType",
                    "configServiceId",
                    "disabled",
                    "eventProcessors",
                    "functionId",
                    "functionName",
                    "name",
                    "projectId",
                    "triggerId",
                    "type",
                    "unordered",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getEventTriggers:getEventTriggers": {
            "description": "`mongodbatlas.getEventTriggers` describe all Event Triggers.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getEventTriggers.\n",
                "properties": {
                    "appId": {
                        "type": "string",
                        "description": "The ObjectID of your application.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to get all event triggers.\n"
                    }
                },
                "type": "object",
                "required": [
                    "appId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getEventTriggers.\n",
                "properties": {
                    "appId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getEventTriggersResult:getEventTriggersResult"
                        },
                        "description": "A list where each represents a Event Trigger.\n"
                    }
                },
                "type": "object",
                "required": [
                    "appId",
                    "projectId",
                    "results",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getFederatedSettings:getFederatedSettings": {
            "description": "`mongodbatlas.getFederatedSettings` provides a federated settings data source. Atlas Cloud federated settings provides federated settings outputs.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst settings = mongodbatlas.getFederatedSettings({\n    orgId: \"627a9683e7f7f7ff7fe306f14\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nsettings = mongodbatlas.get_federated_settings(org_id=\"627a9683e7f7f7ff7fe306f14\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var settings = Mongodbatlas.GetFederatedSettings.Invoke(new()\n    {\n        OrgId = \"627a9683e7f7f7ff7fe306f14\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.GetFederatedSettings(ctx, \u0026mongodbatlas.GetFederatedSettingsArgs{\n\t\t\tOrgId: \"627a9683e7f7f7ff7fe306f14\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetFederatedSettingsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var settings = MongodbatlasFunctions.getFederatedSettings(GetFederatedSettingsArgs.builder()\n            .orgId(\"627a9683e7f7f7ff7fe306f14\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  settings:\n    fn::invoke:\n      Function: mongodbatlas:getFederatedSettings\n      Arguments:\n        orgId: 627a9683e7f7f7ff7fe306f14\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getFederatedSettings.\n",
                "properties": {
                    "orgId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                    }
                },
                "type": "object",
                "required": [
                    "orgId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getFederatedSettings.\n",
                "properties": {
                    "federatedDomains": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List that contains the domains associated with the organization's identity provider.\n"
                    },
                    "hasRoleMappings": {
                        "type": "boolean",
                        "description": "Flag that indicates whether this organization has role mappings configured.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies this federation.\n"
                    },
                    "identityProviderId": {
                        "type": "string",
                        "description": "Unique 20-hexadecimal digit string that identifies the identity provider connected to this organization.\n"
                    },
                    "identityProviderStatus": {
                        "type": "string",
                        "description": "Value that indicates whether the identity provider is active. Atlas returns ACTIVE if the identity provider is active and INACTIVE if the identity provider is inactive.\n"
                    },
                    "orgId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "federatedDomains",
                    "hasRoleMappings",
                    "id",
                    "identityProviderId",
                    "identityProviderStatus",
                    "orgId"
                ]
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProvider:getFederatedSettingsIdentityProvider": {
            "description": "`mongodbatlas.FederatedSettingsIdentityProvider` provides a federated settings identity provider data source. Atlas federated settings identity provider provides federated settings outputs for the configured identity provider.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst identityProvider = new mongodbatlas.FederatedSettingsIdentityProvider(\"identityProvider\", {\n    federationSettingsId: \"627a9687f7f7f7f774de306f14\",\n    associatedDomains: [\"yourdomain.com\"],\n    ssoDebugEnabled: true,\n    status: \"ACTIVE\",\n    ssoUrl: \"https://mysso.oktapreview.com/app/mysso_terraformtest_1/exk177f7f7f70h8/sso/saml\",\n    issuerUri: \"http://www.okta.com/exk17f7f7f7f7p50h8\",\n    requestBinding: \"HTTP-POST\",\n    responseSignatureAlgorithm: \"SHA-256\",\n});\nconst identityProviderDs = mongodbatlas.getFederatedSettingsIdentityProviderOutput({\n    federationSettingsId: identityProvider.id,\n    identityProviderId: \"0oad47f7fXnk1297\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nidentity_provider = mongodbatlas.FederatedSettingsIdentityProvider(\"identityProvider\",\n    federation_settings_id=\"627a9687f7f7f7f774de306f14\",\n    associated_domains=[\"yourdomain.com\"],\n    sso_debug_enabled=True,\n    status=\"ACTIVE\",\n    sso_url=\"https://mysso.oktapreview.com/app/mysso_terraformtest_1/exk177f7f7f70h8/sso/saml\",\n    issuer_uri=\"http://www.okta.com/exk17f7f7f7f7p50h8\",\n    request_binding=\"HTTP-POST\",\n    response_signature_algorithm=\"SHA-256\")\nidentity_provider_ds = mongodbatlas.get_federated_settings_identity_provider_output(federation_settings_id=identity_provider.id,\n    identity_provider_id=\"0oad47f7fXnk1297\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var identityProvider = new Mongodbatlas.FederatedSettingsIdentityProvider(\"identityProvider\", new()\n    {\n        FederationSettingsId = \"627a9687f7f7f7f774de306f14\",\n        AssociatedDomains = new[]\n        {\n            \"yourdomain.com\",\n        },\n        SsoDebugEnabled = true,\n        Status = \"ACTIVE\",\n        SsoUrl = \"https://mysso.oktapreview.com/app/mysso_terraformtest_1/exk177f7f7f70h8/sso/saml\",\n        IssuerUri = \"http://www.okta.com/exk17f7f7f7f7p50h8\",\n        RequestBinding = \"HTTP-POST\",\n        ResponseSignatureAlgorithm = \"SHA-256\",\n    });\n\n    var identityProviderDs = Mongodbatlas.GetFederatedSettingsIdentityProvider.Invoke(new()\n    {\n        FederationSettingsId = identityProvider.Id,\n        IdentityProviderId = \"0oad47f7fXnk1297\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tidentityProvider, err := mongodbatlas.NewFederatedSettingsIdentityProvider(ctx, \"identityProvider\", \u0026mongodbatlas.FederatedSettingsIdentityProviderArgs{\n\t\t\tFederationSettingsId: pulumi.String(\"627a9687f7f7f7f774de306f14\"),\n\t\t\tAssociatedDomains: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"yourdomain.com\"),\n\t\t\t},\n\t\t\tSsoDebugEnabled:            pulumi.Bool(true),\n\t\t\tStatus:                     pulumi.String(\"ACTIVE\"),\n\t\t\tSsoUrl:                     pulumi.String(\"https://mysso.oktapreview.com/app/mysso_terraformtest_1/exk177f7f7f70h8/sso/saml\"),\n\t\t\tIssuerUri:                  pulumi.String(\"http://www.okta.com/exk17f7f7f7f7p50h8\"),\n\t\t\tRequestBinding:             pulumi.String(\"HTTP-POST\"),\n\t\t\tResponseSignatureAlgorithm: pulumi.String(\"SHA-256\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupFederatedSettingsIdentityProviderOutput(ctx, mongodbatlas.GetFederatedSettingsIdentityProviderOutputArgs{\n\t\t\tFederationSettingsId: identityProvider.ID(),\n\t\t\tIdentityProviderId:   pulumi.String(\"0oad47f7fXnk1297\"),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.FederatedSettingsIdentityProvider;\nimport com.pulumi.mongodbatlas.FederatedSettingsIdentityProviderArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetFederatedSettingsIdentityProviderArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var identityProvider = new FederatedSettingsIdentityProvider(\"identityProvider\", FederatedSettingsIdentityProviderArgs.builder()        \n            .federationSettingsId(\"627a9687f7f7f7f774de306f14\")\n            .associatedDomains(\"yourdomain.com\")\n            .ssoDebugEnabled(true)\n            .status(\"ACTIVE\")\n            .ssoUrl(\"https://mysso.oktapreview.com/app/mysso_terraformtest_1/exk177f7f7f70h8/sso/saml\")\n            .issuerUri(\"http://www.okta.com/exk17f7f7f7f7p50h8\")\n            .requestBinding(\"HTTP-POST\")\n            .responseSignatureAlgorithm(\"SHA-256\")\n            .build());\n\n        final var identityProviderDs = MongodbatlasFunctions.getFederatedSettingsIdentityProvider(GetFederatedSettingsIdentityProviderArgs.builder()\n            .federationSettingsId(identityProvider.id())\n            .identityProviderId(\"0oad47f7fXnk1297\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  identityProvider:\n    type: mongodbatlas:FederatedSettingsIdentityProvider\n    properties:\n      federationSettingsId: 627a9687f7f7f7f774de306f14\n      associatedDomains:\n        - yourdomain.com\n      ssoDebugEnabled: true\n      status: ACTIVE\n      ssoUrl: https://mysso.oktapreview.com/app/mysso_terraformtest_1/exk177f7f7f70h8/sso/saml\n      issuerUri: http://www.okta.com/exk17f7f7f7f7p50h8\n      requestBinding: HTTP-POST\n      responseSignatureAlgorithm: SHA-256\nvariables:\n  identityProviderDs:\n    fn::invoke:\n      Function: mongodbatlas:getFederatedSettingsIdentityProvider\n      Arguments:\n        federationSettingsId: ${identityProvider.id}\n        identityProviderId: 0oad47f7fXnk1297\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getFederatedSettingsIdentityProvider.\n",
                "properties": {
                    "federationSettingsId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                    },
                    "identityProviderId": {
                        "type": "string",
                        "description": "Unique 20-hexadecimal digit string that identifies the IdP.\n"
                    }
                },
                "type": "object",
                "required": [
                    "federationSettingsId",
                    "identityProviderId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getFederatedSettingsIdentityProvider.\n",
                "properties": {
                    "acsUrl": {
                        "type": "string",
                        "description": "Assertion consumer service URL to which the IdP sends the SAML response.\n"
                    },
                    "associatedDomains": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List that contains the configured domains from which users can log in for this IdP.\n"
                    },
                    "associatedOrgs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getFederatedSettingsIdentityProviderAssociatedOrg:getFederatedSettingsIdentityProviderAssociatedOrg"
                        },
                        "description": "List that contains the organizations from which users can log in for this IdP.\n"
                    },
                    "audienceUri": {
                        "type": "string",
                        "description": "Identifier for the intended audience of the SAML Assertion.\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "Human-readable label that identifies the IdP.\n"
                    },
                    "federationSettingsId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "identityProviderId": {
                        "type": "string"
                    },
                    "issuerUri": {
                        "type": "string",
                        "description": "Identifier for the issuer of the SAML Assertion.\n"
                    },
                    "oktaIdpId": {
                        "type": "string",
                        "description": "Unique 20-hexadecimal digit string that identifies the IdP.\n"
                    },
                    "pemFileInfos": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getFederatedSettingsIdentityProviderPemFileInfo:getFederatedSettingsIdentityProviderPemFileInfo"
                        }
                    },
                    "requestBinding": {
                        "type": "string",
                        "description": "SAML Authentication Request Protocol binding used to send the AuthNRequest. Atlas supports the following binding values:\n- HTTP POST\n- HTTP REDIRECT\n"
                    },
                    "responseSignatureAlgorithm": {
                        "type": "string",
                        "description": "Algorithm used to encrypt the IdP signature. Atlas supports the following signature algorithm values:\n- SHA-1\n- SHA-256\n"
                    },
                    "ssoDebugEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether the IdP has enabled Bypass SAML Mode. Enabling this mode generates a URL that allows you bypass SAML and login to your organizations at any point. You can authenticate with this special URL only when Bypass Mode is enabled. Set this parameter to true during testing. This keeps you from getting locked out of MongoDB.\n"
                    },
                    "ssoUrl": {
                        "type": "string",
                        "description": "URL of the receiver of the SAML AuthNRequest.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Label that indicates whether the identity provider is active. The IdP is Inactive until you map at least one domain to the IdP.\n"
                    }
                },
                "type": "object",
                "required": [
                    "acsUrl",
                    "associatedDomains",
                    "associatedOrgs",
                    "audienceUri",
                    "displayName",
                    "federationSettingsId",
                    "identityProviderId",
                    "issuerUri",
                    "oktaIdpId",
                    "pemFileInfos",
                    "requestBinding",
                    "responseSignatureAlgorithm",
                    "ssoDebugEnabled",
                    "ssoUrl",
                    "status",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProviders:getFederatedSettingsIdentityProviders": {
            "description": "`mongodbatlas.getFederatedSettingsIdentityProviders` provides an Federated Settings Identity Providers datasource. Atlas Cloud Federated Settings Identity Providers provides federated settings outputs for the configured Identity Providers.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst identityProvider = new mongodbatlas.FederatedSettingsIdentityProvider(\"identityProvider\", {\n    federationSettingsId: \"627a9687f7f7f7f774de306f14\",\n    associatedDomains: [\"yourdomain.com\"],\n    ssoDebugEnabled: true,\n    status: \"ACTIVE\",\n});\nconst identittyProvider = identityProvider.id.apply(id =\u003e mongodbatlas.getFederatedSettingsIdentityProvidersOutput({\n    federationSettingsId: id,\n    pageNum: 1,\n    itemsPerPage: 5,\n}));\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nidentity_provider = mongodbatlas.FederatedSettingsIdentityProvider(\"identityProvider\",\n    federation_settings_id=\"627a9687f7f7f7f774de306f14\",\n    associated_domains=[\"yourdomain.com\"],\n    sso_debug_enabled=True,\n    status=\"ACTIVE\")\nidentitty_provider = identity_provider.id.apply(lambda id: mongodbatlas.get_federated_settings_identity_providers_output(federation_settings_id=id,\n    page_num=1,\n    items_per_page=5))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var identityProvider = new Mongodbatlas.FederatedSettingsIdentityProvider(\"identityProvider\", new()\n    {\n        FederationSettingsId = \"627a9687f7f7f7f774de306f14\",\n        AssociatedDomains = new[]\n        {\n            \"yourdomain.com\",\n        },\n        SsoDebugEnabled = true,\n        Status = \"ACTIVE\",\n    });\n\n    var identittyProvider = Mongodbatlas.GetFederatedSettingsIdentityProviders.Invoke(new()\n    {\n        FederationSettingsId = identityProvider.Id,\n        PageNum = 1,\n        ItemsPerPage = 5,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tidentityProvider, err := mongodbatlas.NewFederatedSettingsIdentityProvider(ctx, \"identityProvider\", \u0026mongodbatlas.FederatedSettingsIdentityProviderArgs{\n\t\t\tFederationSettingsId: pulumi.String(\"627a9687f7f7f7f774de306f14\"),\n\t\t\tAssociatedDomains: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"yourdomain.com\"),\n\t\t\t},\n\t\t\tSsoDebugEnabled: pulumi.Bool(true),\n\t\t\tStatus:          pulumi.String(\"ACTIVE\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = identityProvider.ID().ApplyT(func(id string) (mongodbatlas.GetFederatedSettingsIdentityProvidersResult, error) {\n\t\t\treturn mongodbatlas.LookupFederatedSettingsIdentityProvidersOutput(ctx, mongodbatlas.GetFederatedSettingsIdentityProvidersOutputArgs{\n\t\t\t\tFederationSettingsId: id,\n\t\t\t\tPageNum:              1,\n\t\t\t\tItemsPerPage:         5,\n\t\t\t}, nil), nil\n\t\t}).(mongodbatlas.GetFederatedSettingsIdentityProvidersResultOutput)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.FederatedSettingsIdentityProvider;\nimport com.pulumi.mongodbatlas.FederatedSettingsIdentityProviderArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetFederatedSettingsIdentityProvidersArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var identityProvider = new FederatedSettingsIdentityProvider(\"identityProvider\", FederatedSettingsIdentityProviderArgs.builder()        \n            .federationSettingsId(\"627a9687f7f7f7f774de306f14\")\n            .associatedDomains(\"yourdomain.com\")\n            .ssoDebugEnabled(true)\n            .status(\"ACTIVE\")\n            .build());\n\n        final var identittyProvider = MongodbatlasFunctions.getFederatedSettingsIdentityProviders(GetFederatedSettingsIdentityProvidersArgs.builder()\n            .federationSettingsId(identityProvider.id())\n            .pageNum(1)\n            .itemsPerPage(5)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  identityProvider:\n    type: mongodbatlas:FederatedSettingsIdentityProvider\n    properties:\n      federationSettingsId: 627a9687f7f7f7f774de306f14\n      associatedDomains:\n        - yourdomain.com\n      ssoDebugEnabled: true\n      status: ACTIVE\nvariables:\n  identittyProvider:\n    fn::invoke:\n      Function: mongodbatlas:getFederatedSettingsIdentityProviders\n      Arguments:\n        federationSettingsId: ${identityProvider.id}\n        pageNum: 1\n        itemsPerPage: 5\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getFederatedSettingsIdentityProviders.\n",
                "properties": {
                    "federationSettingsId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer",
                        "description": "Number of items to return per page, up to a maximum of 500. Defaults to `100`.\n"
                    },
                    "pageNum": {
                        "type": "integer",
                        "description": "The page to return. Defaults to `1`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "federationSettingsId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getFederatedSettingsIdentityProviders.\n",
                "properties": {
                    "federationSettingsId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "results": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getFederatedSettingsIdentityProvidersResult:getFederatedSettingsIdentityProvidersResult"
                        },
                        "description": "Includes cloudProviderSnapshot object for each item detailed in the results array section.\n"
                    }
                },
                "type": "object",
                "required": [
                    "federationSettingsId",
                    "results",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getFederatedSettingsOrgConfig:getFederatedSettingsOrgConfig": {
            "description": "`mongodbatlas.FederatedSettingsOrgConfig` provides an Federated Settings Identity Providers datasource. Atlas Cloud Federated Settings Organizational configuration provides federated settings outputs for the configured Organizational configuration.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst orgConnections = new mongodbatlas.FederatedSettingsOrgConfig(\"orgConnections\", {\n    federationSettingsId: \"627a9687f7f7f7f774de306f14\",\n    orgId: \"627a9683ea7ff7f74de306f14\",\n    domainRestrictionEnabled: false,\n    domainAllowLists: [\"mydomain.com\"],\n    postAuthRoleGrants: [\"ORG_MEMBER\"],\n});\nconst orgConfigsDs = mongodbatlas.getFederatedSettingsOrgConfigOutput({\n    federationSettingsId: orgConnections.id,\n    orgId: \"627a9683ea7ff7f74de306f14\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\norg_connections = mongodbatlas.FederatedSettingsOrgConfig(\"orgConnections\",\n    federation_settings_id=\"627a9687f7f7f7f774de306f14\",\n    org_id=\"627a9683ea7ff7f74de306f14\",\n    domain_restriction_enabled=False,\n    domain_allow_lists=[\"mydomain.com\"],\n    post_auth_role_grants=[\"ORG_MEMBER\"])\norg_configs_ds = mongodbatlas.get_federated_settings_org_config_output(federation_settings_id=org_connections.id,\n    org_id=\"627a9683ea7ff7f74de306f14\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var orgConnections = new Mongodbatlas.FederatedSettingsOrgConfig(\"orgConnections\", new()\n    {\n        FederationSettingsId = \"627a9687f7f7f7f774de306f14\",\n        OrgId = \"627a9683ea7ff7f74de306f14\",\n        DomainRestrictionEnabled = false,\n        DomainAllowLists = new[]\n        {\n            \"mydomain.com\",\n        },\n        PostAuthRoleGrants = new[]\n        {\n            \"ORG_MEMBER\",\n        },\n    });\n\n    var orgConfigsDs = Mongodbatlas.GetFederatedSettingsOrgConfig.Invoke(new()\n    {\n        FederationSettingsId = orgConnections.Id,\n        OrgId = \"627a9683ea7ff7f74de306f14\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\torgConnections, err := mongodbatlas.NewFederatedSettingsOrgConfig(ctx, \"orgConnections\", \u0026mongodbatlas.FederatedSettingsOrgConfigArgs{\n\t\t\tFederationSettingsId:     pulumi.String(\"627a9687f7f7f7f774de306f14\"),\n\t\t\tOrgId:                    pulumi.String(\"627a9683ea7ff7f74de306f14\"),\n\t\t\tDomainRestrictionEnabled: pulumi.Bool(false),\n\t\t\tDomainAllowLists: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"mydomain.com\"),\n\t\t\t},\n\t\t\tPostAuthRoleGrants: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"ORG_MEMBER\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupFederatedSettingsOrgConfigOutput(ctx, mongodbatlas.GetFederatedSettingsOrgConfigOutputArgs{\n\t\t\tFederationSettingsId: orgConnections.ID(),\n\t\t\tOrgId:                pulumi.String(\"627a9683ea7ff7f74de306f14\"),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.FederatedSettingsOrgConfig;\nimport com.pulumi.mongodbatlas.FederatedSettingsOrgConfigArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetFederatedSettingsOrgConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var orgConnections = new FederatedSettingsOrgConfig(\"orgConnections\", FederatedSettingsOrgConfigArgs.builder()        \n            .federationSettingsId(\"627a9687f7f7f7f774de306f14\")\n            .orgId(\"627a9683ea7ff7f74de306f14\")\n            .domainRestrictionEnabled(false)\n            .domainAllowLists(\"mydomain.com\")\n            .postAuthRoleGrants(\"ORG_MEMBER\")\n            .build());\n\n        final var orgConfigsDs = MongodbatlasFunctions.getFederatedSettingsOrgConfig(GetFederatedSettingsOrgConfigArgs.builder()\n            .federationSettingsId(orgConnections.id())\n            .orgId(\"627a9683ea7ff7f74de306f14\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  orgConnections:\n    type: mongodbatlas:FederatedSettingsOrgConfig\n    properties:\n      federationSettingsId: 627a9687f7f7f7f774de306f14\n      orgId: 627a9683ea7ff7f74de306f14\n      domainRestrictionEnabled: false\n      domainAllowLists:\n        - mydomain.com\n      postAuthRoleGrants:\n        - ORG_MEMBER\nvariables:\n  orgConfigsDs:\n    fn::invoke:\n      Function: mongodbatlas:getFederatedSettingsOrgConfig\n      Arguments:\n        federationSettingsId: ${orgConnections.id}\n        orgId: 627a9683ea7ff7f74de306f14\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getFederatedSettingsOrgConfig.\n",
                "properties": {
                    "federationSettingsId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                    }
                },
                "type": "object",
                "required": [
                    "federationSettingsId",
                    "orgId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getFederatedSettingsOrgConfig.\n",
                "properties": {
                    "domainAllowLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List that contains the approved domains from which organization users can log in.  Note: If the organization uses an identity provider,  `domain_allow_list` includes: any SSO domains associated with organization's identity provider and any custom domains associated with the specific organization.\n"
                    },
                    "domainRestrictionEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether domain restriction is enabled for the connected organization.  User Conflicts returns null when `domain_restriction_enabled` is false.\n"
                    },
                    "federationSettingsId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "identityProviderId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "postAuthRoleGrants": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List that contains the default [roles](https://www.mongodb.com/docs/atlas/reference/user-roles/#std-label-organization-roles) granted to users who authenticate through the IdP in a connected organization.\n"
                    },
                    "roleMappings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getFederatedSettingsOrgConfigRoleMapping:getFederatedSettingsOrgConfigRoleMapping"
                        }
                    },
                    "userConflicts": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getFederatedSettingsOrgConfigUserConflict:getFederatedSettingsOrgConfigUserConflict"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "domainAllowLists",
                    "domainRestrictionEnabled",
                    "federationSettingsId",
                    "identityProviderId",
                    "orgId",
                    "postAuthRoleGrants",
                    "roleMappings",
                    "userConflicts",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getFederatedSettingsOrgConfigs:getFederatedSettingsOrgConfigs": {
            "description": "`mongodbatlas.getFederatedSettingsOrgConfigs` provides an Federated Settings Identity Providers datasource. Atlas Cloud Federated Settings Identity Providers provides federated settings outputs for the configured Identity Providers.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst orgConnections = new mongodbatlas.FederatedSettingsOrgConfig(\"orgConnections\", {\n    federationSettingsId: \"627a9687f7f7f7f774de306f14\",\n    orgId: \"627a9683ea7ff7f74de306f14\",\n    domainRestrictionEnabled: false,\n    domainAllowLists: [\"mydomain.com\"],\n    postAuthRoleGrants: [\"ORG_MEMBER\"],\n});\nconst orgConfigsDs = mongodbatlas.getFederatedSettingsOrgConfigsOutput({\n    federationSettingsId: orgConnections.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\norg_connections = mongodbatlas.FederatedSettingsOrgConfig(\"orgConnections\",\n    federation_settings_id=\"627a9687f7f7f7f774de306f14\",\n    org_id=\"627a9683ea7ff7f74de306f14\",\n    domain_restriction_enabled=False,\n    domain_allow_lists=[\"mydomain.com\"],\n    post_auth_role_grants=[\"ORG_MEMBER\"])\norg_configs_ds = mongodbatlas.get_federated_settings_org_configs_output(federation_settings_id=org_connections.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var orgConnections = new Mongodbatlas.FederatedSettingsOrgConfig(\"orgConnections\", new()\n    {\n        FederationSettingsId = \"627a9687f7f7f7f774de306f14\",\n        OrgId = \"627a9683ea7ff7f74de306f14\",\n        DomainRestrictionEnabled = false,\n        DomainAllowLists = new[]\n        {\n            \"mydomain.com\",\n        },\n        PostAuthRoleGrants = new[]\n        {\n            \"ORG_MEMBER\",\n        },\n    });\n\n    var orgConfigsDs = Mongodbatlas.GetFederatedSettingsOrgConfigs.Invoke(new()\n    {\n        FederationSettingsId = orgConnections.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\torgConnections, err := mongodbatlas.NewFederatedSettingsOrgConfig(ctx, \"orgConnections\", \u0026mongodbatlas.FederatedSettingsOrgConfigArgs{\n\t\t\tFederationSettingsId:     pulumi.String(\"627a9687f7f7f7f774de306f14\"),\n\t\t\tOrgId:                    pulumi.String(\"627a9683ea7ff7f74de306f14\"),\n\t\t\tDomainRestrictionEnabled: pulumi.Bool(false),\n\t\t\tDomainAllowLists: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"mydomain.com\"),\n\t\t\t},\n\t\t\tPostAuthRoleGrants: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"ORG_MEMBER\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupFederatedSettingsOrgConfigsOutput(ctx, mongodbatlas.GetFederatedSettingsOrgConfigsOutputArgs{\n\t\t\tFederationSettingsId: orgConnections.ID(),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.FederatedSettingsOrgConfig;\nimport com.pulumi.mongodbatlas.FederatedSettingsOrgConfigArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetFederatedSettingsOrgConfigsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var orgConnections = new FederatedSettingsOrgConfig(\"orgConnections\", FederatedSettingsOrgConfigArgs.builder()        \n            .federationSettingsId(\"627a9687f7f7f7f774de306f14\")\n            .orgId(\"627a9683ea7ff7f74de306f14\")\n            .domainRestrictionEnabled(false)\n            .domainAllowLists(\"mydomain.com\")\n            .postAuthRoleGrants(\"ORG_MEMBER\")\n            .build());\n\n        final var orgConfigsDs = MongodbatlasFunctions.getFederatedSettingsOrgConfigs(GetFederatedSettingsOrgConfigsArgs.builder()\n            .federationSettingsId(orgConnections.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  orgConnections:\n    type: mongodbatlas:FederatedSettingsOrgConfig\n    properties:\n      federationSettingsId: 627a9687f7f7f7f774de306f14\n      orgId: 627a9683ea7ff7f74de306f14\n      domainRestrictionEnabled: false\n      domainAllowLists:\n        - mydomain.com\n      postAuthRoleGrants:\n        - ORG_MEMBER\nvariables:\n  orgConfigsDs:\n    fn::invoke:\n      Function: mongodbatlas:getFederatedSettingsOrgConfigs\n      Arguments:\n        federationSettingsId: ${orgConnections.id}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getFederatedSettingsOrgConfigs.\n",
                "properties": {
                    "federationSettingsId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer",
                        "description": "Number of items to return per page, up to a maximum of 500. Defaults to `100`.\n"
                    },
                    "pageNum": {
                        "type": "integer",
                        "description": "The page to return. Defaults to `1`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "federationSettingsId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getFederatedSettingsOrgConfigs.\n",
                "properties": {
                    "federationSettingsId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "results": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getFederatedSettingsOrgConfigsResult:getFederatedSettingsOrgConfigsResult"
                        },
                        "description": "Includes cloudProviderSnapshot object for each item detailed in the results array section.\n"
                    }
                },
                "type": "object",
                "required": [
                    "federationSettingsId",
                    "results",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getFederatedSettingsOrgRoleMapping:getFederatedSettingsOrgRoleMapping": {
            "description": "`mongodbatlas.FederatedSettingsOrgRoleMapping` provides an Federated Settings Org Role Mapping datasource. Atlas Cloud Federated Settings Org Role Mapping provides federated settings outputs for the configured Org Role Mapping.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst orgGroupRoleMappingImport = new mongodbatlas.FederatedSettingsOrgRoleMapping(\"orgGroupRoleMappingImport\", {\n    federationSettingsId: data.mongodbatlas_federated_settings.federated_settings.id,\n    orgId: \"627a9683e7f7f7ff7fe306f14\",\n    externalGroupName: \"myGrouptest\",\n    roleAssignments: [\n        {\n            orgId: \"627a9683e7f7f7ff7fe306f14\",\n            roles: [\n                \"ORG_MEMBER\",\n                \"ORG_GROUP_CREATOR\",\n                \"ORG_BILLING_ADMIN\",\n            ],\n        },\n        {\n            groupId: \"628aa20db7f7f7f98b81b8\",\n            roles: [\n                \"GROUP_OWNER\",\n                \"GROUP_DATA_ACCESS_ADMIN\",\n                \"GROUP_SEARCH_INDEX_EDITOR\",\n                \"GROUP_DATA_ACCESS_READ_ONLY\",\n            ],\n        },\n        {\n            groupId: \"62b477f7f7f7f5e741489c\",\n            roles: [\n                \"GROUP_OWNER\",\n                \"GROUP_DATA_ACCESS_ADMIN\",\n                \"GROUP_SEARCH_INDEX_EDITOR\",\n                \"GROUP_DATA_ACCESS_READ_ONLY\",\n                \"GROUP_DATA_ACCESS_READ_WRITE\",\n            ],\n        },\n    ],\n});\nconst roleMapping = mongodbatlas.getFederatedSettingsOrgRoleMappingOutput({\n    federationSettingsId: orgGroupRoleMappingImport.id,\n    orgId: \"627a9683e7f7f7ff7fe306f14\",\n    roleMappingId: \"627a9673e7f7f7ff7fe306f14\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\norg_group_role_mapping_import = mongodbatlas.FederatedSettingsOrgRoleMapping(\"orgGroupRoleMappingImport\",\n    federation_settings_id=data[\"mongodbatlas_federated_settings\"][\"federated_settings\"][\"id\"],\n    org_id=\"627a9683e7f7f7ff7fe306f14\",\n    external_group_name=\"myGrouptest\",\n    role_assignments=[\n        mongodbatlas.FederatedSettingsOrgRoleMappingRoleAssignmentArgs(\n            org_id=\"627a9683e7f7f7ff7fe306f14\",\n            roles=[\n                \"ORG_MEMBER\",\n                \"ORG_GROUP_CREATOR\",\n                \"ORG_BILLING_ADMIN\",\n            ],\n        ),\n        mongodbatlas.FederatedSettingsOrgRoleMappingRoleAssignmentArgs(\n            group_id=\"628aa20db7f7f7f98b81b8\",\n            roles=[\n                \"GROUP_OWNER\",\n                \"GROUP_DATA_ACCESS_ADMIN\",\n                \"GROUP_SEARCH_INDEX_EDITOR\",\n                \"GROUP_DATA_ACCESS_READ_ONLY\",\n            ],\n        ),\n        mongodbatlas.FederatedSettingsOrgRoleMappingRoleAssignmentArgs(\n            group_id=\"62b477f7f7f7f5e741489c\",\n            roles=[\n                \"GROUP_OWNER\",\n                \"GROUP_DATA_ACCESS_ADMIN\",\n                \"GROUP_SEARCH_INDEX_EDITOR\",\n                \"GROUP_DATA_ACCESS_READ_ONLY\",\n                \"GROUP_DATA_ACCESS_READ_WRITE\",\n            ],\n        ),\n    ])\nrole_mapping = mongodbatlas.get_federated_settings_org_role_mapping_output(federation_settings_id=org_group_role_mapping_import.id,\n    org_id=\"627a9683e7f7f7ff7fe306f14\",\n    role_mapping_id=\"627a9673e7f7f7ff7fe306f14\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var orgGroupRoleMappingImport = new Mongodbatlas.FederatedSettingsOrgRoleMapping(\"orgGroupRoleMappingImport\", new()\n    {\n        FederationSettingsId = data.Mongodbatlas_federated_settings.Federated_settings.Id,\n        OrgId = \"627a9683e7f7f7ff7fe306f14\",\n        ExternalGroupName = \"myGrouptest\",\n        RoleAssignments = new[]\n        {\n            new Mongodbatlas.Inputs.FederatedSettingsOrgRoleMappingRoleAssignmentArgs\n            {\n                OrgId = \"627a9683e7f7f7ff7fe306f14\",\n                Roles = new[]\n                {\n                    \"ORG_MEMBER\",\n                    \"ORG_GROUP_CREATOR\",\n                    \"ORG_BILLING_ADMIN\",\n                },\n            },\n            new Mongodbatlas.Inputs.FederatedSettingsOrgRoleMappingRoleAssignmentArgs\n            {\n                GroupId = \"628aa20db7f7f7f98b81b8\",\n                Roles = new[]\n                {\n                    \"GROUP_OWNER\",\n                    \"GROUP_DATA_ACCESS_ADMIN\",\n                    \"GROUP_SEARCH_INDEX_EDITOR\",\n                    \"GROUP_DATA_ACCESS_READ_ONLY\",\n                },\n            },\n            new Mongodbatlas.Inputs.FederatedSettingsOrgRoleMappingRoleAssignmentArgs\n            {\n                GroupId = \"62b477f7f7f7f5e741489c\",\n                Roles = new[]\n                {\n                    \"GROUP_OWNER\",\n                    \"GROUP_DATA_ACCESS_ADMIN\",\n                    \"GROUP_SEARCH_INDEX_EDITOR\",\n                    \"GROUP_DATA_ACCESS_READ_ONLY\",\n                    \"GROUP_DATA_ACCESS_READ_WRITE\",\n                },\n            },\n        },\n    });\n\n    var roleMapping = Mongodbatlas.GetFederatedSettingsOrgRoleMapping.Invoke(new()\n    {\n        FederationSettingsId = orgGroupRoleMappingImport.Id,\n        OrgId = \"627a9683e7f7f7ff7fe306f14\",\n        RoleMappingId = \"627a9673e7f7f7ff7fe306f14\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\torgGroupRoleMappingImport, err := mongodbatlas.NewFederatedSettingsOrgRoleMapping(ctx, \"orgGroupRoleMappingImport\", \u0026mongodbatlas.FederatedSettingsOrgRoleMappingArgs{\n\t\t\tFederationSettingsId: pulumi.Any(data.Mongodbatlas_federated_settings.Federated_settings.Id),\n\t\t\tOrgId:                pulumi.String(\"627a9683e7f7f7ff7fe306f14\"),\n\t\t\tExternalGroupName:    pulumi.String(\"myGrouptest\"),\n\t\t\tRoleAssignments: mongodbatlas.FederatedSettingsOrgRoleMappingRoleAssignmentArray{\n\t\t\t\t\u0026mongodbatlas.FederatedSettingsOrgRoleMappingRoleAssignmentArgs{\n\t\t\t\t\tOrgId: pulumi.String(\"627a9683e7f7f7ff7fe306f14\"),\n\t\t\t\t\tRoles: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"ORG_MEMBER\"),\n\t\t\t\t\t\tpulumi.String(\"ORG_GROUP_CREATOR\"),\n\t\t\t\t\t\tpulumi.String(\"ORG_BILLING_ADMIN\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.FederatedSettingsOrgRoleMappingRoleAssignmentArgs{\n\t\t\t\t\tGroupId: pulumi.String(\"628aa20db7f7f7f98b81b8\"),\n\t\t\t\t\tRoles: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_OWNER\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_ADMIN\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_SEARCH_INDEX_EDITOR\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_READ_ONLY\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.FederatedSettingsOrgRoleMappingRoleAssignmentArgs{\n\t\t\t\t\tGroupId: pulumi.String(\"62b477f7f7f7f5e741489c\"),\n\t\t\t\t\tRoles: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_OWNER\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_ADMIN\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_SEARCH_INDEX_EDITOR\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_READ_ONLY\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_READ_WRITE\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupFederatedSettingsOrgRoleMappingOutput(ctx, mongodbatlas.GetFederatedSettingsOrgRoleMappingOutputArgs{\n\t\t\tFederationSettingsId: orgGroupRoleMappingImport.ID(),\n\t\t\tOrgId:                pulumi.String(\"627a9683e7f7f7ff7fe306f14\"),\n\t\t\tRoleMappingId:        pulumi.String(\"627a9673e7f7f7ff7fe306f14\"),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.FederatedSettingsOrgRoleMapping;\nimport com.pulumi.mongodbatlas.FederatedSettingsOrgRoleMappingArgs;\nimport com.pulumi.mongodbatlas.inputs.FederatedSettingsOrgRoleMappingRoleAssignmentArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetFederatedSettingsOrgRoleMappingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var orgGroupRoleMappingImport = new FederatedSettingsOrgRoleMapping(\"orgGroupRoleMappingImport\", FederatedSettingsOrgRoleMappingArgs.builder()        \n            .federationSettingsId(data.mongodbatlas_federated_settings().federated_settings().id())\n            .orgId(\"627a9683e7f7f7ff7fe306f14\")\n            .externalGroupName(\"myGrouptest\")\n            .roleAssignments(            \n                FederatedSettingsOrgRoleMappingRoleAssignmentArgs.builder()\n                    .orgId(\"627a9683e7f7f7ff7fe306f14\")\n                    .roles(                    \n                        \"ORG_MEMBER\",\n                        \"ORG_GROUP_CREATOR\",\n                        \"ORG_BILLING_ADMIN\")\n                    .build(),\n                FederatedSettingsOrgRoleMappingRoleAssignmentArgs.builder()\n                    .groupId(\"628aa20db7f7f7f98b81b8\")\n                    .roles(                    \n                        \"GROUP_OWNER\",\n                        \"GROUP_DATA_ACCESS_ADMIN\",\n                        \"GROUP_SEARCH_INDEX_EDITOR\",\n                        \"GROUP_DATA_ACCESS_READ_ONLY\")\n                    .build(),\n                FederatedSettingsOrgRoleMappingRoleAssignmentArgs.builder()\n                    .groupId(\"62b477f7f7f7f5e741489c\")\n                    .roles(                    \n                        \"GROUP_OWNER\",\n                        \"GROUP_DATA_ACCESS_ADMIN\",\n                        \"GROUP_SEARCH_INDEX_EDITOR\",\n                        \"GROUP_DATA_ACCESS_READ_ONLY\",\n                        \"GROUP_DATA_ACCESS_READ_WRITE\")\n                    .build())\n            .build());\n\n        final var roleMapping = MongodbatlasFunctions.getFederatedSettingsOrgRoleMapping(GetFederatedSettingsOrgRoleMappingArgs.builder()\n            .federationSettingsId(orgGroupRoleMappingImport.id())\n            .orgId(\"627a9683e7f7f7ff7fe306f14\")\n            .roleMappingId(\"627a9673e7f7f7ff7fe306f14\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  orgGroupRoleMappingImport:\n    type: mongodbatlas:FederatedSettingsOrgRoleMapping\n    properties:\n      federationSettingsId: ${data.mongodbatlas_federated_settings.federated_settings.id}\n      orgId: 627a9683e7f7f7ff7fe306f14\n      externalGroupName: myGrouptest\n      roleAssignments:\n        - orgId: 627a9683e7f7f7ff7fe306f14\n          roles:\n            - ORG_MEMBER\n            - ORG_GROUP_CREATOR\n            - ORG_BILLING_ADMIN\n        - groupId: 628aa20db7f7f7f98b81b8\n          roles:\n            - GROUP_OWNER\n            - GROUP_DATA_ACCESS_ADMIN\n            - GROUP_SEARCH_INDEX_EDITOR\n            - GROUP_DATA_ACCESS_READ_ONLY\n        - groupId: 62b477f7f7f7f5e741489c\n          roles:\n            - GROUP_OWNER\n            - GROUP_DATA_ACCESS_ADMIN\n            - GROUP_SEARCH_INDEX_EDITOR\n            - GROUP_DATA_ACCESS_READ_ONLY\n            - GROUP_DATA_ACCESS_READ_WRITE\nvariables:\n  roleMapping:\n    fn::invoke:\n      Function: mongodbatlas:getFederatedSettingsOrgRoleMapping\n      Arguments:\n        federationSettingsId: ${orgGroupRoleMappingImport.id}\n        orgId: 627a9683e7f7f7ff7fe306f14\n        roleMappingId: 627a9673e7f7f7ff7fe306f14\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getFederatedSettingsOrgRoleMapping.\n",
                "properties": {
                    "federationSettingsId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                    },
                    "roleMappingId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "federationSettingsId",
                    "orgId",
                    "roleMappingId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getFederatedSettingsOrgRoleMapping.\n",
                "properties": {
                    "externalGroupName": {
                        "type": "string",
                        "description": "Unique human-readable label that identifies the identity provider group to which this role mapping applies.\n"
                    },
                    "federationSettingsId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies this role mapping.\n"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "roleAssignments": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getFederatedSettingsOrgRoleMappingRoleAssignment:getFederatedSettingsOrgRoleMappingRoleAssignment"
                        },
                        "description": "Atlas roles and the unique identifiers of the groups and organizations associated with each role.\n"
                    },
                    "roleMappingId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "externalGroupName",
                    "federationSettingsId",
                    "id",
                    "orgId",
                    "roleAssignments",
                    "roleMappingId"
                ]
            }
        },
        "mongodbatlas:index/getFederatedSettingsOrgRoleMappings:getFederatedSettingsOrgRoleMappings": {
            "description": "`mongodbatlas.getFederatedSettingsOrgRoleMappings` provides an Federated Settings Org Role Mapping datasource. Atlas Cloud Federated Settings Org Role Mapping provides federated settings outputs for the configured Org Role Mapping.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.FederatedSettingsOrgRoleMapping;\nimport com.pulumi.mongodbatlas.FederatedSettingsOrgRoleMappingArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetFederatedSettingsOrgRoleMappingsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var orgGroupRoleMappingImport = new FederatedSettingsOrgRoleMapping(\"orgGroupRoleMappingImport\", FederatedSettingsOrgRoleMappingArgs.builder()        \n            .federationSettingsId(\"\")\n            .orgId(\"627a9683e7f7f7ff7fe306f14\")\n            .groupId(\"628aa20d7f7f7f7f7098b81b8\")\n            .externalGroupName(\"myGrouptest\")\n            .organizationRoles(            \n                \"ORG_OWNER\",\n                \"ORG_MEMBER\",\n                \"ORG_BILLING_ADMIN\",\n                \"ORG_GROUP_CREATOR\",\n                \"ORG_READ_ONLY\")\n            .groupRoles(            \n                \"GROUP_OWNER\",\n                \"GROUP_CLUSTER_MANAGER\",\n                \"GROUP_DATA_ACCESS_ADMIN\",\n                \"GROUP_DATA_ACCESS_READ_WRITE\",\n                \"GROUP_SEARCH_INDEX_EDITOR\",\n                \"GROUP_DATA_ACCESS_READ_ONLY\",\n                \"GROUP_READ_ONLY\")\n            .build());\n\n        final var roleMappings = MongodbatlasFunctions.getFederatedSettingsOrgRoleMappings(GetFederatedSettingsOrgRoleMappingsArgs.builder()\n            .federationSettingsId(orgGroupRoleMappingImport.id())\n            .orgId(\"627a9683e7f7f7ff7fe306f14\")\n            .pageNum(1)\n            .itemsPerPage(5)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  orgGroupRoleMappingImport:\n    type: mongodbatlas:FederatedSettingsOrgRoleMapping\n    properties:\n      federationSettingsId:\n      orgId: 627a9683e7f7f7ff7fe306f14\n      groupId: 628aa20d7f7f7f7f7098b81b8\n      externalGroupName: myGrouptest\n      organizationRoles:\n        - ORG_OWNER\n        - ORG_MEMBER\n        - ORG_BILLING_ADMIN\n        - ORG_GROUP_CREATOR\n        - ORG_READ_ONLY\n      groupRoles:\n        - GROUP_OWNER\n        - GROUP_CLUSTER_MANAGER\n        - GROUP_DATA_ACCESS_ADMIN\n        - GROUP_DATA_ACCESS_READ_WRITE\n        - GROUP_SEARCH_INDEX_EDITOR\n        - GROUP_DATA_ACCESS_READ_ONLY\n        - GROUP_READ_ONLY\nvariables:\n  roleMappings:\n    fn::invoke:\n      Function: mongodbatlas:getFederatedSettingsOrgRoleMappings\n      Arguments:\n        federationSettingsId: ${orgGroupRoleMappingImport.id}\n        orgId: 627a9683e7f7f7ff7fe306f14\n        pageNum: 1\n        itemsPerPage: 5\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getFederatedSettingsOrgRoleMappings.\n",
                "properties": {
                    "federationSettingsId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer",
                        "description": "Number of items to return per page, up to a maximum of 500. Defaults to `100`.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                    },
                    "pageNum": {
                        "type": "integer",
                        "description": "The page to return. Defaults to `1`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "federationSettingsId",
                    "orgId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getFederatedSettingsOrgRoleMappings.\n",
                "properties": {
                    "federationSettingsId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "results": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getFederatedSettingsOrgRoleMappingsResult:getFederatedSettingsOrgRoleMappingsResult"
                        },
                        "description": "Includes cloudProviderSnapshot object for each item detailed in the results array section.\n"
                    }
                },
                "type": "object",
                "required": [
                    "federationSettingsId",
                    "orgId",
                    "results",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getGlobalClusterConfig:getGlobalClusterConfig": {
            "description": "`mongodbatlas.GlobalClusterConfig` describes all managed namespaces and custom zone mappings associated with the specified Global Cluster.\n\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGlobalClusterConfig.\n",
                "properties": {
                    "clusterName": {
                        "type": "string"
                    },
                    "managedNamespaces": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getGlobalClusterConfigManagedNamespace:getGlobalClusterConfigManagedNamespace"
                        },
                        "description": "Add a managed namespaces to a Global Cluster. For more information about managed namespaces, see [Global Clusters](https://docs.atlas.mongodb.com/reference/api/global-clusters/). See Managed Namespace below for more details.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the database user.\n* `cluster_name - (Required) The name of the Global Cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGlobalClusterConfig.\n",
                "properties": {
                    "clusterName": {
                        "type": "string"
                    },
                    "customZoneMapping": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "A map of all custom zone mappings defined for the Global Cluster. Atlas automatically maps each location code to the closest geographical zone. Custom zone mappings allow administrators to override these automatic mappings. If your Global Cluster does not have any custom zone mappings, this document is empty.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "managedNamespaces": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getGlobalClusterConfigManagedNamespace:getGlobalClusterConfigManagedNamespace"
                        },
                        "description": "Add a managed namespaces to a Global Cluster. For more information about managed namespaces, see [Global Clusters](https://docs.atlas.mongodb.com/reference/api/global-clusters/). See Managed Namespace below for more details.\n"
                    },
                    "projectId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "customZoneMapping",
                    "managedNamespaces",
                    "projectId",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getLdapConfiguration:getLdapConfiguration": {
            "description": "`mongodbatlas.LdapConfiguration` describes a LDAP Configuration.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find **group_id** in the official documentation.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getLdapConfiguration.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "Identifier for the Atlas project associated with the LDAP over TLS/SSL configuration.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getLdapConfiguration.\n",
                "properties": {
                    "authenticationEnabled": {
                        "type": "boolean",
                        "description": "Specifies whether user authentication with LDAP is enabled.\n"
                    },
                    "authorizationEnabled": {
                        "type": "boolean",
                        "description": "Specifies whether user authorization with LDAP is enabled.\n"
                    },
                    "authzQueryTemplate": {
                        "type": "string",
                        "description": "An LDAP query template that Atlas executes to obtain the LDAP groups to which the authenticated user belongs.\n"
                    },
                    "bindPassword": {
                        "type": "string",
                        "description": "The password used to authenticate the `bind_username`.\n"
                    },
                    "bindUsername": {
                        "type": "string",
                        "description": "The user DN that Atlas uses to connect to the LDAP server.\n"
                    },
                    "caCertificate": {
                        "type": "string",
                        "description": "CA certificate used to verify the identify of the LDAP server.\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "(Required) The hostname or IP address of the LDAP server.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "port": {
                        "type": "integer",
                        "description": "The port to which the LDAP server listens for client connections.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "userToDnMappings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getLdapConfigurationUserToDnMapping:getLdapConfigurationUserToDnMapping"
                        },
                        "description": "Maps an LDAP username for authentication to an LDAP Distinguished Name (DN).\n* `user_to_dn_mapping.0.match` - A regular expression to match against a provided LDAP username.\n* `user_to_dn_mapping.0.substitution` - An LDAP Distinguished Name (DN) formatting template that converts the LDAP name matched by the `match` regular expression into an LDAP Distinguished Name.\n* `user_to_dn_mapping.0.ldap_query` - An LDAP query formatting template that inserts the LDAP name matched by the `match` regular expression into an LDAP query URI as specified by RFC 4515 and RFC 4516.\n"
                    }
                },
                "type": "object",
                "required": [
                    "authenticationEnabled",
                    "authorizationEnabled",
                    "authzQueryTemplate",
                    "bindPassword",
                    "bindUsername",
                    "caCertificate",
                    "hostname",
                    "port",
                    "projectId",
                    "userToDnMappings",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getLdapVerify:getLdapVerify": {
            "description": "`mongodbatlas.LdapVerify` describes a LDAP Verify.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find **group_id** in the official documentation.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getLdapVerify.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "Unique identifier for the Atlas project associated with the verification request.\n"
                    },
                    "requestId": {
                        "type": "string",
                        "description": "Unique identifier of a request to verify an LDAP configuration.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId",
                    "requestId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getLdapVerify.\n",
                "properties": {
                    "bindUsername": {
                        "type": "string",
                        "description": "The user DN that Atlas uses to connect to the LDAP server.\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "(Required) The hostname or IP address of the LDAP server.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "links": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getLdapVerifyLink:getLdapVerifyLink"
                        },
                        "description": "One or more links to sub-resources. The relations in the URLs are explained in the Web Linking Specification.\n"
                    },
                    "port": {
                        "type": "integer",
                        "description": "LDAP ConfigurationThe port to which the LDAP server listens for client connections.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "requestId": {
                        "type": "string",
                        "description": "The unique identifier for the request to verify the LDAP over TLS/SSL configuration.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "The current status of the LDAP over TLS/SSL configuration.\n"
                    },
                    "validations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getLdapVerifyValidation:getLdapVerifyValidation"
                        },
                        "description": "Array of validation messages related to the verification of the provided LDAP over TLS/SSL configuration details.\n"
                    }
                },
                "type": "object",
                "required": [
                    "bindUsername",
                    "hostname",
                    "links",
                    "port",
                    "projectId",
                    "requestId",
                    "status",
                    "validations",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getMaintenanceWindow:getMaintenanceWindow": {
            "description": "`mongodbatlas.MaintenanceWindow` provides a Maintenance Window entry datasource. Gets information regarding the configured maintenance window for a MongoDB Atlas project.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getMaintenanceWindow.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Maintenance Window.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getMaintenanceWindow.\n",
                "properties": {
                    "autoDeferOnceEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether you want to defer all maintenance windows one week they would be triggered.\nFor more information see: [MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/maintenance-windows/)\n"
                    },
                    "dayOfWeek": {
                        "type": "integer",
                        "description": "Day of the week when you would like the maintenance window to start as a 1-based integer: S=1, M=2, T=3, W=4, T=5, F=6, S=7.\n"
                    },
                    "hourOfDay": {
                        "type": "integer",
                        "description": "Hour of the day when you would like the maintenance window to start. This parameter uses the 24-hour clock, where midnight is 0, noon is 12  (Time zone is UTC).\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "numberOfDeferrals": {
                        "type": "integer",
                        "description": "Number of times the current maintenance event for this project has been deferred, you can set a maximum of 2 deferrals.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "startAsap": {
                        "type": "boolean",
                        "description": "Flag indicating whether project maintenance has been directed to start immediately. If you request that maintenance begin immediately, this field returns true from the time the request was made until the time the maintenance event completes.\n"
                    }
                },
                "type": "object",
                "required": [
                    "autoDeferOnceEnabled",
                    "dayOfWeek",
                    "hourOfDay",
                    "numberOfDeferrals",
                    "projectId",
                    "startAsap",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getNetworkContainer:getNetworkContainer": {
            "description": "`mongodbatlas.NetworkContainer` describes a Network Peering Container. The resource requires your Project ID and container ID.\n\n\u003e **IMPORTANT:** This resource creates one Network Peering container into which Atlas can deploy Network Peering connections. An Atlas project can have a maximum of one container for each cloud provider. You must have either the Project Owner or Organization Owner role to successfully call this endpoint.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find **group_id** in the official documentation.\n\n\n{{% examples %}}\n## Example Usage\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getNetworkContainer.\n",
                "properties": {
                    "containerId": {
                        "type": "string",
                        "description": "The Network Peering Container ID.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the database user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "containerId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNetworkContainer.\n",
                "properties": {
                    "atlasCidrBlock": {
                        "type": "string",
                        "description": "CIDR block that Atlas uses for your clusters. Atlas uses the specified CIDR block for all other Network Peering connections created in the project. The Atlas CIDR block must be at least a /24 and at most a /21 in one of the following [private networks](https://tools.ietf.org/html/rfc1918.html#section-3).\n"
                    },
                    "azureSubscriptionId": {
                        "type": "string",
                        "description": "Unique identifer of the Azure subscription in which the VNet resides.\n"
                    },
                    "containerId": {
                        "type": "string"
                    },
                    "gcpProjectId": {
                        "type": "string",
                        "description": "Unique identifier of the GCP project in which the Network Peering connection resides.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "networkName": {
                        "type": "string",
                        "description": "Name of the Network Peering connection in the Atlas project.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "providerName": {
                        "type": "string",
                        "description": "Cloud provider for this Network Peering connection. If omitted, Atlas sets this parameter to AWS.\n"
                    },
                    "provisioned": {
                        "type": "boolean",
                        "description": "Indicates whether the project has Network Peering connections deployed in the container.\n"
                    },
                    "region": {
                        "type": "string",
                        "description": "The Atlas Azure region name for where this container will exist.\n"
                    },
                    "regionName": {
                        "type": "string",
                        "description": "The Atlas AWS region name for where this container will exist.\n"
                    },
                    "regions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Atlas GCP regions where the container resides.\n"
                    },
                    "vnetName": {
                        "type": "string",
                        "description": "The name of the Azure VNet. This value is null until you provision an Azure VNet in the container.\n"
                    },
                    "vpcId": {
                        "type": "string",
                        "description": "Unique identifier of the project’s VPC.\n"
                    }
                },
                "type": "object",
                "required": [
                    "atlasCidrBlock",
                    "azureSubscriptionId",
                    "containerId",
                    "gcpProjectId",
                    "networkName",
                    "projectId",
                    "providerName",
                    "provisioned",
                    "region",
                    "regionName",
                    "regions",
                    "vnetName",
                    "vpcId",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getNetworkContainers:getNetworkContainers": {
            "description": "`mongodbatlas.getNetworkContainers` describes all Network Peering Containers. The data source requires your Project ID.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find **group_id** in the official documentation.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Basic Example.\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testNetworkContainer = new mongodbatlas.NetworkContainer(\"testNetworkContainer\", {\n    projectId: \"\u003cYOUR-PROJECT-ID\u003e\",\n    atlasCidrBlock: \"10.8.0.0/21\",\n    providerName: \"AWS\",\n    regionName: \"US_EAST_1\",\n});\nconst testNetworkContainers = pulumi.all([testNetworkContainer.projectId, testNetworkContainer.providerName]).apply(([projectId, providerName]) =\u003e mongodbatlas.getNetworkContainersOutput({\n    projectId: projectId,\n    providerName: providerName,\n}));\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_network_container = mongodbatlas.NetworkContainer(\"testNetworkContainer\",\n    project_id=\"\u003cYOUR-PROJECT-ID\u003e\",\n    atlas_cidr_block=\"10.8.0.0/21\",\n    provider_name=\"AWS\",\n    region_name=\"US_EAST_1\")\ntest_network_containers = pulumi.Output.all(test_network_container.project_id, test_network_container.provider_name).apply(lambda project_id, provider_name: mongodbatlas.get_network_containers_output(project_id=project_id,\n    provider_name=provider_name))\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testNetworkContainer = new Mongodbatlas.NetworkContainer(\"testNetworkContainer\", new()\n    {\n        ProjectId = \"\u003cYOUR-PROJECT-ID\u003e\",\n        AtlasCidrBlock = \"10.8.0.0/21\",\n        ProviderName = \"AWS\",\n        RegionName = \"US_EAST_1\",\n    });\n\n    var testNetworkContainers = Mongodbatlas.GetNetworkContainers.Invoke(new()\n    {\n        ProjectId = testNetworkContainer.ProjectId,\n        ProviderName = testNetworkContainer.ProviderName,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestNetworkContainer, err := mongodbatlas.NewNetworkContainer(ctx, \"testNetworkContainer\", \u0026mongodbatlas.NetworkContainerArgs{\n\t\t\tProjectId:      pulumi.String(\"\u003cYOUR-PROJECT-ID\u003e\"),\n\t\t\tAtlasCidrBlock: pulumi.String(\"10.8.0.0/21\"),\n\t\t\tProviderName:   pulumi.String(\"AWS\"),\n\t\t\tRegionName:     pulumi.String(\"US_EAST_1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = pulumi.All(testNetworkContainer.ProjectId, testNetworkContainer.ProviderName).ApplyT(func(_args []interface{}) (mongodbatlas.GetNetworkContainersResult, error) {\n\t\t\tprojectId := _args[0].(string)\n\t\t\tproviderName := _args[1].(*string)\n\t\t\treturn mongodbatlas.LookupNetworkContainersOutput(ctx, mongodbatlas.GetNetworkContainersOutputArgs{\n\t\t\t\tProjectId:    projectId,\n\t\t\t\tProviderName: providerName,\n\t\t\t}, nil), nil\n\t\t}).(mongodbatlas.GetNetworkContainersResultOutput)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.NetworkContainer;\nimport com.pulumi.mongodbatlas.NetworkContainerArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetNetworkContainersArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testNetworkContainer = new NetworkContainer(\"testNetworkContainer\", NetworkContainerArgs.builder()        \n            .projectId(\"\u003cYOUR-PROJECT-ID\u003e\")\n            .atlasCidrBlock(\"10.8.0.0/21\")\n            .providerName(\"AWS\")\n            .regionName(\"US_EAST_1\")\n            .build());\n\n        final var testNetworkContainers = MongodbatlasFunctions.getNetworkContainers(GetNetworkContainersArgs.builder()\n            .projectId(testNetworkContainer.projectId())\n            .providerName(testNetworkContainer.providerName())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testNetworkContainer:\n    type: mongodbatlas:NetworkContainer\n    properties:\n      projectId: \u003cYOUR-PROJECT-ID\u003e\n      atlasCidrBlock: 10.8.0.0/21\n      providerName: AWS\n      regionName: US_EAST_1\nvariables:\n  testNetworkContainers:\n    fn::invoke:\n      Function: mongodbatlas:getNetworkContainers\n      Arguments:\n        projectId: ${testNetworkContainer.projectId}\n        providerName: ${testNetworkContainer.providerName}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getNetworkContainers.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the database user.\n"
                    },
                    "providerName": {
                        "type": "string",
                        "description": "Cloud provider for this Network peering container. Accepted values are AWS, GCP, and Azure.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId",
                    "providerName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNetworkContainers.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "providerName": {
                        "type": "string",
                        "description": "Cloud provider for this Network Peering connection. If omitted, Atlas sets this parameter to AWS.\n"
                    },
                    "results": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getNetworkContainersResult:getNetworkContainersResult"
                        },
                        "description": "A list where each represents a Network Peering Container.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId",
                    "providerName",
                    "results",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getNetworkPeering:getNetworkPeering": {
            "description": "{{% examples %}}\n## Example Usage\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getNetworkPeering.\n",
                "properties": {
                    "peeringId": {
                        "type": "string",
                        "description": "Atlas assigned unique ID for the peering connection.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the database user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "peeringId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNetworkPeering.\n",
                "properties": {
                    "accepterRegionName": {
                        "type": "string",
                        "description": "Specifies the region where the peer VPC resides. For complete lists of supported regions, see [Amazon Web Services](https://docs.atlas.mongodb.com/reference/amazon-aws/).\n"
                    },
                    "atlasCidrBlock": {
                        "type": "string"
                    },
                    "atlasId": {
                        "type": "string"
                    },
                    "awsAccountId": {
                        "type": "string",
                        "description": "Account ID of the owner of the peer VPC.\n"
                    },
                    "azureDirectoryId": {
                        "type": "string",
                        "description": "Unique identifier for an Azure AD directory.\n"
                    },
                    "azureSubscriptionId": {
                        "type": "string",
                        "description": "Unique identifer of the Azure subscription in which the VNet resides.\n"
                    },
                    "connectionId": {
                        "type": "string",
                        "description": "Unique identifier for the peering connection.\n"
                    },
                    "containerId": {
                        "type": "string"
                    },
                    "errorMessage": {
                        "type": "string",
                        "description": "When `\"status\" : \"FAILED\"`, Atlas provides a description of the error.\n"
                    },
                    "errorState": {
                        "type": "string",
                        "description": "Description of the Atlas error when `status` is `Failed`, Otherwise, Atlas returns `null`.\n"
                    },
                    "errorStateName": {
                        "type": "string",
                        "description": "Error state, if any. The VPC peering connection error state value can be one of the following: `REJECTED`, `EXPIRED`, `INVALID_ARGUMENT`.\n"
                    },
                    "gcpProjectId": {
                        "type": "string",
                        "description": "GCP project ID of the owner of the network peer.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "networkName": {
                        "type": "string",
                        "description": "Name of the network peer to which Atlas connects.\n"
                    },
                    "peeringId": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "providerName": {
                        "type": "string",
                        "description": "Cloud provider for this VPC peering connection. If omitted, Atlas sets this parameter to AWS. (Possible Values `AWS`, `AZURE`, `GCP`).\n"
                    },
                    "resourceGroupName": {
                        "type": "string",
                        "description": "Name of your Azure resource group.\n"
                    },
                    "routeTableCidrBlock": {
                        "type": "string",
                        "description": "Peer VPC CIDR block or subnet.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Status of the Atlas network peering connection: `ADDING_PEER`, `AVAILABLE`, `FAILED`, `DELETING`, `WAITING_FOR_USER`.\n"
                    },
                    "statusName": {
                        "type": "string",
                        "description": "The VPC peering connection status value can be one of the following: `INITIATING`, `PENDING_ACCEPTANCE`, `FAILED`, `FINALIZING`, `AVAILABLE`, `TERMINATING`.\n"
                    },
                    "vnetName": {
                        "type": "string",
                        "description": "Name of your Azure VNet.\n"
                    },
                    "vpcId": {
                        "type": "string",
                        "description": "Unique identifier of the peer VPC.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accepterRegionName",
                    "atlasCidrBlock",
                    "atlasId",
                    "awsAccountId",
                    "azureDirectoryId",
                    "azureSubscriptionId",
                    "connectionId",
                    "containerId",
                    "errorMessage",
                    "errorState",
                    "errorStateName",
                    "gcpProjectId",
                    "networkName",
                    "peeringId",
                    "projectId",
                    "providerName",
                    "resourceGroupName",
                    "routeTableCidrBlock",
                    "status",
                    "statusName",
                    "vnetName",
                    "vpcId",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getNetworkPeerings:getNetworkPeerings": {
            "description": "`mongodbatlas.getNetworkPeerings` describes all Network Peering Connections.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find **group_id** in the official documentation.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Basic Example (AWS).\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testNetworkPeering = new mongodbatlas.NetworkPeering(\"testNetworkPeering\", {\n    accepterRegionName: \"us-east-1\",\n    projectId: \"\u003cYOUR-PROJEC-ID\u003e\",\n    containerId: \"507f1f77bcf86cd799439011\",\n    providerName: \"AWS\",\n    routeTableCidrBlock: \"192.168.0.0/24\",\n    vpcId: \"vpc-abc123abc123\",\n    awsAccountId: \"abc123abc123\",\n});\nconst testNetworkPeerings = mongodbatlas.getNetworkPeeringsOutput({\n    projectId: testNetworkPeering.projectId,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_network_peering = mongodbatlas.NetworkPeering(\"testNetworkPeering\",\n    accepter_region_name=\"us-east-1\",\n    project_id=\"\u003cYOUR-PROJEC-ID\u003e\",\n    container_id=\"507f1f77bcf86cd799439011\",\n    provider_name=\"AWS\",\n    route_table_cidr_block=\"192.168.0.0/24\",\n    vpc_id=\"vpc-abc123abc123\",\n    aws_account_id=\"abc123abc123\")\ntest_network_peerings = mongodbatlas.get_network_peerings_output(project_id=test_network_peering.project_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testNetworkPeering = new Mongodbatlas.NetworkPeering(\"testNetworkPeering\", new()\n    {\n        AccepterRegionName = \"us-east-1\",\n        ProjectId = \"\u003cYOUR-PROJEC-ID\u003e\",\n        ContainerId = \"507f1f77bcf86cd799439011\",\n        ProviderName = \"AWS\",\n        RouteTableCidrBlock = \"192.168.0.0/24\",\n        VpcId = \"vpc-abc123abc123\",\n        AwsAccountId = \"abc123abc123\",\n    });\n\n    var testNetworkPeerings = Mongodbatlas.GetNetworkPeerings.Invoke(new()\n    {\n        ProjectId = testNetworkPeering.ProjectId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestNetworkPeering, err := mongodbatlas.NewNetworkPeering(ctx, \"testNetworkPeering\", \u0026mongodbatlas.NetworkPeeringArgs{\n\t\t\tAccepterRegionName:  pulumi.String(\"us-east-1\"),\n\t\t\tProjectId:           pulumi.String(\"\u003cYOUR-PROJEC-ID\u003e\"),\n\t\t\tContainerId:         pulumi.String(\"507f1f77bcf86cd799439011\"),\n\t\t\tProviderName:        pulumi.String(\"AWS\"),\n\t\t\tRouteTableCidrBlock: pulumi.String(\"192.168.0.0/24\"),\n\t\t\tVpcId:               pulumi.String(\"vpc-abc123abc123\"),\n\t\t\tAwsAccountId:        pulumi.String(\"abc123abc123\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupNetworkPeeringsOutput(ctx, mongodbatlas.GetNetworkPeeringsOutputArgs{\n\t\t\tProjectId: testNetworkPeering.ProjectId,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.NetworkPeering;\nimport com.pulumi.mongodbatlas.NetworkPeeringArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetNetworkPeeringsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testNetworkPeering = new NetworkPeering(\"testNetworkPeering\", NetworkPeeringArgs.builder()        \n            .accepterRegionName(\"us-east-1\")\n            .projectId(\"\u003cYOUR-PROJEC-ID\u003e\")\n            .containerId(\"507f1f77bcf86cd799439011\")\n            .providerName(\"AWS\")\n            .routeTableCidrBlock(\"192.168.0.0/24\")\n            .vpcId(\"vpc-abc123abc123\")\n            .awsAccountId(\"abc123abc123\")\n            .build());\n\n        final var testNetworkPeerings = MongodbatlasFunctions.getNetworkPeerings(GetNetworkPeeringsArgs.builder()\n            .projectId(testNetworkPeering.projectId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testNetworkPeering:\n    type: mongodbatlas:NetworkPeering\n    properties:\n      accepterRegionName: us-east-1\n      projectId: \u003cYOUR-PROJEC-ID\u003e\n      containerId: 507f1f77bcf86cd799439011\n      providerName: AWS\n      routeTableCidrBlock: 192.168.0.0/24\n      vpcId: vpc-abc123abc123\n      awsAccountId: abc123abc123\nvariables:\n  testNetworkPeerings:\n    fn::invoke:\n      Function: mongodbatlas:getNetworkPeerings\n      Arguments:\n        projectId: ${testNetworkPeering.projectId}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getNetworkPeerings.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the database user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNetworkPeerings.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getNetworkPeeringsResult:getNetworkPeeringsResult"
                        },
                        "description": "A list where each represents a Network Peering Connection.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId",
                    "results",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getOnlineArchive:getOnlineArchive": {
            "description": "`mongodbatlas.OnlineArchive` describes an Online Archive\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = mongodbatlas.getOnlineArchive({\n    projectId: _var.project_id,\n    clusterName: _var.cluster_name,\n    archiveId: \"5ebad3c1fe9c0ab8d37d61e1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.get_online_archive(project_id=var[\"project_id\"],\n    cluster_name=var[\"cluster_name\"],\n    archive_id=\"5ebad3c1fe9c0ab8d37d61e1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Mongodbatlas.GetOnlineArchive.Invoke(new()\n    {\n        ProjectId = @var.Project_id,\n        ClusterName = @var.Cluster_name,\n        ArchiveId = \"5ebad3c1fe9c0ab8d37d61e1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.LookupOnlineArchive(ctx, \u0026mongodbatlas.LookupOnlineArchiveArgs{\n\t\t\tProjectId:   _var.Project_id,\n\t\t\tClusterName: _var.Cluster_name,\n\t\t\tArchiveId:   \"5ebad3c1fe9c0ab8d37d61e1\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetOnlineArchiveArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getOnlineArchive(GetOnlineArchiveArgs.builder()\n            .projectId(var_.project_id())\n            .clusterName(var_.cluster_name())\n            .archiveId(\"5ebad3c1fe9c0ab8d37d61e1\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getOnlineArchive\n      Arguments:\n        projectId: ${var.project_id}\n        clusterName: ${var.cluster_name}\n        archiveId: 5ebad3c1fe9c0ab8d37d61e1\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference\n\n* `db_name`          -  Name of the database that contains the collection.\n* `coll_name`        -  Name of the collection.\n* `criteria`         -  Criteria to use for archiving data.\n* `criteria.type`          - Type of criteria (DATE, CUSTOM)\n* `criteria.date_field`    - Name of an already indexed date field from the documents. Data is archived when the current date is greater than the value of the date field specified here plus the number of days specified via the `expire_after_days` parameter.\n* `criteria.date_format`   - the date format. Valid values:  ISODATE (default), EPOCH_SECONDS, EPOCH_MILLIS, EPOCH_NANOSECONDS\n* `criteria.expire_after_days` - Number of days that specifies the age limit for the data in the live Atlas cluster.\n* `criteria.query` - JSON query to use to select documents for archiving. Only for `CUSTOM` type\n* `partition_fields` -  Fields to use to partition data.\n* `partition_fields.field_name` - Name of the field. To specify a nested field, use the dot notation.\n* `partition_fields.order` - Position of the field in the partition. Value can be: 0,1,2\nBy default, the date field specified in the criteria.dateField parameter is in the first position of the partition.\n* `partitio_fields.field_type` - Type of the partition field\n* `state`    - Status of the online archive. Valid values are: Pending, Archiving, Idle, Pausing, Paused, Orphaned and Deleted\n\nSee [MongoDB Atlas API](https://docs.atlas.mongodb.com/reference/api/online-archive-get-one/) Documentation for more information.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getOnlineArchive.\n",
                "properties": {
                    "archiveId": {
                        "type": "string",
                        "description": "ID of the online archive.\n"
                    },
                    "clusterName": {
                        "type": "string",
                        "description": "Name of the cluster that contains the collection.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "archiveId",
                    "clusterName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getOnlineArchive.\n",
                "properties": {
                    "archiveId": {
                        "type": "string"
                    },
                    "clusterName": {
                        "type": "string"
                    },
                    "collName": {
                        "type": "string"
                    },
                    "criterias": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getOnlineArchiveCriteria:getOnlineArchiveCriteria"
                        }
                    },
                    "dbName": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "partitionFields": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getOnlineArchivePartitionField:getOnlineArchivePartitionField"
                        }
                    },
                    "paused": {
                        "type": "boolean"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "state": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "archiveId",
                    "clusterName",
                    "collName",
                    "criterias",
                    "dbName",
                    "partitionFields",
                    "paused",
                    "projectId",
                    "state",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getOnlineArchives:getOnlineArchives": {
            "description": "`mongodbatlas.OnlineArchive` Describes the list of all the online archives for a cluster\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = mongodbatlas.getOnlineArchives({\n    projectId: _var.project_id,\n    clusterName: _var.cluster_name,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.get_online_archives(project_id=var[\"project_id\"],\n    cluster_name=var[\"cluster_name\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Mongodbatlas.GetOnlineArchives.Invoke(new()\n    {\n        ProjectId = @var.Project_id,\n        ClusterName = @var.Cluster_name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.LookupOnlineArchives(ctx, \u0026mongodbatlas.LookupOnlineArchivesArgs{\n\t\t\tProjectId:   _var.Project_id,\n\t\t\tClusterName: _var.Cluster_name,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetOnlineArchivesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getOnlineArchives(GetOnlineArchivesArgs.builder()\n            .projectId(var_.project_id())\n            .clusterName(var_.cluster_name())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getOnlineArchives\n      Arguments:\n        projectId: ${var.project_id}\n        clusterName: ${var.cluster_name}\n```\n{{% /example %}}\n{{% /examples %}}\n## Attributes reference \n\nEach object in the results array represents an online archive with the following attributes:\n\n* `archive_id`         - ID of the online archive.\n* `db_name`          -  Name of the database that contains the collection.\n* `coll_name`        -  Name of the collection.\n* `criteria`         -  Criteria to use for archiving data.\n* `criteria.type`          - Type of criteria (DATE, CUSTOM)\n* `criteria.date_field`    - Name of an already indexed date field from the documents. Data is archived when the current date is greater than the value of the date field specified here plus the number of days specified via the `expire_after_days` parameter.\n* `criteria.date_format`   - the date format. Valid values:  ISODATE (default), EPOCH_SECONDS, EPOCH_MILLIS, EPOCH_NANOSECONDS\n* `criteria.expire_after_days` - Number of days that specifies the age limit for the data in the live Atlas cluster.\n* `criteria.query` - JSON query to use to select documents for archiving. Only for `CUSTOM` type\n* `partition_fields` -  Fields to use to partition data.\n* `partition_fields.field_name` - Name of the field. To specify a nested field, use the dot notation.\n* `partition_fields.order` - Position of the field in the partition. Value can be: 0,1,2\nBy default, the date field specified in the criteria.dateField parameter is in the first position of the partition.\n* `partitio_fields.field_type` - Type of the partition field\n* `state`    - Status of the online archive. Valid values are: Pending, Archiving, Idle, Pausing, Paused, Orphaned and Deleted\n\nSee [MongoDB Atlas API](https://docs.atlas.mongodb.com/reference/api/online-archive-get-all-for-cluster/) Documentation for more information.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getOnlineArchives.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "Name of the cluster that contains the collection.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getOnlineArchives.\n",
                "properties": {
                    "clusterName": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getOnlineArchivesResult:getOnlineArchivesResult"
                        }
                    },
                    "totalCount": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId",
                    "results",
                    "totalCount",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getOrgInvitation:getOrgInvitation": {
            "description": "`mongodbatlas.OrgInvitation` describes an invitation for a user to join an Atlas organization.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getOrgInvitation.\n",
                "properties": {
                    "invitationId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the invitation in Atlas.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the organization to which you invited the user.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Email address of the invited user. This is the address to which Atlas sends the invite. If the user accepts the invitation, they log in to Atlas with this username.\n"
                    }
                },
                "type": "object",
                "required": [
                    "invitationId",
                    "orgId",
                    "username"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getOrgInvitation.\n",
                "properties": {
                    "createdAt": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when Atlas sent the invitation.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when the invitation expires. Users have 30 days to accept an invitation.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "invitationId": {
                        "type": "string"
                    },
                    "inviterUsername": {
                        "type": "string",
                        "description": "Atlas user who invited `username` to the organization.\n"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Atlas roles to assign to the invited user. If the user accepts the invitation, Atlas assigns these roles to them. The following options are available:\n* ORG_OWNER\n* ORG_GROUP_CREATOR\n* ORG_BILLING_ADMIN\n* ORG_READ_ONLY\n* ORG_MEMBER\n"
                    },
                    "teamsIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of unique 24-hexadecimal digit strings that identify the teams that the user was invited to join.\n"
                    },
                    "username": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "createdAt",
                    "expiresAt",
                    "invitationId",
                    "inviterUsername",
                    "orgId",
                    "roles",
                    "teamsIds",
                    "username",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getPrivateEndpointRegionalMode:getPrivateEndpointRegionalMode": {
            "description": "`private_endpoint_regional_mode` describe a Private Endpoint Regional Mode. This represents a Private Endpoint Regional Mode Connection that wants to retrieve settings of an Atlas project.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPrivateEndpointRegionalMode.\n",
                "properties": {
                    "enabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether the regionalized private endpoitn setting is enabled for the project.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique identifier for the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPrivateEndpointRegionalMode.\n",
                "properties": {
                    "enabled": {
                        "type": "boolean"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "projectId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "projectId",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getPrivateLinkEndpoint:getPrivateLinkEndpoint": {
            "description": "`mongodbatlas.PrivateLinkEndpoint` describe a Private Endpoint. This represents a Private Endpoint Connection to retrieve details regarding a private endpoint by id in an Atlas project\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPrivateLinkEndpoint.\n",
                "properties": {
                    "privateLinkId": {
                        "type": "string",
                        "description": "Unique identifier of the private endpoint service that you want to retrieve.\n",
                        "willReplaceOnChanges": true
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique identifier for the project.\n",
                        "willReplaceOnChanges": true
                    },
                    "providerName": {
                        "type": "string",
                        "description": "Cloud provider for which you want to retrieve a private endpoint service. Atlas accepts `AWS`, `AZURE` or `GCP`.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "privateLinkId",
                    "projectId",
                    "providerName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPrivateLinkEndpoint.\n",
                "properties": {
                    "endpointGroupNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "GCP network endpoint groups corresponding to the Private Service Connect endpoint service.\n"
                    },
                    "endpointServiceName": {
                        "type": "string",
                        "description": "Name of the PrivateLink endpoint service in AWS. Returns null while the endpoint service is being created.\n"
                    },
                    "errorMessage": {
                        "type": "string",
                        "description": "Error message pertaining to the AWS PrivateLink connection. Returns null if there are no errors.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "interfaceEndpoints": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Unique identifiers of the interface endpoints in your VPC that you added to the AWS PrivateLink connection.\n"
                    },
                    "privateEndpoints": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "All private endpoints that you have added to this Azure Private Link Service.\n"
                    },
                    "privateLinkId": {
                        "type": "string"
                    },
                    "privateLinkServiceName": {
                        "type": "string",
                        "description": "Name of the Azure Private Link Service that Atlas manages.\n"
                    },
                    "privateLinkServiceResourceId": {
                        "type": "string",
                        "description": "Resource ID of the Azure Private Link Service that Atlas manages.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "providerName": {
                        "type": "string"
                    },
                    "regionName": {
                        "type": "string",
                        "description": "GCP region for the Private Service Connect endpoint service.\n"
                    },
                    "serviceAttachmentNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Unique alphanumeric and special character strings that identify the service attachments associated with the GCP Private Service Connect endpoint service.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Status of the AWS PrivateLink connection.\nReturns one of the following values:\n"
                    }
                },
                "type": "object",
                "required": [
                    "endpointGroupNames",
                    "endpointServiceName",
                    "errorMessage",
                    "interfaceEndpoints",
                    "privateEndpoints",
                    "privateLinkId",
                    "privateLinkServiceName",
                    "privateLinkServiceResourceId",
                    "projectId",
                    "providerName",
                    "regionName",
                    "serviceAttachmentNames",
                    "status",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getPrivateLinkEndpointService:getPrivateLinkEndpointService": {
            "description": "`mongodbatlas.PrivateLinkEndpointService` describe a Private Endpoint Link. This represents a Private Endpoint Link Connection that wants to retrieve details in an Atlas project.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPrivateLinkEndpointService.\n",
                "properties": {
                    "endpointServiceId": {
                        "type": "string",
                        "description": "Unique identifier of the `AWS` or `AZURE` resource.\n",
                        "willReplaceOnChanges": true
                    },
                    "privateLinkId": {
                        "type": "string",
                        "description": "Unique identifier of the private endpoint service for which you want to retrieve a private endpoint.\n",
                        "willReplaceOnChanges": true
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique identifier for the project.\n",
                        "willReplaceOnChanges": true
                    },
                    "providerName": {
                        "type": "string",
                        "description": "Cloud provider for which you want to create a private endpoint. Atlas accepts `AWS` or `AZURE`.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "endpointServiceId",
                    "privateLinkId",
                    "projectId",
                    "providerName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPrivateLinkEndpointService.\n",
                "properties": {
                    "awsConnectionStatus": {
                        "type": "string",
                        "description": "Status of the interface endpoint for AWS.\nReturns one of the following values:\n"
                    },
                    "azureStatus": {
                        "type": "string",
                        "description": "Status of the interface endpoint for AZURE.\nReturns one of the following values:\n"
                    },
                    "deleteRequested": {
                        "type": "boolean",
                        "description": "Indicates if Atlas received a request to remove the interface endpoint from the private endpoint connection.\n"
                    },
                    "endpointServiceId": {
                        "type": "string"
                    },
                    "endpoints": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getPrivateLinkEndpointServiceEndpoint:getPrivateLinkEndpointServiceEndpoint"
                        },
                        "description": "Collection of individual private endpoints that comprise your network endpoint group.\n"
                    },
                    "errorMessage": {
                        "type": "string",
                        "description": "Error message pertaining to the interface endpoint. Returns null if there are no errors.\n"
                    },
                    "gcpStatus": {
                        "type": "string",
                        "description": "Status of the interface endpoint for GCP.\nReturns one of the following values:\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "interfaceEndpointId": {
                        "type": "string",
                        "description": "Unique identifier of the interface endpoint.\n"
                    },
                    "privateEndpointConnectionName": {
                        "type": "string",
                        "description": "Name of the connection for this private endpoint that Atlas generates.\n"
                    },
                    "privateEndpointIpAddress": {
                        "type": "string",
                        "description": "Private IP address of the private endpoint network interface.\n"
                    },
                    "privateEndpointResourceId": {
                        "type": "string",
                        "description": "Unique identifier of the private endpoint.\n"
                    },
                    "privateLinkId": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "providerName": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "awsConnectionStatus",
                    "azureStatus",
                    "deleteRequested",
                    "endpointServiceId",
                    "endpoints",
                    "errorMessage",
                    "gcpStatus",
                    "interfaceEndpointId",
                    "privateEndpointConnectionName",
                    "privateEndpointIpAddress",
                    "privateEndpointResourceId",
                    "privateLinkId",
                    "projectId",
                    "providerName",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getPrivatelinkEndpointServiceAdl:getPrivatelinkEndpointServiceAdl": {
            "description": "`privatelink_endpoint_service_adl` Provides an Atlas Data Lake (ADL) and Online Archive PrivateLink endpoint resource.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Basic\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceAdl;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceAdlArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetPrivatelinkEndpointServiceAdlArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var adlTest = new PrivatelinkEndpointServiceAdl(\"adlTest\", PrivatelinkEndpointServiceAdlArgs.builder()        \n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .endpointId(\"\u003cENDPOINT_ID\u003e\")\n            .comment(\"Comment for PrivateLink endpoint ADL\")\n            .type(\"DATA_LAKE\")\n            .providerName(\"AWS\")\n            .build());\n\n        final var test = MongodbatlasFunctions.getPrivatelinkEndpointServiceAdl(GetPrivatelinkEndpointServiceAdlArgs.builder()\n            .projectId(adlTest.projectId())\n            .privateLinkId(adlTest.endpointId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  adlTest:\n    type: mongodbatlas:PrivatelinkEndpointServiceAdl\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      endpointId: \u003cENDPOINT_ID\u003e\n      comment: Comment for PrivateLink endpoint ADL\n      type: DATA_LAKE\n      providerName: AWS\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getPrivatelinkEndpointServiceAdl\n      Arguments:\n        projectId: ${adlTest.projectId}\n        privateLinkId: ${adlTest.endpointId}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getPrivatelinkEndpointServiceAdl.\n",
                "properties": {
                    "endpointId": {
                        "type": "string",
                        "description": "Unique 22-character alphanumeric string that identifies the private endpoint. Atlas supports AWS private endpoints using the [|aws| PrivateLink](https://aws.amazon.com/privatelink/) feature.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-digit hexadecimal string that identifies the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "endpointId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPrivatelinkEndpointServiceAdl.\n",
                "properties": {
                    "comment": {
                        "type": "string",
                        "description": "Human-readable string to associate with this private endpoint.\n"
                    },
                    "endpointId": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "providerName": {
                        "type": "string",
                        "description": "Human-readable label that identifies the cloud provider for this endpoint.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Human-readable label that identifies the type of resource to associate with this private endpoint.\n"
                    }
                },
                "type": "object",
                "required": [
                    "comment",
                    "endpointId",
                    "projectId",
                    "providerName",
                    "type",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getPrivatelinkEndpointServiceServerless:getPrivatelinkEndpointServiceServerless": {
            "description": "`privatelink_endpoint_service_serverless` Provides a Serverless PrivateLink Endpoint Service resource.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n## Example with AWS\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testServerlessInstance = new mongodbatlas.ServerlessInstance(\"testServerlessInstance\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    providerSettingsBackingProviderName: \"AWS\",\n    providerSettingsProviderName: \"SERVERLESS\",\n    providerSettingsRegionName: \"US_EAST_1\",\n    continuousBackupEnabled: true,\n});\nconst testPrivatelinkEndpointServerless = new mongodbatlas.PrivatelinkEndpointServerless(\"testPrivatelinkEndpointServerless\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: testServerlessInstance.name,\n    providerName: \"AWS\",\n});\nconst testPrivatelinkEndpointServiceServerless = mongodbatlas.getPrivatelinkEndpointServiceServerlessOutput({\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: testServerlessInstance.name,\n    endpointId: testPrivatelinkEndpointServerless.endpointId,\n});\nconst testIndex_privatelinkEndpointServiceServerlessPrivatelinkEndpointServiceServerless = new mongodbatlas.PrivatelinkEndpointServiceServerless(\"testIndex/privatelinkEndpointServiceServerlessPrivatelinkEndpointServiceServerless\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: \"test-db\",\n    endpointId: testPrivatelinkEndpointServerless.endpointId,\n    providerName: \"AWS\",\n    comment: \"New serverless endpoint\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_serverless_instance = mongodbatlas.ServerlessInstance(\"testServerlessInstance\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    provider_settings_backing_provider_name=\"AWS\",\n    provider_settings_provider_name=\"SERVERLESS\",\n    provider_settings_region_name=\"US_EAST_1\",\n    continuous_backup_enabled=True)\ntest_privatelink_endpoint_serverless = mongodbatlas.PrivatelinkEndpointServerless(\"testPrivatelinkEndpointServerless\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=test_serverless_instance.name,\n    provider_name=\"AWS\")\ntest_privatelink_endpoint_service_serverless = mongodbatlas.get_privatelink_endpoint_service_serverless_output(project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=test_serverless_instance.name,\n    endpoint_id=test_privatelink_endpoint_serverless.endpoint_id)\ntest_index_privatelink_endpoint_service_serverless_privatelink_endpoint_service_serverless = mongodbatlas.PrivatelinkEndpointServiceServerless(\"testIndex/privatelinkEndpointServiceServerlessPrivatelinkEndpointServiceServerless\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=\"test-db\",\n    endpoint_id=test_privatelink_endpoint_serverless.endpoint_id,\n    provider_name=\"AWS\",\n    comment=\"New serverless endpoint\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testServerlessInstance = new Mongodbatlas.ServerlessInstance(\"testServerlessInstance\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        ProviderSettingsBackingProviderName = \"AWS\",\n        ProviderSettingsProviderName = \"SERVERLESS\",\n        ProviderSettingsRegionName = \"US_EAST_1\",\n        ContinuousBackupEnabled = true,\n    });\n\n    var testPrivatelinkEndpointServerless = new Mongodbatlas.PrivatelinkEndpointServerless(\"testPrivatelinkEndpointServerless\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = testServerlessInstance.Name,\n        ProviderName = \"AWS\",\n    });\n\n    var testPrivatelinkEndpointServiceServerless = Mongodbatlas.GetPrivatelinkEndpointServiceServerless.Invoke(new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = testServerlessInstance.Name,\n        EndpointId = testPrivatelinkEndpointServerless.EndpointId,\n    });\n\n    var testIndex_privatelinkEndpointServiceServerlessPrivatelinkEndpointServiceServerless = new Mongodbatlas.PrivatelinkEndpointServiceServerless(\"testIndex/privatelinkEndpointServiceServerlessPrivatelinkEndpointServiceServerless\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = \"test-db\",\n        EndpointId = testPrivatelinkEndpointServerless.EndpointId,\n        ProviderName = \"AWS\",\n        Comment = \"New serverless endpoint\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestServerlessInstance, err := mongodbatlas.NewServerlessInstance(ctx, \"testServerlessInstance\", \u0026mongodbatlas.ServerlessInstanceArgs{\n\t\t\tProjectId:                           pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tProviderSettingsBackingProviderName: pulumi.String(\"AWS\"),\n\t\t\tProviderSettingsProviderName:        pulumi.String(\"SERVERLESS\"),\n\t\t\tProviderSettingsRegionName:          pulumi.String(\"US_EAST_1\"),\n\t\t\tContinuousBackupEnabled:             pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestPrivatelinkEndpointServerless, err := mongodbatlas.NewPrivatelinkEndpointServerless(ctx, \"testPrivatelinkEndpointServerless\", \u0026mongodbatlas.PrivatelinkEndpointServerlessArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tInstanceName: testServerlessInstance.Name,\n\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupPrivatelinkEndpointServiceServerlessOutput(ctx, mongodbatlas.GetPrivatelinkEndpointServiceServerlessOutputArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tInstanceName: testServerlessInstance.Name,\n\t\t\tEndpointId:   testPrivatelinkEndpointServerless.EndpointId,\n\t\t}, nil)\n\t\t_, err = mongodbatlas.NewPrivatelinkEndpointServiceServerless(ctx, \"testIndex/privatelinkEndpointServiceServerlessPrivatelinkEndpointServiceServerless\", \u0026mongodbatlas.PrivatelinkEndpointServiceServerlessArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tInstanceName: pulumi.String(\"test-db\"),\n\t\t\tEndpointId:   testPrivatelinkEndpointServerless.EndpointId,\n\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\tComment:      pulumi.String(\"New serverless endpoint\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ServerlessInstance;\nimport com.pulumi.mongodbatlas.ServerlessInstanceArgs;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServerless;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServerlessArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetPrivatelinkEndpointServiceServerlessArgs;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceServerless;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceServerlessArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testServerlessInstance = new ServerlessInstance(\"testServerlessInstance\", ServerlessInstanceArgs.builder()        \n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .providerSettingsBackingProviderName(\"AWS\")\n            .providerSettingsProviderName(\"SERVERLESS\")\n            .providerSettingsRegionName(\"US_EAST_1\")\n            .continuousBackupEnabled(true)\n            .build());\n\n        var testPrivatelinkEndpointServerless = new PrivatelinkEndpointServerless(\"testPrivatelinkEndpointServerless\", PrivatelinkEndpointServerlessArgs.builder()        \n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(testServerlessInstance.name())\n            .providerName(\"AWS\")\n            .build());\n\n        final var testPrivatelinkEndpointServiceServerless = MongodbatlasFunctions.getPrivatelinkEndpointServiceServerless(GetPrivatelinkEndpointServiceServerlessArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(testServerlessInstance.name())\n            .endpointId(testPrivatelinkEndpointServerless.endpointId())\n            .build());\n\n        var testIndex_privatelinkEndpointServiceServerlessPrivatelinkEndpointServiceServerless = new PrivatelinkEndpointServiceServerless(\"testIndex/privatelinkEndpointServiceServerlessPrivatelinkEndpointServiceServerless\", PrivatelinkEndpointServiceServerlessArgs.builder()        \n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(\"test-db\")\n            .endpointId(testPrivatelinkEndpointServerless.endpointId())\n            .providerName(\"AWS\")\n            .comment(\"New serverless endpoint\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testPrivatelinkEndpointServerless:\n    type: mongodbatlas:PrivatelinkEndpointServerless\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      instanceName: ${testServerlessInstance.name}\n      providerName: AWS\n  testIndex/privatelinkEndpointServiceServerlessPrivatelinkEndpointServiceServerless:\n    type: mongodbatlas:PrivatelinkEndpointServiceServerless\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      instanceName: test-db\n      endpointId: ${testPrivatelinkEndpointServerless.endpointId}\n      providerName: AWS\n      comment: New serverless endpoint\n  testServerlessInstance:\n    type: mongodbatlas:ServerlessInstance\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      providerSettingsBackingProviderName: AWS\n      providerSettingsProviderName: SERVERLESS\n      providerSettingsRegionName: US_EAST_1\n      continuousBackupEnabled: true\nvariables:\n  testPrivatelinkEndpointServiceServerless:\n    fn::invoke:\n      Function: mongodbatlas:getPrivatelinkEndpointServiceServerless\n      Arguments:\n        projectId: \u003cPROJECT_ID\u003e\n        instanceName: ${testServerlessInstance.name}\n        endpointId: ${testPrivatelinkEndpointServerless.endpointId}\n```\n\n## Example with AZURE\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testServerlessInstance = new mongodbatlas.ServerlessInstance(\"testServerlessInstance\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    providerSettingsBackingProviderName: \"AZURE\",\n    providerSettingsProviderName: \"SERVERLESS\",\n    providerSettingsRegionName: \"US_EAST\",\n    continuousBackupEnabled: true,\n});\nconst testPrivatelinkEndpointServerless = new mongodbatlas.PrivatelinkEndpointServerless(\"testPrivatelinkEndpointServerless\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: testServerlessInstance.name,\n    providerName: \"AZURE\",\n});\nconst testPrivatelinkEndpointServiceServerless = mongodbatlas.getPrivatelinkEndpointServiceServerlessOutput({\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: testServerlessInstance.name,\n    endpointId: testPrivatelinkEndpointServerless.endpointId,\n});\nconst testIndex_privatelinkEndpointServiceServerlessPrivatelinkEndpointServiceServerless = new mongodbatlas.PrivatelinkEndpointServiceServerless(\"testIndex/privatelinkEndpointServiceServerlessPrivatelinkEndpointServiceServerless\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: \"test-db\",\n    endpointId: testPrivatelinkEndpointServerless.endpointId,\n    providerName: \"AZURE\",\n    comment: \"New serverless endpoint\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_serverless_instance = mongodbatlas.ServerlessInstance(\"testServerlessInstance\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    provider_settings_backing_provider_name=\"AZURE\",\n    provider_settings_provider_name=\"SERVERLESS\",\n    provider_settings_region_name=\"US_EAST\",\n    continuous_backup_enabled=True)\ntest_privatelink_endpoint_serverless = mongodbatlas.PrivatelinkEndpointServerless(\"testPrivatelinkEndpointServerless\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=test_serverless_instance.name,\n    provider_name=\"AZURE\")\ntest_privatelink_endpoint_service_serverless = mongodbatlas.get_privatelink_endpoint_service_serverless_output(project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=test_serverless_instance.name,\n    endpoint_id=test_privatelink_endpoint_serverless.endpoint_id)\ntest_index_privatelink_endpoint_service_serverless_privatelink_endpoint_service_serverless = mongodbatlas.PrivatelinkEndpointServiceServerless(\"testIndex/privatelinkEndpointServiceServerlessPrivatelinkEndpointServiceServerless\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=\"test-db\",\n    endpoint_id=test_privatelink_endpoint_serverless.endpoint_id,\n    provider_name=\"AZURE\",\n    comment=\"New serverless endpoint\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testServerlessInstance = new Mongodbatlas.ServerlessInstance(\"testServerlessInstance\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        ProviderSettingsBackingProviderName = \"AZURE\",\n        ProviderSettingsProviderName = \"SERVERLESS\",\n        ProviderSettingsRegionName = \"US_EAST\",\n        ContinuousBackupEnabled = true,\n    });\n\n    var testPrivatelinkEndpointServerless = new Mongodbatlas.PrivatelinkEndpointServerless(\"testPrivatelinkEndpointServerless\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = testServerlessInstance.Name,\n        ProviderName = \"AZURE\",\n    });\n\n    var testPrivatelinkEndpointServiceServerless = Mongodbatlas.GetPrivatelinkEndpointServiceServerless.Invoke(new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = testServerlessInstance.Name,\n        EndpointId = testPrivatelinkEndpointServerless.EndpointId,\n    });\n\n    var testIndex_privatelinkEndpointServiceServerlessPrivatelinkEndpointServiceServerless = new Mongodbatlas.PrivatelinkEndpointServiceServerless(\"testIndex/privatelinkEndpointServiceServerlessPrivatelinkEndpointServiceServerless\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = \"test-db\",\n        EndpointId = testPrivatelinkEndpointServerless.EndpointId,\n        ProviderName = \"AZURE\",\n        Comment = \"New serverless endpoint\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestServerlessInstance, err := mongodbatlas.NewServerlessInstance(ctx, \"testServerlessInstance\", \u0026mongodbatlas.ServerlessInstanceArgs{\n\t\t\tProjectId:                           pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tProviderSettingsBackingProviderName: pulumi.String(\"AZURE\"),\n\t\t\tProviderSettingsProviderName:        pulumi.String(\"SERVERLESS\"),\n\t\t\tProviderSettingsRegionName:          pulumi.String(\"US_EAST\"),\n\t\t\tContinuousBackupEnabled:             pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestPrivatelinkEndpointServerless, err := mongodbatlas.NewPrivatelinkEndpointServerless(ctx, \"testPrivatelinkEndpointServerless\", \u0026mongodbatlas.PrivatelinkEndpointServerlessArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tInstanceName: testServerlessInstance.Name,\n\t\t\tProviderName: pulumi.String(\"AZURE\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupPrivatelinkEndpointServiceServerlessOutput(ctx, mongodbatlas.GetPrivatelinkEndpointServiceServerlessOutputArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tInstanceName: testServerlessInstance.Name,\n\t\t\tEndpointId:   testPrivatelinkEndpointServerless.EndpointId,\n\t\t}, nil)\n\t\t_, err = mongodbatlas.NewPrivatelinkEndpointServiceServerless(ctx, \"testIndex/privatelinkEndpointServiceServerlessPrivatelinkEndpointServiceServerless\", \u0026mongodbatlas.PrivatelinkEndpointServiceServerlessArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tInstanceName: pulumi.String(\"test-db\"),\n\t\t\tEndpointId:   testPrivatelinkEndpointServerless.EndpointId,\n\t\t\tProviderName: pulumi.String(\"AZURE\"),\n\t\t\tComment:      pulumi.String(\"New serverless endpoint\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ServerlessInstance;\nimport com.pulumi.mongodbatlas.ServerlessInstanceArgs;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServerless;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServerlessArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetPrivatelinkEndpointServiceServerlessArgs;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceServerless;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceServerlessArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testServerlessInstance = new ServerlessInstance(\"testServerlessInstance\", ServerlessInstanceArgs.builder()        \n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .providerSettingsBackingProviderName(\"AZURE\")\n            .providerSettingsProviderName(\"SERVERLESS\")\n            .providerSettingsRegionName(\"US_EAST\")\n            .continuousBackupEnabled(true)\n            .build());\n\n        var testPrivatelinkEndpointServerless = new PrivatelinkEndpointServerless(\"testPrivatelinkEndpointServerless\", PrivatelinkEndpointServerlessArgs.builder()        \n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(testServerlessInstance.name())\n            .providerName(\"AZURE\")\n            .build());\n\n        final var testPrivatelinkEndpointServiceServerless = MongodbatlasFunctions.getPrivatelinkEndpointServiceServerless(GetPrivatelinkEndpointServiceServerlessArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(testServerlessInstance.name())\n            .endpointId(testPrivatelinkEndpointServerless.endpointId())\n            .build());\n\n        var testIndex_privatelinkEndpointServiceServerlessPrivatelinkEndpointServiceServerless = new PrivatelinkEndpointServiceServerless(\"testIndex/privatelinkEndpointServiceServerlessPrivatelinkEndpointServiceServerless\", PrivatelinkEndpointServiceServerlessArgs.builder()        \n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(\"test-db\")\n            .endpointId(testPrivatelinkEndpointServerless.endpointId())\n            .providerName(\"AZURE\")\n            .comment(\"New serverless endpoint\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testPrivatelinkEndpointServerless:\n    type: mongodbatlas:PrivatelinkEndpointServerless\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      instanceName: ${testServerlessInstance.name}\n      providerName: AZURE\n  testIndex/privatelinkEndpointServiceServerlessPrivatelinkEndpointServiceServerless:\n    type: mongodbatlas:PrivatelinkEndpointServiceServerless\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      instanceName: test-db\n      endpointId: ${testPrivatelinkEndpointServerless.endpointId}\n      providerName: AZURE\n      comment: New serverless endpoint\n  testServerlessInstance:\n    type: mongodbatlas:ServerlessInstance\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      providerSettingsBackingProviderName: AZURE\n      providerSettingsProviderName: SERVERLESS\n      providerSettingsRegionName: US_EAST\n      continuousBackupEnabled: true\nvariables:\n  testPrivatelinkEndpointServiceServerless:\n    fn::invoke:\n      Function: mongodbatlas:getPrivatelinkEndpointServiceServerless\n      Arguments:\n        projectId: \u003cPROJECT_ID\u003e\n        instanceName: ${testServerlessInstance.name}\n        endpointId: ${testPrivatelinkEndpointServerless.endpointId}\n```\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPrivatelinkEndpointServiceServerless.\n",
                "properties": {
                    "endpointId": {
                        "type": "string",
                        "description": "Unique 22-character alphanumeric string that identifies the private endpoint. Atlas supports AWS private endpoints using the [AWS PrivateLink](https://aws.amazon.com/privatelink/) feature.\n",
                        "willReplaceOnChanges": true
                    },
                    "instanceName": {
                        "type": "string",
                        "description": "Human-readable label that identifies the serverless instance\n",
                        "willReplaceOnChanges": true
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-digit hexadecimal string that identifies the project.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "endpointId",
                    "instanceName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPrivatelinkEndpointServiceServerless.\n",
                "properties": {
                    "cloudProviderEndpointId": {
                        "type": "string"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "endpointId": {
                        "type": "string"
                    },
                    "endpointServiceName": {
                        "type": "string",
                        "description": "Unique string that identifies the PrivateLink endpoint service. MongoDB Cloud returns null while it creates the endpoint service.\n"
                    },
                    "errorMessage": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "instanceName": {
                        "type": "string"
                    },
                    "privateEndpointIpAddress": {
                        "type": "string",
                        "description": "IPv4 address of the private endpoint in your Azure VNet that someone added to this private endpoint service.\n"
                    },
                    "privateLinkServiceResourceId": {
                        "type": "string",
                        "description": "Root-relative path that identifies the Azure Private Link Service that MongoDB Cloud manages.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "status": {
                        "type": "string",
                        "description": "Human-readable label that indicates the current operating status of the private endpoint. Values include: RESERVATION_REQUESTED, RESERVED, INITIATING, AVAILABLE, FAILED, DELETING.\n"
                    }
                },
                "type": "object",
                "required": [
                    "cloudProviderEndpointId",
                    "comment",
                    "endpointId",
                    "endpointServiceName",
                    "errorMessage",
                    "instanceName",
                    "privateEndpointIpAddress",
                    "privateLinkServiceResourceId",
                    "projectId",
                    "status",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getPrivatelinkEndpointsServiceAdl:getPrivatelinkEndpointsServiceAdl": {
            "description": "`privatelink_endpoints_service_adl` Describes the list of all Atlas Data Lake (ADL) and Online Archive PrivateLink endpoints resource.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Basic\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst adlTest = new mongodbatlas.PrivatelinkEndpointServiceAdl(\"adlTest\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    endpointId: \"\u003cENDPOINT_ID\u003e\",\n    comment: \"Comment for PrivateLink endpoint ADL\",\n    type: \"DATA_LAKE\",\n    providerName: \"AWS\",\n});\nconst test = mongodbatlas.getPrivatelinkEndpointsServiceAdlOutput({\n    projectId: adlTest.projectId,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nadl_test = mongodbatlas.PrivatelinkEndpointServiceAdl(\"adlTest\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    endpoint_id=\"\u003cENDPOINT_ID\u003e\",\n    comment=\"Comment for PrivateLink endpoint ADL\",\n    type=\"DATA_LAKE\",\n    provider_name=\"AWS\")\ntest = mongodbatlas.get_privatelink_endpoints_service_adl_output(project_id=adl_test.project_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var adlTest = new Mongodbatlas.PrivatelinkEndpointServiceAdl(\"adlTest\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        EndpointId = \"\u003cENDPOINT_ID\u003e\",\n        Comment = \"Comment for PrivateLink endpoint ADL\",\n        Type = \"DATA_LAKE\",\n        ProviderName = \"AWS\",\n    });\n\n    var test = Mongodbatlas.GetPrivatelinkEndpointsServiceAdl.Invoke(new()\n    {\n        ProjectId = adlTest.ProjectId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tadlTest, err := mongodbatlas.NewPrivatelinkEndpointServiceAdl(ctx, \"adlTest\", \u0026mongodbatlas.PrivatelinkEndpointServiceAdlArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tEndpointId:   pulumi.String(\"\u003cENDPOINT_ID\u003e\"),\n\t\t\tComment:      pulumi.String(\"Comment for PrivateLink endpoint ADL\"),\n\t\t\tType:         pulumi.String(\"DATA_LAKE\"),\n\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupPrivatelinkEndpointsServiceAdlOutput(ctx, mongodbatlas.GetPrivatelinkEndpointsServiceAdlOutputArgs{\n\t\t\tProjectId: adlTest.ProjectId,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceAdl;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceAdlArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetPrivatelinkEndpointsServiceAdlArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var adlTest = new PrivatelinkEndpointServiceAdl(\"adlTest\", PrivatelinkEndpointServiceAdlArgs.builder()        \n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .endpointId(\"\u003cENDPOINT_ID\u003e\")\n            .comment(\"Comment for PrivateLink endpoint ADL\")\n            .type(\"DATA_LAKE\")\n            .providerName(\"AWS\")\n            .build());\n\n        final var test = MongodbatlasFunctions.getPrivatelinkEndpointsServiceAdl(GetPrivatelinkEndpointsServiceAdlArgs.builder()\n            .projectId(adlTest.projectId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  adlTest:\n    type: mongodbatlas:PrivatelinkEndpointServiceAdl\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      endpointId: \u003cENDPOINT_ID\u003e\n      comment: Comment for PrivateLink endpoint ADL\n      type: DATA_LAKE\n      providerName: AWS\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getPrivatelinkEndpointsServiceAdl\n      Arguments:\n        projectId: ${adlTest.projectId}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getPrivatelinkEndpointsServiceAdl.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPrivatelinkEndpointsServiceAdl.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "links": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getPrivatelinkEndpointsServiceAdlLink:getPrivatelinkEndpointsServiceAdlLink"
                        }
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getPrivatelinkEndpointsServiceAdlResult:getPrivatelinkEndpointsServiceAdlResult"
                        }
                    },
                    "totalCount": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "links",
                    "projectId",
                    "results",
                    "totalCount",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getPrivatelinkEndpointsServiceServerless:getPrivatelinkEndpointsServiceServerless": {
            "description": "`privatelink_endpoints_service_serverless` Describes the list of all Serverless PrivateLink Endpoint Service resource.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n## Example with AWS\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testServerlessInstance = new mongodbatlas.ServerlessInstance(\"testServerlessInstance\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    providerSettingsBackingProviderName: \"AWS\",\n    providerSettingsProviderName: \"SERVERLESS\",\n    providerSettingsRegionName: \"US_EAST_1\",\n    continuousBackupEnabled: true,\n});\nconst testPrivatelinkEndpointsServiceServerless = mongodbatlas.getPrivatelinkEndpointsServiceServerlessOutput({\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: testServerlessInstance.name,\n});\nconst testPrivatelinkEndpointServerless = new mongodbatlas.PrivatelinkEndpointServerless(\"testPrivatelinkEndpointServerless\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: testServerlessInstance.name,\n    providerName: \"AWS\",\n});\nconst testPrivatelinkEndpointServiceServerless = new mongodbatlas.PrivatelinkEndpointServiceServerless(\"testPrivatelinkEndpointServiceServerless\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: \"test-db\",\n    endpointId: testPrivatelinkEndpointServerless.endpointId,\n    providerName: \"AWS\",\n    comment: \"New serverless endpoint\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_serverless_instance = mongodbatlas.ServerlessInstance(\"testServerlessInstance\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    provider_settings_backing_provider_name=\"AWS\",\n    provider_settings_provider_name=\"SERVERLESS\",\n    provider_settings_region_name=\"US_EAST_1\",\n    continuous_backup_enabled=True)\ntest_privatelink_endpoints_service_serverless = mongodbatlas.get_privatelink_endpoints_service_serverless_output(project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=test_serverless_instance.name)\ntest_privatelink_endpoint_serverless = mongodbatlas.PrivatelinkEndpointServerless(\"testPrivatelinkEndpointServerless\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=test_serverless_instance.name,\n    provider_name=\"AWS\")\ntest_privatelink_endpoint_service_serverless = mongodbatlas.PrivatelinkEndpointServiceServerless(\"testPrivatelinkEndpointServiceServerless\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=\"test-db\",\n    endpoint_id=test_privatelink_endpoint_serverless.endpoint_id,\n    provider_name=\"AWS\",\n    comment=\"New serverless endpoint\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testServerlessInstance = new Mongodbatlas.ServerlessInstance(\"testServerlessInstance\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        ProviderSettingsBackingProviderName = \"AWS\",\n        ProviderSettingsProviderName = \"SERVERLESS\",\n        ProviderSettingsRegionName = \"US_EAST_1\",\n        ContinuousBackupEnabled = true,\n    });\n\n    var testPrivatelinkEndpointsServiceServerless = Mongodbatlas.GetPrivatelinkEndpointsServiceServerless.Invoke(new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = testServerlessInstance.Name,\n    });\n\n    var testPrivatelinkEndpointServerless = new Mongodbatlas.PrivatelinkEndpointServerless(\"testPrivatelinkEndpointServerless\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = testServerlessInstance.Name,\n        ProviderName = \"AWS\",\n    });\n\n    var testPrivatelinkEndpointServiceServerless = new Mongodbatlas.PrivatelinkEndpointServiceServerless(\"testPrivatelinkEndpointServiceServerless\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = \"test-db\",\n        EndpointId = testPrivatelinkEndpointServerless.EndpointId,\n        ProviderName = \"AWS\",\n        Comment = \"New serverless endpoint\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestServerlessInstance, err := mongodbatlas.NewServerlessInstance(ctx, \"testServerlessInstance\", \u0026mongodbatlas.ServerlessInstanceArgs{\n\t\t\tProjectId:                           pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tProviderSettingsBackingProviderName: pulumi.String(\"AWS\"),\n\t\t\tProviderSettingsProviderName:        pulumi.String(\"SERVERLESS\"),\n\t\t\tProviderSettingsRegionName:          pulumi.String(\"US_EAST_1\"),\n\t\t\tContinuousBackupEnabled:             pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupPrivatelinkEndpointsServiceServerlessOutput(ctx, mongodbatlas.GetPrivatelinkEndpointsServiceServerlessOutputArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tInstanceName: testServerlessInstance.Name,\n\t\t}, nil)\n\t\ttestPrivatelinkEndpointServerless, err := mongodbatlas.NewPrivatelinkEndpointServerless(ctx, \"testPrivatelinkEndpointServerless\", \u0026mongodbatlas.PrivatelinkEndpointServerlessArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tInstanceName: testServerlessInstance.Name,\n\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewPrivatelinkEndpointServiceServerless(ctx, \"testPrivatelinkEndpointServiceServerless\", \u0026mongodbatlas.PrivatelinkEndpointServiceServerlessArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tInstanceName: pulumi.String(\"test-db\"),\n\t\t\tEndpointId:   testPrivatelinkEndpointServerless.EndpointId,\n\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\tComment:      pulumi.String(\"New serverless endpoint\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ServerlessInstance;\nimport com.pulumi.mongodbatlas.ServerlessInstanceArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetPrivatelinkEndpointsServiceServerlessArgs;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServerless;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServerlessArgs;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceServerless;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceServerlessArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testServerlessInstance = new ServerlessInstance(\"testServerlessInstance\", ServerlessInstanceArgs.builder()        \n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .providerSettingsBackingProviderName(\"AWS\")\n            .providerSettingsProviderName(\"SERVERLESS\")\n            .providerSettingsRegionName(\"US_EAST_1\")\n            .continuousBackupEnabled(true)\n            .build());\n\n        final var testPrivatelinkEndpointsServiceServerless = MongodbatlasFunctions.getPrivatelinkEndpointsServiceServerless(GetPrivatelinkEndpointsServiceServerlessArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(testServerlessInstance.name())\n            .build());\n\n        var testPrivatelinkEndpointServerless = new PrivatelinkEndpointServerless(\"testPrivatelinkEndpointServerless\", PrivatelinkEndpointServerlessArgs.builder()        \n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(testServerlessInstance.name())\n            .providerName(\"AWS\")\n            .build());\n\n        var testPrivatelinkEndpointServiceServerless = new PrivatelinkEndpointServiceServerless(\"testPrivatelinkEndpointServiceServerless\", PrivatelinkEndpointServiceServerlessArgs.builder()        \n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(\"test-db\")\n            .endpointId(testPrivatelinkEndpointServerless.endpointId())\n            .providerName(\"AWS\")\n            .comment(\"New serverless endpoint\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testPrivatelinkEndpointServerless:\n    type: mongodbatlas:PrivatelinkEndpointServerless\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      instanceName: ${testServerlessInstance.name}\n      providerName: AWS\n  testPrivatelinkEndpointServiceServerless:\n    type: mongodbatlas:PrivatelinkEndpointServiceServerless\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      instanceName: test-db\n      endpointId: ${testPrivatelinkEndpointServerless.endpointId}\n      providerName: AWS\n      comment: New serverless endpoint\n  testServerlessInstance:\n    type: mongodbatlas:ServerlessInstance\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      providerSettingsBackingProviderName: AWS\n      providerSettingsProviderName: SERVERLESS\n      providerSettingsRegionName: US_EAST_1\n      continuousBackupEnabled: true\nvariables:\n  testPrivatelinkEndpointsServiceServerless:\n    fn::invoke:\n      Function: mongodbatlas:getPrivatelinkEndpointsServiceServerless\n      Arguments:\n        projectId: \u003cPROJECT_ID\u003e\n        instanceName: ${testServerlessInstance.name}\n```\n\n## Example with AZURE\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testServerlessInstance = new mongodbatlas.ServerlessInstance(\"testServerlessInstance\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    providerSettingsBackingProviderName: \"AZURE\",\n    providerSettingsProviderName: \"SERVERLESS\",\n    providerSettingsRegionName: \"US_EAST\",\n    continuousBackupEnabled: true,\n});\nconst testPrivatelinkEndpointsServiceServerless = mongodbatlas.getPrivatelinkEndpointsServiceServerlessOutput({\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: testServerlessInstance.name,\n});\nconst testPrivatelinkEndpointServerless = new mongodbatlas.PrivatelinkEndpointServerless(\"testPrivatelinkEndpointServerless\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: testServerlessInstance.name,\n    providerName: \"AZURE\",\n});\nconst testPrivatelinkEndpointServiceServerless = new mongodbatlas.PrivatelinkEndpointServiceServerless(\"testPrivatelinkEndpointServiceServerless\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: \"test-db\",\n    endpointId: testPrivatelinkEndpointServerless.endpointId,\n    providerName: \"AZURE\",\n    comment: \"New serverless endpoint\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_serverless_instance = mongodbatlas.ServerlessInstance(\"testServerlessInstance\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    provider_settings_backing_provider_name=\"AZURE\",\n    provider_settings_provider_name=\"SERVERLESS\",\n    provider_settings_region_name=\"US_EAST\",\n    continuous_backup_enabled=True)\ntest_privatelink_endpoints_service_serverless = mongodbatlas.get_privatelink_endpoints_service_serverless_output(project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=test_serverless_instance.name)\ntest_privatelink_endpoint_serverless = mongodbatlas.PrivatelinkEndpointServerless(\"testPrivatelinkEndpointServerless\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=test_serverless_instance.name,\n    provider_name=\"AZURE\")\ntest_privatelink_endpoint_service_serverless = mongodbatlas.PrivatelinkEndpointServiceServerless(\"testPrivatelinkEndpointServiceServerless\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=\"test-db\",\n    endpoint_id=test_privatelink_endpoint_serverless.endpoint_id,\n    provider_name=\"AZURE\",\n    comment=\"New serverless endpoint\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testServerlessInstance = new Mongodbatlas.ServerlessInstance(\"testServerlessInstance\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        ProviderSettingsBackingProviderName = \"AZURE\",\n        ProviderSettingsProviderName = \"SERVERLESS\",\n        ProviderSettingsRegionName = \"US_EAST\",\n        ContinuousBackupEnabled = true,\n    });\n\n    var testPrivatelinkEndpointsServiceServerless = Mongodbatlas.GetPrivatelinkEndpointsServiceServerless.Invoke(new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = testServerlessInstance.Name,\n    });\n\n    var testPrivatelinkEndpointServerless = new Mongodbatlas.PrivatelinkEndpointServerless(\"testPrivatelinkEndpointServerless\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = testServerlessInstance.Name,\n        ProviderName = \"AZURE\",\n    });\n\n    var testPrivatelinkEndpointServiceServerless = new Mongodbatlas.PrivatelinkEndpointServiceServerless(\"testPrivatelinkEndpointServiceServerless\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = \"test-db\",\n        EndpointId = testPrivatelinkEndpointServerless.EndpointId,\n        ProviderName = \"AZURE\",\n        Comment = \"New serverless endpoint\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestServerlessInstance, err := mongodbatlas.NewServerlessInstance(ctx, \"testServerlessInstance\", \u0026mongodbatlas.ServerlessInstanceArgs{\n\t\t\tProjectId:                           pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tProviderSettingsBackingProviderName: pulumi.String(\"AZURE\"),\n\t\t\tProviderSettingsProviderName:        pulumi.String(\"SERVERLESS\"),\n\t\t\tProviderSettingsRegionName:          pulumi.String(\"US_EAST\"),\n\t\t\tContinuousBackupEnabled:             pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupPrivatelinkEndpointsServiceServerlessOutput(ctx, mongodbatlas.GetPrivatelinkEndpointsServiceServerlessOutputArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tInstanceName: testServerlessInstance.Name,\n\t\t}, nil)\n\t\ttestPrivatelinkEndpointServerless, err := mongodbatlas.NewPrivatelinkEndpointServerless(ctx, \"testPrivatelinkEndpointServerless\", \u0026mongodbatlas.PrivatelinkEndpointServerlessArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tInstanceName: testServerlessInstance.Name,\n\t\t\tProviderName: pulumi.String(\"AZURE\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewPrivatelinkEndpointServiceServerless(ctx, \"testPrivatelinkEndpointServiceServerless\", \u0026mongodbatlas.PrivatelinkEndpointServiceServerlessArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tInstanceName: pulumi.String(\"test-db\"),\n\t\t\tEndpointId:   testPrivatelinkEndpointServerless.EndpointId,\n\t\t\tProviderName: pulumi.String(\"AZURE\"),\n\t\t\tComment:      pulumi.String(\"New serverless endpoint\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ServerlessInstance;\nimport com.pulumi.mongodbatlas.ServerlessInstanceArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetPrivatelinkEndpointsServiceServerlessArgs;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServerless;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServerlessArgs;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceServerless;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceServerlessArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testServerlessInstance = new ServerlessInstance(\"testServerlessInstance\", ServerlessInstanceArgs.builder()        \n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .providerSettingsBackingProviderName(\"AZURE\")\n            .providerSettingsProviderName(\"SERVERLESS\")\n            .providerSettingsRegionName(\"US_EAST\")\n            .continuousBackupEnabled(true)\n            .build());\n\n        final var testPrivatelinkEndpointsServiceServerless = MongodbatlasFunctions.getPrivatelinkEndpointsServiceServerless(GetPrivatelinkEndpointsServiceServerlessArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(testServerlessInstance.name())\n            .build());\n\n        var testPrivatelinkEndpointServerless = new PrivatelinkEndpointServerless(\"testPrivatelinkEndpointServerless\", PrivatelinkEndpointServerlessArgs.builder()        \n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(testServerlessInstance.name())\n            .providerName(\"AZURE\")\n            .build());\n\n        var testPrivatelinkEndpointServiceServerless = new PrivatelinkEndpointServiceServerless(\"testPrivatelinkEndpointServiceServerless\", PrivatelinkEndpointServiceServerlessArgs.builder()        \n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(\"test-db\")\n            .endpointId(testPrivatelinkEndpointServerless.endpointId())\n            .providerName(\"AZURE\")\n            .comment(\"New serverless endpoint\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testPrivatelinkEndpointServerless:\n    type: mongodbatlas:PrivatelinkEndpointServerless\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      instanceName: ${testServerlessInstance.name}\n      providerName: AZURE\n  testPrivatelinkEndpointServiceServerless:\n    type: mongodbatlas:PrivatelinkEndpointServiceServerless\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      instanceName: test-db\n      endpointId: ${testPrivatelinkEndpointServerless.endpointId}\n      providerName: AZURE\n      comment: New serverless endpoint\n  testServerlessInstance:\n    type: mongodbatlas:ServerlessInstance\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      providerSettingsBackingProviderName: AZURE\n      providerSettingsProviderName: SERVERLESS\n      providerSettingsRegionName: US_EAST\n      continuousBackupEnabled: true\nvariables:\n  testPrivatelinkEndpointsServiceServerless:\n    fn::invoke:\n      Function: mongodbatlas:getPrivatelinkEndpointsServiceServerless\n      Arguments:\n        projectId: \u003cPROJECT_ID\u003e\n        instanceName: ${testServerlessInstance.name}\n```\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPrivatelinkEndpointsServiceServerless.\n",
                "properties": {
                    "instanceName": {
                        "type": "string",
                        "description": "Human-readable label that identifies the serverless instance\n",
                        "willReplaceOnChanges": true
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-digit hexadecimal string that identifies the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "instanceName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPrivatelinkEndpointsServiceServerless.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "instanceName": {
                        "type": "string"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getPrivatelinkEndpointsServiceServerlessResult:getPrivatelinkEndpointsServiceServerlessResult"
                        },
                        "description": "Each element in the `result` array is one private serverless endpoint.\n"
                    }
                },
                "type": "object",
                "required": [
                    "instanceName",
                    "projectId",
                    "results",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getProject:getProject": {
            "description": "`mongodbatlas.Project` describes a MongoDB Atlas Project. This represents a project that has been created.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n{{% examples %}}\n## Example Usage\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getProject.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The unique ID for the project.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getProject.\n",
                "properties": {
                    "apiKeys": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getProjectApiKey:getProjectApiKey"
                        }
                    },
                    "clusterCount": {
                        "type": "integer",
                        "description": "The number of Atlas clusters deployed in the project.\n"
                    },
                    "created": {
                        "type": "string",
                        "description": "The ISO-8601-formatted timestamp of when Atlas created the project.\n* `teams.#.team_id` - The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.\n* `teams.#.role_names` - Each string in the array represents a project role assigned to the team. Every user associated with the team inherits these roles.\nThe following are valid roles:\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "isCollectDatabaseSpecificsStatisticsEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether to enable statistics in [cluster metrics](https://www.mongodb.com/docs/atlas/monitor-cluster-metrics/) collection for the project.\n"
                    },
                    "isDataExplorerEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether to enable Data Explorer for the project. If enabled, you can query your database with an easy to use interface.\n"
                    },
                    "isPerformanceAdvisorEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether to enable Performance Advisor and Profiler for the project. If enabled, you can analyze database logs to recommend performance improvements.\n"
                    },
                    "isRealtimePerformancePanelEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether to enable Real Time Performance Panel for the project. If enabled, you can see real time metrics from your MongoDB database.\n"
                    },
                    "isSchemaAdvisorEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether to enable Schema Advisor for the project. If enabled, you receive customized recommendations to optimize your data model and enhance performance. Disable this setting to disable schema suggestions in the [Performance Advisor](https://www.mongodb.com/docs/atlas/performance-advisor/#std-label-performance-advisor) and the [Data Explorer](https://www.mongodb.com/docs/atlas/atlas-ui/#std-label-atlas-ui).\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the project you want to create. (Cannot be changed via this Provider after creation.)\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "The ID of the organization you want to create the project within.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "regionUsageRestrictions": {
                        "type": "string",
                        "description": "If GOV_REGIONS_ONLY the project can be used for government regions only, otherwise defaults to standard regions. For more information see [MongoDB Atlas for Government](https://www.mongodb.com/docs/atlas/government/api/#creating-a-project).\n"
                    },
                    "teams": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getProjectTeam:getProjectTeam"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "apiKeys",
                    "clusterCount",
                    "created",
                    "isCollectDatabaseSpecificsStatisticsEnabled",
                    "isDataExplorerEnabled",
                    "isPerformanceAdvisorEnabled",
                    "isRealtimePerformancePanelEnabled",
                    "isSchemaAdvisorEnabled",
                    "orgId",
                    "regionUsageRestrictions",
                    "teams",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getProjectApiKey:getProjectApiKey": {
            "description": "{{% examples %}}\n## Example Usage\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectApiKey.\n",
                "properties": {
                    "apiKeyId": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "apiKeyId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectApiKey.\n",
                "properties": {
                    "apiKeyId": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of this Project API key.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "privateKey": {
                        "type": "string",
                        "description": "Private key for this Organization API key.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique identifier for the project whose API keys you want to retrieve. Use the /groups endpoint to retrieve all projects to which the authenticated user has access.\n"
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "Public key for this Organization API key.\n"
                    },
                    "roleNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Name of the role. This resource returns all the roles the user has in Atlas.\nThe following are valid roles:\n"
                    }
                },
                "type": "object",
                "required": [
                    "apiKeyId",
                    "description",
                    "privateKey",
                    "projectId",
                    "publicKey",
                    "roleNames",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getProjectApiKeys:getProjectApiKeys": {
            "inputs": {
                "description": "A collection of arguments for invoking getProjectApiKeys.\n",
                "properties": {
                    "itemsPerPage": {
                        "type": "integer",
                        "description": "Number of items to return per page, up to a maximum of 500. Defaults to `100`.\n"
                    },
                    "pageNum": {
                        "type": "integer",
                        "description": "The page to return. Defaults to `1`.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique identifier for the project whose API keys you want to retrieve. Use the /groups endpoint to retrieve all projects to which the authenticated user has access.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectApiKeys.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getProjectApiKeysResult:getProjectApiKeysResult"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "projectId",
                    "results",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getProjectInvitation:getProjectInvitation": {
            "description": "`mongodbatlas.ProjectInvitation` describes an invitation to a user to join an Atlas project.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find GROUP-ID in the official documentation.\n\n{{% examples %}}\n## Example Usage\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectInvitation.\n",
                "properties": {
                    "invitationId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the invitation in Atlas.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the project to which you invited the user.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Email address of the invited user. This is the address to which Atlas sends the invite. If the user accepts the invitation, they log in to Atlas with this username.\n"
                    }
                },
                "type": "object",
                "required": [
                    "invitationId",
                    "projectId",
                    "username"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectInvitation.\n",
                "properties": {
                    "createdAt": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when Atlas sent the invitation.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when the invitation expires. Users have 30 days to accept an invitation.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "invitationId": {
                        "type": "string"
                    },
                    "inviterUsername": {
                        "type": "string",
                        "description": "Atlas user who invited `username` to the project.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Atlas roles to assign to the invited user. If the user accepts the invitation, Atlas assigns these roles to them. Refer to the [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) for information on valid roles.\n"
                    },
                    "username": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "createdAt",
                    "expiresAt",
                    "invitationId",
                    "inviterUsername",
                    "projectId",
                    "roles",
                    "username",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getProjectIpAccessList:getProjectIpAccessList": {
            "description": "`mongodbatlas.ProjectIpAccessList` describes an IP Access List entry resource. The access list grants access from IPs, CIDRs or AWS Security Groups (if VPC Peering is enabled) to clusters within the Project.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n\u003e **IMPORTANT:**\nWhen you remove an entry from the access list, existing connections from the removed address(es) may remain open for a variable amount of time. How much time passes before Atlas closes the connection depends on several factors, including how the connection was established, the particular behavior of the application or driver using the address, and the connection protocol (e.g., TCP or UDP). This is particularly important to consider when changing an existing IP address or CIDR block as they cannot be updated via the Provider (comments can however), hence a change will force the destruction and recreation of entries.   \n\n\n{{% examples %}}\n## Example Usage\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectIpAccessList.\n",
                "properties": {
                    "awsSecurityGroup": {
                        "type": "string",
                        "description": "Unique identifier of the AWS security group to add to the access list.\n"
                    },
                    "cidrBlock": {
                        "type": "string",
                        "description": "Range of IP addresses in CIDR notation to be added to the access list.\n"
                    },
                    "ipAddress": {
                        "type": "string",
                        "description": "Single IP address to be added to the access list.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique identifier for the project to which you want to add one or more access list entries.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectIpAccessList.\n",
                "properties": {
                    "awsSecurityGroup": {
                        "type": "string"
                    },
                    "cidrBlock": {
                        "type": "string"
                    },
                    "comment": {
                        "type": "string",
                        "description": "Comment to add to the access list entry.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "ipAddress": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "awsSecurityGroup",
                    "cidrBlock",
                    "comment",
                    "ipAddress",
                    "projectId",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getProjects:getProjects": {
            "description": "`mongodbatlas.getProjects` describe all Projects. This represents projects that have been created.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testRolesOrgId = mongodbatlas.getRolesOrgId({});\nconst testProject = new mongodbatlas.Project(\"testProject\", {\n    orgId: testRolesOrgId.then(testRolesOrgId =\u003e testRolesOrgId.orgId),\n    teams: [\n        {\n            teamId: \"5e0fa8c99ccf641c722fe645\",\n            roleNames: [\"GROUP_OWNER\"],\n        },\n        {\n            teamId: \"5e1dd7b4f2a30ba80a70cd4rw\",\n            roleNames: [\n                \"GROUP_READ_ONLY\",\n                \"GROUP_DATA_ACCESS_READ_WRITE\",\n            ],\n        },\n    ],\n    apiKeys: [{\n        apiKeyId: \"61003b299dda8d54a9d7d10c\",\n        roleNames: [\"GROUP_READ_ONLY\"],\n    }],\n});\nconst testProjects = mongodbatlas.getProjects({\n    pageNum: 1,\n    itemsPerPage: 5,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_roles_org_id = mongodbatlas.get_roles_org_id()\ntest_project = mongodbatlas.Project(\"testProject\",\n    org_id=test_roles_org_id.org_id,\n    teams=[\n        mongodbatlas.ProjectTeamArgs(\n            team_id=\"5e0fa8c99ccf641c722fe645\",\n            role_names=[\"GROUP_OWNER\"],\n        ),\n        mongodbatlas.ProjectTeamArgs(\n            team_id=\"5e1dd7b4f2a30ba80a70cd4rw\",\n            role_names=[\n                \"GROUP_READ_ONLY\",\n                \"GROUP_DATA_ACCESS_READ_WRITE\",\n            ],\n        ),\n    ],\n    api_keys=[mongodbatlas.ProjectApiKeyArgs(\n        api_key_id=\"61003b299dda8d54a9d7d10c\",\n        role_names=[\"GROUP_READ_ONLY\"],\n    )])\ntest_projects = mongodbatlas.get_projects(page_num=1,\n    items_per_page=5)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testRolesOrgId = Mongodbatlas.GetRolesOrgId.Invoke();\n\n    var testProject = new Mongodbatlas.Project(\"testProject\", new()\n    {\n        OrgId = testRolesOrgId.Apply(getRolesOrgIdResult =\u003e getRolesOrgIdResult.OrgId),\n        Teams = new[]\n        {\n            new Mongodbatlas.Inputs.ProjectTeamArgs\n            {\n                TeamId = \"5e0fa8c99ccf641c722fe645\",\n                RoleNames = new[]\n                {\n                    \"GROUP_OWNER\",\n                },\n            },\n            new Mongodbatlas.Inputs.ProjectTeamArgs\n            {\n                TeamId = \"5e1dd7b4f2a30ba80a70cd4rw\",\n                RoleNames = new[]\n                {\n                    \"GROUP_READ_ONLY\",\n                    \"GROUP_DATA_ACCESS_READ_WRITE\",\n                },\n            },\n        },\n        ApiKeys = new[]\n        {\n            new Mongodbatlas.Inputs.ProjectApiKeyArgs\n            {\n                ApiKeyId = \"61003b299dda8d54a9d7d10c\",\n                RoleNames = new[]\n                {\n                    \"GROUP_READ_ONLY\",\n                },\n            },\n        },\n    });\n\n    var testProjects = Mongodbatlas.GetProjects.Invoke(new()\n    {\n        PageNum = 1,\n        ItemsPerPage = 5,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestRolesOrgId, err := mongodbatlas.GetRolesOrgId(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewProject(ctx, \"testProject\", \u0026mongodbatlas.ProjectArgs{\n\t\t\tOrgId: *pulumi.String(testRolesOrgId.OrgId),\n\t\t\tTeams: mongodbatlas.ProjectTeamArray{\n\t\t\t\t\u0026mongodbatlas.ProjectTeamArgs{\n\t\t\t\t\tTeamId: pulumi.String(\"5e0fa8c99ccf641c722fe645\"),\n\t\t\t\t\tRoleNames: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_OWNER\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.ProjectTeamArgs{\n\t\t\t\t\tTeamId: pulumi.String(\"5e1dd7b4f2a30ba80a70cd4rw\"),\n\t\t\t\t\tRoleNames: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_READ_ONLY\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_READ_WRITE\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tApiKeys: mongodbatlas.ProjectApiKeyTypeArray{\n\t\t\t\t\u0026mongodbatlas.ProjectApiKeyTypeArgs{\n\t\t\t\t\tApiKeyId: pulumi.String(\"61003b299dda8d54a9d7d10c\"),\n\t\t\t\t\tRoleNames: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_READ_ONLY\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.LookupProjects(ctx, \u0026mongodbatlas.LookupProjectsArgs{\n\t\t\tPageNum:      pulumi.IntRef(1),\n\t\t\tItemsPerPage: pulumi.IntRef(5),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.Project;\nimport com.pulumi.mongodbatlas.ProjectArgs;\nimport com.pulumi.mongodbatlas.inputs.ProjectTeamArgs;\nimport com.pulumi.mongodbatlas.inputs.ProjectApiKeyArgs;\nimport com.pulumi.mongodbatlas.inputs.GetProjectsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var testRolesOrgId = MongodbatlasFunctions.getRolesOrgId();\n\n        var testProject = new Project(\"testProject\", ProjectArgs.builder()        \n            .orgId(testRolesOrgId.applyValue(getRolesOrgIdResult -\u003e getRolesOrgIdResult.orgId()))\n            .teams(            \n                ProjectTeamArgs.builder()\n                    .teamId(\"5e0fa8c99ccf641c722fe645\")\n                    .roleNames(\"GROUP_OWNER\")\n                    .build(),\n                ProjectTeamArgs.builder()\n                    .teamId(\"5e1dd7b4f2a30ba80a70cd4rw\")\n                    .roleNames(                    \n                        \"GROUP_READ_ONLY\",\n                        \"GROUP_DATA_ACCESS_READ_WRITE\")\n                    .build())\n            .apiKeys(ProjectApiKeyArgs.builder()\n                .apiKeyId(\"61003b299dda8d54a9d7d10c\")\n                .roleNames(\"GROUP_READ_ONLY\")\n                .build())\n            .build());\n\n        final var testProjects = MongodbatlasFunctions.getProjects(GetProjectsArgs.builder()\n            .pageNum(1)\n            .itemsPerPage(5)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testProject:\n    type: mongodbatlas:Project\n    properties:\n      orgId: ${testRolesOrgId.orgId}\n      teams:\n        - teamId: 5e0fa8c99ccf641c722fe645\n          roleNames:\n            - GROUP_OWNER\n        - teamId: 5e1dd7b4f2a30ba80a70cd4rw\n          roleNames:\n            - GROUP_READ_ONLY\n            - GROUP_DATA_ACCESS_READ_WRITE\n      apiKeys:\n        - apiKeyId: 61003b299dda8d54a9d7d10c\n          roleNames:\n            - GROUP_READ_ONLY\nvariables:\n  testRolesOrgId:\n    fn::invoke:\n      Function: mongodbatlas:getRolesOrgId\n      Arguments: {}\n  testProjects:\n    fn::invoke:\n      Function: mongodbatlas:getProjects\n      Arguments:\n        pageNum: 1\n        itemsPerPage: 5\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getProjects.\n",
                "properties": {
                    "itemsPerPage": {
                        "type": "integer",
                        "description": "Number of items to return per page, up to a maximum of 500. Defaults to `100`.\n"
                    },
                    "pageNum": {
                        "type": "integer",
                        "description": "The page to return. Defaults to `1`.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getProjects.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "results": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getProjectsResult:getProjectsResult"
                        }
                    },
                    "totalCount": {
                        "type": "integer"
                    }
                },
                "type": "object",
                "required": [
                    "results",
                    "totalCount",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getRolesOrgId:getRolesOrgId": {
            "description": "`mongodbatlas.Project` describes a MongoDB Atlas Roles Org ID. This represents a Roles Org ID.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Using project_id attribute to query\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = mongodbatlas.getRolesOrgId({});\nexport const orgId = test.then(test =\u003e test.orgId);\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.get_roles_org_id()\npulumi.export(\"orgId\", test.org_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Mongodbatlas.GetRolesOrgId.Invoke();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"orgId\"] = test.Apply(getRolesOrgIdResult =\u003e getRolesOrgIdResult.OrgId),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := mongodbatlas.GetRolesOrgId(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"orgId\", test.OrgId)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getRolesOrgId();\n\n        ctx.export(\"orgId\", test.applyValue(getRolesOrgIdResult -\u003e getRolesOrgIdResult.orgId()));\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getRolesOrgId\n      Arguments: {}\noutputs:\n  orgId: ${test.orgId}\n```\n{{% /example %}}\n{{% /examples %}}",
            "outputs": {
                "description": "A collection of values returned by getRolesOrgId.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "The ID of the organization you want to retrieve associated to an API Key.\n"
                    }
                },
                "type": "object",
                "required": [
                    "orgId",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getSearchIndex:getSearchIndex": {
            "description": "`mongodbatlas.SearchIndex` describe a single search indexes. This represents a single search index that have been created.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = mongodbatlas.getSearchIndex({\n    clusterName: \"\u003cCLUSTER_NAME\u003e\",\n    indexId: \"\u003cINDEX_ID\",\n    projectId: \"\u003cPROJECT_ID\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.get_search_index(cluster_name=\"\u003cCLUSTER_NAME\u003e\",\n    index_id=\"\u003cINDEX_ID\",\n    project_id=\"\u003cPROJECT_ID\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Mongodbatlas.GetSearchIndex.Invoke(new()\n    {\n        ClusterName = \"\u003cCLUSTER_NAME\u003e\",\n        IndexId = \"\u003cINDEX_ID\",\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.LookupSearchIndex(ctx, \u0026mongodbatlas.LookupSearchIndexArgs{\n\t\t\tClusterName: \"\u003cCLUSTER_NAME\u003e\",\n\t\t\tIndexId:     \"\u003cINDEX_ID\",\n\t\t\tProjectId:   \"\u003cPROJECT_ID\u003e\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetSearchIndexArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getSearchIndex(GetSearchIndexArgs.builder()\n            .clusterName(\"\u003cCLUSTER_NAME\u003e\")\n            .indexId(\"\u003cINDEX_ID\")\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getSearchIndex\n      Arguments:\n        clusterName: \u003cCLUSTER_NAME\u003e\n        indexId: \u003cINDEX_ID\n        projectId: \u003cPROJECT_ID\u003e\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getSearchIndex.\n",
                "properties": {
                    "analyzer": {
                        "type": "string",
                        "description": "[Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.\n"
                    },
                    "analyzers": {
                        "type": "string",
                        "description": "[Custom analyzers](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-custom-analyzers) to use in this index (this is an array of objects).\n"
                    },
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the cluster containing the collection with one or more Atlas Search indexes.\n"
                    },
                    "collectionName": {
                        "type": "string",
                        "description": "Name of the collection the index is on.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "Name of the database the collection is in.\n"
                    },
                    "indexId": {
                        "type": "string",
                        "description": "The unique identifier of the Atlas Search index. Use the `mongodbatlas.getSearchIndexes`datasource to find the IDs of all Atlas Search indexes.\n"
                    },
                    "mappingsDynamic": {
                        "type": "boolean",
                        "description": "Flag indicating whether the index uses dynamic or static mappings.\n"
                    },
                    "mappingsFields": {
                        "type": "string",
                        "description": "Object containing one or more field specifications.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the index.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier for the [project](https://docs.atlas.mongodb.com/organizations-projects/#std-label-projects) that contains the specified cluster.\n"
                    },
                    "searchAnalyzer": {
                        "type": "string",
                        "description": "[Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when searching the index.\n"
                    },
                    "status": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "indexId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSearchIndex.\n",
                "properties": {
                    "analyzer": {
                        "type": "string",
                        "description": "[Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.\n"
                    },
                    "analyzers": {
                        "type": "string",
                        "description": "[Custom analyzers](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-custom-analyzers) to use in this index (this is an array of objects).\n"
                    },
                    "clusterName": {
                        "type": "string"
                    },
                    "collectionName": {
                        "type": "string",
                        "description": "Name of the collection the index is on.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "Name of the database the collection is in.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "indexId": {
                        "type": "string"
                    },
                    "mappingsDynamic": {
                        "type": "boolean",
                        "description": "Flag indicating whether the index uses dynamic or static mappings.\n"
                    },
                    "mappingsFields": {
                        "type": "string",
                        "description": "Object containing one or more field specifications.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the index.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "searchAnalyzer": {
                        "type": "string",
                        "description": "[Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when searching the index.\n"
                    },
                    "status": {
                        "type": "string"
                    },
                    "synonyms": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getSearchIndexSynonym:getSearchIndexSynonym"
                        },
                        "description": "Synonyms mapping definition to use in this index.\n* `synonyms.#.name` - Name of the [synonym mapping definition](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-ref).\n* `synonyms.#.source_collection` - Name of the source MongoDB collection for the synonyms.\n* `synonyms.#.analyzer` - Name of the [analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use with this synonym mapping.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "indexId",
                    "projectId",
                    "status",
                    "synonyms",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getSearchIndexes:getSearchIndexes": {
            "description": "`mongodbatlas.getSearchIndexes` describe all search indexes. This represents search indexes that have been created.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetSearchIndexArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getSearchIndex(GetSearchIndexArgs.builder()\n            .clusterName(\"\u003cCLUSTER_NAME\u003e\")\n            .collectionName(\"\u003cCOLLECTION_NAME\u003e\")\n            .databaseName(\"\u003cDATABASE_NAME\u003e\")\n            .itemsPerPage(100)\n            .pageNum(1)\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getSearchIndex\n      Arguments:\n        clusterName: \u003cCLUSTER_NAME\u003e\n        collectionName: \u003cCOLLECTION_NAME\u003e\n        databaseName: \u003cDATABASE_NAME\u003e\n        itemsPerPage: 100\n        pageNum: 1\n        projectId: \u003cPROJECT_ID\u003e\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getSearchIndexes.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "Name of the cluster containing the collection with one or more Atlas Search indexes.\n"
                    },
                    "collectionName": {
                        "type": "string",
                        "description": "Name of the collection with one or more Atlas Search indexes.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "(Required) Name of the database the collection is in.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer",
                        "description": "Number of items that Atlas returns per page, up to a maximum of 500.\n"
                    },
                    "pageNum": {
                        "type": "integer",
                        "description": "Page number, starting with one, that Atlas returns of the total number of objects.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique identifier for the [project](https://docs.atlas.mongodb.com/organizations-projects/#std-label-projects) that contains the specified cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "collectionName",
                    "database",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSearchIndexes.\n",
                "properties": {
                    "clusterName": {
                        "type": "string"
                    },
                    "collectionName": {
                        "type": "string",
                        "description": "(Required) Name of the collection the index is on.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "(Required) Name of the database the collection is in.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getSearchIndexesResult:getSearchIndexesResult"
                        },
                        "description": "A list where each represents a search index.\n"
                    },
                    "totalCount": {
                        "type": "integer",
                        "description": "Represents the total of the search indexes\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "collectionName",
                    "database",
                    "projectId",
                    "results",
                    "totalCount",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getServerlessInstance:getServerlessInstance": {
            "description": "`mongodbatlas.ServerlessInstance` describe a single serverless instance. This represents a single serverless instance that have been created.\n\u003e **NOTE:**  Serverless instances do not support some Atlas features at this time.\nFor a full list of unsupported features, see [Serverless Instance Limitations](https://docs.atlas.mongodb.com/reference/serverless-instance-limitations/).\n \n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n### Basic\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testTwo = mongodbatlas.getServerlessInstance({\n    name: \"\u003cSERVERLESS_INSTANCE_NAME\u003e\",\n    projectId: \"\u003cPROJECT_ID \u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_two = mongodbatlas.get_serverless_instance(name=\"\u003cSERVERLESS_INSTANCE_NAME\u003e\",\n    project_id=\"\u003cPROJECT_ID \u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testTwo = Mongodbatlas.GetServerlessInstance.Invoke(new()\n    {\n        Name = \"\u003cSERVERLESS_INSTANCE_NAME\u003e\",\n        ProjectId = \"\u003cPROJECT_ID \u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.LookupServerlessInstance(ctx, \u0026mongodbatlas.LookupServerlessInstanceArgs{\n\t\t\tName:      \"\u003cSERVERLESS_INSTANCE_NAME\u003e\",\n\t\t\tProjectId: \"\u003cPROJECT_ID \u003e\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetServerlessInstanceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var testTwo = MongodbatlasFunctions.getServerlessInstance(GetServerlessInstanceArgs.builder()\n            .name(\"\u003cSERVERLESS_INSTANCE_NAME\u003e\")\n            .projectId(\"\u003cPROJECT_ID \u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  testTwo:\n    fn::invoke:\n      Function: mongodbatlas:getServerlessInstance\n      Arguments:\n        name: \u003cSERVERLESS_INSTANCE_NAME\u003e\n        projectId: \u003cPROJECT_ID \u003e\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getServerlessInstance.\n",
                "properties": {
                    "continuousBackupEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether the serverless instance uses Serverless Continuous Backup.\n"
                    },
                    "links": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getServerlessInstanceLink:getServerlessInstanceLink"
                        }
                    },
                    "name": {
                        "type": "string",
                        "description": "Human-readable label that identifies your serverless instance.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the project that contains your serverless instance.\n"
                    },
                    "stateName": {
                        "type": "string",
                        "description": "Stage of deployment of this serverless instance when the resource made its request.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getServerlessInstance.\n",
                "properties": {
                    "connectionStringsStandardSrv": {
                        "type": "string",
                        "description": "Public `mongodb+srv://` connection string that you can use to connect to this serverless instance.\n"
                    },
                    "continuousBackupEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether the serverless instance uses Serverless Continuous Backup.\n"
                    },
                    "createDate": {
                        "type": "string"
                    },
                    "id": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the serverless instance.\n"
                    },
                    "links": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getServerlessInstanceLink:getServerlessInstanceLink"
                        }
                    },
                    "mongoDbVersion": {
                        "type": "string",
                        "description": "Version of MongoDB that the serverless instance runs, in `\u003cmajor version\u003e`.`\u003cminor version\u003e` format.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "providerSettingsBackingProviderName": {
                        "type": "string",
                        "description": "Cloud service provider on which MongoDB Cloud provisioned the serverless instance.\n"
                    },
                    "providerSettingsProviderName": {
                        "type": "string",
                        "description": "Cloud service provider that applies to the provisioned the serverless instance.\n"
                    },
                    "providerSettingsRegionName": {
                        "type": "string",
                        "description": "Human-readable label that identifies the physical location of your MongoDB serverless instance. The region you choose can affect network latency for clients accessing your databases.\n"
                    },
                    "stateName": {
                        "type": "string",
                        "description": "Stage of deployment of this serverless instance when the resource made its request.\n"
                    },
                    "terminationProtectionEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "connectionStringsStandardSrv",
                    "continuousBackupEnabled",
                    "createDate",
                    "id",
                    "links",
                    "mongoDbVersion",
                    "name",
                    "projectId",
                    "providerSettingsBackingProviderName",
                    "providerSettingsProviderName",
                    "providerSettingsRegionName",
                    "stateName",
                    "terminationProtectionEnabled"
                ]
            }
        },
        "mongodbatlas:index/getServerlessInstances:getServerlessInstances": {
            "description": "`mongodbatlas.getServerlessInstances` describe all serverless instances. This represents serverless instances that have been created for the specified group id.\n\n\u003e **NOTE:**  Serverless instances do not support some Atlas features at this time.\nFor a full list of unsupported features, see [Serverless Instance Limitations](https://docs.atlas.mongodb.com/reference/serverless-instance-limitations/).\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst dataServerless = mongodbatlas.getServerlessInstances({\n    projectId: \"\u003cPROJECT_ID\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ndata_serverless = mongodbatlas.get_serverless_instances(project_id=\"\u003cPROJECT_ID\")\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var dataServerless = Mongodbatlas.GetServerlessInstances.Invoke(new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.LookupServerlessInstances(ctx, \u0026mongodbatlas.LookupServerlessInstancesArgs{\n\t\t\tProjectId: \"\u003cPROJECT_ID\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetServerlessInstancesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var dataServerless = MongodbatlasFunctions.getServerlessInstances(GetServerlessInstancesArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  dataServerless:\n    fn::invoke:\n      Function: mongodbatlas:getServerlessInstances\n      Arguments:\n        projectId: \u003cPROJECT_ID\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getServerlessInstances.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "Unique identifier for the [project](https://docs.atlas.mongodb.com/organizations-projects/#std-label-projects) that contains the specified cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getServerlessInstances.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getServerlessInstancesResult:getServerlessInstancesResult"
                        },
                        "description": "A list where each represents a search index.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId",
                    "results",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getTeam:getTeam": {
            "inputs": {
                "description": "A collection of arguments for invoking getTeam.\n",
                "properties": {
                    "name": {
                        "type": "string"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "teamId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "orgId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getTeam.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "teamId": {
                        "type": "string"
                    },
                    "usernames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "orgId",
                    "teamId",
                    "usernames",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getTeams:getTeams": {
            "inputs": {
                "description": "A collection of arguments for invoking getTeams.\n",
                "properties": {
                    "name": {
                        "type": "string"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "teamId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "orgId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getTeams.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "teamId": {
                        "type": "string"
                    },
                    "usernames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "orgId",
                    "teamId",
                    "usernames",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getThirdPartyIntegration:getThirdPartyIntegration": {
            "description": "`mongodbatlas.ThirdPartyIntegration` describe a Third-Party Integration Settings for the given type.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testFlowdock = new mongodbatlas.ThirdPartyIntegration(\"testFlowdock\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    type: \"FLOWDOCK\",\n    flowName: \"\u003cFLOW-NAME\u003e\",\n    apiToken: \"\u003cAPI-TOKEN\u003e\",\n    orgName: \"\u003cORG-NAME\u003e\",\n});\nconst test = mongodbatlas.getThirdPartyIntegrationOutput({\n    projectId: testFlowdock.projectId,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_flowdock = mongodbatlas.ThirdPartyIntegration(\"testFlowdock\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    type=\"FLOWDOCK\",\n    flow_name=\"\u003cFLOW-NAME\u003e\",\n    api_token=\"\u003cAPI-TOKEN\u003e\",\n    org_name=\"\u003cORG-NAME\u003e\")\ntest = mongodbatlas.get_third_party_integration_output(project_id=test_flowdock.project_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testFlowdock = new Mongodbatlas.ThirdPartyIntegration(\"testFlowdock\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        Type = \"FLOWDOCK\",\n        FlowName = \"\u003cFLOW-NAME\u003e\",\n        ApiToken = \"\u003cAPI-TOKEN\u003e\",\n        OrgName = \"\u003cORG-NAME\u003e\",\n    });\n\n    var test = Mongodbatlas.GetThirdPartyIntegration.Invoke(new()\n    {\n        ProjectId = testFlowdock.ProjectId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestFlowdock, err := mongodbatlas.NewThirdPartyIntegration(ctx, \"testFlowdock\", \u0026mongodbatlas.ThirdPartyIntegrationArgs{\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tType:      pulumi.String(\"FLOWDOCK\"),\n\t\t\tFlowName:  pulumi.String(\"\u003cFLOW-NAME\u003e\"),\n\t\t\tApiToken:  pulumi.String(\"\u003cAPI-TOKEN\u003e\"),\n\t\t\tOrgName:   pulumi.String(\"\u003cORG-NAME\u003e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupThirdPartyIntegrationOutput(ctx, mongodbatlas.GetThirdPartyIntegrationOutputArgs{\n\t\t\tProjectId: testFlowdock.ProjectId,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ThirdPartyIntegration;\nimport com.pulumi.mongodbatlas.ThirdPartyIntegrationArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetThirdPartyIntegrationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testFlowdock = new ThirdPartyIntegration(\"testFlowdock\", ThirdPartyIntegrationArgs.builder()        \n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .type(\"FLOWDOCK\")\n            .flowName(\"\u003cFLOW-NAME\u003e\")\n            .apiToken(\"\u003cAPI-TOKEN\u003e\")\n            .orgName(\"\u003cORG-NAME\u003e\")\n            .build());\n\n        final var test = MongodbatlasFunctions.getThirdPartyIntegration(GetThirdPartyIntegrationArgs.builder()\n            .projectId(testFlowdock.projectId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testFlowdock:\n    type: mongodbatlas:ThirdPartyIntegration\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      type: FLOWDOCK\n      flowName: \u003cFLOW-NAME\u003e\n      apiToken: \u003cAPI-TOKEN\u003e\n      orgName: \u003cORG-NAME\u003e\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getThirdPartyIntegration\n      Arguments:\n        projectId: ${testFlowdock.projectId}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getThirdPartyIntegration.\n",
                "properties": {
                    "enabled": {
                        "type": "boolean",
                        "description": "Whether your cluster has Prometheus enabled.\n"
                    },
                    "microsoftTeamsWebhookUrl": {
                        "type": "string",
                        "description": "Your Microsoft Teams incoming webhook URL.\n",
                        "secret": true
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to get all Third-Party service integrations\n"
                    },
                    "scheme": {
                        "type": "string",
                        "description": "Your Prometheus protocol scheme configured for requests.\n"
                    },
                    "serviceDiscovery": {
                        "type": "string",
                        "description": "Indicates which service discovery method is used, either file or http.\n",
                        "secret": true
                    },
                    "type": {
                        "type": "string",
                        "description": "Third-Party service integration type\n* PAGER_DUTY\n* DATADOG\n* NEW_RELIC*\n* OPS_GENIE\n* VICTOR_OPS\n* FLOWDOCK*\n* WEBHOOK\n* MICROSOFT_TEAMS\n* PROMETHEUS\n"
                    },
                    "userName": {
                        "type": "string",
                        "description": "Your Prometheus username.\n",
                        "secret": true
                    }
                },
                "type": "object",
                "required": [
                    "projectId",
                    "type"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getThirdPartyIntegration.\n",
                "properties": {
                    "accountId": {
                        "type": "string",
                        "description": "Unique identifier of your New Relic account.\n"
                    },
                    "apiKey": {
                        "type": "string",
                        "description": "Your API Key.\n",
                        "secret": true
                    },
                    "apiToken": {
                        "type": "string",
                        "description": "Your API Token.\n",
                        "secret": true
                    },
                    "channelName": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Whether your cluster has Prometheus enabled.\n"
                    },
                    "flowName": {
                        "type": "string",
                        "description": "Your Flowdock Flow name.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "licenseKey": {
                        "type": "string",
                        "description": "Your License Key.\n",
                        "secret": true
                    },
                    "microsoftTeamsWebhookUrl": {
                        "type": "string",
                        "description": "Your Microsoft Teams incoming webhook URL.\n",
                        "secret": true
                    },
                    "orgName": {
                        "type": "string",
                        "description": "Your Flowdock organization name.\n"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "readToken": {
                        "type": "string",
                        "description": "Your Insights Query Key.\n",
                        "secret": true
                    },
                    "region": {
                        "type": "string",
                        "description": "Indicates which API URL to use, either US or EU. Opsgenie will use US by default.\n"
                    },
                    "routingKey": {
                        "type": "string",
                        "description": "An optional field for your Routing Key.\n",
                        "secret": true
                    },
                    "scheme": {
                        "type": "string",
                        "description": "Your Prometheus protocol scheme configured for requests.\n"
                    },
                    "secret": {
                        "type": "string",
                        "description": "An optional field for your webhook secret.\n",
                        "secret": true
                    },
                    "serviceDiscovery": {
                        "type": "string",
                        "description": "Indicates which service discovery method is used, either file or http.\n",
                        "secret": true
                    },
                    "serviceKey": {
                        "type": "string",
                        "description": "Your Service Key.\n",
                        "secret": true
                    },
                    "teamName": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string",
                        "description": "Property equal to its own integration type\n"
                    },
                    "url": {
                        "type": "string",
                        "description": "Your webhook URL.\n"
                    },
                    "userName": {
                        "type": "string",
                        "description": "Your Prometheus username.\n",
                        "secret": true
                    },
                    "writeToken": {
                        "type": "string",
                        "description": "Your Insights Insert Key.\n",
                        "secret": true
                    }
                },
                "type": "object",
                "required": [
                    "accountId",
                    "apiKey",
                    "apiToken",
                    "channelName",
                    "flowName",
                    "licenseKey",
                    "orgName",
                    "projectId",
                    "readToken",
                    "region",
                    "routingKey",
                    "secret",
                    "serviceKey",
                    "teamName",
                    "type",
                    "url",
                    "writeToken",
                    "id"
                ]
            }
        },
        "mongodbatlas:index/getThirdPartyIntegrations:getThirdPartyIntegrations": {
            "description": "`mongodbatlas.getThirdPartyIntegrations` describe all Third-Party Integration Settings. This represents two Third-Party services `PAGER_DUTY` and `FLOWDOCK`\napplied across the project. \n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testPagerDuty = new mongodbatlas.ThirdPartyIntegration(\"testPagerDuty\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    type: \"PAGER_DUTY\",\n    serviceKey: \"\u003cPAGER-DUTY-SERVICE-KEY\u003e\",\n});\nconst testFlowdock = new mongodbatlas.ThirdPartyIntegration(\"testFlowdock\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    type: \"FLOWDOCK\",\n    flowName: \"\u003cFLOW-NAME\u003e\",\n    apiToken: \"\u003cAPI-TOKEN\u003e\",\n    orgName: \"\u003cORG-NAME\u003e\",\n});\nconst test = mongodbatlas.getThirdPartyIntegrationsOutput({\n    projectId: testPagerDuty.projectId,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_pager_duty = mongodbatlas.ThirdPartyIntegration(\"testPagerDuty\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    type=\"PAGER_DUTY\",\n    service_key=\"\u003cPAGER-DUTY-SERVICE-KEY\u003e\")\ntest_flowdock = mongodbatlas.ThirdPartyIntegration(\"testFlowdock\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    type=\"FLOWDOCK\",\n    flow_name=\"\u003cFLOW-NAME\u003e\",\n    api_token=\"\u003cAPI-TOKEN\u003e\",\n    org_name=\"\u003cORG-NAME\u003e\")\ntest = mongodbatlas.get_third_party_integrations_output(project_id=test_pager_duty.project_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testPagerDuty = new Mongodbatlas.ThirdPartyIntegration(\"testPagerDuty\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        Type = \"PAGER_DUTY\",\n        ServiceKey = \"\u003cPAGER-DUTY-SERVICE-KEY\u003e\",\n    });\n\n    var testFlowdock = new Mongodbatlas.ThirdPartyIntegration(\"testFlowdock\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        Type = \"FLOWDOCK\",\n        FlowName = \"\u003cFLOW-NAME\u003e\",\n        ApiToken = \"\u003cAPI-TOKEN\u003e\",\n        OrgName = \"\u003cORG-NAME\u003e\",\n    });\n\n    var test = Mongodbatlas.GetThirdPartyIntegrations.Invoke(new()\n    {\n        ProjectId = testPagerDuty.ProjectId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestPagerDuty, err := mongodbatlas.NewThirdPartyIntegration(ctx, \"testPagerDuty\", \u0026mongodbatlas.ThirdPartyIntegrationArgs{\n\t\t\tProjectId:  pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tType:       pulumi.String(\"PAGER_DUTY\"),\n\t\t\tServiceKey: pulumi.String(\"\u003cPAGER-DUTY-SERVICE-KEY\u003e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewThirdPartyIntegration(ctx, \"testFlowdock\", \u0026mongodbatlas.ThirdPartyIntegrationArgs{\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tType:      pulumi.String(\"FLOWDOCK\"),\n\t\t\tFlowName:  pulumi.String(\"\u003cFLOW-NAME\u003e\"),\n\t\t\tApiToken:  pulumi.String(\"\u003cAPI-TOKEN\u003e\"),\n\t\t\tOrgName:   pulumi.String(\"\u003cORG-NAME\u003e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupThirdPartyIntegrationsOutput(ctx, mongodbatlas.GetThirdPartyIntegrationsOutputArgs{\n\t\t\tProjectId: testPagerDuty.ProjectId,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ThirdPartyIntegration;\nimport com.pulumi.mongodbatlas.ThirdPartyIntegrationArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetThirdPartyIntegrationsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testPagerDuty = new ThirdPartyIntegration(\"testPagerDuty\", ThirdPartyIntegrationArgs.builder()        \n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .type(\"PAGER_DUTY\")\n            .serviceKey(\"\u003cPAGER-DUTY-SERVICE-KEY\u003e\")\n            .build());\n\n        var testFlowdock = new ThirdPartyIntegration(\"testFlowdock\", ThirdPartyIntegrationArgs.builder()        \n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .type(\"FLOWDOCK\")\n            .flowName(\"\u003cFLOW-NAME\u003e\")\n            .apiToken(\"\u003cAPI-TOKEN\u003e\")\n            .orgName(\"\u003cORG-NAME\u003e\")\n            .build());\n\n        final var test = MongodbatlasFunctions.getThirdPartyIntegrations(GetThirdPartyIntegrationsArgs.builder()\n            .projectId(testPagerDuty.projectId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testPagerDuty:\n    type: mongodbatlas:ThirdPartyIntegration\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      type: PAGER_DUTY\n      serviceKey: \u003cPAGER-DUTY-SERVICE-KEY\u003e\n  testFlowdock:\n    type: mongodbatlas:ThirdPartyIntegration\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      type: FLOWDOCK\n      flowName: \u003cFLOW-NAME\u003e\n      apiToken: \u003cAPI-TOKEN\u003e\n      orgName: \u003cORG-NAME\u003e\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getThirdPartyIntegrations\n      Arguments:\n        projectId: ${testPagerDuty.projectId}\n```\n{{% /example %}}\n{{% /examples %}}",
            "inputs": {
                "description": "A collection of arguments for invoking getThirdPartyIntegrations.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to get all Third-Party service integrations\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getThirdPartyIntegrations.\n",
                "properties": {
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "(Required) ID of the Atlas project the Third-Party Service Integration belongs to.\n"
                    },
                    "results": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getThirdPartyIntegrationsResult:getThirdPartyIntegrationsResult"
                        },
                        "description": "A list where each represents a Third-Party service integration.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId",
                    "results",
                    "id"
                ]
            }
        }
    }
}