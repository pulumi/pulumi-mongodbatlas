{
    "name": "mongodbatlas",
    "description": "A Pulumi package for creating and managing mongodbatlas cloud resources.",
    "keywords": [
        "pulumi",
        "mongodbatlas"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`mongodbatlas` Terraform Provider](https://github.com/mongodb/terraform-provider-mongodbatlas).",
    "repository": "https://github.com/pulumi/pulumi-mongodbatlas",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "packageReferences": {
                "Pulumi": "3.*"
            },
            "compatibility": "tfbridge20",
            "respectSchemaVersion": true
        },
        "go": {
            "importBasePath": "github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas",
            "generateResourceContainerTypes": true,
            "generateExtraInputTypes": true,
            "respectSchemaVersion": true
        },
        "nodejs": {
            "packageDescription": "A Pulumi package for creating and managing mongodbatlas cloud resources.",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/mongodb/terraform-provider-mongodbatlas)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-mongodbatlas` repo](https://github.com/pulumi/pulumi-mongodbatlas/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-mongodbatlas` repo](https://github.com/mongodb/terraform-provider-mongodbatlas/issues).",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^10.0.0"
            },
            "compatibility": "tfbridge20",
            "disableUnionOutputTypes": true,
            "respectSchemaVersion": true
        },
        "python": {
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            },
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/mongodb/terraform-provider-mongodbatlas)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-mongodbatlas` repo](https://github.com/pulumi/pulumi-mongodbatlas/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-mongodbatlas` repo](https://github.com/mongodb/terraform-provider-mongodbatlas/issues).",
            "compatibility": "tfbridge20",
            "respectSchemaVersion": true,
            "pyproject": {
                "enabled": true
            }
        }
    },
    "config": {
        "variables": {
            "assumeRole": {
                "$ref": "#/types/mongodbatlas:config/assumeRole:assumeRole"
            },
            "awsAccessKeyId": {
                "type": "string",
                "description": "AWS API Access Key.\n"
            },
            "awsSecretAccessKey": {
                "type": "string",
                "description": "AWS API Access Secret Key.\n"
            },
            "awsSessionToken": {
                "type": "string",
                "description": "AWS Security Token Service provided session token.\n"
            },
            "baseUrl": {
                "type": "string",
                "description": "MongoDB Atlas Base URL\n"
            },
            "isMongodbgovCloud": {
                "type": "boolean",
                "description": "MongoDB Atlas Base URL default to gov\n"
            },
            "privateKey": {
                "type": "string",
                "description": "MongoDB Atlas Programmatic Private Key\n",
                "secret": true
            },
            "publicKey": {
                "type": "string",
                "description": "MongoDB Atlas Programmatic Public Key\n"
            },
            "realmBaseUrl": {
                "type": "string",
                "description": "MongoDB Realm Base URL\n"
            },
            "region": {
                "type": "string",
                "description": "Region where secret is stored as part of AWS Secret Manager.\n"
            },
            "secretName": {
                "type": "string",
                "description": "Name of secret stored in AWS Secret Manager.\n"
            },
            "stsEndpoint": {
                "type": "string",
                "description": "AWS Security Token Service endpoint. Required for cross-AWS region or cross-AWS account secrets.\n"
            }
        }
    },
    "types": {
        "mongodbatlas:config/assumeRole:assumeRole": {
            "properties": {
                "duration": {
                    "type": "string",
                    "description": "The duration, between 15 minutes and 12 hours, of the role session. Valid time units are ns, us (or Âµs), ms, s, h, or m.\n"
                },
                "externalId": {
                    "type": "string",
                    "description": "A unique identifier that might be required when you assume a role in another account.\n"
                },
                "policy": {
                    "type": "string",
                    "description": "IAM Policy JSON describing further restricting permissions for the IAM Role being assumed.\n"
                },
                "policyArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Amazon Resource Names (ARNs) of IAM Policies describing further restricting permissions for the IAM Role being assumed.\n"
                },
                "roleArn": {
                    "type": "string",
                    "description": "Amazon Resource Name (ARN) of an IAM Role to assume prior to making API calls.\n"
                },
                "sessionName": {
                    "type": "string",
                    "description": "An identifier for the assumed role session.\n"
                },
                "sourceIdentity": {
                    "type": "string",
                    "description": "Source identity specified by the principal assuming the role.\n"
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Assume role session tags.\n"
                },
                "transitiveTagKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Assume role session tag keys to pass to any subsequent sessions.\n"
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/AdvancedClusterAdvancedConfiguration:AdvancedClusterAdvancedConfiguration": {
            "properties": {
                "defaultReadConcern": {
                    "type": "string",
                    "description": "[Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/). **(DEPRECATED)** MongoDB 5.0 and later clusters default to `local`. To use a custom read concern level, please refer to your driver documentation.\n",
                    "deprecationMessage": "This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown"
                },
                "defaultWriteConcern": {
                    "type": "string",
                    "description": "[Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).\n"
                },
                "failIndexKeyTooLong": {
                    "type": "boolean",
                    "description": "When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them. **(DEPRECATED)** This parameter has been removed as of [MongoDB 4.4](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.failIndexKeyTooLong).\n",
                    "deprecationMessage": "This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown"
                },
                "javascriptEnabled": {
                    "type": "boolean",
                    "description": "When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.\n"
                },
                "minimumEnabledTlsProtocol": {
                    "type": "string",
                    "description": "Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:\n\n- TLS1_0\n- TLS1_1\n- TLS1_2\n"
                },
                "noTableScan": {
                    "type": "boolean",
                    "description": "When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.\n"
                },
                "oplogMinRetentionHours": {
                    "type": "integer",
                    "description": "Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.\n* **Note**  A minimum oplog retention is required when seeking to change a cluster's class to Local NVMe SSD. To learn more and for latest guidance see [`oplogMinRetentionHours`](https://www.mongodb.com/docs/manual/core/replica-set-oplog/#std-label-replica-set-minimum-oplog-size)\n"
                },
                "oplogSizeMb": {
                    "type": "integer",
                    "description": "The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.\n"
                },
                "sampleRefreshIntervalBiConnector": {
                    "type": "integer",
                    "description": "Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.\n"
                },
                "sampleSizeBiConnector": {
                    "type": "integer",
                    "description": "Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.\n"
                },
                "transactionLifetimeLimitSeconds": {
                    "type": "integer",
                    "description": "Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "defaultReadConcern",
                        "defaultWriteConcern",
                        "failIndexKeyTooLong",
                        "javascriptEnabled",
                        "minimumEnabledTlsProtocol",
                        "noTableScan",
                        "oplogSizeMb",
                        "sampleRefreshIntervalBiConnector",
                        "sampleSizeBiConnector",
                        "transactionLifetimeLimitSeconds"
                    ]
                }
            }
        },
        "mongodbatlas:index/AdvancedClusterBiConnectorConfig:AdvancedClusterBiConnectorConfig": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether or not BI Connector for Atlas is enabled on the cluster.l\n*\n- Set to `true` to enable BI Connector for Atlas.\n- Set to `false` to disable BI Connector for Atlas.\n"
                },
                "readPreference": {
                    "type": "string",
                    "description": "Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).\n\n- Set to \"primary\" to have BI Connector for Atlas read from the primary.\n\n- Set to \"secondary\" to have BI Connector for Atlas read from a secondary member. Default if there are no analytics nodes in the cluster.\n\n- Set to \"analytics\" to have BI Connector for Atlas read from an analytics node. Default if the cluster contains analytics nodes.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "enabled",
                        "readPreference"
                    ]
                }
            }
        },
        "mongodbatlas:index/AdvancedClusterConnectionString:AdvancedClusterConnectionString": {
            "properties": {
                "private": {
                    "type": "string",
                    "description": "[Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.\n"
                },
                "privateEndpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/AdvancedClusterConnectionStringPrivateEndpoint:AdvancedClusterConnectionStringPrivateEndpoint"
                    },
                    "description": "Private endpoint connection strings. Each object describes the connection strings you can use to connect to this cluster through a private endpoint. Atlas returns this parameter only if you deployed a private endpoint to all regions to which you deployed this cluster's nodes.\n- `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.\n- `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in DNS . Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don't need to: Append the seed list or Change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn't, use `connection_strings.private_endpoint[n].connection_string`\n- `connection_strings.private_endpoint.#.srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster supports it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[n].srvConnectionString.\n- `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.\n- `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`\n- `connection_strings.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.\n- `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.\n- `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.\n"
                },
                "privateSrv": {
                    "type": "string",
                    "description": "[Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.\n"
                },
                "standard": {
                    "type": "string",
                    "description": "Public mongodb:// connection string for this cluster.\n"
                },
                "standardSrv": {
                    "type": "string",
                    "description": "Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you donât need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesnât  , use connectionStrings.standard.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "private",
                        "privateEndpoints",
                        "privateSrv",
                        "standard",
                        "standardSrv"
                    ]
                }
            }
        },
        "mongodbatlas:index/AdvancedClusterConnectionStringPrivateEndpoint:AdvancedClusterConnectionStringPrivateEndpoint": {
            "properties": {
                "connectionString": {
                    "type": "string"
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/AdvancedClusterConnectionStringPrivateEndpointEndpoint:AdvancedClusterConnectionStringPrivateEndpointEndpoint"
                    }
                },
                "srvConnectionString": {
                    "type": "string"
                },
                "srvShardOptimizedConnectionString": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "connectionString",
                        "endpoints",
                        "srvConnectionString",
                        "srvShardOptimizedConnectionString",
                        "type"
                    ]
                }
            }
        },
        "mongodbatlas:index/AdvancedClusterConnectionStringPrivateEndpointEndpoint:AdvancedClusterConnectionStringPrivateEndpointEndpoint": {
            "properties": {
                "endpointId": {
                    "type": "string"
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud service provider on which the servers are provisioned.\nThe possible values are:\n\n- `AWS` - Amazon AWS\n- `GCP` - Google Cloud Platform\n- `AZURE` - Microsoft Azure\n- `TENANT` - M2 or M5 multi-tenant cluster. Use `replication_specs.#.region_configs.#.backing_provider_name` to set the cloud service provider.\n"
                },
                "region": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "endpointId",
                        "providerName",
                        "region"
                    ]
                }
            }
        },
        "mongodbatlas:index/AdvancedClusterLabel:AdvancedClusterLabel": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key that you want to write.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value that you want to write.\n\n\u003e **NOTE:** MongoDB Atlas doesn't display your labels.\n"
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/AdvancedClusterReplicationSpec:AdvancedClusterReplicationSpec": {
            "properties": {
                "containerId": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "externalId": {
                    "type": "string"
                },
                "id": {
                    "type": "string",
                    "deprecationMessage": "This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown"
                },
                "numShards": {
                    "type": "integer",
                    "description": "Provide this value if you set a `cluster_type` of SHARDED or GEOSHARDED. Omit this value if you selected a `cluster_type` of REPLICASET. This API resource accepts 1 through 50, inclusive. This parameter defaults to 1. If you specify a `num_shards` value of 1 and a `cluster_type` of SHARDED, Atlas deploys a single-shard [sharded cluster](https://docs.atlas.mongodb.com/reference/glossary/#std-term-sharded-cluster). Don't create a sharded cluster with a single shard for production environments. Single-shard sharded clusters don't provide the same benefits as multi-shard configurations.\nIf you are upgrading a replica set to a sharded cluster, you cannot increase the number of shards in the same update request. You should wait until after the cluster has completed upgrading to sharded and you have reconnected all application clients to the MongoDB router before adding additional shards. Otherwise, your data might become inconsistent once MongoDB Cloud begins distributing data across shards. To learn more, see [Convert a replica set to a sharded cluster documentation](https://www.mongodb.com/docs/atlas/scale-cluster/#convert-a-replica-set-to-a-sharded-cluster) and [Convert a replica set to a sharded cluster tutorial](https://www.mongodb.com/docs/upcoming/tutorial/convert-replica-set-to-replicated-shard-cluster). **(DEPRECATED)** To learn more, see the 1.18.0 Upgrade Guide.\n",
                    "deprecationMessage": "This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown"
                },
                "regionConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/AdvancedClusterReplicationSpecRegionConfig:AdvancedClusterReplicationSpecRegionConfig"
                    },
                    "description": "Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the zone in a Global Cluster. If clusterType is GEOSHARDED, this value indicates the zone that the given shard belongs to and can be used to configure Global Cluster backup policies.\n"
                },
                "zoneName": {
                    "type": "string",
                    "description": "Name for the zone in a Global Cluster.\n"
                }
            },
            "type": "object",
            "required": [
                "regionConfigs"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "containerId",
                        "externalId",
                        "id",
                        "regionConfigs",
                        "zoneId"
                    ]
                }
            }
        },
        "mongodbatlas:index/AdvancedClusterReplicationSpecRegionConfig:AdvancedClusterReplicationSpecRegionConfig": {
            "properties": {
                "analyticsAutoScaling": {
                    "$ref": "#/types/mongodbatlas:index/AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling:AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling",
                    "description": "Configuration for the Collection of settings that configures analytics-auto-scaling information for the cluster. The values for the `analytics_auto_scaling` parameter must be the same for all `region_configs` in all `replication_specs`. See below\n"
                },
                "analyticsSpecs": {
                    "$ref": "#/types/mongodbatlas:index/AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs:AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs",
                    "description": "Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. Analytics nodes handle analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only and can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary). If you don't specify this parameter, no analytics nodes deploy to this region. See below\n"
                },
                "autoScaling": {
                    "$ref": "#/types/mongodbatlas:index/AdvancedClusterReplicationSpecRegionConfigAutoScaling:AdvancedClusterReplicationSpecRegionConfigAutoScaling",
                    "description": "Configuration for the Collection of settings that configures auto-scaling information for the cluster. The values for the `auto_scaling` parameter must be the same for all `region_configs` in all `replication_specs`. See below\n"
                },
                "backingProviderName": {
                    "type": "string",
                    "description": "Cloud service provider on which you provision the host for a multi-tenant cluster. Use this only when a `provider_name` is `TENANT` and `instance_size` of a specs is `M2` or `M5`.\n"
                },
                "electableSpecs": {
                    "$ref": "#/types/mongodbatlas:index/AdvancedClusterReplicationSpecRegionConfigElectableSpecs:AdvancedClusterReplicationSpecRegionConfigElectableSpecs",
                    "description": "Hardware specifications for electable nodes in the region. Electable nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you do not specify this option, no electable nodes are deployed to the region. See below\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Election priority of the region. For regions with only read-only nodes, set this value to 0.\n* If you have multiple `region_configs` objects (your cluster is multi-region or multi-cloud), they must have priorities in descending order. The highest priority is 7.\n* If your region has set `region_configs.#.electable_specs.0.node_count` to 1 or higher, it must have a priority of exactly one (1) less than another region in the `replication_specs.#.region_configs.#` array. The highest-priority region must have a priority of 7. The lowest possible priority is 1.\n"
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud service provider on which the servers are provisioned.\nThe possible values are:\n\n- `AWS` - Amazon AWS\n- `GCP` - Google Cloud Platform\n- `AZURE` - Microsoft Azure\n- `TENANT` - M2 or M5 multi-tenant cluster. Use `replication_specs.#.region_configs.#.backing_provider_name` to set the cloud service provider.\n"
                },
                "readOnlySpecs": {
                    "$ref": "#/types/mongodbatlas:index/AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs:AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs",
                    "description": "Hardware specifications for read-only nodes in the region. Read-only nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you don't specify this parameter, no read-only nodes are deployed to the region. See below\n"
                },
                "regionName": {
                    "type": "string",
                    "description": "Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).\n"
                }
            },
            "type": "object",
            "required": [
                "priority",
                "providerName",
                "regionName"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "analyticsAutoScaling",
                        "analyticsSpecs",
                        "autoScaling",
                        "electableSpecs",
                        "priority",
                        "providerName",
                        "readOnlySpecs",
                        "regionName"
                    ]
                }
            }
        },
        "mongodbatlas:index/AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling:AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling": {
            "properties": {
                "computeEnabled": {
                    "type": "boolean"
                },
                "computeMaxInstanceSize": {
                    "type": "string",
                    "description": "Maximum instance size to which your cluster can automatically scale (such as M40). Atlas requires this parameter if `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_enabled` is true.\n"
                },
                "computeMinInstanceSize": {
                    "type": "string",
                    "description": "Minimum instance size to which your cluster can automatically scale (such as M10). Atlas requires this parameter if `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_scale_down_enabled` is true.\n"
                },
                "computeScaleDownEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the instance size may scale down. Atlas requires this parameter if `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_enabled` : true. If you enable this option, specify a value for `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_min_instance_size`.\n"
                },
                "diskGbEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether this cluster enables disk auto-scaling. This parameter defaults to true.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "computeEnabled",
                        "computeMaxInstanceSize",
                        "computeMinInstanceSize",
                        "computeScaleDownEnabled",
                        "diskGbEnabled"
                    ]
                }
            }
        },
        "mongodbatlas:index/AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs:AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs": {
            "properties": {
                "diskIops": {
                    "type": "integer",
                    "description": "Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. Define this attribute only if you selected AWS as your cloud service provider, `instance_size` is set to \"M30\" or greater (not including \"Mxx_NVME\" tiers), and `ebs_volume_type` is \"PROVISIONED\". You can't set this attribute for a multi-cloud cluster.\n"
                },
                "diskSizeGb": {
                    "type": "number",
                    "description": "Storage capacity that the host's root volume possesses expressed in gigabytes. This value must be equal for all shards and node types. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier. **Note:** Using `disk_size_gb` with Standard IOPS could lead to errors and configuration issues. Therefore, it should be used only with the Provisioned IOPS volume type. When using Provisioned IOPS, the disk_size_gb parameter specifies the storage capacity, but the IOPS are set independently. Ensuring that `disk_size_gb` is used exclusively with Provisioned IOPS will help avoid these issues.\n"
                },
                "ebsVolumeType": {
                    "type": "string",
                    "description": "Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:\n* `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.\n* `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.\n"
                },
                "instanceSize": {
                    "type": "string",
                    "description": "Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size. Electable nodes and read-only nodes (known as \"base nodes\") within a single shard must use the same instance size. Analytics nodes can scale independently from base nodes within a shard. Both base nodes and analytics nodes can scale independently from their equivalents in other shards.\n"
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "Number of nodes of the given type for MongoDB Atlas to deploy to the region.\n"
                }
            },
            "type": "object",
            "required": [
                "instanceSize"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "diskIops",
                        "diskSizeGb",
                        "ebsVolumeType",
                        "instanceSize"
                    ]
                }
            }
        },
        "mongodbatlas:index/AdvancedClusterReplicationSpecRegionConfigAutoScaling:AdvancedClusterReplicationSpecRegionConfigAutoScaling": {
            "properties": {
                "computeEnabled": {
                    "type": "boolean"
                },
                "computeMaxInstanceSize": {
                    "type": "string",
                    "description": "Maximum instance size to which your cluster can automatically scale (such as M40). Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_enabled` is true.\n"
                },
                "computeMinInstanceSize": {
                    "type": "string",
                    "description": "Minimum instance size to which your cluster can automatically scale (such as M10). Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_scale_down_enabled` is true.\n"
                },
                "computeScaleDownEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the instance size may scale down. Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_enabled` : true. If you enable this option, specify a value for `replication_specs.#.region_configs.#.auto_scaling.0.compute_min_instance_size`.\n"
                },
                "diskGbEnabled": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "computeEnabled",
                        "computeMaxInstanceSize",
                        "computeMinInstanceSize",
                        "computeScaleDownEnabled",
                        "diskGbEnabled"
                    ]
                }
            }
        },
        "mongodbatlas:index/AdvancedClusterReplicationSpecRegionConfigElectableSpecs:AdvancedClusterReplicationSpecRegionConfigElectableSpecs": {
            "properties": {
                "diskIops": {
                    "type": "integer",
                    "description": "Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. Define this attribute only if you selected AWS as your cloud service provider, `instance_size` is set to \"M30\" or greater (not including \"Mxx_NVME\" tiers), and `ebs_volume_type` is \"PROVISIONED\". You can't set this attribute for a multi-cloud cluster.\n"
                },
                "diskSizeGb": {
                    "type": "number",
                    "description": "Storage capacity that the host's root volume possesses expressed in gigabytes. This value must be equal for all shards and node types. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier. **Note:** Using `disk_size_gb` with Standard IOPS could lead to errors and configuration issues. Therefore, it should be used only with the Provisioned IOPS volume type. When using Provisioned IOPS, the disk_size_gb parameter specifies the storage capacity, but the IOPS are set independently. Ensuring that `disk_size_gb` is used exclusively with Provisioned IOPS will help avoid these issues.\n"
                },
                "ebsVolumeType": {
                    "type": "string",
                    "description": "Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:\n* `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.\n* `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.\n"
                },
                "instanceSize": {
                    "type": "string",
                    "description": "Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size. Electable nodes and read-only nodes (known as \"base nodes\") within a single shard must use the same instance size. Analytics nodes can scale independently from base nodes within a shard. Both base nodes and analytics nodes can scale independently from their equivalents in other shards.\n"
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "Number of nodes of the given type for MongoDB Atlas to deploy to the region.\n"
                }
            },
            "type": "object",
            "required": [
                "instanceSize"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "diskIops",
                        "diskSizeGb",
                        "ebsVolumeType",
                        "instanceSize"
                    ]
                }
            }
        },
        "mongodbatlas:index/AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs:AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs": {
            "properties": {
                "diskIops": {
                    "type": "integer",
                    "description": "Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. Define this attribute only if you selected AWS as your cloud service provider, `instance_size` is set to \"M30\" or greater (not including \"Mxx_NVME\" tiers), and `ebs_volume_type` is \"PROVISIONED\". You can't set this attribute for a multi-cloud cluster. This parameter defaults to the cluster tier's standard IOPS value.\n"
                },
                "diskSizeGb": {
                    "type": "number",
                    "description": "Storage capacity that the host's root volume possesses expressed in gigabytes. This value must be equal for all shards and node types. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier. **Note:** Using `disk_size_gb` with Standard IOPS could lead to errors and configuration issues. Therefore, it should be used only with the Provisioned IOPS volume type. When using Provisioned IOPS, the disk_size_gb parameter specifies the storage capacity, but the IOPS are set independently. Ensuring that `disk_size_gb` is used exclusively with Provisioned IOPS will help avoid these issues.\n"
                },
                "ebsVolumeType": {
                    "type": "string",
                    "description": "Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:\n* `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.\n* `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.\n"
                },
                "instanceSize": {
                    "type": "string",
                    "description": "Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size. Electable nodes and read-only nodes (known as \"base nodes\") within a single shard must use the same instance size. Analytics nodes can scale independently from base nodes within a shard. Both base nodes and analytics nodes can scale independently from their equivalents in other shards.\n"
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "Number of nodes of the given type for MongoDB Atlas to deploy to the region.\n"
                }
            },
            "type": "object",
            "required": [
                "instanceSize"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "diskIops",
                        "diskSizeGb",
                        "ebsVolumeType",
                        "instanceSize"
                    ]
                }
            }
        },
        "mongodbatlas:index/AdvancedClusterTag:AdvancedClusterTag": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "Constant that defines the set of the tag.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Variable that belongs to the set of the tag.\n\nTo learn more, see [Resource Tags](https://dochub.mongodb.org/core/add-cluster-tag-atlas).\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ]
        },
        "mongodbatlas:index/AlertConfigurationMatcher:AlertConfigurationMatcher": {
            "properties": {
                "fieldName": {
                    "type": "string",
                    "description": "Name of the field in the target object to match on.\n\n| Host alerts         | Replica set alerts  |  Sharded cluster alerts |\n|:----------           |:-------------       |:------                 |\n| `TYPE_NAME`         | `REPLICA_SET_NAME`  | `CLUSTER_NAME`          |\n| `HOSTNAME`          | `SHARD_NAME`        | `SHARD_NAME`            |\n| `PORT`              | `CLUSTER_NAME`      |                         |\n| `HOSTNAME_AND_PORT` |                     |                         |\n| `REPLICA_SET_NAME`  |                     |                         |\n\n\n\nAll other types of alerts do not support matchers.\n"
                },
                "operator": {
                    "type": "string"
                },
                "value": {
                    "type": "string",
                    "description": "Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:\n- `PRIMARY`\n- `SECONDARY`\n- `STANDALONE`\n- `CONFIG`\n- `MONGOS`\n"
                }
            },
            "type": "object",
            "required": [
                "fieldName",
                "operator",
                "value"
            ]
        },
        "mongodbatlas:index/AlertConfigurationMetricThresholdConfig:AlertConfigurationMetricThresholdConfig": {
            "properties": {
                "metricName": {
                    "type": "string",
                    "description": "Name of the metric to check. The full list being quite large, please refer to atlas docs [here for general metrics](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types) and [here for serverless metrics](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-create-config/#serverless-measurements)\n"
                },
                "mode": {
                    "type": "string",
                    "description": "This must be set to AVERAGE. Atlas computes the current metric value as an average.\n"
                },
                "operator": {
                    "type": "string"
                },
                "threshold": {
                    "type": "number"
                },
                "units": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "metricName"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "metricName",
                        "threshold"
                    ]
                }
            }
        },
        "mongodbatlas:index/AlertConfigurationNotification:AlertConfigurationNotification": {
            "properties": {
                "apiToken": {
                    "type": "string",
                    "description": "Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.\n",
                    "secret": true
                },
                "channelName": {
                    "type": "string",
                    "description": "Slack channel name. Required for the SLACK notifications type.\n"
                },
                "datadogApiKey": {
                    "type": "string",
                    "description": "Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.\n",
                    "secret": true
                },
                "datadogRegion": {
                    "type": "string",
                    "description": "Region that indicates which API URL to use. See the `datadogRegion` field in the `notifications` request parameter of [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Alert-Configurations/operation/createAlertConfiguration) for more details. The default Datadog region is US.\n"
                },
                "delayMin": {
                    "type": "integer",
                    "description": "Number of minutes to wait after an alert condition is detected before sending out the first notification.\n"
                },
                "emailAddress": {
                    "type": "string",
                    "description": "Email address to which alert notifications are sent. Required for the EMAIL notifications type.\n"
                },
                "emailEnabled": {
                    "type": "boolean",
                    "description": "Flag indicating email notifications should be sent. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.\n"
                },
                "integrationId": {
                    "type": "string",
                    "description": "The ID of the associated integration, the credentials of which to use for requests.\n"
                },
                "intervalMin": {
                    "type": "integer",
                    "description": "Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5. **NOTE** `PAGER_DUTY`, `VICTOR_OPS`, and `OPS_GENIE` notifications do not return this value. The notification interval must be configured and managed within each external service.\n"
                },
                "microsoftTeamsWebhookUrl": {
                    "type": "string",
                    "description": "Microsoft Teams Webhook Uniform Resource Locator (URL) that MongoDB Cloud needs to send this notification via Microsoft Teams. Required if `type_name` is `MICROSOFT_TEAMS`. If the URL later becomes invalid, MongoDB Cloud sends an email to the project owners. If the key remains invalid, MongoDB Cloud removes it.\n",
                    "secret": true
                },
                "mobileNumber": {
                    "type": "string",
                    "description": "Mobile number to which alert notifications are sent. Required for the SMS notifications type.\n"
                },
                "notifierId": {
                    "type": "string",
                    "description": "The notifier ID is a system-generated unique identifier assigned to each notification method. This is needed when updating third-party notifications without requiring explicit authentication credentials.\n"
                },
                "opsGenieApiKey": {
                    "type": "string",
                    "description": "Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.\n",
                    "secret": true
                },
                "opsGenieRegion": {
                    "type": "string",
                    "description": "Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Optional. One or more roles that receive the configured alert. If you include this field, Atlas sends alerts only to users assigned the roles you specify in the array. If you omit this field, Atlas sends alerts to users assigned any role. This parameter is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.\nAccepted values are:\n\n| Project roles                   | Organization roles  |\n|:----------                      |:-----------         |\n| `GROUP_CLUSTER_MANAGER`         | `ORG_OWNER`         |\n| `GROUP_DATA_ACCESS_ADMIN`       | `ORG_MEMBER`        |\n| `GROUP_DATA_ACCESS_READ_ONLY`   | `ORG_GROUP_CREATOR` |\n| `GROUP_DATA_ACCESS_READ_WRITE`  | `ORG_BILLING_ADMIN` |\n| `GROUP_OWNER`                   | `ORG_READ_ONLY`     |\n| `GROUP_READ_ONLY`               |                     |\n"
                },
                "serviceKey": {
                    "type": "string",
                    "description": "PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.\n",
                    "secret": true
                },
                "smsEnabled": {
                    "type": "boolean",
                    "description": "Flag indicating if text message notifications should be sent to this user's mobile phone. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.\n"
                },
                "teamId": {
                    "type": "string",
                    "description": "Unique identifier of a team.\n"
                },
                "teamName": {
                    "type": "string",
                    "description": "Label for the team that receives this notification.\n"
                },
                "typeName": {
                    "type": "string",
                    "description": "Type of alert notification.\nAccepted values are:\n- `DATADOG`\n- `EMAIL`\n- `GROUP` (Project)\n- `OPS_GENIE`\n- `ORG`\n- `PAGER_DUTY`\n- `SLACK`\n- `SMS`\n- `TEAM`\n- `USER`\n- `VICTOR_OPS`\n- `WEBHOOK`\n- `MICROSOFT_TEAMS`\n"
                },
                "username": {
                    "type": "string",
                    "description": "Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.\n"
                },
                "victorOpsApiKey": {
                    "type": "string",
                    "description": "VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.\n",
                    "secret": true
                },
                "victorOpsRoutingKey": {
                    "type": "string",
                    "description": "VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.\n",
                    "secret": true
                },
                "webhookSecret": {
                    "type": "string",
                    "description": "Optional authentication secret for the `WEBHOOK` notifications type.\n",
                    "secret": true
                },
                "webhookUrl": {
                    "type": "string",
                    "description": "Target URL  for the `WEBHOOK` notifications type.\n",
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "typeName"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "delayMin",
                        "emailEnabled",
                        "intervalMin",
                        "notifierId",
                        "smsEnabled",
                        "teamName",
                        "typeName"
                    ]
                }
            }
        },
        "mongodbatlas:index/AlertConfigurationThresholdConfig:AlertConfigurationThresholdConfig": {
            "properties": {
                "operator": {
                    "type": "string"
                },
                "threshold": {
                    "type": "number"
                },
                "units": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "threshold"
                    ]
                }
            }
        },
        "mongodbatlas:index/BackupCompliancePolicyOnDemandPolicyItem:BackupCompliancePolicyOnDemandPolicyItem": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are\n"
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n"
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.\n"
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.\n"
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "frequencyInterval",
                        "frequencyType",
                        "id",
                        "retentionUnit",
                        "retentionValue"
                    ]
                }
            }
        },
        "mongodbatlas:index/BackupCompliancePolicyPolicyItemDaily:BackupCompliancePolicyPolicyItemDaily": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are\n"
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n"
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.\n"
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.\n"
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "frequencyInterval",
                        "frequencyType",
                        "id",
                        "retentionUnit",
                        "retentionValue"
                    ]
                }
            }
        },
        "mongodbatlas:index/BackupCompliancePolicyPolicyItemHourly:BackupCompliancePolicyPolicyItemHourly": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are\n"
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n"
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.\n"
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.\n"
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "frequencyInterval",
                        "frequencyType",
                        "id",
                        "retentionUnit",
                        "retentionValue"
                    ]
                }
            }
        },
        "mongodbatlas:index/BackupCompliancePolicyPolicyItemMonthly:BackupCompliancePolicyPolicyItemMonthly": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are\n"
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n"
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.\n"
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.\n"
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "frequencyInterval",
                        "frequencyType",
                        "id",
                        "retentionUnit",
                        "retentionValue"
                    ]
                }
            }
        },
        "mongodbatlas:index/BackupCompliancePolicyPolicyItemWeekly:BackupCompliancePolicyPolicyItemWeekly": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are\n"
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n"
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.\n"
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.\n"
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "frequencyInterval",
                        "frequencyType",
                        "id",
                        "retentionUnit",
                        "retentionValue"
                    ]
                }
            }
        },
        "mongodbatlas:index/BackupCompliancePolicyPolicyItemYearly:BackupCompliancePolicyPolicyItemYearly": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are\n"
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n"
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.\n"
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.\n"
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "frequencyInterval",
                        "frequencyType",
                        "id",
                        "retentionUnit",
                        "retentionValue"
                    ]
                }
            }
        },
        "mongodbatlas:index/CloudBackupScheduleCopySetting:CloudBackupScheduleCopySetting": {
            "properties": {
                "cloudProvider": {
                    "type": "string",
                    "description": "Human-readable label that identifies the cloud provider that stores the snapshot copy. i.e. \"AWS\" \"AZURE\" \"GCP\"\n"
                },
                "frequencies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List that describes which types of snapshots to copy. i.e. \"HOURLY\" \"DAILY\" \"WEEKLY\" \"MONTHLY\" \"ON_DEMAND\"\n"
                },
                "regionName": {
                    "type": "string",
                    "description": "Target region to copy snapshots belonging to replicationSpecId to. Please supply the 'Atlas Region' which can be found under https://www.mongodb.com/docs/atlas/reference/cloud-providers/ 'regions' link\n"
                },
                "replicationSpecId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the replication object for a zone in a cluster. For global clusters, there can be multiple zones to choose from. For sharded clusters and replica set clusters, there is only one zone in the cluster. To find the Replication Spec Id, consult the replicationSpecs array returned from [Return One Multi-Cloud Cluster in One Project](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Clusters/operation/getCluster). **(DEPRECATED)** Use `zone_id` instead. To learn more, see the 1.18.0 upgrade guide.\n",
                    "deprecationMessage": "This parameter is deprecated. Please transition to `copy_settings.#.zone_id`. To learn more, see our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown"
                },
                "shouldCopyOplogs": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to copy the oplogs to the target region. You can use the oplogs to perform point-in-time restores.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the zone in a cluster. For global clusters, there can be multiple zones to choose from. For sharded clusters and replica set clusters, there is only one zone in the cluster. To find appropriate value for `zone_id`, do a GET request to Return One Cluster from One Project and consult the replicationSpecs array Return One Cluster From One Project. Alternately, use `mongodbatlas.AdvancedCluster` data source or resource and reference `replication_specs.#.zone_id`.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "cloudProvider",
                        "frequencies",
                        "regionName",
                        "replicationSpecId",
                        "shouldCopyOplogs",
                        "zoneId"
                    ]
                }
            }
        },
        "mongodbatlas:index/CloudBackupScheduleExport:CloudBackupScheduleExport": {
            "properties": {
                "exportBucketId": {
                    "type": "string",
                    "description": "Unique identifier of the mongodbatlas.CloudBackupSnapshotExportBucket export_bucket_id value.\n"
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the export snapshot item.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "exportBucketId",
                        "frequencyType"
                    ]
                }
            }
        },
        "mongodbatlas:index/CloudBackupSchedulePolicyItemDaily:CloudBackupSchedulePolicyItemDaily": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (daily in this case). The only supported value for daily policies is `1` day.\n"
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For daily policies, the frequency type is defined as `daily`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n"
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.\n"
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`.  Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the hourly policy item specifies a retention of two days, the daily retention policy must specify two days or greater.\n"
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "frequencyInterval",
                        "frequencyType",
                        "id",
                        "retentionUnit",
                        "retentionValue"
                    ]
                }
            }
        },
        "mongodbatlas:index/CloudBackupSchedulePolicyItemHourly:CloudBackupSchedulePolicyItemHourly": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (hourly in this case). The supported values for hourly policies are `1`, `2`, `4`, `6`, `8` or `12` hours. Note that `12` hours is the only accepted value for NVMe clusters.\n"
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For hourly policies, the frequency type is defined as `hourly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n"
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.\n"
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`.\n"
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "frequencyInterval",
                        "frequencyType",
                        "id",
                        "retentionUnit",
                        "retentionValue"
                    ]
                }
            }
        },
        "mongodbatlas:index/CloudBackupSchedulePolicyItemMonthly:CloudBackupSchedulePolicyItemMonthly": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are\n"
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n"
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.\n"
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.\n"
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "frequencyInterval",
                        "frequencyType",
                        "id",
                        "retentionUnit",
                        "retentionValue"
                    ]
                }
            }
        },
        "mongodbatlas:index/CloudBackupSchedulePolicyItemWeekly:CloudBackupSchedulePolicyItemWeekly": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (weekly in this case). The supported values for weekly policies are `1` through `7`, where `1` represents Monday and `7` represents Sunday.\n"
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For weekly policies, the frequency type is defined as `weekly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n"
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.\n"
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`. Weekly policy must have retention of at least 7 days or 1 week. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the daily policy item specifies a retention of two weeks, the weekly retention policy must specify two weeks or greater.\n"
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "frequencyInterval",
                        "frequencyType",
                        "id",
                        "retentionUnit",
                        "retentionValue"
                    ]
                }
            }
        },
        "mongodbatlas:index/CloudBackupSchedulePolicyItemYearly:CloudBackupSchedulePolicyItemYearly": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are\n"
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n"
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.\n"
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.\n"
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "frequencyInterval",
                        "frequencyType",
                        "id",
                        "retentionUnit",
                        "retentionValue"
                    ]
                }
            }
        },
        "mongodbatlas:index/CloudBackupSnapshotExportJobComponent:CloudBackupSnapshotExportJobComponent": {
            "properties": {
                "exportId": {
                    "type": "string",
                    "description": "_Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.\n"
                },
                "replicaSetName": {
                    "type": "string",
                    "description": "_Returned for sharded clusters only._ Unique identifier of the export job for the replica set.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "exportId",
                        "replicaSetName"
                    ]
                }
            }
        },
        "mongodbatlas:index/CloudBackupSnapshotExportJobCustomData:CloudBackupSnapshotExportJobCustomData": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "Required if you want to include custom data using `custom_data` in the metadata file uploaded to the bucket. Key to include in the metadata file that Atlas uploads to the bucket when the export job finishes.\n",
                    "willReplaceOnChanges": true
                },
                "value": {
                    "type": "string",
                    "description": "Required if you specify `key`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ]
        },
        "mongodbatlas:index/CloudBackupSnapshotMember:CloudBackupSnapshotMember": {
            "properties": {
                "cloudProvider": {
                    "type": "string",
                    "description": "Cloud provider that stores this snapshot.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier for the sharded cluster snapshot.\n"
                },
                "replicaSetName": {
                    "type": "string",
                    "description": "Label given to a shard or config server from which Atlas took this snapshot.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "cloudProvider",
                        "id",
                        "replicaSetName"
                    ]
                }
            }
        },
        "mongodbatlas:index/CloudBackupSnapshotRestoreJobDeliveryTypeConfig:CloudBackupSnapshotRestoreJobDeliveryTypeConfig": {
            "properties": {
                "automated": {
                    "type": "boolean",
                    "willReplaceOnChanges": true
                },
                "download": {
                    "type": "boolean",
                    "willReplaceOnChanges": true
                },
                "oplogInc": {
                    "type": "integer",
                    "willReplaceOnChanges": true
                },
                "oplogTs": {
                    "type": "integer",
                    "willReplaceOnChanges": true
                },
                "pointInTime": {
                    "type": "boolean",
                    "willReplaceOnChanges": true
                },
                "pointInTimeUtcSeconds": {
                    "type": "integer",
                    "willReplaceOnChanges": true
                },
                "targetClusterName": {
                    "type": "string",
                    "description": "Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.\n",
                    "willReplaceOnChanges": true
                },
                "targetProjectId": {
                    "type": "string",
                    "description": "Name of the target Atlas project of the restore job. Only visible if deliveryType is automated.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/CloudProviderAccessAuthorizationAws:CloudProviderAccessAuthorizationAws": {
            "properties": {
                "iamAssumedRoleArn": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "iamAssumedRoleArn"
            ]
        },
        "mongodbatlas:index/CloudProviderAccessAuthorizationAzure:CloudProviderAccessAuthorizationAzure": {
            "properties": {
                "atlasAzureAppId": {
                    "type": "string"
                },
                "servicePrincipalId": {
                    "type": "string"
                },
                "tenantId": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "atlasAzureAppId",
                "servicePrincipalId",
                "tenantId"
            ]
        },
        "mongodbatlas:index/CloudProviderAccessAuthorizationFeatureUsage:CloudProviderAccessAuthorizationFeatureUsage": {
            "properties": {
                "featureId": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "featureType": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "featureId",
                        "featureType"
                    ]
                }
            }
        },
        "mongodbatlas:index/CloudProviderAccessSetupAwsConfig:CloudProviderAccessSetupAwsConfig": {
            "properties": {
                "atlasAssumedRoleExternalId": {
                    "type": "string"
                },
                "atlasAwsAccountArn": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "atlasAssumedRoleExternalId",
                        "atlasAwsAccountArn"
                    ]
                }
            }
        },
        "mongodbatlas:index/CloudProviderAccessSetupAzureConfig:CloudProviderAccessSetupAzureConfig": {
            "properties": {
                "atlasAzureAppId": {
                    "type": "string"
                },
                "servicePrincipalId": {
                    "type": "string"
                },
                "tenantId": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "atlasAzureAppId",
                "servicePrincipalId",
                "tenantId"
            ]
        },
        "mongodbatlas:index/ClusterAdvancedConfiguration:ClusterAdvancedConfiguration": {
            "properties": {
                "defaultReadConcern": {
                    "type": "string",
                    "description": "[Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).\n",
                    "deprecationMessage": "This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown"
                },
                "defaultWriteConcern": {
                    "type": "string",
                    "description": "[Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).\n"
                },
                "failIndexKeyTooLong": {
                    "type": "boolean",
                    "description": "When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.\n",
                    "deprecationMessage": "This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown"
                },
                "javascriptEnabled": {
                    "type": "boolean",
                    "description": "When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.\n"
                },
                "minimumEnabledTlsProtocol": {
                    "type": "string",
                    "description": "Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:\n\n- TLS1_0\n- TLS1_1\n- TLS1_2\n"
                },
                "noTableScan": {
                    "type": "boolean",
                    "description": "When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.\n"
                },
                "oplogMinRetentionHours": {
                    "type": "integer",
                    "description": "Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.\n* **Note**  A minimum oplog retention is required when seeking to change a cluster's class to Local NVMe SSD. To learn more and for latest guidance see  [`oplogMinRetentionHours`](https://www.mongodb.com/docs/manual/core/replica-set-oplog/#std-label-replica-set-minimum-oplog-size)\n"
                },
                "oplogSizeMb": {
                    "type": "integer",
                    "description": "The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.\n"
                },
                "sampleRefreshIntervalBiConnector": {
                    "type": "integer",
                    "description": "Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.\n"
                },
                "sampleSizeBiConnector": {
                    "type": "integer",
                    "description": "Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.\n"
                },
                "transactionLifetimeLimitSeconds": {
                    "type": "integer",
                    "description": "Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "defaultReadConcern",
                        "defaultWriteConcern",
                        "failIndexKeyTooLong",
                        "javascriptEnabled",
                        "minimumEnabledTlsProtocol",
                        "noTableScan",
                        "oplogSizeMb",
                        "sampleRefreshIntervalBiConnector",
                        "sampleSizeBiConnector",
                        "transactionLifetimeLimitSeconds"
                    ]
                }
            }
        },
        "mongodbatlas:index/ClusterBiConnectorConfig:ClusterBiConnectorConfig": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether or not BI Connector for Atlas is enabled on the cluster.l\n*\n- Set to `true` to enable BI Connector for Atlas.\n- Set to `false` to disable BI Connector for Atlas.\n"
                },
                "readPreference": {
                    "type": "string",
                    "description": "Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).\n\n- Set to \"primary\" to have BI Connector for Atlas read from the primary.\n\n- Set to \"secondary\" to have BI Connector for Atlas read from a secondary member. Default if there are no analytics nodes in the cluster.\n\n- Set to \"analytics\" to have BI Connector for Atlas read from an analytics node. Default if the cluster contains analytics nodes.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "enabled",
                        "readPreference"
                    ]
                }
            }
        },
        "mongodbatlas:index/ClusterConnectionString:ClusterConnectionString": {
            "properties": {
                "private": {
                    "type": "string",
                    "description": "[Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.\n"
                },
                "privateEndpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ClusterConnectionStringPrivateEndpoint:ClusterConnectionStringPrivateEndpoint"
                    },
                    "description": "Private endpoint connection strings. Each object describes the connection strings you can use to connect to this cluster through a private endpoint. Atlas returns this parameter only if you deployed a private endpoint to all regions to which you deployed this cluster's nodes.\n- `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.\n- `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in DNS . Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don't need to: Append the seed list or Change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn't, use `connection_strings.private_endpoint[n].connection_string`\n- `connection_strings.private_endpoint.#.srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster supports it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[n].srvConnectionString.\n- `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.\n- `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`\n- `connection_strings.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.\n- `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.\n- `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.\n"
                },
                "privateSrv": {
                    "type": "string",
                    "description": "[Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.\n"
                },
                "standard": {
                    "type": "string",
                    "description": "Public mongodb:// connection string for this cluster.\n"
                },
                "standardSrv": {
                    "type": "string",
                    "description": "Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you donât need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesnât  , use connectionStrings.standard.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "private",
                        "privateEndpoints",
                        "privateSrv",
                        "standard",
                        "standardSrv"
                    ]
                }
            }
        },
        "mongodbatlas:index/ClusterConnectionStringPrivateEndpoint:ClusterConnectionStringPrivateEndpoint": {
            "properties": {
                "connectionString": {
                    "type": "string"
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ClusterConnectionStringPrivateEndpointEndpoint:ClusterConnectionStringPrivateEndpointEndpoint"
                    }
                },
                "srvConnectionString": {
                    "type": "string"
                },
                "srvShardOptimizedConnectionString": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "connectionString",
                        "endpoints",
                        "srvConnectionString",
                        "srvShardOptimizedConnectionString",
                        "type"
                    ]
                }
            }
        },
        "mongodbatlas:index/ClusterConnectionStringPrivateEndpointEndpoint:ClusterConnectionStringPrivateEndpointEndpoint": {
            "properties": {
                "endpointId": {
                    "type": "string"
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud service provider on which the servers are provisioned.\n\nThe possible values are:\n\n- `AWS` - Amazon AWS\n- `GCP` - Google Cloud Platform\n- `AZURE` - Microsoft Azure\n- `TENANT` - A multi-tenant deployment on one of the supported cloud service providers. Only valid when providerSettings.instanceSizeName is either M2 or M5.\n"
                },
                "region": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "endpointId",
                        "providerName",
                        "region"
                    ]
                }
            }
        },
        "mongodbatlas:index/ClusterLabel:ClusterLabel": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key that you want to write.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value that you want to write.\n\n\u003e **NOTE:** MongoDB Atlas doesn't display your labels.\n"
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/ClusterOutageSimulationOutageFilter:ClusterOutageSimulationOutageFilter": {
            "properties": {
                "cloudProvider": {
                    "type": "string",
                    "description": "The cloud provider of the region that undergoes the outage simulation. Following values are supported:\n* `AWS`\n* `GCP`\n* `AZURE`\n"
                },
                "regionName": {
                    "type": "string",
                    "description": "The Atlas name of the region to undergo an outage simulation.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of cluster outage simulation. Following values are supported:\n* `REGION` - Simulates a cluster outage for a region\n"
                }
            },
            "type": "object",
            "required": [
                "cloudProvider",
                "regionName"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "cloudProvider",
                        "regionName",
                        "type"
                    ]
                }
            }
        },
        "mongodbatlas:index/ClusterReplicationSpec:ClusterReplicationSpec": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "Unique identifer of the replication document for a zone in a Global Cluster.\n"
                },
                "numShards": {
                    "type": "integer",
                    "description": "Selects whether the cluster is a replica set or a sharded cluster. If you use the replicationSpecs parameter, you must set num_shards.\n"
                },
                "regionsConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ClusterReplicationSpecRegionsConfig:ClusterReplicationSpecRegionsConfig"
                    },
                    "description": "Physical location of the region. Each regionsConfig document describes the regionâs priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.\n"
                },
                "zoneName": {
                    "type": "string",
                    "description": "Name for the zone in a Global Cluster.\n\n\n**Region Config**\n"
                }
            },
            "type": "object",
            "required": [
                "numShards"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "numShards",
                        "regionsConfigs"
                    ]
                }
            }
        },
        "mongodbatlas:index/ClusterReplicationSpecRegionsConfig:ClusterReplicationSpecRegionsConfig": {
            "properties": {
                "analyticsNodes": {
                    "type": "integer",
                    "description": "The number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary. If you do not specify this option, no analytics nodes are deployed to the region.\n"
                },
                "electableNodes": {
                    "type": "integer",
                    "description": "Number of electable nodes for Atlas to deploy to the region. Electable nodes can become the primary and can facilitate local reads.\n* The total number of electableNodes across all replication spec regions  must total 3, 5, or 7.\n* Specify 0 if you do not want any electable nodes in the region.\n* You cannot create electable nodes in a region if `priority` is 0.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Election priority of the region. For regions with only read-only nodes, set this value to 0.\n* For regions where `electable_nodes` is at least 1, each region must have a priority of exactly one (1) less than the previous region. The first region must have a priority of 7. The lowest possible priority is 1.\n* The priority 7 region identifies the Preferred Region of the cluster. Atlas places the primary node in the Preferred Region. Priorities 1 through 7 are exclusive - no more than one region per cluster can be assigned a given priority.\n* Example: If you have three regions, their priorities would be 7, 6, and 5 respectively. If you added two more regions for supporting electable nodes, the priorities of those regions would be 4 and 3 respectively.\n"
                },
                "readOnlyNodes": {
                    "type": "integer",
                    "description": "Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.\n"
                },
                "regionName": {
                    "type": "string",
                    "description": "Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).\n"
                }
            },
            "type": "object",
            "required": [
                "regionName"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "electableNodes",
                        "priority",
                        "regionName"
                    ]
                }
            }
        },
        "mongodbatlas:index/ClusterSnapshotBackupPolicy:ClusterSnapshotBackupPolicy": {
            "properties": {
                "clusterId": {
                    "type": "string",
                    "description": "The cluster ID.\n"
                },
                "clusterName": {
                    "type": "string"
                },
                "nextSnapshot": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ClusterSnapshotBackupPolicyPolicy:ClusterSnapshotBackupPolicyPolicy"
                    }
                },
                "referenceHourOfDay": {
                    "type": "integer"
                },
                "referenceMinuteOfHour": {
                    "type": "integer"
                },
                "restoreWindowDays": {
                    "type": "integer"
                },
                "updateSnapshots": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "clusterId",
                        "clusterName",
                        "nextSnapshot",
                        "policies",
                        "referenceHourOfDay",
                        "referenceMinuteOfHour",
                        "restoreWindowDays",
                        "updateSnapshots"
                    ]
                }
            }
        },
        "mongodbatlas:index/ClusterSnapshotBackupPolicyPolicy:ClusterSnapshotBackupPolicyPolicy": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "Unique identifer of the replication document for a zone in a Global Cluster.\n"
                },
                "policyItems": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ClusterSnapshotBackupPolicyPolicyPolicyItem:ClusterSnapshotBackupPolicyPolicyPolicyItem"
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "policyItems"
                    ]
                }
            }
        },
        "mongodbatlas:index/ClusterSnapshotBackupPolicyPolicyPolicyItem:ClusterSnapshotBackupPolicyPolicyPolicyItem": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer"
                },
                "frequencyType": {
                    "type": "string"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifer of the replication document for a zone in a Global Cluster.\n"
                },
                "retentionUnit": {
                    "type": "string"
                },
                "retentionValue": {
                    "type": "integer"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "frequencyInterval",
                        "frequencyType",
                        "id",
                        "retentionUnit",
                        "retentionValue"
                    ]
                }
            }
        },
        "mongodbatlas:index/ClusterTag:ClusterTag": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "Constant that defines the set of the tag.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Variable that belongs to the set of the tag.\n\nTo learn more, see [Resource Tags](https://dochub.mongodb.org/core/add-cluster-tag-atlas).\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ]
        },
        "mongodbatlas:index/CustomDbRoleAction:CustomDbRoleAction": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Name of the privilege action. For a complete list of actions available in the Atlas API, see [Custom Role Actions](https://docs.atlas.mongodb.com/reference/api/custom-role-actions)\n\u003e **Note**: The privilege actions available to the Custom Roles API resource represent a subset of the privilege actions available in the Atlas Custom Roles UI.\n"
                },
                "resources": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CustomDbRoleActionResource:CustomDbRoleActionResource"
                    },
                    "description": "Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.\n\n* `resources.#.collection_name` - (Optional) Collection on which the action is granted. If this value is an empty string, the action is granted on all collections within the database specified in the actions.resources.db field.\n\n\u003e **NOTE** This field is mutually exclusive with the `actions.resources.cluster` field.\n\n* `resources.#.database_name`\tDatabase on which the action is granted.\n\n\u003e **NOTE** This field is mutually exclusive with the `actions.resources.cluster` field.\n\n* `resources.#.cluster`\t(Optional) Set to true to indicate that the action is granted on the cluster resource.\n\n\u003e **NOTE** This field is mutually exclusive with the `actions.resources.collection` and `actions.resources.db fields`.\n"
                }
            },
            "type": "object",
            "required": [
                "action",
                "resources"
            ]
        },
        "mongodbatlas:index/CustomDbRoleActionResource:CustomDbRoleActionResource": {
            "properties": {
                "cluster": {
                    "type": "boolean"
                },
                "collectionName": {
                    "type": "string"
                },
                "databaseName": {
                    "type": "string",
                    "description": "Database on which the inherited role is granted.\n\n\u003e **NOTE** This value should be admin for all roles except read and readWrite.\n"
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/CustomDbRoleInheritedRole:CustomDbRoleInheritedRole": {
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "Database on which the inherited role is granted.\n\n\u003e **NOTE** This value should be admin for all roles except read and readWrite.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "Name of the inherited role. This can either be another custom role or a built-in role.\n"
                }
            },
            "type": "object",
            "required": [
                "databaseName",
                "roleName"
            ]
        },
        "mongodbatlas:index/DataLakePipelineIngestionSchedule:DataLakePipelineIngestionSchedule": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer"
                },
                "frequencyType": {
                    "type": "string"
                },
                "id": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.\n"
                },
                "retentionUnit": {
                    "type": "string"
                },
                "retentionValue": {
                    "type": "integer"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "frequencyInterval",
                        "frequencyType",
                        "id",
                        "retentionUnit",
                        "retentionValue"
                    ]
                }
            }
        },
        "mongodbatlas:index/DataLakePipelineSink:DataLakePipelineSink": {
            "properties": {
                "partitionFields": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/DataLakePipelineSinkPartitionField:DataLakePipelineSinkPartitionField"
                    },
                    "description": "Ordered fields used to physically organize data in the destination.\n* `partition_fields.#.field_name` - Human-readable label that identifies the field name used to partition data.\n* `partition_fields.#.order` - Sequence in which MongoDB Atlas slices the collection data to create partitions. The resource expresses this sequence starting with zero.\n"
                },
                "provider": {
                    "type": "string",
                    "description": "Target cloud provider for this Data Lake Pipeline.\n"
                },
                "region": {
                    "type": "string",
                    "description": "Target cloud provider region for this Data Lake Pipeline. [Supported cloud provider regions](https://www.mongodb.com/docs/datalake/limitations).\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of ingestion source of this Data Lake Pipeline.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "provider",
                        "region"
                    ]
                }
            }
        },
        "mongodbatlas:index/DataLakePipelineSinkPartitionField:DataLakePipelineSinkPartitionField": {
            "properties": {
                "fieldName": {
                    "type": "string"
                },
                "order": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "fieldName",
                "order"
            ]
        },
        "mongodbatlas:index/DataLakePipelineSnapshot:DataLakePipelineSnapshot": {
            "properties": {
                "copyRegion": {
                    "type": "string"
                },
                "createdAt": {
                    "type": "string"
                },
                "expiresAt": {
                    "type": "string"
                },
                "frequencyYype": {
                    "type": "string"
                },
                "id": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.\n"
                },
                "masterKey": {
                    "type": "string"
                },
                "mongodVersion": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "provider": {
                    "type": "string",
                    "description": "Target cloud provider for this Data Lake Pipeline.\n"
                },
                "replicaSetName": {
                    "type": "string"
                },
                "size": {
                    "type": "integer"
                },
                "snapshotType": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "type": {
                    "type": "string",
                    "description": "Type of ingestion source of this Data Lake Pipeline.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "copyRegion",
                        "createdAt",
                        "expiresAt",
                        "frequencyYype",
                        "id",
                        "masterKey",
                        "mongodVersion",
                        "replicaSetName",
                        "size",
                        "snapshotType",
                        "status",
                        "type"
                    ]
                }
            }
        },
        "mongodbatlas:index/DataLakePipelineSource:DataLakePipelineSource": {
            "properties": {
                "clusterName": {
                    "type": "string",
                    "description": "Human-readable name that identifies the cluster.\n"
                },
                "collectionName": {
                    "type": "string",
                    "description": "Human-readable name that identifies the collection.\n"
                },
                "databaseName": {
                    "type": "string",
                    "description": "Human-readable name that identifies the database.\n"
                },
                "policyItemId": {
                    "type": "string"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create a data lake pipeline.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of ingestion source of this Data Lake Pipeline.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "projectId"
                    ]
                }
            }
        },
        "mongodbatlas:index/DataLakePipelineTransformation:DataLakePipelineTransformation": {
            "properties": {
                "field": {
                    "type": "string"
                },
                "type": {
                    "type": "string",
                    "description": "Type of ingestion source of this Data Lake Pipeline.\n"
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/DatabaseUserLabel:DatabaseUserLabel": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key that you want to write.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value that you want to write.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "key",
                        "value"
                    ]
                }
            }
        },
        "mongodbatlas:index/DatabaseUserRole:DatabaseUserRole": {
            "properties": {
                "collectionName": {
                    "type": "string",
                    "description": "Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).\n"
                },
                "databaseName": {
                    "type": "string",
                    "description": "Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases. This field should be set to `admin` for a custom MongoDB role.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "Name of the role to grant. See [Create a Database User](https://docs.atlas.mongodb.com/reference/api/database-users-create-a-user/) `roles.roleName` for valid values and restrictions.\n"
                }
            },
            "type": "object",
            "required": [
                "databaseName",
                "roleName"
            ]
        },
        "mongodbatlas:index/DatabaseUserScope:DatabaseUserScope": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the cluster or Atlas Data Lake that the user has access to.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`\n"
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/EncryptionAtRestAwsKmsConfig:EncryptionAtRestAwsKmsConfig": {
            "properties": {
                "accessKeyId": {
                    "type": "string",
                    "secret": true
                },
                "customerMasterKeyId": {
                    "type": "string",
                    "description": "The AWS customer master key used to encrypt and decrypt the MongoDB master keys.\n",
                    "secret": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether Encryption at Rest is enabled for an Atlas project, To disable Encryption at Rest, pass only this parameter with a value of false, When you disable Encryption at Rest, Atlas also removes the configuration details.\n"
                },
                "region": {
                    "type": "string",
                    "description": "The AWS region in which the AWS customer master key exists: CA_CENTRAL_1, US_EAST_1, US_EAST_2, US_WEST_1, US_WEST_2, SA_EAST_1\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "ID of an AWS IAM role authorized to manage an AWS customer master key. To find the ID for an existing IAM role check the `role_id` attribute of the `mongodbatlas_cloud_provider_access` resource.\n"
                },
                "secretAccessKey": {
                    "type": "string",
                    "secret": true
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "enabled"
                    ]
                }
            }
        },
        "mongodbatlas:index/EncryptionAtRestAzureKeyVaultConfig:EncryptionAtRestAzureKeyVaultConfig": {
            "properties": {
                "azureEnvironment": {
                    "type": "string",
                    "description": "The Azure environment where the Azure account credentials reside. Valid values are the following: AZURE, AZURE_CHINA, AZURE_GERMANY\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "The client ID, also known as the application ID, for an Azure application associated with the Azure AD tenant.\n",
                    "secret": true
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether Encryption at Rest is enabled for an Atlas project. To disable Encryption at Rest, pass only this parameter with a value of false. When you disable Encryption at Rest, Atlas also removes the configuration details.\n"
                },
                "keyIdentifier": {
                    "type": "string",
                    "description": "The unique identifier of a key in an Azure Key Vault.\n",
                    "secret": true
                },
                "keyVaultName": {
                    "type": "string",
                    "description": "The name of an Azure Key Vault containing your key.\n"
                },
                "resourceGroupName": {
                    "type": "string",
                    "description": "The name of the Azure Resource group that contains an Azure Key Vault.\n"
                },
                "secret": {
                    "type": "string",
                    "description": "The secret associated with the Azure Key Vault specified by azureKeyVault.tenantID.\n",
                    "secret": true
                },
                "subscriptionId": {
                    "type": "string",
                    "description": "The unique identifier associated with an Azure subscription.\n",
                    "secret": true
                },
                "tenantId": {
                    "type": "string",
                    "description": "The unique identifier for an Azure AD tenant within an Azure subscription.\n",
                    "secret": true
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "enabled"
                    ]
                }
            }
        },
        "mongodbatlas:index/EncryptionAtRestGoogleCloudKmsConfig:EncryptionAtRestGoogleCloudKmsConfig": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether Encryption at Rest is enabled for an Atlas project. To disable Encryption at Rest, pass only this parameter with a value of false. When you disable Encryption at Rest, Atlas also removes the configuration details.\n"
                },
                "keyVersionResourceId": {
                    "type": "string",
                    "description": "The Key Version Resource ID from your GCP account.\n",
                    "secret": true
                },
                "serviceAccountKey": {
                    "type": "string",
                    "description": "String-formatted JSON object containing GCP KMS credentials from your GCP account.\n",
                    "secret": true
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "enabled"
                    ]
                }
            }
        },
        "mongodbatlas:index/EventTriggerEventProcessors:EventTriggerEventProcessors": {
            "properties": {
                "awsEventbridge": {
                    "$ref": "#/types/mongodbatlas:index/EventTriggerEventProcessorsAwsEventbridge:EventTriggerEventProcessorsAwsEventbridge"
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/EventTriggerEventProcessorsAwsEventbridge:EventTriggerEventProcessorsAwsEventbridge": {
            "properties": {
                "configAccountId": {
                    "type": "string"
                },
                "configRegion": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/FederatedDatabaseInstanceCloudProviderConfig:FederatedDatabaseInstanceCloudProviderConfig": {
            "properties": {
                "aws": {
                    "$ref": "#/types/mongodbatlas:index/FederatedDatabaseInstanceCloudProviderConfigAws:FederatedDatabaseInstanceCloudProviderConfigAws",
                    "description": "Name of the cloud service that hosts the data lake's data stores.\n"
                }
            },
            "type": "object",
            "required": [
                "aws"
            ]
        },
        "mongodbatlas:index/FederatedDatabaseInstanceCloudProviderConfigAws:FederatedDatabaseInstanceCloudProviderConfigAws": {
            "properties": {
                "externalId": {
                    "type": "string",
                    "description": "Unique identifier associated with the IAM Role that the Federated Database Instance assumes when accessing the data stores.\n"
                },
                "iamAssumedRoleArn": {
                    "type": "string",
                    "description": "Amazon Resource Name (ARN) of the IAM Role that the Federated Database Instance assumes when accessing S3 Bucket data stores. The IAM Role must support the following actions against each S3 bucket:\n* `s3:GetObject`\n* `s3:ListBucket`\n* `s3:GetObjectVersion`\n"
                },
                "iamUserArn": {
                    "type": "string",
                    "description": "Amazon Resource Name (ARN) of the user that the Federated Database Instance assumes when accessing S3 Bucket data stores.\n"
                },
                "roleId": {
                    "type": "string"
                },
                "testS3Bucket": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "roleId",
                "testS3Bucket"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "externalId",
                        "iamAssumedRoleArn",
                        "iamUserArn",
                        "roleId",
                        "testS3Bucket"
                    ]
                }
            }
        },
        "mongodbatlas:index/FederatedDatabaseInstanceDataProcessRegion:FederatedDatabaseInstanceDataProcessRegion": {
            "properties": {
                "cloudProvider": {
                    "type": "string"
                },
                "region": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "cloudProvider",
                "region"
            ]
        },
        "mongodbatlas:index/FederatedDatabaseInstanceStorageDatabase:FederatedDatabaseInstanceStorageDatabase": {
            "properties": {
                "collections": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/FederatedDatabaseInstanceStorageDatabaseCollection:FederatedDatabaseInstanceStorageDatabaseCollection"
                    }
                },
                "maxWildcardCollections": {
                    "type": "integer"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the Atlas Federated Database Instance.\n"
                },
                "views": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/FederatedDatabaseInstanceStorageDatabaseView:FederatedDatabaseInstanceStorageDatabaseView"
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "collections",
                        "maxWildcardCollections",
                        "name",
                        "views"
                    ]
                }
            }
        },
        "mongodbatlas:index/FederatedDatabaseInstanceStorageDatabaseCollection:FederatedDatabaseInstanceStorageDatabaseCollection": {
            "properties": {
                "dataSources": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/FederatedDatabaseInstanceStorageDatabaseCollectionDataSource:FederatedDatabaseInstanceStorageDatabaseCollectionDataSource"
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of the Atlas Federated Database Instance.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name"
                    ]
                }
            }
        },
        "mongodbatlas:index/FederatedDatabaseInstanceStorageDatabaseCollectionDataSource:FederatedDatabaseInstanceStorageDatabaseCollectionDataSource": {
            "properties": {
                "allowInsecure": {
                    "type": "boolean"
                },
                "collection": {
                    "type": "string"
                },
                "collectionRegex": {
                    "type": "string"
                },
                "database": {
                    "type": "string"
                },
                "databaseRegex": {
                    "type": "string"
                },
                "datasetName": {
                    "type": "string"
                },
                "defaultFormat": {
                    "type": "string"
                },
                "path": {
                    "type": "string"
                },
                "provenanceFieldName": {
                    "type": "string"
                },
                "storeName": {
                    "type": "string"
                },
                "urls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "allowInsecure",
                        "collection",
                        "collectionRegex",
                        "database",
                        "databaseRegex",
                        "datasetName",
                        "defaultFormat",
                        "path",
                        "provenanceFieldName",
                        "storeName",
                        "urls"
                    ]
                }
            }
        },
        "mongodbatlas:index/FederatedDatabaseInstanceStorageDatabaseView:FederatedDatabaseInstanceStorageDatabaseView": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the Atlas Federated Database Instance.\n"
                },
                "pipeline": {
                    "type": "string"
                },
                "source": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "pipeline",
                        "source"
                    ]
                }
            }
        },
        "mongodbatlas:index/FederatedDatabaseInstanceStorageStore:FederatedDatabaseInstanceStorageStore": {
            "properties": {
                "additionalStorageClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "allowInsecure": {
                    "type": "boolean"
                },
                "bucket": {
                    "type": "string"
                },
                "clusterId": {
                    "type": "string",
                    "deprecationMessage": "This parameter is deprecated and will be removed by September 2024."
                },
                "clusterName": {
                    "type": "string"
                },
                "defaultFormat": {
                    "type": "string"
                },
                "delimiter": {
                    "type": "string"
                },
                "includeTags": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the Atlas Federated Database Instance.\n"
                },
                "prefix": {
                    "type": "string"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create a Federated Database Instance.\n"
                },
                "provider": {
                    "type": "string"
                },
                "public": {
                    "type": "string"
                },
                "readPreference": {
                    "$ref": "#/types/mongodbatlas:index/FederatedDatabaseInstanceStorageStoreReadPreference:FederatedDatabaseInstanceStorageStoreReadPreference"
                },
                "region": {
                    "type": "string"
                },
                "urls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "additionalStorageClasses",
                        "allowInsecure",
                        "bucket",
                        "clusterId",
                        "clusterName",
                        "defaultFormat",
                        "delimiter",
                        "includeTags",
                        "name",
                        "prefix",
                        "projectId",
                        "provider",
                        "public",
                        "readPreference",
                        "region",
                        "urls"
                    ]
                }
            }
        },
        "mongodbatlas:index/FederatedDatabaseInstanceStorageStoreReadPreference:FederatedDatabaseInstanceStorageStoreReadPreference": {
            "properties": {
                "maxStalenessSeconds": {
                    "type": "integer"
                },
                "mode": {
                    "type": "string"
                },
                "tagSets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/FederatedDatabaseInstanceStorageStoreReadPreferenceTagSet:FederatedDatabaseInstanceStorageStoreReadPreferenceTagSet"
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "maxStalenessSeconds",
                        "mode",
                        "tagSets"
                    ]
                }
            }
        },
        "mongodbatlas:index/FederatedDatabaseInstanceStorageStoreReadPreferenceTagSet:FederatedDatabaseInstanceStorageStoreReadPreferenceTagSet": {
            "properties": {
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTag:FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTag"
                    }
                }
            },
            "type": "object",
            "required": [
                "tags"
            ]
        },
        "mongodbatlas:index/FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTag:FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTag": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the Atlas Federated Database Instance.\n"
                },
                "value": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "name",
                        "value"
                    ]
                }
            }
        },
        "mongodbatlas:index/FederatedSettingsOrgConfigUserConflict:FederatedSettingsOrgConfigUserConflict": {
            "properties": {
                "emailAddress": {
                    "type": "string",
                    "description": "Email address of the the user that conflicts with selected domains.\n"
                },
                "federationSettingsId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                },
                "firstName": {
                    "type": "string",
                    "description": "First name of the the user that conflicts with selected domains.\n"
                },
                "lastName": {
                    "type": "string",
                    "description": "Last name of the the user that conflicts with selected domains.\n"
                },
                "userId": {
                    "type": "string",
                    "description": "Name of the Atlas user that conflicts with selected domains.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "emailAddress",
                        "federationSettingsId",
                        "firstName",
                        "lastName",
                        "userId"
                    ]
                }
            }
        },
        "mongodbatlas:index/FederatedSettingsOrgRoleMappingRoleAssignment:FederatedSettingsOrgRoleMappingRoleAssignment": {
            "properties": {
                "groupId": {
                    "type": "string",
                    "description": "Unique identifier of the project to which you want the role mapping to apply.\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the Roles that are attached to the Role Mapping. Available role IDs can be found on [the User Roles\nReference](https://www.mongodb.com/docs/atlas/reference/user-roles/).\n"
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/GlobalClusterConfigCustomZoneMapping:GlobalClusterConfigCustomZoneMapping": {
            "properties": {
                "location": {
                    "type": "string",
                    "description": "The ISO location code to which you want to map a zone in your Global Cluster. You can find a list of all supported location codes [here](https://cloud.mongodb.com/static/atlas/country_iso_codes.txt).\n"
                },
                "zone": {
                    "type": "string",
                    "description": "The name of the zone in your Global Cluster that you want to map to location.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "location",
                        "zone"
                    ]
                }
            }
        },
        "mongodbatlas:index/GlobalClusterConfigManagedNamespace:GlobalClusterConfigManagedNamespace": {
            "properties": {
                "collection": {
                    "type": "string",
                    "description": "The name of the collection associated with the managed namespace.\n"
                },
                "customShardKey": {
                    "type": "string",
                    "description": "The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.\n"
                },
                "db": {
                    "type": "string",
                    "description": "The name of the database containing the collection.\n"
                },
                "isCustomShardKeyHashed": {
                    "type": "boolean",
                    "description": "Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.\n"
                },
                "isShardKeyUnique": {
                    "type": "boolean",
                    "description": "Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).\n"
                }
            },
            "type": "object",
            "required": [
                "collection",
                "customShardKey",
                "db"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "collection",
                        "customShardKey",
                        "db",
                        "isCustomShardKeyHashed",
                        "isShardKeyUnique"
                    ]
                }
            }
        },
        "mongodbatlas:index/LdapConfigurationUserToDnMapping:LdapConfigurationUserToDnMapping": {
            "properties": {
                "ldapQuery": {
                    "type": "string"
                },
                "match": {
                    "type": "string"
                },
                "substitution": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "ldapQuery",
                        "match",
                        "substitution"
                    ]
                }
            }
        },
        "mongodbatlas:index/LdapVerifyLink:LdapVerifyLink": {
            "properties": {
                "href": {
                    "type": "string"
                },
                "rel": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "href",
                        "rel"
                    ]
                }
            }
        },
        "mongodbatlas:index/LdapVerifyValidation:LdapVerifyValidation": {
            "properties": {
                "status": {
                    "type": "string",
                    "description": "The current status of the LDAP over TLS/SSL configuration. One of the following values: `PENDING`, `SUCCESS`, and `FAILED`.\n"
                },
                "validationType": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "status",
                        "validationType"
                    ]
                }
            }
        },
        "mongodbatlas:index/OnlineArchiveCriteria:OnlineArchiveCriteria": {
            "properties": {
                "dateField": {
                    "type": "string",
                    "description": "Indexed database parameter that stores the date that determines when data moves to the online archive. MongoDB Cloud archives the data when the current date exceeds the date in this database parameter plus the number of days specified through the expireAfterDays parameter.\n"
                },
                "dateFormat": {
                    "type": "string",
                    "description": "Syntax used to write the date after which data moves to the online archive. Date can be expressed as ISO 8601 or Epoch timestamps. The Epoch timestamp can be expressed as nanoseconds, milliseconds, or seconds. You must set `type` to `DATE` if `collectionType` is `TIMESERIES`. Valid values:  ISODATE (default), EPOCH_SECONDS, EPOCH_MILLIS, EPOCH_NANOSECONDS.\n"
                },
                "expireAfterDays": {
                    "type": "integer",
                    "description": "Number of days after the value in the criteria.dateField when MongoDB Cloud archives data in the specified cluster.\n\n**_NOTE: if `DATE` is selected, the `partition_fields.field_name` must be completed with the `date_field` value_**\n\nThe only field required for criteria type `CUSTOM`\n"
                },
                "query": {
                    "type": "string",
                    "description": "JSON query to use to select documents for archiving. Atlas uses the specified query with the db.collection.find(query) command. The empty document {} to return all documents is not supported.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of criteria (DATE, CUSTOM)\n\nThe following fields are required for criteria type `DATE`\n"
                }
            },
            "type": "object",
            "required": [
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "dateFormat",
                        "type"
                    ]
                }
            }
        },
        "mongodbatlas:index/OnlineArchiveDataExpirationRule:OnlineArchiveDataExpirationRule": {
            "properties": {
                "expireAfterDays": {
                    "type": "integer",
                    "description": "Number of days used in the date criteria for nominating documents for deletion. Value must be between 7 and 9215.\n"
                }
            },
            "type": "object",
            "required": [
                "expireAfterDays"
            ]
        },
        "mongodbatlas:index/OnlineArchiveDataProcessRegion:OnlineArchiveDataProcessRegion": {
            "properties": {
                "cloudProvider": {
                    "type": "string",
                    "description": "Human-readable label that identifies the Cloud service provider where you wish to store your archived data. `AZURE` may be selected only if Azure is the Cloud service provider for the cluster and no AWS online archive has been created for the cluster.\n"
                },
                "region": {
                    "type": "string",
                    "description": "Human-readable label that identifies the geographic location of the region where you wish to store your archived data. For allowed values, see [MongoDB Atlas API documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Online-Archive/operation/createOnlineArchive)\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "cloudProvider",
                        "region"
                    ]
                }
            }
        },
        "mongodbatlas:index/OnlineArchivePartitionField:OnlineArchivePartitionField": {
            "properties": {
                "fieldName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the parameter that MongoDB Cloud uses to partition data. To specify a nested parameter, use the dot notation.\n"
                },
                "fieldType": {
                    "type": "string",
                    "description": "Data type of the parameter that that MongoDB Cloud uses to partition data. Partition parameters of type UUID must be of binary subtype 4. MongoDB Cloud skips partition parameters of type UUID with subtype 3. Valid values: `date`, `int`, `long`, `objectId`, `string`, `uuid`.\n"
                },
                "order": {
                    "type": "integer",
                    "description": "Sequence in which MongoDB Cloud slices the collection data to create partitions. The resource expresses this sequence starting with zero. The value of the `criteria.dateField` parameter defaults as the first item in the partition sequence.\n"
                }
            },
            "type": "object",
            "required": [
                "fieldName",
                "order"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "fieldName",
                        "fieldType",
                        "order"
                    ]
                }
            }
        },
        "mongodbatlas:index/OnlineArchiveSchedule:OnlineArchiveSchedule": {
            "properties": {
                "dayOfMonth": {
                    "type": "integer",
                    "description": "Day of the month when the scheduled archive starts. This field should be provided only when schedule `type` is `MONTHLY`.\n"
                },
                "dayOfWeek": {
                    "type": "integer",
                    "description": "Day of the week when the scheduled archive starts. The week starts with Monday (1) and ends with Sunday (7). This field should be provided only when schedule `type` is `WEEKLY`.\n"
                },
                "endHour": {
                    "type": "integer",
                    "description": "Hour of the day when the scheduled window to run one online archive ends.\n"
                },
                "endMinute": {
                    "type": "integer",
                    "description": "Minute of the hour when the scheduled window to run one online archive ends.\n"
                },
                "startHour": {
                    "type": "integer",
                    "description": "Hour of the day when the when the scheduled window to run one online archive starts.\n"
                },
                "startMinute": {
                    "type": "integer",
                    "description": "Minute of the hour when the scheduled window to run one online archive starts.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of schedule (``DAILY`, `MONTHLY`, `WEEKLY`).\n"
                }
            },
            "type": "object",
            "required": [
                "type"
            ]
        },
        "mongodbatlas:index/PrivateLinkEndpointServiceEndpoint:PrivateLinkEndpointServiceEndpoint": {
            "properties": {
                "endpointName": {
                    "type": "string",
                    "description": "Forwarding rule that corresponds to the endpoint you created in GCP.\n"
                },
                "ipAddress": {
                    "type": "string",
                    "description": "Private IP address of the endpoint you created in GCP.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Status of the endpoint. Atlas returns one of the [values shown above](https://docs.atlas.mongodb.com/reference/api/private-endpoints-endpoint-create-one/#std-label-ref-status-field).\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "status"
                    ]
                }
            }
        },
        "mongodbatlas:index/ProjectApiKeyProjectAssignment:ProjectApiKeyProjectAssignment": {
            "properties": {
                "projectId": {
                    "type": "string",
                    "description": "Project ID to assign to Access Key\n"
                },
                "roleNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project. You must specify an array even if you are only associating a single role with the Programmatic API key. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) describes the valid roles that can be assigned.\n"
                }
            },
            "type": "object",
            "required": [
                "projectId",
                "roleNames"
            ]
        },
        "mongodbatlas:index/ProjectIpAccessListTimeouts:ProjectIpAccessListTimeouts": {
            "properties": {
                "delete": {
                    "type": "string",
                    "description": "A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as \"30s\" or \"2h45m\". Valid time units are \"s\" (seconds), \"m\" (minutes), \"h\" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.\n"
                },
                "read": {
                    "type": "string",
                    "description": "A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as \"30s\" or \"2h45m\". Valid time units are \"s\" (seconds), \"m\" (minutes), \"h\" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.\n"
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/ProjectIpAddresses:ProjectIpAddresses": {
            "properties": {
                "services": {
                    "$ref": "#/types/mongodbatlas:index/ProjectIpAddressesServices:ProjectIpAddressesServices"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "services"
                    ]
                }
            }
        },
        "mongodbatlas:index/ProjectIpAddressesServices:ProjectIpAddressesServices": {
            "properties": {
                "clusters": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ProjectIpAddressesServicesCluster:ProjectIpAddressesServicesCluster"
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "clusters"
                    ]
                }
            }
        },
        "mongodbatlas:index/ProjectIpAddressesServicesCluster:ProjectIpAddressesServicesCluster": {
            "properties": {
                "clusterName": {
                    "type": "string"
                },
                "inbounds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "outbounds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "clusterName",
                        "inbounds",
                        "outbounds"
                    ]
                }
            }
        },
        "mongodbatlas:index/ProjectLimit:ProjectLimit": {
            "properties": {
                "currentUsage": {
                    "type": "integer"
                },
                "defaultLimit": {
                    "type": "integer"
                },
                "maximumLimit": {
                    "type": "integer"
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable label that identifies this project limit. See [Project Limit Documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Projects/operation/setProjectLimit) under `limitName` parameter to find all the limits that can be defined.\n"
                },
                "value": {
                    "type": "integer",
                    "description": "Amount to set the limit to. Use the [Project Limit Documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Projects/operation/setProjectLimit) under `limitName` parameter to verify the override limits.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "currentUsage",
                        "defaultLimit",
                        "maximumLimit",
                        "name",
                        "value"
                    ]
                }
            }
        },
        "mongodbatlas:index/ProjectTeam:ProjectTeam": {
            "properties": {
                "roleNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Each string in the array represents a project role you want to assign to the team. Every user associated with the team inherits these roles. You must specify an array even if you are only associating a single role with the team. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles a user can have.\n\n\u003e **NOTE:** Project created by API Keys must belong to an existing organization.\n"
                },
                "teamId": {
                    "type": "string",
                    "description": "The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.\n"
                }
            },
            "type": "object",
            "required": [
                "roleNames",
                "teamId"
            ]
        },
        "mongodbatlas:index/ProviderAssumeRole:ProviderAssumeRole": {
            "properties": {
                "duration": {
                    "type": "string",
                    "description": "The duration, between 15 minutes and 12 hours, of the role session. Valid time units are ns, us (or Âµs), ms, s, h, or m.\n"
                },
                "externalId": {
                    "type": "string",
                    "description": "A unique identifier that might be required when you assume a role in another account.\n"
                },
                "policy": {
                    "type": "string",
                    "description": "IAM Policy JSON describing further restricting permissions for the IAM Role being assumed.\n"
                },
                "policyArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Amazon Resource Names (ARNs) of IAM Policies describing further restricting permissions for the IAM Role being assumed.\n"
                },
                "roleArn": {
                    "type": "string",
                    "description": "Amazon Resource Name (ARN) of an IAM Role to assume prior to making API calls.\n"
                },
                "sessionName": {
                    "type": "string",
                    "description": "An identifier for the assumed role session.\n"
                },
                "sourceIdentity": {
                    "type": "string",
                    "description": "Source identity specified by the principal assuming the role.\n"
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Assume role session tags.\n"
                },
                "transitiveTagKeys": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Assume role session tag keys to pass to any subsequent sessions.\n"
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/PushBasedLogExportTimeouts:PushBasedLogExportTimeouts": {
            "properties": {
                "create": {
                    "type": "string",
                    "description": "A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as \"30s\" or \"2h45m\". Valid time units are \"s\" (seconds), \"m\" (minutes), \"h\" (hours).\n"
                },
                "delete": {
                    "type": "string",
                    "description": "A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as \"30s\" or \"2h45m\". Valid time units are \"s\" (seconds), \"m\" (minutes), \"h\" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.\n"
                },
                "update": {
                    "type": "string",
                    "description": "A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as \"30s\" or \"2h45m\". Valid time units are \"s\" (seconds), \"m\" (minutes), \"h\" (hours).\n"
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/SearchDeploymentSpec:SearchDeploymentSpec": {
            "properties": {
                "instanceSize": {
                    "type": "string",
                    "description": "Hardware specification for the search node instance sizes. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Atlas-Search/operation/createAtlasSearchDeployment) describes the valid values. More details can also be found in the [Search Node Documentation](https://www.mongodb.com/docs/atlas/cluster-config/multi-cloud-distribution/#search-tier).\n"
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "Number of search nodes in the cluster.\n"
                }
            },
            "type": "object",
            "required": [
                "instanceSize",
                "nodeCount"
            ]
        },
        "mongodbatlas:index/SearchDeploymentTimeouts:SearchDeploymentTimeouts": {
            "properties": {
                "create": {
                    "type": "string",
                    "description": "A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as \"30s\" or \"2h45m\". Valid time units are \"s\" (seconds), \"m\" (minutes), \"h\" (hours).\n"
                },
                "delete": {
                    "type": "string",
                    "description": "A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as \"30s\" or \"2h45m\". Valid time units are \"s\" (seconds), \"m\" (minutes), \"h\" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.\n"
                },
                "update": {
                    "type": "string",
                    "description": "A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as \"30s\" or \"2h45m\". Valid time units are \"s\" (seconds), \"m\" (minutes), \"h\" (hours).\n"
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/SearchIndexSynonym:SearchIndexSynonym": {
            "properties": {
                "analyzer": {
                    "type": "string",
                    "description": "[Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index. Defaults to [lucene.standard](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/standard/#std-label-ref-standard-analyzer)\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the search index you want to create.\n"
                },
                "sourceCollection": {
                    "type": "string",
                    "description": "(Required) Name of the source MongoDB collection for the synonyms. Documents in this collection must be in the format described in the [Synonyms Source Collection Documents](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-coll-spec).\n"
                }
            },
            "type": "object",
            "required": [
                "analyzer",
                "name",
                "sourceCollection"
            ]
        },
        "mongodbatlas:index/ServerlessInstanceLink:ServerlessInstanceLink": {
            "properties": {
                "href": {
                    "type": "string"
                },
                "rel": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "href",
                        "rel"
                    ]
                }
            }
        },
        "mongodbatlas:index/ServerlessInstanceTag:ServerlessInstanceTag": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "Constant that defines the set of the tag.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Variable that belongs to the set of the tag.\n\nTo learn more, see [Resource Tags](https://dochub.mongodb.org/core/add-cluster-tag-atlas).\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ]
        },
        "mongodbatlas:index/StreamConnectionAuthentication:StreamConnectionAuthentication": {
            "properties": {
                "mechanism": {
                    "type": "string",
                    "description": "Style of authentication. Can be one of `PLAIN`, `SCRAM-256`, or `SCRAM-512`.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password of the account to connect to the Kafka cluster.\n",
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "Username of the account to connect to the Kafka cluster.\n"
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/StreamConnectionDbRoleToExecute:StreamConnectionDbRoleToExecute": {
            "properties": {
                "role": {
                    "type": "string",
                    "description": "The name of the role to use. Value can be  `atlasAdmin`, `readWriteAnyDatabase`, or `readAnyDatabase` if `type` is set to `BUILT_IN`, or the name of a user-defined role if `type` is set to `CUSTOM`.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of connection. Can be either `Cluster`, `Kafka` or `Sample`.\n"
                }
            },
            "type": "object",
            "required": [
                "role",
                "type"
            ]
        },
        "mongodbatlas:index/StreamConnectionSecurity:StreamConnectionSecurity": {
            "properties": {
                "brokerPublicCertificate": {
                    "type": "string",
                    "description": "A trusted, public x509 certificate for connecting to Kafka over SSL. String value of the certificate must be defined in the attribute.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Describes the transport type. Can be either `PLAINTEXT` or `SSL`.\n"
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/StreamInstanceDataProcessRegion:StreamInstanceDataProcessRegion": {
            "properties": {
                "cloudProvider": {
                    "type": "string",
                    "description": "Label that identifies the cloud service provider where MongoDB Cloud performs stream processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.\n"
                },
                "region": {
                    "type": "string",
                    "description": "Name of the cloud provider region hosting Atlas Stream Processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.\n"
                }
            },
            "type": "object",
            "required": [
                "cloudProvider",
                "region"
            ]
        },
        "mongodbatlas:index/StreamInstanceStreamConfig:StreamInstanceStreamConfig": {
            "properties": {
                "tier": {
                    "type": "string",
                    "description": "Selected tier for the Stream Instance. Configures Memory / VCPU allowances. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "tier"
                    ]
                }
            }
        },
        "mongodbatlas:index/X509AuthenticationDatabaseUserCertificate:X509AuthenticationDatabaseUserCertificate": {
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "groupId": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "notAfter": {
                    "type": "string"
                },
                "subject": {
                    "type": "string"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "createdAt",
                        "groupId",
                        "id",
                        "notAfter",
                        "subject"
                    ]
                }
            }
        },
        "mongodbatlas:index/get509AuthenticationDatabaseUserCertificate:get509AuthenticationDatabaseUserCertificate": {
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "groupId": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "notAfter": {
                    "type": "string"
                },
                "subject": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "createdAt",
                "groupId",
                "id",
                "notAfter",
                "subject"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAccessListApiKeysResult:getAccessListApiKeysResult": {
            "properties": {
                "accessCount": {
                    "type": "integer"
                },
                "cidrBlock": {
                    "type": "string",
                    "description": "Range of IP addresses in CIDR notation to be added to the access list.\n"
                },
                "created": {
                    "type": "string"
                },
                "ipAddress": {
                    "type": "string",
                    "description": "Single IP address to be added to the access list.\n"
                },
                "lastUsed": {
                    "type": "string"
                },
                "lastUsedAddress": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "accessCount",
                "cidrBlock",
                "created",
                "ipAddress",
                "lastUsed",
                "lastUsedAddress"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClusterAdvancedConfiguration:getAdvancedClusterAdvancedConfiguration": {
            "properties": {
                "defaultReadConcern": {
                    "type": "string",
                    "description": "[Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/). **(DEPRECATED.)** MongoDB 5.0 and later clusters default to `local`. To use a custom read concern level, please refer to your driver documentation.\n",
                    "deprecationMessage": "This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown"
                },
                "defaultWriteConcern": {
                    "type": "string",
                    "description": "[Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).\n"
                },
                "failIndexKeyTooLong": {
                    "type": "boolean",
                    "description": "When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them. **(DEPRECATED.)** This parameter has been removed as of [MongoDB 4.4](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.failIndexKeyTooLong).\n",
                    "deprecationMessage": "This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown"
                },
                "javascriptEnabled": {
                    "type": "boolean",
                    "description": "When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.\n"
                },
                "minimumEnabledTlsProtocol": {
                    "type": "string",
                    "description": "Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:\n"
                },
                "noTableScan": {
                    "type": "boolean",
                    "description": "When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.\n"
                },
                "oplogMinRetentionHours": {
                    "type": "integer",
                    "description": "Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.\n"
                },
                "oplogSizeMb": {
                    "type": "integer",
                    "description": "The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.\n"
                },
                "sampleRefreshIntervalBiConnector": {
                    "type": "integer",
                    "description": "Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.\n"
                },
                "sampleSizeBiConnector": {
                    "type": "integer",
                    "description": "Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.\n"
                },
                "transactionLifetimeLimitSeconds": {
                    "type": "integer",
                    "description": "Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.\n"
                }
            },
            "type": "object",
            "required": [
                "defaultReadConcern",
                "defaultWriteConcern",
                "failIndexKeyTooLong",
                "javascriptEnabled",
                "minimumEnabledTlsProtocol",
                "noTableScan",
                "oplogMinRetentionHours",
                "oplogSizeMb",
                "sampleRefreshIntervalBiConnector",
                "sampleSizeBiConnector",
                "transactionLifetimeLimitSeconds"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClusterBiConnectorConfig:getAdvancedClusterBiConnectorConfig": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether or not BI Connector for Atlas is enabled on the cluster.l\n"
                },
                "readPreference": {
                    "type": "string",
                    "description": "Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).\n"
                }
            },
            "type": "object",
            "required": [
                "enabled",
                "readPreference"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClusterConnectionString:getAdvancedClusterConnectionString": {
            "properties": {
                "private": {
                    "type": "string",
                    "description": "[Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.\n"
                },
                "privateEndpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClusterConnectionStringPrivateEndpoint:getAdvancedClusterConnectionStringPrivateEndpoint"
                    },
                    "description": "Private endpoint connection strings. Each object describes the connection strings you can use to connect to this cluster through a private endpoint. Atlas returns this parameter only if you deployed a private endpoint to all regions to which you deployed this cluster's nodes.\n- `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.\n- `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in DNS . Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don't need to: Append the seed list or Change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn't, use `connection_strings.private_endpoint[n].connection_string`\n- `connection_strings.private_endpoint.#.srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster supports it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[n].srvConnectionString.\n- `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.\n- `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`\n- `connection_strings.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.\n- `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.\n- `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.\n"
                },
                "privateSrv": {
                    "type": "string",
                    "description": "[Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.\n"
                },
                "standard": {
                    "type": "string",
                    "description": "Public mongodb:// connection string for this cluster.\n"
                },
                "standardSrv": {
                    "type": "string",
                    "description": "Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you donât need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesnât  , use connectionStrings.standard.\n"
                }
            },
            "type": "object",
            "required": [
                "private",
                "privateEndpoints",
                "privateSrv",
                "standard",
                "standardSrv"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClusterConnectionStringPrivateEndpoint:getAdvancedClusterConnectionStringPrivateEndpoint": {
            "properties": {
                "connectionString": {
                    "type": "string"
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClusterConnectionStringPrivateEndpointEndpoint:getAdvancedClusterConnectionStringPrivateEndpointEndpoint"
                    }
                },
                "srvConnectionString": {
                    "type": "string"
                },
                "srvShardOptimizedConnectionString": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "connectionString",
                "endpoints",
                "srvConnectionString",
                "srvShardOptimizedConnectionString",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClusterConnectionStringPrivateEndpointEndpoint:getAdvancedClusterConnectionStringPrivateEndpointEndpoint": {
            "properties": {
                "endpointId": {
                    "type": "string"
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud service provider on which the servers are provisioned.\n"
                },
                "region": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "endpointId",
                "providerName",
                "region"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClusterLabel:getAdvancedClusterLabel": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key that you want to write.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value that you want to write.\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClusterReplicationSpec:getAdvancedClusterReplicationSpec": {
            "properties": {
                "containerId": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A key-value map of the Network Peering Container ID(s) for the configuration specified in `region_configs`. The Container ID is the id of the container either created programmatically by the user before any clusters existed in a project or when the first cluster in the region (AWS/Azure) or project (GCP) was created.  The syntax is `\"providerName:regionName\" = \"containerId\"`. Example `AWS:US_EAST_1\" = \"61e0797dde08fb498ca11a71`.\n"
                },
                "externalId": {
                    "type": "string"
                },
                "id": {
                    "type": "string",
                    "deprecationMessage": "This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown"
                },
                "numShards": {
                    "type": "integer",
                    "description": "Provide this value if you set a `cluster_type` of `SHARDED` or `GEOSHARDED`. **(DEPRECATED.)** To learn more, see the Migration Guide.\n",
                    "deprecationMessage": "This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown"
                },
                "regionConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClusterReplicationSpecRegionConfig:getAdvancedClusterReplicationSpecRegionConfig"
                    },
                    "description": "Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the zone in a Global Cluster. If clusterType is GEOSHARDED, this value indicates the zone that the given shard belongs to and can be used to configure Global Cluster backup policies.\n"
                },
                "zoneName": {
                    "type": "string",
                    "description": "Name for the zone in a Global Cluster.\n"
                }
            },
            "type": "object",
            "required": [
                "containerId",
                "externalId",
                "id",
                "numShards",
                "regionConfigs",
                "zoneId",
                "zoneName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClusterReplicationSpecRegionConfig:getAdvancedClusterReplicationSpecRegionConfig": {
            "properties": {
                "analyticsAutoScalings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling:getAdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling"
                    },
                    "description": "Configuration for the Collection of settings that configures analytics-auto-scaling information for the cluster. See below\n"
                },
                "analyticsSpecs": {
                    "$ref": "#/types/mongodbatlas:index/getAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs:getAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs",
                    "description": "Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. See below\n"
                },
                "autoScalings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClusterReplicationSpecRegionConfigAutoScaling:getAdvancedClusterReplicationSpecRegionConfigAutoScaling"
                    },
                    "description": "Configuration for the Collection of settings that configures auto-scaling information for the cluster. See below\n"
                },
                "backingProviderName": {
                    "type": "string",
                    "description": "Cloud service provider on which you provision the host for a multi-tenant cluster.\n"
                },
                "electableSpecs": {
                    "$ref": "#/types/mongodbatlas:index/getAdvancedClusterReplicationSpecRegionConfigElectableSpecs:getAdvancedClusterReplicationSpecRegionConfigElectableSpecs",
                    "description": "Hardware specifications for electable nodes in the region.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Election priority of the region.\n"
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud service provider on which the servers are provisioned.\n"
                },
                "readOnlySpecs": {
                    "$ref": "#/types/mongodbatlas:index/getAdvancedClusterReplicationSpecRegionConfigReadOnlySpecs:getAdvancedClusterReplicationSpecRegionConfigReadOnlySpecs",
                    "description": "Hardware specifications for read-only nodes in the region. See below\n"
                },
                "regionName": {
                    "type": "string",
                    "description": "Physical location of your MongoDB cluster.\n"
                }
            },
            "type": "object",
            "required": [
                "analyticsAutoScalings",
                "analyticsSpecs",
                "autoScalings",
                "backingProviderName",
                "electableSpecs",
                "priority",
                "providerName",
                "readOnlySpecs",
                "regionName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling:getAdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling": {
            "properties": {
                "computeEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether instance size auto-scaling is enabled.\n"
                },
                "computeMaxInstanceSize": {
                    "type": "string",
                    "description": "Maximum instance size to which your cluster can automatically scale (such as M40). \n#### Advanced Configuration\n"
                },
                "computeMinInstanceSize": {
                    "type": "string",
                    "description": "Minimum instance size to which your cluster can automatically scale (such as M10).\n"
                },
                "computeScaleDownEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the instance size may scale down.\n"
                },
                "diskGbEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether this cluster enables disk auto-scaling.\n"
                }
            },
            "type": "object",
            "required": [
                "computeEnabled",
                "computeMaxInstanceSize",
                "computeMinInstanceSize",
                "computeScaleDownEnabled",
                "diskGbEnabled"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs:getAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs": {
            "properties": {
                "diskIops": {
                    "type": "integer",
                    "description": "Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.\n"
                },
                "diskSizeGb": {
                    "type": "number",
                    "description": "Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.\n"
                },
                "ebsVolumeType": {
                    "type": "string",
                    "description": "Type of storage you want to attach to your AWS-provisioned cluster. \n* `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.\n* `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.\n"
                },
                "instanceSize": {
                    "type": "string",
                    "description": "Hardware specification for the instance sizes in this region.\n"
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "Number of nodes of the given type for MongoDB Atlas to deploy to the region.\n"
                }
            },
            "type": "object",
            "required": [
                "diskIops",
                "diskSizeGb",
                "ebsVolumeType",
                "instanceSize"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClusterReplicationSpecRegionConfigAutoScaling:getAdvancedClusterReplicationSpecRegionConfigAutoScaling": {
            "properties": {
                "computeEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether instance size auto-scaling is enabled.\n"
                },
                "computeMaxInstanceSize": {
                    "type": "string",
                    "description": "Maximum instance size to which your cluster can automatically scale (such as M40). \n#### Advanced Configuration\n"
                },
                "computeMinInstanceSize": {
                    "type": "string",
                    "description": "Minimum instance size to which your cluster can automatically scale (such as M10).\n"
                },
                "computeScaleDownEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the instance size may scale down.\n"
                },
                "diskGbEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether this cluster enables disk auto-scaling.\n"
                }
            },
            "type": "object",
            "required": [
                "computeEnabled",
                "computeMaxInstanceSize",
                "computeMinInstanceSize",
                "computeScaleDownEnabled",
                "diskGbEnabled"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClusterReplicationSpecRegionConfigElectableSpecs:getAdvancedClusterReplicationSpecRegionConfigElectableSpecs": {
            "properties": {
                "diskIops": {
                    "type": "integer",
                    "description": "Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.\n"
                },
                "diskSizeGb": {
                    "type": "number",
                    "description": "Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.\n"
                },
                "ebsVolumeType": {
                    "type": "string",
                    "description": "Type of storage you want to attach to your AWS-provisioned cluster. \n* `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.\n* `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.\n"
                },
                "instanceSize": {
                    "type": "string",
                    "description": "Hardware specification for the instance sizes in this region.\n"
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "Number of nodes of the given type for MongoDB Atlas to deploy to the region.\n"
                }
            },
            "type": "object",
            "required": [
                "diskIops",
                "diskSizeGb",
                "ebsVolumeType",
                "instanceSize"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClusterReplicationSpecRegionConfigReadOnlySpecs:getAdvancedClusterReplicationSpecRegionConfigReadOnlySpecs": {
            "properties": {
                "diskIops": {
                    "type": "integer",
                    "description": "Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.\n"
                },
                "diskSizeGb": {
                    "type": "number",
                    "description": "Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.\n"
                },
                "ebsVolumeType": {
                    "type": "string",
                    "description": "Type of storage you want to attach to your AWS-provisioned cluster. \n* `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.\n* `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.\n"
                },
                "instanceSize": {
                    "type": "string",
                    "description": "Hardware specification for the instance sizes in this region.\n"
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "Number of nodes of the given type for MongoDB Atlas to deploy to the region.\n"
                }
            },
            "type": "object",
            "required": [
                "diskIops",
                "diskSizeGb",
                "ebsVolumeType",
                "instanceSize"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClusterTag:getAdvancedClusterTag": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key that you want to write.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value that you want to write.\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResult:getAdvancedClustersResult": {
            "properties": {
                "advancedConfigurations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResultAdvancedConfiguration:getAdvancedClustersResultAdvancedConfiguration"
                    },
                    "description": "Get the advanced configuration options. See Advanced Configuration below for more details.\n"
                },
                "backupEnabled": {
                    "type": "boolean"
                },
                "biConnectorConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResultBiConnectorConfig:getAdvancedClustersResultBiConnectorConfig"
                    },
                    "description": "Configuration settings applied to BI Connector for Atlas on this cluster. See below. **NOTE** Prior version of provider had parameter as `bi_connector`\n"
                },
                "clusterType": {
                    "type": "string",
                    "description": "Type of the cluster that you want to create.\n"
                },
                "connectionStrings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResultConnectionString:getAdvancedClustersResultConnectionString"
                    },
                    "description": "Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.\n"
                },
                "createDate": {
                    "type": "string"
                },
                "diskSizeGb": {
                    "type": "number",
                    "description": "Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.\n",
                    "deprecationMessage": "This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown"
                },
                "encryptionAtRestProvider": {
                    "type": "string",
                    "description": "Possible values are AWS, GCP, AZURE or NONE.\n"
                },
                "globalClusterSelfManagedSharding": {
                    "type": "boolean",
                    "description": "Flag that indicates if cluster uses Atlas-Managed Sharding (false) or Self-Managed Sharding (true).\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResultLabel:getAdvancedClustersResultLabel"
                    },
                    "description": "Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.\n",
                    "deprecationMessage": "This parameter is deprecated and will be removed by September 2024. Please transition to tags."
                },
                "mongoDbMajorVersion": {
                    "type": "string",
                    "description": "Version of the cluster to deploy.\n"
                },
                "mongoDbVersion": {
                    "type": "string",
                    "description": "Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.\n"
                },
                "name": {
                    "type": "string"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the cluster is paused or not.\n"
                },
                "pitEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates if the cluster uses Continuous Cloud Backup.\n"
                },
                "replicationSpecs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResultReplicationSpec:getAdvancedClustersResultReplicationSpec"
                    },
                    "description": "List of settings that configure your cluster regions. If `use_replication_spec_per_shard = true`, this array has one object per shard representing node configurations in each shard. For replica sets there is only one object representing node configurations. See below\n"
                },
                "rootCertType": {
                    "type": "string",
                    "description": "Certificate Authority that MongoDB Atlas clusters use.\n"
                },
                "stateName": {
                    "type": "string",
                    "description": "Current state of the cluster. The possible states are:\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResultTag:getAdvancedClustersResultTag"
                    },
                    "description": "Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.\n"
                },
                "terminationProtectionEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n"
                },
                "versionReleaseSystem": {
                    "type": "string",
                    "description": "Release cadence that Atlas uses for this cluster.\n"
                }
            },
            "type": "object",
            "required": [
                "advancedConfigurations",
                "backupEnabled",
                "biConnectorConfigs",
                "clusterType",
                "connectionStrings",
                "createDate",
                "diskSizeGb",
                "encryptionAtRestProvider",
                "globalClusterSelfManagedSharding",
                "labels",
                "mongoDbMajorVersion",
                "mongoDbVersion",
                "name",
                "paused",
                "pitEnabled",
                "replicationSpecs",
                "rootCertType",
                "stateName",
                "tags",
                "terminationProtectionEnabled",
                "versionReleaseSystem"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResultAdvancedConfiguration:getAdvancedClustersResultAdvancedConfiguration": {
            "properties": {
                "defaultReadConcern": {
                    "type": "string",
                    "description": "[Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/). **(DEPRECATED.)** MongoDB 5.0 and later clusters default to `local`. To use a custom read concern level, please refer to your driver documentation.\n",
                    "deprecationMessage": "This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown"
                },
                "defaultWriteConcern": {
                    "type": "string",
                    "description": "[Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).\n"
                },
                "failIndexKeyTooLong": {
                    "type": "boolean",
                    "description": "When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them. **(DEPRECATED.)** This parameter has been removed as of [MongoDB 4.4](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.failIndexKeyTooLong).\n",
                    "deprecationMessage": "This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown"
                },
                "javascriptEnabled": {
                    "type": "boolean",
                    "description": "When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.\n"
                },
                "minimumEnabledTlsProtocol": {
                    "type": "string",
                    "description": "Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:\n"
                },
                "noTableScan": {
                    "type": "boolean",
                    "description": "When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.\n"
                },
                "oplogMinRetentionHours": {
                    "type": "integer",
                    "description": "Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.\n"
                },
                "oplogSizeMb": {
                    "type": "integer",
                    "description": "The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.\n"
                },
                "sampleRefreshIntervalBiConnector": {
                    "type": "integer",
                    "description": "Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.\n"
                },
                "sampleSizeBiConnector": {
                    "type": "integer",
                    "description": "Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.\n"
                },
                "transactionLifetimeLimitSeconds": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "defaultReadConcern",
                "defaultWriteConcern",
                "failIndexKeyTooLong",
                "javascriptEnabled",
                "minimumEnabledTlsProtocol",
                "noTableScan",
                "oplogMinRetentionHours",
                "oplogSizeMb",
                "sampleRefreshIntervalBiConnector",
                "sampleSizeBiConnector",
                "transactionLifetimeLimitSeconds"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResultBiConnectorConfig:getAdvancedClustersResultBiConnectorConfig": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Specifies whether or not BI Connector for Atlas is enabled on the cluster.l\n"
                },
                "readPreference": {
                    "type": "string",
                    "description": "Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).\n"
                }
            },
            "type": "object",
            "required": [
                "enabled",
                "readPreference"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResultConnectionString:getAdvancedClustersResultConnectionString": {
            "properties": {
                "private": {
                    "type": "string",
                    "description": "[Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.\n"
                },
                "privateEndpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResultConnectionStringPrivateEndpoint:getAdvancedClustersResultConnectionStringPrivateEndpoint"
                    },
                    "description": "Private endpoint connection strings. Each object describes the connection strings you can use to connect to this cluster through a private endpoint. Atlas returns this parameter only if you deployed a private endpoint to all regions to which you deployed this cluster's nodes.\n- `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.\n- `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in DNS . Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don't need to: Append the seed list or Change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn't, use `connection_strings.private_endpoint[n].connection_string`\n- `connection_strings.private_endpoint.#.srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster supports it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[n].srvConnectionString.\n- `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.\n- `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`\n- `connection_strings.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.\n- `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.\n- `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.\n"
                },
                "privateSrv": {
                    "type": "string",
                    "description": "[Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.\n"
                },
                "standard": {
                    "type": "string",
                    "description": "Public mongodb:// connection string for this cluster.\n"
                },
                "standardSrv": {
                    "type": "string",
                    "description": "Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you donât need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesnât  , use connectionStrings.standard.\n"
                }
            },
            "type": "object",
            "required": [
                "private",
                "privateEndpoints",
                "privateSrv",
                "standard",
                "standardSrv"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResultConnectionStringPrivateEndpoint:getAdvancedClustersResultConnectionStringPrivateEndpoint": {
            "properties": {
                "connectionString": {
                    "type": "string"
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResultConnectionStringPrivateEndpointEndpoint:getAdvancedClustersResultConnectionStringPrivateEndpointEndpoint"
                    }
                },
                "srvConnectionString": {
                    "type": "string"
                },
                "srvShardOptimizedConnectionString": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "connectionString",
                "endpoints",
                "srvConnectionString",
                "srvShardOptimizedConnectionString",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResultConnectionStringPrivateEndpointEndpoint:getAdvancedClustersResultConnectionStringPrivateEndpointEndpoint": {
            "properties": {
                "endpointId": {
                    "type": "string"
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud service provider on which the servers are provisioned.\n"
                },
                "region": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "endpointId",
                "providerName",
                "region"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResultLabel:getAdvancedClustersResultLabel": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key that you want to write.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value that you want to write.\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResultReplicationSpec:getAdvancedClustersResultReplicationSpec": {
            "properties": {
                "containerId": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A key-value map of the Network Peering Container ID(s) for the configuration specified in `region_configs`. The Container ID is the id of the container either created programmatically by the user before any clusters existed in a project or when the first cluster in the region (AWS/Azure) or project (GCP) was created.  The syntax is `\"providerName:regionName\" = \"containerId\"`. Example `AWS:US_EAST_1\" = \"61e0797dde08fb498ca11a71`.\n"
                },
                "externalId": {
                    "type": "string"
                },
                "id": {
                    "type": "string",
                    "deprecationMessage": "This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown"
                },
                "numShards": {
                    "type": "integer",
                    "description": "Provide this value if you set a `cluster_type` of SHARDED or GEOSHARDED. **(DEPRECATED.)** To learn more, see the Migration Guide for more details.\n",
                    "deprecationMessage": "This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown"
                },
                "regionConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResultReplicationSpecRegionConfig:getAdvancedClustersResultReplicationSpecRegionConfig"
                    },
                    "description": "Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the zone in a Global Cluster. If clusterType is GEOSHARDED, this value indicates the zone that the given shard belongs to and can be used to configure Global Cluster backup policies.\n"
                },
                "zoneName": {
                    "type": "string",
                    "description": "Name for the zone in a Global Cluster.\n"
                }
            },
            "type": "object",
            "required": [
                "containerId",
                "externalId",
                "id",
                "numShards",
                "regionConfigs",
                "zoneId",
                "zoneName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResultReplicationSpecRegionConfig:getAdvancedClustersResultReplicationSpecRegionConfig": {
            "properties": {
                "analyticsAutoScalings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResultReplicationSpecRegionConfigAnalyticsAutoScaling:getAdvancedClustersResultReplicationSpecRegionConfigAnalyticsAutoScaling"
                    },
                    "description": "Configuration for the Collection of settings that configures analytis-auto-scaling information for the cluster. See below\n"
                },
                "analyticsSpecs": {
                    "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecs:getAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecs",
                    "description": "Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. See below\n"
                },
                "autoScalings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResultReplicationSpecRegionConfigAutoScaling:getAdvancedClustersResultReplicationSpecRegionConfigAutoScaling"
                    },
                    "description": "Configuration for the Collection of settings that configures auto-scaling information for the cluster. See below\n"
                },
                "backingProviderName": {
                    "type": "string",
                    "description": "Cloud service provider on which you provision the host for a multi-tenant cluster.\n"
                },
                "electableSpecs": {
                    "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResultReplicationSpecRegionConfigElectableSpecs:getAdvancedClustersResultReplicationSpecRegionConfigElectableSpecs",
                    "description": "Hardware specifications for electable nodes in the region.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Election priority of the region.\n"
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud service provider on which the servers are provisioned.\n"
                },
                "readOnlySpecs": {
                    "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecs:getAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecs",
                    "description": "Hardware specifications for read-only nodes in the region. See below\n"
                },
                "regionName": {
                    "type": "string",
                    "description": "Physical location of your MongoDB cluster.\n"
                }
            },
            "type": "object",
            "required": [
                "analyticsAutoScalings",
                "analyticsSpecs",
                "autoScalings",
                "backingProviderName",
                "electableSpecs",
                "priority",
                "providerName",
                "readOnlySpecs",
                "regionName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResultReplicationSpecRegionConfigAnalyticsAutoScaling:getAdvancedClustersResultReplicationSpecRegionConfigAnalyticsAutoScaling": {
            "properties": {
                "computeEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether instance size auto-scaling is enabled.\n"
                },
                "computeMaxInstanceSize": {
                    "type": "string",
                    "description": "Maximum instance size to which your cluster can automatically scale (such as M40).\n"
                },
                "computeMinInstanceSize": {
                    "type": "string",
                    "description": "Minimum instance size to which your cluster can automatically scale (such as M10).\n"
                },
                "computeScaleDownEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the instance size may scale down.\n"
                },
                "diskGbEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether this cluster enables disk auto-scaling.\n"
                }
            },
            "type": "object",
            "required": [
                "computeEnabled",
                "computeMaxInstanceSize",
                "computeMinInstanceSize",
                "computeScaleDownEnabled",
                "diskGbEnabled"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecs:getAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecs": {
            "properties": {
                "diskIops": {
                    "type": "integer",
                    "description": "Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.\n"
                },
                "diskSizeGb": {
                    "type": "number",
                    "description": "Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.\n"
                },
                "ebsVolumeType": {
                    "type": "string",
                    "description": "Type of storage you want to attach to your AWS-provisioned cluster.\n* `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.\n* `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.\n"
                },
                "instanceSize": {
                    "type": "string",
                    "description": "Hardware specification for the instance sizes in this region.\n"
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "Number of nodes of the given type for MongoDB Atlas to deploy to the region.\n"
                }
            },
            "type": "object",
            "required": [
                "diskIops",
                "diskSizeGb",
                "ebsVolumeType",
                "instanceSize"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResultReplicationSpecRegionConfigAutoScaling:getAdvancedClustersResultReplicationSpecRegionConfigAutoScaling": {
            "properties": {
                "computeEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether instance size auto-scaling is enabled.\n"
                },
                "computeMaxInstanceSize": {
                    "type": "string",
                    "description": "Maximum instance size to which your cluster can automatically scale (such as M40).\n"
                },
                "computeMinInstanceSize": {
                    "type": "string",
                    "description": "Minimum instance size to which your cluster can automatically scale (such as M10).\n"
                },
                "computeScaleDownEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the instance size may scale down.\n"
                },
                "diskGbEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether this cluster enables disk auto-scaling.\n"
                }
            },
            "type": "object",
            "required": [
                "computeEnabled",
                "computeMaxInstanceSize",
                "computeMinInstanceSize",
                "computeScaleDownEnabled",
                "diskGbEnabled"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResultReplicationSpecRegionConfigElectableSpecs:getAdvancedClustersResultReplicationSpecRegionConfigElectableSpecs": {
            "properties": {
                "diskIops": {
                    "type": "integer",
                    "description": "Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.\n"
                },
                "diskSizeGb": {
                    "type": "number",
                    "description": "Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.\n"
                },
                "ebsVolumeType": {
                    "type": "string",
                    "description": "Type of storage you want to attach to your AWS-provisioned cluster.\n* `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.\n* `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.\n"
                },
                "instanceSize": {
                    "type": "string",
                    "description": "Hardware specification for the instance sizes in this region.\n"
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "Number of nodes of the given type for MongoDB Atlas to deploy to the region.\n"
                }
            },
            "type": "object",
            "required": [
                "diskIops",
                "diskSizeGb",
                "ebsVolumeType",
                "instanceSize"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecs:getAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecs": {
            "properties": {
                "diskIops": {
                    "type": "integer",
                    "description": "Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.\n"
                },
                "diskSizeGb": {
                    "type": "number",
                    "description": "Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.\n"
                },
                "ebsVolumeType": {
                    "type": "string",
                    "description": "Type of storage you want to attach to your AWS-provisioned cluster.\n* `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.\n* `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.\n"
                },
                "instanceSize": {
                    "type": "string",
                    "description": "Hardware specification for the instance sizes in this region.\n"
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "Number of nodes of the given type for MongoDB Atlas to deploy to the region.\n"
                }
            },
            "type": "object",
            "required": [
                "diskIops",
                "diskSizeGb",
                "ebsVolumeType",
                "instanceSize"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAdvancedClustersResultTag:getAdvancedClustersResultTag": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key that you want to write.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value that you want to write.\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAlertConfigurationMatcher:getAlertConfigurationMatcher": {
            "properties": {
                "fieldName": {
                    "type": "string",
                    "description": "Name of the field in the target object to match on.\n"
                },
                "operator": {
                    "type": "string",
                    "description": "The operator to apply when checking the current metric value against the threshold value.\nAccepted values are:\n- `GREATER_THAN`\n- `LESS_THAN`\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:\n- `PRIMARY`\n- `SECONDARY`\n- `STANDALONE`\n- `CONFIG`\n- `MONGOS`\n"
                }
            },
            "type": "object",
            "required": [
                "fieldName",
                "operator",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAlertConfigurationMetricThresholdConfig:getAlertConfigurationMetricThresholdConfig": {
            "properties": {
                "metricName": {
                    "type": "string",
                    "description": "Name of the metric to check. The full list being quite large, please refer to atlas docs [here for general metrics](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types) and [here for serverless metrics](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-create-config/#serverless-measurements)\n"
                },
                "mode": {
                    "type": "string",
                    "description": "This must be set to AVERAGE. Atlas computes the current metric value as an average.\n"
                },
                "operator": {
                    "type": "string",
                    "description": "The operator to apply when checking the current metric value against the threshold value.\nAccepted values are:\n- `GREATER_THAN`\n- `LESS_THAN`\n"
                },
                "threshold": {
                    "type": "number",
                    "description": "Threshold value outside of which an alert will be triggered.\n"
                },
                "units": {
                    "type": "string",
                    "description": "The units for the threshold value. Depends on the type of metric.\nRefer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.\n"
                }
            },
            "type": "object",
            "required": [
                "metricName",
                "mode",
                "operator",
                "threshold",
                "units"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAlertConfigurationNotification:getAlertConfigurationNotification": {
            "properties": {
                "apiToken": {
                    "type": "string",
                    "description": "Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.\n",
                    "secret": true
                },
                "channelName": {
                    "type": "string",
                    "description": "Slack channel name. Required for the SLACK notifications type.\n"
                },
                "datadogApiKey": {
                    "type": "string",
                    "description": "Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.\n",
                    "secret": true
                },
                "datadogRegion": {
                    "type": "string",
                    "description": "Region that indicates which API URL to use. See the `datadogRegion` field in the `notifications` request parameter of [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Alert-Configurations/operation/createAlertConfiguration) for more details. The default Datadog region is US.\n"
                },
                "delayMin": {
                    "type": "integer",
                    "description": "Number of minutes to wait after an alert condition is detected before sending out the first notification.\n"
                },
                "emailAddress": {
                    "type": "string",
                    "description": "Email address to which alert notifications are sent. Required for the EMAIL notifications type.\n"
                },
                "emailEnabled": {
                    "type": "boolean",
                    "description": "Flag indicating email notifications should be sent. Atlas returns this value if `type_name` is set  to `ORG`, `GROUP`, or `USER`.\n"
                },
                "integrationId": {
                    "type": "string",
                    "description": "The ID of the associated integration, the credentials of which to use for requests.\n"
                },
                "intervalMin": {
                    "type": "integer",
                    "description": "Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5.\n"
                },
                "microsoftTeamsWebhookUrl": {
                    "type": "string",
                    "description": "Microsoft Teams channel incoming webhook URL. Required for the `MICROSOFT_TEAMS` notifications type.\n",
                    "secret": true
                },
                "mobileNumber": {
                    "type": "string",
                    "description": "Mobile number to which alert notifications are sent. Required for the SMS notifications type.\n"
                },
                "notifierId": {
                    "type": "string",
                    "description": "The notifier ID is a system-generated unique identifier assigned to each notification method. This is needed when updating third-party notifications without requiring explicit authentication credentials.\n"
                },
                "opsGenieApiKey": {
                    "type": "string",
                    "description": "Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.\n",
                    "secret": true
                },
                "opsGenieRegion": {
                    "type": "string",
                    "description": "Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Atlas role in current Project or Organization. Atlas returns this value if you set `type_name` to `ORG` or `GROUP`.\n"
                },
                "serviceKey": {
                    "type": "string",
                    "description": "PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.\n",
                    "secret": true
                },
                "smsEnabled": {
                    "type": "boolean",
                    "description": "Flag indicating text notifications should be sent. Atlas returns this value if `type_name` is set to `ORG`, `GROUP`, or `USER`.\n"
                },
                "teamId": {
                    "type": "string",
                    "description": "Unique identifier of a team.\n"
                },
                "teamName": {
                    "type": "string",
                    "description": "Label for the team that receives this notification.\n"
                },
                "typeName": {
                    "type": "string",
                    "description": "Type of alert notification.\nAccepted values are:\n- `DATADOG`\n- `EMAIL`\n- `GROUP` (Project)\n- `OPS_GENIE`\n- `ORG`\n- `PAGER_DUTY`\n- `SLACK`\n- `SMS`\n- `TEAM`\n- `USER`\n- `VICTOR_OPS`\n- `WEBHOOK`\n- `MICROSOFT_TEAMS`\n"
                },
                "username": {
                    "type": "string",
                    "description": "Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.\n"
                },
                "victorOpsApiKey": {
                    "type": "string",
                    "description": "VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.\n",
                    "secret": true
                },
                "victorOpsRoutingKey": {
                    "type": "string",
                    "description": "VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.\n",
                    "secret": true
                },
                "webhookSecret": {
                    "type": "string",
                    "description": "Authentication secret for the `WEBHOOK` notifications type.\n",
                    "secret": true
                },
                "webhookUrl": {
                    "type": "string",
                    "description": "Target URL  for the `WEBHOOK` notifications type.\n",
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "apiToken",
                "channelName",
                "datadogApiKey",
                "datadogRegion",
                "delayMin",
                "emailAddress",
                "emailEnabled",
                "integrationId",
                "intervalMin",
                "microsoftTeamsWebhookUrl",
                "mobileNumber",
                "notifierId",
                "opsGenieApiKey",
                "opsGenieRegion",
                "roles",
                "serviceKey",
                "smsEnabled",
                "teamId",
                "teamName",
                "typeName",
                "username",
                "victorOpsApiKey",
                "victorOpsRoutingKey",
                "webhookSecret",
                "webhookUrl"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAlertConfigurationOutput:getAlertConfigurationOutput": {
            "properties": {
                "label": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                },
                "value": {
                    "type": "string",
                    "description": "Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:\n- `PRIMARY`\n- `SECONDARY`\n- `STANDALONE`\n- `CONFIG`\n- `MONGOS`\n"
                }
            },
            "type": "object",
            "required": [
                "type",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": [
                        "type"
                    ]
                }
            }
        },
        "mongodbatlas:index/getAlertConfigurationThresholdConfig:getAlertConfigurationThresholdConfig": {
            "properties": {
                "operator": {
                    "type": "string",
                    "description": "The operator to apply when checking the current metric value against the threshold value.\nAccepted values are:\n- `GREATER_THAN`\n- `LESS_THAN`\n"
                },
                "threshold": {
                    "type": "number",
                    "description": "Threshold value outside of which an alert will be triggered.\n"
                },
                "units": {
                    "type": "string",
                    "description": "The units for the threshold value. Depends on the type of metric.\nRefer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.\n"
                }
            },
            "type": "object",
            "required": [
                "operator",
                "threshold",
                "units"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAlertConfigurationsListOption:getAlertConfigurationsListOption": {
            "properties": {
                "includeCount": {
                    "type": "boolean"
                },
                "itemsPerPage": {
                    "type": "integer"
                },
                "pageNum": {
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "mongodbatlas:index/getAlertConfigurationsResult:getAlertConfigurationsResult": {
            "properties": {
                "alertConfigurationId": {
                    "type": "string",
                    "description": "The ID of the alert configuration\n"
                },
                "created": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when this alert configuration was created.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "If set to true, the alert configuration is enabled. If enabled is not exported it is set to false.\n"
                },
                "eventType": {
                    "type": "string",
                    "description": "The type of event that will trigger an alert.\n"
                },
                "id": {
                    "type": "string"
                },
                "matchers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAlertConfigurationsResultMatcher:getAlertConfigurationsResultMatcher"
                    },
                    "description": "Rules to apply when matching an object against this alert configuration. See matchers.\n"
                },
                "metricThresholdConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAlertConfigurationsResultMetricThresholdConfig:getAlertConfigurationsResultMetricThresholdConfig"
                    },
                    "description": "The threshold that causes an alert to be triggered. Required if `event_type_name` : `OUTSIDE_METRIC_THRESHOLD` or `OUTSIDE_SERVERLESS_METRIC_THRESHOLD`. See metric threshold config.\n"
                },
                "notifications": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAlertConfigurationsResultNotification:getAlertConfigurationsResultNotification"
                    }
                },
                "outputs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAlertConfigurationsResultOutput:getAlertConfigurationsResultOutput"
                    },
                    "description": "Requested output string format for the alert configuration\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to get the alert configurations.\n"
                },
                "thresholdConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAlertConfigurationsResultThresholdConfig:getAlertConfigurationsResultThresholdConfig"
                    },
                    "description": "Threshold that triggers an alert. Required if `event_type_name` is any value other than `OUTSIDE_METRIC_THRESHOLD` or `OUTSIDE_SERVERLESS_METRIC_THRESHOLD`. See threshold config.\n"
                },
                "updated": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when this alert configuration was last updated.\n"
                }
            },
            "type": "object",
            "required": [
                "alertConfigurationId",
                "created",
                "enabled",
                "eventType",
                "id",
                "matchers",
                "metricThresholdConfigs",
                "notifications",
                "outputs",
                "projectId",
                "thresholdConfigs",
                "updated"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAlertConfigurationsResultMatcher:getAlertConfigurationsResultMatcher": {
            "properties": {
                "fieldName": {
                    "type": "string",
                    "description": "Name of the field in the target object to match on.\n"
                },
                "operator": {
                    "type": "string",
                    "description": "The operator to apply when checking the current metric value against the threshold value.\nAccepted values are:\n- `GREATER_THAN`\n- `LESS_THAN`\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:\n- `PRIMARY`\n- `SECONDARY`\n- `STANDALONE`\n- `CONFIG`\n- `MONGOS`\n"
                }
            },
            "type": "object",
            "required": [
                "fieldName",
                "operator",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAlertConfigurationsResultMetricThresholdConfig:getAlertConfigurationsResultMetricThresholdConfig": {
            "properties": {
                "metricName": {
                    "type": "string",
                    "description": "Name of the metric to check. The full list being quite large, please refer to atlas docs [here for general metrics](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types) and [here for serverless metrics](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-create-config/#serverless-measurements)\n"
                },
                "mode": {
                    "type": "string",
                    "description": "This must be set to AVERAGE. Atlas computes the current metric value as an average.\n"
                },
                "operator": {
                    "type": "string",
                    "description": "The operator to apply when checking the current metric value against the threshold value.\nAccepted values are:\n- `GREATER_THAN`\n- `LESS_THAN`\n"
                },
                "threshold": {
                    "type": "number",
                    "description": "Threshold value outside of which an alert will be triggered.\n"
                },
                "units": {
                    "type": "string",
                    "description": "The units for the threshold value. Depends on the type of metric.\nRefer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.\n"
                }
            },
            "type": "object",
            "required": [
                "metricName",
                "mode",
                "operator",
                "threshold",
                "units"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAlertConfigurationsResultNotification:getAlertConfigurationsResultNotification": {
            "properties": {
                "apiToken": {
                    "type": "string",
                    "description": "Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.\n",
                    "secret": true
                },
                "channelName": {
                    "type": "string",
                    "description": "Slack channel name. Required for the SLACK notifications type.\n"
                },
                "datadogApiKey": {
                    "type": "string",
                    "description": "Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.\n",
                    "secret": true
                },
                "datadogRegion": {
                    "type": "string",
                    "description": "Region that indicates which API URL to use. See the `datadogRegion` field in the `notifications` request parameter of [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Alert-Configurations/operation/createAlertConfiguration) for more details. The default Datadog region is US.\n"
                },
                "delayMin": {
                    "type": "integer",
                    "description": "Number of minutes to wait after an alert condition is detected before sending out the first notification.\n"
                },
                "emailAddress": {
                    "type": "string",
                    "description": "Email address to which alert notifications are sent. Required for the EMAIL notifications type.\n"
                },
                "emailEnabled": {
                    "type": "boolean",
                    "description": "Flag indicating email notifications should be sent. Atlas returns this value if `type_name` is set  to `ORG`, `GROUP`, or `USER`.\n"
                },
                "integrationId": {
                    "type": "string",
                    "description": "The ID of the associated integration, the credentials of which to use for requests.\n"
                },
                "intervalMin": {
                    "type": "integer",
                    "description": "Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5.\n"
                },
                "microsoftTeamsWebhookUrl": {
                    "type": "string",
                    "description": "Microsoft Teams channel incoming webhook URL. Required for the `MICROSOFT_TEAMS` notifications type.\n",
                    "secret": true
                },
                "mobileNumber": {
                    "type": "string",
                    "description": "Mobile number to which alert notifications are sent. Required for the SMS notifications type.\n"
                },
                "notifierId": {
                    "type": "string",
                    "description": "The notifier ID is a system-generated unique identifier assigned to each notification method. This is needed when updating third-party notifications without requiring explicit authentication credentials.\n"
                },
                "opsGenieApiKey": {
                    "type": "string",
                    "description": "Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.\n",
                    "secret": true
                },
                "opsGenieRegion": {
                    "type": "string",
                    "description": "Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Atlas role in current Project or Organization. Atlas returns this value if you set `type_name` to `ORG` or `GROUP`.\n"
                },
                "serviceKey": {
                    "type": "string",
                    "description": "PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.\n",
                    "secret": true
                },
                "smsEnabled": {
                    "type": "boolean",
                    "description": "Flag indicating text notifications should be sent. Atlas returns this value if `type_name` is set to `ORG`, `GROUP`, or `USER`.\n"
                },
                "teamId": {
                    "type": "string",
                    "description": "Unique identifier of a team.\n"
                },
                "teamName": {
                    "type": "string",
                    "description": "Label for the team that receives this notification.\n"
                },
                "typeName": {
                    "type": "string",
                    "description": "Type of alert notification.\nAccepted values are:\n- `DATADOG`\n- `EMAIL`\n- `GROUP` (Project)\n- `OPS_GENIE`\n- `ORG`\n- `PAGER_DUTY`\n- `SLACK`\n- `SMS`\n- `TEAM`\n- `USER`\n- `VICTOR_OPS`\n- `WEBHOOK`\n- `MICROSOFT_TEAMS`\n"
                },
                "username": {
                    "type": "string",
                    "description": "Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.\n"
                },
                "victorOpsApiKey": {
                    "type": "string",
                    "description": "VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.\n",
                    "secret": true
                },
                "victorOpsRoutingKey": {
                    "type": "string",
                    "description": "VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.\n",
                    "secret": true
                },
                "webhookSecret": {
                    "type": "string",
                    "description": "Authentication secret for the `WEBHOOK` notifications type.\n",
                    "secret": true
                },
                "webhookUrl": {
                    "type": "string",
                    "description": "Target URL  for the `WEBHOOK` notifications type.\n",
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "apiToken",
                "channelName",
                "datadogApiKey",
                "datadogRegion",
                "delayMin",
                "emailAddress",
                "emailEnabled",
                "integrationId",
                "intervalMin",
                "microsoftTeamsWebhookUrl",
                "mobileNumber",
                "notifierId",
                "opsGenieApiKey",
                "opsGenieRegion",
                "roles",
                "serviceKey",
                "smsEnabled",
                "teamId",
                "teamName",
                "typeName",
                "username",
                "victorOpsApiKey",
                "victorOpsRoutingKey",
                "webhookSecret",
                "webhookUrl"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAlertConfigurationsResultOutput:getAlertConfigurationsResultOutput": {
            "properties": {
                "label": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                },
                "value": {
                    "type": "string",
                    "description": "Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:\n- `PRIMARY`\n- `SECONDARY`\n- `STANDALONE`\n- `CONFIG`\n- `MONGOS`\n"
                }
            },
            "type": "object",
            "required": [
                "label",
                "type",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAlertConfigurationsResultThresholdConfig:getAlertConfigurationsResultThresholdConfig": {
            "properties": {
                "operator": {
                    "type": "string",
                    "description": "The operator to apply when checking the current metric value against the threshold value.\nAccepted values are:\n- `GREATER_THAN`\n- `LESS_THAN`\n"
                },
                "threshold": {
                    "type": "number",
                    "description": "Threshold value outside of which an alert will be triggered.\n"
                },
                "units": {
                    "type": "string",
                    "description": "The units for the threshold value. Depends on the type of metric.\nRefer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.\n"
                }
            },
            "type": "object",
            "required": [
                "operator",
                "threshold",
                "units"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getApiKeysResult:getApiKeysResult": {
            "properties": {
                "apiKeyId": {
                    "type": "string",
                    "description": "Unique identifier for the API key you want to update. Use the /orgs/{ORG-ID}/apiKeys endpoint to retrieve all API keys to which the authenticated user has access for the specified organization.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of this Organization API key.\n"
                },
                "publicKey": {
                    "type": "string"
                },
                "roleNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Name of the role. This resource returns all the roles the user has in Atlas.\n\nThe following are valid roles:\n* `ORG_OWNER`\n* `ORG_GROUP_CREATOR`\n* `ORG_BILLING_ADMIN`\n* `ORG_READ_ONLY`\n* `ORG_MEMBER`\n\nSee [MongoDB Atlas API - Return All Organization API Keys](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Programmatic-API-Keys/operation/listApiKeys) - Documentation for more information.\n"
                }
            },
            "type": "object",
            "required": [
                "apiKeyId",
                "description",
                "publicKey",
                "roleNames"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAtlasUserLink:getAtlasUserLink": {
            "properties": {
                "href": {
                    "type": "string"
                },
                "rel": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "href",
                "rel"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAtlasUserRole:getAtlasUserRole": {
            "properties": {
                "groupId": {
                    "type": "string"
                },
                "orgId": {
                    "type": "string"
                },
                "roleName": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "groupId",
                "orgId",
                "roleName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAtlasUsersResult:getAtlasUsersResult": {
            "properties": {
                "country": {
                    "type": "string",
                    "description": "Two alphabet characters that identifies MongoDB Cloud user's geographic location. This parameter uses the ISO 3166-1a2 code format.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Date and time when the current account is created. This value is in the ISO 8601 timestamp format in UTC.\n"
                },
                "emailAddress": {
                    "type": "string",
                    "description": "Email address that belongs to the MongoDB Atlas user.\n"
                },
                "firstName": {
                    "type": "string",
                    "description": "First or given name that belongs to the MongoDB Atlas user.\n"
                },
                "id": {
                    "type": "string"
                },
                "lastAuth": {
                    "type": "string",
                    "description": "Date and time when the current account last authenticated. This value is in the ISO 8601 timestamp format in UTC.\n"
                },
                "lastName": {
                    "type": "string",
                    "description": "Last name, family name, or surname that belongs to the MongoDB Atlas user.\n"
                },
                "links": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAtlasUsersResultLink:getAtlasUsersResultLink"
                    }
                },
                "mobileNumber": {
                    "type": "string",
                    "description": "Mobile phone number that belongs to the MongoDB Atlas user.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getAtlasUsersResultRole:getAtlasUsersResultRole"
                    }
                },
                "teamIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of unique 24-hexadecimal digit strings that identifies the teams to which this MongoDB Atlas user belongs.\n* `links.#.href` - Uniform Resource Locator (URL) that points another API resource to which this response has some relationship. This URL often begins with https://cloud.mongodb.com/api/atlas.\n* `links.#.rel` - Uniform Resource Locator (URL) that defines the semantic relationship between this resource and another API resource. This URL often begins with https://cloud.mongodb.com/api/atlas.\n* `roles.#.group_id` - Unique 24-hexadecimal digit string that identifies the project to which this role belongs. You can set a value for this parameter or orgId but not both in the same request.\n* `roles.#.org_id` - Unique 24-hexadecimal digit string that identifies the organization to which this role belongs. You can set a value for this parameter or groupId but not both in the same request.\n* `roles.#.role_name` - Human-readable label that identifies the collection of privileges that MongoDB Atlas grants a specific API key, user, or team. These roles include organization- and project-level roles. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#service-user-roles) describes the valid roles that can be assigned.\n"
                },
                "userId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies this user.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Email address that belongs to the MongoDB Atlas user account. You cannot modify this address after creating the user.\n"
                }
            },
            "type": "object",
            "required": [
                "country",
                "createdAt",
                "emailAddress",
                "firstName",
                "id",
                "lastAuth",
                "lastName",
                "links",
                "mobileNumber",
                "roles",
                "teamIds",
                "userId",
                "username"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAtlasUsersResultLink:getAtlasUsersResultLink": {
            "properties": {
                "href": {
                    "type": "string"
                },
                "rel": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "href",
                "rel"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getAtlasUsersResultRole:getAtlasUsersResultRole": {
            "properties": {
                "groupId": {
                    "type": "string"
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization whose users you want to return. Also needed when `team_id` attributes is defined.\n"
                },
                "roleName": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "groupId",
                "orgId",
                "roleName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getBackupCompliancePolicyOnDemandPolicyItem:getBackupCompliancePolicyOnDemandPolicyItem": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are\n"
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n"
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.\n"
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.\n"
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "frequencyType",
                "id",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getBackupCompliancePolicyPolicyItemDaily:getBackupCompliancePolicyPolicyItemDaily": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are\n"
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n"
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.\n"
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.\n"
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "frequencyType",
                "id",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getBackupCompliancePolicyPolicyItemHourly:getBackupCompliancePolicyPolicyItemHourly": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are\n"
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n"
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.\n"
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.\n"
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "frequencyType",
                "id",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getBackupCompliancePolicyPolicyItemMonthly:getBackupCompliancePolicyPolicyItemMonthly": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are\n"
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n"
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.\n"
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.\n"
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "frequencyType",
                "id",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getBackupCompliancePolicyPolicyItemWeekly:getBackupCompliancePolicyPolicyItemWeekly": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are\n"
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n"
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.\n"
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.\n"
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "frequencyType",
                "id",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getBackupCompliancePolicyPolicyItemYearly:getBackupCompliancePolicyPolicyItemYearly": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are\n"
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n"
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.\n"
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.\n"
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "frequencyType",
                "id",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupScheduleCopySetting:getCloudBackupScheduleCopySetting": {
            "properties": {
                "cloudProvider": {
                    "type": "string",
                    "description": "Human-readable label that identifies the cloud provider that stores the snapshot copy. i.e. \"AWS\" \"AZURE\" \"GCP\"\n"
                },
                "frequencies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List that describes which types of snapshots to copy. i.e. \"HOURLY\" \"DAILY\" \"WEEKLY\" \"MONTHLY\" \"YEARLY\" \"ON_DEMAND\"\n"
                },
                "regionName": {
                    "type": "string",
                    "description": "Target region to copy snapshots belonging to replicationSpecId to. Please supply the 'Atlas Region' which can be found under https://www.mongodb.com/docs/atlas/reference/cloud-providers/ 'regions' link\n"
                },
                "replicationSpecId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the replication object for a zone in a cluster. For global clusters, there can be multiple zones to choose from. For sharded clusters and replica set clusters, there is only one zone in the cluster. To find the Replication Spec Id, consult the replicationSpecs array returned from [Return One Multi-Cloud Cluster in One Project](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Clusters/operation/getCluster). **(DEPRECATED)** Use `zone_id` instead. To learn more, see the 1.18.0 upgrade guide.\n",
                    "deprecationMessage": "This parameter is deprecated. Please transition to `copy_settings.#.zone_id`. To learn more, see our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown"
                },
                "shouldCopyOplogs": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to copy the oplogs to the target region. You can use the oplogs to perform point-in-time restores.\n"
                },
                "zoneId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the zone in a cluster. For global clusters, there can be multiple zones to choose from. For sharded clusters and replica set clusters, there is only one zone in the cluster.\n"
                }
            },
            "type": "object",
            "required": [
                "cloudProvider",
                "frequencies",
                "regionName",
                "replicationSpecId",
                "shouldCopyOplogs",
                "zoneId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupScheduleExport:getCloudBackupScheduleExport": {
            "properties": {
                "exportBucketId": {
                    "type": "string",
                    "description": "Unique identifier of the mongodbatlas.CloudBackupSnapshotExportBucket export_bucket_id value.\n"
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n"
                }
            },
            "type": "object",
            "required": [
                "exportBucketId",
                "frequencyType"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSchedulePolicyItemDaily:getCloudBackupSchedulePolicyItemDaily": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are\n"
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n"
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.\n"
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.\n"
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "frequencyType",
                "id",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSchedulePolicyItemHourly:getCloudBackupSchedulePolicyItemHourly": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are\n"
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n"
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.\n"
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.\n"
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "frequencyType",
                "id",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSchedulePolicyItemMonthly:getCloudBackupSchedulePolicyItemMonthly": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are\n"
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n"
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.\n"
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.\n"
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "frequencyType",
                "id",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSchedulePolicyItemWeekly:getCloudBackupSchedulePolicyItemWeekly": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are\n"
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n"
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.\n"
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.\n"
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "frequencyType",
                "id",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSchedulePolicyItemYearly:getCloudBackupSchedulePolicyItemYearly": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer",
                    "description": "Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are\n"
                },
                "frequencyType": {
                    "type": "string",
                    "description": "Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy item.\n"
                },
                "retentionUnit": {
                    "type": "string",
                    "description": "Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.\n"
                },
                "retentionValue": {
                    "type": "integer",
                    "description": "Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.\n"
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "frequencyType",
                "id",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotExportBucketsResult:getCloudBackupSnapshotExportBucketsResult": {
            "properties": {
                "bucketName": {
                    "type": "string",
                    "description": "Name of the bucket that the provided role ID is authorized to access.\n"
                },
                "cloudProvider": {
                    "type": "string",
                    "description": "Name of the provider of the cloud service where Atlas can access the S3 bucket.\n"
                },
                "exportBucketId": {
                    "type": "string",
                    "description": "Unique identifier of the snapshot bucket id.\n"
                },
                "iamRoleId": {
                    "type": "string",
                    "description": "Unique identifier of the role that Atlas can use to access the bucket.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "Unique identifier of the Azure Service Principal that Atlas can use to access the Azure Blob Storage Container.\n"
                },
                "serviceUrl": {
                    "type": "string",
                    "description": "URL that identifies the blob Endpoint of the Azure Blob Storage Account.\n"
                },
                "tenantId": {
                    "type": "string",
                    "description": "UUID that identifies the Azure Active Directory Tenant ID.\n"
                }
            },
            "type": "object",
            "required": [
                "bucketName",
                "cloudProvider",
                "exportBucketId",
                "iamRoleId",
                "roleId",
                "serviceUrl",
                "tenantId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotExportJobComponent:getCloudBackupSnapshotExportJobComponent": {
            "properties": {
                "exportId": {
                    "type": "string",
                    "description": "_Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.\n"
                },
                "replicaSetName": {
                    "type": "string",
                    "description": "_Returned for sharded clusters only._ Unique identifier of the export job for the replica set.\n"
                }
            },
            "type": "object",
            "required": [
                "exportId",
                "replicaSetName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotExportJobCustomData:getCloudBackupSnapshotExportJobCustomData": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "Custom data specified as key in the key and value pair.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value for the key specified using `key`.\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotExportJobsResult:getCloudBackupSnapshotExportJobsResult": {
            "properties": {
                "components": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getCloudBackupSnapshotExportJobsResultComponent:getCloudBackupSnapshotExportJobsResultComponent"
                    },
                    "description": "_Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when the export job was created.\n"
                },
                "customDatas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getCloudBackupSnapshotExportJobsResultCustomData:getCloudBackupSnapshotExportJobsResultCustomData"
                    },
                    "description": "Custom data to include in the metadata file named `.complete` that Atlas uploads to the bucket when the export job finishes. Custom data can be specified as key and value pairs.\n"
                },
                "errMsg": {
                    "type": "string",
                    "description": "Error message, only if the export job failed. **Note:** This attribute is deprecated as it is not being used.\n",
                    "deprecationMessage": "This parameter is deprecated and will be removed in version 1.20.0."
                },
                "exportBucketId": {
                    "type": "string",
                    "description": "Unique identifier of the AWS bucket to export the Cloud Backup snapshot to.\n"
                },
                "exportJobId": {
                    "type": "string",
                    "description": "Unique identifier of the export job.\n* `prefix ` - Full path on the cloud provider bucket to the folder where the snapshot is exported. The path is in the following format:`/exported_snapshots/{ORG-NAME}/{PROJECT-NAME}/{CLUSTER-NAME}/{SNAPSHOT-INITIATION-DATE}/{TIMESTAMP}`\n"
                },
                "exportStatusExportedCollections": {
                    "type": "integer"
                },
                "exportStatusTotalCollections": {
                    "type": "integer"
                },
                "finishedAt": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when the export job completes.\n"
                },
                "prefix": {
                    "type": "string"
                },
                "snapshotId": {
                    "type": "string",
                    "description": "Unique identifier of the Cloud Backup snapshot to export.\n"
                },
                "state": {
                    "type": "string",
                    "description": "Status of the export job. Value can be one of the following:\n* `Queued` - indicates that the export job is queued\n* `InProgress` - indicates that the snapshot is being exported\n* `Successful` - indicates that the export job has completed successfully\n* `Failed` - indicates that the export job has failed\n"
                }
            },
            "type": "object",
            "required": [
                "components",
                "createdAt",
                "customDatas",
                "errMsg",
                "exportBucketId",
                "exportJobId",
                "exportStatusExportedCollections",
                "exportStatusTotalCollections",
                "finishedAt",
                "prefix",
                "snapshotId",
                "state"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotExportJobsResultComponent:getCloudBackupSnapshotExportJobsResultComponent": {
            "properties": {
                "exportId": {
                    "type": "string",
                    "description": "_Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.\n"
                },
                "replicaSetName": {
                    "type": "string",
                    "description": "_Returned for sharded clusters only._ Unique identifier of the export job for the replica set.\n"
                }
            },
            "type": "object",
            "required": [
                "exportId",
                "replicaSetName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotExportJobsResultCustomData:getCloudBackupSnapshotExportJobsResultCustomData": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "Custom data specified as key in the key and value pair.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Value for the key specified using `key`.\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotMember:getCloudBackupSnapshotMember": {
            "properties": {
                "cloudProvider": {
                    "type": "string",
                    "description": "Cloud provider that stores this snapshot.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier for the sharded cluster snapshot.\n"
                },
                "replicaSetName": {
                    "type": "string",
                    "description": "Label given to a shard or config server from which Atlas took this snapshot.\n"
                }
            },
            "type": "object",
            "required": [
                "cloudProvider",
                "id",
                "replicaSetName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotRestoreJobsResult:getCloudBackupSnapshotRestoreJobsResult": {
            "properties": {
                "cancelled": {
                    "type": "boolean",
                    "description": "Indicates whether the restore job was canceled.\n"
                },
                "deliveryType": {
                    "type": "string",
                    "description": "Type of restore job to create. Possible values are: automated and download.\n"
                },
                "deliveryUrls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "One or more URLs for the compressed snapshot files for manual download. Only visible if deliveryType is download.\n"
                },
                "expired": {
                    "type": "boolean",
                    "description": "Indicates whether the restore job expired.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "UTC ISO 8601 formatted point in time when the restore job expires.\n"
                },
                "finishedAt": {
                    "type": "string",
                    "description": "UTC ISO 8601 formatted point in time when the restore job completed.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The unique identifier of the restore job.\n"
                },
                "oplogInc": {
                    "type": "integer"
                },
                "oplogTs": {
                    "type": "integer"
                },
                "pointInTimeUtcSeconds": {
                    "type": "integer"
                },
                "snapshotId": {
                    "type": "string",
                    "description": "Unique identifier of the source snapshot ID of the restore job.\n"
                },
                "targetClusterName": {
                    "type": "string",
                    "description": "Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.\n"
                },
                "targetProjectId": {
                    "type": "string",
                    "description": "Name of the target Atlas project of the restore job. Only visible if deliveryType is automated.\n"
                },
                "timestamp": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when the snapshot associated to snapshotId was taken.\n* `oplogTs` - Timestamp in the number of seconds that have elapsed since the UNIX epoch.\n* `oplogInc` - Oplog operation number from which to you want to restore this snapshot.\n* `pointInTimeUTCSeconds` - Timestamp in the number of seconds that have elapsed since the UNIX epoch.\n"
                }
            },
            "type": "object",
            "required": [
                "cancelled",
                "deliveryType",
                "deliveryUrls",
                "expired",
                "expiresAt",
                "finishedAt",
                "id",
                "oplogInc",
                "oplogTs",
                "pointInTimeUtcSeconds",
                "snapshotId",
                "targetClusterName",
                "targetProjectId",
                "timestamp"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotsResult:getCloudBackupSnapshotsResult": {
            "properties": {
                "cloudProvider": {
                    "type": "string",
                    "description": "Cloud provider that stores this snapshot.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "UTC ISO 8601 formatted point in time when Atlas took the snapshot.\n"
                },
                "description": {
                    "type": "string",
                    "description": "UDescription of the snapshot. Only present for on-demand snapshots.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "UTC ISO 8601 formatted point in time when Atlas will delete the snapshot.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier for the sharded cluster snapshot.\n"
                },
                "masterKeyUuid": {
                    "type": "string",
                    "description": "Unique ID of the AWS KMS Customer Master Key used to encrypt the snapshot. Only visible for clusters using Encryption at Rest via Customer KMS.\n"
                },
                "members": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getCloudBackupSnapshotsResultMember:getCloudBackupSnapshotsResultMember"
                    },
                    "description": "Block of List of snapshots and the cloud provider where the snapshots are stored. See below\n"
                },
                "mongodVersion": {
                    "type": "string",
                    "description": "Version of the MongoDB server.\n"
                },
                "replicaSetName": {
                    "type": "string",
                    "description": "Label given to a shard or config server from which Atlas took this snapshot.\n"
                },
                "snapshotIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Unique identifiers of the snapshots created for the shards and config server for a sharded cluster.\n"
                },
                "snapshotType": {
                    "type": "string",
                    "description": "Specified the type of snapshot. Valid values are onDemand and scheduled.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Current status of the snapshot. One of the following values: queued, inProgress, completed, failed.\n"
                },
                "storageSizeBytes": {
                    "type": "integer",
                    "description": "Specifies the size of the snapshot in bytes.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Specifies the type of cluster: replicaSet or shardedCluster.\n"
                }
            },
            "type": "object",
            "required": [
                "cloudProvider",
                "createdAt",
                "description",
                "expiresAt",
                "id",
                "masterKeyUuid",
                "members",
                "mongodVersion",
                "replicaSetName",
                "snapshotIds",
                "snapshotType",
                "status",
                "storageSizeBytes",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotsResultMember:getCloudBackupSnapshotsResultMember": {
            "properties": {
                "cloudProvider": {
                    "type": "string",
                    "description": "Cloud provider that stores this snapshot.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier for the sharded cluster snapshot.\n"
                },
                "replicaSetName": {
                    "type": "string",
                    "description": "Label given to a shard or config server from which Atlas took this snapshot.\n"
                }
            },
            "type": "object",
            "required": [
                "cloudProvider",
                "id",
                "replicaSetName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudProviderAccessSetupAwsConfig:getCloudProviderAccessSetupAwsConfig": {
            "properties": {
                "atlasAssumedRoleExternalId": {
                    "type": "string",
                    "description": "Unique external ID Atlas uses when assuming the IAM role in your AWS account.\n"
                },
                "atlasAwsAccountArn": {
                    "type": "string",
                    "description": "ARN associated with the Atlas AWS account used to assume IAM roles in your AWS account.\n"
                }
            },
            "type": "object",
            "required": [
                "atlasAssumedRoleExternalId",
                "atlasAwsAccountArn"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCloudProviderAccessSetupAzureConfig:getCloudProviderAccessSetupAzureConfig": {
            "properties": {
                "atlasAzureAppId": {
                    "type": "string",
                    "description": "Azure Active Directory Application ID of Atlas.\n"
                },
                "servicePrincipalId": {
                    "type": "string",
                    "description": "UUID string that identifies the Azure Service Principal.\n"
                },
                "tenantId": {
                    "type": "string",
                    "description": "UUID String that identifies the Azure Active Directory Tenant ID.\n"
                }
            },
            "type": "object",
            "required": [
                "atlasAzureAppId",
                "servicePrincipalId",
                "tenantId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClusterAdvancedConfiguration:getClusterAdvancedConfiguration": {
            "properties": {
                "defaultReadConcern": {
                    "type": "string",
                    "description": "[Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).\n",
                    "deprecationMessage": "This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown"
                },
                "defaultWriteConcern": {
                    "type": "string",
                    "description": "[Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).\n"
                },
                "failIndexKeyTooLong": {
                    "type": "boolean",
                    "description": "When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.\n",
                    "deprecationMessage": "This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown"
                },
                "javascriptEnabled": {
                    "type": "boolean",
                    "description": "When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.\n"
                },
                "minimumEnabledTlsProtocol": {
                    "type": "string",
                    "description": "Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:\n"
                },
                "noTableScan": {
                    "type": "boolean",
                    "description": "When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.\n"
                },
                "oplogMinRetentionHours": {
                    "type": "integer",
                    "description": "Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.\n"
                },
                "oplogSizeMb": {
                    "type": "integer",
                    "description": "The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.\n"
                },
                "sampleRefreshIntervalBiConnector": {
                    "type": "integer",
                    "description": "Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.\n"
                },
                "sampleSizeBiConnector": {
                    "type": "integer",
                    "description": "Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.\n"
                },
                "transactionLifetimeLimitSeconds": {
                    "type": "integer",
                    "description": "Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.\n"
                }
            },
            "type": "object",
            "required": [
                "defaultReadConcern",
                "defaultWriteConcern",
                "failIndexKeyTooLong",
                "javascriptEnabled",
                "minimumEnabledTlsProtocol",
                "noTableScan",
                "oplogMinRetentionHours",
                "oplogSizeMb",
                "sampleRefreshIntervalBiConnector",
                "sampleSizeBiConnector",
                "transactionLifetimeLimitSeconds"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClusterBiConnectorConfig:getClusterBiConnectorConfig": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Indicates whether or not BI Connector for Atlas is enabled on the cluster.\n"
                },
                "readPreference": {
                    "type": "string",
                    "description": "Indicates the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).\n"
                }
            },
            "type": "object",
            "required": [
                "enabled",
                "readPreference"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClusterConnectionString:getClusterConnectionString": {
            "properties": {
                "awsPrivateLink": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "awsPrivateLinkSrv": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "private": {
                    "type": "string",
                    "description": "[Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.\n"
                },
                "privateEndpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClusterConnectionStringPrivateEndpoint:getClusterConnectionStringPrivateEndpoint"
                    }
                },
                "privateSrv": {
                    "type": "string",
                    "description": "[Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.\n- `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.\n- `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint.\n- `connection_strings.private_endpoint.#.srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint.\n- `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.\n- `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`\n- `connection_strings.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.\n- `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.\n- `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.\n"
                },
                "standard": {
                    "type": "string",
                    "description": "Public mongodb:// connection string for this cluster.\n"
                },
                "standardSrv": {
                    "type": "string",
                    "description": "Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you donât need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesnât, use connectionStrings.standard.\n"
                }
            },
            "type": "object",
            "required": [
                "awsPrivateLink",
                "awsPrivateLinkSrv",
                "private",
                "privateEndpoints",
                "privateSrv",
                "standard",
                "standardSrv"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClusterConnectionStringPrivateEndpoint:getClusterConnectionStringPrivateEndpoint": {
            "properties": {
                "connectionString": {
                    "type": "string"
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClusterConnectionStringPrivateEndpointEndpoint:getClusterConnectionStringPrivateEndpointEndpoint"
                    }
                },
                "srvConnectionString": {
                    "type": "string"
                },
                "srvShardOptimizedConnectionString": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "connectionString",
                "endpoints",
                "srvConnectionString",
                "srvShardOptimizedConnectionString",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClusterConnectionStringPrivateEndpointEndpoint:getClusterConnectionStringPrivateEndpointEndpoint": {
            "properties": {
                "endpointId": {
                    "type": "string"
                },
                "providerName": {
                    "type": "string",
                    "description": "Indicates the cloud service provider on which the servers are provisioned.\n"
                },
                "region": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "endpointId",
                "providerName",
                "region"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClusterLabel:getClusterLabel": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key that you want to write.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value that you want to write.\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClusterOutageSimulationOutageFilter:getClusterOutageSimulationOutageFilter": {
            "properties": {
                "cloudProvider": {
                    "type": "string",
                    "description": "The cloud provider of the region that undergoes the outage simulation. Following values are supported:\n* `AWS`\n* `GCP`\n* `AZURE`\n"
                },
                "regionName": {
                    "type": "string",
                    "description": "The Atlas name of the region undergoing an outage simulation.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of cluster outage simulation. Following values are supported:\n* `REGION` (Simulates a cluster outage for a region)\n"
                }
            },
            "type": "object",
            "required": [
                "cloudProvider",
                "regionName",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClusterReplicationSpec:getClusterReplicationSpec": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "Unique identifer of the replication document for a zone in a Global Cluster.\n"
                },
                "numShards": {
                    "type": "integer",
                    "description": "Number of shards to deploy in the specified zone.\n"
                },
                "regionsConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClusterReplicationSpecRegionsConfig:getClusterReplicationSpecRegionsConfig"
                    },
                    "description": "Describes the physical location of the region. Each regionsConfig document describes the regionâs priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.\n"
                },
                "zoneName": {
                    "type": "string",
                    "description": "Indicates the n ame for the zone in a Global Cluster.\n"
                }
            },
            "type": "object",
            "required": [
                "id",
                "numShards",
                "regionsConfigs",
                "zoneName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClusterReplicationSpecRegionsConfig:getClusterReplicationSpecRegionsConfig": {
            "properties": {
                "analyticsNodes": {
                    "type": "integer",
                    "description": "Indicates the number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary.\n"
                },
                "electableNodes": {
                    "type": "integer",
                    "description": "Number of electable nodes for Atlas to deploy to the region.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Election priority of the region. For regions with only read-only nodes, set this value to 0.\n"
                },
                "readOnlyNodes": {
                    "type": "integer",
                    "description": "Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.\n"
                },
                "regionName": {
                    "type": "string",
                    "description": "Name for the region specified.\n"
                }
            },
            "type": "object",
            "required": [
                "analyticsNodes",
                "electableNodes",
                "priority",
                "readOnlyNodes",
                "regionName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClusterSnapshotBackupPolicy:getClusterSnapshotBackupPolicy": {
            "properties": {
                "clusterId": {
                    "type": "string"
                },
                "clusterName": {
                    "type": "string"
                },
                "nextSnapshot": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClusterSnapshotBackupPolicyPolicy:getClusterSnapshotBackupPolicyPolicy"
                    }
                },
                "referenceHourOfDay": {
                    "type": "integer"
                },
                "referenceMinuteOfHour": {
                    "type": "integer"
                },
                "restoreWindowDays": {
                    "type": "integer"
                },
                "updateSnapshots": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "required": [
                "clusterId",
                "clusterName",
                "nextSnapshot",
                "policies",
                "referenceHourOfDay",
                "referenceMinuteOfHour",
                "restoreWindowDays",
                "updateSnapshots"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClusterSnapshotBackupPolicyPolicy:getClusterSnapshotBackupPolicyPolicy": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "Unique identifer of the replication document for a zone in a Global Cluster.\n"
                },
                "policyItems": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClusterSnapshotBackupPolicyPolicyPolicyItem:getClusterSnapshotBackupPolicyPolicyPolicyItem"
                    }
                }
            },
            "type": "object",
            "required": [
                "id",
                "policyItems"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClusterSnapshotBackupPolicyPolicyPolicyItem:getClusterSnapshotBackupPolicyPolicyPolicyItem": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer"
                },
                "frequencyType": {
                    "type": "string"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifer of the replication document for a zone in a Global Cluster.\n"
                },
                "retentionUnit": {
                    "type": "string"
                },
                "retentionValue": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "frequencyType",
                "id",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClusterTag:getClusterTag": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key that you want to write.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value that you want to write.\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClustersResult:getClustersResult": {
            "properties": {
                "advancedConfigurations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClustersResultAdvancedConfiguration:getClustersResultAdvancedConfiguration"
                    },
                    "description": "Get the advanced configuration options. See Advanced Configuration below for more details.\n"
                },
                "autoScalingComputeEnabled": {
                    "type": "boolean",
                    "description": "Specifies whether cluster tier auto-scaling is enabled. The default is false.\n"
                },
                "autoScalingComputeScaleDownEnabled": {
                    "type": "boolean",
                    "description": "* `auto_scaling_compute_scale_down_enabled` - Specifies whether cluster tier auto-down-scaling is enabled.\n"
                },
                "autoScalingDiskGbEnabled": {
                    "type": "boolean",
                    "description": "Indicates whether disk auto-scaling is enabled.\n"
                },
                "backingProviderName": {
                    "type": "string",
                    "description": "Indicates Cloud service provider on which the server for a multi-tenant cluster is provisioned.\n"
                },
                "backupEnabled": {
                    "type": "boolean",
                    "description": "Legacy Option, Indicates whether Atlas continuous backups are enabled for the cluster.\n"
                },
                "biConnectorConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClustersResultBiConnectorConfig:getClustersResultBiConnectorConfig"
                    },
                    "description": "Indicates BI Connector for Atlas configuration on this cluster. BI Connector for Atlas is only available for M10+ clusters. See BI Connector below for more details.\n"
                },
                "clusterType": {
                    "type": "string",
                    "description": "Indicates the type of the cluster that you want to modify. You cannot convert a sharded cluster deployment to a replica set deployment.\n"
                },
                "connectionStrings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClustersResultConnectionString:getClustersResultConnectionString"
                    },
                    "description": "Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.\n"
                },
                "containerId": {
                    "type": "string",
                    "description": "The Network Peering Container ID.\n"
                },
                "diskSizeGb": {
                    "type": "number",
                    "description": "Indicates the size in gigabytes of the serverâs root volume (AWS/GCP Only).\n"
                },
                "encryptionAtRestProvider": {
                    "type": "string",
                    "description": "Indicates whether Encryption at Rest is enabled or disabled.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClustersResultLabel:getClustersResultLabel"
                    },
                    "description": "Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below. **DEPRECATED** Use `tags` instead.\n",
                    "deprecationMessage": "This parameter is deprecated and will be removed by September 2024. Please transition to tags."
                },
                "mongoDbMajorVersion": {
                    "type": "string",
                    "description": "Indicates the version of the cluster to deploy.\n"
                },
                "mongoDbVersion": {
                    "type": "string",
                    "description": "Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.\n"
                },
                "mongoUri": {
                    "type": "string",
                    "description": "Base connection string for the cluster. Atlas only displays this field after the cluster is operational, not while it builds the cluster.\n"
                },
                "mongoUriUpdated": {
                    "type": "string",
                    "description": "Lists when the connection string was last updated. The connection string changes, for example, if you change a replica set to a sharded cluster.\n"
                },
                "mongoUriWithOptions": {
                    "type": "string",
                    "description": "Describes connection string for connecting to the Atlas cluster. Includes the replicaSet, ssl, and authSource query parameters in the connection string with values appropriate for the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the current plugin\n"
                },
                "numShards": {
                    "type": "integer",
                    "description": "Number of shards to deploy in the specified zone.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the cluster is paused or not.\n"
                },
                "pitEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates if the cluster uses Continuous Cloud Backup.\n"
                },
                "providerAutoScalingComputeMaxInstanceSize": {
                    "type": "string",
                    "description": "Maximum instance size to which your cluster can automatically scale.\n"
                },
                "providerAutoScalingComputeMinInstanceSize": {
                    "type": "string",
                    "description": "Minimum instance size to which your cluster can automatically scale.\n"
                },
                "providerBackupEnabled": {
                    "type": "boolean",
                    "description": "Flag indicating if the cluster uses Cloud Backup Snapshots for backups. **DEPRECATED** Use `cloud_backup` instead.\n"
                },
                "providerDiskIops": {
                    "type": "integer",
                    "description": "Indicates the maximum input/output operations per second (IOPS) the system can perform. The possible values depend on the selected providerSettings.instanceSizeName and diskSizeGB.\n"
                },
                "providerDiskTypeName": {
                    "type": "string",
                    "description": "Describes Azure disk type of the serverâs root volume (Azure Only).\n"
                },
                "providerEncryptEbsVolume": {
                    "type": "boolean",
                    "description": "**(DEPRECATED)** Indicates whether the Amazon EBS encryption is enabled. This feature encrypts the serverâs root volume for both data at rest within the volume and data moving between the volume and the instance. By default this attribute is always enabled, per deprecation process showing the real value at `provider_encrypt_ebs_volume_flag` computed attribute.\n"
                },
                "providerInstanceSizeName": {
                    "type": "string",
                    "description": "Atlas provides different instance sizes, each with a default storage capacity and RAM size.\n"
                },
                "providerName": {
                    "type": "string",
                    "description": "Indicates the cloud service provider on which the servers are provisioned.\n"
                },
                "providerRegionName": {
                    "type": "string",
                    "description": "Indicates Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases. Requires the Atlas Region name, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).\n"
                },
                "providerVolumeType": {
                    "type": "string",
                    "description": "Indicates the type of the volume. The possible values are: `STANDARD` and `PROVISIONED`.\n\u003e **NOTE:** `STANDARD` is not available for NVME clusters.\n"
                },
                "replicationFactor": {
                    "type": "integer",
                    "description": "(Deprecated) Number of replica set members. Each member keeps a copy of your databases, providing high availability and data redundancy. The possible values are 3, 5, or 7. The default value is 3.\n"
                },
                "replicationSpecs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClustersResultReplicationSpec:getClustersResultReplicationSpec"
                    },
                    "description": "Configuration for cluster regions.  See Replication Spec below for more details.\n"
                },
                "snapshotBackupPolicies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClustersResultSnapshotBackupPolicy:getClustersResultSnapshotBackupPolicy"
                    },
                    "description": "current snapshot schedule and retention settings for the cluster.\n"
                },
                "srvAddress": {
                    "type": "string",
                    "description": "Connection string for connecting to the Atlas cluster. The +srv modifier forces the connection to use TLS/SSL. See the mongoURI for additional options.\n"
                },
                "stateName": {
                    "type": "string",
                    "description": "Indicates the current state of the cluster. The possible states are:\n- IDLE\n- CREATING\n- UPDATING\n- DELETING\n- DELETED\n- REPAIRING\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClustersResultTag:getClustersResultTag"
                    },
                    "description": "Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.\n"
                },
                "terminationProtectionEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n"
                },
                "versionReleaseSystem": {
                    "type": "string",
                    "description": "Release cadence that Atlas uses for this cluster.\n"
                }
            },
            "type": "object",
            "required": [
                "advancedConfigurations",
                "autoScalingComputeEnabled",
                "autoScalingComputeScaleDownEnabled",
                "autoScalingDiskGbEnabled",
                "backingProviderName",
                "backupEnabled",
                "biConnectorConfigs",
                "clusterType",
                "connectionStrings",
                "containerId",
                "diskSizeGb",
                "encryptionAtRestProvider",
                "labels",
                "mongoDbMajorVersion",
                "mongoDbVersion",
                "mongoUri",
                "mongoUriUpdated",
                "mongoUriWithOptions",
                "name",
                "numShards",
                "paused",
                "pitEnabled",
                "providerAutoScalingComputeMaxInstanceSize",
                "providerAutoScalingComputeMinInstanceSize",
                "providerBackupEnabled",
                "providerDiskIops",
                "providerDiskTypeName",
                "providerEncryptEbsVolume",
                "providerInstanceSizeName",
                "providerName",
                "providerRegionName",
                "providerVolumeType",
                "replicationFactor",
                "replicationSpecs",
                "snapshotBackupPolicies",
                "srvAddress",
                "stateName",
                "tags",
                "terminationProtectionEnabled",
                "versionReleaseSystem"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClustersResultAdvancedConfiguration:getClustersResultAdvancedConfiguration": {
            "properties": {
                "defaultReadConcern": {
                    "type": "string",
                    "description": "[Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).\n",
                    "deprecationMessage": "This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown"
                },
                "defaultWriteConcern": {
                    "type": "string",
                    "description": "[Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).\n"
                },
                "failIndexKeyTooLong": {
                    "type": "boolean",
                    "description": "When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.\n",
                    "deprecationMessage": "This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown"
                },
                "javascriptEnabled": {
                    "type": "boolean",
                    "description": "When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.\n"
                },
                "minimumEnabledTlsProtocol": {
                    "type": "string",
                    "description": "Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:\n"
                },
                "noTableScan": {
                    "type": "boolean",
                    "description": "When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.\n"
                },
                "oplogMinRetentionHours": {
                    "type": "integer",
                    "description": "Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.\n"
                },
                "oplogSizeMb": {
                    "type": "integer",
                    "description": "The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.\n"
                },
                "sampleRefreshIntervalBiConnector": {
                    "type": "integer",
                    "description": "Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.\n"
                },
                "sampleSizeBiConnector": {
                    "type": "integer",
                    "description": "Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.\n"
                },
                "transactionLifetimeLimitSeconds": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "defaultReadConcern",
                "defaultWriteConcern",
                "failIndexKeyTooLong",
                "javascriptEnabled",
                "minimumEnabledTlsProtocol",
                "noTableScan",
                "oplogMinRetentionHours",
                "oplogSizeMb",
                "sampleRefreshIntervalBiConnector",
                "sampleSizeBiConnector",
                "transactionLifetimeLimitSeconds"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClustersResultBiConnectorConfig:getClustersResultBiConnectorConfig": {
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Indicates whether or not BI Connector for Atlas is enabled on the cluster.\n"
                },
                "readPreference": {
                    "type": "string",
                    "description": "Indicates the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).\n"
                }
            },
            "type": "object",
            "required": [
                "enabled",
                "readPreference"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClustersResultConnectionString:getClustersResultConnectionString": {
            "properties": {
                "awsPrivateLink": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "awsPrivateLinkSrv": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "private": {
                    "type": "string",
                    "description": "[Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.\n"
                },
                "privateEndpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClustersResultConnectionStringPrivateEndpoint:getClustersResultConnectionStringPrivateEndpoint"
                    }
                },
                "privateSrv": {
                    "type": "string",
                    "description": "[Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.\n- `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.\n- `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint.\n- `connection_strings.private_endpoint.#.srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint.\n- `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.\n- `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`\n- `connection_strings.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.\n- `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.\n- `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.\n"
                },
                "standard": {
                    "type": "string",
                    "description": "Public mongodb:// connection string for this cluster.\n"
                },
                "standardSrv": {
                    "type": "string",
                    "description": "Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you donât need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesnât, use connectionStrings.standard.\n"
                }
            },
            "type": "object",
            "required": [
                "awsPrivateLink",
                "awsPrivateLinkSrv",
                "private",
                "privateEndpoints",
                "privateSrv",
                "standard",
                "standardSrv"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClustersResultConnectionStringPrivateEndpoint:getClustersResultConnectionStringPrivateEndpoint": {
            "properties": {
                "connectionString": {
                    "type": "string"
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClustersResultConnectionStringPrivateEndpointEndpoint:getClustersResultConnectionStringPrivateEndpointEndpoint"
                    }
                },
                "srvConnectionString": {
                    "type": "string"
                },
                "srvShardOptimizedConnectionString": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "connectionString",
                "endpoints",
                "srvConnectionString",
                "srvShardOptimizedConnectionString",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClustersResultConnectionStringPrivateEndpointEndpoint:getClustersResultConnectionStringPrivateEndpointEndpoint": {
            "properties": {
                "endpointId": {
                    "type": "string"
                },
                "providerName": {
                    "type": "string",
                    "description": "Indicates the cloud service provider on which the servers are provisioned.\n"
                },
                "region": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "endpointId",
                "providerName",
                "region"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClustersResultLabel:getClustersResultLabel": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key that you want to write.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value that you want to write.\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClustersResultReplicationSpec:getClustersResultReplicationSpec": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "Unique identifer of the replication document for a zone in a Global Cluster.\n"
                },
                "numShards": {
                    "type": "integer",
                    "description": "Number of shards to deploy in the specified zone.\n"
                },
                "regionsConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClustersResultReplicationSpecRegionsConfig:getClustersResultReplicationSpecRegionsConfig"
                    },
                    "description": "Describes the physical location of the region. Each regionsConfig document describes the regionâs priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.\n"
                },
                "zoneName": {
                    "type": "string",
                    "description": "Indicates the n ame for the zone in a Global Cluster.\n"
                }
            },
            "type": "object",
            "required": [
                "id",
                "numShards",
                "regionsConfigs",
                "zoneName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClustersResultReplicationSpecRegionsConfig:getClustersResultReplicationSpecRegionsConfig": {
            "properties": {
                "analyticsNodes": {
                    "type": "integer",
                    "description": "Indicates the number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary.\n"
                },
                "electableNodes": {
                    "type": "integer",
                    "description": "Number of electable nodes for Atlas to deploy to the region.\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Election priority of the region. For regions with only read-only nodes, set this value to 0.\n"
                },
                "readOnlyNodes": {
                    "type": "integer",
                    "description": "Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.\n"
                },
                "regionName": {
                    "type": "string",
                    "description": "Name for the region specified.\n"
                }
            },
            "type": "object",
            "required": [
                "analyticsNodes",
                "electableNodes",
                "priority",
                "readOnlyNodes",
                "regionName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClustersResultSnapshotBackupPolicy:getClustersResultSnapshotBackupPolicy": {
            "properties": {
                "clusterId": {
                    "type": "string"
                },
                "clusterName": {
                    "type": "string"
                },
                "nextSnapshot": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClustersResultSnapshotBackupPolicyPolicy:getClustersResultSnapshotBackupPolicyPolicy"
                    }
                },
                "referenceHourOfDay": {
                    "type": "integer"
                },
                "referenceMinuteOfHour": {
                    "type": "integer"
                },
                "restoreWindowDays": {
                    "type": "integer"
                },
                "updateSnapshots": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "required": [
                "clusterId",
                "clusterName",
                "nextSnapshot",
                "policies",
                "referenceHourOfDay",
                "referenceMinuteOfHour",
                "restoreWindowDays",
                "updateSnapshots"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClustersResultSnapshotBackupPolicyPolicy:getClustersResultSnapshotBackupPolicyPolicy": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "Unique identifer of the replication document for a zone in a Global Cluster.\n"
                },
                "policyItems": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getClustersResultSnapshotBackupPolicyPolicyPolicyItem:getClustersResultSnapshotBackupPolicyPolicyPolicyItem"
                    }
                }
            },
            "type": "object",
            "required": [
                "id",
                "policyItems"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClustersResultSnapshotBackupPolicyPolicyPolicyItem:getClustersResultSnapshotBackupPolicyPolicyPolicyItem": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer"
                },
                "frequencyType": {
                    "type": "string"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifer of the replication document for a zone in a Global Cluster.\n"
                },
                "retentionUnit": {
                    "type": "string"
                },
                "retentionValue": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "frequencyType",
                "id",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getClustersResultTag:getClustersResultTag": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key that you want to write.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value that you want to write.\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getControlPlaneIpAddressesInbound:getControlPlaneIpAddressesInbound": {
            "properties": {
                "aws": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "description": "Control plane IP addresses in AWS. Each key identifies an Amazon Web Services (AWS) region. Each value identifies control plane IP addresses in the AWS region.\n"
                },
                "azure": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "description": "Control plane IP addresses in Azure. Each key identifies an Azure region. Each value identifies control plane IP addresses in the Azure region.\n"
                },
                "gcp": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "description": "Control plane IP addresses in GCP. Each key identifies a Google Cloud (GCP) region. Each value identifies control plane IP addresses in the GCP region.\n"
                }
            },
            "type": "object",
            "required": [
                "aws",
                "azure",
                "gcp"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getControlPlaneIpAddressesOutbound:getControlPlaneIpAddressesOutbound": {
            "properties": {
                "aws": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "description": "Control plane IP addresses in AWS. Each key identifies an Amazon Web Services (AWS) region. Each value identifies control plane IP addresses in the AWS region.\n"
                },
                "azure": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "description": "Control plane IP addresses in Azure. Each key identifies an Azure region. Each value identifies control plane IP addresses in the Azure region.\n"
                },
                "gcp": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "description": "Control plane IP addresses in GCP. Each key identifies a Google Cloud (GCP) region. Each value identifies control plane IP addresses in the GCP region.\n"
                }
            },
            "type": "object",
            "required": [
                "aws",
                "azure",
                "gcp"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCustomDbRoleAction:getCustomDbRoleAction": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "(Required) Name of the privilege action. For a complete list of actions available in the Atlas API, see Custom Role Actions.\n"
                },
                "resources": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getCustomDbRoleActionResource:getCustomDbRoleActionResource"
                    },
                    "description": "(Required) Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.\n"
                }
            },
            "type": "object",
            "required": [
                "action",
                "resources"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCustomDbRoleActionResource:getCustomDbRoleActionResource": {
            "properties": {
                "cluster": {
                    "type": "boolean"
                },
                "collectionName": {
                    "type": "string"
                },
                "databaseName": {
                    "type": "string",
                    "description": "(Required) Database on which the inherited role is granted.\n"
                }
            },
            "type": "object",
            "required": [
                "cluster",
                "collectionName",
                "databaseName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCustomDbRoleInheritedRole:getCustomDbRoleInheritedRole": {
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "(Required) Database on which the inherited role is granted.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "Name of the custom role.\n"
                }
            },
            "type": "object",
            "required": [
                "databaseName",
                "roleName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCustomDbRolesResult:getCustomDbRolesResult": {
            "properties": {
                "actions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getCustomDbRolesResultAction:getCustomDbRolesResultAction"
                    }
                },
                "inheritedRoles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getCustomDbRolesResultInheritedRole:getCustomDbRolesResultInheritedRole"
                    }
                },
                "roleName": {
                    "type": "string",
                    "description": "(Required) Name of the inherited role. This can either be another custom role or a built-in role.\n"
                }
            },
            "type": "object",
            "required": [
                "actions",
                "inheritedRoles",
                "roleName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCustomDbRolesResultAction:getCustomDbRolesResultAction": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "(Required) Name of the privilege action. For a complete list of actions available in the Atlas API, see Custom Role Actions.\n"
                },
                "resources": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getCustomDbRolesResultActionResource:getCustomDbRolesResultActionResource"
                    },
                    "description": "(Required) Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.\n"
                }
            },
            "type": "object",
            "required": [
                "action",
                "resources"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCustomDbRolesResultActionResource:getCustomDbRolesResultActionResource": {
            "properties": {
                "cluster": {
                    "type": "boolean"
                },
                "collectionName": {
                    "type": "string"
                },
                "databaseName": {
                    "type": "string",
                    "description": "(Required) Database on which the inherited role is granted.\n"
                }
            },
            "type": "object",
            "required": [
                "cluster",
                "collectionName",
                "databaseName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getCustomDbRolesResultInheritedRole:getCustomDbRolesResultInheritedRole": {
            "properties": {
                "databaseName": {
                    "type": "string",
                    "description": "(Required) Database on which the inherited role is granted.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "(Required) Name of the inherited role. This can either be another custom role or a built-in role.\n"
                }
            },
            "type": "object",
            "required": [
                "databaseName",
                "roleName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakePipelineIngestionSchedule:getDataLakePipelineIngestionSchedule": {
            "properties": {
                "frequencyInterval": {
                    "type": "integer"
                },
                "frequencyType": {
                    "type": "string"
                },
                "id": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.\n"
                },
                "retentionUnit": {
                    "type": "string"
                },
                "retentionValue": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "frequencyInterval",
                "frequencyType",
                "id",
                "retentionUnit",
                "retentionValue"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakePipelineRunStat:getDataLakePipelineRunStat": {
            "properties": {
                "bytesExported": {
                    "type": "integer",
                    "description": "Total data size in bytes exported for this pipeline run.\n"
                },
                "numDocs": {
                    "type": "integer",
                    "description": "Number of docs ingested for a this pipeline run.\n"
                }
            },
            "type": "object",
            "required": [
                "bytesExported",
                "numDocs"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakePipelineRunsResult:getDataLakePipelineRunsResult": {
            "properties": {
                "backupFrequencyType": {
                    "type": "string",
                    "description": "Backup schedule interval of the Data Lake Pipeline.\n"
                },
                "createdDate": {
                    "type": "string",
                    "description": "Timestamp that indicates when the pipeline run was created.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal character string that identifies a Data Lake Pipeline run.\n"
                },
                "lastUpdatedDate": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal character string that identifies a Data Lake Pipeline run.\n"
                },
                "phase": {
                    "type": "string",
                    "description": "Processing phase of the Data Lake Pipeline.\n"
                },
                "pipelineId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal character string that identifies a Data Lake Pipeline.\n"
                },
                "pipelineRunId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal character string that identifies a Data Lake Pipeline run.\n"
                },
                "snapshotId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal character string that identifies the snapshot of a cluster.\n"
                },
                "state": {
                    "type": "string",
                    "description": "State of the pipeline run.\n"
                },
                "stats": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getDataLakePipelineRunsResultStat:getDataLakePipelineRunsResultStat"
                    },
                    "description": "Runtime statistics for this Data Lake Pipeline run.\n"
                }
            },
            "type": "object",
            "required": [
                "backupFrequencyType",
                "createdDate",
                "id",
                "lastUpdatedDate",
                "phase",
                "pipelineId",
                "pipelineRunId",
                "snapshotId",
                "state",
                "stats"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakePipelineRunsResultStat:getDataLakePipelineRunsResultStat": {
            "properties": {
                "bytesExported": {
                    "type": "integer",
                    "description": "Total data size in bytes exported for this pipeline run.\n"
                },
                "numDocs": {
                    "type": "integer",
                    "description": "Number of docs ingested for a this pipeline run.\n"
                }
            },
            "type": "object",
            "required": [
                "bytesExported",
                "numDocs"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakePipelineSink:getDataLakePipelineSink": {
            "properties": {
                "partitionFields": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getDataLakePipelineSinkPartitionField:getDataLakePipelineSinkPartitionField"
                    },
                    "description": "Ordered fields used to physically organize data in the destination.\n* `partition_fields.#.field_name` - Human-readable label that identifies the field name used to partition data.\n* `partition_fields.#.order` - Sequence in which MongoDB Atlas slices the collection data to create partitions. The resource expresses this sequence starting with zero.\n"
                },
                "provider": {
                    "type": "string",
                    "description": "Target cloud provider for this Data Lake Pipeline.\n"
                },
                "region": {
                    "type": "string",
                    "description": "Target cloud provider region for this Data Lake Pipeline. [Supported cloud provider regions](https://www.mongodb.com/docs/datalake/limitations).\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of ingestion source of this Data Lake Pipeline.\n"
                }
            },
            "type": "object",
            "required": [
                "partitionFields",
                "provider",
                "region",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakePipelineSinkPartitionField:getDataLakePipelineSinkPartitionField": {
            "properties": {
                "fieldName": {
                    "type": "string"
                },
                "order": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "fieldName",
                "order"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakePipelineSnapshot:getDataLakePipelineSnapshot": {
            "properties": {
                "copyRegion": {
                    "type": "string"
                },
                "createdAt": {
                    "type": "string"
                },
                "expiresAt": {
                    "type": "string"
                },
                "frequencyYype": {
                    "type": "string"
                },
                "id": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.\n"
                },
                "masterKey": {
                    "type": "string"
                },
                "mongodVersion": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "provider": {
                    "type": "string",
                    "description": "Target cloud provider for this Data Lake Pipeline.\n"
                },
                "replicaSetName": {
                    "type": "string"
                },
                "size": {
                    "type": "integer"
                },
                "status": {
                    "type": "string"
                },
                "type": {
                    "type": "string",
                    "description": "Type of ingestion source of this Data Lake Pipeline.\n"
                }
            },
            "type": "object",
            "required": [
                "copyRegion",
                "createdAt",
                "expiresAt",
                "frequencyYype",
                "id",
                "masterKey",
                "mongodVersion",
                "policies",
                "provider",
                "replicaSetName",
                "size",
                "status",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakePipelineSource:getDataLakePipelineSource": {
            "properties": {
                "clusterName": {
                    "type": "string",
                    "description": "Human-readable name that identifies the cluster.\n"
                },
                "collectionName": {
                    "type": "string",
                    "description": "Human-readable name that identifies the collection.\n"
                },
                "databaseName": {
                    "type": "string",
                    "description": "Human-readable name that identifies the database.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create a Data Lake Pipeline.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of ingestion source of this Data Lake Pipeline.\n"
                }
            },
            "type": "object",
            "required": [
                "clusterName",
                "collectionName",
                "databaseName",
                "projectId",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakePipelineTransformation:getDataLakePipelineTransformation": {
            "properties": {
                "field": {
                    "type": "string"
                },
                "type": {
                    "type": "string",
                    "description": "Type of ingestion source of this Data Lake Pipeline.\n"
                }
            },
            "type": "object",
            "required": [
                "field",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakePipelinesResult:getDataLakePipelinesResult": {
            "properties": {
                "createdDate": {
                    "type": "string",
                    "description": "Timestamp that indicates when the Data Lake Pipeline was created.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.\n"
                },
                "lastUpdatedDate": {
                    "type": "string",
                    "description": "Timestamp that indicates the last time that the Data Lake Pipeline was updated.\n"
                },
                "name": {
                    "type": "string"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create a data lake pipeline.\n"
                },
                "sinks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getDataLakePipelinesResultSink:getDataLakePipelinesResultSink"
                    }
                },
                "sources": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getDataLakePipelinesResultSource:getDataLakePipelinesResultSource"
                    }
                },
                "state": {
                    "type": "string",
                    "description": "State of this Data Lake Pipeline.\n"
                },
                "transformations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getDataLakePipelinesResultTransformation:getDataLakePipelinesResultTransformation"
                    },
                    "description": "Fields to be excluded for this Data Lake Pipeline.\n* `transformations.#.field` - Key in the document.\n* `transformations.#.type` - Type of transformation applied during the export of the namespace in a Data Lake Pipeline.\n"
                }
            },
            "type": "object",
            "required": [
                "createdDate",
                "id",
                "lastUpdatedDate",
                "name",
                "projectId",
                "sinks",
                "sources",
                "state",
                "transformations"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakePipelinesResultSink:getDataLakePipelinesResultSink": {
            "properties": {
                "partitionFields": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getDataLakePipelinesResultSinkPartitionField:getDataLakePipelinesResultSinkPartitionField"
                    },
                    "description": "Ordered fields used to physically organize data in the destination.\n* `partition_fields.#.field_name` - Human-readable label that identifies the field name used to partition data.\n* `partition_fields.#.order` - Sequence in which MongoDB Atlas slices the collection data to create partitions. The resource expresses this sequence starting with zero.\n"
                },
                "provider": {
                    "type": "string",
                    "description": "Target cloud provider for this Data Lake Pipeline.\n"
                },
                "region": {
                    "type": "string",
                    "description": "Target cloud provider region for this Data Lake Pipeline. [Supported cloud provider regions](https://www.mongodb.com/docs/datalake/limitations).\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of ingestion source of this Data Lake Pipeline.\n"
                }
            },
            "type": "object",
            "required": [
                "partitionFields",
                "provider",
                "region",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakePipelinesResultSinkPartitionField:getDataLakePipelinesResultSinkPartitionField": {
            "properties": {
                "fieldName": {
                    "type": "string"
                },
                "order": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "fieldName",
                "order"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakePipelinesResultSource:getDataLakePipelinesResultSource": {
            "properties": {
                "clusterName": {
                    "type": "string",
                    "description": "Human-readable name that identifies the cluster.\n"
                },
                "collectionName": {
                    "type": "string",
                    "description": "Human-readable name that identifies the collection.\n"
                },
                "databaseName": {
                    "type": "string",
                    "description": "Human-readable name that identifies the database.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create a data lake pipeline.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of ingestion source of this Data Lake Pipeline.\n"
                }
            },
            "type": "object",
            "required": [
                "clusterName",
                "collectionName",
                "databaseName",
                "projectId",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDataLakePipelinesResultTransformation:getDataLakePipelinesResultTransformation": {
            "properties": {
                "field": {
                    "type": "string"
                },
                "type": {
                    "type": "string",
                    "description": "Type of ingestion source of this Data Lake Pipeline.\n"
                }
            },
            "type": "object",
            "required": [
                "field",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDatabaseUserLabel:getDatabaseUserLabel": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key that you want to write.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value that you want to write.\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDatabaseUserRole:getDatabaseUserRole": {
            "properties": {
                "collectionName": {
                    "type": "string",
                    "description": "Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).\n"
                },
                "databaseName": {
                    "type": "string",
                    "description": "Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.\n"
                },
                "roleName": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "collectionName",
                "databaseName",
                "roleName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDatabaseUserScope:getDatabaseUserScope": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the role to grant.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDatabaseUsersResult:getDatabaseUsersResult": {
            "properties": {
                "authDatabaseName": {
                    "type": "string",
                    "description": "(Required) Database against which Atlas authenticates the user. A user must provide both a username and authentication database to log into MongoDB.\nPossible values include:\n"
                },
                "awsIamType": {
                    "type": "string",
                    "description": "The new database user authenticates with AWS IAM credentials. Default is `NONE`, `USER` means user has AWS IAM user credentials, `ROLE` - means user has credentials associated with an AWS IAM role.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Autogenerated Unique ID for this data source.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getDatabaseUsersResultLabel:getDatabaseUsersResultLabel"
                    }
                },
                "ldapAuthType": {
                    "type": "string",
                    "description": "Method by which the provided username is authenticated. Default is `NONE`. Other valid values are: `USER`, `GROUP`.\n"
                },
                "oidcAuthType": {
                    "type": "string",
                    "description": "(Optional) Human-readable label that indicates whether the new database user authenticates with OIDC (OpenID Connect) federated authentication. If no value is given, Atlas uses the default value of `NONE`. The accepted types are:\n* `NONE` -\tThe user does not use OIDC federated authentication.\n* `IDP_GROUP` - OIDC Workforce federated authentication group. To learn more about OIDC federated authentication, see [Set up Workforce Identity Federation with OIDC](https://www.mongodb.com/docs/atlas/security-oidc/).\n* `USER` - OIDC Workload federated authentication user. To learn more about OIDC federated authentication, see [Set up Workload Identity Federation with OIDC](https://www.mongodb.com/docs/atlas/security-oidc/).\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to get all database users.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getDatabaseUsersResultRole:getDatabaseUsersResultRole"
                    },
                    "description": "List of userâs roles and the databases / collections on which the roles apply. A role allows the user to perform particular actions on the specified database. A role on the admin database can include privileges that apply to the other databases as well. See Roles below for more details.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getDatabaseUsersResultScope:getDatabaseUsersResultScope"
                    },
                    "description": "Array of clusters and Atlas Data Lakes that this user has access to.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username for authenticating to MongoDB.\n"
                },
                "x509Type": {
                    "type": "string",
                    "description": "X.509 method by which the provided username is authenticated.\n"
                }
            },
            "type": "object",
            "required": [
                "authDatabaseName",
                "awsIamType",
                "id",
                "labels",
                "ldapAuthType",
                "oidcAuthType",
                "projectId",
                "roles",
                "scopes",
                "username",
                "x509Type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDatabaseUsersResultLabel:getDatabaseUsersResultLabel": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "The key that you want to write.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value that you want to write.\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDatabaseUsersResultRole:getDatabaseUsersResultRole": {
            "properties": {
                "collectionName": {
                    "type": "string",
                    "description": "Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).\n"
                },
                "databaseName": {
                    "type": "string",
                    "description": "Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.\n"
                },
                "roleName": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "collectionName",
                "databaseName",
                "roleName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getDatabaseUsersResultScope:getDatabaseUsersResultScope": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the role to grant.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getEventTriggerEventProcessor:getEventTriggerEventProcessor": {
            "properties": {
                "awsEventbridges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getEventTriggerEventProcessorAwsEventbridge:getEventTriggerEventProcessorAwsEventbridge"
                    }
                }
            },
            "type": "object",
            "required": [
                "awsEventbridges"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getEventTriggerEventProcessorAwsEventbridge:getEventTriggerEventProcessorAwsEventbridge": {
            "properties": {
                "configAccountId": {
                    "type": "string",
                    "description": "AWS Account ID.\n"
                },
                "configRegion": {
                    "type": "string",
                    "description": "Region of AWS Account.\n"
                }
            },
            "type": "object",
            "required": [
                "configAccountId",
                "configRegion"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getEventTriggersResult:getEventTriggersResult": {
            "properties": {
                "configCollection": {
                    "type": "string",
                    "description": "The name of the MongoDB collection that the trigger watches for change events.\n"
                },
                "configDatabase": {
                    "type": "string",
                    "description": "The name of the MongoDB database to watch.\n"
                },
                "configFullDocument": {
                    "type": "boolean",
                    "description": "If true, indicates that `UPDATE` change events should include the most current [majority-committed](https://docs.mongodb.com/manual/reference/read-concern-majority/) version of the modified document in the fullDocument field.\n"
                },
                "configFullDocumentBefore": {
                    "type": "boolean"
                },
                "configMatch": {
                    "type": "string",
                    "description": "A [$match](https://docs.mongodb.com/manual/reference/operator/aggregation/match/) expression document that MongoDB Realm includes in the underlying change stream pipeline for the trigger.\n"
                },
                "configOperationType": {
                    "type": "string",
                    "description": "The [authentication operation type](https://docs.mongodb.com/realm/triggers/authentication-triggers/#std-label-authentication-event-operation-types) to listen for.\n"
                },
                "configOperationTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The [database event operation types](https://docs.mongodb.com/realm/triggers/database-triggers/#std-label-database-events) to listen for.\n"
                },
                "configProject": {
                    "type": "string",
                    "description": "A [$project](https://docs.mongodb.com/manual/reference/operator/aggregation/project/) expression document that Realm uses to filter the fields that appear in change event objects.\n"
                },
                "configProviders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of one or more [authentication provider](https://docs.mongodb.com/realm/authentication/providers/) id values. The trigger will only listen for authentication events produced by these providers.\n"
                },
                "configSchedule": {
                    "type": "string",
                    "description": "A [cron expression](https://docs.mongodb.com/realm/triggers/cron-expressions/) that defines the trigger schedule.\n"
                },
                "configScheduleType": {
                    "type": "string"
                },
                "configServiceId": {
                    "type": "string",
                    "description": "The ID of the MongoDB Service associated with the trigger.\n"
                },
                "disabled": {
                    "type": "boolean",
                    "description": "Status of a trigger.\n"
                },
                "eventProcessors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getEventTriggersResultEventProcessor:getEventTriggersResultEventProcessor"
                    },
                    "description": "An object where each field name is an event processor ID and each value is an object that configures its corresponding event processor.\n"
                },
                "functionId": {
                    "type": "string",
                    "description": "The ID of the function associated with the trigger.\n"
                },
                "functionName": {
                    "type": "string",
                    "description": "The name of the function associated with the trigger.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the trigger.\n"
                },
                "triggerId": {
                    "type": "string"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the trigger. Possible Values: `DATABASE`, `AUTHENTICATION`\n"
                },
                "unordered": {
                    "type": "boolean",
                    "description": "Sort order for `DATABASE` type.\n"
                }
            },
            "type": "object",
            "required": [
                "configCollection",
                "configDatabase",
                "configFullDocument",
                "configFullDocumentBefore",
                "configMatch",
                "configOperationType",
                "configOperationTypes",
                "configProject",
                "configProviders",
                "configSchedule",
                "configScheduleType",
                "configServiceId",
                "disabled",
                "eventProcessors",
                "functionId",
                "functionName",
                "name",
                "triggerId",
                "type",
                "unordered"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getEventTriggersResultEventProcessor:getEventTriggersResultEventProcessor": {
            "properties": {
                "awsEventbridges": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getEventTriggersResultEventProcessorAwsEventbridge:getEventTriggersResultEventProcessorAwsEventbridge"
                    }
                }
            },
            "type": "object",
            "required": [
                "awsEventbridges"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getEventTriggersResultEventProcessorAwsEventbridge:getEventTriggersResultEventProcessorAwsEventbridge": {
            "properties": {
                "configAccountId": {
                    "type": "string",
                    "description": "AWS Account ID.\n"
                },
                "configRegion": {
                    "type": "string",
                    "description": "Region of AWS Account.\n"
                }
            },
            "type": "object",
            "required": [
                "configAccountId",
                "configRegion"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedDatabaseInstanceCloudProviderConfig:getFederatedDatabaseInstanceCloudProviderConfig": {
            "properties": {
                "aws": {
                    "$ref": "#/types/mongodbatlas:index/getFederatedDatabaseInstanceCloudProviderConfigAws:getFederatedDatabaseInstanceCloudProviderConfigAws"
                }
            },
            "type": "object",
            "required": [
                "aws"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedDatabaseInstanceCloudProviderConfigAws:getFederatedDatabaseInstanceCloudProviderConfigAws": {
            "properties": {
                "externalId": {
                    "type": "string",
                    "description": "Unique identifier associated with the IAM Role that the Federated Database Instance assumes when accessing the data stores.\n"
                },
                "iamAssumedRoleArn": {
                    "type": "string",
                    "description": "Amazon Resource Name (ARN) of the IAM Role that the Federated Database Instance assumes when accessing S3 Bucket data stores. The IAM Role must support the following actions against each S3 bucket:\n* `s3:GetObject`\n* `s3:ListBucket`\n* `s3:GetObjectVersion`\n"
                },
                "iamUserArn": {
                    "type": "string",
                    "description": "Amazon Resource Name (ARN) of the user that the Federated Database Instance assumes when accessing S3 Bucket data stores.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "Unique identifier of the role that the data lake can use to access the data stores.\n"
                },
                "testS3Bucket": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "externalId",
                "iamAssumedRoleArn",
                "iamUserArn",
                "roleId",
                "testS3Bucket"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedDatabaseInstanceDataProcessRegion:getFederatedDatabaseInstanceDataProcessRegion": {
            "properties": {
                "cloudProvider": {
                    "type": "string",
                    "description": "Name of the cloud service provider. Atlas Federated Database only supports AWS.\n"
                },
                "region": {
                    "type": "string",
                    "description": "Name of the region to which the Federanted Instnace routes client connections for data processing.\n"
                }
            },
            "type": "object",
            "required": [
                "cloudProvider",
                "region"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedDatabaseInstanceStorageDatabase:getFederatedDatabaseInstanceStorageDatabase": {
            "properties": {
                "collections": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedDatabaseInstanceStorageDatabaseCollection:getFederatedDatabaseInstanceStorageDatabaseCollection"
                    }
                },
                "maxWildcardCollections": {
                    "type": "integer"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the Atlas Federated Database Instance.\n"
                },
                "views": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedDatabaseInstanceStorageDatabaseView:getFederatedDatabaseInstanceStorageDatabaseView"
                    }
                }
            },
            "type": "object",
            "required": [
                "collections",
                "maxWildcardCollections",
                "name",
                "views"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedDatabaseInstanceStorageDatabaseCollection:getFederatedDatabaseInstanceStorageDatabaseCollection": {
            "properties": {
                "dataSources": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedDatabaseInstanceStorageDatabaseCollectionDataSource:getFederatedDatabaseInstanceStorageDatabaseCollectionDataSource"
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Name of the Atlas Federated Database Instance.\n"
                }
            },
            "type": "object",
            "required": [
                "dataSources",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedDatabaseInstanceStorageDatabaseCollectionDataSource:getFederatedDatabaseInstanceStorageDatabaseCollectionDataSource": {
            "properties": {
                "allowInsecure": {
                    "type": "boolean"
                },
                "collection": {
                    "type": "string"
                },
                "collectionRegex": {
                    "type": "string"
                },
                "database": {
                    "type": "string"
                },
                "databaseRegex": {
                    "type": "string"
                },
                "datasetName": {
                    "type": "string"
                },
                "defaultFormat": {
                    "type": "string"
                },
                "path": {
                    "type": "string"
                },
                "provenanceFieldName": {
                    "type": "string"
                },
                "storeName": {
                    "type": "string"
                },
                "urls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object",
            "required": [
                "allowInsecure",
                "collection",
                "collectionRegex",
                "database",
                "databaseRegex",
                "datasetName",
                "defaultFormat",
                "path",
                "provenanceFieldName",
                "storeName",
                "urls"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedDatabaseInstanceStorageDatabaseView:getFederatedDatabaseInstanceStorageDatabaseView": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the Atlas Federated Database Instance.\n"
                },
                "pipeline": {
                    "type": "string"
                },
                "source": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "name",
                "pipeline",
                "source"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedDatabaseInstanceStorageStore:getFederatedDatabaseInstanceStorageStore": {
            "properties": {
                "additionalStorageClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "allowInsecure": {
                    "type": "boolean"
                },
                "bucket": {
                    "type": "string"
                },
                "clusterId": {
                    "type": "string",
                    "deprecationMessage": "This parameter is deprecated and will be removed by September 2024."
                },
                "clusterName": {
                    "type": "string"
                },
                "defaultFormat": {
                    "type": "string"
                },
                "delimiter": {
                    "type": "string"
                },
                "includeTags": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the Atlas Federated Database Instance.\n"
                },
                "prefix": {
                    "type": "string"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create a Federated Database Instance.\n"
                },
                "provider": {
                    "type": "string"
                },
                "public": {
                    "type": "string"
                },
                "readPreferences": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedDatabaseInstanceStorageStoreReadPreference:getFederatedDatabaseInstanceStorageStoreReadPreference"
                    }
                },
                "region": {
                    "type": "string",
                    "description": "Name of the region to which the Federanted Instnace routes client connections for data processing.\n"
                },
                "urls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object",
            "required": [
                "additionalStorageClasses",
                "allowInsecure",
                "bucket",
                "clusterId",
                "clusterName",
                "defaultFormat",
                "delimiter",
                "includeTags",
                "name",
                "prefix",
                "projectId",
                "provider",
                "public",
                "readPreferences",
                "region",
                "urls"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedDatabaseInstanceStorageStoreReadPreference:getFederatedDatabaseInstanceStorageStoreReadPreference": {
            "properties": {
                "maxStalenessSeconds": {
                    "type": "integer"
                },
                "mode": {
                    "type": "string"
                },
                "tagSets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedDatabaseInstanceStorageStoreReadPreferenceTagSet:getFederatedDatabaseInstanceStorageStoreReadPreferenceTagSet"
                    }
                }
            },
            "type": "object",
            "required": [
                "maxStalenessSeconds",
                "mode",
                "tagSets"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedDatabaseInstanceStorageStoreReadPreferenceTagSet:getFederatedDatabaseInstanceStorageStoreReadPreferenceTagSet": {
            "properties": {
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTag:getFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTag"
                    }
                }
            },
            "type": "object",
            "required": [
                "tags"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTag:getFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTag": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Name of the Atlas Federated Database Instance.\n"
                },
                "value": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedDatabaseInstancesResult:getFederatedDatabaseInstancesResult": {
            "properties": {
                "cloudProviderConfig": {
                    "$ref": "#/types/mongodbatlas:index/getFederatedDatabaseInstancesResultCloudProviderConfig:getFederatedDatabaseInstancesResultCloudProviderConfig"
                },
                "dataProcessRegions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedDatabaseInstancesResultDataProcessRegion:getFederatedDatabaseInstancesResultDataProcessRegion"
                    }
                },
                "hostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of hostnames assigned to the Federated Database Instance. Each string in the array is a hostname assigned to the Federated Database Instance.\n"
                },
                "name": {
                    "type": "string"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create a Federated Database Instance.\n"
                },
                "state": {
                    "type": "string",
                    "description": "Current state of the Federated Database Instance:\n* `ACTIVE` - The Federated Database Instance is active and verified. You can query the data stores associated with the Federated Database Instance.\n* `DELETED` - The Federated Database Instance was deleted.\n"
                },
                "storageDatabases": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedDatabaseInstancesResultStorageDatabase:getFederatedDatabaseInstancesResultStorageDatabase"
                    },
                    "description": "Configuration details for mapping each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [databases](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-databases-reference). An empty object indicates that the Federated Database Instance has no mapping configuration for any data store.\n* `storage_databases.#.name` - Name of the database to which the Federated Database Instance maps the data contained in the data store.\n* `storage_databases.#.collections` -     Array of objects where each object represents a collection and data sources that map to a [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#mongodb-datalakeconf-datalakeconf.stores) data store.\n* `storage_databases.#.collections.#.name` - Name of the collection.\n* `storage_databases.#.collections.#.data_sources` -     Array of objects where each object represents a stores data store to map with the collection.\n* `storage_databases.#.collections.#.data_sources.#.store_name` -     Name of a data store to map to the `\u003ccollection\u003e`. Must match the name of an object in the stores array.\n* `storage_databases.#.collections.#.data_sources.#.dataset_name` -     Human-readable label that identifies the dataset that Atlas generates for an ingestion pipeline run or Online Archive.\n* `storage_databases.#.collections.#.data_sources.#.default_format` - Default format that Federated Database assumes if it encounters a file without an extension while searching the storeName.\n* `storage_databases.#.collections.#.data_sources.#.path` - File path that controls how MongoDB Cloud searches for and parses files in the storeName before mapping them to a collection. Specify / to capture all files and folders from the prefix path.\n* `storage_databases.#.collections.#.data_sources.#.database` - Human-readable label that identifies the database, which contains the collection in the cluster.\n* `storage_databases.#.collections.#.data_sources.#.allow_insecure` - Flag that validates the scheme in the specified URLs. If true, allows insecure HTTP scheme, doesn't verify the server's certificate chain and hostname, and accepts any certificate with any hostname presented by the server. If false, allows secure HTTPS scheme only.\n* `storage_databases.#.collections.#.data_sources.#.database_regex` - Regex pattern to use for creating the wildcard database.\n* `storage_databases.#.collections.#.data_sources.#.collection` - Human-readable label that identifies the collection in the database.\n* `storage_databases.#.collections.#.data_sources.#.collection_regex` - Regex pattern to use for creating the wildcard (*) collection.\n* `storage_databases.#.collections.#.data_sources.#.provenance_field_name` - Name for the field that includes the provenance of the documents in the results.\n* `storage_databases.#.collections.#.data_sources.#.storeName` - Human-readable label that identifies the data store that MongoDB Cloud maps to the collection.\n* `storage_databases.#.collections.#.data_sources.#.urls` - URLs of the publicly accessible data files. You can't specify URLs that require authentication.\n* `storage_databases.#.views` -     Array of objects where each object represents an [aggregation pipeline](https://docs.mongodb.com/manual/core/aggregation-pipeline/#id1) on a collection. To learn more about views, see [Views](https://docs.mongodb.com/manual/core/views/).\n* `storage_databases.#.views.#.name` - Name of the view.\n* `storage_databases.#.views.#.source` -  Name of the source collection for the view.\n* `storage_databases.#.views.#.pipeline`- Aggregation pipeline stage(s) to apply to the source collection.\n"
                },
                "storageStores": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedDatabaseInstancesResultStorageStore:getFederatedDatabaseInstancesResultStorageStore"
                    },
                    "description": "Each object in the array represents a data store. Federated Database uses the storage.databases configuration details to map data in each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-stores-reference). An empty object indicates that the Federated Database Instance has no configured data stores.\n* `storage_stores.#.name` - Name of the data store.\n* `storage_stores.#.provider` - Defines where the data is stored.\n* `storage_stores.#.region` - Name of the AWS region in which the S3 bucket is hosted.\n* `storage_stores.#.bucket` - Name of the AWS S3 bucket.\n* `storage_stores.#.prefix` - Prefix the Federated Database Instance applies when searching for files in the S3 bucket.\n* `storage_stores.#.delimiter` - The delimiter that separates `storage_databases.#.collections.#.data_sources.#.path` segments in the data store.\n* `storage_stores.#.include_tags` - Determines whether or not to use S3 tags on the files in the given path as additional partition attributes.\n* `storage_stores.#.cluster_name` - Human-readable label of the MongoDB Cloud cluster on which the store is based.\n* `storage_stores.#.cluster_id` - ID of the Cluster the Online Archive belongs to.\n* `storage_stores.#.allow_insecure` - Flag that validates the scheme in the specified URLs.\n* `storage_stores.#.public` - Flag that indicates whether the bucket is public.\n* `storage_stores.#.default_format` - Default format that Data Lake assumes if it encounters a file without an extension while searching the storeName.\n* `storage_stores.#.urls` - Comma-separated list of publicly accessible HTTP URLs where data is stored.\n* `storage_stores.#.read_preference` - MongoDB Cloud cluster read preference, which describes how to route read requests to the cluster.\n* `storage_stores.#.read_preference.maxStalenessSeconds` - Maximum replication lag, or staleness, for reads from secondaries.\n* `storage_stores.#.read_preference.mode` - Read preference mode that specifies to which replica set member to route the read requests.\n* `storage_stores.#.read_preference.tag_sets` - List that contains tag sets or tag specification documents.\n* `storage_stores.#.read_preference.tags` - List of all tags within a tag set\n* `storage_stores.#.read_preference.tags.name` - Human-readable label of the tag.\n* `storage_stores.#.read_preference.tags.value` - Value of the tag.\n"
                }
            },
            "type": "object",
            "required": [
                "cloudProviderConfig",
                "dataProcessRegions",
                "hostnames",
                "name",
                "projectId",
                "state",
                "storageDatabases",
                "storageStores"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedDatabaseInstancesResultCloudProviderConfig:getFederatedDatabaseInstancesResultCloudProviderConfig": {
            "properties": {
                "aws": {
                    "$ref": "#/types/mongodbatlas:index/getFederatedDatabaseInstancesResultCloudProviderConfigAws:getFederatedDatabaseInstancesResultCloudProviderConfigAws"
                }
            },
            "type": "object",
            "required": [
                "aws"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedDatabaseInstancesResultCloudProviderConfigAws:getFederatedDatabaseInstancesResultCloudProviderConfigAws": {
            "properties": {
                "externalId": {
                    "type": "string",
                    "description": "Unique identifier associated with the IAM Role that the Federated Database Instance assumes when accessing the data stores.\n"
                },
                "iamAssumedRoleArn": {
                    "type": "string",
                    "description": "Amazon Resource Name (ARN) of the IAM Role that the Federated Database Instance assumes when accessing S3 Bucket data stores. The IAM Role must support the following actions against each S3 bucket:\n* `s3:GetObject`\n* `s3:ListBucket`\n* `s3:GetObjectVersion`\n"
                },
                "iamUserArn": {
                    "type": "string",
                    "description": "Amazon Resource Name (ARN) of the user that the Federated Database Instance assumes when accessing S3 Bucket data stores.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "Unique identifier of the role that the data lake can use to access the data stores.\n#### `data_process_region` - The cloud provider region to which the Federated Instance routes client connections for data processing.\n"
                },
                "testS3Bucket": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "externalId",
                "iamAssumedRoleArn",
                "iamUserArn",
                "roleId",
                "testS3Bucket"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedDatabaseInstancesResultDataProcessRegion:getFederatedDatabaseInstancesResultDataProcessRegion": {
            "properties": {
                "cloudProvider": {
                    "type": "string",
                    "description": "Name of the cloud service provider. Atlas Federated Database only supports AWS.\n"
                },
                "region": {
                    "type": "string",
                    "description": "Name of the region to which the Federanted Instnace routes client connections for data processing.\n"
                }
            },
            "type": "object",
            "required": [
                "cloudProvider",
                "region"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedDatabaseInstancesResultStorageDatabase:getFederatedDatabaseInstancesResultStorageDatabase": {
            "properties": {
                "collections": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedDatabaseInstancesResultStorageDatabaseCollection:getFederatedDatabaseInstancesResultStorageDatabaseCollection"
                    }
                },
                "maxWildcardCollections": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "views": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedDatabaseInstancesResultStorageDatabaseView:getFederatedDatabaseInstancesResultStorageDatabaseView"
                    }
                }
            },
            "type": "object",
            "required": [
                "collections",
                "maxWildcardCollections",
                "name",
                "views"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedDatabaseInstancesResultStorageDatabaseCollection:getFederatedDatabaseInstancesResultStorageDatabaseCollection": {
            "properties": {
                "dataSources": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedDatabaseInstancesResultStorageDatabaseCollectionDataSource:getFederatedDatabaseInstancesResultStorageDatabaseCollectionDataSource"
                    }
                },
                "name": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "dataSources",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedDatabaseInstancesResultStorageDatabaseCollectionDataSource:getFederatedDatabaseInstancesResultStorageDatabaseCollectionDataSource": {
            "properties": {
                "allowInsecure": {
                    "type": "boolean"
                },
                "collection": {
                    "type": "string"
                },
                "collectionRegex": {
                    "type": "string"
                },
                "database": {
                    "type": "string"
                },
                "databaseRegex": {
                    "type": "string"
                },
                "datasetName": {
                    "type": "string"
                },
                "defaultFormat": {
                    "type": "string"
                },
                "path": {
                    "type": "string"
                },
                "provenanceFieldName": {
                    "type": "string"
                },
                "storeName": {
                    "type": "string"
                },
                "urls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object",
            "required": [
                "allowInsecure",
                "collection",
                "collectionRegex",
                "database",
                "databaseRegex",
                "datasetName",
                "defaultFormat",
                "path",
                "provenanceFieldName",
                "storeName",
                "urls"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedDatabaseInstancesResultStorageDatabaseView:getFederatedDatabaseInstancesResultStorageDatabaseView": {
            "properties": {
                "name": {
                    "type": "string"
                },
                "pipeline": {
                    "type": "string"
                },
                "source": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "name",
                "pipeline",
                "source"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedDatabaseInstancesResultStorageStore:getFederatedDatabaseInstancesResultStorageStore": {
            "properties": {
                "additionalStorageClasses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "allowInsecure": {
                    "type": "boolean"
                },
                "bucket": {
                    "type": "string"
                },
                "clusterId": {
                    "type": "string",
                    "deprecationMessage": "This parameter is deprecated and will be removed by September 2024."
                },
                "clusterName": {
                    "type": "string"
                },
                "defaultFormat": {
                    "type": "string"
                },
                "delimiter": {
                    "type": "string"
                },
                "includeTags": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string"
                },
                "prefix": {
                    "type": "string"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create a Federated Database Instance.\n"
                },
                "provider": {
                    "type": "string"
                },
                "public": {
                    "type": "string"
                },
                "readPreferences": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedDatabaseInstancesResultStorageStoreReadPreference:getFederatedDatabaseInstancesResultStorageStoreReadPreference"
                    }
                },
                "region": {
                    "type": "string",
                    "description": "Name of the region to which the Federanted Instnace routes client connections for data processing.\n"
                },
                "urls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object",
            "required": [
                "additionalStorageClasses",
                "allowInsecure",
                "bucket",
                "clusterId",
                "clusterName",
                "defaultFormat",
                "delimiter",
                "includeTags",
                "name",
                "prefix",
                "projectId",
                "provider",
                "public",
                "readPreferences",
                "region",
                "urls"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedDatabaseInstancesResultStorageStoreReadPreference:getFederatedDatabaseInstancesResultStorageStoreReadPreference": {
            "properties": {
                "maxStalenessSeconds": {
                    "type": "integer"
                },
                "mode": {
                    "type": "string"
                },
                "tagSets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSet:getFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSet"
                    }
                }
            },
            "type": "object",
            "required": [
                "maxStalenessSeconds",
                "mode",
                "tagSets"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSet:getFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSet": {
            "properties": {
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetTag:getFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetTag"
                    }
                }
            },
            "type": "object",
            "required": [
                "tags"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetTag:getFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetTag": {
            "properties": {
                "name": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedQueryLimitsResult:getFederatedQueryLimitsResult": {
            "properties": {
                "currentUsage": {
                    "type": "integer",
                    "description": "Amount that indicates the current usage of the limit.\n"
                },
                "defaultLimit": {
                    "type": "integer",
                    "description": "Default value of the limit.\n* `lastModifiedDate` - Only used for Data Federation limits. Timestamp that indicates when this usage limit was last modified. This field uses the ISO 8601 timestamp format in UTC.\n* `maximumLimit` - Maximum value of the limit.\n"
                },
                "lastModifiedDate": {
                    "type": "string"
                },
                "limitName": {
                    "type": "string"
                },
                "maximumLimit": {
                    "type": "integer"
                },
                "overrunPolicy": {
                    "type": "string"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create a Federated Database Instance.\n"
                },
                "tenantName": {
                    "type": "string",
                    "description": "Name of the Atlas Federated Database Instance.\n"
                },
                "value": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "currentUsage",
                "defaultLimit",
                "lastModifiedDate",
                "limitName",
                "maximumLimit",
                "overrunPolicy",
                "projectId",
                "tenantName",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProviderAssociatedOrg:getFederatedSettingsIdentityProviderAssociatedOrg": {
            "properties": {
                "domainAllowLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List that contains the approved domains from which organization users can log in.\n"
                },
                "domainRestrictionEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether domain restriction is enabled for the connected organization.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the IdP.\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                },
                "postAuthRoleGrants": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List that contains the default roles granted to users who authenticate through the IdP in a connected organization. If you provide a postAuthRoleGrants field in the request, the array that you provide replaces the current postAuthRoleGrants.\n"
                },
                "roleMappings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsIdentityProviderAssociatedOrgRoleMapping:getFederatedSettingsIdentityProviderAssociatedOrgRoleMapping"
                    }
                },
                "userConflicts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsIdentityProviderAssociatedOrgUserConflict:getFederatedSettingsIdentityProviderAssociatedOrgUserConflict"
                    }
                }
            },
            "type": "object",
            "required": [
                "domainAllowLists",
                "domainRestrictionEnabled",
                "identityProviderId",
                "orgId",
                "postAuthRoleGrants",
                "roleMappings",
                "userConflicts"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProviderAssociatedOrgRoleMapping:getFederatedSettingsIdentityProviderAssociatedOrgRoleMapping": {
            "properties": {
                "externalGroupName": {
                    "type": "string",
                    "description": "Unique human-readable label that identifies the identity provider group to which this role mapping applies.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies this role mapping.\n"
                },
                "roleAssignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignment:getFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignment"
                    },
                    "description": "Atlas roles and the unique identifiers of the groups and organizations associated with each role.\n"
                }
            },
            "type": "object",
            "required": [
                "externalGroupName",
                "id",
                "roleAssignments"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignment:getFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignment": {
            "properties": {
                "groupId": {
                    "type": "string",
                    "description": "Unique identifier of the project to which you want the role mapping to apply.\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Specifies the Role that is attached to the Role Mapping.\n"
                }
            },
            "type": "object",
            "required": [
                "groupId",
                "orgId",
                "role"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProviderAssociatedOrgUserConflict:getFederatedSettingsIdentityProviderAssociatedOrgUserConflict": {
            "properties": {
                "emailAddress": {
                    "type": "string",
                    "description": "Email address of the the user that conflicts with selected domains.\n"
                },
                "federationSettingsId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                },
                "firstName": {
                    "type": "string",
                    "description": "First name of the the user that conflicts with selected domains.\n"
                },
                "lastName": {
                    "type": "string",
                    "description": "Last name of the the user that conflicts with selected domains.\n"
                },
                "userId": {
                    "type": "string",
                    "description": "Name of the Atlas user that conflicts with selected domains.\n"
                }
            },
            "type": "object",
            "required": [
                "emailAddress",
                "federationSettingsId",
                "firstName",
                "lastName",
                "userId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProviderPemFileInfo:getFederatedSettingsIdentityProviderPemFileInfo": {
            "properties": {
                "certificates": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsIdentityProviderPemFileInfoCertificate:getFederatedSettingsIdentityProviderPemFileInfoCertificate"
                    }
                },
                "fileName": {
                    "type": "string",
                    "description": "Filename of certificate\n"
                }
            },
            "type": "object",
            "required": [
                "certificates",
                "fileName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProviderPemFileInfoCertificate:getFederatedSettingsIdentityProviderPemFileInfoCertificate": {
            "properties": {
                "notAfter": {
                    "type": "string",
                    "description": "Expiration  Date.\n"
                },
                "notBefore": {
                    "type": "string",
                    "description": "Start Date.\n"
                }
            },
            "type": "object",
            "required": [
                "notAfter",
                "notBefore"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProvidersResult:getFederatedSettingsIdentityProvidersResult": {
            "properties": {
                "acsUrl": {
                    "type": "string",
                    "description": "Assertion consumer service URL to which the IdP sends the SAML response.\n"
                },
                "associatedDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List that contains the configured domains from which users can log in for this IdP.\n"
                },
                "associatedOrgs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsIdentityProvidersResultAssociatedOrg:getFederatedSettingsIdentityProvidersResultAssociatedOrg"
                    },
                    "description": "List that contains the configured domains from which users can log in for this IdP.\n"
                },
                "audience": {
                    "type": "string",
                    "description": "Identifier of the intended recipient of the token.\n"
                },
                "audienceUri": {
                    "type": "string",
                    "description": "Identifier for the intended audience of the SAML Assertion.\n"
                },
                "authorizationType": {
                    "type": "string",
                    "description": "Indicates whether authorization is granted based on group membership or user ID. Valid values are `GROUP` or `USER`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "Client identifier that is assigned to an application by the Identity Provider.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the identity provider.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the IdP.\n"
                },
                "groupsClaim": {
                    "type": "string",
                    "description": "Identifier of the claim which contains IdP Group IDs in the token.\n"
                },
                "idpId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the IdP.\n"
                },
                "idpType": {
                    "type": "string",
                    "description": "Type of the identity provider. Valid values are `WORKFORCE` or `WORKLOAD`.\n"
                },
                "issuerUri": {
                    "type": "string",
                    "description": "Identifier for the issuer of the SAML Assertion.\n"
                },
                "oktaIdpId": {
                    "type": "string"
                },
                "pemFileInfos": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsIdentityProvidersResultPemFileInfo:getFederatedSettingsIdentityProvidersResultPemFileInfo"
                    }
                },
                "protocol": {
                    "type": "string",
                    "description": "The protocol of the identity provider\n"
                },
                "requestBinding": {
                    "type": "string",
                    "description": "SAML Authentication Request Protocol binding used to send the AuthNRequest. Atlas supports the following binding values:\n- HTTP POST\n- HTTP REDIRECT\n"
                },
                "requestedScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Scopes that MongoDB applications will request from the authorization endpoint.\n"
                },
                "responseSignatureAlgorithm": {
                    "type": "string",
                    "description": "Algorithm used to encrypt the IdP signature. Atlas supports the following signature algorithm values:\n- SHA-1\n- SHA-256\n"
                },
                "ssoDebugEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the IdP has enabled Bypass SAML Mode. Enabling this mode generates a URL that allows you bypass SAML and login to your organizations at any point. You can authenticate with this special URL only when Bypass Mode is enabled. Set this parameter to true during testing. This keeps you from getting locked out of MongoDB.\n"
                },
                "ssoUrl": {
                    "type": "string",
                    "description": "URL of the receiver of the SAML AuthNRequest.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Label that indicates whether the identity provider is active. The IdP is Inactive until you map at least one domain to the IdP.\n"
                },
                "userClaim": {
                    "type": "string",
                    "description": "Identifier of the claim which contains the user ID in the token.\n"
                }
            },
            "type": "object",
            "required": [
                "acsUrl",
                "associatedDomains",
                "associatedOrgs",
                "audience",
                "audienceUri",
                "authorizationType",
                "clientId",
                "description",
                "displayName",
                "groupsClaim",
                "idpId",
                "idpType",
                "issuerUri",
                "oktaIdpId",
                "pemFileInfos",
                "protocol",
                "requestBinding",
                "requestedScopes",
                "responseSignatureAlgorithm",
                "ssoDebugEnabled",
                "ssoUrl",
                "status",
                "userClaim"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProvidersResultAssociatedOrg:getFederatedSettingsIdentityProvidersResultAssociatedOrg": {
            "properties": {
                "domainAllowLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List that contains the approved domains from which organization users can log in.\n"
                },
                "domainRestrictionEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether domain restriction is enabled for the connected organization.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                },
                "postAuthRoleGrants": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List that contains the default roles granted to users who authenticate through the IdP in a connected organization. If you provide a postAuthRoleGrants field in the request, the array that you provide replaces the current postAuthRoleGrants.\n"
                },
                "roleMappings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMapping:getFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMapping"
                    }
                },
                "userConflicts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsIdentityProvidersResultAssociatedOrgUserConflict:getFederatedSettingsIdentityProvidersResultAssociatedOrgUserConflict"
                    }
                }
            },
            "type": "object",
            "required": [
                "domainAllowLists",
                "domainRestrictionEnabled",
                "identityProviderId",
                "orgId",
                "postAuthRoleGrants",
                "roleMappings",
                "userConflicts"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMapping:getFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMapping": {
            "properties": {
                "externalGroupName": {
                    "type": "string",
                    "description": "Unique human-readable label that identifies the identity provider group to which this role mapping applies.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies this role mapping.\n"
                },
                "roleAssignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignment:getFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignment"
                    },
                    "description": "Atlas roles and the unique identifiers of the groups and organizations associated with each role.\n"
                }
            },
            "type": "object",
            "required": [
                "externalGroupName",
                "id",
                "roleAssignments"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignment:getFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignment": {
            "properties": {
                "groupId": {
                    "type": "string",
                    "description": "Unique identifier of the project to which you want the role mapping to apply.\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Specifies the Role that is attached to the Role Mapping.\n"
                }
            },
            "type": "object",
            "required": [
                "groupId",
                "orgId",
                "role"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProvidersResultAssociatedOrgUserConflict:getFederatedSettingsIdentityProvidersResultAssociatedOrgUserConflict": {
            "properties": {
                "emailAddress": {
                    "type": "string",
                    "description": "Email address of the the user that conflicts with selected domains.\n"
                },
                "federationSettingsId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                },
                "firstName": {
                    "type": "string",
                    "description": "First name of the the user that conflicts with selected domains.\n"
                },
                "lastName": {
                    "type": "string",
                    "description": "Last name of the the user that conflicts with selected domains.\n"
                },
                "userId": {
                    "type": "string",
                    "description": "Name of the Atlas user that conflicts with selected domains.\n"
                }
            },
            "type": "object",
            "required": [
                "emailAddress",
                "federationSettingsId",
                "firstName",
                "lastName",
                "userId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProvidersResultPemFileInfo:getFederatedSettingsIdentityProvidersResultPemFileInfo": {
            "properties": {
                "certificates": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsIdentityProvidersResultPemFileInfoCertificate:getFederatedSettingsIdentityProvidersResultPemFileInfoCertificate"
                    }
                },
                "fileName": {
                    "type": "string",
                    "description": "Filename of certificate\n"
                }
            },
            "type": "object",
            "required": [
                "certificates",
                "fileName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProvidersResultPemFileInfoCertificate:getFederatedSettingsIdentityProvidersResultPemFileInfoCertificate": {
            "properties": {
                "notAfter": {
                    "type": "string",
                    "description": "Expiration  Date.\n"
                },
                "notBefore": {
                    "type": "string",
                    "description": "Start Date.\n"
                }
            },
            "type": "object",
            "required": [
                "notAfter",
                "notBefore"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsOrgConfigRoleMapping:getFederatedSettingsOrgConfigRoleMapping": {
            "properties": {
                "externalGroupName": {
                    "type": "string",
                    "description": "Unique human-readable label that identifies the identity provider group to which this role mapping applies.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies this role mapping.\n"
                },
                "roleAssignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsOrgConfigRoleMappingRoleAssignment:getFederatedSettingsOrgConfigRoleMappingRoleAssignment"
                    },
                    "description": "Atlas roles and the unique identifiers of the groups and organizations associated with each role.\n"
                }
            },
            "type": "object",
            "required": [
                "externalGroupName",
                "id",
                "roleAssignments"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsOrgConfigRoleMappingRoleAssignment:getFederatedSettingsOrgConfigRoleMappingRoleAssignment": {
            "properties": {
                "groupId": {
                    "type": "string",
                    "description": "Unique identifier of the project to which you want the role mapping to apply.\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Specifies the Role that is attached to the Role Mapping.\n"
                }
            },
            "type": "object",
            "required": [
                "groupId",
                "orgId",
                "role"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsOrgConfigUserConflict:getFederatedSettingsOrgConfigUserConflict": {
            "properties": {
                "emailAddress": {
                    "type": "string",
                    "description": "Email address of the the user that conflicts with selected domains.\n"
                },
                "federationSettingsId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                },
                "firstName": {
                    "type": "string",
                    "description": "First name of the the user that conflicts with selected domains.\n"
                },
                "lastName": {
                    "type": "string",
                    "description": "Last name of the the user that conflicts with selected domains.\n"
                },
                "userId": {
                    "type": "string",
                    "description": "Name of the Atlas user that conflicts with selected domains.\n"
                }
            },
            "type": "object",
            "required": [
                "emailAddress",
                "federationSettingsId",
                "firstName",
                "lastName",
                "userId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsOrgConfigsResult:getFederatedSettingsOrgConfigsResult": {
            "properties": {
                "dataAccessIdentityProviderIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The collection of unique ids representing the identity providers that can be used for data access in this organization.\n"
                },
                "domainAllowLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List that contains the approved domains from which organization users can log in.\n"
                },
                "domainRestrictionEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether domain restriction is enabled for the connected organization.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "Legacy 20-hexadecimal digit string that identifies the SAML access identity provider that this connected org config is associated with. This id can be found in two ways:\n1. Within the Federation Management UI in Atlas in the Identity Providers tab by clicking the info icon in the IdP ID row of a configured SAML identity provider\n2. `okta_idp_id` on the `mongodbatlas.FederatedSettingsIdentityProvider` resource\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                },
                "postAuthRoleGrants": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List that contains the default roles granted to users who authenticate through the IdP in a connected organization.\n"
                },
                "roleMappings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsOrgConfigsResultRoleMapping:getFederatedSettingsOrgConfigsResultRoleMapping"
                    },
                    "description": "Role mappings that are configured in this organization. See below\n"
                },
                "userConflicts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsOrgConfigsResultUserConflict:getFederatedSettingsOrgConfigsResultUserConflict"
                    },
                    "description": "List that contains the users who have an email address that doesn't match any domain on the allowed list. See below\n"
                }
            },
            "type": "object",
            "required": [
                "dataAccessIdentityProviderIds",
                "domainAllowLists",
                "domainRestrictionEnabled",
                "identityProviderId",
                "orgId",
                "postAuthRoleGrants",
                "roleMappings",
                "userConflicts"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsOrgConfigsResultRoleMapping:getFederatedSettingsOrgConfigsResultRoleMapping": {
            "properties": {
                "externalGroupName": {
                    "type": "string",
                    "description": "Unique human-readable label that identifies the identity provider group to which this role mapping applies.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies this role mapping.\n"
                },
                "roleAssignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsOrgConfigsResultRoleMappingRoleAssignment:getFederatedSettingsOrgConfigsResultRoleMappingRoleAssignment"
                    },
                    "description": "Atlas roles and the unique identifiers of the groups and organizations associated with each role.\n"
                }
            },
            "type": "object",
            "required": [
                "externalGroupName",
                "id",
                "roleAssignments"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsOrgConfigsResultRoleMappingRoleAssignment:getFederatedSettingsOrgConfigsResultRoleMappingRoleAssignment": {
            "properties": {
                "groupId": {
                    "type": "string",
                    "description": "Unique identifier of the project to which you want the role mapping to apply.\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Specifies the Role that is attached to the Role Mapping.\n"
                }
            },
            "type": "object",
            "required": [
                "groupId",
                "orgId",
                "role"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsOrgConfigsResultUserConflict:getFederatedSettingsOrgConfigsResultUserConflict": {
            "properties": {
                "emailAddress": {
                    "type": "string",
                    "description": "Email address of the the user that conflicts with selected domains.\n"
                },
                "federationSettingsId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                },
                "firstName": {
                    "type": "string",
                    "description": "First name of the the user that conflicts with selected domains.\n"
                },
                "lastName": {
                    "type": "string",
                    "description": "Last name of the the user that conflicts with selected domains.\n"
                },
                "userId": {
                    "type": "string",
                    "description": "Name of the Atlas user that conflicts with selected domains.\n"
                }
            },
            "type": "object",
            "required": [
                "emailAddress",
                "federationSettingsId",
                "firstName",
                "lastName",
                "userId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsOrgRoleMappingRoleAssignment:getFederatedSettingsOrgRoleMappingRoleAssignment": {
            "properties": {
                "groupId": {
                    "type": "string",
                    "description": "Unique identifier of the project to which you want the role mapping to apply.\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Specifies the Role that is attached to the Role Mapping.\n"
                }
            },
            "type": "object",
            "required": [
                "groupId",
                "orgId",
                "role"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsOrgRoleMappingsResult:getFederatedSettingsOrgRoleMappingsResult": {
            "properties": {
                "externalGroupName": {
                    "type": "string",
                    "description": "Unique human-readable label that identifies the identity provider group to which this role mapping applies.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies this role mapping.\n"
                },
                "roleAssignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedSettingsOrgRoleMappingsResultRoleAssignment:getFederatedSettingsOrgRoleMappingsResultRoleAssignment"
                    },
                    "description": "Atlas roles and the unique identifiers of the groups and organizations associated with each role.\n"
                }
            },
            "type": "object",
            "required": [
                "externalGroupName",
                "id",
                "roleAssignments"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getFederatedSettingsOrgRoleMappingsResultRoleAssignment:getFederatedSettingsOrgRoleMappingsResultRoleAssignment": {
            "properties": {
                "groupId": {
                    "type": "string",
                    "description": "Unique identifier of the project to which you want the role mapping to apply.\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Specifies the Role that is attached to the Role Mapping.\n"
                }
            },
            "type": "object",
            "required": [
                "groupId",
                "orgId",
                "role"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getGlobalClusterConfigManagedNamespace:getGlobalClusterConfigManagedNamespace": {
            "properties": {
                "collection": {
                    "type": "string",
                    "description": "(Required) The name of the collection associated with the managed namespace.\n"
                },
                "customShardKey": {
                    "type": "string",
                    "description": "(Required)\tThe custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.\n"
                },
                "db": {
                    "type": "string",
                    "description": "(Required) The name of the database containing the collection.\n"
                },
                "isCustomShardKeyHashed": {
                    "type": "boolean",
                    "description": "Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.\n"
                },
                "isShardKeyUnique": {
                    "type": "boolean",
                    "description": "Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).\n"
                }
            },
            "type": "object",
            "required": [
                "collection",
                "customShardKey",
                "db",
                "isCustomShardKeyHashed",
                "isShardKeyUnique"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": [
                        "collection",
                        "customShardKey",
                        "db"
                    ]
                }
            }
        },
        "mongodbatlas:index/getLdapConfigurationUserToDnMapping:getLdapConfigurationUserToDnMapping": {
            "properties": {
                "ldapQuery": {
                    "type": "string",
                    "description": "An LDAP query formatting template that inserts the LDAP name matched by the `match` regular expression into an LDAP query URI as specified by RFC 4515 and RFC 4516.\n"
                },
                "match": {
                    "type": "string",
                    "description": "A regular expression to match against a provided LDAP username.\n"
                },
                "substitution": {
                    "type": "string",
                    "description": "An LDAP Distinguished Name (DN) formatting template that converts the LDAP name matched by the `match` regular expression into an LDAP Distinguished Name.\n"
                }
            },
            "type": "object",
            "required": [
                "ldapQuery",
                "match",
                "substitution"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getLdapVerifyLink:getLdapVerifyLink": {
            "properties": {
                "href": {
                    "type": "string"
                },
                "rel": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "href",
                "rel"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getLdapVerifyValidation:getLdapVerifyValidation": {
            "properties": {
                "status": {
                    "type": "string",
                    "description": "The current status of the LDAP over TLS/SSL configuration.\n"
                },
                "validationType": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "status",
                "validationType"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getNetworkContainersResult:getNetworkContainersResult": {
            "properties": {
                "atlasCidrBlock": {
                    "type": "string",
                    "description": "CIDR block that Atlas uses for your clusters. Atlas uses the specified CIDR block for all other Network Peering connections created in the project. The Atlas CIDR block must be at least a /24 and at most a /21 in one of the following [private networks](https://tools.ietf.org/html/rfc1918.html#section-3).\n"
                },
                "azureSubscriptionId": {
                    "type": "string",
                    "description": "Unique identifer of the Azure subscription in which the VNet resides.\n"
                },
                "gcpProjectId": {
                    "type": "string",
                    "description": "Unique identifier of the GCP project in which the Network Peering connection resides.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The Network Peering Container ID.\n"
                },
                "networkName": {
                    "type": "string",
                    "description": "Name of the Network Peering connection in the Atlas project.\n"
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud provider for this Network peering container. Accepted values are AWS, GCP, and Azure.\n"
                },
                "provisioned": {
                    "type": "boolean",
                    "description": "Indicates whether the project has Network Peering connections deployed in the container.\n"
                },
                "region": {
                    "type": "string",
                    "description": "The Atlas Azure region name for where this container exists.\n"
                },
                "regionName": {
                    "type": "string",
                    "description": "The Atlas AWS region name for where this container exists.\n"
                },
                "regions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Atlas GCP regions where the container resides.\n"
                },
                "vnetName": {
                    "type": "string",
                    "description": "The name of the Azure VNet. This value is null until you provision an Azure VNet in the container.\n"
                },
                "vpcId": {
                    "type": "string",
                    "description": "Unique identifier of the projectâs VPC.\n"
                }
            },
            "type": "object",
            "required": [
                "atlasCidrBlock",
                "azureSubscriptionId",
                "gcpProjectId",
                "id",
                "networkName",
                "providerName",
                "provisioned",
                "region",
                "regionName",
                "regions",
                "vnetName",
                "vpcId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getNetworkPeeringsResult:getNetworkPeeringsResult": {
            "properties": {
                "accepterRegionName": {
                    "type": "string",
                    "description": "Specifies the region where the peer VPC resides. For complete lists of supported regions, see [Amazon Web Services](https://docs.atlas.mongodb.com/reference/amazon-aws/).\n"
                },
                "atlasCidrBlock": {
                    "type": "string"
                },
                "awsAccountId": {
                    "type": "string",
                    "description": "Account ID of the owner of the peer VPC.\n"
                },
                "azureDirectoryId": {
                    "type": "string",
                    "description": "Unique identifier for an Azure AD directory.\n"
                },
                "azureSubscriptionId": {
                    "type": "string",
                    "description": "Unique identifer of the Azure subscription in which the VNet resides.\n"
                },
                "connectionId": {
                    "type": "string",
                    "description": "Unique identifier for the peering connection.\n"
                },
                "containerId": {
                    "type": "string"
                },
                "errorMessage": {
                    "type": "string",
                    "description": "When `\"status\" : \"FAILED\"`, Atlas provides a description of the error.\n"
                },
                "errorState": {
                    "type": "string",
                    "description": "Description of the Atlas error when `status` is `Failed`, Otherwise, Atlas returns `null`.\n"
                },
                "errorStateName": {
                    "type": "string",
                    "description": "Error state, if any. The VPC peering connection error state value can be one of the following: `REJECTED`, `EXPIRED`, `INVALID_ARGUMENT`.\n"
                },
                "gcpProjectId": {
                    "type": "string",
                    "description": "GCP project ID of the owner of the network peer.\n"
                },
                "networkName": {
                    "type": "string",
                    "description": "Name of the network peer to which Atlas connects.\n"
                },
                "peeringId": {
                    "type": "string",
                    "description": "Atlas assigned unique ID for the peering connection.\n"
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud provider for this VPC peering connection. If omitted, Atlas sets this parameter to AWS. (Possible Values `AWS`, `AZURE`, `GCP`).\n"
                },
                "resourceGroupName": {
                    "type": "string",
                    "description": "Name of your Azure resource group.\n"
                },
                "routeTableCidrBlock": {
                    "type": "string",
                    "description": "Peer VPC CIDR block or subnet.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Status of the Atlas network peering connection: `ADDING_PEER`, `AVAILABLE`, `FAILED`, `DELETING`, `WAITING_FOR_USER`.\n"
                },
                "statusName": {
                    "type": "string",
                    "description": "The VPC peering connection status value can be one of the following: `INITIATING`, `PENDING_ACCEPTANCE`, `FAILED`, `FINALIZING`, `AVAILABLE`, `TERMINATING`.\n"
                },
                "vnetName": {
                    "type": "string",
                    "description": "Name of your Azure VNet.\n"
                },
                "vpcId": {
                    "type": "string",
                    "description": "Unique identifier of the peer VPC.\n"
                }
            },
            "type": "object",
            "required": [
                "accepterRegionName",
                "atlasCidrBlock",
                "awsAccountId",
                "azureDirectoryId",
                "azureSubscriptionId",
                "connectionId",
                "containerId",
                "errorMessage",
                "errorState",
                "errorStateName",
                "gcpProjectId",
                "networkName",
                "peeringId",
                "providerName",
                "resourceGroupName",
                "routeTableCidrBlock",
                "status",
                "statusName",
                "vnetName",
                "vpcId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getOnlineArchiveCriteria:getOnlineArchiveCriteria": {
            "properties": {
                "dateField": {
                    "type": "string"
                },
                "dateFormat": {
                    "type": "string"
                },
                "expireAfterDays": {
                    "type": "integer"
                },
                "query": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "dateField",
                "dateFormat",
                "expireAfterDays",
                "query",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getOnlineArchiveDataExpirationRule:getOnlineArchiveDataExpirationRule": {
            "properties": {
                "expireAfterDays": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "expireAfterDays"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getOnlineArchiveDataProcessRegion:getOnlineArchiveDataProcessRegion": {
            "properties": {
                "cloudProvider": {
                    "type": "string"
                },
                "region": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "cloudProvider",
                "region"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getOnlineArchivePartitionField:getOnlineArchivePartitionField": {
            "properties": {
                "fieldName": {
                    "type": "string"
                },
                "fieldType": {
                    "type": "string"
                },
                "order": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "fieldName",
                "fieldType",
                "order"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getOnlineArchiveSchedule:getOnlineArchiveSchedule": {
            "properties": {
                "dayOfMonth": {
                    "type": "integer"
                },
                "dayOfWeek": {
                    "type": "integer"
                },
                "endHour": {
                    "type": "integer"
                },
                "endMinute": {
                    "type": "integer"
                },
                "startHour": {
                    "type": "integer"
                },
                "startMinute": {
                    "type": "integer"
                },
                "type": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "endHour",
                "endMinute",
                "startHour",
                "startMinute",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getOnlineArchivesResult:getOnlineArchivesResult": {
            "properties": {
                "archiveId": {
                    "type": "string"
                },
                "clusterName": {
                    "type": "string",
                    "description": "Name of the cluster that contains the collection.\n\n# Attributes Reference\n\nIn addition to all arguments above, the following attributes are exported:\n"
                },
                "collName": {
                    "type": "string"
                },
                "collectionType": {
                    "type": "string"
                },
                "criterias": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getOnlineArchivesResultCriteria:getOnlineArchivesResultCriteria"
                    }
                },
                "dataExpirationRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getOnlineArchivesResultDataExpirationRule:getOnlineArchivesResultDataExpirationRule"
                    }
                },
                "dataProcessRegions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getOnlineArchivesResultDataProcessRegion:getOnlineArchivesResultDataProcessRegion"
                    }
                },
                "dbName": {
                    "type": "string"
                },
                "partitionFields": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getOnlineArchivesResultPartitionField:getOnlineArchivesResultPartitionField"
                    }
                },
                "paused": {
                    "type": "boolean"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project.\n"
                },
                "schedules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getOnlineArchivesResultSchedule:getOnlineArchivesResultSchedule"
                    }
                },
                "state": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "archiveId",
                "clusterName",
                "collName",
                "collectionType",
                "criterias",
                "dataExpirationRules",
                "dataProcessRegions",
                "dbName",
                "partitionFields",
                "paused",
                "projectId",
                "schedules",
                "state"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getOnlineArchivesResultCriteria:getOnlineArchivesResultCriteria": {
            "properties": {
                "dateField": {
                    "type": "string"
                },
                "dateFormat": {
                    "type": "string"
                },
                "expireAfterDays": {
                    "type": "integer"
                },
                "query": {
                    "type": "string"
                },
                "type": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "dateField",
                "dateFormat",
                "expireAfterDays",
                "query",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getOnlineArchivesResultDataExpirationRule:getOnlineArchivesResultDataExpirationRule": {
            "properties": {
                "expireAfterDays": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "expireAfterDays"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getOnlineArchivesResultDataProcessRegion:getOnlineArchivesResultDataProcessRegion": {
            "properties": {
                "cloudProvider": {
                    "type": "string"
                },
                "region": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "cloudProvider",
                "region"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getOnlineArchivesResultPartitionField:getOnlineArchivesResultPartitionField": {
            "properties": {
                "fieldName": {
                    "type": "string"
                },
                "fieldType": {
                    "type": "string"
                },
                "order": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "fieldName",
                "fieldType",
                "order"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getOnlineArchivesResultSchedule:getOnlineArchivesResultSchedule": {
            "properties": {
                "dayOfMonth": {
                    "type": "integer"
                },
                "dayOfWeek": {
                    "type": "integer"
                },
                "endHour": {
                    "type": "integer"
                },
                "endMinute": {
                    "type": "integer"
                },
                "startHour": {
                    "type": "integer"
                },
                "startMinute": {
                    "type": "integer"
                },
                "type": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "endHour",
                "endMinute",
                "startHour",
                "startMinute",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getOrganizationLink:getOrganizationLink": {
            "properties": {
                "href": {
                    "type": "string"
                },
                "rel": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "href",
                "rel"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getOrganizationsResult:getOrganizationsResult": {
            "properties": {
                "apiAccessListRequired": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to require API operations to originate from an IP Address added to the API access list for the specified organization.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Autogenerated Unique ID for this data source.\n"
                },
                "isDeleted": {
                    "type": "boolean",
                    "description": "Flag that indicates whether this organization has been deleted.\n"
                },
                "links": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getOrganizationsResultLink:getOrganizationsResultLink"
                    }
                },
                "multiFactorAuthRequired": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to require users to set up Multi-Factor Authentication (MFA) before accessing the specified organization. To learn more, see: https://www.mongodb.com/docs/atlas/security-multi-factor-authentication/.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable label that identifies the organization.\n"
                },
                "restrictEmployeeAccess": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to block MongoDB Support from accessing Atlas infrastructure for any deployment in the specified organization without explicit permission. Once this setting is turned on, you can grant MongoDB Support a 24-hour bypass access to the Atlas deployment to resolve support issues. To learn more, see: https://www.mongodb.com/docs/atlas/security-restrict-support-access/.\n\nSee [MongoDB Atlas API - Organizations](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Organizations/operation/listOrganizations)  Documentation for more information.\n"
                }
            },
            "type": "object",
            "required": [
                "apiAccessListRequired",
                "id",
                "isDeleted",
                "links",
                "multiFactorAuthRequired",
                "name",
                "restrictEmployeeAccess"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getOrganizationsResultLink:getOrganizationsResultLink": {
            "properties": {
                "href": {
                    "type": "string"
                },
                "rel": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "href",
                "rel"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getPrivateLinkEndpointServiceEndpoint:getPrivateLinkEndpointServiceEndpoint": {
            "properties": {
                "endpointName": {
                    "type": "string",
                    "description": "Forwarding rule that corresponds to the endpoint you created in GCP.\n"
                },
                "ipAddress": {
                    "type": "string",
                    "description": "Private IP address of the network endpoint group you created in GCP.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Status of the endpoint. Atlas returns one of the [values shown above](https://docs.atlas.mongodb.com/reference/api/private-endpoints-endpoint-create-one/#std-label-ref-status-field).\n"
                }
            },
            "type": "object",
            "required": [
                "endpointName",
                "ipAddress",
                "status"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getPrivatelinkEndpointServiceDataFederationOnlineArchivesResult:getPrivatelinkEndpointServiceDataFederationOnlineArchivesResult": {
            "properties": {
                "comment": {
                    "type": "string",
                    "description": "Human-readable string to associate with this private endpoint.\n"
                },
                "customerEndpointDnsName": {
                    "type": "string",
                    "description": "(Optional) Human-readable label to identify VPC endpoint DNS name.\n"
                },
                "endpointId": {
                    "type": "string",
                    "description": "Unique 22-character alphanumeric string that identifies the private endpoint. See [Atlas Data Lake supports Amazon Web Services private endpoints using the AWS PrivateLink feature](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation/operation/createDataFederationPrivateEndpoint:~:text=Atlas%20Data%20Lake%20supports%20Amazon%20Web%20Services%20private%20endpoints%20using%20the%20AWS%20PrivateLink%20feature).\n"
                },
                "providerName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the cloud service provider.\n"
                },
                "region": {
                    "type": "string",
                    "description": "Human-readable label to identify the region of VPC endpoint.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).\n"
                },
                "type": {
                    "type": "string",
                    "description": "Human-readable label that identifies the resource type associated with this private endpoint.\n"
                }
            },
            "type": "object",
            "required": [
                "comment",
                "customerEndpointDnsName",
                "endpointId",
                "providerName",
                "region",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getPrivatelinkEndpointsServiceServerlessResult:getPrivatelinkEndpointsServiceServerlessResult": {
            "properties": {
                "cloudProviderEndpointId": {
                    "type": "string",
                    "description": "Unique string that identifies the private endpoint's network interface.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Human-readable string to associate with this private endpoint.\n"
                },
                "endpointId": {
                    "type": "string",
                    "description": "(Required) Unique 22-character alphanumeric string that identifies the private endpoint. Atlas supports AWS private endpoints using the [AWS PrivateLink](https://aws.amazon.com/privatelink/) feature.\n"
                },
                "endpointServiceName": {
                    "type": "string",
                    "description": "Unique string that identifies the PrivateLink endpoint service. MongoDB Cloud returns null while it creates the endpoint service.\n"
                },
                "errorMessage": {
                    "type": "string"
                },
                "privateEndpointIpAddress": {
                    "type": "string",
                    "description": "IPv4 address of the private endpoint in your Azure VNet that someone added to this private endpoint service.\n"
                },
                "privateLinkServiceResourceId": {
                    "type": "string",
                    "description": "Root-relative path that identifies the Azure Private Link Service that MongoDB Cloud manages.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Human-readable label that indicates the current operating status of the private endpoint. Values include: RESERVATION_REQUESTED, RESERVED, INITIATING, AVAILABLE, FAILED, DELETING.\n"
                }
            },
            "type": "object",
            "required": [
                "cloudProviderEndpointId",
                "comment",
                "endpointId",
                "endpointServiceName",
                "errorMessage",
                "privateEndpointIpAddress",
                "privateLinkServiceResourceId",
                "status"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getProjectApiKeyProjectAssignment:getProjectApiKeyProjectAssignment": {
            "properties": {
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project.\n"
                },
                "roleNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project. You must specify an array even if you are only associating a single role with the Programmatic API key. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) describes the valid roles that can be assigned.\n"
                }
            },
            "type": "object",
            "required": [
                "projectId",
                "roleNames"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getProjectApiKeysResult:getProjectApiKeysResult": {
            "properties": {
                "apiKeyId": {
                    "type": "string",
                    "description": "Unique identifier for the API key you want to update. Use the /orgs/{ORG-ID}/apiKeys endpoint to retrieve all API keys to which the authenticated user has access for the specified organization.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of this Project API key.\n"
                },
                "privateKey": {
                    "type": "string"
                },
                "projectAssignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getProjectApiKeysResultProjectAssignment:getProjectApiKeysResultProjectAssignment"
                    }
                },
                "publicKey": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "apiKeyId",
                "description",
                "privateKey",
                "publicKey"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getProjectApiKeysResultProjectAssignment:getProjectApiKeysResultProjectAssignment": {
            "properties": {
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project.\n"
                },
                "roleNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project. You must specify an array even if you are only associating a single role with the Programmatic API key. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) describes the valid roles that can be assigned.\n"
                }
            },
            "type": "object",
            "required": [
                "projectId",
                "roleNames"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getProjectIpAddresses:getProjectIpAddresses": {
            "properties": {
                "services": {
                    "$ref": "#/types/mongodbatlas:index/getProjectIpAddressesServices:getProjectIpAddressesServices"
                }
            },
            "type": "object",
            "required": [
                "services"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getProjectIpAddressesServices:getProjectIpAddressesServices": {
            "properties": {
                "clusters": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getProjectIpAddressesServicesCluster:getProjectIpAddressesServicesCluster"
                    }
                }
            },
            "type": "object",
            "required": [
                "clusters"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getProjectIpAddressesServicesCluster:getProjectIpAddressesServicesCluster": {
            "properties": {
                "clusterName": {
                    "type": "string"
                },
                "inbounds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "outbounds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object",
            "required": [
                "clusterName",
                "inbounds",
                "outbounds"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getProjectLimit:getProjectLimit": {
            "properties": {
                "currentUsage": {
                    "type": "integer",
                    "description": "Amount that indicates the current usage of the limit.\n"
                },
                "defaultLimit": {
                    "type": "integer",
                    "description": "Default value of the limit.\n"
                },
                "maximumLimit": {
                    "type": "integer",
                    "description": "Maximum value of the limit.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The unique ID for the project.\n\n\u003e **IMPORTANT:** Either `project_id` or `name` must be configurated.\n"
                },
                "value": {
                    "type": "integer",
                    "description": "Amount the limit is set to.\n"
                }
            },
            "type": "object",
            "required": [
                "currentUsage",
                "defaultLimit",
                "maximumLimit",
                "name",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getProjectTeam:getProjectTeam": {
            "properties": {
                "roleNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Each string in the array represents a project role assigned to the team. Every user associated with the team inherits these roles. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles a user can have.\n"
                },
                "teamId": {
                    "type": "string",
                    "description": "The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.\n"
                }
            },
            "type": "object",
            "required": [
                "roleNames",
                "teamId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getProjectsResult:getProjectsResult": {
            "properties": {
                "clusterCount": {
                    "type": "integer",
                    "description": "The number of Atlas clusters deployed in the project.\n"
                },
                "created": {
                    "type": "string",
                    "description": "The ISO-8601-formatted timestamp of when Atlas created the project.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Autogenerated Unique ID for this data source.\n"
                },
                "ipAddresses": {
                    "$ref": "#/types/mongodbatlas:index/getProjectsResultIpAddresses:getProjectsResultIpAddresses",
                    "description": "IP addresses in a project categorized by services. See IP Addresses.\n"
                },
                "isCollectDatabaseSpecificsStatisticsEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable statistics in [cluster metrics](https://www.mongodb.com/docs/atlas/monitor-cluster-metrics/) collection for the project.\n"
                },
                "isDataExplorerEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable Data Explorer for the project. If enabled, you can query your database with an easy to use interface.\n"
                },
                "isExtendedStorageSizesEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable extended storage sizes for the specified project.\n"
                },
                "isPerformanceAdvisorEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable Performance Advisor and Profiler for the project. If enabled, you can analyze database logs to recommend performance improvements.\n"
                },
                "isRealtimePerformancePanelEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable Real Time Performance Panel for the project. If enabled, you can see real time metrics from your MongoDB database.\n"
                },
                "isSchemaAdvisorEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable Schema Advisor for the project. If enabled, you receive customized recommendations to optimize your data model and enhance performance. Disable this setting to disable schema suggestions in the [Performance Advisor](https://www.mongodb.com/docs/atlas/performance-advisor/#std-label-performance-advisor) and the [Data Explorer](https://www.mongodb.com/docs/atlas/atlas-ui/#std-label-atlas-ui).\n"
                },
                "limits": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getProjectsResultLimit:getProjectsResultLimit"
                    },
                    "description": "The limits for the specified project. See Limits.\n"
                },
                "name": {
                    "type": "string"
                },
                "orgId": {
                    "type": "string",
                    "description": "The ID of the organization you want to create the project within.\n"
                },
                "projectId": {
                    "type": "string"
                },
                "regionUsageRestrictions": {
                    "type": "string",
                    "description": "If GOV_REGIONS_ONLY the project can be used for government regions only, otherwise defaults to standard regions. For more information see [MongoDB Atlas for Government](https://www.mongodb.com/docs/atlas/government/api/#creating-a-project).\n"
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the project. To learn more, see [Resource Tags](https://www.mongodb.com/docs/atlas/tags/)\n"
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getProjectsResultTeam:getProjectsResultTeam"
                    },
                    "description": "Returns all teams to which the authenticated user has access in the project. See Teams.\n"
                }
            },
            "type": "object",
            "required": [
                "clusterCount",
                "created",
                "id",
                "ipAddresses",
                "isCollectDatabaseSpecificsStatisticsEnabled",
                "isDataExplorerEnabled",
                "isExtendedStorageSizesEnabled",
                "isPerformanceAdvisorEnabled",
                "isRealtimePerformancePanelEnabled",
                "isSchemaAdvisorEnabled",
                "limits",
                "name",
                "orgId",
                "projectId",
                "regionUsageRestrictions",
                "tags",
                "teams"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getProjectsResultIpAddresses:getProjectsResultIpAddresses": {
            "properties": {
                "services": {
                    "$ref": "#/types/mongodbatlas:index/getProjectsResultIpAddressesServices:getProjectsResultIpAddressesServices"
                }
            },
            "type": "object",
            "required": [
                "services"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getProjectsResultIpAddressesServices:getProjectsResultIpAddressesServices": {
            "properties": {
                "clusters": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getProjectsResultIpAddressesServicesCluster:getProjectsResultIpAddressesServicesCluster"
                    }
                }
            },
            "type": "object",
            "required": [
                "clusters"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getProjectsResultIpAddressesServicesCluster:getProjectsResultIpAddressesServicesCluster": {
            "properties": {
                "clusterName": {
                    "type": "string"
                },
                "inbounds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "outbounds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object",
            "required": [
                "clusterName",
                "inbounds",
                "outbounds"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getProjectsResultLimit:getProjectsResultLimit": {
            "properties": {
                "currentUsage": {
                    "type": "integer",
                    "description": "Amount that indicates the current usage of the limit.\n"
                },
                "defaultLimit": {
                    "type": "integer",
                    "description": "Default value of the limit.\n"
                },
                "maximumLimit": {
                    "type": "integer",
                    "description": "Maximum value of the limit.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable label that identifies this project limit.\n"
                },
                "value": {
                    "type": "integer",
                    "description": "Amount the limit is set to.\n"
                }
            },
            "type": "object",
            "required": [
                "currentUsage",
                "defaultLimit",
                "maximumLimit",
                "name",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getProjectsResultTeam:getProjectsResultTeam": {
            "properties": {
                "roleNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Each string in the array represents a project role assigned to the team. Every user associated with the team inherits these roles. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles a user can have.\n"
                },
                "teamId": {
                    "type": "string",
                    "description": "The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.\n"
                }
            },
            "type": "object",
            "required": [
                "roleNames",
                "teamId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getSearchDeploymentSpec:getSearchDeploymentSpec": {
            "properties": {
                "instanceSize": {
                    "type": "string",
                    "description": "Hardware specification for the search node instance sizes. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Atlas-Search/operation/createAtlasSearchDeployment) describes the valid values. More details can also be found in the [Search Node Documentation](https://www.mongodb.com/docs/atlas/cluster-config/multi-cloud-distribution/#search-tier).\n"
                },
                "nodeCount": {
                    "type": "integer",
                    "description": "Number of search nodes in the cluster.\n"
                }
            },
            "type": "object",
            "required": [
                "instanceSize",
                "nodeCount"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getSearchIndexSynonym:getSearchIndexSynonym": {
            "properties": {
                "analyzer": {
                    "type": "string",
                    "description": "[Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the index.\n"
                },
                "sourceCollection": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "analyzer",
                "name",
                "sourceCollection"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getSearchIndexesResult:getSearchIndexesResult": {
            "properties": {
                "analyzer": {
                    "type": "string",
                    "description": "[Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.\n"
                },
                "analyzers": {
                    "type": "string",
                    "description": "[Custom analyzers](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-custom-analyzers) to use in this index (this is an array of objects).\n"
                },
                "clusterName": {
                    "type": "string",
                    "description": "Name of the cluster containing the collection with one or more Atlas Search indexes.\n"
                },
                "collectionName": {
                    "type": "string",
                    "description": "Name of the collection with one or more Atlas Search indexes.\n"
                },
                "database": {
                    "type": "string",
                    "description": "(Required) Name of the database the collection is in.\n"
                },
                "fields": {
                    "type": "string"
                },
                "indexId": {
                    "type": "string",
                    "description": "The unique identifier of the Atlas Search index.\n"
                },
                "mappingsDynamic": {
                    "type": "boolean",
                    "description": "Flag indicating whether the index uses dynamic or static mappings.\n"
                },
                "mappingsFields": {
                    "type": "string",
                    "description": "Object containing one or more field specifications.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the index.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique identifier for the [project](https://docs.atlas.mongodb.com/organizations-projects/#std-label-projects) that contains the specified cluster.\n"
                },
                "searchAnalyzer": {
                    "type": "string",
                    "description": "[Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when searching the index.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Current status of the index.\n"
                },
                "storedSource": {
                    "type": "string",
                    "description": "String that can be \"true\" (store all fields), \"false\" (default, don't store any field), or a JSON string that contains the list of fields to store (include) or not store (exclude) on Atlas Search. To learn more, see [Stored Source Fields](https://www.mongodb.com/docs/atlas/atlas-search/stored-source-definition/).\n"
                },
                "synonyms": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getSearchIndexesResultSynonym:getSearchIndexesResultSynonym"
                    },
                    "description": "Synonyms mapping definition to use in this index.\n* `synonyms.#.name` - Name of the [synonym mapping definition](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-ref).\n* `synonyms.#.source_collection` - Name of the source MongoDB collection for the synonyms.\n* `synonyms.#.analyzer` - Name of the [analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use with this synonym mapping.\n"
                },
                "type": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "analyzer",
                "analyzers",
                "clusterName",
                "collectionName",
                "database",
                "fields",
                "indexId",
                "mappingsDynamic",
                "mappingsFields",
                "name",
                "projectId",
                "searchAnalyzer",
                "status",
                "storedSource",
                "synonyms",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getSearchIndexesResultSynonym:getSearchIndexesResultSynonym": {
            "properties": {
                "analyzer": {
                    "type": "string",
                    "description": "[Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the index.\n"
                },
                "sourceCollection": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "analyzer",
                "name",
                "sourceCollection"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getServerlessInstanceLink:getServerlessInstanceLink": {
            "properties": {
                "href": {
                    "type": "string"
                },
                "rel": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "href",
                "rel"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getServerlessInstanceTag:getServerlessInstanceTag": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "Constant that defines the set of the tag.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Variable that belongs to the set of the tag.\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getServerlessInstancesResult:getServerlessInstancesResult": {
            "properties": {
                "autoIndexing": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the serverless instance uses [Serverless Auto Indexing](https://www.mongodb.com/docs/atlas/performance-advisor/auto-index-serverless/).\n"
                },
                "connectionStringsPrivateEndpointSrvs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "connectionStringsStandardSrv": {
                    "type": "string",
                    "description": "Public `mongodb+srv://` connection string that you can use to connect to this serverless instance.\n"
                },
                "continuousBackupEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the serverless instance uses Serverless Continuous Backup.\n"
                },
                "createDate": {
                    "type": "string"
                },
                "id": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the serverless instance.\n"
                },
                "links": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getServerlessInstancesResultLink:getServerlessInstancesResultLink"
                    }
                },
                "mongoDbVersion": {
                    "type": "string",
                    "description": "Version of MongoDB that the serverless instance runs, in `\u003cmajor version\u003e`.`\u003cminor version\u003e` format.\n"
                },
                "name": {
                    "type": "string",
                    "description": "(Required) Human-readable label that identifies your serverless instance.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique identifier for the [project](https://docs.atlas.mongodb.com/organizations-projects/#std-label-projects) that contains the specified cluster.\n"
                },
                "providerSettingsBackingProviderName": {
                    "type": "string",
                    "description": "Cloud service provider on which MongoDB Cloud provisioned the serverless instance.\n"
                },
                "providerSettingsProviderName": {
                    "type": "string",
                    "description": "Cloud service provider that applies to the provisioned the serverless instance.\n"
                },
                "providerSettingsRegionName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the physical location of your MongoDB serverless instance. The region you choose can affect network latency for clients accessing your databases.\n"
                },
                "stateName": {
                    "type": "string",
                    "description": "Stage of deployment of this serverless instance when the resource made its request.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/getServerlessInstancesResultTag:getServerlessInstancesResultTag"
                    },
                    "description": "Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.\n"
                },
                "terminationProtectionEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n"
                }
            },
            "type": "object",
            "required": [
                "autoIndexing",
                "connectionStringsPrivateEndpointSrvs",
                "connectionStringsStandardSrv",
                "continuousBackupEnabled",
                "createDate",
                "id",
                "links",
                "mongoDbVersion",
                "name",
                "projectId",
                "providerSettingsBackingProviderName",
                "providerSettingsProviderName",
                "providerSettingsRegionName",
                "stateName",
                "tags",
                "terminationProtectionEnabled"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getServerlessInstancesResultLink:getServerlessInstancesResultLink": {
            "properties": {
                "href": {
                    "type": "string"
                },
                "rel": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "href",
                "rel"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getServerlessInstancesResultTag:getServerlessInstancesResultTag": {
            "properties": {
                "key": {
                    "type": "string",
                    "description": "Constant that defines the set of the tag.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Variable that belongs to the set of the tag.\n"
                }
            },
            "type": "object",
            "required": [
                "key",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getSharedTierRestoreJobsResult:getSharedTierRestoreJobsResult": {
            "properties": {
                "deliveryType": {
                    "type": "string"
                },
                "expirationDate": {
                    "type": "string"
                },
                "jobId": {
                    "type": "string"
                },
                "restoreFinishedDate": {
                    "type": "string"
                },
                "restoreScheduledDate": {
                    "type": "string"
                },
                "snapshotFinishedDate": {
                    "type": "string"
                },
                "snapshotId": {
                    "type": "string"
                },
                "snapshotUrl": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                },
                "targetDeploymentItemName": {
                    "type": "string"
                },
                "targetProjectId": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "deliveryType",
                "expirationDate",
                "jobId",
                "restoreFinishedDate",
                "restoreScheduledDate",
                "snapshotFinishedDate",
                "snapshotId",
                "snapshotUrl",
                "status",
                "targetDeploymentItemName",
                "targetProjectId"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getSharedTierSnapshotsResult:getSharedTierSnapshotsResult": {
            "properties": {
                "expiration": {
                    "type": "string"
                },
                "finishTime": {
                    "type": "string"
                },
                "mongoDbVersion": {
                    "type": "string"
                },
                "scheduledTime": {
                    "type": "string"
                },
                "snapshotId": {
                    "type": "string"
                },
                "startTime": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "expiration",
                "finishTime",
                "mongoDbVersion",
                "scheduledTime",
                "snapshotId",
                "startTime",
                "status"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getStreamConnectionAuthentication:getStreamConnectionAuthentication": {
            "properties": {
                "mechanism": {
                    "type": "string",
                    "description": "Style of authentication. Can be one of `PLAIN`, `SCRAM-256`, or `SCRAM-512`.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password of the account to connect to the Kafka cluster.\n",
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "Username of the account to connect to the Kafka cluster.\n"
                }
            },
            "type": "object",
            "required": [
                "mechanism",
                "password",
                "username"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getStreamConnectionDbRoleToExecute:getStreamConnectionDbRoleToExecute": {
            "properties": {
                "role": {
                    "type": "string",
                    "description": "The name of the role to use. Can be a built in role or a custom role.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the DB role. Can be either BUILT_IN or CUSTOM.\n"
                }
            },
            "type": "object",
            "required": [
                "role",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getStreamConnectionSecurity:getStreamConnectionSecurity": {
            "properties": {
                "brokerPublicCertificate": {
                    "type": "string",
                    "description": "A trusted, public x509 certificate for connecting to Kafka over SSL. String value of the certificate must be defined in the attribute.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Describes the transport type. Can be either `PLAINTEXT` or `SSL`.\n"
                }
            },
            "type": "object",
            "required": [
                "brokerPublicCertificate",
                "protocol"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getStreamConnectionsResult:getStreamConnectionsResult": {
            "properties": {
                "authentication": {
                    "$ref": "#/types/mongodbatlas:index/getStreamConnectionsResultAuthentication:getStreamConnectionsResultAuthentication",
                    "description": "User credentials required to connect to a Kafka cluster. Includes the authentication type, as well as the parameters for that authentication mode. See authentication.\n"
                },
                "bootstrapServers": {
                    "type": "string",
                    "description": "Comma separated list of server addresses.\n"
                },
                "clusterName": {
                    "type": "string",
                    "description": "Name of the cluster configured for this connection.\n"
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of Kafka key-value pairs for optional configuration. This is a flat object, and keys can have '.' characters.\n"
                },
                "connectionName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the stream connection. In the case of the Sample type, this is the name of the sample source.\n"
                },
                "dbRoleToExecute": {
                    "$ref": "#/types/mongodbatlas:index/getStreamConnectionsResultDbRoleToExecute:getStreamConnectionsResultDbRoleToExecute",
                    "description": "The name of a Built in or Custom DB Role to connect to an Atlas Cluster. See DBRoleToExecute.\n"
                },
                "id": {
                    "type": "string"
                },
                "instanceName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the stream instance.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies your project.\n"
                },
                "security": {
                    "$ref": "#/types/mongodbatlas:index/getStreamConnectionsResultSecurity:getStreamConnectionsResultSecurity",
                    "description": "Properties for the secure transport connection to Kafka. For SSL, this can include the trusted certificate to use. See security.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the DB role. Can be either BUILT_IN or CUSTOM.\n"
                }
            },
            "type": "object",
            "required": [
                "authentication",
                "bootstrapServers",
                "clusterName",
                "config",
                "connectionName",
                "dbRoleToExecute",
                "id",
                "instanceName",
                "projectId",
                "security",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getStreamConnectionsResultAuthentication:getStreamConnectionsResultAuthentication": {
            "properties": {
                "mechanism": {
                    "type": "string",
                    "description": "Style of authentication. Can be one of `PLAIN`, `SCRAM-256`, or `SCRAM-512`.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password of the account to connect to the Kafka cluster.\n",
                    "secret": true
                },
                "username": {
                    "type": "string",
                    "description": "Username of the account to connect to the Kafka cluster.\n"
                }
            },
            "type": "object",
            "required": [
                "mechanism",
                "password",
                "username"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getStreamConnectionsResultDbRoleToExecute:getStreamConnectionsResultDbRoleToExecute": {
            "properties": {
                "role": {
                    "type": "string",
                    "description": "The name of the role to use. Can be a built in role or a custom role.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the DB role. Can be either BUILT_IN or CUSTOM.\n"
                }
            },
            "type": "object",
            "required": [
                "role",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getStreamConnectionsResultSecurity:getStreamConnectionsResultSecurity": {
            "properties": {
                "brokerPublicCertificate": {
                    "type": "string",
                    "description": "A trusted, public x509 certificate for connecting to Kafka over SSL. String value of the certificate must be defined in the attribute.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Describes the transport type. Can be either `PLAINTEXT` or `SSL`.\n"
                }
            },
            "type": "object",
            "required": [
                "brokerPublicCertificate",
                "protocol"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getStreamInstanceDataProcessRegion:getStreamInstanceDataProcessRegion": {
            "properties": {
                "cloudProvider": {
                    "type": "string",
                    "description": "Label that identifies the cloud service provider where MongoDB Cloud performs stream processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.\n"
                },
                "region": {
                    "type": "string",
                    "description": "Name of the cloud provider region hosting Atlas Stream Processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.\n"
                }
            },
            "type": "object",
            "required": [
                "cloudProvider",
                "region"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getStreamInstanceStreamConfig:getStreamInstanceStreamConfig": {
            "properties": {
                "tier": {
                    "type": "string",
                    "description": "Selected tier for the Stream Instance. Configures Memory / VCPU allowances. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.\n"
                }
            },
            "type": "object",
            "required": [
                "tier"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getStreamInstancesResult:getStreamInstancesResult": {
            "properties": {
                "dataProcessRegion": {
                    "$ref": "#/types/mongodbatlas:index/getStreamInstancesResultDataProcessRegion:getStreamInstancesResultDataProcessRegion",
                    "description": "Defines the cloud service provider and region where MongoDB Cloud performs stream processing. See data process region.\n"
                },
                "hostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List that contains the hostnames assigned to the stream instance.\n"
                },
                "id": {
                    "type": "string"
                },
                "instanceName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the stream instance.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies your project.\n"
                },
                "streamConfig": {
                    "$ref": "#/types/mongodbatlas:index/getStreamInstancesResultStreamConfig:getStreamInstancesResultStreamConfig",
                    "description": "Defines the configuration options for an Atlas Stream Processing Instance. See stream config\n"
                }
            },
            "type": "object",
            "required": [
                "dataProcessRegion",
                "hostnames",
                "id",
                "instanceName",
                "projectId",
                "streamConfig"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getStreamInstancesResultDataProcessRegion:getStreamInstancesResultDataProcessRegion": {
            "properties": {
                "cloudProvider": {
                    "type": "string",
                    "description": "Label that identifies the cloud service provider where MongoDB Cloud performs stream processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.\n"
                },
                "region": {
                    "type": "string",
                    "description": "Name of the cloud provider region hosting Atlas Stream Processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.\n"
                }
            },
            "type": "object",
            "required": [
                "cloudProvider",
                "region"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getStreamInstancesResultStreamConfig:getStreamInstancesResultStreamConfig": {
            "properties": {
                "tier": {
                    "type": "string",
                    "description": "Selected tier for the Stream Instance. Configures Memory / VCPU allowances. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.\n"
                }
            },
            "type": "object",
            "required": [
                "tier"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getThirdPartyIntegrationsResult:getThirdPartyIntegrationsResult": {
            "properties": {
                "accountId": {
                    "type": "string"
                },
                "apiKey": {
                    "type": "string",
                    "description": "Your API Key.\n",
                    "secret": true
                },
                "channelName": {
                    "type": "string"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Whether your cluster has Prometheus enabled.\n"
                },
                "id": {
                    "type": "string",
                    "description": "Unique identifier of the integration.\n"
                },
                "microsoftTeamsWebhookUrl": {
                    "type": "string",
                    "description": "Your Microsoft Teams incoming webhook URL.\n* `PROMETHEUS`\n",
                    "secret": true
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to get all Third-Party service integrations\n"
                },
                "region": {
                    "type": "string",
                    "description": "Two-letter code that indicates which API URL to use. See the `region` response field of [MongoDB API Third-Party Service Integration documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Third-Party-Integrations/operation/getThirdPartyIntegration) for more details. Opsgenie will use US by default.\n* `VICTOR_OPS`\n"
                },
                "routingKey": {
                    "type": "string",
                    "description": "An optional field for your Routing Key.\n* `WEBHOOK`\n",
                    "secret": true
                },
                "secret": {
                    "type": "string",
                    "description": "An optional field for your webhook secret.\n* `MICROSOFT_TEAMS`\n",
                    "secret": true
                },
                "serviceDiscovery": {
                    "type": "string",
                    "description": "Indicates which service discovery method is used, either file or http.\n",
                    "secret": true
                },
                "serviceKey": {
                    "type": "string",
                    "description": "Your Service Key.\n* `DATADOG`\n",
                    "secret": true
                },
                "teamName": {
                    "type": "string"
                },
                "type": {
                    "type": "string",
                    "description": "Thirt-Party service integration type.\n"
                },
                "url": {
                    "type": "string",
                    "description": "Your webhook URL.\n"
                },
                "userName": {
                    "type": "string",
                    "description": "Your Prometheus username.\n",
                    "secret": true
                }
            },
            "type": "object",
            "required": [
                "accountId",
                "apiKey",
                "channelName",
                "id",
                "projectId",
                "region",
                "routingKey",
                "secret",
                "serviceKey",
                "teamName",
                "type",
                "url"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "mongodbatlas:index/getX509AuthenticationDatabaseUserCertificate:getX509AuthenticationDatabaseUserCertificate": {
            "properties": {
                "createdAt": {
                    "type": "string"
                },
                "groupId": {
                    "type": "string"
                },
                "id": {
                    "type": "integer"
                },
                "notAfter": {
                    "type": "string"
                },
                "subject": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "createdAt",
                "groupId",
                "id",
                "notAfter",
                "subject"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        }
    },
    "provider": {
        "description": "The provider type for the mongodbatlas package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "assumeRole": {
                "$ref": "#/types/mongodbatlas:index/ProviderAssumeRole:ProviderAssumeRole"
            },
            "awsAccessKeyId": {
                "type": "string",
                "description": "AWS API Access Key.\n"
            },
            "awsSecretAccessKey": {
                "type": "string",
                "description": "AWS API Access Secret Key.\n"
            },
            "awsSessionToken": {
                "type": "string",
                "description": "AWS Security Token Service provided session token.\n"
            },
            "baseUrl": {
                "type": "string",
                "description": "MongoDB Atlas Base URL\n"
            },
            "isMongodbgovCloud": {
                "type": "boolean",
                "description": "MongoDB Atlas Base URL default to gov\n"
            },
            "privateKey": {
                "type": "string",
                "description": "MongoDB Atlas Programmatic Private Key\n",
                "secret": true
            },
            "publicKey": {
                "type": "string",
                "description": "MongoDB Atlas Programmatic Public Key\n"
            },
            "realmBaseUrl": {
                "type": "string",
                "description": "MongoDB Realm Base URL\n"
            },
            "region": {
                "type": "string",
                "description": "Region where secret is stored as part of AWS Secret Manager.\n"
            },
            "secretName": {
                "type": "string",
                "description": "Name of secret stored in AWS Secret Manager.\n"
            },
            "stsEndpoint": {
                "type": "string",
                "description": "AWS Security Token Service endpoint. Required for cross-AWS region or cross-AWS account secrets.\n"
            }
        },
        "inputProperties": {
            "assumeRole": {
                "$ref": "#/types/mongodbatlas:index/ProviderAssumeRole:ProviderAssumeRole"
            },
            "awsAccessKeyId": {
                "type": "string",
                "description": "AWS API Access Key.\n"
            },
            "awsSecretAccessKey": {
                "type": "string",
                "description": "AWS API Access Secret Key.\n"
            },
            "awsSessionToken": {
                "type": "string",
                "description": "AWS Security Token Service provided session token.\n"
            },
            "baseUrl": {
                "type": "string",
                "description": "MongoDB Atlas Base URL\n"
            },
            "isMongodbgovCloud": {
                "type": "boolean",
                "description": "MongoDB Atlas Base URL default to gov\n"
            },
            "privateKey": {
                "type": "string",
                "description": "MongoDB Atlas Programmatic Private Key\n",
                "secret": true
            },
            "publicKey": {
                "type": "string",
                "description": "MongoDB Atlas Programmatic Public Key\n"
            },
            "realmBaseUrl": {
                "type": "string",
                "description": "MongoDB Realm Base URL\n"
            },
            "region": {
                "type": "string",
                "description": "Region where secret is stored as part of AWS Secret Manager.\n"
            },
            "secretName": {
                "type": "string",
                "description": "Name of secret stored in AWS Secret Manager.\n"
            },
            "stsEndpoint": {
                "type": "string",
                "description": "AWS Security Token Service endpoint. Required for cross-AWS region or cross-AWS account secrets.\n"
            }
        }
    },
    "resources": {
        "mongodbatlas:index/accessListApiKey:AccessListApiKey": {
            "description": "## Example Usage\n\n### Using CIDR Block\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.AccessListApiKey(\"test\", {\n    orgId: \"\u003cORG-ID\u003e\",\n    cidrBlock: \"1.2.3.4/32\",\n    apiKeyId: \"a29120e123cd\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.AccessListApiKey(\"test\",\n    org_id=\"\u003cORG-ID\u003e\",\n    cidr_block=\"1.2.3.4/32\",\n    api_key_id=\"a29120e123cd\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.AccessListApiKey(\"test\", new()\n    {\n        OrgId = \"\u003cORG-ID\u003e\",\n        CidrBlock = \"1.2.3.4/32\",\n        ApiKeyId = \"a29120e123cd\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewAccessListApiKey(ctx, \"test\", \u0026mongodbatlas.AccessListApiKeyArgs{\n\t\t\tOrgId:     pulumi.String(\"\u003cORG-ID\u003e\"),\n\t\t\tCidrBlock: pulumi.String(\"1.2.3.4/32\"),\n\t\t\tApiKeyId:  pulumi.String(\"a29120e123cd\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AccessListApiKey;\nimport com.pulumi.mongodbatlas.AccessListApiKeyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new AccessListApiKey(\"test\", AccessListApiKeyArgs.builder()\n            .orgId(\"\u003cORG-ID\u003e\")\n            .cidrBlock(\"1.2.3.4/32\")\n            .apiKeyId(\"a29120e123cd\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:AccessListApiKey\n    properties:\n      orgId: \u003cORG-ID\u003e\n      cidrBlock: 1.2.3.4/32\n      apiKeyId: a29120e123cd\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Using IP Address\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.AccessListApiKey(\"test\", {\n    orgId: \"\u003cORG-ID\u003e\",\n    ipAddress: \"2.3.4.5\",\n    apiKeyId: \"a29120e123cd\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.AccessListApiKey(\"test\",\n    org_id=\"\u003cORG-ID\u003e\",\n    ip_address=\"2.3.4.5\",\n    api_key_id=\"a29120e123cd\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.AccessListApiKey(\"test\", new()\n    {\n        OrgId = \"\u003cORG-ID\u003e\",\n        IpAddress = \"2.3.4.5\",\n        ApiKeyId = \"a29120e123cd\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewAccessListApiKey(ctx, \"test\", \u0026mongodbatlas.AccessListApiKeyArgs{\n\t\t\tOrgId:     pulumi.String(\"\u003cORG-ID\u003e\"),\n\t\t\tIpAddress: pulumi.String(\"2.3.4.5\"),\n\t\t\tApiKeyId:  pulumi.String(\"a29120e123cd\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AccessListApiKey;\nimport com.pulumi.mongodbatlas.AccessListApiKeyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new AccessListApiKey(\"test\", AccessListApiKeyArgs.builder()\n            .orgId(\"\u003cORG-ID\u003e\")\n            .ipAddress(\"2.3.4.5\")\n            .apiKeyId(\"a29120e123cd\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:AccessListApiKey\n    properties:\n      orgId: \u003cORG-ID\u003e\n      ipAddress: 2.3.4.5\n      apiKeyId: a29120e123cd\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nIP Access List entries can be imported using the `org_id` , `api_key_id` and `cidr_block` or `ip_address`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/accessListApiKey:AccessListApiKey test 5d0f1f74cf09a29120e123cd-a29120e123cd-10.242.88.0/21\n```\nFor more information see: [MongoDB Atlas API Reference.](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Programmatic-API-Keys/operation/createApiKeyAccessList)\n\n",
            "properties": {
                "apiKeyId": {
                    "type": "string",
                    "description": "Unique identifier for the Organization API Key for which you want to create a new access list entry.\n\n\u003e **NOTE:** One of the following attributes must set: `cidr_block`  or `ip_address` but not both.\n"
                },
                "cidrBlock": {
                    "type": "string",
                    "description": "Range of IP addresses in CIDR notation to be added to the access list. Your access list entry can include only one `cidrBlock`, or one `ipAddress`.\n"
                },
                "ipAddress": {
                    "type": "string",
                    "description": "Single IP address to be added to the access list.\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                }
            },
            "required": [
                "apiKeyId",
                "cidrBlock",
                "ipAddress",
                "orgId"
            ],
            "inputProperties": {
                "apiKeyId": {
                    "type": "string",
                    "description": "Unique identifier for the Organization API Key for which you want to create a new access list entry.\n\n\u003e **NOTE:** One of the following attributes must set: `cidr_block`  or `ip_address` but not both.\n"
                },
                "cidrBlock": {
                    "type": "string",
                    "description": "Range of IP addresses in CIDR notation to be added to the access list. Your access list entry can include only one `cidrBlock`, or one `ipAddress`.\n",
                    "willReplaceOnChanges": true
                },
                "ipAddress": {
                    "type": "string",
                    "description": "Single IP address to be added to the access list.\n",
                    "willReplaceOnChanges": true
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                }
            },
            "requiredInputs": [
                "apiKeyId",
                "orgId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AccessListApiKey resources.\n",
                "properties": {
                    "apiKeyId": {
                        "type": "string",
                        "description": "Unique identifier for the Organization API Key for which you want to create a new access list entry.\n\n\u003e **NOTE:** One of the following attributes must set: `cidr_block`  or `ip_address` but not both.\n"
                    },
                    "cidrBlock": {
                        "type": "string",
                        "description": "Range of IP addresses in CIDR notation to be added to the access list. Your access list entry can include only one `cidrBlock`, or one `ipAddress`.\n",
                        "willReplaceOnChanges": true
                    },
                    "ipAddress": {
                        "type": "string",
                        "description": "Single IP address to be added to the access list.\n",
                        "willReplaceOnChanges": true
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/advancedCluster:AdvancedCluster": {
            "description": "## # Resource: mongodbatlas.AdvancedCluster\n\n`mongodbatlas.AdvancedCluster` provides an Advanced Cluster resource. The resource lets you create, edit and delete advanced clusters. The resource requires your Project ID.\n\nMore information on considerations for using advanced clusters please see [Considerations](https://docs.atlas.mongodb.com/reference/api/cluster-advanced/create-one-cluster-advanced/#considerations)\n\n\u003e **IMPORTANT:**\n\u003cbr\u003e \u0026#8226; The primary difference between `mongodbatlas.Cluster` and `mongodbatlas.AdvancedCluster` is that `mongodbatlas.AdvancedCluster` supports multi-cloud clusters.  We recommend new users start with the `mongodbatlas.AdvancedCluster` resource.  \n\n\u003e **NOTE:** If Backup Compliance Policy is enabled for the project for which this backup schedule is defined, you cannot modify the backup schedule for an individual cluster below the minimum requirements set in the Backup Compliance Policy.  See [Backup Compliance Policy Prohibited Actions and Considerations](https://www.mongodb.com/docs/atlas/backup/cloud-backup/backup-compliance-policy/#configure-a-backup-compliance-policy).\n\n\n\u003cbr\u003e \u0026#8226; Upgrading the shared tier is supported. Any change from a shared tier cluster (a tenant) to a different instance size will be considered a tenant upgrade. When upgrading from the shared tier, change the `provider_name` from \"TENANT\" to your preferred provider (AWS, GCP or Azure) and remove the variable `backing_provider_name`.  See the Example Tenant Cluster Upgrade below.   Note you can upgrade a shared tier cluster only to a single provider on an M10-tier cluster or greater.  \n\u003cbr\u003e \u0026#8226; **IMPORTANT NOTE** When upgrading from the shared tier, *only* the upgrade changes will be applied. This helps avoid a corrupt state file in the event that the upgrade succeeds but subsequent updates fail within the same `pulumi up`. To apply additional cluster changes, run a secondary `pulumi up` after the upgrade succeeds.\n\u003e **NOTE:** Groups and projects are synonymous terms. You might find group_id in the official documentation.\n\n\u003e **NOTE:** A network container is created for each provider/region combination on the advanced cluster. This can be referenced via a computed attribute for use with other resources. Refer to the `replication_specs.#.container_id` attribute in the Attributes Reference for more information.\n\n\u003e **NOTE:** To enable Cluster Extended Storage Sizes use the `is_extended_storage_sizes_enabled` parameter in the mongodbatlas.Project resource.\n\n\u003e **NOTE:** The Low-CPU instance clusters are prefixed with `R`, for example `R40`. For complete list of Low-CPU instance clusters see Cluster Configuration Options under each Cloud Provider (https://www.mongodb.com/docs/atlas/reference/cloud-providers/).\n\n\n## Example Usage\n\n### Example single provider and single region\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.AdvancedCluster(\"test\", {\n    projectId: \"PROJECT ID\",\n    name: \"NAME OF CLUSTER\",\n    clusterType: \"REPLICASET\",\n    replicationSpecs: [{\n        regionConfigs: [{\n            electableSpecs: {\n                instanceSize: \"M10\",\n                nodeCount: 3,\n            },\n            analyticsSpecs: {\n                instanceSize: \"M10\",\n                nodeCount: 1,\n            },\n            providerName: \"AWS\",\n            priority: 7,\n            regionName: \"US_EAST_1\",\n        }],\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.AdvancedCluster(\"test\",\n    project_id=\"PROJECT ID\",\n    name=\"NAME OF CLUSTER\",\n    cluster_type=\"REPLICASET\",\n    replication_specs=[{\n        \"region_configs\": [{\n            \"electable_specs\": {\n                \"instance_size\": \"M10\",\n                \"node_count\": 3,\n            },\n            \"analytics_specs\": {\n                \"instance_size\": \"M10\",\n                \"node_count\": 1,\n            },\n            \"provider_name\": \"AWS\",\n            \"priority\": 7,\n            \"region_name\": \"US_EAST_1\",\n        }],\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.AdvancedCluster(\"test\", new()\n    {\n        ProjectId = \"PROJECT ID\",\n        Name = \"NAME OF CLUSTER\",\n        ClusterType = \"REPLICASET\",\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M10\",\n                            NodeCount = 3,\n                        },\n                        AnalyticsSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgs\n                        {\n                            InstanceSize = \"M10\",\n                            NodeCount = 1,\n                        },\n                        ProviderName = \"AWS\",\n                        Priority = 7,\n                        RegionName = \"US_EAST_1\",\n                    },\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewAdvancedCluster(ctx, \"test\", \u0026mongodbatlas.AdvancedClusterArgs{\n\t\t\tProjectId:   pulumi.String(\"PROJECT ID\"),\n\t\t\tName:        pulumi.String(\"NAME OF CLUSTER\"),\n\t\t\tClusterType: pulumi.String(\"REPLICASET\"),\n\t\t\tReplicationSpecs: mongodbatlas.AdvancedClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M10\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(3),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tAnalyticsSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M10\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(1),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tPriority:     pulumi.Int(7),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"US_EAST_1\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AdvancedCluster;\nimport com.pulumi.mongodbatlas.AdvancedClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.AdvancedClusterReplicationSpecArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new AdvancedCluster(\"test\", AdvancedClusterArgs.builder()\n            .projectId(\"PROJECT ID\")\n            .name(\"NAME OF CLUSTER\")\n            .clusterType(\"REPLICASET\")\n            .replicationSpecs(AdvancedClusterReplicationSpecArgs.builder()\n                .regionConfigs(AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                    .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                        .instanceSize(\"M10\")\n                        .nodeCount(3)\n                        .build())\n                    .analyticsSpecs(AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgs.builder()\n                        .instanceSize(\"M10\")\n                        .nodeCount(1)\n                        .build())\n                    .providerName(\"AWS\")\n                    .priority(7)\n                    .regionName(\"US_EAST_1\")\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:AdvancedCluster\n    properties:\n      projectId: PROJECT ID\n      name: NAME OF CLUSTER\n      clusterType: REPLICASET\n      replicationSpecs:\n        - regionConfigs:\n            - electableSpecs:\n                instanceSize: M10\n                nodeCount: 3\n              analyticsSpecs:\n                instanceSize: M10\n                nodeCount: 1\n              providerName: AWS\n              priority: 7\n              regionName: US_EAST_1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example Tenant Cluster\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.AdvancedCluster(\"test\", {\n    projectId: \"PROJECT ID\",\n    name: \"NAME OF CLUSTER\",\n    clusterType: \"REPLICASET\",\n    replicationSpecs: [{\n        regionConfigs: [{\n            electableSpecs: {\n                instanceSize: \"M5\",\n            },\n            providerName: \"TENANT\",\n            backingProviderName: \"AWS\",\n            regionName: \"US_EAST_1\",\n            priority: 7,\n        }],\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.AdvancedCluster(\"test\",\n    project_id=\"PROJECT ID\",\n    name=\"NAME OF CLUSTER\",\n    cluster_type=\"REPLICASET\",\n    replication_specs=[{\n        \"region_configs\": [{\n            \"electable_specs\": {\n                \"instance_size\": \"M5\",\n            },\n            \"provider_name\": \"TENANT\",\n            \"backing_provider_name\": \"AWS\",\n            \"region_name\": \"US_EAST_1\",\n            \"priority\": 7,\n        }],\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.AdvancedCluster(\"test\", new()\n    {\n        ProjectId = \"PROJECT ID\",\n        Name = \"NAME OF CLUSTER\",\n        ClusterType = \"REPLICASET\",\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M5\",\n                        },\n                        ProviderName = \"TENANT\",\n                        BackingProviderName = \"AWS\",\n                        RegionName = \"US_EAST_1\",\n                        Priority = 7,\n                    },\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewAdvancedCluster(ctx, \"test\", \u0026mongodbatlas.AdvancedClusterArgs{\n\t\t\tProjectId:   pulumi.String(\"PROJECT ID\"),\n\t\t\tName:        pulumi.String(\"NAME OF CLUSTER\"),\n\t\t\tClusterType: pulumi.String(\"REPLICASET\"),\n\t\t\tReplicationSpecs: mongodbatlas.AdvancedClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M5\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName:        pulumi.String(\"TENANT\"),\n\t\t\t\t\t\t\tBackingProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tRegionName:          pulumi.String(\"US_EAST_1\"),\n\t\t\t\t\t\t\tPriority:            pulumi.Int(7),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AdvancedCluster;\nimport com.pulumi.mongodbatlas.AdvancedClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.AdvancedClusterReplicationSpecArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new AdvancedCluster(\"test\", AdvancedClusterArgs.builder()\n            .projectId(\"PROJECT ID\")\n            .name(\"NAME OF CLUSTER\")\n            .clusterType(\"REPLICASET\")\n            .replicationSpecs(AdvancedClusterReplicationSpecArgs.builder()\n                .regionConfigs(AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                    .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                        .instanceSize(\"M5\")\n                        .build())\n                    .providerName(\"TENANT\")\n                    .backingProviderName(\"AWS\")\n                    .regionName(\"US_EAST_1\")\n                    .priority(7)\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:AdvancedCluster\n    properties:\n      projectId: PROJECT ID\n      name: NAME OF CLUSTER\n      clusterType: REPLICASET\n      replicationSpecs:\n        - regionConfigs:\n            - electableSpecs:\n                instanceSize: M5\n              providerName: TENANT\n              backingProviderName: AWS\n              regionName: US_EAST_1\n              priority: 7\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example Tenant Cluster Upgrade\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.AdvancedCluster(\"test\", {\n    projectId: \"PROJECT ID\",\n    name: \"NAME OF CLUSTER\",\n    clusterType: \"REPLICASET\",\n    replicationSpecs: [{\n        regionConfigs: [{\n            electableSpecs: {\n                instanceSize: \"M10\",\n            },\n            providerName: \"AWS\",\n            regionName: \"US_EAST_1\",\n            priority: 7,\n        }],\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.AdvancedCluster(\"test\",\n    project_id=\"PROJECT ID\",\n    name=\"NAME OF CLUSTER\",\n    cluster_type=\"REPLICASET\",\n    replication_specs=[{\n        \"region_configs\": [{\n            \"electable_specs\": {\n                \"instance_size\": \"M10\",\n            },\n            \"provider_name\": \"AWS\",\n            \"region_name\": \"US_EAST_1\",\n            \"priority\": 7,\n        }],\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.AdvancedCluster(\"test\", new()\n    {\n        ProjectId = \"PROJECT ID\",\n        Name = \"NAME OF CLUSTER\",\n        ClusterType = \"REPLICASET\",\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M10\",\n                        },\n                        ProviderName = \"AWS\",\n                        RegionName = \"US_EAST_1\",\n                        Priority = 7,\n                    },\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewAdvancedCluster(ctx, \"test\", \u0026mongodbatlas.AdvancedClusterArgs{\n\t\t\tProjectId:   pulumi.String(\"PROJECT ID\"),\n\t\t\tName:        pulumi.String(\"NAME OF CLUSTER\"),\n\t\t\tClusterType: pulumi.String(\"REPLICASET\"),\n\t\t\tReplicationSpecs: mongodbatlas.AdvancedClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M10\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"US_EAST_1\"),\n\t\t\t\t\t\t\tPriority:     pulumi.Int(7),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AdvancedCluster;\nimport com.pulumi.mongodbatlas.AdvancedClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.AdvancedClusterReplicationSpecArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new AdvancedCluster(\"test\", AdvancedClusterArgs.builder()\n            .projectId(\"PROJECT ID\")\n            .name(\"NAME OF CLUSTER\")\n            .clusterType(\"REPLICASET\")\n            .replicationSpecs(AdvancedClusterReplicationSpecArgs.builder()\n                .regionConfigs(AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                    .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                        .instanceSize(\"M10\")\n                        .build())\n                    .providerName(\"AWS\")\n                    .regionName(\"US_EAST_1\")\n                    .priority(7)\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:AdvancedCluster\n    properties:\n      projectId: PROJECT ID\n      name: NAME OF CLUSTER\n      clusterType: REPLICASET\n      replicationSpecs:\n        - regionConfigs:\n            - electableSpecs:\n                instanceSize: M10\n              providerName: AWS\n              regionName: US_EAST_1\n              priority: 7\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example Multi-Cloud Cluster\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.AdvancedCluster(\"test\", {\n    projectId: \"PROJECT ID\",\n    name: \"NAME OF CLUSTER\",\n    clusterType: \"REPLICASET\",\n    replicationSpecs: [{\n        regionConfigs: [\n            {\n                electableSpecs: {\n                    instanceSize: \"M10\",\n                    nodeCount: 3,\n                },\n                analyticsSpecs: {\n                    instanceSize: \"M10\",\n                    nodeCount: 1,\n                },\n                providerName: \"AWS\",\n                priority: 7,\n                regionName: \"US_EAST_1\",\n            },\n            {\n                electableSpecs: {\n                    instanceSize: \"M10\",\n                    nodeCount: 2,\n                },\n                providerName: \"GCP\",\n                priority: 6,\n                regionName: \"NORTH_AMERICA_NORTHEAST_1\",\n            },\n        ],\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.AdvancedCluster(\"test\",\n    project_id=\"PROJECT ID\",\n    name=\"NAME OF CLUSTER\",\n    cluster_type=\"REPLICASET\",\n    replication_specs=[{\n        \"region_configs\": [\n            {\n                \"electable_specs\": {\n                    \"instance_size\": \"M10\",\n                    \"node_count\": 3,\n                },\n                \"analytics_specs\": {\n                    \"instance_size\": \"M10\",\n                    \"node_count\": 1,\n                },\n                \"provider_name\": \"AWS\",\n                \"priority\": 7,\n                \"region_name\": \"US_EAST_1\",\n            },\n            {\n                \"electable_specs\": {\n                    \"instance_size\": \"M10\",\n                    \"node_count\": 2,\n                },\n                \"provider_name\": \"GCP\",\n                \"priority\": 6,\n                \"region_name\": \"NORTH_AMERICA_NORTHEAST_1\",\n            },\n        ],\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.AdvancedCluster(\"test\", new()\n    {\n        ProjectId = \"PROJECT ID\",\n        Name = \"NAME OF CLUSTER\",\n        ClusterType = \"REPLICASET\",\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M10\",\n                            NodeCount = 3,\n                        },\n                        AnalyticsSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgs\n                        {\n                            InstanceSize = \"M10\",\n                            NodeCount = 1,\n                        },\n                        ProviderName = \"AWS\",\n                        Priority = 7,\n                        RegionName = \"US_EAST_1\",\n                    },\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M10\",\n                            NodeCount = 2,\n                        },\n                        ProviderName = \"GCP\",\n                        Priority = 6,\n                        RegionName = \"NORTH_AMERICA_NORTHEAST_1\",\n                    },\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewAdvancedCluster(ctx, \"test\", \u0026mongodbatlas.AdvancedClusterArgs{\n\t\t\tProjectId:   pulumi.String(\"PROJECT ID\"),\n\t\t\tName:        pulumi.String(\"NAME OF CLUSTER\"),\n\t\t\tClusterType: pulumi.String(\"REPLICASET\"),\n\t\t\tReplicationSpecs: mongodbatlas.AdvancedClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M10\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(3),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tAnalyticsSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M10\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(1),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tPriority:     pulumi.Int(7),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"US_EAST_1\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M10\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(2),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"GCP\"),\n\t\t\t\t\t\t\tPriority:     pulumi.Int(6),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"NORTH_AMERICA_NORTHEAST_1\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AdvancedCluster;\nimport com.pulumi.mongodbatlas.AdvancedClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.AdvancedClusterReplicationSpecArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new AdvancedCluster(\"test\", AdvancedClusterArgs.builder()\n            .projectId(\"PROJECT ID\")\n            .name(\"NAME OF CLUSTER\")\n            .clusterType(\"REPLICASET\")\n            .replicationSpecs(AdvancedClusterReplicationSpecArgs.builder()\n                .regionConfigs(                \n                    AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                        .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                            .instanceSize(\"M10\")\n                            .nodeCount(3)\n                            .build())\n                        .analyticsSpecs(AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgs.builder()\n                            .instanceSize(\"M10\")\n                            .nodeCount(1)\n                            .build())\n                        .providerName(\"AWS\")\n                        .priority(7)\n                        .regionName(\"US_EAST_1\")\n                        .build(),\n                    AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                        .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                            .instanceSize(\"M10\")\n                            .nodeCount(2)\n                            .build())\n                        .providerName(\"GCP\")\n                        .priority(6)\n                        .regionName(\"NORTH_AMERICA_NORTHEAST_1\")\n                        .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:AdvancedCluster\n    properties:\n      projectId: PROJECT ID\n      name: NAME OF CLUSTER\n      clusterType: REPLICASET\n      replicationSpecs:\n        - regionConfigs:\n            - electableSpecs:\n                instanceSize: M10\n                nodeCount: 3\n              analyticsSpecs:\n                instanceSize: M10\n                nodeCount: 1\n              providerName: AWS\n              priority: 7\n              regionName: US_EAST_1\n            - electableSpecs:\n                instanceSize: M10\n                nodeCount: 2\n              providerName: GCP\n              priority: 6\n              regionName: NORTH_AMERICA_NORTHEAST_1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n### Example of a Multi Cloud Sharded Cluster with 2 shards\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst cluster = new mongodbatlas.AdvancedCluster(\"cluster\", {\n    projectId: project.id,\n    name: clusterName,\n    clusterType: \"SHARDED\",\n    backupEnabled: true,\n    replicationSpecs: [\n        {\n            regionConfigs: [\n                {\n                    electableSpecs: {\n                        instanceSize: \"M10\",\n                        nodeCount: 3,\n                    },\n                    providerName: \"AWS\",\n                    priority: 7,\n                    regionName: \"US_EAST_1\",\n                },\n                {\n                    electableSpecs: {\n                        instanceSize: \"M10\",\n                        nodeCount: 2,\n                    },\n                    providerName: \"AZURE\",\n                    priority: 6,\n                    regionName: \"US_EAST_2\",\n                },\n            ],\n        },\n        {\n            regionConfigs: [\n                {\n                    electableSpecs: {\n                        instanceSize: \"M10\",\n                        nodeCount: 3,\n                    },\n                    providerName: \"AWS\",\n                    priority: 7,\n                    regionName: \"US_EAST_1\",\n                },\n                {\n                    electableSpecs: {\n                        instanceSize: \"M10\",\n                        nodeCount: 2,\n                    },\n                    providerName: \"AZURE\",\n                    priority: 6,\n                    regionName: \"US_EAST_2\",\n                },\n            ],\n        },\n    ],\n    advancedConfiguration: {\n        javascriptEnabled: true,\n        oplogSizeMb: 991,\n        sampleRefreshIntervalBiConnector: 300,\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ncluster = mongodbatlas.AdvancedCluster(\"cluster\",\n    project_id=project[\"id\"],\n    name=cluster_name,\n    cluster_type=\"SHARDED\",\n    backup_enabled=True,\n    replication_specs=[\n        {\n            \"region_configs\": [\n                {\n                    \"electable_specs\": {\n                        \"instance_size\": \"M10\",\n                        \"node_count\": 3,\n                    },\n                    \"provider_name\": \"AWS\",\n                    \"priority\": 7,\n                    \"region_name\": \"US_EAST_1\",\n                },\n                {\n                    \"electable_specs\": {\n                        \"instance_size\": \"M10\",\n                        \"node_count\": 2,\n                    },\n                    \"provider_name\": \"AZURE\",\n                    \"priority\": 6,\n                    \"region_name\": \"US_EAST_2\",\n                },\n            ],\n        },\n        {\n            \"region_configs\": [\n                {\n                    \"electable_specs\": {\n                        \"instance_size\": \"M10\",\n                        \"node_count\": 3,\n                    },\n                    \"provider_name\": \"AWS\",\n                    \"priority\": 7,\n                    \"region_name\": \"US_EAST_1\",\n                },\n                {\n                    \"electable_specs\": {\n                        \"instance_size\": \"M10\",\n                        \"node_count\": 2,\n                    },\n                    \"provider_name\": \"AZURE\",\n                    \"priority\": 6,\n                    \"region_name\": \"US_EAST_2\",\n                },\n            ],\n        },\n    ],\n    advanced_configuration={\n        \"javascript_enabled\": True,\n        \"oplog_size_mb\": 991,\n        \"sample_refresh_interval_bi_connector\": 300,\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var cluster = new Mongodbatlas.AdvancedCluster(\"cluster\", new()\n    {\n        ProjectId = project.Id,\n        Name = clusterName,\n        ClusterType = \"SHARDED\",\n        BackupEnabled = true,\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M10\",\n                            NodeCount = 3,\n                        },\n                        ProviderName = \"AWS\",\n                        Priority = 7,\n                        RegionName = \"US_EAST_1\",\n                    },\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M10\",\n                            NodeCount = 2,\n                        },\n                        ProviderName = \"AZURE\",\n                        Priority = 6,\n                        RegionName = \"US_EAST_2\",\n                    },\n                },\n            },\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M10\",\n                            NodeCount = 3,\n                        },\n                        ProviderName = \"AWS\",\n                        Priority = 7,\n                        RegionName = \"US_EAST_1\",\n                    },\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M10\",\n                            NodeCount = 2,\n                        },\n                        ProviderName = \"AZURE\",\n                        Priority = 6,\n                        RegionName = \"US_EAST_2\",\n                    },\n                },\n            },\n        },\n        AdvancedConfiguration = new Mongodbatlas.Inputs.AdvancedClusterAdvancedConfigurationArgs\n        {\n            JavascriptEnabled = true,\n            OplogSizeMb = 991,\n            SampleRefreshIntervalBiConnector = 300,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewAdvancedCluster(ctx, \"cluster\", \u0026mongodbatlas.AdvancedClusterArgs{\n\t\t\tProjectId:     pulumi.Any(project.Id),\n\t\t\tName:          pulumi.Any(clusterName),\n\t\t\tClusterType:   pulumi.String(\"SHARDED\"),\n\t\t\tBackupEnabled: pulumi.Bool(true),\n\t\t\tReplicationSpecs: mongodbatlas.AdvancedClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M10\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(3),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tPriority:     pulumi.Int(7),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"US_EAST_1\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M10\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(2),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AZURE\"),\n\t\t\t\t\t\t\tPriority:     pulumi.Int(6),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"US_EAST_2\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M10\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(3),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tPriority:     pulumi.Int(7),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"US_EAST_1\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M10\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(2),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AZURE\"),\n\t\t\t\t\t\t\tPriority:     pulumi.Int(6),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"US_EAST_2\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tAdvancedConfiguration: \u0026mongodbatlas.AdvancedClusterAdvancedConfigurationArgs{\n\t\t\t\tJavascriptEnabled:                pulumi.Bool(true),\n\t\t\t\tOplogSizeMb:                      pulumi.Int(991),\n\t\t\t\tSampleRefreshIntervalBiConnector: pulumi.Int(300),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AdvancedCluster;\nimport com.pulumi.mongodbatlas.AdvancedClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.AdvancedClusterReplicationSpecArgs;\nimport com.pulumi.mongodbatlas.inputs.AdvancedClusterAdvancedConfigurationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var cluster = new AdvancedCluster(\"cluster\", AdvancedClusterArgs.builder()\n            .projectId(project.id())\n            .name(clusterName)\n            .clusterType(\"SHARDED\")\n            .backupEnabled(true)\n            .replicationSpecs(            \n                AdvancedClusterReplicationSpecArgs.builder()\n                    .regionConfigs(                    \n                        AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                            .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                                .instanceSize(\"M10\")\n                                .nodeCount(3)\n                                .build())\n                            .providerName(\"AWS\")\n                            .priority(7)\n                            .regionName(\"US_EAST_1\")\n                            .build(),\n                        AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                            .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                                .instanceSize(\"M10\")\n                                .nodeCount(2)\n                                .build())\n                            .providerName(\"AZURE\")\n                            .priority(6)\n                            .regionName(\"US_EAST_2\")\n                            .build())\n                    .build(),\n                AdvancedClusterReplicationSpecArgs.builder()\n                    .regionConfigs(                    \n                        AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                            .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                                .instanceSize(\"M10\")\n                                .nodeCount(3)\n                                .build())\n                            .providerName(\"AWS\")\n                            .priority(7)\n                            .regionName(\"US_EAST_1\")\n                            .build(),\n                        AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                            .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                                .instanceSize(\"M10\")\n                                .nodeCount(2)\n                                .build())\n                            .providerName(\"AZURE\")\n                            .priority(6)\n                            .regionName(\"US_EAST_2\")\n                            .build())\n                    .build())\n            .advancedConfiguration(AdvancedClusterAdvancedConfigurationArgs.builder()\n                .javascriptEnabled(true)\n                .oplogSizeMb(991)\n                .sampleRefreshIntervalBiConnector(300)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  cluster:\n    type: mongodbatlas:AdvancedCluster\n    properties:\n      projectId: ${project.id}\n      name: ${clusterName}\n      clusterType: SHARDED\n      backupEnabled: true\n      replicationSpecs:\n        - regionConfigs:\n            - electableSpecs:\n                instanceSize: M10\n                nodeCount: 3\n              providerName: AWS\n              priority: 7\n              regionName: US_EAST_1\n            - electableSpecs:\n                instanceSize: M10\n                nodeCount: 2\n              providerName: AZURE\n              priority: 6\n              regionName: US_EAST_2\n        - regionConfigs:\n            - electableSpecs:\n                instanceSize: M10\n                nodeCount: 3\n              providerName: AWS\n              priority: 7\n              regionName: US_EAST_1\n            - electableSpecs:\n                instanceSize: M10\n                nodeCount: 2\n              providerName: AZURE\n              priority: 6\n              regionName: US_EAST_2\n      advancedConfiguration:\n        javascriptEnabled: true\n        oplogSizeMb: 991\n        sampleRefreshIntervalBiConnector: 300\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example of a Global Cluster with 2 zones\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst cluster = new mongodbatlas.AdvancedCluster(\"cluster\", {\n    projectId: project.id,\n    name: clusterName,\n    clusterType: \"GEOSHARDED\",\n    backupEnabled: true,\n    replicationSpecs: [\n        {\n            zoneName: \"zone n1\",\n            regionConfigs: [\n                {\n                    electableSpecs: {\n                        instanceSize: \"M10\",\n                        nodeCount: 3,\n                    },\n                    providerName: \"AWS\",\n                    priority: 7,\n                    regionName: \"US_EAST_1\",\n                },\n                {\n                    electableSpecs: {\n                        instanceSize: \"M10\",\n                        nodeCount: 2,\n                    },\n                    providerName: \"AZURE\",\n                    priority: 6,\n                    regionName: \"US_EAST_2\",\n                },\n            ],\n        },\n        {\n            zoneName: \"zone n1\",\n            regionConfigs: [\n                {\n                    electableSpecs: {\n                        instanceSize: \"M10\",\n                        nodeCount: 3,\n                    },\n                    providerName: \"AWS\",\n                    priority: 7,\n                    regionName: \"US_EAST_1\",\n                },\n                {\n                    electableSpecs: {\n                        instanceSize: \"M10\",\n                        nodeCount: 2,\n                    },\n                    providerName: \"AZURE\",\n                    priority: 6,\n                    regionName: \"US_EAST_2\",\n                },\n            ],\n        },\n        {\n            zoneName: \"zone n2\",\n            regionConfigs: [\n                {\n                    electableSpecs: {\n                        instanceSize: \"M10\",\n                        nodeCount: 3,\n                    },\n                    providerName: \"AWS\",\n                    priority: 7,\n                    regionName: \"EU_WEST_1\",\n                },\n                {\n                    electableSpecs: {\n                        instanceSize: \"M10\",\n                        nodeCount: 2,\n                    },\n                    providerName: \"AZURE\",\n                    priority: 6,\n                    regionName: \"EUROPE_NORTH\",\n                },\n            ],\n        },\n        {\n            zoneName: \"zone n2\",\n            regionConfigs: [\n                {\n                    electableSpecs: {\n                        instanceSize: \"M10\",\n                        nodeCount: 3,\n                    },\n                    providerName: \"AWS\",\n                    priority: 7,\n                    regionName: \"EU_WEST_1\",\n                },\n                {\n                    electableSpecs: {\n                        instanceSize: \"M10\",\n                        nodeCount: 2,\n                    },\n                    providerName: \"AZURE\",\n                    priority: 6,\n                    regionName: \"EUROPE_NORTH\",\n                },\n            ],\n        },\n    ],\n    advancedConfiguration: {\n        javascriptEnabled: true,\n        oplogSizeMb: 999,\n        sampleRefreshIntervalBiConnector: 300,\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ncluster = mongodbatlas.AdvancedCluster(\"cluster\",\n    project_id=project[\"id\"],\n    name=cluster_name,\n    cluster_type=\"GEOSHARDED\",\n    backup_enabled=True,\n    replication_specs=[\n        {\n            \"zone_name\": \"zone n1\",\n            \"region_configs\": [\n                {\n                    \"electable_specs\": {\n                        \"instance_size\": \"M10\",\n                        \"node_count\": 3,\n                    },\n                    \"provider_name\": \"AWS\",\n                    \"priority\": 7,\n                    \"region_name\": \"US_EAST_1\",\n                },\n                {\n                    \"electable_specs\": {\n                        \"instance_size\": \"M10\",\n                        \"node_count\": 2,\n                    },\n                    \"provider_name\": \"AZURE\",\n                    \"priority\": 6,\n                    \"region_name\": \"US_EAST_2\",\n                },\n            ],\n        },\n        {\n            \"zone_name\": \"zone n1\",\n            \"region_configs\": [\n                {\n                    \"electable_specs\": {\n                        \"instance_size\": \"M10\",\n                        \"node_count\": 3,\n                    },\n                    \"provider_name\": \"AWS\",\n                    \"priority\": 7,\n                    \"region_name\": \"US_EAST_1\",\n                },\n                {\n                    \"electable_specs\": {\n                        \"instance_size\": \"M10\",\n                        \"node_count\": 2,\n                    },\n                    \"provider_name\": \"AZURE\",\n                    \"priority\": 6,\n                    \"region_name\": \"US_EAST_2\",\n                },\n            ],\n        },\n        {\n            \"zone_name\": \"zone n2\",\n            \"region_configs\": [\n                {\n                    \"electable_specs\": {\n                        \"instance_size\": \"M10\",\n                        \"node_count\": 3,\n                    },\n                    \"provider_name\": \"AWS\",\n                    \"priority\": 7,\n                    \"region_name\": \"EU_WEST_1\",\n                },\n                {\n                    \"electable_specs\": {\n                        \"instance_size\": \"M10\",\n                        \"node_count\": 2,\n                    },\n                    \"provider_name\": \"AZURE\",\n                    \"priority\": 6,\n                    \"region_name\": \"EUROPE_NORTH\",\n                },\n            ],\n        },\n        {\n            \"zone_name\": \"zone n2\",\n            \"region_configs\": [\n                {\n                    \"electable_specs\": {\n                        \"instance_size\": \"M10\",\n                        \"node_count\": 3,\n                    },\n                    \"provider_name\": \"AWS\",\n                    \"priority\": 7,\n                    \"region_name\": \"EU_WEST_1\",\n                },\n                {\n                    \"electable_specs\": {\n                        \"instance_size\": \"M10\",\n                        \"node_count\": 2,\n                    },\n                    \"provider_name\": \"AZURE\",\n                    \"priority\": 6,\n                    \"region_name\": \"EUROPE_NORTH\",\n                },\n            ],\n        },\n    ],\n    advanced_configuration={\n        \"javascript_enabled\": True,\n        \"oplog_size_mb\": 999,\n        \"sample_refresh_interval_bi_connector\": 300,\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var cluster = new Mongodbatlas.AdvancedCluster(\"cluster\", new()\n    {\n        ProjectId = project.Id,\n        Name = clusterName,\n        ClusterType = \"GEOSHARDED\",\n        BackupEnabled = true,\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                ZoneName = \"zone n1\",\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M10\",\n                            NodeCount = 3,\n                        },\n                        ProviderName = \"AWS\",\n                        Priority = 7,\n                        RegionName = \"US_EAST_1\",\n                    },\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M10\",\n                            NodeCount = 2,\n                        },\n                        ProviderName = \"AZURE\",\n                        Priority = 6,\n                        RegionName = \"US_EAST_2\",\n                    },\n                },\n            },\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                ZoneName = \"zone n1\",\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M10\",\n                            NodeCount = 3,\n                        },\n                        ProviderName = \"AWS\",\n                        Priority = 7,\n                        RegionName = \"US_EAST_1\",\n                    },\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M10\",\n                            NodeCount = 2,\n                        },\n                        ProviderName = \"AZURE\",\n                        Priority = 6,\n                        RegionName = \"US_EAST_2\",\n                    },\n                },\n            },\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                ZoneName = \"zone n2\",\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M10\",\n                            NodeCount = 3,\n                        },\n                        ProviderName = \"AWS\",\n                        Priority = 7,\n                        RegionName = \"EU_WEST_1\",\n                    },\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M10\",\n                            NodeCount = 2,\n                        },\n                        ProviderName = \"AZURE\",\n                        Priority = 6,\n                        RegionName = \"EUROPE_NORTH\",\n                    },\n                },\n            },\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                ZoneName = \"zone n2\",\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M10\",\n                            NodeCount = 3,\n                        },\n                        ProviderName = \"AWS\",\n                        Priority = 7,\n                        RegionName = \"EU_WEST_1\",\n                    },\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M10\",\n                            NodeCount = 2,\n                        },\n                        ProviderName = \"AZURE\",\n                        Priority = 6,\n                        RegionName = \"EUROPE_NORTH\",\n                    },\n                },\n            },\n        },\n        AdvancedConfiguration = new Mongodbatlas.Inputs.AdvancedClusterAdvancedConfigurationArgs\n        {\n            JavascriptEnabled = true,\n            OplogSizeMb = 999,\n            SampleRefreshIntervalBiConnector = 300,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewAdvancedCluster(ctx, \"cluster\", \u0026mongodbatlas.AdvancedClusterArgs{\n\t\t\tProjectId:     pulumi.Any(project.Id),\n\t\t\tName:          pulumi.Any(clusterName),\n\t\t\tClusterType:   pulumi.String(\"GEOSHARDED\"),\n\t\t\tBackupEnabled: pulumi.Bool(true),\n\t\t\tReplicationSpecs: mongodbatlas.AdvancedClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tZoneName: pulumi.String(\"zone n1\"),\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M10\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(3),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tPriority:     pulumi.Int(7),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"US_EAST_1\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M10\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(2),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AZURE\"),\n\t\t\t\t\t\t\tPriority:     pulumi.Int(6),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"US_EAST_2\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tZoneName: pulumi.String(\"zone n1\"),\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M10\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(3),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tPriority:     pulumi.Int(7),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"US_EAST_1\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M10\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(2),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AZURE\"),\n\t\t\t\t\t\t\tPriority:     pulumi.Int(6),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"US_EAST_2\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tZoneName: pulumi.String(\"zone n2\"),\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M10\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(3),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tPriority:     pulumi.Int(7),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"EU_WEST_1\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M10\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(2),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AZURE\"),\n\t\t\t\t\t\t\tPriority:     pulumi.Int(6),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"EUROPE_NORTH\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tZoneName: pulumi.String(\"zone n2\"),\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M10\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(3),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tPriority:     pulumi.Int(7),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"EU_WEST_1\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M10\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(2),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AZURE\"),\n\t\t\t\t\t\t\tPriority:     pulumi.Int(6),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"EUROPE_NORTH\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tAdvancedConfiguration: \u0026mongodbatlas.AdvancedClusterAdvancedConfigurationArgs{\n\t\t\t\tJavascriptEnabled:                pulumi.Bool(true),\n\t\t\t\tOplogSizeMb:                      pulumi.Int(999),\n\t\t\t\tSampleRefreshIntervalBiConnector: pulumi.Int(300),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AdvancedCluster;\nimport com.pulumi.mongodbatlas.AdvancedClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.AdvancedClusterReplicationSpecArgs;\nimport com.pulumi.mongodbatlas.inputs.AdvancedClusterAdvancedConfigurationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var cluster = new AdvancedCluster(\"cluster\", AdvancedClusterArgs.builder()\n            .projectId(project.id())\n            .name(clusterName)\n            .clusterType(\"GEOSHARDED\")\n            .backupEnabled(true)\n            .replicationSpecs(            \n                AdvancedClusterReplicationSpecArgs.builder()\n                    .zoneName(\"zone n1\")\n                    .regionConfigs(                    \n                        AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                            .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                                .instanceSize(\"M10\")\n                                .nodeCount(3)\n                                .build())\n                            .providerName(\"AWS\")\n                            .priority(7)\n                            .regionName(\"US_EAST_1\")\n                            .build(),\n                        AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                            .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                                .instanceSize(\"M10\")\n                                .nodeCount(2)\n                                .build())\n                            .providerName(\"AZURE\")\n                            .priority(6)\n                            .regionName(\"US_EAST_2\")\n                            .build())\n                    .build(),\n                AdvancedClusterReplicationSpecArgs.builder()\n                    .zoneName(\"zone n1\")\n                    .regionConfigs(                    \n                        AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                            .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                                .instanceSize(\"M10\")\n                                .nodeCount(3)\n                                .build())\n                            .providerName(\"AWS\")\n                            .priority(7)\n                            .regionName(\"US_EAST_1\")\n                            .build(),\n                        AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                            .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                                .instanceSize(\"M10\")\n                                .nodeCount(2)\n                                .build())\n                            .providerName(\"AZURE\")\n                            .priority(6)\n                            .regionName(\"US_EAST_2\")\n                            .build())\n                    .build(),\n                AdvancedClusterReplicationSpecArgs.builder()\n                    .zoneName(\"zone n2\")\n                    .regionConfigs(                    \n                        AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                            .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                                .instanceSize(\"M10\")\n                                .nodeCount(3)\n                                .build())\n                            .providerName(\"AWS\")\n                            .priority(7)\n                            .regionName(\"EU_WEST_1\")\n                            .build(),\n                        AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                            .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                                .instanceSize(\"M10\")\n                                .nodeCount(2)\n                                .build())\n                            .providerName(\"AZURE\")\n                            .priority(6)\n                            .regionName(\"EUROPE_NORTH\")\n                            .build())\n                    .build(),\n                AdvancedClusterReplicationSpecArgs.builder()\n                    .zoneName(\"zone n2\")\n                    .regionConfigs(                    \n                        AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                            .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                                .instanceSize(\"M10\")\n                                .nodeCount(3)\n                                .build())\n                            .providerName(\"AWS\")\n                            .priority(7)\n                            .regionName(\"EU_WEST_1\")\n                            .build(),\n                        AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                            .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                                .instanceSize(\"M10\")\n                                .nodeCount(2)\n                                .build())\n                            .providerName(\"AZURE\")\n                            .priority(6)\n                            .regionName(\"EUROPE_NORTH\")\n                            .build())\n                    .build())\n            .advancedConfiguration(AdvancedClusterAdvancedConfigurationArgs.builder()\n                .javascriptEnabled(true)\n                .oplogSizeMb(999)\n                .sampleRefreshIntervalBiConnector(300)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  cluster:\n    type: mongodbatlas:AdvancedCluster\n    properties:\n      projectId: ${project.id}\n      name: ${clusterName}\n      clusterType: GEOSHARDED\n      backupEnabled: true\n      replicationSpecs:\n        - zoneName: zone n1\n          regionConfigs:\n            - electableSpecs:\n                instanceSize: M10\n                nodeCount: 3\n              providerName: AWS\n              priority: 7\n              regionName: US_EAST_1\n            - electableSpecs:\n                instanceSize: M10\n                nodeCount: 2\n              providerName: AZURE\n              priority: 6\n              regionName: US_EAST_2\n        - zoneName: zone n1\n          regionConfigs:\n            - electableSpecs:\n                instanceSize: M10\n                nodeCount: 3\n              providerName: AWS\n              priority: 7\n              regionName: US_EAST_1\n            - electableSpecs:\n                instanceSize: M10\n                nodeCount: 2\n              providerName: AZURE\n              priority: 6\n              regionName: US_EAST_2\n        - zoneName: zone n2\n          regionConfigs:\n            - electableSpecs:\n                instanceSize: M10\n                nodeCount: 3\n              providerName: AWS\n              priority: 7\n              regionName: EU_WEST_1\n            - electableSpecs:\n                instanceSize: M10\n                nodeCount: 2\n              providerName: AZURE\n              priority: 6\n              regionName: EUROPE_NORTH\n        - zoneName: zone n2\n          regionConfigs:\n            - electableSpecs:\n                instanceSize: M10\n                nodeCount: 3\n              providerName: AWS\n              priority: 7\n              regionName: EU_WEST_1\n            - electableSpecs:\n                instanceSize: M10\n                nodeCount: 2\n              providerName: AZURE\n              priority: 6\n              regionName: EUROPE_NORTH\n      advancedConfiguration:\n        javascriptEnabled: true\n        oplogSizeMb: 999\n        sampleRefreshIntervalBiConnector: 300\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### Example - Return a Connection String\nStandard\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n\nexport const standard = cluster.connectionStrings[0].standard;\n```\n```python\nimport pulumi\n\npulumi.export(\"standard\", cluster[\"connectionStrings\"][0][\"standard\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"standard\"] = cluster.ConnectionStrings[0].Standard,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tctx.Export(\"standard\", cluster.ConnectionStrings[0].Standard)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        ctx.export(\"standard\", cluster.connectionStrings()[0].standard());\n    }\n}\n```\n```yaml\noutputs:\n  standard: ${cluster.connectionStrings[0].standard}\n```\n\u003c!--End PulumiCodeChooser --\u003e\nStandard srv\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n\nexport const standardSrv = cluster.connectionStrings[0].standardSrv;\n```\n```python\nimport pulumi\n\npulumi.export(\"standardSrv\", cluster[\"connectionStrings\"][0][\"standardSrv\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"standardSrv\"] = cluster.ConnectionStrings[0].StandardSrv,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tctx.Export(\"standardSrv\", cluster.ConnectionStrings[0].StandardSrv)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        ctx.export(\"standardSrv\", cluster.connectionStrings()[0].standardSrv());\n    }\n}\n```\n```yaml\noutputs:\n  standardSrv: ${cluster.connectionStrings[0].standardSrv}\n```\n\u003c!--End PulumiCodeChooser --\u003e\nPrivate with Network peering and Custom DNS AWS enabled\n## Import\n\nClusters can be imported using project ID and cluster name, in the format `PROJECTID-CLUSTERNAME`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/advancedCluster:AdvancedCluster my_cluster 1112222b3bf99403840e8934-Cluster0\n```\nSee detailed information for arguments and attributes: [MongoDB API Advanced Clusters](https://docs.atlas.mongodb.com/reference/api/cluster-advanced/create-one-cluster-advanced/)\n\n~\u003e __IMPORTANT:__\n\\n\\n \u0026#8226; When a cluster is imported, the resulting schema structure will always return the new schema including `replication_specs` per independent shards of the cluster.\n\\n\\n \u0026#8226;  Note: The first time `pulumi up` command is run __after__ updating the configuration of an imported cluster, you may receive a `500 Internal Server Error (Error code: \"SERVICE_UNAVAILABLE\")` error. This is a known temporary issue. If you encounter this, please re-run `pulumi up` and this time the update should succeed.\n\n",
            "properties": {
                "acceptDataRisksAndForceReplicaSetReconfig": {
                    "type": "string",
                    "description": "If reconfiguration is necessary to regain a primary due to a regional outage, submit this field alongside your topology reconfiguration to request a new regional outage resistant topology. Forced reconfigurations during an outage of the majority of electable nodes carry a risk of data loss if replicated writes (even majority committed writes) have not been replicated to the new primary node. MongoDB Atlas docs contain more information. To proceed with an operation which carries that risk, set `accept_data_risks_and_force_replica_set_reconfig` to the current date. Learn more about Reconfiguring a Replica Set during a regional outage [here](https://dochub.mongodb.org/core/regional-outage-reconfigure-replica-set).\n"
                },
                "advancedConfiguration": {
                    "$ref": "#/types/mongodbatlas:index/AdvancedClusterAdvancedConfiguration:AdvancedClusterAdvancedConfiguration"
                },
                "backupEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the cluster can perform backups.\nIf `true`, the cluster can perform backups. You must set this value to `true` for NVMe clusters.\n\nBackup uses:\n[Cloud Backups](https://docs.atlas.mongodb.com/backup/cloud-backup/overview/#std-label-backup-cloud-provider) for dedicated clusters.\n[Shared Cluster Backups](https://docs.atlas.mongodb.com/backup/shared-tier/overview/#std-label-m2-m5-snapshots) for tenant clusters.\nIf \"`backup_enabled`\" : `false`, the cluster doesn't use Atlas backups.\n\nThis parameter defaults to false.\n"
                },
                "biConnectorConfig": {
                    "$ref": "#/types/mongodbatlas:index/AdvancedClusterBiConnectorConfig:AdvancedClusterBiConnectorConfig",
                    "description": "Configuration settings applied to BI Connector for Atlas on this cluster. The MongoDB Connector for Business Intelligence for Atlas (BI Connector) is only available for M10 and larger clusters. The BI Connector is a powerful tool which provides users SQL-based access to their MongoDB databases. As a result, the BI Connector performs operations which may be CPU and memory intensive. Given the limited hardware resources on M10 and M20 cluster tiers, you may experience performance degradation of the cluster when enabling the BI Connector. If this occurs, upgrade to an M30 or larger cluster or disable the BI Connector. See below.\n"
                },
                "clusterId": {
                    "type": "string",
                    "description": "The cluster ID.\n"
                },
                "clusterType": {
                    "type": "string",
                    "description": "Type of the cluster that you want to create.\nAccepted values include:\n- `REPLICASET` Replica set\n- `SHARDED`\tSharded cluster\n- `GEOSHARDED` Global Cluster\n"
                },
                "connectionStrings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/AdvancedClusterConnectionString:AdvancedClusterConnectionString"
                    },
                    "description": "Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.\n"
                },
                "createDate": {
                    "type": "string"
                },
                "diskSizeGb": {
                    "type": "number",
                    "description": "Capacity, in gigabytes, of the host's root volume. Increase this number to add capacity, up to a maximum possible value of 4096 (4 TB). This value must be a positive number. You can't set this value with clusters with local [NVMe SSDs](https://docs.atlas.mongodb.com/cluster-tier/#std-label-nvme-storage). The minimum disk size for dedicated clusters is 10 GB for AWS and GCP. If you specify diskSizeGB with a lower disk size, Atlas defaults to the minimum disk size value. If your cluster includes Azure nodes, this value must correspond to an existing Azure disk type (8, 16, 32, 64, 128, 256, 512, 1024, 2048, or 4095)Atlas calculates storage charges differently depending on whether you choose the default value or a custom value. The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require additional storage space beyond this limitation, consider [upgrading your cluster](https://docs.atlas.mongodb.com/scale-cluster/#std-label-scale-cluster-instance) to a higher tier. If your cluster spans cloud service providers, this value defaults to the minimum default of the providers involved. **(DEPRECATED)** Use `replication_specs.#.region_config.#.(analytics_specs|electable_specs|read_only_specs).disk_size_gb` instead. To learn more, see the 1.18.0 upgrade guide.\n",
                    "deprecationMessage": "This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown"
                },
                "encryptionAtRestProvider": {
                    "type": "string",
                    "description": "Possible values are AWS, GCP, AZURE or NONE.  Only needed if you desire to manage the keys, see [Encryption at Rest using Customer Key Management](https://docs.atlas.mongodb.com/security-kms-encryption/) for complete documentation.  You must configure encryption at rest for the Atlas project before enabling it on any cluster in the project. For Documentation, see [AWS](https://docs.atlas.mongodb.com/security-aws-kms/), [GCP](https://docs.atlas.mongodb.com/security-kms-encryption/) and [Azure](https://docs.atlas.mongodb.com/security-azure-kms/#std-label-security-azure-kms). Requirements are if `replication_specs.#.region_configs.#.\u003ctype\u003eSpecs.instance_size` is M10 or greater and `backup_enabled` is false or omitted.\n"
                },
                "globalClusterSelfManagedSharding": {
                    "type": "boolean",
                    "description": "Flag that indicates if cluster uses Atlas-Managed Sharding (false, default) or Self-Managed Sharding (true). It can only be enabled for Global Clusters (`GEOSHARDED`). It cannot be changed once the cluster is created. Use this mode if you're an advanced user and the default configuration is too restrictive for your workload. If you select this option, you must manually configure the sharding strategy, more info [here](https://www.mongodb.com/docs/atlas/tutorial/create-global-cluster/#select-your-sharding-configuration).\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/AdvancedClusterLabel:AdvancedClusterLabel"
                    },
                    "description": "Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below. **DEPRECATED** Use `tags` instead.\n",
                    "deprecationMessage": "This parameter is deprecated and will be removed by September 2024. Please transition to tags."
                },
                "mongoDbMajorVersion": {
                    "type": "string",
                    "description": "Version of the cluster to deploy. Atlas supports the following MongoDB versions for M10+ clusters: `4.4`, `5.0`, `6.0` or `7.0`. If omitted, Atlas deploys a cluster that runs MongoDB 7.0. If `replication_specs#.region_configs#.\u003ctype\u003eSpecs.instance_size`: `M0`, `M2` or `M5`, Atlas deploys MongoDB 4.4. Atlas always deploys the cluster with the latest stable release of the specified version.  If you set a value to this parameter and set `version_release_system` `CONTINUOUS`, the resource returns an error. Either clear this parameter or set `version_release_system`: `LTS`.\n"
                },
                "mongoDbVersion": {
                    "type": "string",
                    "description": "Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the cluster as it appears in Atlas. Once the cluster is created, its name cannot be changed. **WARNING** Changing the name will result in destruction of the existing cluster and the creation of a new cluster.\n"
                },
                "paused": {
                    "type": "boolean"
                },
                "pitEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates if the cluster uses Continuous Cloud Backup.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique ID for the project to create the database user.\n"
                },
                "replicationSpecs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/AdvancedClusterReplicationSpec:AdvancedClusterReplicationSpec"
                    },
                    "description": "List of settings that configure your cluster regions. This attribute has one object per shard representing node configurations in each shard. For replica sets there is only one object representing node configurations. If for each replication_spec `num_shards` is configured with a value greater than 1 (using deprecated sharding configurations), then each object represents a zone with one or more shards. See below\n"
                },
                "retainBackupsEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to retain backup snapshots for the deleted dedicated cluster\n"
                },
                "rootCertType": {
                    "type": "string",
                    "description": "Certificate Authority that MongoDB Atlas clusters use. You can specify ISRGROOTX1 (for ISRG Root X1).\n"
                },
                "stateName": {
                    "type": "string",
                    "description": "Current state of the cluster. The possible states are:\n- IDLE\n- CREATING\n- UPDATING\n- DELETING\n- DELETED\n- REPAIRING\n* `replication_specs.#.container_id` - A key-value map of the Network Peering Container ID(s) for the configuration specified in `region_configs`. The Container ID is the id of the container created when the first cluster in the region (AWS/Azure) or project (GCP) was created.  The syntax is `\"providerName:regionName\" = \"containerId\"`. Example `AWS:US_EAST_1\" = \"61e0797dde08fb498ca11a71`.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/AdvancedClusterTag:AdvancedClusterTag"
                    },
                    "description": "Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.\n"
                },
                "terminationProtectionEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n"
                },
                "versionReleaseSystem": {
                    "type": "string",
                    "description": "Release cadence that Atlas uses for this cluster. This parameter defaults to `LTS`. If you set this field to `CONTINUOUS`, you must omit the `mongo_db_major_version` field. Atlas accepts:\n- `CONTINUOUS`:  Atlas creates your cluster using the most recent MongoDB release. Atlas automatically updates your cluster to the latest major and rapid MongoDB releases as they become available.\n- `LTS`: Atlas creates your cluster using the latest patch release of the MongoDB version that you specify in the mongoDBMajorVersion field. Atlas automatically updates your cluster to subsequent patch releases of this MongoDB version. Atlas doesn't update your cluster to newer rapid or major MongoDB releases as they become available.\n"
                }
            },
            "required": [
                "advancedConfiguration",
                "backupEnabled",
                "biConnectorConfig",
                "clusterId",
                "clusterType",
                "connectionStrings",
                "createDate",
                "diskSizeGb",
                "encryptionAtRestProvider",
                "globalClusterSelfManagedSharding",
                "mongoDbMajorVersion",
                "mongoDbVersion",
                "name",
                "paused",
                "pitEnabled",
                "projectId",
                "replicationSpecs",
                "rootCertType",
                "stateName",
                "terminationProtectionEnabled",
                "versionReleaseSystem"
            ],
            "inputProperties": {
                "acceptDataRisksAndForceReplicaSetReconfig": {
                    "type": "string",
                    "description": "If reconfiguration is necessary to regain a primary due to a regional outage, submit this field alongside your topology reconfiguration to request a new regional outage resistant topology. Forced reconfigurations during an outage of the majority of electable nodes carry a risk of data loss if replicated writes (even majority committed writes) have not been replicated to the new primary node. MongoDB Atlas docs contain more information. To proceed with an operation which carries that risk, set `accept_data_risks_and_force_replica_set_reconfig` to the current date. Learn more about Reconfiguring a Replica Set during a regional outage [here](https://dochub.mongodb.org/core/regional-outage-reconfigure-replica-set).\n"
                },
                "advancedConfiguration": {
                    "$ref": "#/types/mongodbatlas:index/AdvancedClusterAdvancedConfiguration:AdvancedClusterAdvancedConfiguration"
                },
                "backupEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the cluster can perform backups.\nIf `true`, the cluster can perform backups. You must set this value to `true` for NVMe clusters.\n\nBackup uses:\n[Cloud Backups](https://docs.atlas.mongodb.com/backup/cloud-backup/overview/#std-label-backup-cloud-provider) for dedicated clusters.\n[Shared Cluster Backups](https://docs.atlas.mongodb.com/backup/shared-tier/overview/#std-label-m2-m5-snapshots) for tenant clusters.\nIf \"`backup_enabled`\" : `false`, the cluster doesn't use Atlas backups.\n\nThis parameter defaults to false.\n"
                },
                "biConnectorConfig": {
                    "$ref": "#/types/mongodbatlas:index/AdvancedClusterBiConnectorConfig:AdvancedClusterBiConnectorConfig",
                    "description": "Configuration settings applied to BI Connector for Atlas on this cluster. The MongoDB Connector for Business Intelligence for Atlas (BI Connector) is only available for M10 and larger clusters. The BI Connector is a powerful tool which provides users SQL-based access to their MongoDB databases. As a result, the BI Connector performs operations which may be CPU and memory intensive. Given the limited hardware resources on M10 and M20 cluster tiers, you may experience performance degradation of the cluster when enabling the BI Connector. If this occurs, upgrade to an M30 or larger cluster or disable the BI Connector. See below.\n"
                },
                "clusterType": {
                    "type": "string",
                    "description": "Type of the cluster that you want to create.\nAccepted values include:\n- `REPLICASET` Replica set\n- `SHARDED`\tSharded cluster\n- `GEOSHARDED` Global Cluster\n"
                },
                "diskSizeGb": {
                    "type": "number",
                    "description": "Capacity, in gigabytes, of the host's root volume. Increase this number to add capacity, up to a maximum possible value of 4096 (4 TB). This value must be a positive number. You can't set this value with clusters with local [NVMe SSDs](https://docs.atlas.mongodb.com/cluster-tier/#std-label-nvme-storage). The minimum disk size for dedicated clusters is 10 GB for AWS and GCP. If you specify diskSizeGB with a lower disk size, Atlas defaults to the minimum disk size value. If your cluster includes Azure nodes, this value must correspond to an existing Azure disk type (8, 16, 32, 64, 128, 256, 512, 1024, 2048, or 4095)Atlas calculates storage charges differently depending on whether you choose the default value or a custom value. The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require additional storage space beyond this limitation, consider [upgrading your cluster](https://docs.atlas.mongodb.com/scale-cluster/#std-label-scale-cluster-instance) to a higher tier. If your cluster spans cloud service providers, this value defaults to the minimum default of the providers involved. **(DEPRECATED)** Use `replication_specs.#.region_config.#.(analytics_specs|electable_specs|read_only_specs).disk_size_gb` instead. To learn more, see the 1.18.0 upgrade guide.\n",
                    "deprecationMessage": "This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown"
                },
                "encryptionAtRestProvider": {
                    "type": "string",
                    "description": "Possible values are AWS, GCP, AZURE or NONE.  Only needed if you desire to manage the keys, see [Encryption at Rest using Customer Key Management](https://docs.atlas.mongodb.com/security-kms-encryption/) for complete documentation.  You must configure encryption at rest for the Atlas project before enabling it on any cluster in the project. For Documentation, see [AWS](https://docs.atlas.mongodb.com/security-aws-kms/), [GCP](https://docs.atlas.mongodb.com/security-kms-encryption/) and [Azure](https://docs.atlas.mongodb.com/security-azure-kms/#std-label-security-azure-kms). Requirements are if `replication_specs.#.region_configs.#.\u003ctype\u003eSpecs.instance_size` is M10 or greater and `backup_enabled` is false or omitted.\n"
                },
                "globalClusterSelfManagedSharding": {
                    "type": "boolean",
                    "description": "Flag that indicates if cluster uses Atlas-Managed Sharding (false, default) or Self-Managed Sharding (true). It can only be enabled for Global Clusters (`GEOSHARDED`). It cannot be changed once the cluster is created. Use this mode if you're an advanced user and the default configuration is too restrictive for your workload. If you select this option, you must manually configure the sharding strategy, more info [here](https://www.mongodb.com/docs/atlas/tutorial/create-global-cluster/#select-your-sharding-configuration).\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/AdvancedClusterLabel:AdvancedClusterLabel"
                    },
                    "description": "Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below. **DEPRECATED** Use `tags` instead.\n",
                    "deprecationMessage": "This parameter is deprecated and will be removed by September 2024. Please transition to tags."
                },
                "mongoDbMajorVersion": {
                    "type": "string",
                    "description": "Version of the cluster to deploy. Atlas supports the following MongoDB versions for M10+ clusters: `4.4`, `5.0`, `6.0` or `7.0`. If omitted, Atlas deploys a cluster that runs MongoDB 7.0. If `replication_specs#.region_configs#.\u003ctype\u003eSpecs.instance_size`: `M0`, `M2` or `M5`, Atlas deploys MongoDB 4.4. Atlas always deploys the cluster with the latest stable release of the specified version.  If you set a value to this parameter and set `version_release_system` `CONTINUOUS`, the resource returns an error. Either clear this parameter or set `version_release_system`: `LTS`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the cluster as it appears in Atlas. Once the cluster is created, its name cannot be changed. **WARNING** Changing the name will result in destruction of the existing cluster and the creation of a new cluster.\n",
                    "willReplaceOnChanges": true
                },
                "paused": {
                    "type": "boolean"
                },
                "pitEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates if the cluster uses Continuous Cloud Backup.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique ID for the project to create the database user.\n",
                    "willReplaceOnChanges": true
                },
                "replicationSpecs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/AdvancedClusterReplicationSpec:AdvancedClusterReplicationSpec"
                    },
                    "description": "List of settings that configure your cluster regions. This attribute has one object per shard representing node configurations in each shard. For replica sets there is only one object representing node configurations. If for each replication_spec `num_shards` is configured with a value greater than 1 (using deprecated sharding configurations), then each object represents a zone with one or more shards. See below\n"
                },
                "retainBackupsEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to retain backup snapshots for the deleted dedicated cluster\n"
                },
                "rootCertType": {
                    "type": "string",
                    "description": "Certificate Authority that MongoDB Atlas clusters use. You can specify ISRGROOTX1 (for ISRG Root X1).\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/AdvancedClusterTag:AdvancedClusterTag"
                    },
                    "description": "Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.\n"
                },
                "terminationProtectionEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n"
                },
                "versionReleaseSystem": {
                    "type": "string",
                    "description": "Release cadence that Atlas uses for this cluster. This parameter defaults to `LTS`. If you set this field to `CONTINUOUS`, you must omit the `mongo_db_major_version` field. Atlas accepts:\n- `CONTINUOUS`:  Atlas creates your cluster using the most recent MongoDB release. Atlas automatically updates your cluster to the latest major and rapid MongoDB releases as they become available.\n- `LTS`: Atlas creates your cluster using the latest patch release of the MongoDB version that you specify in the mongoDBMajorVersion field. Atlas automatically updates your cluster to subsequent patch releases of this MongoDB version. Atlas doesn't update your cluster to newer rapid or major MongoDB releases as they become available.\n"
                }
            },
            "requiredInputs": [
                "clusterType",
                "projectId",
                "replicationSpecs"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AdvancedCluster resources.\n",
                "properties": {
                    "acceptDataRisksAndForceReplicaSetReconfig": {
                        "type": "string",
                        "description": "If reconfiguration is necessary to regain a primary due to a regional outage, submit this field alongside your topology reconfiguration to request a new regional outage resistant topology. Forced reconfigurations during an outage of the majority of electable nodes carry a risk of data loss if replicated writes (even majority committed writes) have not been replicated to the new primary node. MongoDB Atlas docs contain more information. To proceed with an operation which carries that risk, set `accept_data_risks_and_force_replica_set_reconfig` to the current date. Learn more about Reconfiguring a Replica Set during a regional outage [here](https://dochub.mongodb.org/core/regional-outage-reconfigure-replica-set).\n"
                    },
                    "advancedConfiguration": {
                        "$ref": "#/types/mongodbatlas:index/AdvancedClusterAdvancedConfiguration:AdvancedClusterAdvancedConfiguration"
                    },
                    "backupEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether the cluster can perform backups.\nIf `true`, the cluster can perform backups. You must set this value to `true` for NVMe clusters.\n\nBackup uses:\n[Cloud Backups](https://docs.atlas.mongodb.com/backup/cloud-backup/overview/#std-label-backup-cloud-provider) for dedicated clusters.\n[Shared Cluster Backups](https://docs.atlas.mongodb.com/backup/shared-tier/overview/#std-label-m2-m5-snapshots) for tenant clusters.\nIf \"`backup_enabled`\" : `false`, the cluster doesn't use Atlas backups.\n\nThis parameter defaults to false.\n"
                    },
                    "biConnectorConfig": {
                        "$ref": "#/types/mongodbatlas:index/AdvancedClusterBiConnectorConfig:AdvancedClusterBiConnectorConfig",
                        "description": "Configuration settings applied to BI Connector for Atlas on this cluster. The MongoDB Connector for Business Intelligence for Atlas (BI Connector) is only available for M10 and larger clusters. The BI Connector is a powerful tool which provides users SQL-based access to their MongoDB databases. As a result, the BI Connector performs operations which may be CPU and memory intensive. Given the limited hardware resources on M10 and M20 cluster tiers, you may experience performance degradation of the cluster when enabling the BI Connector. If this occurs, upgrade to an M30 or larger cluster or disable the BI Connector. See below.\n"
                    },
                    "clusterId": {
                        "type": "string",
                        "description": "The cluster ID.\n"
                    },
                    "clusterType": {
                        "type": "string",
                        "description": "Type of the cluster that you want to create.\nAccepted values include:\n- `REPLICASET` Replica set\n- `SHARDED`\tSharded cluster\n- `GEOSHARDED` Global Cluster\n"
                    },
                    "connectionStrings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/AdvancedClusterConnectionString:AdvancedClusterConnectionString"
                        },
                        "description": "Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.\n"
                    },
                    "createDate": {
                        "type": "string"
                    },
                    "diskSizeGb": {
                        "type": "number",
                        "description": "Capacity, in gigabytes, of the host's root volume. Increase this number to add capacity, up to a maximum possible value of 4096 (4 TB). This value must be a positive number. You can't set this value with clusters with local [NVMe SSDs](https://docs.atlas.mongodb.com/cluster-tier/#std-label-nvme-storage). The minimum disk size for dedicated clusters is 10 GB for AWS and GCP. If you specify diskSizeGB with a lower disk size, Atlas defaults to the minimum disk size value. If your cluster includes Azure nodes, this value must correspond to an existing Azure disk type (8, 16, 32, 64, 128, 256, 512, 1024, 2048, or 4095)Atlas calculates storage charges differently depending on whether you choose the default value or a custom value. The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require additional storage space beyond this limitation, consider [upgrading your cluster](https://docs.atlas.mongodb.com/scale-cluster/#std-label-scale-cluster-instance) to a higher tier. If your cluster spans cloud service providers, this value defaults to the minimum default of the providers involved. **(DEPRECATED)** Use `replication_specs.#.region_config.#.(analytics_specs|electable_specs|read_only_specs).disk_size_gb` instead. To learn more, see the 1.18.0 upgrade guide.\n",
                        "deprecationMessage": "This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown"
                    },
                    "encryptionAtRestProvider": {
                        "type": "string",
                        "description": "Possible values are AWS, GCP, AZURE or NONE.  Only needed if you desire to manage the keys, see [Encryption at Rest using Customer Key Management](https://docs.atlas.mongodb.com/security-kms-encryption/) for complete documentation.  You must configure encryption at rest for the Atlas project before enabling it on any cluster in the project. For Documentation, see [AWS](https://docs.atlas.mongodb.com/security-aws-kms/), [GCP](https://docs.atlas.mongodb.com/security-kms-encryption/) and [Azure](https://docs.atlas.mongodb.com/security-azure-kms/#std-label-security-azure-kms). Requirements are if `replication_specs.#.region_configs.#.\u003ctype\u003eSpecs.instance_size` is M10 or greater and `backup_enabled` is false or omitted.\n"
                    },
                    "globalClusterSelfManagedSharding": {
                        "type": "boolean",
                        "description": "Flag that indicates if cluster uses Atlas-Managed Sharding (false, default) or Self-Managed Sharding (true). It can only be enabled for Global Clusters (`GEOSHARDED`). It cannot be changed once the cluster is created. Use this mode if you're an advanced user and the default configuration is too restrictive for your workload. If you select this option, you must manually configure the sharding strategy, more info [here](https://www.mongodb.com/docs/atlas/tutorial/create-global-cluster/#select-your-sharding-configuration).\n"
                    },
                    "labels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/AdvancedClusterLabel:AdvancedClusterLabel"
                        },
                        "description": "Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below. **DEPRECATED** Use `tags` instead.\n",
                        "deprecationMessage": "This parameter is deprecated and will be removed by September 2024. Please transition to tags."
                    },
                    "mongoDbMajorVersion": {
                        "type": "string",
                        "description": "Version of the cluster to deploy. Atlas supports the following MongoDB versions for M10+ clusters: `4.4`, `5.0`, `6.0` or `7.0`. If omitted, Atlas deploys a cluster that runs MongoDB 7.0. If `replication_specs#.region_configs#.\u003ctype\u003eSpecs.instance_size`: `M0`, `M2` or `M5`, Atlas deploys MongoDB 4.4. Atlas always deploys the cluster with the latest stable release of the specified version.  If you set a value to this parameter and set `version_release_system` `CONTINUOUS`, the resource returns an error. Either clear this parameter or set `version_release_system`: `LTS`.\n"
                    },
                    "mongoDbVersion": {
                        "type": "string",
                        "description": "Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the cluster as it appears in Atlas. Once the cluster is created, its name cannot be changed. **WARNING** Changing the name will result in destruction of the existing cluster and the creation of a new cluster.\n",
                        "willReplaceOnChanges": true
                    },
                    "paused": {
                        "type": "boolean"
                    },
                    "pitEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates if the cluster uses Continuous Cloud Backup.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique ID for the project to create the database user.\n",
                        "willReplaceOnChanges": true
                    },
                    "replicationSpecs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/AdvancedClusterReplicationSpec:AdvancedClusterReplicationSpec"
                        },
                        "description": "List of settings that configure your cluster regions. This attribute has one object per shard representing node configurations in each shard. For replica sets there is only one object representing node configurations. If for each replication_spec `num_shards` is configured with a value greater than 1 (using deprecated sharding configurations), then each object represents a zone with one or more shards. See below\n"
                    },
                    "retainBackupsEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether to retain backup snapshots for the deleted dedicated cluster\n"
                    },
                    "rootCertType": {
                        "type": "string",
                        "description": "Certificate Authority that MongoDB Atlas clusters use. You can specify ISRGROOTX1 (for ISRG Root X1).\n"
                    },
                    "stateName": {
                        "type": "string",
                        "description": "Current state of the cluster. The possible states are:\n- IDLE\n- CREATING\n- UPDATING\n- DELETING\n- DELETED\n- REPAIRING\n* `replication_specs.#.container_id` - A key-value map of the Network Peering Container ID(s) for the configuration specified in `region_configs`. The Container ID is the id of the container created when the first cluster in the region (AWS/Azure) or project (GCP) was created.  The syntax is `\"providerName:regionName\" = \"containerId\"`. Example `AWS:US_EAST_1\" = \"61e0797dde08fb498ca11a71`.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/AdvancedClusterTag:AdvancedClusterTag"
                        },
                        "description": "Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.\n"
                    },
                    "terminationProtectionEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n"
                    },
                    "versionReleaseSystem": {
                        "type": "string",
                        "description": "Release cadence that Atlas uses for this cluster. This parameter defaults to `LTS`. If you set this field to `CONTINUOUS`, you must omit the `mongo_db_major_version` field. Atlas accepts:\n- `CONTINUOUS`:  Atlas creates your cluster using the most recent MongoDB release. Atlas automatically updates your cluster to the latest major and rapid MongoDB releases as they become available.\n- `LTS`: Atlas creates your cluster using the latest patch release of the MongoDB version that you specify in the mongoDBMajorVersion field. Atlas automatically updates your cluster to subsequent patch releases of this MongoDB version. Atlas doesn't update your cluster to newer rapid or major MongoDB releases as they become available.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/alertConfiguration:AlertConfiguration": {
            "description": "## # Resource: mongodbatlas.AlertConfiguration\n\n`mongodbatlas.AlertConfiguration` provides an Alert Configuration resource to define the conditions that trigger an alert and the methods of notification within a MongoDB Atlas project.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.AlertConfiguration(\"test\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    eventType: \"OUTSIDE_METRIC_THRESHOLD\",\n    enabled: true,\n    notifications: [{\n        typeName: \"GROUP\",\n        intervalMin: 5,\n        delayMin: 0,\n        smsEnabled: false,\n        emailEnabled: true,\n        roles: [\"GROUP_CLUSTER_MANAGER\"],\n    }],\n    matchers: [{\n        fieldName: \"HOSTNAME_AND_PORT\",\n        operator: \"EQUALS\",\n        value: \"SECONDARY\",\n    }],\n    metricThresholdConfig: {\n        metricName: \"ASSERT_REGULAR\",\n        operator: \"LESS_THAN\",\n        threshold: 99,\n        units: \"RAW\",\n        mode: \"AVERAGE\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.AlertConfiguration(\"test\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    event_type=\"OUTSIDE_METRIC_THRESHOLD\",\n    enabled=True,\n    notifications=[{\n        \"type_name\": \"GROUP\",\n        \"interval_min\": 5,\n        \"delay_min\": 0,\n        \"sms_enabled\": False,\n        \"email_enabled\": True,\n        \"roles\": [\"GROUP_CLUSTER_MANAGER\"],\n    }],\n    matchers=[{\n        \"field_name\": \"HOSTNAME_AND_PORT\",\n        \"operator\": \"EQUALS\",\n        \"value\": \"SECONDARY\",\n    }],\n    metric_threshold_config={\n        \"metric_name\": \"ASSERT_REGULAR\",\n        \"operator\": \"LESS_THAN\",\n        \"threshold\": 99,\n        \"units\": \"RAW\",\n        \"mode\": \"AVERAGE\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.AlertConfiguration(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        EventType = \"OUTSIDE_METRIC_THRESHOLD\",\n        Enabled = true,\n        Notifications = new[]\n        {\n            new Mongodbatlas.Inputs.AlertConfigurationNotificationArgs\n            {\n                TypeName = \"GROUP\",\n                IntervalMin = 5,\n                DelayMin = 0,\n                SmsEnabled = false,\n                EmailEnabled = true,\n                Roles = new[]\n                {\n                    \"GROUP_CLUSTER_MANAGER\",\n                },\n            },\n        },\n        Matchers = new[]\n        {\n            new Mongodbatlas.Inputs.AlertConfigurationMatcherArgs\n            {\n                FieldName = \"HOSTNAME_AND_PORT\",\n                Operator = \"EQUALS\",\n                Value = \"SECONDARY\",\n            },\n        },\n        MetricThresholdConfig = new Mongodbatlas.Inputs.AlertConfigurationMetricThresholdConfigArgs\n        {\n            MetricName = \"ASSERT_REGULAR\",\n            Operator = \"LESS_THAN\",\n            Threshold = 99,\n            Units = \"RAW\",\n            Mode = \"AVERAGE\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewAlertConfiguration(ctx, \"test\", \u0026mongodbatlas.AlertConfigurationArgs{\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tEventType: pulumi.String(\"OUTSIDE_METRIC_THRESHOLD\"),\n\t\t\tEnabled:   pulumi.Bool(true),\n\t\t\tNotifications: mongodbatlas.AlertConfigurationNotificationArray{\n\t\t\t\t\u0026mongodbatlas.AlertConfigurationNotificationArgs{\n\t\t\t\t\tTypeName:     pulumi.String(\"GROUP\"),\n\t\t\t\t\tIntervalMin:  pulumi.Int(5),\n\t\t\t\t\tDelayMin:     pulumi.Int(0),\n\t\t\t\t\tSmsEnabled:   pulumi.Bool(false),\n\t\t\t\t\tEmailEnabled: pulumi.Bool(true),\n\t\t\t\t\tRoles: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_CLUSTER_MANAGER\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tMatchers: mongodbatlas.AlertConfigurationMatcherArray{\n\t\t\t\t\u0026mongodbatlas.AlertConfigurationMatcherArgs{\n\t\t\t\t\tFieldName: pulumi.String(\"HOSTNAME_AND_PORT\"),\n\t\t\t\t\tOperator:  pulumi.String(\"EQUALS\"),\n\t\t\t\t\tValue:     pulumi.String(\"SECONDARY\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tMetricThresholdConfig: \u0026mongodbatlas.AlertConfigurationMetricThresholdConfigArgs{\n\t\t\t\tMetricName: pulumi.String(\"ASSERT_REGULAR\"),\n\t\t\t\tOperator:   pulumi.String(\"LESS_THAN\"),\n\t\t\t\tThreshold:  pulumi.Float64(99),\n\t\t\t\tUnits:      pulumi.String(\"RAW\"),\n\t\t\t\tMode:       pulumi.String(\"AVERAGE\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AlertConfiguration;\nimport com.pulumi.mongodbatlas.AlertConfigurationArgs;\nimport com.pulumi.mongodbatlas.inputs.AlertConfigurationNotificationArgs;\nimport com.pulumi.mongodbatlas.inputs.AlertConfigurationMatcherArgs;\nimport com.pulumi.mongodbatlas.inputs.AlertConfigurationMetricThresholdConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new AlertConfiguration(\"test\", AlertConfigurationArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .eventType(\"OUTSIDE_METRIC_THRESHOLD\")\n            .enabled(true)\n            .notifications(AlertConfigurationNotificationArgs.builder()\n                .typeName(\"GROUP\")\n                .intervalMin(5)\n                .delayMin(0)\n                .smsEnabled(false)\n                .emailEnabled(true)\n                .roles(\"GROUP_CLUSTER_MANAGER\")\n                .build())\n            .matchers(AlertConfigurationMatcherArgs.builder()\n                .fieldName(\"HOSTNAME_AND_PORT\")\n                .operator(\"EQUALS\")\n                .value(\"SECONDARY\")\n                .build())\n            .metricThresholdConfig(AlertConfigurationMetricThresholdConfigArgs.builder()\n                .metricName(\"ASSERT_REGULAR\")\n                .operator(\"LESS_THAN\")\n                .threshold(99)\n                .units(\"RAW\")\n                .mode(\"AVERAGE\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:AlertConfiguration\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      eventType: OUTSIDE_METRIC_THRESHOLD\n      enabled: true\n      notifications:\n        - typeName: GROUP\n          intervalMin: 5\n          delayMin: 0\n          smsEnabled: false\n          emailEnabled: true\n          roles:\n            - GROUP_CLUSTER_MANAGER\n      matchers:\n        - fieldName: HOSTNAME_AND_PORT\n          operator: EQUALS\n          value: SECONDARY\n      metricThresholdConfig:\n        metricName: ASSERT_REGULAR\n        operator: LESS_THAN\n        threshold: 99\n        units: RAW\n        mode: AVERAGE\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\u003e **NOTE:** In order to allow for a fast pace of change to alert variables some validations have been removed from this resource in order to unblock alert creation. Impacted areas have links to the MongoDB Atlas API documentation so always check it for the most current information: https://docs.atlas.mongodb.com/reference/api/alert-configurations-create-config/\n\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.AlertConfiguration(\"test\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    eventType: \"REPLICATION_OPLOG_WINDOW_RUNNING_OUT\",\n    enabled: true,\n    notifications: [{\n        typeName: \"GROUP\",\n        intervalMin: 5,\n        delayMin: 0,\n        smsEnabled: false,\n        emailEnabled: true,\n        roles: [\"GROUP_CLUSTER_MANAGER\"],\n    }],\n    matchers: [{\n        fieldName: \"CLUSTER_NAME\",\n        operator: \"EQUALS\",\n        value: \"my-cluster\",\n    }],\n    thresholdConfig: {\n        operator: \"LESS_THAN\",\n        threshold: 1,\n        units: \"HOURS\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.AlertConfiguration(\"test\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    event_type=\"REPLICATION_OPLOG_WINDOW_RUNNING_OUT\",\n    enabled=True,\n    notifications=[{\n        \"type_name\": \"GROUP\",\n        \"interval_min\": 5,\n        \"delay_min\": 0,\n        \"sms_enabled\": False,\n        \"email_enabled\": True,\n        \"roles\": [\"GROUP_CLUSTER_MANAGER\"],\n    }],\n    matchers=[{\n        \"field_name\": \"CLUSTER_NAME\",\n        \"operator\": \"EQUALS\",\n        \"value\": \"my-cluster\",\n    }],\n    threshold_config={\n        \"operator\": \"LESS_THAN\",\n        \"threshold\": 1,\n        \"units\": \"HOURS\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.AlertConfiguration(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        EventType = \"REPLICATION_OPLOG_WINDOW_RUNNING_OUT\",\n        Enabled = true,\n        Notifications = new[]\n        {\n            new Mongodbatlas.Inputs.AlertConfigurationNotificationArgs\n            {\n                TypeName = \"GROUP\",\n                IntervalMin = 5,\n                DelayMin = 0,\n                SmsEnabled = false,\n                EmailEnabled = true,\n                Roles = new[]\n                {\n                    \"GROUP_CLUSTER_MANAGER\",\n                },\n            },\n        },\n        Matchers = new[]\n        {\n            new Mongodbatlas.Inputs.AlertConfigurationMatcherArgs\n            {\n                FieldName = \"CLUSTER_NAME\",\n                Operator = \"EQUALS\",\n                Value = \"my-cluster\",\n            },\n        },\n        ThresholdConfig = new Mongodbatlas.Inputs.AlertConfigurationThresholdConfigArgs\n        {\n            Operator = \"LESS_THAN\",\n            Threshold = 1,\n            Units = \"HOURS\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewAlertConfiguration(ctx, \"test\", \u0026mongodbatlas.AlertConfigurationArgs{\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tEventType: pulumi.String(\"REPLICATION_OPLOG_WINDOW_RUNNING_OUT\"),\n\t\t\tEnabled:   pulumi.Bool(true),\n\t\t\tNotifications: mongodbatlas.AlertConfigurationNotificationArray{\n\t\t\t\t\u0026mongodbatlas.AlertConfigurationNotificationArgs{\n\t\t\t\t\tTypeName:     pulumi.String(\"GROUP\"),\n\t\t\t\t\tIntervalMin:  pulumi.Int(5),\n\t\t\t\t\tDelayMin:     pulumi.Int(0),\n\t\t\t\t\tSmsEnabled:   pulumi.Bool(false),\n\t\t\t\t\tEmailEnabled: pulumi.Bool(true),\n\t\t\t\t\tRoles: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_CLUSTER_MANAGER\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tMatchers: mongodbatlas.AlertConfigurationMatcherArray{\n\t\t\t\t\u0026mongodbatlas.AlertConfigurationMatcherArgs{\n\t\t\t\t\tFieldName: pulumi.String(\"CLUSTER_NAME\"),\n\t\t\t\t\tOperator:  pulumi.String(\"EQUALS\"),\n\t\t\t\t\tValue:     pulumi.String(\"my-cluster\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tThresholdConfig: \u0026mongodbatlas.AlertConfigurationThresholdConfigArgs{\n\t\t\t\tOperator:  pulumi.String(\"LESS_THAN\"),\n\t\t\t\tThreshold: pulumi.Float64(1),\n\t\t\t\tUnits:     pulumi.String(\"HOURS\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AlertConfiguration;\nimport com.pulumi.mongodbatlas.AlertConfigurationArgs;\nimport com.pulumi.mongodbatlas.inputs.AlertConfigurationNotificationArgs;\nimport com.pulumi.mongodbatlas.inputs.AlertConfigurationMatcherArgs;\nimport com.pulumi.mongodbatlas.inputs.AlertConfigurationThresholdConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new AlertConfiguration(\"test\", AlertConfigurationArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .eventType(\"REPLICATION_OPLOG_WINDOW_RUNNING_OUT\")\n            .enabled(true)\n            .notifications(AlertConfigurationNotificationArgs.builder()\n                .typeName(\"GROUP\")\n                .intervalMin(5)\n                .delayMin(0)\n                .smsEnabled(false)\n                .emailEnabled(true)\n                .roles(\"GROUP_CLUSTER_MANAGER\")\n                .build())\n            .matchers(AlertConfigurationMatcherArgs.builder()\n                .fieldName(\"CLUSTER_NAME\")\n                .operator(\"EQUALS\")\n                .value(\"my-cluster\")\n                .build())\n            .thresholdConfig(AlertConfigurationThresholdConfigArgs.builder()\n                .operator(\"LESS_THAN\")\n                .threshold(1)\n                .units(\"HOURS\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:AlertConfiguration\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      eventType: REPLICATION_OPLOG_WINDOW_RUNNING_OUT\n      enabled: true\n      notifications:\n        - typeName: GROUP\n          intervalMin: 5\n          delayMin: 0\n          smsEnabled: false\n          emailEnabled: true\n          roles:\n            - GROUP_CLUSTER_MANAGER\n      matchers:\n        - fieldName: CLUSTER_NAME\n          operator: EQUALS\n          value: my-cluster\n      thresholdConfig:\n        operator: LESS_THAN\n        threshold: 1\n        units: HOURS\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Create an alert with two notifications using Email and SMS\n\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.AlertConfiguration(\"test\", {\n    projectId: \"PROJECT ID\",\n    eventType: \"OUTSIDE_METRIC_THRESHOLD\",\n    enabled: true,\n    notifications: [\n        {\n            typeName: \"GROUP\",\n            intervalMin: 5,\n            delayMin: 0,\n            smsEnabled: false,\n            emailEnabled: true,\n            roles: [\n                \"GROUP_DATA_ACCESS_READ_ONLY\",\n                \"GROUP_CLUSTER_MANAGER\",\n                \"GROUP_DATA_ACCESS_ADMIN\",\n            ],\n        },\n        {\n            typeName: \"ORG\",\n            intervalMin: 5,\n            delayMin: 0,\n            smsEnabled: true,\n            emailEnabled: false,\n        },\n    ],\n    matchers: [{\n        fieldName: \"HOSTNAME_AND_PORT\",\n        operator: \"EQUALS\",\n        value: \"SECONDARY\",\n    }],\n    metricThresholdConfig: {\n        metricName: \"ASSERT_REGULAR\",\n        operator: \"LESS_THAN\",\n        threshold: 99,\n        units: \"RAW\",\n        mode: \"AVERAGE\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.AlertConfiguration(\"test\",\n    project_id=\"PROJECT ID\",\n    event_type=\"OUTSIDE_METRIC_THRESHOLD\",\n    enabled=True,\n    notifications=[\n        {\n            \"type_name\": \"GROUP\",\n            \"interval_min\": 5,\n            \"delay_min\": 0,\n            \"sms_enabled\": False,\n            \"email_enabled\": True,\n            \"roles\": [\n                \"GROUP_DATA_ACCESS_READ_ONLY\",\n                \"GROUP_CLUSTER_MANAGER\",\n                \"GROUP_DATA_ACCESS_ADMIN\",\n            ],\n        },\n        {\n            \"type_name\": \"ORG\",\n            \"interval_min\": 5,\n            \"delay_min\": 0,\n            \"sms_enabled\": True,\n            \"email_enabled\": False,\n        },\n    ],\n    matchers=[{\n        \"field_name\": \"HOSTNAME_AND_PORT\",\n        \"operator\": \"EQUALS\",\n        \"value\": \"SECONDARY\",\n    }],\n    metric_threshold_config={\n        \"metric_name\": \"ASSERT_REGULAR\",\n        \"operator\": \"LESS_THAN\",\n        \"threshold\": 99,\n        \"units\": \"RAW\",\n        \"mode\": \"AVERAGE\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.AlertConfiguration(\"test\", new()\n    {\n        ProjectId = \"PROJECT ID\",\n        EventType = \"OUTSIDE_METRIC_THRESHOLD\",\n        Enabled = true,\n        Notifications = new[]\n        {\n            new Mongodbatlas.Inputs.AlertConfigurationNotificationArgs\n            {\n                TypeName = \"GROUP\",\n                IntervalMin = 5,\n                DelayMin = 0,\n                SmsEnabled = false,\n                EmailEnabled = true,\n                Roles = new[]\n                {\n                    \"GROUP_DATA_ACCESS_READ_ONLY\",\n                    \"GROUP_CLUSTER_MANAGER\",\n                    \"GROUP_DATA_ACCESS_ADMIN\",\n                },\n            },\n            new Mongodbatlas.Inputs.AlertConfigurationNotificationArgs\n            {\n                TypeName = \"ORG\",\n                IntervalMin = 5,\n                DelayMin = 0,\n                SmsEnabled = true,\n                EmailEnabled = false,\n            },\n        },\n        Matchers = new[]\n        {\n            new Mongodbatlas.Inputs.AlertConfigurationMatcherArgs\n            {\n                FieldName = \"HOSTNAME_AND_PORT\",\n                Operator = \"EQUALS\",\n                Value = \"SECONDARY\",\n            },\n        },\n        MetricThresholdConfig = new Mongodbatlas.Inputs.AlertConfigurationMetricThresholdConfigArgs\n        {\n            MetricName = \"ASSERT_REGULAR\",\n            Operator = \"LESS_THAN\",\n            Threshold = 99,\n            Units = \"RAW\",\n            Mode = \"AVERAGE\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewAlertConfiguration(ctx, \"test\", \u0026mongodbatlas.AlertConfigurationArgs{\n\t\t\tProjectId: pulumi.String(\"PROJECT ID\"),\n\t\t\tEventType: pulumi.String(\"OUTSIDE_METRIC_THRESHOLD\"),\n\t\t\tEnabled:   pulumi.Bool(true),\n\t\t\tNotifications: mongodbatlas.AlertConfigurationNotificationArray{\n\t\t\t\t\u0026mongodbatlas.AlertConfigurationNotificationArgs{\n\t\t\t\t\tTypeName:     pulumi.String(\"GROUP\"),\n\t\t\t\t\tIntervalMin:  pulumi.Int(5),\n\t\t\t\t\tDelayMin:     pulumi.Int(0),\n\t\t\t\t\tSmsEnabled:   pulumi.Bool(false),\n\t\t\t\t\tEmailEnabled: pulumi.Bool(true),\n\t\t\t\t\tRoles: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_READ_ONLY\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_CLUSTER_MANAGER\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_ADMIN\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.AlertConfigurationNotificationArgs{\n\t\t\t\t\tTypeName:     pulumi.String(\"ORG\"),\n\t\t\t\t\tIntervalMin:  pulumi.Int(5),\n\t\t\t\t\tDelayMin:     pulumi.Int(0),\n\t\t\t\t\tSmsEnabled:   pulumi.Bool(true),\n\t\t\t\t\tEmailEnabled: pulumi.Bool(false),\n\t\t\t\t},\n\t\t\t},\n\t\t\tMatchers: mongodbatlas.AlertConfigurationMatcherArray{\n\t\t\t\t\u0026mongodbatlas.AlertConfigurationMatcherArgs{\n\t\t\t\t\tFieldName: pulumi.String(\"HOSTNAME_AND_PORT\"),\n\t\t\t\t\tOperator:  pulumi.String(\"EQUALS\"),\n\t\t\t\t\tValue:     pulumi.String(\"SECONDARY\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tMetricThresholdConfig: \u0026mongodbatlas.AlertConfigurationMetricThresholdConfigArgs{\n\t\t\t\tMetricName: pulumi.String(\"ASSERT_REGULAR\"),\n\t\t\t\tOperator:   pulumi.String(\"LESS_THAN\"),\n\t\t\t\tThreshold:  pulumi.Float64(99),\n\t\t\t\tUnits:      pulumi.String(\"RAW\"),\n\t\t\t\tMode:       pulumi.String(\"AVERAGE\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AlertConfiguration;\nimport com.pulumi.mongodbatlas.AlertConfigurationArgs;\nimport com.pulumi.mongodbatlas.inputs.AlertConfigurationNotificationArgs;\nimport com.pulumi.mongodbatlas.inputs.AlertConfigurationMatcherArgs;\nimport com.pulumi.mongodbatlas.inputs.AlertConfigurationMetricThresholdConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new AlertConfiguration(\"test\", AlertConfigurationArgs.builder()\n            .projectId(\"PROJECT ID\")\n            .eventType(\"OUTSIDE_METRIC_THRESHOLD\")\n            .enabled(true)\n            .notifications(            \n                AlertConfigurationNotificationArgs.builder()\n                    .typeName(\"GROUP\")\n                    .intervalMin(5)\n                    .delayMin(0)\n                    .smsEnabled(false)\n                    .emailEnabled(true)\n                    .roles(                    \n                        \"GROUP_DATA_ACCESS_READ_ONLY\",\n                        \"GROUP_CLUSTER_MANAGER\",\n                        \"GROUP_DATA_ACCESS_ADMIN\")\n                    .build(),\n                AlertConfigurationNotificationArgs.builder()\n                    .typeName(\"ORG\")\n                    .intervalMin(5)\n                    .delayMin(0)\n                    .smsEnabled(true)\n                    .emailEnabled(false)\n                    .build())\n            .matchers(AlertConfigurationMatcherArgs.builder()\n                .fieldName(\"HOSTNAME_AND_PORT\")\n                .operator(\"EQUALS\")\n                .value(\"SECONDARY\")\n                .build())\n            .metricThresholdConfig(AlertConfigurationMetricThresholdConfigArgs.builder()\n                .metricName(\"ASSERT_REGULAR\")\n                .operator(\"LESS_THAN\")\n                .threshold(99)\n                .units(\"RAW\")\n                .mode(\"AVERAGE\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:AlertConfiguration\n    properties:\n      projectId: PROJECT ID\n      eventType: OUTSIDE_METRIC_THRESHOLD\n      enabled: true\n      notifications:\n        - typeName: GROUP\n          intervalMin: 5\n          delayMin: 0\n          smsEnabled: false\n          emailEnabled: true\n          roles:\n            - GROUP_DATA_ACCESS_READ_ONLY\n            - GROUP_CLUSTER_MANAGER\n            - GROUP_DATA_ACCESS_ADMIN\n        - typeName: ORG\n          intervalMin: 5\n          delayMin: 0\n          smsEnabled: true\n          emailEnabled: false\n      matchers:\n        - fieldName: HOSTNAME_AND_PORT\n          operator: EQUALS\n          value: SECONDARY\n      metricThresholdConfig:\n        metricName: ASSERT_REGULAR\n        operator: LESS_THAN\n        threshold: 99\n        units: RAW\n        mode: AVERAGE\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Create third party notification using credentials from existing third party integration\n\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = mongodbatlas.getThirdPartyIntegration({\n    projectId: \"PROJECT ID\",\n    type: \"PAGER_DUTY\",\n});\nconst testAlertConfiguration = new mongodbatlas.AlertConfiguration(\"test\", {\n    projectId: \"PROJECT ID\",\n    enabled: true,\n    eventType: \"USERS_WITHOUT_MULTI_FACTOR_AUTH\",\n    notifications: [{\n        typeName: \"PAGER_DUTY\",\n        integrationId: test.then(test =\u003e test.id),\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.get_third_party_integration(project_id=\"PROJECT ID\",\n    type=\"PAGER_DUTY\")\ntest_alert_configuration = mongodbatlas.AlertConfiguration(\"test\",\n    project_id=\"PROJECT ID\",\n    enabled=True,\n    event_type=\"USERS_WITHOUT_MULTI_FACTOR_AUTH\",\n    notifications=[{\n        \"type_name\": \"PAGER_DUTY\",\n        \"integration_id\": test.id,\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Mongodbatlas.GetThirdPartyIntegration.Invoke(new()\n    {\n        ProjectId = \"PROJECT ID\",\n        Type = \"PAGER_DUTY\",\n    });\n\n    var testAlertConfiguration = new Mongodbatlas.AlertConfiguration(\"test\", new()\n    {\n        ProjectId = \"PROJECT ID\",\n        Enabled = true,\n        EventType = \"USERS_WITHOUT_MULTI_FACTOR_AUTH\",\n        Notifications = new[]\n        {\n            new Mongodbatlas.Inputs.AlertConfigurationNotificationArgs\n            {\n                TypeName = \"PAGER_DUTY\",\n                IntegrationId = test.Apply(getThirdPartyIntegrationResult =\u003e getThirdPartyIntegrationResult.Id),\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := mongodbatlas.LookupThirdPartyIntegration(ctx, \u0026mongodbatlas.LookupThirdPartyIntegrationArgs{\n\t\t\tProjectId: \"PROJECT ID\",\n\t\t\tType:      \"PAGER_DUTY\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewAlertConfiguration(ctx, \"test\", \u0026mongodbatlas.AlertConfigurationArgs{\n\t\t\tProjectId: pulumi.String(\"PROJECT ID\"),\n\t\t\tEnabled:   pulumi.Bool(true),\n\t\t\tEventType: pulumi.String(\"USERS_WITHOUT_MULTI_FACTOR_AUTH\"),\n\t\t\tNotifications: mongodbatlas.AlertConfigurationNotificationArray{\n\t\t\t\t\u0026mongodbatlas.AlertConfigurationNotificationArgs{\n\t\t\t\t\tTypeName:      pulumi.String(\"PAGER_DUTY\"),\n\t\t\t\t\tIntegrationId: pulumi.String(test.Id),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetThirdPartyIntegrationArgs;\nimport com.pulumi.mongodbatlas.AlertConfiguration;\nimport com.pulumi.mongodbatlas.AlertConfigurationArgs;\nimport com.pulumi.mongodbatlas.inputs.AlertConfigurationNotificationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getThirdPartyIntegration(GetThirdPartyIntegrationArgs.builder()\n            .projectId(\"PROJECT ID\")\n            .type(\"PAGER_DUTY\")\n            .build());\n\n        var testAlertConfiguration = new AlertConfiguration(\"testAlertConfiguration\", AlertConfigurationArgs.builder()\n            .projectId(\"PROJECT ID\")\n            .enabled(true)\n            .eventType(\"USERS_WITHOUT_MULTI_FACTOR_AUTH\")\n            .notifications(AlertConfigurationNotificationArgs.builder()\n                .typeName(\"PAGER_DUTY\")\n                .integrationId(test.applyValue(getThirdPartyIntegrationResult -\u003e getThirdPartyIntegrationResult.id()))\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testAlertConfiguration:\n    type: mongodbatlas:AlertConfiguration\n    name: test\n    properties:\n      projectId: PROJECT ID\n      enabled: true\n      eventType: USERS_WITHOUT_MULTI_FACTOR_AUTH\n      notifications:\n        - typeName: PAGER_DUTY\n          integrationId: ${test.id}\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getThirdPartyIntegration\n      Arguments:\n        projectId: PROJECT ID\n        type: PAGER_DUTY\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAlert Configuration can be imported using the `project_id-alert_configuration_id`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/alertConfiguration:AlertConfiguration test 5d0f1f74cf09a29120e123cd-5d0f1f74cf09a29120e1fscg\n```\n\n**NOTE**: Third-party notifications will not contain their respective credentials as these are sensitive attributes. If you wish to perform updates on these notifications without providing the original credentials, the corresponding `notifier_id` attribute must be provided instead.\n\nFor more information see: [MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/alert-configurations/)\n\n",
            "properties": {
                "alertConfigurationId": {
                    "type": "string",
                    "description": "Unique identifier for the alert configuration.\n"
                },
                "created": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when this alert configuration was created.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "It is not required, but If the attribute is omitted, by default will be false, and the configuration would be disabled. You must set true to enable the configuration.\n"
                },
                "eventType": {
                    "type": "string",
                    "description": "The type of event that will trigger an alert.\n\n\u003e ***IMPORTANT:*** Event Type has many possible values. Details for both conditional and metric based alerts can be found by selecting the tabs on the [alert config page](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Alert-Configurations/operation/createAlertConfiguration) and checking the latest eventTypeName options.\n\n\n\u003e **NOTE:** If `event_type` is set to `OUTSIDE_METRIC_THRESHOLD` or `OUTSIDE_SERVERLESS_METRIC_THRESHOLD`, the `metric_threshold_config` field must also be configured.\n"
                },
                "matchers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/AlertConfigurationMatcher:AlertConfigurationMatcher"
                    }
                },
                "metricThresholdConfig": {
                    "$ref": "#/types/mongodbatlas:index/AlertConfigurationMetricThresholdConfig:AlertConfigurationMetricThresholdConfig"
                },
                "notifications": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/AlertConfigurationNotification:AlertConfigurationNotification"
                    }
                },
                "projectId": {
                    "type": "string",
                    "description": "The ID of the project where the alert configuration will create.\n"
                },
                "thresholdConfig": {
                    "$ref": "#/types/mongodbatlas:index/AlertConfigurationThresholdConfig:AlertConfigurationThresholdConfig"
                },
                "updated": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when this alert configuration was last updated.\n"
                }
            },
            "required": [
                "alertConfigurationId",
                "created",
                "enabled",
                "eventType",
                "projectId",
                "updated"
            ],
            "inputProperties": {
                "enabled": {
                    "type": "boolean",
                    "description": "It is not required, but If the attribute is omitted, by default will be false, and the configuration would be disabled. You must set true to enable the configuration.\n"
                },
                "eventType": {
                    "type": "string",
                    "description": "The type of event that will trigger an alert.\n\n\u003e ***IMPORTANT:*** Event Type has many possible values. Details for both conditional and metric based alerts can be found by selecting the tabs on the [alert config page](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Alert-Configurations/operation/createAlertConfiguration) and checking the latest eventTypeName options.\n\n\n\u003e **NOTE:** If `event_type` is set to `OUTSIDE_METRIC_THRESHOLD` or `OUTSIDE_SERVERLESS_METRIC_THRESHOLD`, the `metric_threshold_config` field must also be configured.\n"
                },
                "matchers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/AlertConfigurationMatcher:AlertConfigurationMatcher"
                    }
                },
                "metricThresholdConfig": {
                    "$ref": "#/types/mongodbatlas:index/AlertConfigurationMetricThresholdConfig:AlertConfigurationMetricThresholdConfig"
                },
                "notifications": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/AlertConfigurationNotification:AlertConfigurationNotification"
                    }
                },
                "projectId": {
                    "type": "string",
                    "description": "The ID of the project where the alert configuration will create.\n"
                },
                "thresholdConfig": {
                    "$ref": "#/types/mongodbatlas:index/AlertConfigurationThresholdConfig:AlertConfigurationThresholdConfig"
                }
            },
            "requiredInputs": [
                "eventType",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AlertConfiguration resources.\n",
                "properties": {
                    "alertConfigurationId": {
                        "type": "string",
                        "description": "Unique identifier for the alert configuration.\n"
                    },
                    "created": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when this alert configuration was created.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "It is not required, but If the attribute is omitted, by default will be false, and the configuration would be disabled. You must set true to enable the configuration.\n"
                    },
                    "eventType": {
                        "type": "string",
                        "description": "The type of event that will trigger an alert.\n\n\u003e ***IMPORTANT:*** Event Type has many possible values. Details for both conditional and metric based alerts can be found by selecting the tabs on the [alert config page](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Alert-Configurations/operation/createAlertConfiguration) and checking the latest eventTypeName options.\n\n\n\u003e **NOTE:** If `event_type` is set to `OUTSIDE_METRIC_THRESHOLD` or `OUTSIDE_SERVERLESS_METRIC_THRESHOLD`, the `metric_threshold_config` field must also be configured.\n"
                    },
                    "matchers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/AlertConfigurationMatcher:AlertConfigurationMatcher"
                        }
                    },
                    "metricThresholdConfig": {
                        "$ref": "#/types/mongodbatlas:index/AlertConfigurationMetricThresholdConfig:AlertConfigurationMetricThresholdConfig"
                    },
                    "notifications": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/AlertConfigurationNotification:AlertConfigurationNotification"
                        }
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The ID of the project where the alert configuration will create.\n"
                    },
                    "thresholdConfig": {
                        "$ref": "#/types/mongodbatlas:index/AlertConfigurationThresholdConfig:AlertConfigurationThresholdConfig"
                    },
                    "updated": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when this alert configuration was last updated.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/apiKey:ApiKey": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.ApiKey(\"test\", {\n    description: \"key-name\",\n    orgId: \"\u003cORG_ID\u003e\",\n    roleNames: [\"ORG_READ_ONLY\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.ApiKey(\"test\",\n    description=\"key-name\",\n    org_id=\"\u003cORG_ID\u003e\",\n    role_names=[\"ORG_READ_ONLY\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.ApiKey(\"test\", new()\n    {\n        Description = \"key-name\",\n        OrgId = \"\u003cORG_ID\u003e\",\n        RoleNames = new[]\n        {\n            \"ORG_READ_ONLY\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewApiKey(ctx, \"test\", \u0026mongodbatlas.ApiKeyArgs{\n\t\t\tDescription: pulumi.String(\"key-name\"),\n\t\t\tOrgId:       pulumi.String(\"\u003cORG_ID\u003e\"),\n\t\t\tRoleNames: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"ORG_READ_ONLY\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ApiKey;\nimport com.pulumi.mongodbatlas.ApiKeyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new ApiKey(\"test\", ApiKeyArgs.builder()\n            .description(\"key-name\")\n            .orgId(\"\u003cORG_ID\u003e\")\n            .roleNames(\"ORG_READ_ONLY\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:ApiKey\n    properties:\n      description: key-name\n      orgId: \u003cORG_ID\u003e\n      roleNames:\n        - ORG_READ_ONLY\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n##  ## Attributes Reference\n\nIn addition to all arguments above, the following attributes are exported:\n\n* `api_key_id` - Unique identifier for this Organization API key.\n\n## Import\n\nAPI Keys must be imported using org ID, API Key ID e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/apiKey:ApiKey test 5d09d6a59ccf6445652a444a-6576974933969669\n```\nSee [MongoDB Atlas API - API Key](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Programmatic-API-Keys/operation/createApiKey) Documentation for more information.\n\n",
            "properties": {
                "apiKeyId": {
                    "type": "string"
                },
                "description": {
                    "type": "string",
                    "description": "Description of this Organization API key.\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique identifier for the organization whose API keys you want to retrieve. Use the /orgs endpoint to retrieve all organizations to which the authenticated user has access.\n"
                },
                "privateKey": {
                    "type": "string",
                    "secret": true
                },
                "publicKey": {
                    "type": "string"
                },
                "roleNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Name of the role. This resource returns all the roles the user has in Atlas.\nThe following are valid roles:\n* `ORG_OWNER`\n* `ORG_GROUP_CREATOR`\n* `ORG_BILLING_ADMIN`\n* `ORG_READ_ONLY`\n* `ORG_MEMBER`\n"
                }
            },
            "required": [
                "apiKeyId",
                "description",
                "orgId",
                "privateKey",
                "publicKey",
                "roleNames"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Description of this Organization API key.\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique identifier for the organization whose API keys you want to retrieve. Use the /orgs endpoint to retrieve all organizations to which the authenticated user has access.\n"
                },
                "roleNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Name of the role. This resource returns all the roles the user has in Atlas.\nThe following are valid roles:\n* `ORG_OWNER`\n* `ORG_GROUP_CREATOR`\n* `ORG_BILLING_ADMIN`\n* `ORG_READ_ONLY`\n* `ORG_MEMBER`\n"
                }
            },
            "requiredInputs": [
                "description",
                "orgId",
                "roleNames"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ApiKey resources.\n",
                "properties": {
                    "apiKeyId": {
                        "type": "string"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of this Organization API key.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Unique identifier for the organization whose API keys you want to retrieve. Use the /orgs endpoint to retrieve all organizations to which the authenticated user has access.\n"
                    },
                    "privateKey": {
                        "type": "string",
                        "secret": true
                    },
                    "publicKey": {
                        "type": "string"
                    },
                    "roleNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Name of the role. This resource returns all the roles the user has in Atlas.\nThe following are valid roles:\n* `ORG_OWNER`\n* `ORG_GROUP_CREATOR`\n* `ORG_BILLING_ADMIN`\n* `ORG_READ_ONLY`\n* `ORG_MEMBER`\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/auditing:Auditing": {
            "description": "## # Resource: mongodbatlas.Auditing\n\n`mongodbatlas.Auditing` provides an Auditing resource. This allows auditing to be created.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.Auditing(\"test\", {\n    projectId: \"\u003cproject-id\u003e\",\n    auditFilter: \"{ 'atype': 'authenticate', 'param': {   'user': 'auditAdmin',   'db': 'admin',   'mechanism': 'SCRAM-SHA-1' }}\",\n    auditAuthorizationSuccess: false,\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.Auditing(\"test\",\n    project_id=\"\u003cproject-id\u003e\",\n    audit_filter=\"{ 'atype': 'authenticate', 'param': {   'user': 'auditAdmin',   'db': 'admin',   'mechanism': 'SCRAM-SHA-1' }}\",\n    audit_authorization_success=False,\n    enabled=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.Auditing(\"test\", new()\n    {\n        ProjectId = \"\u003cproject-id\u003e\",\n        AuditFilter = \"{ 'atype': 'authenticate', 'param': {   'user': 'auditAdmin',   'db': 'admin',   'mechanism': 'SCRAM-SHA-1' }}\",\n        AuditAuthorizationSuccess = false,\n        Enabled = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewAuditing(ctx, \"test\", \u0026mongodbatlas.AuditingArgs{\n\t\t\tProjectId:                 pulumi.String(\"\u003cproject-id\u003e\"),\n\t\t\tAuditFilter:               pulumi.String(\"{ 'atype': 'authenticate', 'param': {   'user': 'auditAdmin',   'db': 'admin',   'mechanism': 'SCRAM-SHA-1' }}\"),\n\t\t\tAuditAuthorizationSuccess: pulumi.Bool(false),\n\t\t\tEnabled:                   pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Auditing;\nimport com.pulumi.mongodbatlas.AuditingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new Auditing(\"test\", AuditingArgs.builder()\n            .projectId(\"\u003cproject-id\u003e\")\n            .auditFilter(\"{ 'atype': 'authenticate', 'param': {   'user': 'auditAdmin',   'db': 'admin',   'mechanism': 'SCRAM-SHA-1' }}\")\n            .auditAuthorizationSuccess(false)\n            .enabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:Auditing\n    properties:\n      projectId: \u003cproject-id\u003e\n      auditFilter: '{ ''atype'': ''authenticate'', ''param'': {   ''user'': ''auditAdmin'',   ''db'': ''admin'',   ''mechanism'': ''SCRAM-SHA-1'' }}'\n      auditAuthorizationSuccess: false\n      enabled: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAuditing must be imported using auditing ID, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/auditing:Auditing my_auditing 5d09d6a59ccf6445652a444a\n```\nFor more information see: [MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/auditing/)\n\n",
            "properties": {
                "auditAuthorizationSuccess": {
                    "type": "boolean",
                    "description": "Indicates whether the auditing system captures successful authentication attempts for audit filters using the \"atype\" : \"authCheck\" auditing event. For more information, see [auditAuthorizationSuccess](https://docs.mongodb.com/manual/reference/parameters/#param.auditAuthorizationSuccess).  **Warning! Enabling Audit authorization successes can severely impact cluster performance. Enable this option with caution.**\n"
                },
                "auditFilter": {
                    "type": "string",
                    "description": "JSON-formatted audit filter. For complete documentation on custom auditing filters, see [Configure Audit Filters](https://docs.mongodb.com/manual/tutorial/configure-audit-filters/).\n"
                },
                "configurationType": {
                    "type": "string",
                    "description": "Denotes the configuration method for the audit filter. Possible values are: \n* NONE - auditing not configured for the project.\n* FILTER_BUILDER - auditing configured via Atlas UI filter builder.\n* FILTER_JSON - auditing configured via Atlas custom filter or API.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Denotes whether or not the project associated with the {project_id} has database auditing enabled.  Defaults to false.\n\n\u003e **NOTE:** Auditing created by API Keys must belong to an existing organization.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to configure auditing. **Note: When changing this value to a different project_id it will delete the current audit settings for the original project that was assigned to.**\n"
                }
            },
            "required": [
                "auditAuthorizationSuccess",
                "auditFilter",
                "configurationType",
                "enabled",
                "projectId"
            ],
            "inputProperties": {
                "auditAuthorizationSuccess": {
                    "type": "boolean",
                    "description": "Indicates whether the auditing system captures successful authentication attempts for audit filters using the \"atype\" : \"authCheck\" auditing event. For more information, see [auditAuthorizationSuccess](https://docs.mongodb.com/manual/reference/parameters/#param.auditAuthorizationSuccess).  **Warning! Enabling Audit authorization successes can severely impact cluster performance. Enable this option with caution.**\n"
                },
                "auditFilter": {
                    "type": "string",
                    "description": "JSON-formatted audit filter. For complete documentation on custom auditing filters, see [Configure Audit Filters](https://docs.mongodb.com/manual/tutorial/configure-audit-filters/).\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Denotes whether or not the project associated with the {project_id} has database auditing enabled.  Defaults to false.\n\n\u003e **NOTE:** Auditing created by API Keys must belong to an existing organization.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to configure auditing. **Note: When changing this value to a different project_id it will delete the current audit settings for the original project that was assigned to.**\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Auditing resources.\n",
                "properties": {
                    "auditAuthorizationSuccess": {
                        "type": "boolean",
                        "description": "Indicates whether the auditing system captures successful authentication attempts for audit filters using the \"atype\" : \"authCheck\" auditing event. For more information, see [auditAuthorizationSuccess](https://docs.mongodb.com/manual/reference/parameters/#param.auditAuthorizationSuccess).  **Warning! Enabling Audit authorization successes can severely impact cluster performance. Enable this option with caution.**\n"
                    },
                    "auditFilter": {
                        "type": "string",
                        "description": "JSON-formatted audit filter. For complete documentation on custom auditing filters, see [Configure Audit Filters](https://docs.mongodb.com/manual/tutorial/configure-audit-filters/).\n"
                    },
                    "configurationType": {
                        "type": "string",
                        "description": "Denotes the configuration method for the audit filter. Possible values are: \n* NONE - auditing not configured for the project.\n* FILTER_BUILDER - auditing configured via Atlas UI filter builder.\n* FILTER_JSON - auditing configured via Atlas custom filter or API.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Denotes whether or not the project associated with the {project_id} has database auditing enabled.  Defaults to false.\n\n\u003e **NOTE:** Auditing created by API Keys must belong to an existing organization.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to configure auditing. **Note: When changing this value to a different project_id it will delete the current audit settings for the original project that was assigned to.**\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/backupCompliancePolicy:BackupCompliancePolicy": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst myCluster = new mongodbatlas.AdvancedCluster(\"my_cluster\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    name: \"clusterTest\",\n    clusterType: \"REPLICASET\",\n    backupEnabled: true,\n    replicationSpecs: [{\n        regionConfigs: [{\n            priority: 7,\n            providerName: \"AWS\",\n            regionName: region,\n            electableSpecs: {\n                instanceSize: \"M10\",\n                nodeCount: 3,\n            },\n        }],\n    }],\n});\nconst testCloudBackupSchedule = new mongodbatlas.CloudBackupSchedule(\"test\", {\n    projectId: myCluster.projectId,\n    clusterName: myCluster.name,\n    referenceHourOfDay: 3,\n    referenceMinuteOfHour: 45,\n    restoreWindowDays: 4,\n    policyItemHourly: {\n        frequencyInterval: 1,\n        retentionUnit: \"days\",\n        retentionValue: 7,\n    },\n    policyItemDaily: {\n        frequencyInterval: 1,\n        retentionUnit: \"days\",\n        retentionValue: 7,\n    },\n    policyItemWeeklies: [{\n        frequencyInterval: 1,\n        retentionUnit: \"weeks\",\n        retentionValue: 4,\n    }],\n    policyItemMonthlies: [{\n        frequencyInterval: 1,\n        retentionUnit: \"months\",\n        retentionValue: 12,\n    }],\n    policyItemYearlies: [{\n        frequencyInterval: 1,\n        retentionUnit: \"years\",\n        retentionValue: 1,\n    }],\n});\nconst test = mongodbatlas.getCloudBackupScheduleOutput({\n    projectId: testCloudBackupSchedule.projectId,\n    clusterName: testCloudBackupSchedule.clusterName,\n});\nconst backupPolicy = mongodbatlas.getBackupCompliancePolicyOutput({\n    projectId: testCloudBackupSchedule.projectId,\n});\nconst backupPolicyBackupCompliancePolicy = new mongodbatlas.BackupCompliancePolicy(\"backup_policy\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    authorizedEmail: \"user@email.com\",\n    authorizedUserFirstName: \"First\",\n    authorizedUserLastName: \"Last\",\n    copyProtectionEnabled: false,\n    pitEnabled: false,\n    encryptionAtRestEnabled: false,\n    restoreWindowDays: 7,\n    onDemandPolicyItem: {\n        frequencyInterval: 1,\n        retentionUnit: \"days\",\n        retentionValue: 3,\n    },\n    policyItemHourly: {\n        frequencyInterval: 1,\n        retentionUnit: \"days\",\n        retentionValue: 7,\n    },\n    policyItemDaily: {\n        frequencyInterval: 1,\n        retentionUnit: \"days\",\n        retentionValue: 7,\n    },\n    policyItemWeeklies: [{\n        frequencyInterval: 1,\n        retentionUnit: \"weeks\",\n        retentionValue: 4,\n    }],\n    policyItemMonthlies: [{\n        frequencyInterval: 1,\n        retentionUnit: \"months\",\n        retentionValue: 12,\n    }],\n    policyItemYearlies: [{\n        frequencyInterval: 1,\n        retentionUnit: \"years\",\n        retentionValue: 1,\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nmy_cluster = mongodbatlas.AdvancedCluster(\"my_cluster\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    name=\"clusterTest\",\n    cluster_type=\"REPLICASET\",\n    backup_enabled=True,\n    replication_specs=[{\n        \"region_configs\": [{\n            \"priority\": 7,\n            \"provider_name\": \"AWS\",\n            \"region_name\": region,\n            \"electable_specs\": {\n                \"instance_size\": \"M10\",\n                \"node_count\": 3,\n            },\n        }],\n    }])\ntest_cloud_backup_schedule = mongodbatlas.CloudBackupSchedule(\"test\",\n    project_id=my_cluster.project_id,\n    cluster_name=my_cluster.name,\n    reference_hour_of_day=3,\n    reference_minute_of_hour=45,\n    restore_window_days=4,\n    policy_item_hourly={\n        \"frequency_interval\": 1,\n        \"retention_unit\": \"days\",\n        \"retention_value\": 7,\n    },\n    policy_item_daily={\n        \"frequency_interval\": 1,\n        \"retention_unit\": \"days\",\n        \"retention_value\": 7,\n    },\n    policy_item_weeklies=[{\n        \"frequency_interval\": 1,\n        \"retention_unit\": \"weeks\",\n        \"retention_value\": 4,\n    }],\n    policy_item_monthlies=[{\n        \"frequency_interval\": 1,\n        \"retention_unit\": \"months\",\n        \"retention_value\": 12,\n    }],\n    policy_item_yearlies=[{\n        \"frequency_interval\": 1,\n        \"retention_unit\": \"years\",\n        \"retention_value\": 1,\n    }])\ntest = mongodbatlas.get_cloud_backup_schedule_output(project_id=test_cloud_backup_schedule.project_id,\n    cluster_name=test_cloud_backup_schedule.cluster_name)\nbackup_policy = mongodbatlas.get_backup_compliance_policy_output(project_id=test_cloud_backup_schedule.project_id)\nbackup_policy_backup_compliance_policy = mongodbatlas.BackupCompliancePolicy(\"backup_policy\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    authorized_email=\"user@email.com\",\n    authorized_user_first_name=\"First\",\n    authorized_user_last_name=\"Last\",\n    copy_protection_enabled=False,\n    pit_enabled=False,\n    encryption_at_rest_enabled=False,\n    restore_window_days=7,\n    on_demand_policy_item={\n        \"frequency_interval\": 1,\n        \"retention_unit\": \"days\",\n        \"retention_value\": 3,\n    },\n    policy_item_hourly={\n        \"frequency_interval\": 1,\n        \"retention_unit\": \"days\",\n        \"retention_value\": 7,\n    },\n    policy_item_daily={\n        \"frequency_interval\": 1,\n        \"retention_unit\": \"days\",\n        \"retention_value\": 7,\n    },\n    policy_item_weeklies=[{\n        \"frequency_interval\": 1,\n        \"retention_unit\": \"weeks\",\n        \"retention_value\": 4,\n    }],\n    policy_item_monthlies=[{\n        \"frequency_interval\": 1,\n        \"retention_unit\": \"months\",\n        \"retention_value\": 12,\n    }],\n    policy_item_yearlies=[{\n        \"frequency_interval\": 1,\n        \"retention_unit\": \"years\",\n        \"retention_value\": 1,\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myCluster = new Mongodbatlas.AdvancedCluster(\"my_cluster\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        Name = \"clusterTest\",\n        ClusterType = \"REPLICASET\",\n        BackupEnabled = true,\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        Priority = 7,\n                        ProviderName = \"AWS\",\n                        RegionName = region,\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M10\",\n                            NodeCount = 3,\n                        },\n                    },\n                },\n            },\n        },\n    });\n\n    var testCloudBackupSchedule = new Mongodbatlas.CloudBackupSchedule(\"test\", new()\n    {\n        ProjectId = myCluster.ProjectId,\n        ClusterName = myCluster.Name,\n        ReferenceHourOfDay = 3,\n        ReferenceMinuteOfHour = 45,\n        RestoreWindowDays = 4,\n        PolicyItemHourly = new Mongodbatlas.Inputs.CloudBackupSchedulePolicyItemHourlyArgs\n        {\n            FrequencyInterval = 1,\n            RetentionUnit = \"days\",\n            RetentionValue = 7,\n        },\n        PolicyItemDaily = new Mongodbatlas.Inputs.CloudBackupSchedulePolicyItemDailyArgs\n        {\n            FrequencyInterval = 1,\n            RetentionUnit = \"days\",\n            RetentionValue = 7,\n        },\n        PolicyItemWeeklies = new[]\n        {\n            new Mongodbatlas.Inputs.CloudBackupSchedulePolicyItemWeeklyArgs\n            {\n                FrequencyInterval = 1,\n                RetentionUnit = \"weeks\",\n                RetentionValue = 4,\n            },\n        },\n        PolicyItemMonthlies = new[]\n        {\n            new Mongodbatlas.Inputs.CloudBackupSchedulePolicyItemMonthlyArgs\n            {\n                FrequencyInterval = 1,\n                RetentionUnit = \"months\",\n                RetentionValue = 12,\n            },\n        },\n        PolicyItemYearlies = new[]\n        {\n            new Mongodbatlas.Inputs.CloudBackupSchedulePolicyItemYearlyArgs\n            {\n                FrequencyInterval = 1,\n                RetentionUnit = \"years\",\n                RetentionValue = 1,\n            },\n        },\n    });\n\n    var test = Mongodbatlas.GetCloudBackupSchedule.Invoke(new()\n    {\n        ProjectId = testCloudBackupSchedule.ProjectId,\n        ClusterName = testCloudBackupSchedule.ClusterName,\n    });\n\n    var backupPolicy = Mongodbatlas.GetBackupCompliancePolicy.Invoke(new()\n    {\n        ProjectId = testCloudBackupSchedule.ProjectId,\n    });\n\n    var backupPolicyBackupCompliancePolicy = new Mongodbatlas.BackupCompliancePolicy(\"backup_policy\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        AuthorizedEmail = \"user@email.com\",\n        AuthorizedUserFirstName = \"First\",\n        AuthorizedUserLastName = \"Last\",\n        CopyProtectionEnabled = false,\n        PitEnabled = false,\n        EncryptionAtRestEnabled = false,\n        RestoreWindowDays = 7,\n        OnDemandPolicyItem = new Mongodbatlas.Inputs.BackupCompliancePolicyOnDemandPolicyItemArgs\n        {\n            FrequencyInterval = 1,\n            RetentionUnit = \"days\",\n            RetentionValue = 3,\n        },\n        PolicyItemHourly = new Mongodbatlas.Inputs.BackupCompliancePolicyPolicyItemHourlyArgs\n        {\n            FrequencyInterval = 1,\n            RetentionUnit = \"days\",\n            RetentionValue = 7,\n        },\n        PolicyItemDaily = new Mongodbatlas.Inputs.BackupCompliancePolicyPolicyItemDailyArgs\n        {\n            FrequencyInterval = 1,\n            RetentionUnit = \"days\",\n            RetentionValue = 7,\n        },\n        PolicyItemWeeklies = new[]\n        {\n            new Mongodbatlas.Inputs.BackupCompliancePolicyPolicyItemWeeklyArgs\n            {\n                FrequencyInterval = 1,\n                RetentionUnit = \"weeks\",\n                RetentionValue = 4,\n            },\n        },\n        PolicyItemMonthlies = new[]\n        {\n            new Mongodbatlas.Inputs.BackupCompliancePolicyPolicyItemMonthlyArgs\n            {\n                FrequencyInterval = 1,\n                RetentionUnit = \"months\",\n                RetentionValue = 12,\n            },\n        },\n        PolicyItemYearlies = new[]\n        {\n            new Mongodbatlas.Inputs.BackupCompliancePolicyPolicyItemYearlyArgs\n            {\n                FrequencyInterval = 1,\n                RetentionUnit = \"years\",\n                RetentionValue = 1,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmyCluster, err := mongodbatlas.NewAdvancedCluster(ctx, \"my_cluster\", \u0026mongodbatlas.AdvancedClusterArgs{\n\t\t\tProjectId:     pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tName:          pulumi.String(\"clusterTest\"),\n\t\t\tClusterType:   pulumi.String(\"REPLICASET\"),\n\t\t\tBackupEnabled: pulumi.Bool(true),\n\t\t\tReplicationSpecs: mongodbatlas.AdvancedClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tPriority:     pulumi.Int(7),\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tRegionName:   pulumi.Any(region),\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M10\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(3),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestCloudBackupSchedule, err := mongodbatlas.NewCloudBackupSchedule(ctx, \"test\", \u0026mongodbatlas.CloudBackupScheduleArgs{\n\t\t\tProjectId:             myCluster.ProjectId,\n\t\t\tClusterName:           myCluster.Name,\n\t\t\tReferenceHourOfDay:    pulumi.Int(3),\n\t\t\tReferenceMinuteOfHour: pulumi.Int(45),\n\t\t\tRestoreWindowDays:     pulumi.Int(4),\n\t\t\tPolicyItemHourly: \u0026mongodbatlas.CloudBackupSchedulePolicyItemHourlyArgs{\n\t\t\t\tFrequencyInterval: pulumi.Int(1),\n\t\t\t\tRetentionUnit:     pulumi.String(\"days\"),\n\t\t\t\tRetentionValue:    pulumi.Int(7),\n\t\t\t},\n\t\t\tPolicyItemDaily: \u0026mongodbatlas.CloudBackupSchedulePolicyItemDailyArgs{\n\t\t\t\tFrequencyInterval: pulumi.Int(1),\n\t\t\t\tRetentionUnit:     pulumi.String(\"days\"),\n\t\t\t\tRetentionValue:    pulumi.Int(7),\n\t\t\t},\n\t\t\tPolicyItemWeeklies: mongodbatlas.CloudBackupSchedulePolicyItemWeeklyArray{\n\t\t\t\t\u0026mongodbatlas.CloudBackupSchedulePolicyItemWeeklyArgs{\n\t\t\t\t\tFrequencyInterval: pulumi.Int(1),\n\t\t\t\t\tRetentionUnit:     pulumi.String(\"weeks\"),\n\t\t\t\t\tRetentionValue:    pulumi.Int(4),\n\t\t\t\t},\n\t\t\t},\n\t\t\tPolicyItemMonthlies: mongodbatlas.CloudBackupSchedulePolicyItemMonthlyArray{\n\t\t\t\t\u0026mongodbatlas.CloudBackupSchedulePolicyItemMonthlyArgs{\n\t\t\t\t\tFrequencyInterval: pulumi.Int(1),\n\t\t\t\t\tRetentionUnit:     pulumi.String(\"months\"),\n\t\t\t\t\tRetentionValue:    pulumi.Int(12),\n\t\t\t\t},\n\t\t\t},\n\t\t\tPolicyItemYearlies: mongodbatlas.CloudBackupSchedulePolicyItemYearlyArray{\n\t\t\t\t\u0026mongodbatlas.CloudBackupSchedulePolicyItemYearlyArgs{\n\t\t\t\t\tFrequencyInterval: pulumi.Int(1),\n\t\t\t\t\tRetentionUnit:     pulumi.String(\"years\"),\n\t\t\t\t\tRetentionValue:    pulumi.Int(1),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupCloudBackupScheduleOutput(ctx, mongodbatlas.GetCloudBackupScheduleOutputArgs{\n\t\t\tProjectId:   testCloudBackupSchedule.ProjectId,\n\t\t\tClusterName: testCloudBackupSchedule.ClusterName,\n\t\t}, nil)\n\t\t_ = mongodbatlas.LookupBackupCompliancePolicyOutput(ctx, mongodbatlas.GetBackupCompliancePolicyOutputArgs{\n\t\t\tProjectId: testCloudBackupSchedule.ProjectId,\n\t\t}, nil)\n\t\t_, err = mongodbatlas.NewBackupCompliancePolicy(ctx, \"backup_policy\", \u0026mongodbatlas.BackupCompliancePolicyArgs{\n\t\t\tProjectId:               pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tAuthorizedEmail:         pulumi.String(\"user@email.com\"),\n\t\t\tAuthorizedUserFirstName: pulumi.String(\"First\"),\n\t\t\tAuthorizedUserLastName:  pulumi.String(\"Last\"),\n\t\t\tCopyProtectionEnabled:   pulumi.Bool(false),\n\t\t\tPitEnabled:              pulumi.Bool(false),\n\t\t\tEncryptionAtRestEnabled: pulumi.Bool(false),\n\t\t\tRestoreWindowDays:       pulumi.Int(7),\n\t\t\tOnDemandPolicyItem: \u0026mongodbatlas.BackupCompliancePolicyOnDemandPolicyItemArgs{\n\t\t\t\tFrequencyInterval: pulumi.Int(1),\n\t\t\t\tRetentionUnit:     pulumi.String(\"days\"),\n\t\t\t\tRetentionValue:    pulumi.Int(3),\n\t\t\t},\n\t\t\tPolicyItemHourly: \u0026mongodbatlas.BackupCompliancePolicyPolicyItemHourlyArgs{\n\t\t\t\tFrequencyInterval: pulumi.Int(1),\n\t\t\t\tRetentionUnit:     pulumi.String(\"days\"),\n\t\t\t\tRetentionValue:    pulumi.Int(7),\n\t\t\t},\n\t\t\tPolicyItemDaily: \u0026mongodbatlas.BackupCompliancePolicyPolicyItemDailyArgs{\n\t\t\t\tFrequencyInterval: pulumi.Int(1),\n\t\t\t\tRetentionUnit:     pulumi.String(\"days\"),\n\t\t\t\tRetentionValue:    pulumi.Int(7),\n\t\t\t},\n\t\t\tPolicyItemWeeklies: mongodbatlas.BackupCompliancePolicyPolicyItemWeeklyArray{\n\t\t\t\t\u0026mongodbatlas.BackupCompliancePolicyPolicyItemWeeklyArgs{\n\t\t\t\t\tFrequencyInterval: pulumi.Int(1),\n\t\t\t\t\tRetentionUnit:     pulumi.String(\"weeks\"),\n\t\t\t\t\tRetentionValue:    pulumi.Int(4),\n\t\t\t\t},\n\t\t\t},\n\t\t\tPolicyItemMonthlies: mongodbatlas.BackupCompliancePolicyPolicyItemMonthlyArray{\n\t\t\t\t\u0026mongodbatlas.BackupCompliancePolicyPolicyItemMonthlyArgs{\n\t\t\t\t\tFrequencyInterval: pulumi.Int(1),\n\t\t\t\t\tRetentionUnit:     pulumi.String(\"months\"),\n\t\t\t\t\tRetentionValue:    pulumi.Int(12),\n\t\t\t\t},\n\t\t\t},\n\t\t\tPolicyItemYearlies: mongodbatlas.BackupCompliancePolicyPolicyItemYearlyArray{\n\t\t\t\t\u0026mongodbatlas.BackupCompliancePolicyPolicyItemYearlyArgs{\n\t\t\t\t\tFrequencyInterval: pulumi.Int(1),\n\t\t\t\t\tRetentionUnit:     pulumi.String(\"years\"),\n\t\t\t\t\tRetentionValue:    pulumi.Int(1),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AdvancedCluster;\nimport com.pulumi.mongodbatlas.AdvancedClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.AdvancedClusterReplicationSpecArgs;\nimport com.pulumi.mongodbatlas.CloudBackupSchedule;\nimport com.pulumi.mongodbatlas.CloudBackupScheduleArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudBackupSchedulePolicyItemHourlyArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudBackupSchedulePolicyItemDailyArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudBackupSchedulePolicyItemWeeklyArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudBackupSchedulePolicyItemMonthlyArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudBackupSchedulePolicyItemYearlyArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetCloudBackupScheduleArgs;\nimport com.pulumi.mongodbatlas.inputs.GetBackupCompliancePolicyArgs;\nimport com.pulumi.mongodbatlas.BackupCompliancePolicy;\nimport com.pulumi.mongodbatlas.BackupCompliancePolicyArgs;\nimport com.pulumi.mongodbatlas.inputs.BackupCompliancePolicyOnDemandPolicyItemArgs;\nimport com.pulumi.mongodbatlas.inputs.BackupCompliancePolicyPolicyItemHourlyArgs;\nimport com.pulumi.mongodbatlas.inputs.BackupCompliancePolicyPolicyItemDailyArgs;\nimport com.pulumi.mongodbatlas.inputs.BackupCompliancePolicyPolicyItemWeeklyArgs;\nimport com.pulumi.mongodbatlas.inputs.BackupCompliancePolicyPolicyItemMonthlyArgs;\nimport com.pulumi.mongodbatlas.inputs.BackupCompliancePolicyPolicyItemYearlyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myCluster = new AdvancedCluster(\"myCluster\", AdvancedClusterArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .name(\"clusterTest\")\n            .clusterType(\"REPLICASET\")\n            .backupEnabled(true)\n            .replicationSpecs(AdvancedClusterReplicationSpecArgs.builder()\n                .regionConfigs(AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                    .priority(7)\n                    .providerName(\"AWS\")\n                    .regionName(region)\n                    .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                        .instanceSize(\"M10\")\n                        .nodeCount(3)\n                        .build())\n                    .build())\n                .build())\n            .build());\n\n        var testCloudBackupSchedule = new CloudBackupSchedule(\"testCloudBackupSchedule\", CloudBackupScheduleArgs.builder()\n            .projectId(myCluster.projectId())\n            .clusterName(myCluster.name())\n            .referenceHourOfDay(3)\n            .referenceMinuteOfHour(45)\n            .restoreWindowDays(4)\n            .policyItemHourly(CloudBackupSchedulePolicyItemHourlyArgs.builder()\n                .frequencyInterval(1)\n                .retentionUnit(\"days\")\n                .retentionValue(7)\n                .build())\n            .policyItemDaily(CloudBackupSchedulePolicyItemDailyArgs.builder()\n                .frequencyInterval(1)\n                .retentionUnit(\"days\")\n                .retentionValue(7)\n                .build())\n            .policyItemWeeklies(CloudBackupSchedulePolicyItemWeeklyArgs.builder()\n                .frequencyInterval(1)\n                .retentionUnit(\"weeks\")\n                .retentionValue(4)\n                .build())\n            .policyItemMonthlies(CloudBackupSchedulePolicyItemMonthlyArgs.builder()\n                .frequencyInterval(1)\n                .retentionUnit(\"months\")\n                .retentionValue(12)\n                .build())\n            .policyItemYearlies(CloudBackupSchedulePolicyItemYearlyArgs.builder()\n                .frequencyInterval(1)\n                .retentionUnit(\"years\")\n                .retentionValue(1)\n                .build())\n            .build());\n\n        final var test = MongodbatlasFunctions.getCloudBackupSchedule(GetCloudBackupScheduleArgs.builder()\n            .projectId(testCloudBackupSchedule.projectId())\n            .clusterName(testCloudBackupSchedule.clusterName())\n            .build());\n\n        final var backupPolicy = MongodbatlasFunctions.getBackupCompliancePolicy(GetBackupCompliancePolicyArgs.builder()\n            .projectId(testCloudBackupSchedule.projectId())\n            .build());\n\n        var backupPolicyBackupCompliancePolicy = new BackupCompliancePolicy(\"backupPolicyBackupCompliancePolicy\", BackupCompliancePolicyArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .authorizedEmail(\"user@email.com\")\n            .authorizedUserFirstName(\"First\")\n            .authorizedUserLastName(\"Last\")\n            .copyProtectionEnabled(false)\n            .pitEnabled(false)\n            .encryptionAtRestEnabled(false)\n            .restoreWindowDays(7)\n            .onDemandPolicyItem(BackupCompliancePolicyOnDemandPolicyItemArgs.builder()\n                .frequencyInterval(1)\n                .retentionUnit(\"days\")\n                .retentionValue(3)\n                .build())\n            .policyItemHourly(BackupCompliancePolicyPolicyItemHourlyArgs.builder()\n                .frequencyInterval(1)\n                .retentionUnit(\"days\")\n                .retentionValue(7)\n                .build())\n            .policyItemDaily(BackupCompliancePolicyPolicyItemDailyArgs.builder()\n                .frequencyInterval(1)\n                .retentionUnit(\"days\")\n                .retentionValue(7)\n                .build())\n            .policyItemWeeklies(BackupCompliancePolicyPolicyItemWeeklyArgs.builder()\n                .frequencyInterval(1)\n                .retentionUnit(\"weeks\")\n                .retentionValue(4)\n                .build())\n            .policyItemMonthlies(BackupCompliancePolicyPolicyItemMonthlyArgs.builder()\n                .frequencyInterval(1)\n                .retentionUnit(\"months\")\n                .retentionValue(12)\n                .build())\n            .policyItemYearlies(BackupCompliancePolicyPolicyItemYearlyArgs.builder()\n                .frequencyInterval(1)\n                .retentionUnit(\"years\")\n                .retentionValue(1)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myCluster:\n    type: mongodbatlas:AdvancedCluster\n    name: my_cluster\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      name: clusterTest\n      clusterType: REPLICASET\n      backupEnabled: true # enable cloud backup snapshots\n      replicationSpecs:\n        - regionConfigs:\n            - priority: 7\n              providerName: AWS\n              regionName: ${region}\n              electableSpecs:\n                instanceSize: M10\n                nodeCount: 3\n  testCloudBackupSchedule:\n    type: mongodbatlas:CloudBackupSchedule\n    name: test\n    properties:\n      projectId: ${myCluster.projectId}\n      clusterName: ${myCluster.name}\n      referenceHourOfDay: 3\n      referenceMinuteOfHour: 45\n      restoreWindowDays: 4 # This will now add the desired policy items to the existing mongodbatlas_cloud_backup_schedule resource\n      policyItemHourly:\n        frequencyInterval: 1\n        retentionUnit: days\n        retentionValue: 7\n      policyItemDaily:\n        frequencyInterval: 1\n        retentionUnit: days\n        retentionValue: 7\n      policyItemWeeklies:\n        - frequencyInterval: 1\n          retentionUnit: weeks\n          retentionValue: 4\n      policyItemMonthlies:\n        - frequencyInterval: 1\n          retentionUnit: months\n          retentionValue: 12\n      policyItemYearlies:\n        - frequencyInterval: 1\n          retentionUnit: years\n          retentionValue: 1\n  backupPolicyBackupCompliancePolicy:\n    type: mongodbatlas:BackupCompliancePolicy\n    name: backup_policy\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      authorizedEmail: user@email.com\n      authorizedUserFirstName: First\n      authorizedUserLastName: Last\n      copyProtectionEnabled: false\n      pitEnabled: false\n      encryptionAtRestEnabled: false\n      restoreWindowDays: 7\n      onDemandPolicyItem:\n        frequencyInterval: 1\n        retentionUnit: days\n        retentionValue: 3\n      policyItemHourly:\n        frequencyInterval: 1\n        retentionUnit: days\n        retentionValue: 7\n      policyItemDaily:\n        frequencyInterval: 1\n        retentionUnit: days\n        retentionValue: 7\n      policyItemWeeklies:\n        - frequencyInterval: 1\n          retentionUnit: weeks\n          retentionValue: 4\n      policyItemMonthlies:\n        - frequencyInterval: 1\n          retentionUnit: months\n          retentionValue: 12\n      policyItemYearlies:\n        - frequencyInterval: 1\n          retentionUnit: years\n          retentionValue: 1\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getCloudBackupSchedule\n      Arguments:\n        projectId: ${testCloudBackupSchedule.projectId}\n        clusterName: ${testCloudBackupSchedule.clusterName}\n  backupPolicy:\n    fn::invoke:\n      Function: mongodbatlas:getBackupCompliancePolicy\n      Arguments:\n        projectId: ${testCloudBackupSchedule.projectId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nBackup Compliance Policy entries can be imported using project project_id  in the format `project_id`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/backupCompliancePolicy:BackupCompliancePolicy backup_policy 5d0f1f73cf09a29120e173cf\n```\nFor more information see: [MongoDB Atlas API Reference](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Cloud-Backups/operation/updateDataProtectionSettings) and [Backup Compliance Policy Prohibited Actions](https://www.mongodb.com/docs/atlas/backup/cloud-backup/backup-compliance-policy/#prohibited-actions).\n\n",
            "properties": {
                "authorizedEmail": {
                    "type": "string",
                    "description": "Email address of a security or legal representative for the Backup Compliance Policy who is authorized to update the Backup Compliance Policy settings.\n"
                },
                "authorizedUserFirstName": {
                    "type": "string",
                    "description": "First name of the user who authorized to update the Backup Compliance Policy settings.\n"
                },
                "authorizedUserLastName": {
                    "type": "string",
                    "description": "Last name of the user who authorized to update the Backup Compliance Policy settings.\n"
                },
                "copyProtectionEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable additional backup copies for the cluster. If unspecified, this value defaults to false.\n"
                },
                "encryptionAtRestEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether Encryption at Rest using Customer Key Management is required for all clusters with a Backup Compliance Policy. If unspecified, this value defaults to false.\n"
                },
                "onDemandPolicyItem": {
                    "$ref": "#/types/mongodbatlas:index/BackupCompliancePolicyOnDemandPolicyItem:BackupCompliancePolicyOnDemandPolicyItem"
                },
                "pitEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the cluster uses Continuous Cloud Backups with a Backup Compliance Policy. If unspecified, this value defaults to false.\n"
                },
                "policyItemDaily": {
                    "$ref": "#/types/mongodbatlas:index/BackupCompliancePolicyPolicyItemDaily:BackupCompliancePolicyPolicyItemDaily"
                },
                "policyItemHourly": {
                    "$ref": "#/types/mongodbatlas:index/BackupCompliancePolicyPolicyItemHourly:BackupCompliancePolicyPolicyItemHourly"
                },
                "policyItemMonthlies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/BackupCompliancePolicyPolicyItemMonthly:BackupCompliancePolicyPolicyItemMonthly"
                    }
                },
                "policyItemWeeklies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/BackupCompliancePolicyPolicyItemWeekly:BackupCompliancePolicyPolicyItemWeekly"
                    }
                },
                "policyItemYearlies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/BackupCompliancePolicyPolicyItemYearly:BackupCompliancePolicyPolicyItemYearly"
                    }
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies your project.\n"
                },
                "restoreWindowDays": {
                    "type": "integer",
                    "description": "Number of previous days that you can restore back to with Continuous Cloud Backup with a Backup Compliance Policy. You must specify a positive, non-zero integer, and the maximum retention window can't exceed the hourly retention time. This parameter applies only to Continuous Cloud Backups with a Backup Compliance Policy.\n"
                },
                "state": {
                    "type": "string",
                    "description": "Label that indicates the state of the Backup Compliance Policy settings. MongoDB Cloud ignores this setting when you enable or update the Backup Compliance Policy settings.\n"
                },
                "updatedDate": {
                    "type": "string",
                    "description": "ISO 8601 timestamp format in UTC that indicates when the user updated the Data Protection Policy settings. MongoDB Cloud ignores this setting when you enable or update the Backup Compliance Policy settings.\n"
                },
                "updatedUser": {
                    "type": "string",
                    "description": "Email address that identifies the user who updated the Backup Compliance Policy settings. MongoDB Cloud ignores this email setting when you enable or update the Backup Compliance Policy settings.\n"
                }
            },
            "required": [
                "authorizedEmail",
                "authorizedUserFirstName",
                "authorizedUserLastName",
                "onDemandPolicyItem",
                "projectId",
                "restoreWindowDays",
                "state",
                "updatedDate",
                "updatedUser"
            ],
            "inputProperties": {
                "authorizedEmail": {
                    "type": "string",
                    "description": "Email address of a security or legal representative for the Backup Compliance Policy who is authorized to update the Backup Compliance Policy settings.\n"
                },
                "authorizedUserFirstName": {
                    "type": "string",
                    "description": "First name of the user who authorized to update the Backup Compliance Policy settings.\n"
                },
                "authorizedUserLastName": {
                    "type": "string",
                    "description": "Last name of the user who authorized to update the Backup Compliance Policy settings.\n"
                },
                "copyProtectionEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable additional backup copies for the cluster. If unspecified, this value defaults to false.\n"
                },
                "encryptionAtRestEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether Encryption at Rest using Customer Key Management is required for all clusters with a Backup Compliance Policy. If unspecified, this value defaults to false.\n"
                },
                "onDemandPolicyItem": {
                    "$ref": "#/types/mongodbatlas:index/BackupCompliancePolicyOnDemandPolicyItem:BackupCompliancePolicyOnDemandPolicyItem"
                },
                "pitEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the cluster uses Continuous Cloud Backups with a Backup Compliance Policy. If unspecified, this value defaults to false.\n"
                },
                "policyItemDaily": {
                    "$ref": "#/types/mongodbatlas:index/BackupCompliancePolicyPolicyItemDaily:BackupCompliancePolicyPolicyItemDaily"
                },
                "policyItemHourly": {
                    "$ref": "#/types/mongodbatlas:index/BackupCompliancePolicyPolicyItemHourly:BackupCompliancePolicyPolicyItemHourly"
                },
                "policyItemMonthlies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/BackupCompliancePolicyPolicyItemMonthly:BackupCompliancePolicyPolicyItemMonthly"
                    }
                },
                "policyItemWeeklies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/BackupCompliancePolicyPolicyItemWeekly:BackupCompliancePolicyPolicyItemWeekly"
                    }
                },
                "policyItemYearlies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/BackupCompliancePolicyPolicyItemYearly:BackupCompliancePolicyPolicyItemYearly"
                    }
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies your project.\n"
                },
                "restoreWindowDays": {
                    "type": "integer",
                    "description": "Number of previous days that you can restore back to with Continuous Cloud Backup with a Backup Compliance Policy. You must specify a positive, non-zero integer, and the maximum retention window can't exceed the hourly retention time. This parameter applies only to Continuous Cloud Backups with a Backup Compliance Policy.\n"
                }
            },
            "requiredInputs": [
                "authorizedEmail",
                "authorizedUserFirstName",
                "authorizedUserLastName",
                "onDemandPolicyItem",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering BackupCompliancePolicy resources.\n",
                "properties": {
                    "authorizedEmail": {
                        "type": "string",
                        "description": "Email address of a security or legal representative for the Backup Compliance Policy who is authorized to update the Backup Compliance Policy settings.\n"
                    },
                    "authorizedUserFirstName": {
                        "type": "string",
                        "description": "First name of the user who authorized to update the Backup Compliance Policy settings.\n"
                    },
                    "authorizedUserLastName": {
                        "type": "string",
                        "description": "Last name of the user who authorized to update the Backup Compliance Policy settings.\n"
                    },
                    "copyProtectionEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether to enable additional backup copies for the cluster. If unspecified, this value defaults to false.\n"
                    },
                    "encryptionAtRestEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether Encryption at Rest using Customer Key Management is required for all clusters with a Backup Compliance Policy. If unspecified, this value defaults to false.\n"
                    },
                    "onDemandPolicyItem": {
                        "$ref": "#/types/mongodbatlas:index/BackupCompliancePolicyOnDemandPolicyItem:BackupCompliancePolicyOnDemandPolicyItem"
                    },
                    "pitEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether the cluster uses Continuous Cloud Backups with a Backup Compliance Policy. If unspecified, this value defaults to false.\n"
                    },
                    "policyItemDaily": {
                        "$ref": "#/types/mongodbatlas:index/BackupCompliancePolicyPolicyItemDaily:BackupCompliancePolicyPolicyItemDaily"
                    },
                    "policyItemHourly": {
                        "$ref": "#/types/mongodbatlas:index/BackupCompliancePolicyPolicyItemHourly:BackupCompliancePolicyPolicyItemHourly"
                    },
                    "policyItemMonthlies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/BackupCompliancePolicyPolicyItemMonthly:BackupCompliancePolicyPolicyItemMonthly"
                        }
                    },
                    "policyItemWeeklies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/BackupCompliancePolicyPolicyItemWeekly:BackupCompliancePolicyPolicyItemWeekly"
                        }
                    },
                    "policyItemYearlies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/BackupCompliancePolicyPolicyItemYearly:BackupCompliancePolicyPolicyItemYearly"
                        }
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies your project.\n"
                    },
                    "restoreWindowDays": {
                        "type": "integer",
                        "description": "Number of previous days that you can restore back to with Continuous Cloud Backup with a Backup Compliance Policy. You must specify a positive, non-zero integer, and the maximum retention window can't exceed the hourly retention time. This parameter applies only to Continuous Cloud Backups with a Backup Compliance Policy.\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "Label that indicates the state of the Backup Compliance Policy settings. MongoDB Cloud ignores this setting when you enable or update the Backup Compliance Policy settings.\n"
                    },
                    "updatedDate": {
                        "type": "string",
                        "description": "ISO 8601 timestamp format in UTC that indicates when the user updated the Data Protection Policy settings. MongoDB Cloud ignores this setting when you enable or update the Backup Compliance Policy settings.\n"
                    },
                    "updatedUser": {
                        "type": "string",
                        "description": "Email address that identifies the user who updated the Backup Compliance Policy settings. MongoDB Cloud ignores this email setting when you enable or update the Backup Compliance Policy settings.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/cloudBackupSchedule:CloudBackupSchedule": {
            "description": "\n\n## Import\n\nCloud Backup Schedule entries can be imported using project_id and cluster_name, in the format `PROJECTID-CLUSTERNAME`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/cloudBackupSchedule:CloudBackupSchedule test 5d0f1f73cf09a29120e173cf-MyClusterTest\n```\nFor more information see: [MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/cloud-backup/schedule/modify-one-schedule/)\n\n",
            "properties": {
                "autoExportEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether automatic export of cloud backup snapshots to the AWS bucket is enabled. Value can be one of the following:\n* true - enables automatic export of cloud backup snapshots to the AWS bucket\n* false - disables automatic export of cloud backup snapshots to the AWS bucket (default)\n"
                },
                "clusterId": {
                    "type": "string",
                    "description": "Unique identifier of the Atlas cluster.\n"
                },
                "clusterName": {
                    "type": "string",
                    "description": "The name of the Atlas cluster that contains the snapshot backup policy you want to retrieve.\n"
                },
                "copySettings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupScheduleCopySetting:CloudBackupScheduleCopySetting"
                    },
                    "description": "List that contains a document for each copy setting item in the desired backup policy. See below\n"
                },
                "export": {
                    "$ref": "#/types/mongodbatlas:index/CloudBackupScheduleExport:CloudBackupScheduleExport",
                    "description": "Policy for automatically exporting Cloud Backup Snapshots. See below\n"
                },
                "idPolicy": {
                    "type": "string",
                    "description": "Unique identifier of the backup policy.\n"
                },
                "nextSnapshot": {
                    "type": "string",
                    "description": "Timestamp in the number of seconds that have elapsed since the UNIX epoch when Atlas takes the next snapshot.\n"
                },
                "policyItemDaily": {
                    "$ref": "#/types/mongodbatlas:index/CloudBackupSchedulePolicyItemDaily:CloudBackupSchedulePolicyItemDaily",
                    "description": "Daily policy item. See below\n"
                },
                "policyItemHourly": {
                    "$ref": "#/types/mongodbatlas:index/CloudBackupSchedulePolicyItemHourly:CloudBackupSchedulePolicyItemHourly",
                    "description": "Hourly policy item. See below\n"
                },
                "policyItemMonthlies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupSchedulePolicyItemMonthly:CloudBackupSchedulePolicyItemMonthly"
                    },
                    "description": "Monthly policy item. See below\n"
                },
                "policyItemWeeklies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupSchedulePolicyItemWeekly:CloudBackupSchedulePolicyItemWeekly"
                    },
                    "description": "Weekly policy item. See below\n"
                },
                "policyItemYearlies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupSchedulePolicyItemYearly:CloudBackupSchedulePolicyItemYearly"
                    },
                    "description": "Yearly policy item. See below\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier of the project for the Atlas cluster.\n"
                },
                "referenceHourOfDay": {
                    "type": "integer",
                    "description": "UTC Hour of day between 0 and 23, inclusive, representing which hour of the day that Atlas takes snapshots for backup policy items.\n"
                },
                "referenceMinuteOfHour": {
                    "type": "integer",
                    "description": "UTC Minutes after `reference_hour_of_day` that Atlas takes snapshots for backup policy items. Must be between 0 and 59, inclusive.\n"
                },
                "restoreWindowDays": {
                    "type": "integer",
                    "description": "Number of days back in time you can restore to with point-in-time accuracy. Must be a positive, non-zero integer.\n"
                },
                "updateSnapshots": {
                    "type": "boolean"
                },
                "useOrgAndGroupNamesInExportPrefix": {
                    "type": "boolean",
                    "description": "Specify true to use organization and project names instead of organization and project UUIDs in the path for the metadata files that Atlas uploads to your S3 bucket after it finishes exporting the snapshots. To learn more about the metadata files that Atlas uploads, see [Export Cloud Backup Snapshot](https://www.mongodb.com/docs/atlas/backup/cloud-backup/export/#std-label-cloud-provider-snapshot-export).\n"
                }
            },
            "required": [
                "autoExportEnabled",
                "clusterId",
                "clusterName",
                "export",
                "idPolicy",
                "nextSnapshot",
                "projectId",
                "referenceHourOfDay",
                "referenceMinuteOfHour",
                "restoreWindowDays",
                "updateSnapshots",
                "useOrgAndGroupNamesInExportPrefix"
            ],
            "inputProperties": {
                "autoExportEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether automatic export of cloud backup snapshots to the AWS bucket is enabled. Value can be one of the following:\n* true - enables automatic export of cloud backup snapshots to the AWS bucket\n* false - disables automatic export of cloud backup snapshots to the AWS bucket (default)\n"
                },
                "clusterName": {
                    "type": "string",
                    "description": "The name of the Atlas cluster that contains the snapshot backup policy you want to retrieve.\n"
                },
                "copySettings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupScheduleCopySetting:CloudBackupScheduleCopySetting"
                    },
                    "description": "List that contains a document for each copy setting item in the desired backup policy. See below\n"
                },
                "export": {
                    "$ref": "#/types/mongodbatlas:index/CloudBackupScheduleExport:CloudBackupScheduleExport",
                    "description": "Policy for automatically exporting Cloud Backup Snapshots. See below\n"
                },
                "policyItemDaily": {
                    "$ref": "#/types/mongodbatlas:index/CloudBackupSchedulePolicyItemDaily:CloudBackupSchedulePolicyItemDaily",
                    "description": "Daily policy item. See below\n"
                },
                "policyItemHourly": {
                    "$ref": "#/types/mongodbatlas:index/CloudBackupSchedulePolicyItemHourly:CloudBackupSchedulePolicyItemHourly",
                    "description": "Hourly policy item. See below\n"
                },
                "policyItemMonthlies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupSchedulePolicyItemMonthly:CloudBackupSchedulePolicyItemMonthly"
                    },
                    "description": "Monthly policy item. See below\n"
                },
                "policyItemWeeklies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupSchedulePolicyItemWeekly:CloudBackupSchedulePolicyItemWeekly"
                    },
                    "description": "Weekly policy item. See below\n"
                },
                "policyItemYearlies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupSchedulePolicyItemYearly:CloudBackupSchedulePolicyItemYearly"
                    },
                    "description": "Yearly policy item. See below\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier of the project for the Atlas cluster.\n",
                    "willReplaceOnChanges": true
                },
                "referenceHourOfDay": {
                    "type": "integer",
                    "description": "UTC Hour of day between 0 and 23, inclusive, representing which hour of the day that Atlas takes snapshots for backup policy items.\n"
                },
                "referenceMinuteOfHour": {
                    "type": "integer",
                    "description": "UTC Minutes after `reference_hour_of_day` that Atlas takes snapshots for backup policy items. Must be between 0 and 59, inclusive.\n"
                },
                "restoreWindowDays": {
                    "type": "integer",
                    "description": "Number of days back in time you can restore to with point-in-time accuracy. Must be a positive, non-zero integer.\n"
                },
                "updateSnapshots": {
                    "type": "boolean"
                },
                "useOrgAndGroupNamesInExportPrefix": {
                    "type": "boolean",
                    "description": "Specify true to use organization and project names instead of organization and project UUIDs in the path for the metadata files that Atlas uploads to your S3 bucket after it finishes exporting the snapshots. To learn more about the metadata files that Atlas uploads, see [Export Cloud Backup Snapshot](https://www.mongodb.com/docs/atlas/backup/cloud-backup/export/#std-label-cloud-provider-snapshot-export).\n"
                }
            },
            "requiredInputs": [
                "clusterName",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudBackupSchedule resources.\n",
                "properties": {
                    "autoExportEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether automatic export of cloud backup snapshots to the AWS bucket is enabled. Value can be one of the following:\n* true - enables automatic export of cloud backup snapshots to the AWS bucket\n* false - disables automatic export of cloud backup snapshots to the AWS bucket (default)\n"
                    },
                    "clusterId": {
                        "type": "string",
                        "description": "Unique identifier of the Atlas cluster.\n"
                    },
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the Atlas cluster that contains the snapshot backup policy you want to retrieve.\n"
                    },
                    "copySettings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/CloudBackupScheduleCopySetting:CloudBackupScheduleCopySetting"
                        },
                        "description": "List that contains a document for each copy setting item in the desired backup policy. See below\n"
                    },
                    "export": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupScheduleExport:CloudBackupScheduleExport",
                        "description": "Policy for automatically exporting Cloud Backup Snapshots. See below\n"
                    },
                    "idPolicy": {
                        "type": "string",
                        "description": "Unique identifier of the backup policy.\n"
                    },
                    "nextSnapshot": {
                        "type": "string",
                        "description": "Timestamp in the number of seconds that have elapsed since the UNIX epoch when Atlas takes the next snapshot.\n"
                    },
                    "policyItemDaily": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupSchedulePolicyItemDaily:CloudBackupSchedulePolicyItemDaily",
                        "description": "Daily policy item. See below\n"
                    },
                    "policyItemHourly": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupSchedulePolicyItemHourly:CloudBackupSchedulePolicyItemHourly",
                        "description": "Hourly policy item. See below\n"
                    },
                    "policyItemMonthlies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/CloudBackupSchedulePolicyItemMonthly:CloudBackupSchedulePolicyItemMonthly"
                        },
                        "description": "Monthly policy item. See below\n"
                    },
                    "policyItemWeeklies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/CloudBackupSchedulePolicyItemWeekly:CloudBackupSchedulePolicyItemWeekly"
                        },
                        "description": "Weekly policy item. See below\n"
                    },
                    "policyItemYearlies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/CloudBackupSchedulePolicyItemYearly:CloudBackupSchedulePolicyItemYearly"
                        },
                        "description": "Yearly policy item. See below\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster.\n",
                        "willReplaceOnChanges": true
                    },
                    "referenceHourOfDay": {
                        "type": "integer",
                        "description": "UTC Hour of day between 0 and 23, inclusive, representing which hour of the day that Atlas takes snapshots for backup policy items.\n"
                    },
                    "referenceMinuteOfHour": {
                        "type": "integer",
                        "description": "UTC Minutes after `reference_hour_of_day` that Atlas takes snapshots for backup policy items. Must be between 0 and 59, inclusive.\n"
                    },
                    "restoreWindowDays": {
                        "type": "integer",
                        "description": "Number of days back in time you can restore to with point-in-time accuracy. Must be a positive, non-zero integer.\n"
                    },
                    "updateSnapshots": {
                        "type": "boolean"
                    },
                    "useOrgAndGroupNamesInExportPrefix": {
                        "type": "boolean",
                        "description": "Specify true to use organization and project names instead of organization and project UUIDs in the path for the metadata files that Atlas uploads to your S3 bucket after it finishes exporting the snapshots. To learn more about the metadata files that Atlas uploads, see [Export Cloud Backup Snapshot](https://www.mongodb.com/docs/atlas/backup/cloud-backup/export/#std-label-cloud-provider-snapshot-export).\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/cloudBackupSnapshot:CloudBackupSnapshot": {
            "description": "## # Resource: mongodbatlas.CloudBackupSnapshot\n\n`mongodbatlas.CloudBackupSnapshot` provides a resource to take a cloud backup snapshot on demand.\nOn-demand snapshots happen immediately, unlike scheduled snapshots which occur at regular intervals. If there is already an on-demand snapshot with a status of queued or inProgress, you must wait until Atlas has completed the on-demand snapshot before taking another.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n\u003e **NOTE:** If Backup Compliance Policy is enabled for the project for which this backup schedule is defined, you cannot delete a backup snapshot or decrease the retention time for a snapshot after it's taken.  See [Backup Compliance Policy Prohibited Actions and Considerations](https://www.mongodb.com/docs/atlas/backup/cloud-backup/backup-compliance-policy/#configure-a-backup-compliance-policy).\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst myCluster = new mongodbatlas.AdvancedCluster(\"my_cluster\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    name: \"MyCluster\",\n    clusterType: \"REPLICASET\",\n    backupEnabled: true,\n    replicationSpecs: [{\n        regionConfigs: [{\n            priority: 7,\n            providerName: \"AWS\",\n            regionName: \"EU_WEST_2\",\n            electableSpecs: {\n                instanceSize: \"M10\",\n                nodeCount: 3,\n            },\n        }],\n    }],\n});\nconst test = new mongodbatlas.CloudBackupSnapshot(\"test\", {\n    projectId: myCluster.projectId,\n    clusterName: myCluster.name,\n    description: \"myDescription\",\n    retentionInDays: 1,\n});\nconst testCloudBackupSnapshotRestoreJob = new mongodbatlas.CloudBackupSnapshotRestoreJob(\"test\", {\n    projectId: test.projectId,\n    clusterName: test.clusterName,\n    snapshotId: test.snapshotId,\n    deliveryTypeConfig: {\n        download: true,\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nmy_cluster = mongodbatlas.AdvancedCluster(\"my_cluster\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    name=\"MyCluster\",\n    cluster_type=\"REPLICASET\",\n    backup_enabled=True,\n    replication_specs=[{\n        \"region_configs\": [{\n            \"priority\": 7,\n            \"provider_name\": \"AWS\",\n            \"region_name\": \"EU_WEST_2\",\n            \"electable_specs\": {\n                \"instance_size\": \"M10\",\n                \"node_count\": 3,\n            },\n        }],\n    }])\ntest = mongodbatlas.CloudBackupSnapshot(\"test\",\n    project_id=my_cluster.project_id,\n    cluster_name=my_cluster.name,\n    description=\"myDescription\",\n    retention_in_days=1)\ntest_cloud_backup_snapshot_restore_job = mongodbatlas.CloudBackupSnapshotRestoreJob(\"test\",\n    project_id=test.project_id,\n    cluster_name=test.cluster_name,\n    snapshot_id=test.snapshot_id,\n    delivery_type_config={\n        \"download\": True,\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myCluster = new Mongodbatlas.AdvancedCluster(\"my_cluster\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        Name = \"MyCluster\",\n        ClusterType = \"REPLICASET\",\n        BackupEnabled = true,\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        Priority = 7,\n                        ProviderName = \"AWS\",\n                        RegionName = \"EU_WEST_2\",\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M10\",\n                            NodeCount = 3,\n                        },\n                    },\n                },\n            },\n        },\n    });\n\n    var test = new Mongodbatlas.CloudBackupSnapshot(\"test\", new()\n    {\n        ProjectId = myCluster.ProjectId,\n        ClusterName = myCluster.Name,\n        Description = \"myDescription\",\n        RetentionInDays = 1,\n    });\n\n    var testCloudBackupSnapshotRestoreJob = new Mongodbatlas.CloudBackupSnapshotRestoreJob(\"test\", new()\n    {\n        ProjectId = test.ProjectId,\n        ClusterName = test.ClusterName,\n        SnapshotId = test.SnapshotId,\n        DeliveryTypeConfig = new Mongodbatlas.Inputs.CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs\n        {\n            Download = true,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmyCluster, err := mongodbatlas.NewAdvancedCluster(ctx, \"my_cluster\", \u0026mongodbatlas.AdvancedClusterArgs{\n\t\t\tProjectId:     pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tName:          pulumi.String(\"MyCluster\"),\n\t\t\tClusterType:   pulumi.String(\"REPLICASET\"),\n\t\t\tBackupEnabled: pulumi.Bool(true),\n\t\t\tReplicationSpecs: mongodbatlas.AdvancedClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tPriority:     pulumi.Int(7),\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"EU_WEST_2\"),\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M10\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(3),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttest, err := mongodbatlas.NewCloudBackupSnapshot(ctx, \"test\", \u0026mongodbatlas.CloudBackupSnapshotArgs{\n\t\t\tProjectId:       myCluster.ProjectId,\n\t\t\tClusterName:     myCluster.Name,\n\t\t\tDescription:     pulumi.String(\"myDescription\"),\n\t\t\tRetentionInDays: pulumi.Int(1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewCloudBackupSnapshotRestoreJob(ctx, \"test\", \u0026mongodbatlas.CloudBackupSnapshotRestoreJobArgs{\n\t\t\tProjectId:   test.ProjectId,\n\t\t\tClusterName: test.ClusterName,\n\t\t\tSnapshotId:  test.SnapshotId,\n\t\t\tDeliveryTypeConfig: \u0026mongodbatlas.CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs{\n\t\t\t\tDownload: pulumi.Bool(true),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AdvancedCluster;\nimport com.pulumi.mongodbatlas.AdvancedClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.AdvancedClusterReplicationSpecArgs;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshot;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotArgs;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotRestoreJob;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotRestoreJobArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myCluster = new AdvancedCluster(\"myCluster\", AdvancedClusterArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .name(\"MyCluster\")\n            .clusterType(\"REPLICASET\")\n            .backupEnabled(true)\n            .replicationSpecs(AdvancedClusterReplicationSpecArgs.builder()\n                .regionConfigs(AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                    .priority(7)\n                    .providerName(\"AWS\")\n                    .regionName(\"EU_WEST_2\")\n                    .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                        .instanceSize(\"M10\")\n                        .nodeCount(3)\n                        .build())\n                    .build())\n                .build())\n            .build());\n\n        var test = new CloudBackupSnapshot(\"test\", CloudBackupSnapshotArgs.builder()\n            .projectId(myCluster.projectId())\n            .clusterName(myCluster.name())\n            .description(\"myDescription\")\n            .retentionInDays(1)\n            .build());\n\n        var testCloudBackupSnapshotRestoreJob = new CloudBackupSnapshotRestoreJob(\"testCloudBackupSnapshotRestoreJob\", CloudBackupSnapshotRestoreJobArgs.builder()\n            .projectId(test.projectId())\n            .clusterName(test.clusterName())\n            .snapshotId(test.snapshotId())\n            .deliveryTypeConfig(CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs.builder()\n                .download(true)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myCluster:\n    type: mongodbatlas:AdvancedCluster\n    name: my_cluster\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      name: MyCluster\n      clusterType: REPLICASET\n      backupEnabled: true # enable cloud backup snapshots\n      replicationSpecs:\n        - regionConfigs:\n            - priority: 7\n              providerName: AWS\n              regionName: EU_WEST_2\n              electableSpecs:\n                instanceSize: M10\n                nodeCount: 3\n  test:\n    type: mongodbatlas:CloudBackupSnapshot\n    properties:\n      projectId: ${myCluster.projectId}\n      clusterName: ${myCluster.name}\n      description: myDescription\n      retentionInDays: 1\n  testCloudBackupSnapshotRestoreJob:\n    type: mongodbatlas:CloudBackupSnapshotRestoreJob\n    name: test\n    properties:\n      projectId: ${test.projectId}\n      clusterName: ${test.clusterName}\n      snapshotId: ${test.snapshotId}\n      deliveryTypeConfig:\n        download: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nCloud Backup Snapshot entries can be imported using project project_id, cluster_name and snapshot_id (Unique identifier of the snapshot), in the format `PROJECTID-CLUSTERNAME-SNAPSHOTID`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/cloudBackupSnapshot:CloudBackupSnapshot test 5d0f1f73cf09a29120e173cf-MyClusterTest-5d116d82014b764445b2f9b5\n```\nFor more information see: [MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/cloud-backup/backup/backups/)\n\n",
            "properties": {
                "cloudProvider": {
                    "type": "string",
                    "description": "Cloud provider that stores this snapshot.\n"
                },
                "clusterName": {
                    "type": "string",
                    "description": "The name of the Atlas cluster that contains the snapshots you want to retrieve.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "UTC ISO 8601 formatted point in time when Atlas took the snapshot.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the on-demand snapshot.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "UTC ISO 8601 formatted point in time when Atlas will delete the snapshot.\n"
                },
                "masterKeyUuid": {
                    "type": "string",
                    "description": "Unique ID of the AWS KMS Customer Master Key used to encrypt the snapshot. Only visible for clusters using Encryption at Rest via Customer KMS.\n"
                },
                "members": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupSnapshotMember:CloudBackupSnapshotMember"
                    },
                    "description": "Block of List of snapshots and the cloud provider where the snapshots are stored. Atlas returns this parameter when `type` is `shardedCluster`. See below\n"
                },
                "mongodVersion": {
                    "type": "string",
                    "description": "Version of the MongoDB server.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier of the project for the Atlas cluster.\n"
                },
                "replicaSetName": {
                    "type": "string",
                    "description": "Label given to a shard or config server from which Atlas took this snapshot.\n"
                },
                "retentionInDays": {
                    "type": "integer",
                    "description": "The number of days that Atlas should retain the on-demand snapshot. Must be at least 1.\n"
                },
                "snapshotId": {
                    "type": "string",
                    "description": "Unique identifier of the snapshot.\n"
                },
                "snapshotIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Unique identifiers of the snapshots created for the shards and config server for a sharded cluster. Atlas returns this parameter when `type` is `shardedCluster`. These identifiers should match those given in the `members[n].id` parameters. This allows you to map a snapshot to its shard or config server name.\n"
                },
                "snapshotType": {
                    "type": "string",
                    "description": "Specified the type of snapshot. Valid values are onDemand and scheduled.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Current status of the snapshot. One of the following values will be returned: queued, inProgress, completed, failed.\n"
                },
                "storageSizeBytes": {
                    "type": "integer",
                    "description": "Specifies the size of the snapshot in bytes.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Specifies the type of cluster: replicaSet or shardedCluster.\n"
                }
            },
            "required": [
                "cloudProvider",
                "clusterName",
                "createdAt",
                "description",
                "expiresAt",
                "masterKeyUuid",
                "members",
                "mongodVersion",
                "projectId",
                "replicaSetName",
                "retentionInDays",
                "snapshotId",
                "snapshotIds",
                "snapshotType",
                "status",
                "storageSizeBytes",
                "type"
            ],
            "inputProperties": {
                "clusterName": {
                    "type": "string",
                    "description": "The name of the Atlas cluster that contains the snapshots you want to retrieve.\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "Description of the on-demand snapshot.\n",
                    "willReplaceOnChanges": true
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier of the project for the Atlas cluster.\n",
                    "willReplaceOnChanges": true
                },
                "retentionInDays": {
                    "type": "integer",
                    "description": "The number of days that Atlas should retain the on-demand snapshot. Must be at least 1.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "clusterName",
                "description",
                "projectId",
                "retentionInDays"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudBackupSnapshot resources.\n",
                "properties": {
                    "cloudProvider": {
                        "type": "string",
                        "description": "Cloud provider that stores this snapshot.\n"
                    },
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the Atlas cluster that contains the snapshots you want to retrieve.\n",
                        "willReplaceOnChanges": true
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "UTC ISO 8601 formatted point in time when Atlas took the snapshot.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of the on-demand snapshot.\n",
                        "willReplaceOnChanges": true
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "UTC ISO 8601 formatted point in time when Atlas will delete the snapshot.\n"
                    },
                    "masterKeyUuid": {
                        "type": "string",
                        "description": "Unique ID of the AWS KMS Customer Master Key used to encrypt the snapshot. Only visible for clusters using Encryption at Rest via Customer KMS.\n"
                    },
                    "members": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/CloudBackupSnapshotMember:CloudBackupSnapshotMember"
                        },
                        "description": "Block of List of snapshots and the cloud provider where the snapshots are stored. Atlas returns this parameter when `type` is `shardedCluster`. See below\n"
                    },
                    "mongodVersion": {
                        "type": "string",
                        "description": "Version of the MongoDB server.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster.\n",
                        "willReplaceOnChanges": true
                    },
                    "replicaSetName": {
                        "type": "string",
                        "description": "Label given to a shard or config server from which Atlas took this snapshot.\n"
                    },
                    "retentionInDays": {
                        "type": "integer",
                        "description": "The number of days that Atlas should retain the on-demand snapshot. Must be at least 1.\n",
                        "willReplaceOnChanges": true
                    },
                    "snapshotId": {
                        "type": "string",
                        "description": "Unique identifier of the snapshot.\n"
                    },
                    "snapshotIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Unique identifiers of the snapshots created for the shards and config server for a sharded cluster. Atlas returns this parameter when `type` is `shardedCluster`. These identifiers should match those given in the `members[n].id` parameters. This allows you to map a snapshot to its shard or config server name.\n"
                    },
                    "snapshotType": {
                        "type": "string",
                        "description": "Specified the type of snapshot. Valid values are onDemand and scheduled.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Current status of the snapshot. One of the following values will be returned: queued, inProgress, completed, failed.\n"
                    },
                    "storageSizeBytes": {
                        "type": "integer",
                        "description": "Specifies the size of the snapshot in bytes.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Specifies the type of cluster: replicaSet or shardedCluster.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/cloudBackupSnapshotExportBucket:CloudBackupSnapshotExportBucket": {
            "description": "## # Resource: mongodbatlas.CloudBackupSnapshotExportBucket\n\n`mongodbatlas.CloudBackupSnapshotExportBucket` allows you to create an export snapshot bucket for the specified project. \n\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n## Example Usage\n\n### AWS Example\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.CloudBackupSnapshotExportBucket(\"test\", {\n    projectId: \"{PROJECT_ID}\",\n    iamRoleId: \"{IAM_ROLE_ID}\",\n    bucketName: \"example-bucket\",\n    cloudProvider: \"AWS\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.CloudBackupSnapshotExportBucket(\"test\",\n    project_id=\"{PROJECT_ID}\",\n    iam_role_id=\"{IAM_ROLE_ID}\",\n    bucket_name=\"example-bucket\",\n    cloud_provider=\"AWS\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.CloudBackupSnapshotExportBucket(\"test\", new()\n    {\n        ProjectId = \"{PROJECT_ID}\",\n        IamRoleId = \"{IAM_ROLE_ID}\",\n        BucketName = \"example-bucket\",\n        CloudProvider = \"AWS\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewCloudBackupSnapshotExportBucket(ctx, \"test\", \u0026mongodbatlas.CloudBackupSnapshotExportBucketArgs{\n\t\t\tProjectId:     pulumi.String(\"{PROJECT_ID}\"),\n\t\t\tIamRoleId:     pulumi.String(\"{IAM_ROLE_ID}\"),\n\t\t\tBucketName:    pulumi.String(\"example-bucket\"),\n\t\t\tCloudProvider: pulumi.String(\"AWS\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportBucket;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportBucketArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new CloudBackupSnapshotExportBucket(\"test\", CloudBackupSnapshotExportBucketArgs.builder()\n            .projectId(\"{PROJECT_ID}\")\n            .iamRoleId(\"{IAM_ROLE_ID}\")\n            .bucketName(\"example-bucket\")\n            .cloudProvider(\"AWS\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:CloudBackupSnapshotExportBucket\n    properties:\n      projectId: '{PROJECT_ID}'\n      iamRoleId: '{IAM_ROLE_ID}'\n      bucketName: example-bucket\n      cloudProvider: AWS\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Azure Example\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.CloudBackupSnapshotExportBucket(\"test\", {\n    projectId: \"{PROJECT_ID}\",\n    roleId: \"{ROLE_ID}\",\n    serviceUrl: \"{SERVICE_URL}\",\n    tenantId: \"{TENANT_ID}\",\n    bucketName: \"example-bucket\",\n    cloudProvider: \"AZURE\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.CloudBackupSnapshotExportBucket(\"test\",\n    project_id=\"{PROJECT_ID}\",\n    role_id=\"{ROLE_ID}\",\n    service_url=\"{SERVICE_URL}\",\n    tenant_id=\"{TENANT_ID}\",\n    bucket_name=\"example-bucket\",\n    cloud_provider=\"AZURE\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.CloudBackupSnapshotExportBucket(\"test\", new()\n    {\n        ProjectId = \"{PROJECT_ID}\",\n        RoleId = \"{ROLE_ID}\",\n        ServiceUrl = \"{SERVICE_URL}\",\n        TenantId = \"{TENANT_ID}\",\n        BucketName = \"example-bucket\",\n        CloudProvider = \"AZURE\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewCloudBackupSnapshotExportBucket(ctx, \"test\", \u0026mongodbatlas.CloudBackupSnapshotExportBucketArgs{\n\t\t\tProjectId:     pulumi.String(\"{PROJECT_ID}\"),\n\t\t\tRoleId:        pulumi.String(\"{ROLE_ID}\"),\n\t\t\tServiceUrl:    pulumi.String(\"{SERVICE_URL}\"),\n\t\t\tTenantId:      pulumi.String(\"{TENANT_ID}\"),\n\t\t\tBucketName:    pulumi.String(\"example-bucket\"),\n\t\t\tCloudProvider: pulumi.String(\"AZURE\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportBucket;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportBucketArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new CloudBackupSnapshotExportBucket(\"test\", CloudBackupSnapshotExportBucketArgs.builder()\n            .projectId(\"{PROJECT_ID}\")\n            .roleId(\"{ROLE_ID}\")\n            .serviceUrl(\"{SERVICE_URL}\")\n            .tenantId(\"{TENANT_ID}\")\n            .bucketName(\"example-bucket\")\n            .cloudProvider(\"AZURE\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:CloudBackupSnapshotExportBucket\n    properties:\n      projectId: '{PROJECT_ID}'\n      roleId: '{ROLE_ID}'\n      serviceUrl: '{SERVICE_URL}'\n      tenantId: '{TENANT_ID}'\n      bucketName: example-bucket\n      cloudProvider: AZURE\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nCloud Backup Snapshot Export Backup entries can be imported using project project_id, and bucket_id (Unique identifier of the snapshot export bucket), in the format `PROJECTID-BUCKETID`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/cloudBackupSnapshotExportBucket:CloudBackupSnapshotExportBucket test 5d0f1f73cf09a29120e173cf-5d116d82014b764445b2f9b5\n```\nFor more information see: [MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/cloud-backup/export/create-one-export-bucket/)\n\n",
            "properties": {
                "bucketName": {
                    "type": "string",
                    "description": "Name of the bucket that the provided role ID is authorized to access.\n"
                },
                "cloudProvider": {
                    "type": "string",
                    "description": "Name of the provider of the cloud service where Atlas can access the S3 bucket.\n"
                },
                "exportBucketId": {
                    "type": "string",
                    "description": "Unique identifier of the snapshot export bucket.\n"
                },
                "iamRoleId": {
                    "type": "string",
                    "description": "Unique identifier of the role that Atlas can use to access the bucket. Required if `cloud_provider` is set to `AWS`.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier of the project for the Atlas cluster.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "Unique identifier of the Azure Service Principal that Atlas can use to access the Azure Blob Storage Container. Required if `cloud_provider` is set to `AZURE`.\n"
                },
                "serviceUrl": {
                    "type": "string",
                    "description": "URL that identifies the blob Endpoint of the Azure Blob Storage Account. Required if `cloud_provider` is set to `AZURE`.\n"
                },
                "tenantId": {
                    "type": "string",
                    "description": "UUID that identifies the Azure Active Directory Tenant ID. Required if `cloud_provider` is set to `AZURE`.\n"
                }
            },
            "required": [
                "bucketName",
                "cloudProvider",
                "exportBucketId",
                "projectId"
            ],
            "inputProperties": {
                "bucketName": {
                    "type": "string",
                    "description": "Name of the bucket that the provided role ID is authorized to access.\n",
                    "willReplaceOnChanges": true
                },
                "cloudProvider": {
                    "type": "string",
                    "description": "Name of the provider of the cloud service where Atlas can access the S3 bucket.\n",
                    "willReplaceOnChanges": true
                },
                "iamRoleId": {
                    "type": "string",
                    "description": "Unique identifier of the role that Atlas can use to access the bucket. Required if `cloud_provider` is set to `AWS`.\n",
                    "willReplaceOnChanges": true
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier of the project for the Atlas cluster.\n",
                    "willReplaceOnChanges": true
                },
                "roleId": {
                    "type": "string",
                    "description": "Unique identifier of the Azure Service Principal that Atlas can use to access the Azure Blob Storage Container. Required if `cloud_provider` is set to `AZURE`.\n",
                    "willReplaceOnChanges": true
                },
                "serviceUrl": {
                    "type": "string",
                    "description": "URL that identifies the blob Endpoint of the Azure Blob Storage Account. Required if `cloud_provider` is set to `AZURE`.\n",
                    "willReplaceOnChanges": true
                },
                "tenantId": {
                    "type": "string",
                    "description": "UUID that identifies the Azure Active Directory Tenant ID. Required if `cloud_provider` is set to `AZURE`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "bucketName",
                "cloudProvider",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudBackupSnapshotExportBucket resources.\n",
                "properties": {
                    "bucketName": {
                        "type": "string",
                        "description": "Name of the bucket that the provided role ID is authorized to access.\n",
                        "willReplaceOnChanges": true
                    },
                    "cloudProvider": {
                        "type": "string",
                        "description": "Name of the provider of the cloud service where Atlas can access the S3 bucket.\n",
                        "willReplaceOnChanges": true
                    },
                    "exportBucketId": {
                        "type": "string",
                        "description": "Unique identifier of the snapshot export bucket.\n"
                    },
                    "iamRoleId": {
                        "type": "string",
                        "description": "Unique identifier of the role that Atlas can use to access the bucket. Required if `cloud_provider` is set to `AWS`.\n",
                        "willReplaceOnChanges": true
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster.\n",
                        "willReplaceOnChanges": true
                    },
                    "roleId": {
                        "type": "string",
                        "description": "Unique identifier of the Azure Service Principal that Atlas can use to access the Azure Blob Storage Container. Required if `cloud_provider` is set to `AZURE`.\n",
                        "willReplaceOnChanges": true
                    },
                    "serviceUrl": {
                        "type": "string",
                        "description": "URL that identifies the blob Endpoint of the Azure Blob Storage Account. Required if `cloud_provider` is set to `AZURE`.\n",
                        "willReplaceOnChanges": true
                    },
                    "tenantId": {
                        "type": "string",
                        "description": "UUID that identifies the Azure Active Directory Tenant ID. Required if `cloud_provider` is set to `AZURE`.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/cloudBackupSnapshotExportJob:CloudBackupSnapshotExportJob": {
            "description": "## # Resource: mongodbatlas.CloudBackupSnapshotExportJob\n\n`mongodbatlas.CloudBackupSnapshotExportJob` allows you to create a cloud backup snapshot export job for the specified project. \n\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n## Example Usage\n\n### Export one snapshot\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.CloudBackupSnapshotExportBucket(\"test\", {\n    projectId: \"{PROJECT_ID}\",\n    iamRoleId: \"{IAM_ROLE_ID}\",\n    bucketName: \"example_bucket\",\n    cloudProvider: \"AWS\",\n});\nconst testCloudBackupSnapshotExportJob = new mongodbatlas.CloudBackupSnapshotExportJob(\"test\", {\n    projectId: \"{PROJECT_ID}\",\n    clusterName: \"{CLUSTER_NAME}\",\n    snapshotId: \"{SNAPSHOT_ID}\",\n    exportBucketId: test.exportBucketId,\n    customDatas: [{\n        key: \"exported by\",\n        value: \"myName\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.CloudBackupSnapshotExportBucket(\"test\",\n    project_id=\"{PROJECT_ID}\",\n    iam_role_id=\"{IAM_ROLE_ID}\",\n    bucket_name=\"example_bucket\",\n    cloud_provider=\"AWS\")\ntest_cloud_backup_snapshot_export_job = mongodbatlas.CloudBackupSnapshotExportJob(\"test\",\n    project_id=\"{PROJECT_ID}\",\n    cluster_name=\"{CLUSTER_NAME}\",\n    snapshot_id=\"{SNAPSHOT_ID}\",\n    export_bucket_id=test.export_bucket_id,\n    custom_datas=[{\n        \"key\": \"exported by\",\n        \"value\": \"myName\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.CloudBackupSnapshotExportBucket(\"test\", new()\n    {\n        ProjectId = \"{PROJECT_ID}\",\n        IamRoleId = \"{IAM_ROLE_ID}\",\n        BucketName = \"example_bucket\",\n        CloudProvider = \"AWS\",\n    });\n\n    var testCloudBackupSnapshotExportJob = new Mongodbatlas.CloudBackupSnapshotExportJob(\"test\", new()\n    {\n        ProjectId = \"{PROJECT_ID}\",\n        ClusterName = \"{CLUSTER_NAME}\",\n        SnapshotId = \"{SNAPSHOT_ID}\",\n        ExportBucketId = test.ExportBucketId,\n        CustomDatas = new[]\n        {\n            new Mongodbatlas.Inputs.CloudBackupSnapshotExportJobCustomDataArgs\n            {\n                Key = \"exported by\",\n                Value = \"myName\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := mongodbatlas.NewCloudBackupSnapshotExportBucket(ctx, \"test\", \u0026mongodbatlas.CloudBackupSnapshotExportBucketArgs{\n\t\t\tProjectId:     pulumi.String(\"{PROJECT_ID}\"),\n\t\t\tIamRoleId:     pulumi.String(\"{IAM_ROLE_ID}\"),\n\t\t\tBucketName:    pulumi.String(\"example_bucket\"),\n\t\t\tCloudProvider: pulumi.String(\"AWS\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewCloudBackupSnapshotExportJob(ctx, \"test\", \u0026mongodbatlas.CloudBackupSnapshotExportJobArgs{\n\t\t\tProjectId:      pulumi.String(\"{PROJECT_ID}\"),\n\t\t\tClusterName:    pulumi.String(\"{CLUSTER_NAME}\"),\n\t\t\tSnapshotId:     pulumi.String(\"{SNAPSHOT_ID}\"),\n\t\t\tExportBucketId: test.ExportBucketId,\n\t\t\tCustomDatas: mongodbatlas.CloudBackupSnapshotExportJobCustomDataArray{\n\t\t\t\t\u0026mongodbatlas.CloudBackupSnapshotExportJobCustomDataArgs{\n\t\t\t\t\tKey:   pulumi.String(\"exported by\"),\n\t\t\t\t\tValue: pulumi.String(\"myName\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportBucket;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportBucketArgs;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportJob;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportJobArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudBackupSnapshotExportJobCustomDataArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new CloudBackupSnapshotExportBucket(\"test\", CloudBackupSnapshotExportBucketArgs.builder()\n            .projectId(\"{PROJECT_ID}\")\n            .iamRoleId(\"{IAM_ROLE_ID}\")\n            .bucketName(\"example_bucket\")\n            .cloudProvider(\"AWS\")\n            .build());\n\n        var testCloudBackupSnapshotExportJob = new CloudBackupSnapshotExportJob(\"testCloudBackupSnapshotExportJob\", CloudBackupSnapshotExportJobArgs.builder()\n            .projectId(\"{PROJECT_ID}\")\n            .clusterName(\"{CLUSTER_NAME}\")\n            .snapshotId(\"{SNAPSHOT_ID}\")\n            .exportBucketId(test.exportBucketId())\n            .customDatas(CloudBackupSnapshotExportJobCustomDataArgs.builder()\n                .key(\"exported by\")\n                .value(\"myName\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:CloudBackupSnapshotExportBucket\n    properties:\n      projectId: '{PROJECT_ID}'\n      iamRoleId: '{IAM_ROLE_ID}'\n      bucketName: example_bucket\n      cloudProvider: AWS\n  testCloudBackupSnapshotExportJob:\n    type: mongodbatlas:CloudBackupSnapshotExportJob\n    name: test\n    properties:\n      projectId: '{PROJECT_ID}'\n      clusterName: '{CLUSTER_NAME}'\n      snapshotId: '{SNAPSHOT_ID}'\n      exportBucketId: ${test.exportBucketId}\n      customDatas:\n        - key: exported by\n          value: myName\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Create backup and automatic snapshot export policies\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst _export = new mongodbatlas.CloudBackupSnapshotExportBucket(\"export\", {\n    projectId: \"{PROJECT_ID}\",\n    iamRoleId: \"{IAM_ROLE_ID}\",\n    bucketName: \"example_bucket\",\n    cloudProvider: \"AWS\",\n});\nconst backup = new mongodbatlas.CloudBackupSchedule(\"backup\", {\n    projectId: \"{PROJECT_ID}\",\n    clusterName: \"{CLUSTER_NAME}\",\n    autoExportEnabled: true,\n    \"export\": {\n        exportBucketId: _export.exportBucketId,\n        frequencyType: \"daily\",\n    },\n    useOrgAndGroupNamesInExportPrefix: true,\n    referenceHourOfDay: 7,\n    referenceMinuteOfHour: 0,\n    restoreWindowDays: 5,\n    policyItemHourly: {\n        frequencyInterval: 6,\n        retentionUnit: \"days\",\n        retentionValue: 7,\n    },\n    policyItemDaily: {\n        frequencyInterval: 1,\n        retentionUnit: \"days\",\n        retentionValue: 7,\n    },\n    policyItemWeeklies: [{\n        frequencyInterval: 6,\n        retentionUnit: \"weeks\",\n        retentionValue: 4,\n    }],\n    policyItemMonthlies: [{\n        frequencyInterval: 28,\n        retentionUnit: \"months\",\n        retentionValue: 12,\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nexport = mongodbatlas.CloudBackupSnapshotExportBucket(\"export\",\n    project_id=\"{PROJECT_ID}\",\n    iam_role_id=\"{IAM_ROLE_ID}\",\n    bucket_name=\"example_bucket\",\n    cloud_provider=\"AWS\")\nbackup = mongodbatlas.CloudBackupSchedule(\"backup\",\n    project_id=\"{PROJECT_ID}\",\n    cluster_name=\"{CLUSTER_NAME}\",\n    auto_export_enabled=True,\n    export={\n        \"export_bucket_id\": export.export_bucket_id,\n        \"frequency_type\": \"daily\",\n    },\n    use_org_and_group_names_in_export_prefix=True,\n    reference_hour_of_day=7,\n    reference_minute_of_hour=0,\n    restore_window_days=5,\n    policy_item_hourly={\n        \"frequency_interval\": 6,\n        \"retention_unit\": \"days\",\n        \"retention_value\": 7,\n    },\n    policy_item_daily={\n        \"frequency_interval\": 1,\n        \"retention_unit\": \"days\",\n        \"retention_value\": 7,\n    },\n    policy_item_weeklies=[{\n        \"frequency_interval\": 6,\n        \"retention_unit\": \"weeks\",\n        \"retention_value\": 4,\n    }],\n    policy_item_monthlies=[{\n        \"frequency_interval\": 28,\n        \"retention_unit\": \"months\",\n        \"retention_value\": 12,\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var export = new Mongodbatlas.CloudBackupSnapshotExportBucket(\"export\", new()\n    {\n        ProjectId = \"{PROJECT_ID}\",\n        IamRoleId = \"{IAM_ROLE_ID}\",\n        BucketName = \"example_bucket\",\n        CloudProvider = \"AWS\",\n    });\n\n    var backup = new Mongodbatlas.CloudBackupSchedule(\"backup\", new()\n    {\n        ProjectId = \"{PROJECT_ID}\",\n        ClusterName = \"{CLUSTER_NAME}\",\n        AutoExportEnabled = true,\n        Export = new Mongodbatlas.Inputs.CloudBackupScheduleExportArgs\n        {\n            ExportBucketId = export.ExportBucketId,\n            FrequencyType = \"daily\",\n        },\n        UseOrgAndGroupNamesInExportPrefix = true,\n        ReferenceHourOfDay = 7,\n        ReferenceMinuteOfHour = 0,\n        RestoreWindowDays = 5,\n        PolicyItemHourly = new Mongodbatlas.Inputs.CloudBackupSchedulePolicyItemHourlyArgs\n        {\n            FrequencyInterval = 6,\n            RetentionUnit = \"days\",\n            RetentionValue = 7,\n        },\n        PolicyItemDaily = new Mongodbatlas.Inputs.CloudBackupSchedulePolicyItemDailyArgs\n        {\n            FrequencyInterval = 1,\n            RetentionUnit = \"days\",\n            RetentionValue = 7,\n        },\n        PolicyItemWeeklies = new[]\n        {\n            new Mongodbatlas.Inputs.CloudBackupSchedulePolicyItemWeeklyArgs\n            {\n                FrequencyInterval = 6,\n                RetentionUnit = \"weeks\",\n                RetentionValue = 4,\n            },\n        },\n        PolicyItemMonthlies = new[]\n        {\n            new Mongodbatlas.Inputs.CloudBackupSchedulePolicyItemMonthlyArgs\n            {\n                FrequencyInterval = 28,\n                RetentionUnit = \"months\",\n                RetentionValue = 12,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texport, err := mongodbatlas.NewCloudBackupSnapshotExportBucket(ctx, \"export\", \u0026mongodbatlas.CloudBackupSnapshotExportBucketArgs{\n\t\t\tProjectId:     pulumi.String(\"{PROJECT_ID}\"),\n\t\t\tIamRoleId:     pulumi.String(\"{IAM_ROLE_ID}\"),\n\t\t\tBucketName:    pulumi.String(\"example_bucket\"),\n\t\t\tCloudProvider: pulumi.String(\"AWS\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewCloudBackupSchedule(ctx, \"backup\", \u0026mongodbatlas.CloudBackupScheduleArgs{\n\t\t\tProjectId:         pulumi.String(\"{PROJECT_ID}\"),\n\t\t\tClusterName:       pulumi.String(\"{CLUSTER_NAME}\"),\n\t\t\tAutoExportEnabled: pulumi.Bool(true),\n\t\t\tExport: \u0026mongodbatlas.CloudBackupScheduleExportArgs{\n\t\t\t\tExportBucketId: export.ExportBucketId,\n\t\t\t\tFrequencyType:  pulumi.String(\"daily\"),\n\t\t\t},\n\t\t\tUseOrgAndGroupNamesInExportPrefix: pulumi.Bool(true),\n\t\t\tReferenceHourOfDay:                pulumi.Int(7),\n\t\t\tReferenceMinuteOfHour:             pulumi.Int(0),\n\t\t\tRestoreWindowDays:                 pulumi.Int(5),\n\t\t\tPolicyItemHourly: \u0026mongodbatlas.CloudBackupSchedulePolicyItemHourlyArgs{\n\t\t\t\tFrequencyInterval: pulumi.Int(6),\n\t\t\t\tRetentionUnit:     pulumi.String(\"days\"),\n\t\t\t\tRetentionValue:    pulumi.Int(7),\n\t\t\t},\n\t\t\tPolicyItemDaily: \u0026mongodbatlas.CloudBackupSchedulePolicyItemDailyArgs{\n\t\t\t\tFrequencyInterval: pulumi.Int(1),\n\t\t\t\tRetentionUnit:     pulumi.String(\"days\"),\n\t\t\t\tRetentionValue:    pulumi.Int(7),\n\t\t\t},\n\t\t\tPolicyItemWeeklies: mongodbatlas.CloudBackupSchedulePolicyItemWeeklyArray{\n\t\t\t\t\u0026mongodbatlas.CloudBackupSchedulePolicyItemWeeklyArgs{\n\t\t\t\t\tFrequencyInterval: pulumi.Int(6),\n\t\t\t\t\tRetentionUnit:     pulumi.String(\"weeks\"),\n\t\t\t\t\tRetentionValue:    pulumi.Int(4),\n\t\t\t\t},\n\t\t\t},\n\t\t\tPolicyItemMonthlies: mongodbatlas.CloudBackupSchedulePolicyItemMonthlyArray{\n\t\t\t\t\u0026mongodbatlas.CloudBackupSchedulePolicyItemMonthlyArgs{\n\t\t\t\t\tFrequencyInterval: pulumi.Int(28),\n\t\t\t\t\tRetentionUnit:     pulumi.String(\"months\"),\n\t\t\t\t\tRetentionValue:    pulumi.Int(12),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportBucket;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportBucketArgs;\nimport com.pulumi.mongodbatlas.CloudBackupSchedule;\nimport com.pulumi.mongodbatlas.CloudBackupScheduleArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudBackupScheduleExportArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudBackupSchedulePolicyItemHourlyArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudBackupSchedulePolicyItemDailyArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudBackupSchedulePolicyItemWeeklyArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudBackupSchedulePolicyItemMonthlyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var export = new CloudBackupSnapshotExportBucket(\"export\", CloudBackupSnapshotExportBucketArgs.builder()\n            .projectId(\"{PROJECT_ID}\")\n            .iamRoleId(\"{IAM_ROLE_ID}\")\n            .bucketName(\"example_bucket\")\n            .cloudProvider(\"AWS\")\n            .build());\n\n        var backup = new CloudBackupSchedule(\"backup\", CloudBackupScheduleArgs.builder()\n            .projectId(\"{PROJECT_ID}\")\n            .clusterName(\"{CLUSTER_NAME}\")\n            .autoExportEnabled(true)\n            .export(CloudBackupScheduleExportArgs.builder()\n                .exportBucketId(export.exportBucketId())\n                .frequencyType(\"daily\")\n                .build())\n            .useOrgAndGroupNamesInExportPrefix(true)\n            .referenceHourOfDay(7)\n            .referenceMinuteOfHour(0)\n            .restoreWindowDays(5)\n            .policyItemHourly(CloudBackupSchedulePolicyItemHourlyArgs.builder()\n                .frequencyInterval(6)\n                .retentionUnit(\"days\")\n                .retentionValue(7)\n                .build())\n            .policyItemDaily(CloudBackupSchedulePolicyItemDailyArgs.builder()\n                .frequencyInterval(1)\n                .retentionUnit(\"days\")\n                .retentionValue(7)\n                .build())\n            .policyItemWeeklies(CloudBackupSchedulePolicyItemWeeklyArgs.builder()\n                .frequencyInterval(6)\n                .retentionUnit(\"weeks\")\n                .retentionValue(4)\n                .build())\n            .policyItemMonthlies(CloudBackupSchedulePolicyItemMonthlyArgs.builder()\n                .frequencyInterval(28)\n                .retentionUnit(\"months\")\n                .retentionValue(12)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  export:\n    type: mongodbatlas:CloudBackupSnapshotExportBucket\n    properties:\n      projectId: '{PROJECT_ID}'\n      iamRoleId: '{IAM_ROLE_ID}'\n      bucketName: example_bucket\n      cloudProvider: AWS\n  backup:\n    type: mongodbatlas:CloudBackupSchedule\n    properties:\n      projectId: '{PROJECT_ID}'\n      clusterName: '{CLUSTER_NAME}'\n      autoExportEnabled: true\n      export:\n        exportBucketId: ${export.exportBucketId}\n        frequencyType: daily\n      useOrgAndGroupNamesInExportPrefix: true\n      referenceHourOfDay: 7\n      referenceMinuteOfHour: 0\n      restoreWindowDays: 5\n      policyItemHourly:\n        frequencyInterval: 6\n        retentionUnit: days\n        retentionValue: 7\n      policyItemDaily:\n        frequencyInterval: 1\n        retentionUnit: days\n        retentionValue: 7\n      policyItemWeeklies:\n        - frequencyInterval: 6\n          retentionUnit: weeks\n          retentionValue: 4\n      policyItemMonthlies:\n        - frequencyInterval: 28\n          retentionUnit: months\n          retentionValue: 12\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nCloud Backup Snapshot Export Backup entries can be imported using project project_id, cluster_name and export_job_id (Unique identifier of the snapshot export job), in the format `PROJECTID-CLUSTERNAME-EXPORTJOBID`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/cloudBackupSnapshotExportJob:CloudBackupSnapshotExportJob test 5d0f1f73cf09a29120e173cf-5d116d82014b764445b2f9b5-5d116d82014b764445b2f9b5\n```\nFor more information see: [MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/cloud-backup/export/create-one-export-job/)\n\n",
            "properties": {
                "clusterName": {
                    "type": "string",
                    "description": "Name of the Atlas cluster whose snapshot you want to export.\n"
                },
                "components": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupSnapshotExportJobComponent:CloudBackupSnapshotExportJobComponent"
                    },
                    "description": "_Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.\n"
                },
                "createdAt": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when the export job was created.\n"
                },
                "customDatas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupSnapshotExportJobCustomData:CloudBackupSnapshotExportJobCustomData"
                    },
                    "description": "Custom data to include in the metadata file named `.complete` that Atlas uploads to the bucket when the export job finishes. Custom data can be specified as key and value pairs.\n"
                },
                "errMsg": {
                    "type": "string",
                    "description": "Error message, only if the export job failed. **Note:** This attribute is deprecated as it is not being used.\n",
                    "deprecationMessage": "This parameter is deprecated and will be removed in version 1.20.0."
                },
                "exportBucketId": {
                    "type": "string",
                    "description": "Unique identifier of the AWS bucket to export the Cloud Backup snapshot to. If necessary, use the [Get All Snapshot Export Buckets](https://docs.atlas.mongodb.com/reference/api/cloud-backup/export/get-all-export-buckets/) API to retrieve the IDs of all available export buckets for a project or use the data source mongodbatlas_cloud_backup_snapshot_export_buckets\n"
                },
                "exportJobId": {
                    "type": "string",
                    "description": "Unique identifier of the export job.\n* `prefix ` - Full path on the cloud provider bucket to the folder where the snapshot is exported. The path is in the following format:`/exported_snapshots/{ORG-NAME}/{PROJECT-NAME}/{CLUSTER-NAME}/{SNAPSHOT-INITIATION-DATE}/{TIMESTAMP}`\n"
                },
                "exportStatusExportedCollections": {
                    "type": "integer"
                },
                "exportStatusTotalCollections": {
                    "type": "integer"
                },
                "finishedAt": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when the export job completes.\n"
                },
                "prefix": {
                    "type": "string"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the project which contains the Atlas cluster whose snapshot you want to export.\n"
                },
                "snapshotId": {
                    "type": "string",
                    "description": "Unique identifier of the Cloud Backup snapshot to export. If necessary, use the [Get All Cloud Backups](https://docs.atlas.mongodb.com/reference/api/cloud-backup/backup/get-all-backups/) API to retrieve the list of snapshot IDs for a cluster or use the data source mongodbatlas_cloud_cloud_backup_snapshots\n"
                },
                "state": {
                    "type": "string",
                    "description": "Status of the export job. Value can be one of the following:\n* `Queued` - indicates that the export job is queued\n* `InProgress` - indicates that the snapshot is being exported\n* `Successful` - indicates that the export job has completed successfully\n* `Failed` - indicates that the export job has failed\n"
                }
            },
            "required": [
                "clusterName",
                "components",
                "createdAt",
                "customDatas",
                "errMsg",
                "exportBucketId",
                "exportJobId",
                "exportStatusExportedCollections",
                "exportStatusTotalCollections",
                "finishedAt",
                "prefix",
                "projectId",
                "snapshotId",
                "state"
            ],
            "inputProperties": {
                "clusterName": {
                    "type": "string",
                    "description": "Name of the Atlas cluster whose snapshot you want to export.\n",
                    "willReplaceOnChanges": true
                },
                "customDatas": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupSnapshotExportJobCustomData:CloudBackupSnapshotExportJobCustomData"
                    },
                    "description": "Custom data to include in the metadata file named `.complete` that Atlas uploads to the bucket when the export job finishes. Custom data can be specified as key and value pairs.\n",
                    "willReplaceOnChanges": true
                },
                "exportBucketId": {
                    "type": "string",
                    "description": "Unique identifier of the AWS bucket to export the Cloud Backup snapshot to. If necessary, use the [Get All Snapshot Export Buckets](https://docs.atlas.mongodb.com/reference/api/cloud-backup/export/get-all-export-buckets/) API to retrieve the IDs of all available export buckets for a project or use the data source mongodbatlas_cloud_backup_snapshot_export_buckets\n",
                    "willReplaceOnChanges": true
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the project which contains the Atlas cluster whose snapshot you want to export.\n",
                    "willReplaceOnChanges": true
                },
                "snapshotId": {
                    "type": "string",
                    "description": "Unique identifier of the Cloud Backup snapshot to export. If necessary, use the [Get All Cloud Backups](https://docs.atlas.mongodb.com/reference/api/cloud-backup/backup/get-all-backups/) API to retrieve the list of snapshot IDs for a cluster or use the data source mongodbatlas_cloud_cloud_backup_snapshots\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "clusterName",
                "customDatas",
                "exportBucketId",
                "projectId",
                "snapshotId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudBackupSnapshotExportJob resources.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "Name of the Atlas cluster whose snapshot you want to export.\n",
                        "willReplaceOnChanges": true
                    },
                    "components": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/CloudBackupSnapshotExportJobComponent:CloudBackupSnapshotExportJobComponent"
                        },
                        "description": "_Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.\n"
                    },
                    "createdAt": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when the export job was created.\n"
                    },
                    "customDatas": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/CloudBackupSnapshotExportJobCustomData:CloudBackupSnapshotExportJobCustomData"
                        },
                        "description": "Custom data to include in the metadata file named `.complete` that Atlas uploads to the bucket when the export job finishes. Custom data can be specified as key and value pairs.\n",
                        "willReplaceOnChanges": true
                    },
                    "errMsg": {
                        "type": "string",
                        "description": "Error message, only if the export job failed. **Note:** This attribute is deprecated as it is not being used.\n",
                        "deprecationMessage": "This parameter is deprecated and will be removed in version 1.20.0."
                    },
                    "exportBucketId": {
                        "type": "string",
                        "description": "Unique identifier of the AWS bucket to export the Cloud Backup snapshot to. If necessary, use the [Get All Snapshot Export Buckets](https://docs.atlas.mongodb.com/reference/api/cloud-backup/export/get-all-export-buckets/) API to retrieve the IDs of all available export buckets for a project or use the data source mongodbatlas_cloud_backup_snapshot_export_buckets\n",
                        "willReplaceOnChanges": true
                    },
                    "exportJobId": {
                        "type": "string",
                        "description": "Unique identifier of the export job.\n* `prefix ` - Full path on the cloud provider bucket to the folder where the snapshot is exported. The path is in the following format:`/exported_snapshots/{ORG-NAME}/{PROJECT-NAME}/{CLUSTER-NAME}/{SNAPSHOT-INITIATION-DATE}/{TIMESTAMP}`\n"
                    },
                    "exportStatusExportedCollections": {
                        "type": "integer"
                    },
                    "exportStatusTotalCollections": {
                        "type": "integer"
                    },
                    "finishedAt": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when the export job completes.\n"
                    },
                    "prefix": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the project which contains the Atlas cluster whose snapshot you want to export.\n",
                        "willReplaceOnChanges": true
                    },
                    "snapshotId": {
                        "type": "string",
                        "description": "Unique identifier of the Cloud Backup snapshot to export. If necessary, use the [Get All Cloud Backups](https://docs.atlas.mongodb.com/reference/api/cloud-backup/backup/get-all-backups/) API to retrieve the list of snapshot IDs for a cluster or use the data source mongodbatlas_cloud_cloud_backup_snapshots\n",
                        "willReplaceOnChanges": true
                    },
                    "state": {
                        "type": "string",
                        "description": "Status of the export job. Value can be one of the following:\n* `Queued` - indicates that the export job is queued\n* `InProgress` - indicates that the snapshot is being exported\n* `Successful` - indicates that the export job has completed successfully\n* `Failed` - indicates that the export job has failed\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/cloudBackupSnapshotRestoreJob:CloudBackupSnapshotRestoreJob": {
            "description": "## Example Usage\n\n### Example automated delivery type\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst myCluster = new mongodbatlas.AdvancedCluster(\"my_cluster\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    name: \"MyCluster\",\n    clusterType: \"REPLICASET\",\n    backupEnabled: true,\n    replicationSpecs: [{\n        regionConfigs: [{\n            priority: 7,\n            providerName: \"AWS\",\n            regionName: \"EU_WEST_2\",\n            electableSpecs: {\n                instanceSize: \"M10\",\n                nodeCount: 3,\n            },\n        }],\n    }],\n});\nconst test = new mongodbatlas.index.CloudProviderSnapshot(\"test\", {\n    projectId: myCluster.projectId,\n    clusterName: myCluster.name,\n    description: \"myDescription\",\n    retentionInDays: 1,\n});\nconst testCloudBackupSnapshotRestoreJob = new mongodbatlas.CloudBackupSnapshotRestoreJob(\"test\", {\n    projectId: test.projectId,\n    clusterName: test.clusterName,\n    snapshotId: test.snapshotId,\n    deliveryTypeConfig: {\n        automated: true,\n        targetClusterName: \"MyCluster\",\n        targetProjectId: \"5cf5a45a9ccf6400e60981b6\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nmy_cluster = mongodbatlas.AdvancedCluster(\"my_cluster\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    name=\"MyCluster\",\n    cluster_type=\"REPLICASET\",\n    backup_enabled=True,\n    replication_specs=[{\n        \"region_configs\": [{\n            \"priority\": 7,\n            \"provider_name\": \"AWS\",\n            \"region_name\": \"EU_WEST_2\",\n            \"electable_specs\": {\n                \"instance_size\": \"M10\",\n                \"node_count\": 3,\n            },\n        }],\n    }])\ntest = mongodbatlas.index.CloudProviderSnapshot(\"test\",\n    project_id=my_cluster.project_id,\n    cluster_name=my_cluster.name,\n    description=myDescription,\n    retention_in_days=1)\ntest_cloud_backup_snapshot_restore_job = mongodbatlas.CloudBackupSnapshotRestoreJob(\"test\",\n    project_id=test[\"projectId\"],\n    cluster_name=test[\"clusterName\"],\n    snapshot_id=test[\"snapshotId\"],\n    delivery_type_config={\n        \"automated\": True,\n        \"target_cluster_name\": \"MyCluster\",\n        \"target_project_id\": \"5cf5a45a9ccf6400e60981b6\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myCluster = new Mongodbatlas.AdvancedCluster(\"my_cluster\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        Name = \"MyCluster\",\n        ClusterType = \"REPLICASET\",\n        BackupEnabled = true,\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        Priority = 7,\n                        ProviderName = \"AWS\",\n                        RegionName = \"EU_WEST_2\",\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M10\",\n                            NodeCount = 3,\n                        },\n                    },\n                },\n            },\n        },\n    });\n\n    var test = new Mongodbatlas.Index.CloudProviderSnapshot(\"test\", new()\n    {\n        ProjectId = myCluster.ProjectId,\n        ClusterName = myCluster.Name,\n        Description = \"myDescription\",\n        RetentionInDays = 1,\n    });\n\n    var testCloudBackupSnapshotRestoreJob = new Mongodbatlas.CloudBackupSnapshotRestoreJob(\"test\", new()\n    {\n        ProjectId = test.ProjectId,\n        ClusterName = test.ClusterName,\n        SnapshotId = test.SnapshotId,\n        DeliveryTypeConfig = new Mongodbatlas.Inputs.CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs\n        {\n            Automated = true,\n            TargetClusterName = \"MyCluster\",\n            TargetProjectId = \"5cf5a45a9ccf6400e60981b6\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmyCluster, err := mongodbatlas.NewAdvancedCluster(ctx, \"my_cluster\", \u0026mongodbatlas.AdvancedClusterArgs{\n\t\t\tProjectId:     pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tName:          pulumi.String(\"MyCluster\"),\n\t\t\tClusterType:   pulumi.String(\"REPLICASET\"),\n\t\t\tBackupEnabled: pulumi.Bool(true),\n\t\t\tReplicationSpecs: mongodbatlas.AdvancedClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tPriority:     pulumi.Int(7),\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"EU_WEST_2\"),\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M10\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(3),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttest, err := mongodbatlas.NewCloudProviderSnapshot(ctx, \"test\", \u0026mongodbatlas.CloudProviderSnapshotArgs{\n\t\t\tProjectId:       myCluster.ProjectId,\n\t\t\tClusterName:     myCluster.Name,\n\t\t\tDescription:     \"myDescription\",\n\t\t\tRetentionInDays: 1,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewCloudBackupSnapshotRestoreJob(ctx, \"test\", \u0026mongodbatlas.CloudBackupSnapshotRestoreJobArgs{\n\t\t\tProjectId:   test.ProjectId,\n\t\t\tClusterName: test.ClusterName,\n\t\t\tSnapshotId:  test.SnapshotId,\n\t\t\tDeliveryTypeConfig: \u0026mongodbatlas.CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs{\n\t\t\t\tAutomated:         pulumi.Bool(true),\n\t\t\t\tTargetClusterName: pulumi.String(\"MyCluster\"),\n\t\t\t\tTargetProjectId:   pulumi.String(\"5cf5a45a9ccf6400e60981b6\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AdvancedCluster;\nimport com.pulumi.mongodbatlas.AdvancedClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.AdvancedClusterReplicationSpecArgs;\nimport com.pulumi.mongodbatlas.cloudProviderSnapshot;\nimport com.pulumi.mongodbatlas.CloudProviderSnapshotArgs;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotRestoreJob;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotRestoreJobArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myCluster = new AdvancedCluster(\"myCluster\", AdvancedClusterArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .name(\"MyCluster\")\n            .clusterType(\"REPLICASET\")\n            .backupEnabled(true)\n            .replicationSpecs(AdvancedClusterReplicationSpecArgs.builder()\n                .regionConfigs(AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                    .priority(7)\n                    .providerName(\"AWS\")\n                    .regionName(\"EU_WEST_2\")\n                    .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                        .instanceSize(\"M10\")\n                        .nodeCount(3)\n                        .build())\n                    .build())\n                .build())\n            .build());\n\n        var test = new CloudProviderSnapshot(\"test\", CloudProviderSnapshotArgs.builder()\n            .projectId(myCluster.projectId())\n            .clusterName(myCluster.name())\n            .description(\"myDescription\")\n            .retentionInDays(1)\n            .build());\n\n        var testCloudBackupSnapshotRestoreJob = new CloudBackupSnapshotRestoreJob(\"testCloudBackupSnapshotRestoreJob\", CloudBackupSnapshotRestoreJobArgs.builder()\n            .projectId(test.projectId())\n            .clusterName(test.clusterName())\n            .snapshotId(test.snapshotId())\n            .deliveryTypeConfig(CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs.builder()\n                .automated(true)\n                .targetClusterName(\"MyCluster\")\n                .targetProjectId(\"5cf5a45a9ccf6400e60981b6\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myCluster:\n    type: mongodbatlas:AdvancedCluster\n    name: my_cluster\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      name: MyCluster\n      clusterType: REPLICASET\n      backupEnabled: true # enable cloud backup snapshots\n      replicationSpecs:\n        - regionConfigs:\n            - priority: 7\n              providerName: AWS\n              regionName: EU_WEST_2\n              electableSpecs:\n                instanceSize: M10\n                nodeCount: 3\n  test:\n    type: mongodbatlas:cloudProviderSnapshot\n    properties:\n      projectId: ${myCluster.projectId}\n      clusterName: ${myCluster.name}\n      description: myDescription\n      retentionInDays: 1\n  testCloudBackupSnapshotRestoreJob:\n    type: mongodbatlas:CloudBackupSnapshotRestoreJob\n    name: test\n    properties:\n      projectId: ${test.projectId}\n      clusterName: ${test.clusterName}\n      snapshotId: ${test.snapshotId}\n      deliveryTypeConfig:\n        automated: true\n        targetClusterName: MyCluster\n        targetProjectId: 5cf5a45a9ccf6400e60981b6\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example download delivery type\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst myCluster = new mongodbatlas.AdvancedCluster(\"my_cluster\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    name: \"MyCluster\",\n    clusterType: \"REPLICASET\",\n    backupEnabled: true,\n    replicationSpecs: [{\n        regionConfigs: [{\n            priority: 7,\n            providerName: \"AWS\",\n            regionName: \"EU_WEST_2\",\n            electableSpecs: {\n                instanceSize: \"M10\",\n                nodeCount: 3,\n            },\n        }],\n    }],\n});\nconst test = new mongodbatlas.index.CloudProviderSnapshot(\"test\", {\n    projectId: myCluster.projectId,\n    clusterName: myCluster.name,\n    description: \"myDescription\",\n    retentionInDays: 1,\n});\nconst testCloudBackupSnapshotRestoreJob = new mongodbatlas.CloudBackupSnapshotRestoreJob(\"test\", {\n    projectId: test.projectId,\n    clusterName: test.clusterName,\n    snapshotId: test.snapshotId,\n    deliveryTypeConfig: {\n        download: true,\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nmy_cluster = mongodbatlas.AdvancedCluster(\"my_cluster\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    name=\"MyCluster\",\n    cluster_type=\"REPLICASET\",\n    backup_enabled=True,\n    replication_specs=[{\n        \"region_configs\": [{\n            \"priority\": 7,\n            \"provider_name\": \"AWS\",\n            \"region_name\": \"EU_WEST_2\",\n            \"electable_specs\": {\n                \"instance_size\": \"M10\",\n                \"node_count\": 3,\n            },\n        }],\n    }])\ntest = mongodbatlas.index.CloudProviderSnapshot(\"test\",\n    project_id=my_cluster.project_id,\n    cluster_name=my_cluster.name,\n    description=myDescription,\n    retention_in_days=1)\ntest_cloud_backup_snapshot_restore_job = mongodbatlas.CloudBackupSnapshotRestoreJob(\"test\",\n    project_id=test[\"projectId\"],\n    cluster_name=test[\"clusterName\"],\n    snapshot_id=test[\"snapshotId\"],\n    delivery_type_config={\n        \"download\": True,\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myCluster = new Mongodbatlas.AdvancedCluster(\"my_cluster\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        Name = \"MyCluster\",\n        ClusterType = \"REPLICASET\",\n        BackupEnabled = true,\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        Priority = 7,\n                        ProviderName = \"AWS\",\n                        RegionName = \"EU_WEST_2\",\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M10\",\n                            NodeCount = 3,\n                        },\n                    },\n                },\n            },\n        },\n    });\n\n    var test = new Mongodbatlas.Index.CloudProviderSnapshot(\"test\", new()\n    {\n        ProjectId = myCluster.ProjectId,\n        ClusterName = myCluster.Name,\n        Description = \"myDescription\",\n        RetentionInDays = 1,\n    });\n\n    var testCloudBackupSnapshotRestoreJob = new Mongodbatlas.CloudBackupSnapshotRestoreJob(\"test\", new()\n    {\n        ProjectId = test.ProjectId,\n        ClusterName = test.ClusterName,\n        SnapshotId = test.SnapshotId,\n        DeliveryTypeConfig = new Mongodbatlas.Inputs.CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs\n        {\n            Download = true,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmyCluster, err := mongodbatlas.NewAdvancedCluster(ctx, \"my_cluster\", \u0026mongodbatlas.AdvancedClusterArgs{\n\t\t\tProjectId:     pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tName:          pulumi.String(\"MyCluster\"),\n\t\t\tClusterType:   pulumi.String(\"REPLICASET\"),\n\t\t\tBackupEnabled: pulumi.Bool(true),\n\t\t\tReplicationSpecs: mongodbatlas.AdvancedClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tPriority:     pulumi.Int(7),\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"EU_WEST_2\"),\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M10\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(3),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttest, err := mongodbatlas.NewCloudProviderSnapshot(ctx, \"test\", \u0026mongodbatlas.CloudProviderSnapshotArgs{\n\t\t\tProjectId:       myCluster.ProjectId,\n\t\t\tClusterName:     myCluster.Name,\n\t\t\tDescription:     \"myDescription\",\n\t\t\tRetentionInDays: 1,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewCloudBackupSnapshotRestoreJob(ctx, \"test\", \u0026mongodbatlas.CloudBackupSnapshotRestoreJobArgs{\n\t\t\tProjectId:   test.ProjectId,\n\t\t\tClusterName: test.ClusterName,\n\t\t\tSnapshotId:  test.SnapshotId,\n\t\t\tDeliveryTypeConfig: \u0026mongodbatlas.CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs{\n\t\t\t\tDownload: pulumi.Bool(true),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AdvancedCluster;\nimport com.pulumi.mongodbatlas.AdvancedClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.AdvancedClusterReplicationSpecArgs;\nimport com.pulumi.mongodbatlas.cloudProviderSnapshot;\nimport com.pulumi.mongodbatlas.CloudProviderSnapshotArgs;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotRestoreJob;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotRestoreJobArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myCluster = new AdvancedCluster(\"myCluster\", AdvancedClusterArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .name(\"MyCluster\")\n            .clusterType(\"REPLICASET\")\n            .backupEnabled(true)\n            .replicationSpecs(AdvancedClusterReplicationSpecArgs.builder()\n                .regionConfigs(AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                    .priority(7)\n                    .providerName(\"AWS\")\n                    .regionName(\"EU_WEST_2\")\n                    .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                        .instanceSize(\"M10\")\n                        .nodeCount(3)\n                        .build())\n                    .build())\n                .build())\n            .build());\n\n        var test = new CloudProviderSnapshot(\"test\", CloudProviderSnapshotArgs.builder()\n            .projectId(myCluster.projectId())\n            .clusterName(myCluster.name())\n            .description(\"myDescription\")\n            .retentionInDays(1)\n            .build());\n\n        var testCloudBackupSnapshotRestoreJob = new CloudBackupSnapshotRestoreJob(\"testCloudBackupSnapshotRestoreJob\", CloudBackupSnapshotRestoreJobArgs.builder()\n            .projectId(test.projectId())\n            .clusterName(test.clusterName())\n            .snapshotId(test.snapshotId())\n            .deliveryTypeConfig(CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs.builder()\n                .download(true)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myCluster:\n    type: mongodbatlas:AdvancedCluster\n    name: my_cluster\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      name: MyCluster\n      clusterType: REPLICASET\n      backupEnabled: true # enable cloud backup snapshots\n      replicationSpecs:\n        - regionConfigs:\n            - priority: 7\n              providerName: AWS\n              regionName: EU_WEST_2\n              electableSpecs:\n                instanceSize: M10\n                nodeCount: 3\n  test:\n    type: mongodbatlas:cloudProviderSnapshot\n    properties:\n      projectId: ${myCluster.projectId}\n      clusterName: ${myCluster.name}\n      description: myDescription\n      retentionInDays: 1\n  testCloudBackupSnapshotRestoreJob:\n    type: mongodbatlas:CloudBackupSnapshotRestoreJob\n    name: test\n    properties:\n      projectId: ${test.projectId}\n      clusterName: ${test.clusterName}\n      snapshotId: ${test.snapshotId}\n      deliveryTypeConfig:\n        download: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example of a point in time restore\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst myCluster = new mongodbatlas.AdvancedCluster(\"my_cluster\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    name: \"MyCluster\",\n    clusterType: \"REPLICASET\",\n    backupEnabled: true,\n    replicationSpecs: [{\n        regionConfigs: [{\n            priority: 7,\n            providerName: \"AWS\",\n            regionName: \"EU_WEST_2\",\n            electableSpecs: {\n                instanceSize: \"M10\",\n                nodeCount: 3,\n            },\n        }],\n    }],\n});\nconst test = new mongodbatlas.CloudBackupSnapshot(\"test\", {\n    projectId: clusterTest.projectId,\n    clusterName: clusterTest.name,\n    description: \"My description\",\n    retentionInDays: 1,\n});\nconst testCloudBackupSnapshotRestoreJob: mongodbatlas.CloudBackupSnapshotRestoreJob[] = [];\nfor (const range = {value: 0}; range.value \u003c (pointInTimeUtcSeconds == 0 ? 0 : 1); range.value++) {\n    testCloudBackupSnapshotRestoreJob.push(new mongodbatlas.CloudBackupSnapshotRestoreJob(`test-${range.value}`, {\n        projectId: test.projectId,\n        clusterName: test.clusterName,\n        snapshotId: test.id,\n        deliveryTypeConfig: {\n            pointInTime: true,\n            targetClusterName: clusterTest.name,\n            targetProjectId: clusterTest.projectId,\n            pointInTimeUtcSeconds: pointInTimeUtcSeconds,\n        },\n    }));\n}\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nmy_cluster = mongodbatlas.AdvancedCluster(\"my_cluster\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    name=\"MyCluster\",\n    cluster_type=\"REPLICASET\",\n    backup_enabled=True,\n    replication_specs=[{\n        \"region_configs\": [{\n            \"priority\": 7,\n            \"provider_name\": \"AWS\",\n            \"region_name\": \"EU_WEST_2\",\n            \"electable_specs\": {\n                \"instance_size\": \"M10\",\n                \"node_count\": 3,\n            },\n        }],\n    }])\ntest = mongodbatlas.CloudBackupSnapshot(\"test\",\n    project_id=cluster_test[\"projectId\"],\n    cluster_name=cluster_test[\"name\"],\n    description=\"My description\",\n    retention_in_days=1)\ntest_cloud_backup_snapshot_restore_job = []\nfor range in [{\"value\": i} for i in range(0, 0 if point_in_time_utc_seconds == 0 else 1)]:\n    test_cloud_backup_snapshot_restore_job.append(mongodbatlas.CloudBackupSnapshotRestoreJob(f\"test-{range['value']}\",\n        project_id=test.project_id,\n        cluster_name=test.cluster_name,\n        snapshot_id=test.id,\n        delivery_type_config={\n            \"point_in_time\": True,\n            \"target_cluster_name\": cluster_test[\"name\"],\n            \"target_project_id\": cluster_test[\"projectId\"],\n            \"point_in_time_utc_seconds\": point_in_time_utc_seconds,\n        }))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myCluster = new Mongodbatlas.AdvancedCluster(\"my_cluster\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        Name = \"MyCluster\",\n        ClusterType = \"REPLICASET\",\n        BackupEnabled = true,\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        Priority = 7,\n                        ProviderName = \"AWS\",\n                        RegionName = \"EU_WEST_2\",\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M10\",\n                            NodeCount = 3,\n                        },\n                    },\n                },\n            },\n        },\n    });\n\n    var test = new Mongodbatlas.CloudBackupSnapshot(\"test\", new()\n    {\n        ProjectId = clusterTest.ProjectId,\n        ClusterName = clusterTest.Name,\n        Description = \"My description\",\n        RetentionInDays = 1,\n    });\n\n    var testCloudBackupSnapshotRestoreJob = new List\u003cMongodbatlas.CloudBackupSnapshotRestoreJob\u003e();\n    for (var rangeIndex = 0; rangeIndex \u003c (pointInTimeUtcSeconds == 0 ? 0 : 1); rangeIndex++)\n    {\n        var range = new { Value = rangeIndex };\n        testCloudBackupSnapshotRestoreJob.Add(new Mongodbatlas.CloudBackupSnapshotRestoreJob($\"test-{range.Value}\", new()\n        {\n            ProjectId = test.ProjectId,\n            ClusterName = test.ClusterName,\n            SnapshotId = test.Id,\n            DeliveryTypeConfig = new Mongodbatlas.Inputs.CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs\n            {\n                PointInTime = true,\n                TargetClusterName = clusterTest.Name,\n                TargetProjectId = clusterTest.ProjectId,\n                PointInTimeUtcSeconds = pointInTimeUtcSeconds,\n            },\n        }));\n    }\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewAdvancedCluster(ctx, \"my_cluster\", \u0026mongodbatlas.AdvancedClusterArgs{\n\t\t\tProjectId:     pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tName:          pulumi.String(\"MyCluster\"),\n\t\t\tClusterType:   pulumi.String(\"REPLICASET\"),\n\t\t\tBackupEnabled: pulumi.Bool(true),\n\t\t\tReplicationSpecs: mongodbatlas.AdvancedClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tPriority:     pulumi.Int(7),\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"EU_WEST_2\"),\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M10\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(3),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttest, err := mongodbatlas.NewCloudBackupSnapshot(ctx, \"test\", \u0026mongodbatlas.CloudBackupSnapshotArgs{\n\t\t\tProjectId:       pulumi.Any(clusterTest.ProjectId),\n\t\t\tClusterName:     pulumi.Any(clusterTest.Name),\n\t\t\tDescription:     pulumi.String(\"My description\"),\n\t\t\tRetentionInDays: pulumi.Int(1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvar tmp0 float64\n\t\tif pointInTimeUtcSeconds == 0 {\n\t\t\ttmp0 = 0\n\t\t} else {\n\t\t\ttmp0 = 1\n\t\t}\n\t\tvar testCloudBackupSnapshotRestoreJob []*mongodbatlas.CloudBackupSnapshotRestoreJob\n\t\tfor index := 0; index \u003c tmp0; index++ {\n\t\t\tkey0 := index\n\t\t\t_ := index\n\t\t\t__res, err := mongodbatlas.NewCloudBackupSnapshotRestoreJob(ctx, fmt.Sprintf(\"test-%v\", key0), \u0026mongodbatlas.CloudBackupSnapshotRestoreJobArgs{\n\t\t\t\tProjectId:   test.ProjectId,\n\t\t\t\tClusterName: test.ClusterName,\n\t\t\t\tSnapshotId:  test.ID(),\n\t\t\t\tDeliveryTypeConfig: \u0026mongodbatlas.CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs{\n\t\t\t\t\tPointInTime:           pulumi.Bool(true),\n\t\t\t\t\tTargetClusterName:     pulumi.Any(clusterTest.Name),\n\t\t\t\t\tTargetProjectId:       pulumi.Any(clusterTest.ProjectId),\n\t\t\t\t\tPointInTimeUtcSeconds: pulumi.Any(pointInTimeUtcSeconds),\n\t\t\t\t},\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\ttestCloudBackupSnapshotRestoreJob = append(testCloudBackupSnapshotRestoreJob, __res)\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AdvancedCluster;\nimport com.pulumi.mongodbatlas.AdvancedClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.AdvancedClusterReplicationSpecArgs;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshot;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotArgs;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotRestoreJob;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotRestoreJobArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs;\nimport com.pulumi.codegen.internal.KeyedValue;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myCluster = new AdvancedCluster(\"myCluster\", AdvancedClusterArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .name(\"MyCluster\")\n            .clusterType(\"REPLICASET\")\n            .backupEnabled(true)\n            .replicationSpecs(AdvancedClusterReplicationSpecArgs.builder()\n                .regionConfigs(AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                    .priority(7)\n                    .providerName(\"AWS\")\n                    .regionName(\"EU_WEST_2\")\n                    .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                        .instanceSize(\"M10\")\n                        .nodeCount(3)\n                        .build())\n                    .build())\n                .build())\n            .build());\n\n        var test = new CloudBackupSnapshot(\"test\", CloudBackupSnapshotArgs.builder()\n            .projectId(clusterTest.projectId())\n            .clusterName(clusterTest.name())\n            .description(\"My description\")\n            .retentionInDays(\"1\")\n            .build());\n\n        for (var i = 0; i \u003c (pointInTimeUtcSeconds == 0 ? 0 : 1); i++) {\n            new CloudBackupSnapshotRestoreJob(\"testCloudBackupSnapshotRestoreJob-\" + i, CloudBackupSnapshotRestoreJobArgs.builder()\n                .projectId(test.projectId())\n                .clusterName(test.clusterName())\n                .snapshotId(test.id())\n                .deliveryTypeConfig(CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs.builder()\n                    .pointInTime(true)\n                    .targetClusterName(clusterTest.name())\n                    .targetProjectId(clusterTest.projectId())\n                    .pointInTimeUtcSeconds(pointInTimeUtcSeconds)\n                    .build())\n                .build());\n\n        \n}\n    }\n}\n```\n```yaml\nresources:\n  myCluster:\n    type: mongodbatlas:AdvancedCluster\n    name: my_cluster\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      name: MyCluster\n      clusterType: REPLICASET\n      backupEnabled: true # enable cloud backup snapshots\n      replicationSpecs:\n        - regionConfigs:\n            - priority: 7\n              providerName: AWS\n              regionName: EU_WEST_2\n              electableSpecs:\n                instanceSize: M10\n                nodeCount: 3\n  test:\n    type: mongodbatlas:CloudBackupSnapshot\n    properties:\n      projectId: ${clusterTest.projectId}\n      clusterName: ${clusterTest.name}\n      description: My description\n      retentionInDays: '1'\n  testCloudBackupSnapshotRestoreJob:\n    type: mongodbatlas:CloudBackupSnapshotRestoreJob\n    name: test\n    properties:\n      projectId: ${test.projectId}\n      clusterName: ${test.clusterName}\n      snapshotId: ${test.id}\n      deliveryTypeConfig:\n        pointInTime: true\n        targetClusterName: ${clusterTest.name}\n        targetProjectId: ${clusterTest.projectId}\n        pointInTimeUtcSeconds: ${pointInTimeUtcSeconds}\n    options: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Available complete examples\n- Restore from backup snapshot at point in time\n- Restore from backup snapshot using an advanced cluster resource\n\n## Import\n\nCloud Backup Snapshot Restore Job entries can be imported using project project_id, cluster_name and snapshot_id (Unique identifier of the snapshot), in the format `PROJECTID-CLUSTERNAME-JOBID`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/cloudBackupSnapshotRestoreJob:CloudBackupSnapshotRestoreJob test 5cf5a45a9ccf6400e60981b6-MyCluster-5d1b654ecf09a24b888f4c79\n```\nFor more information see: [MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/cloud-backup/restore/restores/)\n\n",
            "properties": {
                "cancelled": {
                    "type": "boolean",
                    "description": "Indicates whether the restore job was canceled.\n"
                },
                "clusterName": {
                    "type": "string",
                    "description": "The name of the Atlas cluster whose snapshot you want to restore.\n"
                },
                "deliveryTypeConfig": {
                    "$ref": "#/types/mongodbatlas:index/CloudBackupSnapshotRestoreJobDeliveryTypeConfig:CloudBackupSnapshotRestoreJobDeliveryTypeConfig",
                    "description": "Type of restore job to create. Possible configurations are: **download**, **automated**, or **pointInTime** only one must be set it in ``true``.\n* `delivery_type_config.automated` - Set to `true` to use the automated configuration.\n* `delivery_type_config.download` - Set to `true` to use the download configuration.\n* `delivery_type_config.pointInTime` - Set to `true` to use the pointInTime configuration. If using pointInTime configuration, you must also specify either `oplog_ts` and `oplog_inc`, or `point_in_time_utc_seconds`.\n* `delivery_type_config.target_cluster_name` - Name of the target Atlas cluster to which the restore job restores the snapshot. Required for **automated** and **pointInTime**.\n* `delivery_type_config.target_project_id` - Name of the target Atlas cluster to which the restore job restores the snapshot. Required for **automated** and **pointInTime**.\n* `delivery_type_config.oplog_ts` - Optional setting for **pointInTime** configuration. Timestamp in the number of seconds that have elapsed since the UNIX epoch from which to you want to restore this snapshot. This is the first part of an Oplog timestamp.\n* `delivery_type_config.oplog_inc` - Optional setting for **pointInTime** configuration. Oplog operation number from which to you want to restore this snapshot. This is the second part of an Oplog timestamp. Used in conjunction with `oplog_ts`.\n* `delivery_type_config.point_in_time_utc_seconds` - Optional setting for **pointInTime** configuration. Timestamp in the number of seconds that have elapsed since the UNIX epoch from which you want to restore this snapshot. Used instead of oplog settings.\n"
                },
                "deliveryUrls": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "One or more URLs for the compressed snapshot files for manual download. Only visible if deliveryType is download.\n"
                },
                "expired": {
                    "type": "boolean",
                    "description": "Indicates whether the restore job expired.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "UTC ISO 8601 formatted point in time when the restore job expires.\n"
                },
                "finishedAt": {
                    "type": "string",
                    "description": "UTC ISO 8601 formatted point in time when the restore job completed.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier of the project for the Atlas cluster whose snapshot you want to restore.\n"
                },
                "snapshotId": {
                    "type": "string",
                    "description": "Optional setting for **pointInTime** configuration. Unique identifier of the snapshot to restore.\n"
                },
                "snapshotRestoreJobId": {
                    "type": "string",
                    "description": "The unique identifier of the restore job.\n"
                },
                "timestamp": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when the snapshot associated to snapshotId was taken.\n* `oplogTs` - Timestamp in the number of seconds that have elapsed since the UNIX epoch from which to you want to restore this snapshot.\nThree conditions apply to this parameter:\n* Enable Continuous Cloud Backup on your cluster.\n* Specify oplogInc.\n* Specify either oplogTs and oplogInc or pointInTimeUTCSeconds, but not both.\n* `oplogInc` - Oplog operation number from which to you want to restore this snapshot. This is the second part of an Oplog timestamp.\nThree conditions apply to this parameter:\n* Enable Continuous Cloud Backup on your cluster.\n* Specify oplogTs.\n* Specify either oplogTs and oplogInc or pointInTimeUTCSeconds, but not both.\n* `pointInTimeUTCSeconds` - Timestamp in the number of seconds that have elapsed since the UNIX epoch from which you want to restore this snapshot.\nTwo conditions apply to this parameter:\n* Enable Continuous Cloud Backup on your cluster.\n* Specify either pointInTimeUTCSeconds or oplogTs and oplogInc, but not both.\n"
                }
            },
            "required": [
                "cancelled",
                "clusterName",
                "deliveryUrls",
                "expired",
                "expiresAt",
                "finishedAt",
                "projectId",
                "snapshotRestoreJobId",
                "timestamp"
            ],
            "inputProperties": {
                "clusterName": {
                    "type": "string",
                    "description": "The name of the Atlas cluster whose snapshot you want to restore.\n",
                    "willReplaceOnChanges": true
                },
                "deliveryTypeConfig": {
                    "$ref": "#/types/mongodbatlas:index/CloudBackupSnapshotRestoreJobDeliveryTypeConfig:CloudBackupSnapshotRestoreJobDeliveryTypeConfig",
                    "description": "Type of restore job to create. Possible configurations are: **download**, **automated**, or **pointInTime** only one must be set it in ``true``.\n* `delivery_type_config.automated` - Set to `true` to use the automated configuration.\n* `delivery_type_config.download` - Set to `true` to use the download configuration.\n* `delivery_type_config.pointInTime` - Set to `true` to use the pointInTime configuration. If using pointInTime configuration, you must also specify either `oplog_ts` and `oplog_inc`, or `point_in_time_utc_seconds`.\n* `delivery_type_config.target_cluster_name` - Name of the target Atlas cluster to which the restore job restores the snapshot. Required for **automated** and **pointInTime**.\n* `delivery_type_config.target_project_id` - Name of the target Atlas cluster to which the restore job restores the snapshot. Required for **automated** and **pointInTime**.\n* `delivery_type_config.oplog_ts` - Optional setting for **pointInTime** configuration. Timestamp in the number of seconds that have elapsed since the UNIX epoch from which to you want to restore this snapshot. This is the first part of an Oplog timestamp.\n* `delivery_type_config.oplog_inc` - Optional setting for **pointInTime** configuration. Oplog operation number from which to you want to restore this snapshot. This is the second part of an Oplog timestamp. Used in conjunction with `oplog_ts`.\n* `delivery_type_config.point_in_time_utc_seconds` - Optional setting for **pointInTime** configuration. Timestamp in the number of seconds that have elapsed since the UNIX epoch from which you want to restore this snapshot. Used instead of oplog settings.\n",
                    "willReplaceOnChanges": true
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier of the project for the Atlas cluster whose snapshot you want to restore.\n",
                    "willReplaceOnChanges": true
                },
                "snapshotId": {
                    "type": "string",
                    "description": "Optional setting for **pointInTime** configuration. Unique identifier of the snapshot to restore.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "clusterName",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudBackupSnapshotRestoreJob resources.\n",
                "properties": {
                    "cancelled": {
                        "type": "boolean",
                        "description": "Indicates whether the restore job was canceled.\n"
                    },
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the Atlas cluster whose snapshot you want to restore.\n",
                        "willReplaceOnChanges": true
                    },
                    "deliveryTypeConfig": {
                        "$ref": "#/types/mongodbatlas:index/CloudBackupSnapshotRestoreJobDeliveryTypeConfig:CloudBackupSnapshotRestoreJobDeliveryTypeConfig",
                        "description": "Type of restore job to create. Possible configurations are: **download**, **automated**, or **pointInTime** only one must be set it in ``true``.\n* `delivery_type_config.automated` - Set to `true` to use the automated configuration.\n* `delivery_type_config.download` - Set to `true` to use the download configuration.\n* `delivery_type_config.pointInTime` - Set to `true` to use the pointInTime configuration. If using pointInTime configuration, you must also specify either `oplog_ts` and `oplog_inc`, or `point_in_time_utc_seconds`.\n* `delivery_type_config.target_cluster_name` - Name of the target Atlas cluster to which the restore job restores the snapshot. Required for **automated** and **pointInTime**.\n* `delivery_type_config.target_project_id` - Name of the target Atlas cluster to which the restore job restores the snapshot. Required for **automated** and **pointInTime**.\n* `delivery_type_config.oplog_ts` - Optional setting for **pointInTime** configuration. Timestamp in the number of seconds that have elapsed since the UNIX epoch from which to you want to restore this snapshot. This is the first part of an Oplog timestamp.\n* `delivery_type_config.oplog_inc` - Optional setting for **pointInTime** configuration. Oplog operation number from which to you want to restore this snapshot. This is the second part of an Oplog timestamp. Used in conjunction with `oplog_ts`.\n* `delivery_type_config.point_in_time_utc_seconds` - Optional setting for **pointInTime** configuration. Timestamp in the number of seconds that have elapsed since the UNIX epoch from which you want to restore this snapshot. Used instead of oplog settings.\n",
                        "willReplaceOnChanges": true
                    },
                    "deliveryUrls": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "One or more URLs for the compressed snapshot files for manual download. Only visible if deliveryType is download.\n"
                    },
                    "expired": {
                        "type": "boolean",
                        "description": "Indicates whether the restore job expired.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "UTC ISO 8601 formatted point in time when the restore job expires.\n"
                    },
                    "finishedAt": {
                        "type": "string",
                        "description": "UTC ISO 8601 formatted point in time when the restore job completed.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster whose snapshot you want to restore.\n",
                        "willReplaceOnChanges": true
                    },
                    "snapshotId": {
                        "type": "string",
                        "description": "Optional setting for **pointInTime** configuration. Unique identifier of the snapshot to restore.\n",
                        "willReplaceOnChanges": true
                    },
                    "snapshotRestoreJobId": {
                        "type": "string",
                        "description": "The unique identifier of the restore job.\n"
                    },
                    "timestamp": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when the snapshot associated to snapshotId was taken.\n* `oplogTs` - Timestamp in the number of seconds that have elapsed since the UNIX epoch from which to you want to restore this snapshot.\nThree conditions apply to this parameter:\n* Enable Continuous Cloud Backup on your cluster.\n* Specify oplogInc.\n* Specify either oplogTs and oplogInc or pointInTimeUTCSeconds, but not both.\n* `oplogInc` - Oplog operation number from which to you want to restore this snapshot. This is the second part of an Oplog timestamp.\nThree conditions apply to this parameter:\n* Enable Continuous Cloud Backup on your cluster.\n* Specify oplogTs.\n* Specify either oplogTs and oplogInc or pointInTimeUTCSeconds, but not both.\n* `pointInTimeUTCSeconds` - Timestamp in the number of seconds that have elapsed since the UNIX epoch from which you want to restore this snapshot.\nTwo conditions apply to this parameter:\n* Enable Continuous Cloud Backup on your cluster.\n* Specify either pointInTimeUTCSeconds or oplogTs and oplogInc, but not both.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/cloudProviderAccessAuthorization:CloudProviderAccessAuthorization": {
            "properties": {
                "authorizedDate": {
                    "type": "string"
                },
                "aws": {
                    "$ref": "#/types/mongodbatlas:index/CloudProviderAccessAuthorizationAws:CloudProviderAccessAuthorizationAws"
                },
                "azure": {
                    "$ref": "#/types/mongodbatlas:index/CloudProviderAccessAuthorizationAzure:CloudProviderAccessAuthorizationAzure"
                },
                "featureUsages": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudProviderAccessAuthorizationFeatureUsage:CloudProviderAccessAuthorizationFeatureUsage"
                    }
                },
                "projectId": {
                    "type": "string"
                },
                "roleId": {
                    "type": "string"
                }
            },
            "required": [
                "authorizedDate",
                "featureUsages",
                "projectId",
                "roleId"
            ],
            "inputProperties": {
                "aws": {
                    "$ref": "#/types/mongodbatlas:index/CloudProviderAccessAuthorizationAws:CloudProviderAccessAuthorizationAws"
                },
                "azure": {
                    "$ref": "#/types/mongodbatlas:index/CloudProviderAccessAuthorizationAzure:CloudProviderAccessAuthorizationAzure"
                },
                "projectId": {
                    "type": "string"
                },
                "roleId": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "projectId",
                "roleId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudProviderAccessAuthorization resources.\n",
                "properties": {
                    "authorizedDate": {
                        "type": "string"
                    },
                    "aws": {
                        "$ref": "#/types/mongodbatlas:index/CloudProviderAccessAuthorizationAws:CloudProviderAccessAuthorizationAws"
                    },
                    "azure": {
                        "$ref": "#/types/mongodbatlas:index/CloudProviderAccessAuthorizationAzure:CloudProviderAccessAuthorizationAzure"
                    },
                    "featureUsages": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/CloudProviderAccessAuthorizationFeatureUsage:CloudProviderAccessAuthorizationFeatureUsage"
                        }
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "roleId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/cloudProviderAccessSetup:CloudProviderAccessSetup": {
            "properties": {
                "awsConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudProviderAccessSetupAwsConfig:CloudProviderAccessSetupAwsConfig"
                    }
                },
                "azureConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudProviderAccessSetupAzureConfig:CloudProviderAccessSetupAzureConfig"
                    }
                },
                "createdDate": {
                    "type": "string"
                },
                "lastUpdatedDate": {
                    "type": "string"
                },
                "projectId": {
                    "type": "string"
                },
                "providerName": {
                    "type": "string"
                },
                "roleId": {
                    "type": "string"
                }
            },
            "required": [
                "awsConfigs",
                "createdDate",
                "lastUpdatedDate",
                "projectId",
                "providerName",
                "roleId"
            ],
            "inputProperties": {
                "azureConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CloudProviderAccessSetupAzureConfig:CloudProviderAccessSetupAzureConfig"
                    }
                },
                "projectId": {
                    "type": "string"
                },
                "providerName": {
                    "type": "string",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "projectId",
                "providerName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CloudProviderAccessSetup resources.\n",
                "properties": {
                    "awsConfigs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/CloudProviderAccessSetupAwsConfig:CloudProviderAccessSetupAwsConfig"
                        }
                    },
                    "azureConfigs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/CloudProviderAccessSetupAzureConfig:CloudProviderAccessSetupAzureConfig"
                        }
                    },
                    "createdDate": {
                        "type": "string"
                    },
                    "lastUpdatedDate": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "providerName": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "roleId": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/cluster:Cluster": {
            "description": "## Example Usage\n\n### Example AWS cluster\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst cluster_test = new mongodbatlas.Cluster(\"cluster-test\", {\n    projectId: \"\u003cYOUR-PROJECT-ID\u003e\",\n    name: \"cluster-test\",\n    clusterType: \"REPLICASET\",\n    replicationSpecs: [{\n        numShards: 1,\n        regionsConfigs: [{\n            regionName: \"US_EAST_1\",\n            electableNodes: 3,\n            priority: 7,\n            readOnlyNodes: 0,\n        }],\n    }],\n    cloudBackup: true,\n    autoScalingDiskGbEnabled: true,\n    mongoDbMajorVersion: \"7.0\",\n    providerName: \"AWS\",\n    providerInstanceSizeName: \"M40\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ncluster_test = mongodbatlas.Cluster(\"cluster-test\",\n    project_id=\"\u003cYOUR-PROJECT-ID\u003e\",\n    name=\"cluster-test\",\n    cluster_type=\"REPLICASET\",\n    replication_specs=[{\n        \"num_shards\": 1,\n        \"regions_configs\": [{\n            \"region_name\": \"US_EAST_1\",\n            \"electable_nodes\": 3,\n            \"priority\": 7,\n            \"read_only_nodes\": 0,\n        }],\n    }],\n    cloud_backup=True,\n    auto_scaling_disk_gb_enabled=True,\n    mongo_db_major_version=\"7.0\",\n    provider_name=\"AWS\",\n    provider_instance_size_name=\"M40\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var cluster_test = new Mongodbatlas.Cluster(\"cluster-test\", new()\n    {\n        ProjectId = \"\u003cYOUR-PROJECT-ID\u003e\",\n        Name = \"cluster-test\",\n        ClusterType = \"REPLICASET\",\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.ClusterReplicationSpecArgs\n            {\n                NumShards = 1,\n                RegionsConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.ClusterReplicationSpecRegionsConfigArgs\n                    {\n                        RegionName = \"US_EAST_1\",\n                        ElectableNodes = 3,\n                        Priority = 7,\n                        ReadOnlyNodes = 0,\n                    },\n                },\n            },\n        },\n        CloudBackup = true,\n        AutoScalingDiskGbEnabled = true,\n        MongoDbMajorVersion = \"7.0\",\n        ProviderName = \"AWS\",\n        ProviderInstanceSizeName = \"M40\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewCluster(ctx, \"cluster-test\", \u0026mongodbatlas.ClusterArgs{\n\t\t\tProjectId:   pulumi.String(\"\u003cYOUR-PROJECT-ID\u003e\"),\n\t\t\tName:        pulumi.String(\"cluster-test\"),\n\t\t\tClusterType: pulumi.String(\"REPLICASET\"),\n\t\t\tReplicationSpecs: mongodbatlas.ClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecArgs{\n\t\t\t\t\tNumShards: pulumi.Int(1),\n\t\t\t\t\tRegionsConfigs: mongodbatlas.ClusterReplicationSpecRegionsConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecRegionsConfigArgs{\n\t\t\t\t\t\t\tRegionName:     pulumi.String(\"US_EAST_1\"),\n\t\t\t\t\t\t\tElectableNodes: pulumi.Int(3),\n\t\t\t\t\t\t\tPriority:       pulumi.Int(7),\n\t\t\t\t\t\t\tReadOnlyNodes:  pulumi.Int(0),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tCloudBackup:              pulumi.Bool(true),\n\t\t\tAutoScalingDiskGbEnabled: pulumi.Bool(true),\n\t\t\tMongoDbMajorVersion:      pulumi.String(\"7.0\"),\n\t\t\tProviderName:             pulumi.String(\"AWS\"),\n\t\t\tProviderInstanceSizeName: pulumi.String(\"M40\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Cluster;\nimport com.pulumi.mongodbatlas.ClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.ClusterReplicationSpecArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var cluster_test = new Cluster(\"cluster-test\", ClusterArgs.builder()\n            .projectId(\"\u003cYOUR-PROJECT-ID\u003e\")\n            .name(\"cluster-test\")\n            .clusterType(\"REPLICASET\")\n            .replicationSpecs(ClusterReplicationSpecArgs.builder()\n                .numShards(1)\n                .regionsConfigs(ClusterReplicationSpecRegionsConfigArgs.builder()\n                    .regionName(\"US_EAST_1\")\n                    .electableNodes(3)\n                    .priority(7)\n                    .readOnlyNodes(0)\n                    .build())\n                .build())\n            .cloudBackup(true)\n            .autoScalingDiskGbEnabled(true)\n            .mongoDbMajorVersion(\"7.0\")\n            .providerName(\"AWS\")\n            .providerInstanceSizeName(\"M40\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  cluster-test:\n    type: mongodbatlas:Cluster\n    properties:\n      projectId: \u003cYOUR-PROJECT-ID\u003e\n      name: cluster-test\n      clusterType: REPLICASET\n      replicationSpecs:\n        - numShards: 1\n          regionsConfigs:\n            - regionName: US_EAST_1\n              electableNodes: 3\n              priority: 7\n              readOnlyNodes: 0\n      cloudBackup: true\n      autoScalingDiskGbEnabled: true\n      mongoDbMajorVersion: '7.0'\n      providerName: AWS\n      providerInstanceSizeName: M40\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example Azure cluster.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.Cluster(\"test\", {\n    projectId: \"\u003cYOUR-PROJECT-ID\u003e\",\n    name: \"test\",\n    clusterType: \"REPLICASET\",\n    replicationSpecs: [{\n        numShards: 1,\n        regionsConfigs: [{\n            regionName: \"US_EAST\",\n            electableNodes: 3,\n            priority: 7,\n            readOnlyNodes: 0,\n        }],\n    }],\n    cloudBackup: true,\n    autoScalingDiskGbEnabled: true,\n    mongoDbMajorVersion: \"7.0\",\n    providerName: \"AZURE\",\n    providerDiskTypeName: \"P6\",\n    providerInstanceSizeName: \"M30\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.Cluster(\"test\",\n    project_id=\"\u003cYOUR-PROJECT-ID\u003e\",\n    name=\"test\",\n    cluster_type=\"REPLICASET\",\n    replication_specs=[{\n        \"num_shards\": 1,\n        \"regions_configs\": [{\n            \"region_name\": \"US_EAST\",\n            \"electable_nodes\": 3,\n            \"priority\": 7,\n            \"read_only_nodes\": 0,\n        }],\n    }],\n    cloud_backup=True,\n    auto_scaling_disk_gb_enabled=True,\n    mongo_db_major_version=\"7.0\",\n    provider_name=\"AZURE\",\n    provider_disk_type_name=\"P6\",\n    provider_instance_size_name=\"M30\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.Cluster(\"test\", new()\n    {\n        ProjectId = \"\u003cYOUR-PROJECT-ID\u003e\",\n        Name = \"test\",\n        ClusterType = \"REPLICASET\",\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.ClusterReplicationSpecArgs\n            {\n                NumShards = 1,\n                RegionsConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.ClusterReplicationSpecRegionsConfigArgs\n                    {\n                        RegionName = \"US_EAST\",\n                        ElectableNodes = 3,\n                        Priority = 7,\n                        ReadOnlyNodes = 0,\n                    },\n                },\n            },\n        },\n        CloudBackup = true,\n        AutoScalingDiskGbEnabled = true,\n        MongoDbMajorVersion = \"7.0\",\n        ProviderName = \"AZURE\",\n        ProviderDiskTypeName = \"P6\",\n        ProviderInstanceSizeName = \"M30\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewCluster(ctx, \"test\", \u0026mongodbatlas.ClusterArgs{\n\t\t\tProjectId:   pulumi.String(\"\u003cYOUR-PROJECT-ID\u003e\"),\n\t\t\tName:        pulumi.String(\"test\"),\n\t\t\tClusterType: pulumi.String(\"REPLICASET\"),\n\t\t\tReplicationSpecs: mongodbatlas.ClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecArgs{\n\t\t\t\t\tNumShards: pulumi.Int(1),\n\t\t\t\t\tRegionsConfigs: mongodbatlas.ClusterReplicationSpecRegionsConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecRegionsConfigArgs{\n\t\t\t\t\t\t\tRegionName:     pulumi.String(\"US_EAST\"),\n\t\t\t\t\t\t\tElectableNodes: pulumi.Int(3),\n\t\t\t\t\t\t\tPriority:       pulumi.Int(7),\n\t\t\t\t\t\t\tReadOnlyNodes:  pulumi.Int(0),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tCloudBackup:              pulumi.Bool(true),\n\t\t\tAutoScalingDiskGbEnabled: pulumi.Bool(true),\n\t\t\tMongoDbMajorVersion:      pulumi.String(\"7.0\"),\n\t\t\tProviderName:             pulumi.String(\"AZURE\"),\n\t\t\tProviderDiskTypeName:     pulumi.String(\"P6\"),\n\t\t\tProviderInstanceSizeName: pulumi.String(\"M30\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Cluster;\nimport com.pulumi.mongodbatlas.ClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.ClusterReplicationSpecArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new Cluster(\"test\", ClusterArgs.builder()\n            .projectId(\"\u003cYOUR-PROJECT-ID\u003e\")\n            .name(\"test\")\n            .clusterType(\"REPLICASET\")\n            .replicationSpecs(ClusterReplicationSpecArgs.builder()\n                .numShards(1)\n                .regionsConfigs(ClusterReplicationSpecRegionsConfigArgs.builder()\n                    .regionName(\"US_EAST\")\n                    .electableNodes(3)\n                    .priority(7)\n                    .readOnlyNodes(0)\n                    .build())\n                .build())\n            .cloudBackup(true)\n            .autoScalingDiskGbEnabled(true)\n            .mongoDbMajorVersion(\"7.0\")\n            .providerName(\"AZURE\")\n            .providerDiskTypeName(\"P6\")\n            .providerInstanceSizeName(\"M30\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:Cluster\n    properties:\n      projectId: \u003cYOUR-PROJECT-ID\u003e\n      name: test\n      clusterType: REPLICASET\n      replicationSpecs:\n        - numShards: 1\n          regionsConfigs:\n            - regionName: US_EAST\n              electableNodes: 3\n              priority: 7\n              readOnlyNodes: 0\n      cloudBackup: true\n      autoScalingDiskGbEnabled: true\n      mongoDbMajorVersion: '7.0'\n      providerName: AZURE\n      providerDiskTypeName: P6\n      providerInstanceSizeName: M30\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example GCP cluster\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.Cluster(\"test\", {\n    projectId: \"\u003cYOUR-PROJECT-ID\u003e\",\n    name: \"test\",\n    clusterType: \"REPLICASET\",\n    replicationSpecs: [{\n        numShards: 1,\n        regionsConfigs: [{\n            regionName: \"EASTERN_US\",\n            electableNodes: 3,\n            priority: 7,\n            readOnlyNodes: 0,\n        }],\n    }],\n    cloudBackup: true,\n    autoScalingDiskGbEnabled: true,\n    mongoDbMajorVersion: \"7.0\",\n    providerName: \"GCP\",\n    providerInstanceSizeName: \"M30\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.Cluster(\"test\",\n    project_id=\"\u003cYOUR-PROJECT-ID\u003e\",\n    name=\"test\",\n    cluster_type=\"REPLICASET\",\n    replication_specs=[{\n        \"num_shards\": 1,\n        \"regions_configs\": [{\n            \"region_name\": \"EASTERN_US\",\n            \"electable_nodes\": 3,\n            \"priority\": 7,\n            \"read_only_nodes\": 0,\n        }],\n    }],\n    cloud_backup=True,\n    auto_scaling_disk_gb_enabled=True,\n    mongo_db_major_version=\"7.0\",\n    provider_name=\"GCP\",\n    provider_instance_size_name=\"M30\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.Cluster(\"test\", new()\n    {\n        ProjectId = \"\u003cYOUR-PROJECT-ID\u003e\",\n        Name = \"test\",\n        ClusterType = \"REPLICASET\",\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.ClusterReplicationSpecArgs\n            {\n                NumShards = 1,\n                RegionsConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.ClusterReplicationSpecRegionsConfigArgs\n                    {\n                        RegionName = \"EASTERN_US\",\n                        ElectableNodes = 3,\n                        Priority = 7,\n                        ReadOnlyNodes = 0,\n                    },\n                },\n            },\n        },\n        CloudBackup = true,\n        AutoScalingDiskGbEnabled = true,\n        MongoDbMajorVersion = \"7.0\",\n        ProviderName = \"GCP\",\n        ProviderInstanceSizeName = \"M30\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewCluster(ctx, \"test\", \u0026mongodbatlas.ClusterArgs{\n\t\t\tProjectId:   pulumi.String(\"\u003cYOUR-PROJECT-ID\u003e\"),\n\t\t\tName:        pulumi.String(\"test\"),\n\t\t\tClusterType: pulumi.String(\"REPLICASET\"),\n\t\t\tReplicationSpecs: mongodbatlas.ClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecArgs{\n\t\t\t\t\tNumShards: pulumi.Int(1),\n\t\t\t\t\tRegionsConfigs: mongodbatlas.ClusterReplicationSpecRegionsConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecRegionsConfigArgs{\n\t\t\t\t\t\t\tRegionName:     pulumi.String(\"EASTERN_US\"),\n\t\t\t\t\t\t\tElectableNodes: pulumi.Int(3),\n\t\t\t\t\t\t\tPriority:       pulumi.Int(7),\n\t\t\t\t\t\t\tReadOnlyNodes:  pulumi.Int(0),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tCloudBackup:              pulumi.Bool(true),\n\t\t\tAutoScalingDiskGbEnabled: pulumi.Bool(true),\n\t\t\tMongoDbMajorVersion:      pulumi.String(\"7.0\"),\n\t\t\tProviderName:             pulumi.String(\"GCP\"),\n\t\t\tProviderInstanceSizeName: pulumi.String(\"M30\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Cluster;\nimport com.pulumi.mongodbatlas.ClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.ClusterReplicationSpecArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new Cluster(\"test\", ClusterArgs.builder()\n            .projectId(\"\u003cYOUR-PROJECT-ID\u003e\")\n            .name(\"test\")\n            .clusterType(\"REPLICASET\")\n            .replicationSpecs(ClusterReplicationSpecArgs.builder()\n                .numShards(1)\n                .regionsConfigs(ClusterReplicationSpecRegionsConfigArgs.builder()\n                    .regionName(\"EASTERN_US\")\n                    .electableNodes(3)\n                    .priority(7)\n                    .readOnlyNodes(0)\n                    .build())\n                .build())\n            .cloudBackup(true)\n            .autoScalingDiskGbEnabled(true)\n            .mongoDbMajorVersion(\"7.0\")\n            .providerName(\"GCP\")\n            .providerInstanceSizeName(\"M30\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:Cluster\n    properties:\n      projectId: \u003cYOUR-PROJECT-ID\u003e\n      name: test\n      clusterType: REPLICASET\n      replicationSpecs:\n        - numShards: 1\n          regionsConfigs:\n            - regionName: EASTERN_US\n              electableNodes: 3\n              priority: 7\n              readOnlyNodes: 0\n      cloudBackup: true\n      autoScalingDiskGbEnabled: true\n      mongoDbMajorVersion: '7.0'\n      providerName: GCP\n      providerInstanceSizeName: M30\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example Multi Region cluster\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst cluster_test = new mongodbatlas.Cluster(\"cluster-test\", {\n    projectId: \"\u003cYOUR-PROJECT-ID\u003e\",\n    name: \"cluster-test-multi-region\",\n    numShards: 1,\n    cloudBackup: true,\n    clusterType: \"REPLICASET\",\n    providerName: \"AWS\",\n    providerInstanceSizeName: \"M10\",\n    replicationSpecs: [{\n        numShards: 1,\n        regionsConfigs: [\n            {\n                regionName: \"US_EAST_1\",\n                electableNodes: 3,\n                priority: 7,\n                readOnlyNodes: 0,\n            },\n            {\n                regionName: \"US_EAST_2\",\n                electableNodes: 2,\n                priority: 6,\n                readOnlyNodes: 0,\n            },\n            {\n                regionName: \"US_WEST_1\",\n                electableNodes: 2,\n                priority: 5,\n                readOnlyNodes: 2,\n            },\n        ],\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ncluster_test = mongodbatlas.Cluster(\"cluster-test\",\n    project_id=\"\u003cYOUR-PROJECT-ID\u003e\",\n    name=\"cluster-test-multi-region\",\n    num_shards=1,\n    cloud_backup=True,\n    cluster_type=\"REPLICASET\",\n    provider_name=\"AWS\",\n    provider_instance_size_name=\"M10\",\n    replication_specs=[{\n        \"num_shards\": 1,\n        \"regions_configs\": [\n            {\n                \"region_name\": \"US_EAST_1\",\n                \"electable_nodes\": 3,\n                \"priority\": 7,\n                \"read_only_nodes\": 0,\n            },\n            {\n                \"region_name\": \"US_EAST_2\",\n                \"electable_nodes\": 2,\n                \"priority\": 6,\n                \"read_only_nodes\": 0,\n            },\n            {\n                \"region_name\": \"US_WEST_1\",\n                \"electable_nodes\": 2,\n                \"priority\": 5,\n                \"read_only_nodes\": 2,\n            },\n        ],\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var cluster_test = new Mongodbatlas.Cluster(\"cluster-test\", new()\n    {\n        ProjectId = \"\u003cYOUR-PROJECT-ID\u003e\",\n        Name = \"cluster-test-multi-region\",\n        NumShards = 1,\n        CloudBackup = true,\n        ClusterType = \"REPLICASET\",\n        ProviderName = \"AWS\",\n        ProviderInstanceSizeName = \"M10\",\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.ClusterReplicationSpecArgs\n            {\n                NumShards = 1,\n                RegionsConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.ClusterReplicationSpecRegionsConfigArgs\n                    {\n                        RegionName = \"US_EAST_1\",\n                        ElectableNodes = 3,\n                        Priority = 7,\n                        ReadOnlyNodes = 0,\n                    },\n                    new Mongodbatlas.Inputs.ClusterReplicationSpecRegionsConfigArgs\n                    {\n                        RegionName = \"US_EAST_2\",\n                        ElectableNodes = 2,\n                        Priority = 6,\n                        ReadOnlyNodes = 0,\n                    },\n                    new Mongodbatlas.Inputs.ClusterReplicationSpecRegionsConfigArgs\n                    {\n                        RegionName = \"US_WEST_1\",\n                        ElectableNodes = 2,\n                        Priority = 5,\n                        ReadOnlyNodes = 2,\n                    },\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewCluster(ctx, \"cluster-test\", \u0026mongodbatlas.ClusterArgs{\n\t\t\tProjectId:                pulumi.String(\"\u003cYOUR-PROJECT-ID\u003e\"),\n\t\t\tName:                     pulumi.String(\"cluster-test-multi-region\"),\n\t\t\tNumShards:                pulumi.Int(1),\n\t\t\tCloudBackup:              pulumi.Bool(true),\n\t\t\tClusterType:              pulumi.String(\"REPLICASET\"),\n\t\t\tProviderName:             pulumi.String(\"AWS\"),\n\t\t\tProviderInstanceSizeName: pulumi.String(\"M10\"),\n\t\t\tReplicationSpecs: mongodbatlas.ClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecArgs{\n\t\t\t\t\tNumShards: pulumi.Int(1),\n\t\t\t\t\tRegionsConfigs: mongodbatlas.ClusterReplicationSpecRegionsConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecRegionsConfigArgs{\n\t\t\t\t\t\t\tRegionName:     pulumi.String(\"US_EAST_1\"),\n\t\t\t\t\t\t\tElectableNodes: pulumi.Int(3),\n\t\t\t\t\t\t\tPriority:       pulumi.Int(7),\n\t\t\t\t\t\t\tReadOnlyNodes:  pulumi.Int(0),\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecRegionsConfigArgs{\n\t\t\t\t\t\t\tRegionName:     pulumi.String(\"US_EAST_2\"),\n\t\t\t\t\t\t\tElectableNodes: pulumi.Int(2),\n\t\t\t\t\t\t\tPriority:       pulumi.Int(6),\n\t\t\t\t\t\t\tReadOnlyNodes:  pulumi.Int(0),\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecRegionsConfigArgs{\n\t\t\t\t\t\t\tRegionName:     pulumi.String(\"US_WEST_1\"),\n\t\t\t\t\t\t\tElectableNodes: pulumi.Int(2),\n\t\t\t\t\t\t\tPriority:       pulumi.Int(5),\n\t\t\t\t\t\t\tReadOnlyNodes:  pulumi.Int(2),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Cluster;\nimport com.pulumi.mongodbatlas.ClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.ClusterReplicationSpecArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var cluster_test = new Cluster(\"cluster-test\", ClusterArgs.builder()\n            .projectId(\"\u003cYOUR-PROJECT-ID\u003e\")\n            .name(\"cluster-test-multi-region\")\n            .numShards(1)\n            .cloudBackup(true)\n            .clusterType(\"REPLICASET\")\n            .providerName(\"AWS\")\n            .providerInstanceSizeName(\"M10\")\n            .replicationSpecs(ClusterReplicationSpecArgs.builder()\n                .numShards(1)\n                .regionsConfigs(                \n                    ClusterReplicationSpecRegionsConfigArgs.builder()\n                        .regionName(\"US_EAST_1\")\n                        .electableNodes(3)\n                        .priority(7)\n                        .readOnlyNodes(0)\n                        .build(),\n                    ClusterReplicationSpecRegionsConfigArgs.builder()\n                        .regionName(\"US_EAST_2\")\n                        .electableNodes(2)\n                        .priority(6)\n                        .readOnlyNodes(0)\n                        .build(),\n                    ClusterReplicationSpecRegionsConfigArgs.builder()\n                        .regionName(\"US_WEST_1\")\n                        .electableNodes(2)\n                        .priority(5)\n                        .readOnlyNodes(2)\n                        .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  cluster-test:\n    type: mongodbatlas:Cluster\n    properties:\n      projectId: \u003cYOUR-PROJECT-ID\u003e\n      name: cluster-test-multi-region\n      numShards: 1\n      cloudBackup: true\n      clusterType: REPLICASET\n      providerName: AWS\n      providerInstanceSizeName: M10\n      replicationSpecs:\n        - numShards: 1\n          regionsConfigs:\n            - regionName: US_EAST_1\n              electableNodes: 3\n              priority: 7\n              readOnlyNodes: 0\n            - regionName: US_EAST_2\n              electableNodes: 2\n              priority: 6\n              readOnlyNodes: 0\n            - regionName: US_WEST_1\n              electableNodes: 2\n              priority: 5\n              readOnlyNodes: 2\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example Global cluster\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst cluster_test = new mongodbatlas.Cluster(\"cluster-test\", {\n    projectId: \"\u003cYOUR-PROJECT-ID\u003e\",\n    name: \"cluster-test-global\",\n    numShards: 1,\n    cloudBackup: true,\n    clusterType: \"GEOSHARDED\",\n    providerName: \"AWS\",\n    providerInstanceSizeName: \"M30\",\n    replicationSpecs: [\n        {\n            zoneName: \"Zone 1\",\n            numShards: 2,\n            regionsConfigs: [{\n                regionName: \"US_EAST_1\",\n                electableNodes: 3,\n                priority: 7,\n                readOnlyNodes: 0,\n            }],\n        },\n        {\n            zoneName: \"Zone 2\",\n            numShards: 2,\n            regionsConfigs: [{\n                regionName: \"EU_CENTRAL_1\",\n                electableNodes: 3,\n                priority: 7,\n                readOnlyNodes: 0,\n            }],\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ncluster_test = mongodbatlas.Cluster(\"cluster-test\",\n    project_id=\"\u003cYOUR-PROJECT-ID\u003e\",\n    name=\"cluster-test-global\",\n    num_shards=1,\n    cloud_backup=True,\n    cluster_type=\"GEOSHARDED\",\n    provider_name=\"AWS\",\n    provider_instance_size_name=\"M30\",\n    replication_specs=[\n        {\n            \"zone_name\": \"Zone 1\",\n            \"num_shards\": 2,\n            \"regions_configs\": [{\n                \"region_name\": \"US_EAST_1\",\n                \"electable_nodes\": 3,\n                \"priority\": 7,\n                \"read_only_nodes\": 0,\n            }],\n        },\n        {\n            \"zone_name\": \"Zone 2\",\n            \"num_shards\": 2,\n            \"regions_configs\": [{\n                \"region_name\": \"EU_CENTRAL_1\",\n                \"electable_nodes\": 3,\n                \"priority\": 7,\n                \"read_only_nodes\": 0,\n            }],\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var cluster_test = new Mongodbatlas.Cluster(\"cluster-test\", new()\n    {\n        ProjectId = \"\u003cYOUR-PROJECT-ID\u003e\",\n        Name = \"cluster-test-global\",\n        NumShards = 1,\n        CloudBackup = true,\n        ClusterType = \"GEOSHARDED\",\n        ProviderName = \"AWS\",\n        ProviderInstanceSizeName = \"M30\",\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.ClusterReplicationSpecArgs\n            {\n                ZoneName = \"Zone 1\",\n                NumShards = 2,\n                RegionsConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.ClusterReplicationSpecRegionsConfigArgs\n                    {\n                        RegionName = \"US_EAST_1\",\n                        ElectableNodes = 3,\n                        Priority = 7,\n                        ReadOnlyNodes = 0,\n                    },\n                },\n            },\n            new Mongodbatlas.Inputs.ClusterReplicationSpecArgs\n            {\n                ZoneName = \"Zone 2\",\n                NumShards = 2,\n                RegionsConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.ClusterReplicationSpecRegionsConfigArgs\n                    {\n                        RegionName = \"EU_CENTRAL_1\",\n                        ElectableNodes = 3,\n                        Priority = 7,\n                        ReadOnlyNodes = 0,\n                    },\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewCluster(ctx, \"cluster-test\", \u0026mongodbatlas.ClusterArgs{\n\t\t\tProjectId:                pulumi.String(\"\u003cYOUR-PROJECT-ID\u003e\"),\n\t\t\tName:                     pulumi.String(\"cluster-test-global\"),\n\t\t\tNumShards:                pulumi.Int(1),\n\t\t\tCloudBackup:              pulumi.Bool(true),\n\t\t\tClusterType:              pulumi.String(\"GEOSHARDED\"),\n\t\t\tProviderName:             pulumi.String(\"AWS\"),\n\t\t\tProviderInstanceSizeName: pulumi.String(\"M30\"),\n\t\t\tReplicationSpecs: mongodbatlas.ClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecArgs{\n\t\t\t\t\tZoneName:  pulumi.String(\"Zone 1\"),\n\t\t\t\t\tNumShards: pulumi.Int(2),\n\t\t\t\t\tRegionsConfigs: mongodbatlas.ClusterReplicationSpecRegionsConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecRegionsConfigArgs{\n\t\t\t\t\t\t\tRegionName:     pulumi.String(\"US_EAST_1\"),\n\t\t\t\t\t\t\tElectableNodes: pulumi.Int(3),\n\t\t\t\t\t\t\tPriority:       pulumi.Int(7),\n\t\t\t\t\t\t\tReadOnlyNodes:  pulumi.Int(0),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecArgs{\n\t\t\t\t\tZoneName:  pulumi.String(\"Zone 2\"),\n\t\t\t\t\tNumShards: pulumi.Int(2),\n\t\t\t\t\tRegionsConfigs: mongodbatlas.ClusterReplicationSpecRegionsConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecRegionsConfigArgs{\n\t\t\t\t\t\t\tRegionName:     pulumi.String(\"EU_CENTRAL_1\"),\n\t\t\t\t\t\t\tElectableNodes: pulumi.Int(3),\n\t\t\t\t\t\t\tPriority:       pulumi.Int(7),\n\t\t\t\t\t\t\tReadOnlyNodes:  pulumi.Int(0),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Cluster;\nimport com.pulumi.mongodbatlas.ClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.ClusterReplicationSpecArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var cluster_test = new Cluster(\"cluster-test\", ClusterArgs.builder()\n            .projectId(\"\u003cYOUR-PROJECT-ID\u003e\")\n            .name(\"cluster-test-global\")\n            .numShards(1)\n            .cloudBackup(true)\n            .clusterType(\"GEOSHARDED\")\n            .providerName(\"AWS\")\n            .providerInstanceSizeName(\"M30\")\n            .replicationSpecs(            \n                ClusterReplicationSpecArgs.builder()\n                    .zoneName(\"Zone 1\")\n                    .numShards(2)\n                    .regionsConfigs(ClusterReplicationSpecRegionsConfigArgs.builder()\n                        .regionName(\"US_EAST_1\")\n                        .electableNodes(3)\n                        .priority(7)\n                        .readOnlyNodes(0)\n                        .build())\n                    .build(),\n                ClusterReplicationSpecArgs.builder()\n                    .zoneName(\"Zone 2\")\n                    .numShards(2)\n                    .regionsConfigs(ClusterReplicationSpecRegionsConfigArgs.builder()\n                        .regionName(\"EU_CENTRAL_1\")\n                        .electableNodes(3)\n                        .priority(7)\n                        .readOnlyNodes(0)\n                        .build())\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  cluster-test:\n    type: mongodbatlas:Cluster\n    properties:\n      projectId: \u003cYOUR-PROJECT-ID\u003e\n      name: cluster-test-global\n      numShards: 1\n      cloudBackup: true\n      clusterType: GEOSHARDED\n      providerName: AWS\n      providerInstanceSizeName: M30\n      replicationSpecs:\n        - zoneName: Zone 1\n          numShards: 2\n          regionsConfigs:\n            - regionName: US_EAST_1\n              electableNodes: 3\n              priority: 7\n              readOnlyNodes: 0\n        - zoneName: Zone 2\n          numShards: 2\n          regionsConfigs:\n            - regionName: EU_CENTRAL_1\n              electableNodes: 3\n              priority: 7\n              readOnlyNodes: 0\n```\n\u003c!--End PulumiCodeChooser --\u003e\n### Example AWS Shared Tier (M2/M5) cluster\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst cluster_test = new mongodbatlas.Cluster(\"cluster-test\", {\n    projectId: \"\u003cYOUR-PROJECT-ID\u003e\",\n    name: \"cluster-test-global\",\n    providerName: \"TENANT\",\n    backingProviderName: \"AWS\",\n    providerRegionName: \"US_EAST_1\",\n    providerInstanceSizeName: \"M2\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ncluster_test = mongodbatlas.Cluster(\"cluster-test\",\n    project_id=\"\u003cYOUR-PROJECT-ID\u003e\",\n    name=\"cluster-test-global\",\n    provider_name=\"TENANT\",\n    backing_provider_name=\"AWS\",\n    provider_region_name=\"US_EAST_1\",\n    provider_instance_size_name=\"M2\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var cluster_test = new Mongodbatlas.Cluster(\"cluster-test\", new()\n    {\n        ProjectId = \"\u003cYOUR-PROJECT-ID\u003e\",\n        Name = \"cluster-test-global\",\n        ProviderName = \"TENANT\",\n        BackingProviderName = \"AWS\",\n        ProviderRegionName = \"US_EAST_1\",\n        ProviderInstanceSizeName = \"M2\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewCluster(ctx, \"cluster-test\", \u0026mongodbatlas.ClusterArgs{\n\t\t\tProjectId:                pulumi.String(\"\u003cYOUR-PROJECT-ID\u003e\"),\n\t\t\tName:                     pulumi.String(\"cluster-test-global\"),\n\t\t\tProviderName:             pulumi.String(\"TENANT\"),\n\t\t\tBackingProviderName:      pulumi.String(\"AWS\"),\n\t\t\tProviderRegionName:       pulumi.String(\"US_EAST_1\"),\n\t\t\tProviderInstanceSizeName: pulumi.String(\"M2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Cluster;\nimport com.pulumi.mongodbatlas.ClusterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var cluster_test = new Cluster(\"cluster-test\", ClusterArgs.builder()\n            .projectId(\"\u003cYOUR-PROJECT-ID\u003e\")\n            .name(\"cluster-test-global\")\n            .providerName(\"TENANT\")\n            .backingProviderName(\"AWS\")\n            .providerRegionName(\"US_EAST_1\")\n            .providerInstanceSizeName(\"M2\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  cluster-test:\n    type: mongodbatlas:Cluster\n    properties:\n      projectId: \u003cYOUR-PROJECT-ID\u003e\n      name: cluster-test-global\n      providerName: TENANT\n      backingProviderName: AWS\n      providerRegionName: US_EAST_1\n      providerInstanceSizeName: M2\n```\n\u003c!--End PulumiCodeChooser --\u003e\n### Example AWS Free Tier cluster\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst cluster_test = new mongodbatlas.Cluster(\"cluster-test\", {\n    projectId: \"\u003cYOUR-PROJECT-ID\u003e\",\n    name: \"cluster-test-global\",\n    providerName: \"TENANT\",\n    backingProviderName: \"AWS\",\n    providerRegionName: \"US_EAST_1\",\n    providerInstanceSizeName: \"M0\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ncluster_test = mongodbatlas.Cluster(\"cluster-test\",\n    project_id=\"\u003cYOUR-PROJECT-ID\u003e\",\n    name=\"cluster-test-global\",\n    provider_name=\"TENANT\",\n    backing_provider_name=\"AWS\",\n    provider_region_name=\"US_EAST_1\",\n    provider_instance_size_name=\"M0\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var cluster_test = new Mongodbatlas.Cluster(\"cluster-test\", new()\n    {\n        ProjectId = \"\u003cYOUR-PROJECT-ID\u003e\",\n        Name = \"cluster-test-global\",\n        ProviderName = \"TENANT\",\n        BackingProviderName = \"AWS\",\n        ProviderRegionName = \"US_EAST_1\",\n        ProviderInstanceSizeName = \"M0\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewCluster(ctx, \"cluster-test\", \u0026mongodbatlas.ClusterArgs{\n\t\t\tProjectId:                pulumi.String(\"\u003cYOUR-PROJECT-ID\u003e\"),\n\t\t\tName:                     pulumi.String(\"cluster-test-global\"),\n\t\t\tProviderName:             pulumi.String(\"TENANT\"),\n\t\t\tBackingProviderName:      pulumi.String(\"AWS\"),\n\t\t\tProviderRegionName:       pulumi.String(\"US_EAST_1\"),\n\t\t\tProviderInstanceSizeName: pulumi.String(\"M0\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Cluster;\nimport com.pulumi.mongodbatlas.ClusterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var cluster_test = new Cluster(\"cluster-test\", ClusterArgs.builder()\n            .projectId(\"\u003cYOUR-PROJECT-ID\u003e\")\n            .name(\"cluster-test-global\")\n            .providerName(\"TENANT\")\n            .backingProviderName(\"AWS\")\n            .providerRegionName(\"US_EAST_1\")\n            .providerInstanceSizeName(\"M0\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  cluster-test:\n    type: mongodbatlas:Cluster\n    properties:\n      projectId: \u003cYOUR-PROJECT-ID\u003e\n      name: cluster-test-global\n      providerName: TENANT\n      backingProviderName: AWS\n      providerRegionName: US_EAST_1\n      providerInstanceSizeName: M0\n```\n\u003c!--End PulumiCodeChooser --\u003e\n### Example - Return a Connection String\nStandard\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n\nexport const standard = cluster_test.connectionStrings[0].standard;\n```\n```python\nimport pulumi\n\npulumi.export(\"standard\", cluster_test[\"connectionStrings\"][0][\"standard\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"standard\"] = cluster_test.ConnectionStrings[0].Standard,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tctx.Export(\"standard\", cluster_test.ConnectionStrings[0].Standard)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        ctx.export(\"standard\", cluster_test.connectionStrings()[0].standard());\n    }\n}\n```\n```yaml\noutputs:\n  standard: ${[\"cluster-test\"].connectionStrings[0].standard}\n```\n\u003c!--End PulumiCodeChooser --\u003e\nStandard srv\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\n\nexport const standardSrv = cluster_test.connectionStrings[0].standardSrv;\n```\n```python\nimport pulumi\n\npulumi.export(\"standardSrv\", cluster_test[\"connectionStrings\"][0][\"standardSrv\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"standardSrv\"] = cluster_test.ConnectionStrings[0].StandardSrv,\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tctx.Export(\"standardSrv\", cluster_test.ConnectionStrings[0].StandardSrv)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        ctx.export(\"standardSrv\", cluster_test.connectionStrings()[0].standardSrv());\n    }\n}\n```\n```yaml\noutputs:\n  standardSrv: ${[\"cluster-test\"].connectionStrings[0].standardSrv}\n```\n\u003c!--End PulumiCodeChooser --\u003e\nPrivate with Network peering and Custom DNS AWS enabled\n## Import\n\nClusters can be imported using project ID and cluster name, in the format `PROJECTID-CLUSTERNAME`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/cluster:Cluster my_cluster 1112222b3bf99403840e8934-Cluster0\n```\nSee detailed information for arguments and attributes: [MongoDB API Clusters](https://docs.atlas.mongodb.com/reference/api/clusters-create-one/)\n\n",
            "properties": {
                "acceptDataRisksAndForceReplicaSetReconfig": {
                    "type": "string",
                    "description": "If reconfiguration is necessary to regain a primary due to a regional outage, submit this field alongside your topology reconfiguration to request a new regional outage resistant topology. Forced reconfigurations during an outage of the majority of electable nodes carry a risk of data loss if replicated writes (even majority committed writes) have not been replicated to the new primary node. MongoDB Atlas docs contain more information. To proceed with an operation which carries that risk, set `accept_data_risks_and_force_replica_set_reconfig` to the current date. Learn more about Reconfiguring a Replica Set during a regional outage [here](https://dochub.mongodb.org/core/regional-outage-reconfigure-replica-set).\n"
                },
                "advancedConfiguration": {
                    "$ref": "#/types/mongodbatlas:index/ClusterAdvancedConfiguration:ClusterAdvancedConfiguration"
                },
                "autoScalingComputeEnabled": {
                    "type": "boolean"
                },
                "autoScalingComputeScaleDownEnabled": {
                    "type": "boolean",
                    "description": "Set to `true` to enable the cluster tier to scale down. This option is only available if `autoScaling.compute.enabled` is `true`.\n- If this option is enabled, you must specify a value for `providerSettings.autoScaling.compute.minInstanceSize`\n"
                },
                "autoScalingDiskGbEnabled": {
                    "type": "boolean"
                },
                "backingProviderName": {
                    "type": "string",
                    "description": "Cloud service provider on which the server for a multi-tenant cluster is provisioned.\n\nThis setting is only valid when providerSetting.providerName is TENANT and providerSetting.instanceSizeName is M2 or M5.\n\nThe possible values are:\n\n- AWS - Amazon AWS\n- GCP - Google Cloud Platform\n- AZURE - Microsoft Azure\n"
                },
                "backupEnabled": {
                    "type": "boolean",
                    "description": "Legacy Backup - Set to true to enable Atlas legacy backups for the cluster.\n**Important** - MongoDB deprecated the Legacy Backup feature. Clusters that use Legacy Backup can continue to use it. MongoDB recommends using [Cloud Backups](https://docs.atlas.mongodb.com/backup/cloud-backup/overview/).\n* New Atlas clusters of any type do not support this parameter. These clusters must use Cloud Backup, `cloud_backup`, to enable Cloud Backup.  If you create a new Atlas cluster and set `backup_enabled` to true, the Provider will respond with an error.  This change doesnât affect existing clusters that use legacy backups.\n* Setting this value to false to disable legacy backups for the cluster will let Atlas delete any stored snapshots. In order to preserve the legacy backups snapshots, disable the legacy backups and enable the cloud backups in the single **pulumi up** action.\n```\nbackup_enabled = \"false\"\ncloud_backup = \"true\"\n```\n* The default value is false.  M10 and above only.\n"
                },
                "biConnectorConfig": {
                    "$ref": "#/types/mongodbatlas:index/ClusterBiConnectorConfig:ClusterBiConnectorConfig",
                    "description": "Specifies BI Connector for Atlas configuration on this cluster. BI Connector for Atlas is only available for M10+ clusters. See BI Connector below for more details.\n"
                },
                "cloudBackup": {
                    "type": "boolean"
                },
                "clusterId": {
                    "type": "string",
                    "description": "The cluster ID.\n"
                },
                "clusterType": {
                    "type": "string",
                    "description": "Specifies the type of the cluster that you want to modify. You cannot convert a sharded cluster deployment to a replica set deployment.\n\n\u003e **WHEN SHOULD YOU USE CLUSTERTYPE?**\nWhen you set replication_specs, when you are deploying Global Clusters or when you are deploying non-Global replica sets and sharded clusters.\n\nAccepted values include:\n- `REPLICASET` Replica set\n- `SHARDED` Sharded cluster\n- `GEOSHARDED` Global Cluster\n"
                },
                "connectionStrings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ClusterConnectionString:ClusterConnectionString"
                    },
                    "description": "Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.\n"
                },
                "containerId": {
                    "type": "string",
                    "description": "The Container ID is the id of the container created when the first cluster in the region (AWS/Azure) or project (GCP) was created.\n"
                },
                "diskSizeGb": {
                    "type": "number",
                    "description": "Capacity, in gigabytes, of the hostâs root volume. Increase this number to add capacity, up to a maximum possible value of 4096 (i.e., 4 TB). This value must be a positive integer.\n* The minimum disk size for dedicated clusters is 10GB for AWS and GCP. If you specify diskSizeGB with a lower disk size, Atlas defaults to the minimum disk size value.\n* Note: The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require additional storage space beyond this limitation, consider upgrading your cluster to a higher tier.\n* Cannot be used with clusters with local NVMe SSDs\n* Cannot be used with Azure clusters\n"
                },
                "encryptionAtRestProvider": {
                    "type": "string",
                    "description": "Possible values are AWS, GCP, AZURE or NONE.  Only needed if you desire to manage the keys, see [Encryption at Rest using Customer Key Management](https://docs.atlas.mongodb.com/security-aws-kms/) for complete documentation.  You must configure encryption at rest for the Atlas project before enabling it on any cluster in the project. For complete documentation on configuring Encryption at Rest, see Encryption at Rest using Customer Key Management. Requires M10 or greater. and for legacy backups, backup_enabled, to be false or omitted. **Note: Atlas encrypts all cluster storage and snapshot volumes, securing all cluster data on disk: a concept known as encryption at rest, by default**.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ClusterLabel:ClusterLabel"
                    },
                    "description": "Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below. **DEPRECATED** Use `tags` instead.\n",
                    "deprecationMessage": "This parameter is deprecated and will be removed by September 2024. Please transition to tags."
                },
                "mongoDbMajorVersion": {
                    "type": "string",
                    "description": "Version of the cluster to deploy. Atlas supports the following MongoDB versions for M10+ clusters: `4.4`, `5.0`, `6.0` or `7.0`. If omitted, Atlas deploys a cluster that runs MongoDB 7.0. If `provider_instance_size_name`: `M0`, `M2` or `M5`, Atlas deploys MongoDB 5.0. Atlas always deploys the cluster with the latest stable release of the specified version. See [Release Notes](https://www.mongodb.com/docs/upcoming/release-notes/) for latest Current Stable Release.\n"
                },
                "mongoDbVersion": {
                    "type": "string",
                    "description": "Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.\n"
                },
                "mongoUri": {
                    "type": "string",
                    "description": "Base connection string for the cluster. Atlas only displays this field after the cluster is operational, not while it builds the cluster.\n"
                },
                "mongoUriUpdated": {
                    "type": "string",
                    "description": "Lists when the connection string was last updated. The connection string changes, for example, if you change a replica set to a sharded cluster.\n"
                },
                "mongoUriWithOptions": {
                    "type": "string",
                    "description": "connection string for connecting to the Atlas cluster. Includes the replicaSet, ssl, and authSource query parameters in the connection string with values appropriate for the cluster.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the cluster as it appears in Atlas. Once the cluster is created, its name cannot be changed. **WARNING** Changing the name will result in destruction of the existing cluster and the creation of a new cluster.\n"
                },
                "numShards": {
                    "type": "integer",
                    "description": "Selects whether the cluster is a replica set or a sharded cluster. If you use the replicationSpecs parameter, you must set num_shards.\n"
                },
                "paused": {
                    "type": "boolean"
                },
                "pitEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates if the cluster uses Continuous Cloud Backup. If set to true, cloud_backup must also be set to true.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create the database user.\n"
                },
                "providerAutoScalingComputeMaxInstanceSize": {
                    "type": "string",
                    "description": "Maximum instance size to which your cluster can automatically scale (e.g., M40). Required if `autoScaling.compute.enabled` is `true`.\n"
                },
                "providerAutoScalingComputeMinInstanceSize": {
                    "type": "string",
                    "description": "Minimum instance size to which your cluster can automatically scale (e.g., M10). Required if `autoScaling.compute.scaleDownEnabled` is `true`.\n"
                },
                "providerDiskIops": {
                    "type": "integer",
                    "description": "The maximum input/output operations per second (IOPS) the system can perform. The possible values depend on the selected `provider_instance_size_name` and `disk_size_gb`.  This setting requires that `provider_instance_size_name` to be M30 or greater and cannot be used with clusters with local NVMe SSDs.  The default value for `provider_disk_iops` is the same as the cluster tier's Standard IOPS value, as viewable in the Atlas console.  It is used in cases where a higher number of IOPS is needed and possible.  If a value is submitted that is lower or equal to the default IOPS value for the cluster tier Atlas ignores the requested value and uses the default.  More details available under the providerSettings.diskIOPS parameter: [MongoDB API Clusters](https://docs.atlas.mongodb.com/reference/api/clusters-create-one/)\n* You do not need to configure IOPS for a STANDARD disk configuration but only for a PROVISIONED configuration.\n"
                },
                "providerDiskTypeName": {
                    "type": "string",
                    "description": "Azure disk type of the serverâs root volume. If omitted, Atlas uses the default disk type for the selected providerSettings.instanceSizeName.  Example disk types and associated storage sizes: P4 - 32GB, P6 - 64GB, P10 - 128GB, P15 - 256GB, P20 - 512GB, P30 - 1024GB, P40 - 2048GB, P50 - 4095GB.  More information and the most update to date disk types/storage sizes can be located at https://docs.atlas.mongodb.com/reference/api/clusters-create-one/.\n"
                },
                "providerEncryptEbsVolume": {
                    "type": "boolean",
                    "description": "**(Deprecated) The Flag is always true.** Flag that indicates whether the Amazon EBS encryption feature encrypts the host's root volume for both data at rest within the volume and for data moving between the volume and the cluster. Note: This setting is always enabled for clusters with local NVMe SSDs. **Atlas encrypts all cluster storage and snapshot volumes, securing all cluster data on disk: a concept known as encryption at rest, by default.**.\n",
                    "deprecationMessage": "All EBS volumes are encrypted by default, the option to disable encryption has been removed"
                },
                "providerEncryptEbsVolumeFlag": {
                    "type": "boolean"
                },
                "providerInstanceSizeName": {
                    "type": "string",
                    "description": "Atlas provides different instance sizes, each with a default storage capacity and RAM size. The instance size you select is used for all the data-bearing servers in your cluster. See [Create a Cluster](https://docs.atlas.mongodb.com/reference/api/clusters-create-one/) `providerSettings.instanceSizeName` for valid values and default resources.\n"
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud service provider on which the servers are provisioned.\n\nThe possible values are:\n\n- `AWS` - Amazon AWS\n- `GCP` - Google Cloud Platform\n- `AZURE` - Microsoft Azure\n- `TENANT` - A multi-tenant deployment on one of the supported cloud service providers. Only valid when providerSettings.instanceSizeName is either M2 or M5.\n"
                },
                "providerRegionName": {
                    "type": "string",
                    "description": "Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).\nDo not specify this field when creating a multi-region cluster using the replicationSpec document or a Global Cluster with the replicationSpecs array.\n"
                },
                "providerVolumeType": {
                    "type": "string",
                    "description": "The type of the volume. The possible values are: `STANDARD` and `PROVISIONED`.  `PROVISIONED` is ONLY required if setting IOPS higher than the default instance IOPS.\n\u003e **NOTE:** `STANDARD` is not available for NVME clusters.\n"
                },
                "replicationFactor": {
                    "type": "integer",
                    "description": "Number of replica set members. Each member keeps a copy of your databases, providing high availability and data redundancy. The possible values are 3, 5, or 7. The default value is 3.\n"
                },
                "replicationSpecs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ClusterReplicationSpec:ClusterReplicationSpec"
                    },
                    "description": "Configuration for cluster regions.  See Replication Spec below for more details.\n"
                },
                "retainBackupsEnabled": {
                    "type": "boolean",
                    "description": "Set to true to retain backup snapshots for the deleted cluster. M10 and above only.\n"
                },
                "snapshotBackupPolicies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ClusterSnapshotBackupPolicy:ClusterSnapshotBackupPolicy"
                    },
                    "description": "current snapshot schedule and retention settings for the cluster.\n"
                },
                "srvAddress": {
                    "type": "string",
                    "description": "Connection string for connecting to the Atlas cluster. The +srv modifier forces the connection to use TLS/SSL. See the mongoURI for additional options.\n"
                },
                "stateName": {
                    "type": "string",
                    "description": "Current state of the cluster. The possible states are:\n- IDLE\n- CREATING\n- UPDATING\n- DELETING\n- DELETED\n- REPAIRING\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ClusterTag:ClusterTag"
                    },
                    "description": "Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.\n"
                },
                "terminationProtectionEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n"
                },
                "versionReleaseSystem": {
                    "type": "string",
                    "description": "Release cadence that Atlas uses for this cluster. This parameter defaults to `LTS`. If you set this field to `CONTINUOUS`, you must omit the `mongo_db_major_version` field. Atlas accepts:\n- `CONTINUOUS`:  Atlas creates your cluster using the most recent MongoDB release. Atlas automatically updates your cluster to the latest major and rapid MongoDB releases as they become available.\n- `LTS`: Atlas creates your cluster using the latest patch release of the MongoDB version that you specify in the mongoDBMajorVersion field. Atlas automatically updates your cluster to subsequent patch releases of this MongoDB version. Atlas doesn't update your cluster to newer rapid or major MongoDB releases as they become available.\n"
                }
            },
            "required": [
                "acceptDataRisksAndForceReplicaSetReconfig",
                "advancedConfiguration",
                "autoScalingComputeEnabled",
                "autoScalingComputeScaleDownEnabled",
                "autoScalingDiskGbEnabled",
                "backingProviderName",
                "backupEnabled",
                "biConnectorConfig",
                "cloudBackup",
                "clusterId",
                "clusterType",
                "connectionStrings",
                "containerId",
                "diskSizeGb",
                "encryptionAtRestProvider",
                "mongoDbMajorVersion",
                "mongoDbVersion",
                "mongoUri",
                "mongoUriUpdated",
                "mongoUriWithOptions",
                "name",
                "numShards",
                "paused",
                "pitEnabled",
                "projectId",
                "providerAutoScalingComputeMaxInstanceSize",
                "providerAutoScalingComputeMinInstanceSize",
                "providerDiskIops",
                "providerDiskTypeName",
                "providerEncryptEbsVolume",
                "providerEncryptEbsVolumeFlag",
                "providerInstanceSizeName",
                "providerName",
                "providerRegionName",
                "providerVolumeType",
                "replicationFactor",
                "replicationSpecs",
                "snapshotBackupPolicies",
                "srvAddress",
                "stateName",
                "terminationProtectionEnabled",
                "versionReleaseSystem"
            ],
            "inputProperties": {
                "acceptDataRisksAndForceReplicaSetReconfig": {
                    "type": "string",
                    "description": "If reconfiguration is necessary to regain a primary due to a regional outage, submit this field alongside your topology reconfiguration to request a new regional outage resistant topology. Forced reconfigurations during an outage of the majority of electable nodes carry a risk of data loss if replicated writes (even majority committed writes) have not been replicated to the new primary node. MongoDB Atlas docs contain more information. To proceed with an operation which carries that risk, set `accept_data_risks_and_force_replica_set_reconfig` to the current date. Learn more about Reconfiguring a Replica Set during a regional outage [here](https://dochub.mongodb.org/core/regional-outage-reconfigure-replica-set).\n"
                },
                "advancedConfiguration": {
                    "$ref": "#/types/mongodbatlas:index/ClusterAdvancedConfiguration:ClusterAdvancedConfiguration"
                },
                "autoScalingComputeEnabled": {
                    "type": "boolean"
                },
                "autoScalingComputeScaleDownEnabled": {
                    "type": "boolean",
                    "description": "Set to `true` to enable the cluster tier to scale down. This option is only available if `autoScaling.compute.enabled` is `true`.\n- If this option is enabled, you must specify a value for `providerSettings.autoScaling.compute.minInstanceSize`\n"
                },
                "autoScalingDiskGbEnabled": {
                    "type": "boolean"
                },
                "backingProviderName": {
                    "type": "string",
                    "description": "Cloud service provider on which the server for a multi-tenant cluster is provisioned.\n\nThis setting is only valid when providerSetting.providerName is TENANT and providerSetting.instanceSizeName is M2 or M5.\n\nThe possible values are:\n\n- AWS - Amazon AWS\n- GCP - Google Cloud Platform\n- AZURE - Microsoft Azure\n"
                },
                "backupEnabled": {
                    "type": "boolean",
                    "description": "Legacy Backup - Set to true to enable Atlas legacy backups for the cluster.\n**Important** - MongoDB deprecated the Legacy Backup feature. Clusters that use Legacy Backup can continue to use it. MongoDB recommends using [Cloud Backups](https://docs.atlas.mongodb.com/backup/cloud-backup/overview/).\n* New Atlas clusters of any type do not support this parameter. These clusters must use Cloud Backup, `cloud_backup`, to enable Cloud Backup.  If you create a new Atlas cluster and set `backup_enabled` to true, the Provider will respond with an error.  This change doesnât affect existing clusters that use legacy backups.\n* Setting this value to false to disable legacy backups for the cluster will let Atlas delete any stored snapshots. In order to preserve the legacy backups snapshots, disable the legacy backups and enable the cloud backups in the single **pulumi up** action.\n```\nbackup_enabled = \"false\"\ncloud_backup = \"true\"\n```\n* The default value is false.  M10 and above only.\n"
                },
                "biConnectorConfig": {
                    "$ref": "#/types/mongodbatlas:index/ClusterBiConnectorConfig:ClusterBiConnectorConfig",
                    "description": "Specifies BI Connector for Atlas configuration on this cluster. BI Connector for Atlas is only available for M10+ clusters. See BI Connector below for more details.\n"
                },
                "cloudBackup": {
                    "type": "boolean"
                },
                "clusterType": {
                    "type": "string",
                    "description": "Specifies the type of the cluster that you want to modify. You cannot convert a sharded cluster deployment to a replica set deployment.\n\n\u003e **WHEN SHOULD YOU USE CLUSTERTYPE?**\nWhen you set replication_specs, when you are deploying Global Clusters or when you are deploying non-Global replica sets and sharded clusters.\n\nAccepted values include:\n- `REPLICASET` Replica set\n- `SHARDED` Sharded cluster\n- `GEOSHARDED` Global Cluster\n"
                },
                "diskSizeGb": {
                    "type": "number",
                    "description": "Capacity, in gigabytes, of the hostâs root volume. Increase this number to add capacity, up to a maximum possible value of 4096 (i.e., 4 TB). This value must be a positive integer.\n* The minimum disk size for dedicated clusters is 10GB for AWS and GCP. If you specify diskSizeGB with a lower disk size, Atlas defaults to the minimum disk size value.\n* Note: The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require additional storage space beyond this limitation, consider upgrading your cluster to a higher tier.\n* Cannot be used with clusters with local NVMe SSDs\n* Cannot be used with Azure clusters\n"
                },
                "encryptionAtRestProvider": {
                    "type": "string",
                    "description": "Possible values are AWS, GCP, AZURE or NONE.  Only needed if you desire to manage the keys, see [Encryption at Rest using Customer Key Management](https://docs.atlas.mongodb.com/security-aws-kms/) for complete documentation.  You must configure encryption at rest for the Atlas project before enabling it on any cluster in the project. For complete documentation on configuring Encryption at Rest, see Encryption at Rest using Customer Key Management. Requires M10 or greater. and for legacy backups, backup_enabled, to be false or omitted. **Note: Atlas encrypts all cluster storage and snapshot volumes, securing all cluster data on disk: a concept known as encryption at rest, by default**.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ClusterLabel:ClusterLabel"
                    },
                    "description": "Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below. **DEPRECATED** Use `tags` instead.\n",
                    "deprecationMessage": "This parameter is deprecated and will be removed by September 2024. Please transition to tags."
                },
                "mongoDbMajorVersion": {
                    "type": "string",
                    "description": "Version of the cluster to deploy. Atlas supports the following MongoDB versions for M10+ clusters: `4.4`, `5.0`, `6.0` or `7.0`. If omitted, Atlas deploys a cluster that runs MongoDB 7.0. If `provider_instance_size_name`: `M0`, `M2` or `M5`, Atlas deploys MongoDB 5.0. Atlas always deploys the cluster with the latest stable release of the specified version. See [Release Notes](https://www.mongodb.com/docs/upcoming/release-notes/) for latest Current Stable Release.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the cluster as it appears in Atlas. Once the cluster is created, its name cannot be changed. **WARNING** Changing the name will result in destruction of the existing cluster and the creation of a new cluster.\n",
                    "willReplaceOnChanges": true
                },
                "numShards": {
                    "type": "integer",
                    "description": "Selects whether the cluster is a replica set or a sharded cluster. If you use the replicationSpecs parameter, you must set num_shards.\n"
                },
                "paused": {
                    "type": "boolean"
                },
                "pitEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates if the cluster uses Continuous Cloud Backup. If set to true, cloud_backup must also be set to true.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create the database user.\n",
                    "willReplaceOnChanges": true
                },
                "providerAutoScalingComputeMaxInstanceSize": {
                    "type": "string",
                    "description": "Maximum instance size to which your cluster can automatically scale (e.g., M40). Required if `autoScaling.compute.enabled` is `true`.\n"
                },
                "providerAutoScalingComputeMinInstanceSize": {
                    "type": "string",
                    "description": "Minimum instance size to which your cluster can automatically scale (e.g., M10). Required if `autoScaling.compute.scaleDownEnabled` is `true`.\n"
                },
                "providerDiskIops": {
                    "type": "integer",
                    "description": "The maximum input/output operations per second (IOPS) the system can perform. The possible values depend on the selected `provider_instance_size_name` and `disk_size_gb`.  This setting requires that `provider_instance_size_name` to be M30 or greater and cannot be used with clusters with local NVMe SSDs.  The default value for `provider_disk_iops` is the same as the cluster tier's Standard IOPS value, as viewable in the Atlas console.  It is used in cases where a higher number of IOPS is needed and possible.  If a value is submitted that is lower or equal to the default IOPS value for the cluster tier Atlas ignores the requested value and uses the default.  More details available under the providerSettings.diskIOPS parameter: [MongoDB API Clusters](https://docs.atlas.mongodb.com/reference/api/clusters-create-one/)\n* You do not need to configure IOPS for a STANDARD disk configuration but only for a PROVISIONED configuration.\n"
                },
                "providerDiskTypeName": {
                    "type": "string",
                    "description": "Azure disk type of the serverâs root volume. If omitted, Atlas uses the default disk type for the selected providerSettings.instanceSizeName.  Example disk types and associated storage sizes: P4 - 32GB, P6 - 64GB, P10 - 128GB, P15 - 256GB, P20 - 512GB, P30 - 1024GB, P40 - 2048GB, P50 - 4095GB.  More information and the most update to date disk types/storage sizes can be located at https://docs.atlas.mongodb.com/reference/api/clusters-create-one/.\n"
                },
                "providerEncryptEbsVolume": {
                    "type": "boolean",
                    "description": "**(Deprecated) The Flag is always true.** Flag that indicates whether the Amazon EBS encryption feature encrypts the host's root volume for both data at rest within the volume and for data moving between the volume and the cluster. Note: This setting is always enabled for clusters with local NVMe SSDs. **Atlas encrypts all cluster storage and snapshot volumes, securing all cluster data on disk: a concept known as encryption at rest, by default.**.\n",
                    "deprecationMessage": "All EBS volumes are encrypted by default, the option to disable encryption has been removed"
                },
                "providerInstanceSizeName": {
                    "type": "string",
                    "description": "Atlas provides different instance sizes, each with a default storage capacity and RAM size. The instance size you select is used for all the data-bearing servers in your cluster. See [Create a Cluster](https://docs.atlas.mongodb.com/reference/api/clusters-create-one/) `providerSettings.instanceSizeName` for valid values and default resources.\n"
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud service provider on which the servers are provisioned.\n\nThe possible values are:\n\n- `AWS` - Amazon AWS\n- `GCP` - Google Cloud Platform\n- `AZURE` - Microsoft Azure\n- `TENANT` - A multi-tenant deployment on one of the supported cloud service providers. Only valid when providerSettings.instanceSizeName is either M2 or M5.\n"
                },
                "providerRegionName": {
                    "type": "string",
                    "description": "Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).\nDo not specify this field when creating a multi-region cluster using the replicationSpec document or a Global Cluster with the replicationSpecs array.\n"
                },
                "providerVolumeType": {
                    "type": "string",
                    "description": "The type of the volume. The possible values are: `STANDARD` and `PROVISIONED`.  `PROVISIONED` is ONLY required if setting IOPS higher than the default instance IOPS.\n\u003e **NOTE:** `STANDARD` is not available for NVME clusters.\n"
                },
                "replicationFactor": {
                    "type": "integer",
                    "description": "Number of replica set members. Each member keeps a copy of your databases, providing high availability and data redundancy. The possible values are 3, 5, or 7. The default value is 3.\n"
                },
                "replicationSpecs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ClusterReplicationSpec:ClusterReplicationSpec"
                    },
                    "description": "Configuration for cluster regions.  See Replication Spec below for more details.\n"
                },
                "retainBackupsEnabled": {
                    "type": "boolean",
                    "description": "Set to true to retain backup snapshots for the deleted cluster. M10 and above only.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ClusterTag:ClusterTag"
                    },
                    "description": "Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.\n"
                },
                "terminationProtectionEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n"
                },
                "versionReleaseSystem": {
                    "type": "string",
                    "description": "Release cadence that Atlas uses for this cluster. This parameter defaults to `LTS`. If you set this field to `CONTINUOUS`, you must omit the `mongo_db_major_version` field. Atlas accepts:\n- `CONTINUOUS`:  Atlas creates your cluster using the most recent MongoDB release. Atlas automatically updates your cluster to the latest major and rapid MongoDB releases as they become available.\n- `LTS`: Atlas creates your cluster using the latest patch release of the MongoDB version that you specify in the mongoDBMajorVersion field. Atlas automatically updates your cluster to subsequent patch releases of this MongoDB version. Atlas doesn't update your cluster to newer rapid or major MongoDB releases as they become available.\n"
                }
            },
            "requiredInputs": [
                "projectId",
                "providerInstanceSizeName",
                "providerName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Cluster resources.\n",
                "properties": {
                    "acceptDataRisksAndForceReplicaSetReconfig": {
                        "type": "string",
                        "description": "If reconfiguration is necessary to regain a primary due to a regional outage, submit this field alongside your topology reconfiguration to request a new regional outage resistant topology. Forced reconfigurations during an outage of the majority of electable nodes carry a risk of data loss if replicated writes (even majority committed writes) have not been replicated to the new primary node. MongoDB Atlas docs contain more information. To proceed with an operation which carries that risk, set `accept_data_risks_and_force_replica_set_reconfig` to the current date. Learn more about Reconfiguring a Replica Set during a regional outage [here](https://dochub.mongodb.org/core/regional-outage-reconfigure-replica-set).\n"
                    },
                    "advancedConfiguration": {
                        "$ref": "#/types/mongodbatlas:index/ClusterAdvancedConfiguration:ClusterAdvancedConfiguration"
                    },
                    "autoScalingComputeEnabled": {
                        "type": "boolean"
                    },
                    "autoScalingComputeScaleDownEnabled": {
                        "type": "boolean",
                        "description": "Set to `true` to enable the cluster tier to scale down. This option is only available if `autoScaling.compute.enabled` is `true`.\n- If this option is enabled, you must specify a value for `providerSettings.autoScaling.compute.minInstanceSize`\n"
                    },
                    "autoScalingDiskGbEnabled": {
                        "type": "boolean"
                    },
                    "backingProviderName": {
                        "type": "string",
                        "description": "Cloud service provider on which the server for a multi-tenant cluster is provisioned.\n\nThis setting is only valid when providerSetting.providerName is TENANT and providerSetting.instanceSizeName is M2 or M5.\n\nThe possible values are:\n\n- AWS - Amazon AWS\n- GCP - Google Cloud Platform\n- AZURE - Microsoft Azure\n"
                    },
                    "backupEnabled": {
                        "type": "boolean",
                        "description": "Legacy Backup - Set to true to enable Atlas legacy backups for the cluster.\n**Important** - MongoDB deprecated the Legacy Backup feature. Clusters that use Legacy Backup can continue to use it. MongoDB recommends using [Cloud Backups](https://docs.atlas.mongodb.com/backup/cloud-backup/overview/).\n* New Atlas clusters of any type do not support this parameter. These clusters must use Cloud Backup, `cloud_backup`, to enable Cloud Backup.  If you create a new Atlas cluster and set `backup_enabled` to true, the Provider will respond with an error.  This change doesnât affect existing clusters that use legacy backups.\n* Setting this value to false to disable legacy backups for the cluster will let Atlas delete any stored snapshots. In order to preserve the legacy backups snapshots, disable the legacy backups and enable the cloud backups in the single **pulumi up** action.\n```\nbackup_enabled = \"false\"\ncloud_backup = \"true\"\n```\n* The default value is false.  M10 and above only.\n"
                    },
                    "biConnectorConfig": {
                        "$ref": "#/types/mongodbatlas:index/ClusterBiConnectorConfig:ClusterBiConnectorConfig",
                        "description": "Specifies BI Connector for Atlas configuration on this cluster. BI Connector for Atlas is only available for M10+ clusters. See BI Connector below for more details.\n"
                    },
                    "cloudBackup": {
                        "type": "boolean"
                    },
                    "clusterId": {
                        "type": "string",
                        "description": "The cluster ID.\n"
                    },
                    "clusterType": {
                        "type": "string",
                        "description": "Specifies the type of the cluster that you want to modify. You cannot convert a sharded cluster deployment to a replica set deployment.\n\n\u003e **WHEN SHOULD YOU USE CLUSTERTYPE?**\nWhen you set replication_specs, when you are deploying Global Clusters or when you are deploying non-Global replica sets and sharded clusters.\n\nAccepted values include:\n- `REPLICASET` Replica set\n- `SHARDED` Sharded cluster\n- `GEOSHARDED` Global Cluster\n"
                    },
                    "connectionStrings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/ClusterConnectionString:ClusterConnectionString"
                        },
                        "description": "Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.\n"
                    },
                    "containerId": {
                        "type": "string",
                        "description": "The Container ID is the id of the container created when the first cluster in the region (AWS/Azure) or project (GCP) was created.\n"
                    },
                    "diskSizeGb": {
                        "type": "number",
                        "description": "Capacity, in gigabytes, of the hostâs root volume. Increase this number to add capacity, up to a maximum possible value of 4096 (i.e., 4 TB). This value must be a positive integer.\n* The minimum disk size for dedicated clusters is 10GB for AWS and GCP. If you specify diskSizeGB with a lower disk size, Atlas defaults to the minimum disk size value.\n* Note: The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require additional storage space beyond this limitation, consider upgrading your cluster to a higher tier.\n* Cannot be used with clusters with local NVMe SSDs\n* Cannot be used with Azure clusters\n"
                    },
                    "encryptionAtRestProvider": {
                        "type": "string",
                        "description": "Possible values are AWS, GCP, AZURE or NONE.  Only needed if you desire to manage the keys, see [Encryption at Rest using Customer Key Management](https://docs.atlas.mongodb.com/security-aws-kms/) for complete documentation.  You must configure encryption at rest for the Atlas project before enabling it on any cluster in the project. For complete documentation on configuring Encryption at Rest, see Encryption at Rest using Customer Key Management. Requires M10 or greater. and for legacy backups, backup_enabled, to be false or omitted. **Note: Atlas encrypts all cluster storage and snapshot volumes, securing all cluster data on disk: a concept known as encryption at rest, by default**.\n"
                    },
                    "labels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/ClusterLabel:ClusterLabel"
                        },
                        "description": "Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below. **DEPRECATED** Use `tags` instead.\n",
                        "deprecationMessage": "This parameter is deprecated and will be removed by September 2024. Please transition to tags."
                    },
                    "mongoDbMajorVersion": {
                        "type": "string",
                        "description": "Version of the cluster to deploy. Atlas supports the following MongoDB versions for M10+ clusters: `4.4`, `5.0`, `6.0` or `7.0`. If omitted, Atlas deploys a cluster that runs MongoDB 7.0. If `provider_instance_size_name`: `M0`, `M2` or `M5`, Atlas deploys MongoDB 5.0. Atlas always deploys the cluster with the latest stable release of the specified version. See [Release Notes](https://www.mongodb.com/docs/upcoming/release-notes/) for latest Current Stable Release.\n"
                    },
                    "mongoDbVersion": {
                        "type": "string",
                        "description": "Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.\n"
                    },
                    "mongoUri": {
                        "type": "string",
                        "description": "Base connection string for the cluster. Atlas only displays this field after the cluster is operational, not while it builds the cluster.\n"
                    },
                    "mongoUriUpdated": {
                        "type": "string",
                        "description": "Lists when the connection string was last updated. The connection string changes, for example, if you change a replica set to a sharded cluster.\n"
                    },
                    "mongoUriWithOptions": {
                        "type": "string",
                        "description": "connection string for connecting to the Atlas cluster. Includes the replicaSet, ssl, and authSource query parameters in the connection string with values appropriate for the cluster.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the cluster as it appears in Atlas. Once the cluster is created, its name cannot be changed. **WARNING** Changing the name will result in destruction of the existing cluster and the creation of a new cluster.\n",
                        "willReplaceOnChanges": true
                    },
                    "numShards": {
                        "type": "integer",
                        "description": "Selects whether the cluster is a replica set or a sharded cluster. If you use the replicationSpecs parameter, you must set num_shards.\n"
                    },
                    "paused": {
                        "type": "boolean"
                    },
                    "pitEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates if the cluster uses Continuous Cloud Backup. If set to true, cloud_backup must also be set to true.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the database user.\n",
                        "willReplaceOnChanges": true
                    },
                    "providerAutoScalingComputeMaxInstanceSize": {
                        "type": "string",
                        "description": "Maximum instance size to which your cluster can automatically scale (e.g., M40). Required if `autoScaling.compute.enabled` is `true`.\n"
                    },
                    "providerAutoScalingComputeMinInstanceSize": {
                        "type": "string",
                        "description": "Minimum instance size to which your cluster can automatically scale (e.g., M10). Required if `autoScaling.compute.scaleDownEnabled` is `true`.\n"
                    },
                    "providerDiskIops": {
                        "type": "integer",
                        "description": "The maximum input/output operations per second (IOPS) the system can perform. The possible values depend on the selected `provider_instance_size_name` and `disk_size_gb`.  This setting requires that `provider_instance_size_name` to be M30 or greater and cannot be used with clusters with local NVMe SSDs.  The default value for `provider_disk_iops` is the same as the cluster tier's Standard IOPS value, as viewable in the Atlas console.  It is used in cases where a higher number of IOPS is needed and possible.  If a value is submitted that is lower or equal to the default IOPS value for the cluster tier Atlas ignores the requested value and uses the default.  More details available under the providerSettings.diskIOPS parameter: [MongoDB API Clusters](https://docs.atlas.mongodb.com/reference/api/clusters-create-one/)\n* You do not need to configure IOPS for a STANDARD disk configuration but only for a PROVISIONED configuration.\n"
                    },
                    "providerDiskTypeName": {
                        "type": "string",
                        "description": "Azure disk type of the serverâs root volume. If omitted, Atlas uses the default disk type for the selected providerSettings.instanceSizeName.  Example disk types and associated storage sizes: P4 - 32GB, P6 - 64GB, P10 - 128GB, P15 - 256GB, P20 - 512GB, P30 - 1024GB, P40 - 2048GB, P50 - 4095GB.  More information and the most update to date disk types/storage sizes can be located at https://docs.atlas.mongodb.com/reference/api/clusters-create-one/.\n"
                    },
                    "providerEncryptEbsVolume": {
                        "type": "boolean",
                        "description": "**(Deprecated) The Flag is always true.** Flag that indicates whether the Amazon EBS encryption feature encrypts the host's root volume for both data at rest within the volume and for data moving between the volume and the cluster. Note: This setting is always enabled for clusters with local NVMe SSDs. **Atlas encrypts all cluster storage and snapshot volumes, securing all cluster data on disk: a concept known as encryption at rest, by default.**.\n",
                        "deprecationMessage": "All EBS volumes are encrypted by default, the option to disable encryption has been removed"
                    },
                    "providerEncryptEbsVolumeFlag": {
                        "type": "boolean"
                    },
                    "providerInstanceSizeName": {
                        "type": "string",
                        "description": "Atlas provides different instance sizes, each with a default storage capacity and RAM size. The instance size you select is used for all the data-bearing servers in your cluster. See [Create a Cluster](https://docs.atlas.mongodb.com/reference/api/clusters-create-one/) `providerSettings.instanceSizeName` for valid values and default resources.\n"
                    },
                    "providerName": {
                        "type": "string",
                        "description": "Cloud service provider on which the servers are provisioned.\n\nThe possible values are:\n\n- `AWS` - Amazon AWS\n- `GCP` - Google Cloud Platform\n- `AZURE` - Microsoft Azure\n- `TENANT` - A multi-tenant deployment on one of the supported cloud service providers. Only valid when providerSettings.instanceSizeName is either M2 or M5.\n"
                    },
                    "providerRegionName": {
                        "type": "string",
                        "description": "Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).\nDo not specify this field when creating a multi-region cluster using the replicationSpec document or a Global Cluster with the replicationSpecs array.\n"
                    },
                    "providerVolumeType": {
                        "type": "string",
                        "description": "The type of the volume. The possible values are: `STANDARD` and `PROVISIONED`.  `PROVISIONED` is ONLY required if setting IOPS higher than the default instance IOPS.\n\u003e **NOTE:** `STANDARD` is not available for NVME clusters.\n"
                    },
                    "replicationFactor": {
                        "type": "integer",
                        "description": "Number of replica set members. Each member keeps a copy of your databases, providing high availability and data redundancy. The possible values are 3, 5, or 7. The default value is 3.\n"
                    },
                    "replicationSpecs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/ClusterReplicationSpec:ClusterReplicationSpec"
                        },
                        "description": "Configuration for cluster regions.  See Replication Spec below for more details.\n"
                    },
                    "retainBackupsEnabled": {
                        "type": "boolean",
                        "description": "Set to true to retain backup snapshots for the deleted cluster. M10 and above only.\n"
                    },
                    "snapshotBackupPolicies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/ClusterSnapshotBackupPolicy:ClusterSnapshotBackupPolicy"
                        },
                        "description": "current snapshot schedule and retention settings for the cluster.\n"
                    },
                    "srvAddress": {
                        "type": "string",
                        "description": "Connection string for connecting to the Atlas cluster. The +srv modifier forces the connection to use TLS/SSL. See the mongoURI for additional options.\n"
                    },
                    "stateName": {
                        "type": "string",
                        "description": "Current state of the cluster. The possible states are:\n- IDLE\n- CREATING\n- UPDATING\n- DELETING\n- DELETED\n- REPAIRING\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/ClusterTag:ClusterTag"
                        },
                        "description": "Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.\n"
                    },
                    "terminationProtectionEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n"
                    },
                    "versionReleaseSystem": {
                        "type": "string",
                        "description": "Release cadence that Atlas uses for this cluster. This parameter defaults to `LTS`. If you set this field to `CONTINUOUS`, you must omit the `mongo_db_major_version` field. Atlas accepts:\n- `CONTINUOUS`:  Atlas creates your cluster using the most recent MongoDB release. Atlas automatically updates your cluster to the latest major and rapid MongoDB releases as they become available.\n- `LTS`: Atlas creates your cluster using the latest patch release of the MongoDB version that you specify in the mongoDBMajorVersion field. Atlas automatically updates your cluster to subsequent patch releases of this MongoDB version. Atlas doesn't update your cluster to newer rapid or major MongoDB releases as they become available.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/clusterOutageSimulation:ClusterOutageSimulation": {
            "description": "## # Resource: mongodbatlas.ClusterOutageSimulation\n\n`mongodbatlas.ClusterOutageSimulation` provides a Cluster Outage Simulation resource. For more details see https://www.mongodb.com/docs/atlas/tutorial/test-resilience/simulate-regional-outage/\n\nTest Outage on Minority of Electable Nodes - Select fewer than half of your electable nodes. \n\nTest Outage on Majority of Electable Nodes - Select at least one more than half of your electable nodes and keep at least one electable node remaining. \n\n**IMPORTANT:** Test Outage on Majority of Electable Nodes will leave the Atlas cluster without a majority quorum. There will be no primary so write operations will not succeed, and reads will succeed only when configured with a suitable [readPreference](https://www.mongodb.com/docs/manual/core/read-preference/). To recover the majority quorum, you will have the option to manually reconfigure your cluster by adding new nodes to existing regions or adding new regions at the risk of losing recent writes, or end the simulation.   \n\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n\u003e **IMPORTANT:** This resource cannot be updated.\n\u003e **IMPORTANT:** An existing Cluster Outage Simulation cannot be imported as this resource does not support import operation.\n\n## Example Usage\n\n### S\n\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst outageSimulation = new mongodbatlas.ClusterOutageSimulation(\"outage_simulation\", {\n    projectId: \"64707f06c519c20c3a2b1b03\",\n    clusterName: \"Cluster0\",\n    outageFilters: [\n        {\n            cloudProvider: \"AWS\",\n            regionName: \"US_EAST_1\",\n        },\n        {\n            cloudProvider: \"AWS\",\n            regionName: \"US_EAST_2\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\noutage_simulation = mongodbatlas.ClusterOutageSimulation(\"outage_simulation\",\n    project_id=\"64707f06c519c20c3a2b1b03\",\n    cluster_name=\"Cluster0\",\n    outage_filters=[\n        {\n            \"cloud_provider\": \"AWS\",\n            \"region_name\": \"US_EAST_1\",\n        },\n        {\n            \"cloud_provider\": \"AWS\",\n            \"region_name\": \"US_EAST_2\",\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var outageSimulation = new Mongodbatlas.ClusterOutageSimulation(\"outage_simulation\", new()\n    {\n        ProjectId = \"64707f06c519c20c3a2b1b03\",\n        ClusterName = \"Cluster0\",\n        OutageFilters = new[]\n        {\n            new Mongodbatlas.Inputs.ClusterOutageSimulationOutageFilterArgs\n            {\n                CloudProvider = \"AWS\",\n                RegionName = \"US_EAST_1\",\n            },\n            new Mongodbatlas.Inputs.ClusterOutageSimulationOutageFilterArgs\n            {\n                CloudProvider = \"AWS\",\n                RegionName = \"US_EAST_2\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewClusterOutageSimulation(ctx, \"outage_simulation\", \u0026mongodbatlas.ClusterOutageSimulationArgs{\n\t\t\tProjectId:   pulumi.String(\"64707f06c519c20c3a2b1b03\"),\n\t\t\tClusterName: pulumi.String(\"Cluster0\"),\n\t\t\tOutageFilters: mongodbatlas.ClusterOutageSimulationOutageFilterArray{\n\t\t\t\t\u0026mongodbatlas.ClusterOutageSimulationOutageFilterArgs{\n\t\t\t\t\tCloudProvider: pulumi.String(\"AWS\"),\n\t\t\t\t\tRegionName:    pulumi.String(\"US_EAST_1\"),\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.ClusterOutageSimulationOutageFilterArgs{\n\t\t\t\t\tCloudProvider: pulumi.String(\"AWS\"),\n\t\t\t\t\tRegionName:    pulumi.String(\"US_EAST_2\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ClusterOutageSimulation;\nimport com.pulumi.mongodbatlas.ClusterOutageSimulationArgs;\nimport com.pulumi.mongodbatlas.inputs.ClusterOutageSimulationOutageFilterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var outageSimulation = new ClusterOutageSimulation(\"outageSimulation\", ClusterOutageSimulationArgs.builder()\n            .projectId(\"64707f06c519c20c3a2b1b03\")\n            .clusterName(\"Cluster0\")\n            .outageFilters(            \n                ClusterOutageSimulationOutageFilterArgs.builder()\n                    .cloudProvider(\"AWS\")\n                    .regionName(\"US_EAST_1\")\n                    .build(),\n                ClusterOutageSimulationOutageFilterArgs.builder()\n                    .cloudProvider(\"AWS\")\n                    .regionName(\"US_EAST_2\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  outageSimulation:\n    type: mongodbatlas:ClusterOutageSimulation\n    name: outage_simulation\n    properties:\n      projectId: 64707f06c519c20c3a2b1b03\n      clusterName: Cluster0\n      outageFilters:\n        - cloudProvider: AWS\n          regionName: US_EAST_1\n        - cloudProvider: AWS\n          regionName: US_EAST_2\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nThe `mongodbatlas_cluster_outage_simulation` resource does not support import operation.\n\nSee [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Cluster-Outage-Simulation) Documentation for more information.\n\n",
            "properties": {
                "clusterName": {
                    "type": "string",
                    "description": "Name of the Atlas Cluster that is/will undergoing outage simulation.\n"
                },
                "outageFilters": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ClusterOutageSimulationOutageFilter:ClusterOutageSimulationOutageFilter"
                    },
                    "description": "List of settings that specify the type of cluster outage simulation.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project that contains the cluster that is/will undergoing outage simulation.\n"
                },
                "simulationId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal character string that identifies the outage simulation.\n"
                },
                "startRequestDate": {
                    "type": "string",
                    "description": "Date and time when MongoDB Cloud started the regional outage simulation.\n"
                },
                "state": {
                    "type": "string",
                    "description": "Current phase of the outage simulation:\n* `START_REQUESTED` - User has requested cluster outage simulation.\n* `STARTING` - MongoDB Cloud is starting cluster outage simulation.\n* `SIMULATING` - MongoDB Cloud is simulating cluster outage.\n* `RECOVERY_REQUESTED` - User has requested recovery from the simulated outage.\n* `RECOVERING` - MongoDB Cloud is recovering the cluster from the simulated outage.\n* `COMPLETE` - MongoDB Cloud has completed the cluster outage simulation.\n"
                }
            },
            "required": [
                "clusterName",
                "outageFilters",
                "projectId",
                "simulationId",
                "startRequestDate",
                "state"
            ],
            "inputProperties": {
                "clusterName": {
                    "type": "string",
                    "description": "Name of the Atlas Cluster that is/will undergoing outage simulation.\n"
                },
                "outageFilters": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ClusterOutageSimulationOutageFilter:ClusterOutageSimulationOutageFilter"
                    },
                    "description": "List of settings that specify the type of cluster outage simulation.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project that contains the cluster that is/will undergoing outage simulation.\n"
                }
            },
            "requiredInputs": [
                "clusterName",
                "outageFilters",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ClusterOutageSimulation resources.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "Name of the Atlas Cluster that is/will undergoing outage simulation.\n"
                    },
                    "outageFilters": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/ClusterOutageSimulationOutageFilter:ClusterOutageSimulationOutageFilter"
                        },
                        "description": "List of settings that specify the type of cluster outage simulation.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project that contains the cluster that is/will undergoing outage simulation.\n"
                    },
                    "simulationId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal character string that identifies the outage simulation.\n"
                    },
                    "startRequestDate": {
                        "type": "string",
                        "description": "Date and time when MongoDB Cloud started the regional outage simulation.\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "Current phase of the outage simulation:\n* `START_REQUESTED` - User has requested cluster outage simulation.\n* `STARTING` - MongoDB Cloud is starting cluster outage simulation.\n* `SIMULATING` - MongoDB Cloud is simulating cluster outage.\n* `RECOVERY_REQUESTED` - User has requested recovery from the simulated outage.\n* `RECOVERING` - MongoDB Cloud is recovering the cluster from the simulated outage.\n* `COMPLETE` - MongoDB Cloud has completed the cluster outage simulation.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/customDbRole:CustomDbRole": {
            "description": "## # Resource: mongodbatlas.CustomDbRole\n\n`mongodbatlas.CustomDbRole` provides a Custom DB Role resource. The customDBRoles resource lets you retrieve, create and modify the custom MongoDB roles in your cluster. Use custom MongoDB roles to specify custom sets of actions which cannot be described by the built-in Atlas database user privileges.\n\n\u003e **IMPORTANT**  You define custom roles at the project level for all clusters in the project. The `mongodbatlas.CustomDbRole` resource supports a subset of MongoDB privilege actions. For a complete list of [privilege actions](https://docs.mongodb.com/manual/reference/privilege-actions/) available for this resource, see [Custom Role actions](https://docs.atlas.mongodb.com/reference/api/custom-role-actions/). Custom roles must include actions that all project's clusters support, and that are compatible with each MongoDB version used by your project's clusters. For example, if your project has MongoDB 4.2 clusters, you can't create custom roles that use actions introduced in MongoDB 4.4.\n\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testRole = new mongodbatlas.CustomDbRole(\"test_role\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    roleName: \"myCustomRole\",\n    actions: [\n        {\n            action: \"UPDATE\",\n            resources: [{\n                collectionName: \"\",\n                databaseName: \"anyDatabase\",\n            }],\n        },\n        {\n            action: \"INSERT\",\n            resources: [{\n                collectionName: \"\",\n                databaseName: \"anyDatabase\",\n            }],\n        },\n        {\n            action: \"REMOVE\",\n            resources: [{\n                collectionName: \"\",\n                databaseName: \"anyDatabase\",\n            }],\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_role = mongodbatlas.CustomDbRole(\"test_role\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    role_name=\"myCustomRole\",\n    actions=[\n        {\n            \"action\": \"UPDATE\",\n            \"resources\": [{\n                \"collection_name\": \"\",\n                \"database_name\": \"anyDatabase\",\n            }],\n        },\n        {\n            \"action\": \"INSERT\",\n            \"resources\": [{\n                \"collection_name\": \"\",\n                \"database_name\": \"anyDatabase\",\n            }],\n        },\n        {\n            \"action\": \"REMOVE\",\n            \"resources\": [{\n                \"collection_name\": \"\",\n                \"database_name\": \"anyDatabase\",\n            }],\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testRole = new Mongodbatlas.CustomDbRole(\"test_role\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        RoleName = \"myCustomRole\",\n        Actions = new[]\n        {\n            new Mongodbatlas.Inputs.CustomDbRoleActionArgs\n            {\n                Action = \"UPDATE\",\n                Resources = new[]\n                {\n                    new Mongodbatlas.Inputs.CustomDbRoleActionResourceArgs\n                    {\n                        CollectionName = \"\",\n                        DatabaseName = \"anyDatabase\",\n                    },\n                },\n            },\n            new Mongodbatlas.Inputs.CustomDbRoleActionArgs\n            {\n                Action = \"INSERT\",\n                Resources = new[]\n                {\n                    new Mongodbatlas.Inputs.CustomDbRoleActionResourceArgs\n                    {\n                        CollectionName = \"\",\n                        DatabaseName = \"anyDatabase\",\n                    },\n                },\n            },\n            new Mongodbatlas.Inputs.CustomDbRoleActionArgs\n            {\n                Action = \"REMOVE\",\n                Resources = new[]\n                {\n                    new Mongodbatlas.Inputs.CustomDbRoleActionResourceArgs\n                    {\n                        CollectionName = \"\",\n                        DatabaseName = \"anyDatabase\",\n                    },\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewCustomDbRole(ctx, \"test_role\", \u0026mongodbatlas.CustomDbRoleArgs{\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tRoleName:  pulumi.String(\"myCustomRole\"),\n\t\t\tActions: mongodbatlas.CustomDbRoleActionArray{\n\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionArgs{\n\t\t\t\t\tAction: pulumi.String(\"UPDATE\"),\n\t\t\t\t\tResources: mongodbatlas.CustomDbRoleActionResourceArray{\n\t\t\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionResourceArgs{\n\t\t\t\t\t\t\tCollectionName: pulumi.String(\"\"),\n\t\t\t\t\t\t\tDatabaseName:   pulumi.String(\"anyDatabase\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionArgs{\n\t\t\t\t\tAction: pulumi.String(\"INSERT\"),\n\t\t\t\t\tResources: mongodbatlas.CustomDbRoleActionResourceArray{\n\t\t\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionResourceArgs{\n\t\t\t\t\t\t\tCollectionName: pulumi.String(\"\"),\n\t\t\t\t\t\t\tDatabaseName:   pulumi.String(\"anyDatabase\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionArgs{\n\t\t\t\t\tAction: pulumi.String(\"REMOVE\"),\n\t\t\t\t\tResources: mongodbatlas.CustomDbRoleActionResourceArray{\n\t\t\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionResourceArgs{\n\t\t\t\t\t\t\tCollectionName: pulumi.String(\"\"),\n\t\t\t\t\t\t\tDatabaseName:   pulumi.String(\"anyDatabase\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CustomDbRole;\nimport com.pulumi.mongodbatlas.CustomDbRoleArgs;\nimport com.pulumi.mongodbatlas.inputs.CustomDbRoleActionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testRole = new CustomDbRole(\"testRole\", CustomDbRoleArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .roleName(\"myCustomRole\")\n            .actions(            \n                CustomDbRoleActionArgs.builder()\n                    .action(\"UPDATE\")\n                    .resources(CustomDbRoleActionResourceArgs.builder()\n                        .collectionName(\"\")\n                        .databaseName(\"anyDatabase\")\n                        .build())\n                    .build(),\n                CustomDbRoleActionArgs.builder()\n                    .action(\"INSERT\")\n                    .resources(CustomDbRoleActionResourceArgs.builder()\n                        .collectionName(\"\")\n                        .databaseName(\"anyDatabase\")\n                        .build())\n                    .build(),\n                CustomDbRoleActionArgs.builder()\n                    .action(\"REMOVE\")\n                    .resources(CustomDbRoleActionResourceArgs.builder()\n                        .collectionName(\"\")\n                        .databaseName(\"anyDatabase\")\n                        .build())\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testRole:\n    type: mongodbatlas:CustomDbRole\n    name: test_role\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      roleName: myCustomRole\n      actions:\n        - action: UPDATE\n          resources:\n            - collectionName:\n              databaseName: anyDatabase\n        - action: INSERT\n          resources:\n            - collectionName:\n              databaseName: anyDatabase\n        - action: REMOVE\n          resources:\n            - collectionName:\n              databaseName: anyDatabase\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### With Inherited Roles\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst inheritedRoleOne = new mongodbatlas.CustomDbRole(\"inherited_role_one\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    roleName: \"insertRole\",\n    actions: [{\n        action: \"INSERT\",\n        resources: [{\n            collectionName: \"\",\n            databaseName: \"anyDatabase\",\n        }],\n    }],\n});\nconst inheritedRoleTwo = new mongodbatlas.CustomDbRole(\"inherited_role_two\", {\n    projectId: inheritedRoleOne.projectId,\n    roleName: \"statusServerRole\",\n    actions: [{\n        action: \"SERVER_STATUS\",\n        resources: [{\n            cluster: true,\n        }],\n    }],\n});\nconst testRole = new mongodbatlas.CustomDbRole(\"test_role\", {\n    projectId: inheritedRoleOne.projectId,\n    roleName: \"myCustomRole\",\n    actions: [\n        {\n            action: \"UPDATE\",\n            resources: [{\n                collectionName: \"\",\n                databaseName: \"anyDatabase\",\n            }],\n        },\n        {\n            action: \"REMOVE\",\n            resources: [{\n                collectionName: \"\",\n                databaseName: \"anyDatabase\",\n            }],\n        },\n    ],\n    inheritedRoles: [\n        {\n            roleName: inheritedRoleOne.roleName,\n            databaseName: \"admin\",\n        },\n        {\n            roleName: inheritedRoleTwo.roleName,\n            databaseName: \"admin\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ninherited_role_one = mongodbatlas.CustomDbRole(\"inherited_role_one\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    role_name=\"insertRole\",\n    actions=[{\n        \"action\": \"INSERT\",\n        \"resources\": [{\n            \"collection_name\": \"\",\n            \"database_name\": \"anyDatabase\",\n        }],\n    }])\ninherited_role_two = mongodbatlas.CustomDbRole(\"inherited_role_two\",\n    project_id=inherited_role_one.project_id,\n    role_name=\"statusServerRole\",\n    actions=[{\n        \"action\": \"SERVER_STATUS\",\n        \"resources\": [{\n            \"cluster\": True,\n        }],\n    }])\ntest_role = mongodbatlas.CustomDbRole(\"test_role\",\n    project_id=inherited_role_one.project_id,\n    role_name=\"myCustomRole\",\n    actions=[\n        {\n            \"action\": \"UPDATE\",\n            \"resources\": [{\n                \"collection_name\": \"\",\n                \"database_name\": \"anyDatabase\",\n            }],\n        },\n        {\n            \"action\": \"REMOVE\",\n            \"resources\": [{\n                \"collection_name\": \"\",\n                \"database_name\": \"anyDatabase\",\n            }],\n        },\n    ],\n    inherited_roles=[\n        {\n            \"role_name\": inherited_role_one.role_name,\n            \"database_name\": \"admin\",\n        },\n        {\n            \"role_name\": inherited_role_two.role_name,\n            \"database_name\": \"admin\",\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var inheritedRoleOne = new Mongodbatlas.CustomDbRole(\"inherited_role_one\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        RoleName = \"insertRole\",\n        Actions = new[]\n        {\n            new Mongodbatlas.Inputs.CustomDbRoleActionArgs\n            {\n                Action = \"INSERT\",\n                Resources = new[]\n                {\n                    new Mongodbatlas.Inputs.CustomDbRoleActionResourceArgs\n                    {\n                        CollectionName = \"\",\n                        DatabaseName = \"anyDatabase\",\n                    },\n                },\n            },\n        },\n    });\n\n    var inheritedRoleTwo = new Mongodbatlas.CustomDbRole(\"inherited_role_two\", new()\n    {\n        ProjectId = inheritedRoleOne.ProjectId,\n        RoleName = \"statusServerRole\",\n        Actions = new[]\n        {\n            new Mongodbatlas.Inputs.CustomDbRoleActionArgs\n            {\n                Action = \"SERVER_STATUS\",\n                Resources = new[]\n                {\n                    new Mongodbatlas.Inputs.CustomDbRoleActionResourceArgs\n                    {\n                        Cluster = true,\n                    },\n                },\n            },\n        },\n    });\n\n    var testRole = new Mongodbatlas.CustomDbRole(\"test_role\", new()\n    {\n        ProjectId = inheritedRoleOne.ProjectId,\n        RoleName = \"myCustomRole\",\n        Actions = new[]\n        {\n            new Mongodbatlas.Inputs.CustomDbRoleActionArgs\n            {\n                Action = \"UPDATE\",\n                Resources = new[]\n                {\n                    new Mongodbatlas.Inputs.CustomDbRoleActionResourceArgs\n                    {\n                        CollectionName = \"\",\n                        DatabaseName = \"anyDatabase\",\n                    },\n                },\n            },\n            new Mongodbatlas.Inputs.CustomDbRoleActionArgs\n            {\n                Action = \"REMOVE\",\n                Resources = new[]\n                {\n                    new Mongodbatlas.Inputs.CustomDbRoleActionResourceArgs\n                    {\n                        CollectionName = \"\",\n                        DatabaseName = \"anyDatabase\",\n                    },\n                },\n            },\n        },\n        InheritedRoles = new[]\n        {\n            new Mongodbatlas.Inputs.CustomDbRoleInheritedRoleArgs\n            {\n                RoleName = inheritedRoleOne.RoleName,\n                DatabaseName = \"admin\",\n            },\n            new Mongodbatlas.Inputs.CustomDbRoleInheritedRoleArgs\n            {\n                RoleName = inheritedRoleTwo.RoleName,\n                DatabaseName = \"admin\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tinheritedRoleOne, err := mongodbatlas.NewCustomDbRole(ctx, \"inherited_role_one\", \u0026mongodbatlas.CustomDbRoleArgs{\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tRoleName:  pulumi.String(\"insertRole\"),\n\t\t\tActions: mongodbatlas.CustomDbRoleActionArray{\n\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionArgs{\n\t\t\t\t\tAction: pulumi.String(\"INSERT\"),\n\t\t\t\t\tResources: mongodbatlas.CustomDbRoleActionResourceArray{\n\t\t\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionResourceArgs{\n\t\t\t\t\t\t\tCollectionName: pulumi.String(\"\"),\n\t\t\t\t\t\t\tDatabaseName:   pulumi.String(\"anyDatabase\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tinheritedRoleTwo, err := mongodbatlas.NewCustomDbRole(ctx, \"inherited_role_two\", \u0026mongodbatlas.CustomDbRoleArgs{\n\t\t\tProjectId: inheritedRoleOne.ProjectId,\n\t\t\tRoleName:  pulumi.String(\"statusServerRole\"),\n\t\t\tActions: mongodbatlas.CustomDbRoleActionArray{\n\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionArgs{\n\t\t\t\t\tAction: pulumi.String(\"SERVER_STATUS\"),\n\t\t\t\t\tResources: mongodbatlas.CustomDbRoleActionResourceArray{\n\t\t\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionResourceArgs{\n\t\t\t\t\t\t\tCluster: pulumi.Bool(true),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewCustomDbRole(ctx, \"test_role\", \u0026mongodbatlas.CustomDbRoleArgs{\n\t\t\tProjectId: inheritedRoleOne.ProjectId,\n\t\t\tRoleName:  pulumi.String(\"myCustomRole\"),\n\t\t\tActions: mongodbatlas.CustomDbRoleActionArray{\n\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionArgs{\n\t\t\t\t\tAction: pulumi.String(\"UPDATE\"),\n\t\t\t\t\tResources: mongodbatlas.CustomDbRoleActionResourceArray{\n\t\t\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionResourceArgs{\n\t\t\t\t\t\t\tCollectionName: pulumi.String(\"\"),\n\t\t\t\t\t\t\tDatabaseName:   pulumi.String(\"anyDatabase\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionArgs{\n\t\t\t\t\tAction: pulumi.String(\"REMOVE\"),\n\t\t\t\t\tResources: mongodbatlas.CustomDbRoleActionResourceArray{\n\t\t\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionResourceArgs{\n\t\t\t\t\t\t\tCollectionName: pulumi.String(\"\"),\n\t\t\t\t\t\t\tDatabaseName:   pulumi.String(\"anyDatabase\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tInheritedRoles: mongodbatlas.CustomDbRoleInheritedRoleArray{\n\t\t\t\t\u0026mongodbatlas.CustomDbRoleInheritedRoleArgs{\n\t\t\t\t\tRoleName:     inheritedRoleOne.RoleName,\n\t\t\t\t\tDatabaseName: pulumi.String(\"admin\"),\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.CustomDbRoleInheritedRoleArgs{\n\t\t\t\t\tRoleName:     inheritedRoleTwo.RoleName,\n\t\t\t\t\tDatabaseName: pulumi.String(\"admin\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CustomDbRole;\nimport com.pulumi.mongodbatlas.CustomDbRoleArgs;\nimport com.pulumi.mongodbatlas.inputs.CustomDbRoleActionArgs;\nimport com.pulumi.mongodbatlas.inputs.CustomDbRoleInheritedRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var inheritedRoleOne = new CustomDbRole(\"inheritedRoleOne\", CustomDbRoleArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .roleName(\"insertRole\")\n            .actions(CustomDbRoleActionArgs.builder()\n                .action(\"INSERT\")\n                .resources(CustomDbRoleActionResourceArgs.builder()\n                    .collectionName(\"\")\n                    .databaseName(\"anyDatabase\")\n                    .build())\n                .build())\n            .build());\n\n        var inheritedRoleTwo = new CustomDbRole(\"inheritedRoleTwo\", CustomDbRoleArgs.builder()\n            .projectId(inheritedRoleOne.projectId())\n            .roleName(\"statusServerRole\")\n            .actions(CustomDbRoleActionArgs.builder()\n                .action(\"SERVER_STATUS\")\n                .resources(CustomDbRoleActionResourceArgs.builder()\n                    .cluster(true)\n                    .build())\n                .build())\n            .build());\n\n        var testRole = new CustomDbRole(\"testRole\", CustomDbRoleArgs.builder()\n            .projectId(inheritedRoleOne.projectId())\n            .roleName(\"myCustomRole\")\n            .actions(            \n                CustomDbRoleActionArgs.builder()\n                    .action(\"UPDATE\")\n                    .resources(CustomDbRoleActionResourceArgs.builder()\n                        .collectionName(\"\")\n                        .databaseName(\"anyDatabase\")\n                        .build())\n                    .build(),\n                CustomDbRoleActionArgs.builder()\n                    .action(\"REMOVE\")\n                    .resources(CustomDbRoleActionResourceArgs.builder()\n                        .collectionName(\"\")\n                        .databaseName(\"anyDatabase\")\n                        .build())\n                    .build())\n            .inheritedRoles(            \n                CustomDbRoleInheritedRoleArgs.builder()\n                    .roleName(inheritedRoleOne.roleName())\n                    .databaseName(\"admin\")\n                    .build(),\n                CustomDbRoleInheritedRoleArgs.builder()\n                    .roleName(inheritedRoleTwo.roleName())\n                    .databaseName(\"admin\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  inheritedRoleOne:\n    type: mongodbatlas:CustomDbRole\n    name: inherited_role_one\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      roleName: insertRole\n      actions:\n        - action: INSERT\n          resources:\n            - collectionName:\n              databaseName: anyDatabase\n  inheritedRoleTwo:\n    type: mongodbatlas:CustomDbRole\n    name: inherited_role_two\n    properties:\n      projectId: ${inheritedRoleOne.projectId}\n      roleName: statusServerRole\n      actions:\n        - action: SERVER_STATUS\n          resources:\n            - cluster: true\n  testRole:\n    type: mongodbatlas:CustomDbRole\n    name: test_role\n    properties:\n      projectId: ${inheritedRoleOne.projectId}\n      roleName: myCustomRole\n      actions:\n        - action: UPDATE\n          resources:\n            - collectionName:\n              databaseName: anyDatabase\n        - action: REMOVE\n          resources:\n            - collectionName:\n              databaseName: anyDatabase\n      inheritedRoles:\n        - roleName: ${inheritedRoleOne.roleName}\n          databaseName: admin\n        - roleName: ${inheritedRoleTwo.roleName}\n          databaseName: admin\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nDatabase users can be imported using project ID and username, in the format `PROJECTID-ROLENAME`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/customDbRole:CustomDbRole my_role 1112222b3bf99403840e8934-MyCustomRole\n```\nFor more information see: [MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/custom-roles/)\n\n",
            "properties": {
                "actions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CustomDbRoleAction:CustomDbRoleAction"
                    }
                },
                "inheritedRoles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CustomDbRoleInheritedRole:CustomDbRoleInheritedRole"
                    }
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create the database user.\n"
                },
                "roleName": {
                    "type": "string",
                    "description": "Name of the custom role.\n\n\u003e **IMPORTANT** The specified role name can only contain letters, digits, underscores, and dashes. Additionally, you cannot specify a role name which meets any of the following criteria:\n\n* Is a name already used by an existing custom role in the project\n* Is a name of any of the built-in roles\n* Is `atlasAdmin`\n* Starts with `xgen-`\n"
                }
            },
            "required": [
                "projectId",
                "roleName"
            ],
            "inputProperties": {
                "actions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CustomDbRoleAction:CustomDbRoleAction"
                    }
                },
                "inheritedRoles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/CustomDbRoleInheritedRole:CustomDbRoleInheritedRole"
                    }
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create the database user.\n",
                    "willReplaceOnChanges": true
                },
                "roleName": {
                    "type": "string",
                    "description": "Name of the custom role.\n\n\u003e **IMPORTANT** The specified role name can only contain letters, digits, underscores, and dashes. Additionally, you cannot specify a role name which meets any of the following criteria:\n\n* Is a name already used by an existing custom role in the project\n* Is a name of any of the built-in roles\n* Is `atlasAdmin`\n* Starts with `xgen-`\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "projectId",
                "roleName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomDbRole resources.\n",
                "properties": {
                    "actions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/CustomDbRoleAction:CustomDbRoleAction"
                        }
                    },
                    "inheritedRoles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/CustomDbRoleInheritedRole:CustomDbRoleInheritedRole"
                        }
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the database user.\n",
                        "willReplaceOnChanges": true
                    },
                    "roleName": {
                        "type": "string",
                        "description": "Name of the custom role.\n\n\u003e **IMPORTANT** The specified role name can only contain letters, digits, underscores, and dashes. Additionally, you cannot specify a role name which meets any of the following criteria:\n\n* Is a name already used by an existing custom role in the project\n* Is a name of any of the built-in roles\n* Is `atlasAdmin`\n* Starts with `xgen-`\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/customDnsConfigurationClusterAws:CustomDnsConfigurationClusterAws": {
            "description": "## # Resource: mongodbatlas.CustomDnsConfigurationClusterAws\n\n`mongodbatlas.CustomDnsConfigurationClusterAws` provides a Custom DNS Configuration for Atlas Clusters on AWS resource. This represents a Custom DNS Configuration for Atlas Clusters on AWS that can be updated in an Atlas project.\n\n\u003e **IMPORTANT:**You must have one of the following roles to successfully handle the resource:\n  * Organization Owner\n  * Project Owner\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.CustomDnsConfigurationClusterAws(\"test\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    enabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.CustomDnsConfigurationClusterAws(\"test\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    enabled=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.CustomDnsConfigurationClusterAws(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        Enabled = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewCustomDnsConfigurationClusterAws(ctx, \"test\", \u0026mongodbatlas.CustomDnsConfigurationClusterAwsArgs{\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tEnabled:   pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CustomDnsConfigurationClusterAws;\nimport com.pulumi.mongodbatlas.CustomDnsConfigurationClusterAwsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new CustomDnsConfigurationClusterAws(\"test\", CustomDnsConfigurationClusterAwsArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .enabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:CustomDnsConfigurationClusterAws\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      enabled: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nCustom DNS Configuration for Atlas Clusters on AWS must be imported using Project ID, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/customDnsConfigurationClusterAws:CustomDnsConfigurationClusterAws test 1112222b3bf99403840e8934\n```\nSee detailed information for arguments and attributes: [MongoDB API Custom DNS Configuration for Atlas Clusters on AWS](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/AWS-Clusters-DNS/operation/getAWSCustomDNS).\n\n",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Indicates whether the project's clusters deployed to AWS use custom DNS. If `true`, the `Get All Clusters` and `Get One Cluster` endpoints return the `connectionStrings.private` and `connectionStrings.privateSrv` fields for clusters deployed to AWS .\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Required \tUnique identifier for the project.\n"
                }
            },
            "required": [
                "enabled",
                "projectId"
            ],
            "inputProperties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Indicates whether the project's clusters deployed to AWS use custom DNS. If `true`, the `Get All Clusters` and `Get One Cluster` endpoints return the `connectionStrings.private` and `connectionStrings.privateSrv` fields for clusters deployed to AWS .\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Required \tUnique identifier for the project.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "enabled",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CustomDnsConfigurationClusterAws resources.\n",
                "properties": {
                    "enabled": {
                        "type": "boolean",
                        "description": "Indicates whether the project's clusters deployed to AWS use custom DNS. If `true`, the `Get All Clusters` and `Get One Cluster` endpoints return the `connectionStrings.private` and `connectionStrings.privateSrv` fields for clusters deployed to AWS .\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Required \tUnique identifier for the project.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/dataLakePipeline:DataLakePipeline": {
            "description": "## # Resource: mongodbatlas.DataLakePipeline\n\n`mongodbatlas.DataLakePipeline` provides a Data Lake Pipeline resource.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `group_id` in the official documentation.\n\n## Example Usage\n\n### S\n\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Project;\nimport com.pulumi.mongodbatlas.ProjectArgs;\nimport com.pulumi.mongodbatlas.AdvancedCluster;\nimport com.pulumi.mongodbatlas.AdvancedClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.AdvancedClusterReplicationSpecArgs;\nimport com.pulumi.mongodbatlas.DataLakePipeline;\nimport com.pulumi.mongodbatlas.DataLakePipelineArgs;\nimport com.pulumi.mongodbatlas.inputs.DataLakePipelineSinkArgs;\nimport com.pulumi.mongodbatlas.inputs.DataLakePipelineSourceArgs;\nimport com.pulumi.mongodbatlas.inputs.DataLakePipelineTransformationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var projectTest = new Project(\"projectTest\", ProjectArgs.builder()\n            .name(\"NAME OF THE PROJECT\")\n            .orgId(\"ORGANIZATION ID\")\n            .build());\n\n        var automatedBackupTest = new AdvancedCluster(\"automatedBackupTest\", AdvancedClusterArgs.builder()\n            .projectId(projectId)\n            .name(\"automated-backup-test\")\n            .clusterType(\"REPLICASET\")\n            .backupEnabled(true)\n            .replicationSpecs(AdvancedClusterReplicationSpecArgs.builder()\n                .regionConfigs(AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                    .priority(7)\n                    .providerName(\"GCP\")\n                    .regionName(\"US_EAST_4\")\n                    .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                        .instanceSize(\"M10\")\n                        .nodeCount(3)\n                        .build())\n                    .build())\n                .build())\n            .build());\n\n        var pipeline = new DataLakePipeline(\"pipeline\", DataLakePipelineArgs.builder()\n            .projectId(projectTest.projectId())\n            .name(\"DataLakePipelineName\")\n            .sink(DataLakePipelineSinkArgs.builder()\n                .type(\"DLS\")\n                .partitionFields(DataLakePipelineSinkPartitionFieldArgs.builder()\n                    .name(\"access\")\n                    .order(0)\n                    .build())\n                .build())\n            .source(DataLakePipelineSourceArgs.builder()\n                .type(\"ON_DEMAND_CPS\")\n                .clusterName(automatedBackupTest.name())\n                .databaseName(\"sample_airbnb\")\n                .collectionName(\"listingsAndReviews\")\n                .build())\n            .transformations(            \n                DataLakePipelineTransformationArgs.builder()\n                    .field(\"test\")\n                    .type(\"EXCLUDE\")\n                    .build(),\n                DataLakePipelineTransformationArgs.builder()\n                    .field(\"test22\")\n                    .type(\"EXCLUDE\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  projectTest:\n    type: mongodbatlas:Project\n    properties:\n      name: NAME OF THE PROJECT\n      orgId: ORGANIZATION ID\n  automatedBackupTest:\n    type: mongodbatlas:AdvancedCluster\n    name: automated_backup_test\n    properties:\n      projectId: ${projectId}\n      name: automated-backup-test\n      clusterType: REPLICASET\n      backupEnabled: true # enable cloud backup snapshots\n      replicationSpecs:\n        - regionConfigs:\n            - priority: 7\n              providerName: GCP\n              regionName: US_EAST_4\n              electableSpecs:\n                instanceSize: M10\n                nodeCount: 3\n  pipeline:\n    type: mongodbatlas:DataLakePipeline\n    properties:\n      projectId: ${projectTest.projectId}\n      name: DataLakePipelineName\n      sink:\n        type: DLS\n        partitionFields:\n          - name: access\n            order: 0\n      source:\n        type: ON_DEMAND_CPS\n        clusterName: ${automatedBackupTest.name}\n        databaseName: sample_airbnb\n        collectionName: listingsAndReviews\n      transformations:\n        - field: test\n          type: EXCLUDE\n        - field: test22\n          type: EXCLUDE\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nData Lake Pipeline can be imported using project ID, name of the data lake and name of the AWS s3 bucket, in the format `project_id`--`name`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/dataLakePipeline:DataLakePipeline example 1112222b3bf99403840e8934--test-data-lake-pipeline-test\n```\nSee [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Lake-Pipelines) Documentation for more information.\n\n",
            "properties": {
                "createdDate": {
                    "type": "string",
                    "description": "Timestamp that indicates when the Data Lake Pipeline was created.\n"
                },
                "ingestionSchedules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/DataLakePipelineIngestionSchedule:DataLakePipelineIngestionSchedule"
                    },
                    "description": "List of backup schedule policy items that you can use as a Data Lake Pipeline source.\n* `ingestion_schedules.#.id` - Unique 24-hexadecimal digit string that identifies this backup policy item.\n* `ingestion_schedules.#.frequency_type` - Human-readable label that identifies the frequency type associated with the backup policy.\n* `ingestion_schedules.#.frequency_interval` - Number that indicates the frequency interval for a set of snapshots.\n* `ingestion_schedules.#.retention_unit` - Unit of time in which MongoDB Atlas measures snapshot retention.\n* `ingestion_schedules.#.retention_value` - Duration in days, weeks, or months that MongoDB Atlas retains the snapshot.\n"
                },
                "lastUpdatedDate": {
                    "type": "string",
                    "description": "Timestamp that indicates the last time that the Data Lake Pipeline was updated.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the Atlas Data Lake Pipeline.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create a data lake pipeline.\n"
                },
                "sink": {
                    "$ref": "#/types/mongodbatlas:index/DataLakePipelineSink:DataLakePipelineSink"
                },
                "snapshots": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/DataLakePipelineSnapshot:DataLakePipelineSnapshot"
                    },
                    "description": "List of backup snapshots that you can use to trigger an on demand pipeline run.\n* `snapshots.#.id` - Unique 24-hexadecimal digit string that identifies the snapshot.\n* `snapshots.#.provider` - Human-readable label that identifies the cloud provider that stores this snapshot.\n* `snapshots.#.created_at` - Date and time when MongoDB Atlas took the snapshot.\n* `snapshots.#.expires_at` - Date and time when MongoDB Atlas deletes the snapshot.\n* `snapshots.#.frequency_type` - Human-readable label that identifies how often this snapshot triggers.\n* `snapshots.#.master_key` - Unique string that identifies the Amazon Web Services (AWS) Key Management Service (KMS) Customer Master Key (CMK) used to encrypt the snapshot.\n* `snapshots.#.mongod_version` - Version of the MongoDB host that this snapshot backs up.\n* `snapshots.#.replica_set_name` - Human-readable label that identifies the replica set from which MongoDB Atlas took this snapshot.\n* `snapshots.#.type` - Human-readable label that categorizes the cluster as a replica set or sharded cluster.\n* `snapshots.#.snapshot_type` - Human-readable label that identifies when this snapshot triggers.\n* `snapshots.#.status` - Human-readable label that indicates the stage of the backup process for this snapshot.\n* `snapshots.#.size` - List of backup snapshots that you can use to trigger an on demand pipeline run.\n* `snapshots.#.copy_region` - List that identifies the regions to which MongoDB Atlas copies the snapshot.\n* `snapshots.#.policies` - List that contains unique identifiers for the policy items.\n"
                },
                "source": {
                    "$ref": "#/types/mongodbatlas:index/DataLakePipelineSource:DataLakePipelineSource"
                },
                "state": {
                    "type": "string",
                    "description": "State of this Data Lake Pipeline.\n"
                },
                "transformations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/DataLakePipelineTransformation:DataLakePipelineTransformation"
                    },
                    "description": "Fields to be excluded for this Data Lake Pipeline.\n* `transformations.#.field` - Key in the document.\n* `transformations.#.type` - Type of transformation applied during the export of the namespace in a Data Lake Pipeline.\n"
                }
            },
            "required": [
                "createdDate",
                "ingestionSchedules",
                "lastUpdatedDate",
                "name",
                "projectId",
                "snapshots",
                "state"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "Name of the Atlas Data Lake Pipeline.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create a data lake pipeline.\n"
                },
                "sink": {
                    "$ref": "#/types/mongodbatlas:index/DataLakePipelineSink:DataLakePipelineSink"
                },
                "source": {
                    "$ref": "#/types/mongodbatlas:index/DataLakePipelineSource:DataLakePipelineSource"
                },
                "transformations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/DataLakePipelineTransformation:DataLakePipelineTransformation"
                    },
                    "description": "Fields to be excluded for this Data Lake Pipeline.\n* `transformations.#.field` - Key in the document.\n* `transformations.#.type` - Type of transformation applied during the export of the namespace in a Data Lake Pipeline.\n"
                }
            },
            "requiredInputs": [
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DataLakePipeline resources.\n",
                "properties": {
                    "createdDate": {
                        "type": "string",
                        "description": "Timestamp that indicates when the Data Lake Pipeline was created.\n"
                    },
                    "ingestionSchedules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/DataLakePipelineIngestionSchedule:DataLakePipelineIngestionSchedule"
                        },
                        "description": "List of backup schedule policy items that you can use as a Data Lake Pipeline source.\n* `ingestion_schedules.#.id` - Unique 24-hexadecimal digit string that identifies this backup policy item.\n* `ingestion_schedules.#.frequency_type` - Human-readable label that identifies the frequency type associated with the backup policy.\n* `ingestion_schedules.#.frequency_interval` - Number that indicates the frequency interval for a set of snapshots.\n* `ingestion_schedules.#.retention_unit` - Unit of time in which MongoDB Atlas measures snapshot retention.\n* `ingestion_schedules.#.retention_value` - Duration in days, weeks, or months that MongoDB Atlas retains the snapshot.\n"
                    },
                    "lastUpdatedDate": {
                        "type": "string",
                        "description": "Timestamp that indicates the last time that the Data Lake Pipeline was updated.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the Atlas Data Lake Pipeline.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create a data lake pipeline.\n"
                    },
                    "sink": {
                        "$ref": "#/types/mongodbatlas:index/DataLakePipelineSink:DataLakePipelineSink"
                    },
                    "snapshots": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/DataLakePipelineSnapshot:DataLakePipelineSnapshot"
                        },
                        "description": "List of backup snapshots that you can use to trigger an on demand pipeline run.\n* `snapshots.#.id` - Unique 24-hexadecimal digit string that identifies the snapshot.\n* `snapshots.#.provider` - Human-readable label that identifies the cloud provider that stores this snapshot.\n* `snapshots.#.created_at` - Date and time when MongoDB Atlas took the snapshot.\n* `snapshots.#.expires_at` - Date and time when MongoDB Atlas deletes the snapshot.\n* `snapshots.#.frequency_type` - Human-readable label that identifies how often this snapshot triggers.\n* `snapshots.#.master_key` - Unique string that identifies the Amazon Web Services (AWS) Key Management Service (KMS) Customer Master Key (CMK) used to encrypt the snapshot.\n* `snapshots.#.mongod_version` - Version of the MongoDB host that this snapshot backs up.\n* `snapshots.#.replica_set_name` - Human-readable label that identifies the replica set from which MongoDB Atlas took this snapshot.\n* `snapshots.#.type` - Human-readable label that categorizes the cluster as a replica set or sharded cluster.\n* `snapshots.#.snapshot_type` - Human-readable label that identifies when this snapshot triggers.\n* `snapshots.#.status` - Human-readable label that indicates the stage of the backup process for this snapshot.\n* `snapshots.#.size` - List of backup snapshots that you can use to trigger an on demand pipeline run.\n* `snapshots.#.copy_region` - List that identifies the regions to which MongoDB Atlas copies the snapshot.\n* `snapshots.#.policies` - List that contains unique identifiers for the policy items.\n"
                    },
                    "source": {
                        "$ref": "#/types/mongodbatlas:index/DataLakePipelineSource:DataLakePipelineSource"
                    },
                    "state": {
                        "type": "string",
                        "description": "State of this Data Lake Pipeline.\n"
                    },
                    "transformations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/DataLakePipelineTransformation:DataLakePipelineTransformation"
                        },
                        "description": "Fields to be excluded for this Data Lake Pipeline.\n* `transformations.#.field` - Key in the document.\n* `transformations.#.type` - Type of transformation applied during the export of the namespace in a Data Lake Pipeline.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/databaseUser:DatabaseUser": {
            "description": "## # Resource: mongodbatlas.DatabaseUser\n\n`mongodbatlas.DatabaseUser` provides a Database User resource. This represents a database user which will be applied to all clusters within the project.\n\nEach user has a set of roles that provide access to the projectâs databases. User's roles apply to all the clusters in the project: if two clusters have a `products` database and a user has a role granting `read` access on the products database, the user has that access on both clusters.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n\u003e **WARNING:** The password argument is required for creation but should be removed after creation if it will be managed externally. More details can be found in the password argument documentation.\n\n\u003e **IMPORTANT:** All arguments including the password will be stored in the raw state as plain-text. Read more about sensitive data in state.\n\n## Example Usage\n\n### S\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.DatabaseUser(\"test\", {\n    username: \"test-acc-username\",\n    password: \"test-acc-password\",\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    authDatabaseName: \"admin\",\n    roles: [\n        {\n            roleName: \"readWrite\",\n            databaseName: \"dbforApp\",\n        },\n        {\n            roleName: \"readAnyDatabase\",\n            databaseName: \"admin\",\n        },\n    ],\n    labels: [{\n        key: \"My Key\",\n        value: \"My Value\",\n    }],\n    scopes: [\n        {\n            name: \"My cluster name\",\n            type: \"CLUSTER\",\n        },\n        {\n            name: \"My second cluster name\",\n            type: \"CLUSTER\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.DatabaseUser(\"test\",\n    username=\"test-acc-username\",\n    password=\"test-acc-password\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    auth_database_name=\"admin\",\n    roles=[\n        {\n            \"role_name\": \"readWrite\",\n            \"database_name\": \"dbforApp\",\n        },\n        {\n            \"role_name\": \"readAnyDatabase\",\n            \"database_name\": \"admin\",\n        },\n    ],\n    labels=[{\n        \"key\": \"My Key\",\n        \"value\": \"My Value\",\n    }],\n    scopes=[\n        {\n            \"name\": \"My cluster name\",\n            \"type\": \"CLUSTER\",\n        },\n        {\n            \"name\": \"My second cluster name\",\n            \"type\": \"CLUSTER\",\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.DatabaseUser(\"test\", new()\n    {\n        Username = \"test-acc-username\",\n        Password = \"test-acc-password\",\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        AuthDatabaseName = \"admin\",\n        Roles = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserRoleArgs\n            {\n                RoleName = \"readWrite\",\n                DatabaseName = \"dbforApp\",\n            },\n            new Mongodbatlas.Inputs.DatabaseUserRoleArgs\n            {\n                RoleName = \"readAnyDatabase\",\n                DatabaseName = \"admin\",\n            },\n        },\n        Labels = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserLabelArgs\n            {\n                Key = \"My Key\",\n                Value = \"My Value\",\n            },\n        },\n        Scopes = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserScopeArgs\n            {\n                Name = \"My cluster name\",\n                Type = \"CLUSTER\",\n            },\n            new Mongodbatlas.Inputs.DatabaseUserScopeArgs\n            {\n                Name = \"My second cluster name\",\n                Type = \"CLUSTER\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewDatabaseUser(ctx, \"test\", \u0026mongodbatlas.DatabaseUserArgs{\n\t\t\tUsername:         pulumi.String(\"test-acc-username\"),\n\t\t\tPassword:         pulumi.String(\"test-acc-password\"),\n\t\t\tProjectId:        pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tAuthDatabaseName: pulumi.String(\"admin\"),\n\t\t\tRoles: mongodbatlas.DatabaseUserRoleArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserRoleArgs{\n\t\t\t\t\tRoleName:     pulumi.String(\"readWrite\"),\n\t\t\t\t\tDatabaseName: pulumi.String(\"dbforApp\"),\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.DatabaseUserRoleArgs{\n\t\t\t\t\tRoleName:     pulumi.String(\"readAnyDatabase\"),\n\t\t\t\t\tDatabaseName: pulumi.String(\"admin\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tLabels: mongodbatlas.DatabaseUserLabelArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserLabelArgs{\n\t\t\t\t\tKey:   pulumi.String(\"My Key\"),\n\t\t\t\t\tValue: pulumi.String(\"My Value\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tScopes: mongodbatlas.DatabaseUserScopeArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserScopeArgs{\n\t\t\t\t\tName: pulumi.String(\"My cluster name\"),\n\t\t\t\t\tType: pulumi.String(\"CLUSTER\"),\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.DatabaseUserScopeArgs{\n\t\t\t\t\tName: pulumi.String(\"My second cluster name\"),\n\t\t\t\t\tType: pulumi.String(\"CLUSTER\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.DatabaseUser;\nimport com.pulumi.mongodbatlas.DatabaseUserArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserRoleArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserLabelArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserScopeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new DatabaseUser(\"test\", DatabaseUserArgs.builder()\n            .username(\"test-acc-username\")\n            .password(\"test-acc-password\")\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .authDatabaseName(\"admin\")\n            .roles(            \n                DatabaseUserRoleArgs.builder()\n                    .roleName(\"readWrite\")\n                    .databaseName(\"dbforApp\")\n                    .build(),\n                DatabaseUserRoleArgs.builder()\n                    .roleName(\"readAnyDatabase\")\n                    .databaseName(\"admin\")\n                    .build())\n            .labels(DatabaseUserLabelArgs.builder()\n                .key(\"My Key\")\n                .value(\"My Value\")\n                .build())\n            .scopes(            \n                DatabaseUserScopeArgs.builder()\n                    .name(\"My cluster name\")\n                    .type(\"CLUSTER\")\n                    .build(),\n                DatabaseUserScopeArgs.builder()\n                    .name(\"My second cluster name\")\n                    .type(\"CLUSTER\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:DatabaseUser\n    properties:\n      username: test-acc-username\n      password: test-acc-password\n      projectId: \u003cPROJECT-ID\u003e\n      authDatabaseName: admin\n      roles:\n        - roleName: readWrite\n          databaseName: dbforApp\n        - roleName: readAnyDatabase\n          databaseName: admin\n      labels:\n        - key: My Key\n          value: My Value\n      scopes:\n        - name: My cluster name\n          type: CLUSTER\n        - name: My second cluster name\n          type: CLUSTER\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.DatabaseUser(\"test\", {\n    username: \"test-acc-username\",\n    x509Type: \"MANAGED\",\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    authDatabaseName: \"$external\",\n    roles: [{\n        roleName: \"readAnyDatabase\",\n        databaseName: \"admin\",\n    }],\n    labels: [{\n        key: \"%s\",\n        value: \"%s\",\n    }],\n    scopes: [{\n        name: \"My cluster name\",\n        type: \"CLUSTER\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.DatabaseUser(\"test\",\n    username=\"test-acc-username\",\n    x509_type=\"MANAGED\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    auth_database_name=\"$external\",\n    roles=[{\n        \"role_name\": \"readAnyDatabase\",\n        \"database_name\": \"admin\",\n    }],\n    labels=[{\n        \"key\": \"%s\",\n        \"value\": \"%s\",\n    }],\n    scopes=[{\n        \"name\": \"My cluster name\",\n        \"type\": \"CLUSTER\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.DatabaseUser(\"test\", new()\n    {\n        Username = \"test-acc-username\",\n        X509Type = \"MANAGED\",\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        AuthDatabaseName = \"$external\",\n        Roles = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserRoleArgs\n            {\n                RoleName = \"readAnyDatabase\",\n                DatabaseName = \"admin\",\n            },\n        },\n        Labels = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserLabelArgs\n            {\n                Key = \"%s\",\n                Value = \"%s\",\n            },\n        },\n        Scopes = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserScopeArgs\n            {\n                Name = \"My cluster name\",\n                Type = \"CLUSTER\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewDatabaseUser(ctx, \"test\", \u0026mongodbatlas.DatabaseUserArgs{\n\t\t\tUsername:         pulumi.String(\"test-acc-username\"),\n\t\t\tX509Type:         pulumi.String(\"MANAGED\"),\n\t\t\tProjectId:        pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tAuthDatabaseName: pulumi.String(\"$external\"),\n\t\t\tRoles: mongodbatlas.DatabaseUserRoleArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserRoleArgs{\n\t\t\t\t\tRoleName:     pulumi.String(\"readAnyDatabase\"),\n\t\t\t\t\tDatabaseName: pulumi.String(\"admin\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tLabels: mongodbatlas.DatabaseUserLabelArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserLabelArgs{\n\t\t\t\t\tKey:   pulumi.String(\"%s\"),\n\t\t\t\t\tValue: pulumi.String(\"%s\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tScopes: mongodbatlas.DatabaseUserScopeArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserScopeArgs{\n\t\t\t\t\tName: pulumi.String(\"My cluster name\"),\n\t\t\t\t\tType: pulumi.String(\"CLUSTER\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.DatabaseUser;\nimport com.pulumi.mongodbatlas.DatabaseUserArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserRoleArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserLabelArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserScopeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new DatabaseUser(\"test\", DatabaseUserArgs.builder()\n            .username(\"test-acc-username\")\n            .x509Type(\"MANAGED\")\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .authDatabaseName(\"$external\")\n            .roles(DatabaseUserRoleArgs.builder()\n                .roleName(\"readAnyDatabase\")\n                .databaseName(\"admin\")\n                .build())\n            .labels(DatabaseUserLabelArgs.builder()\n                .key(\"%s\")\n                .value(\"%s\")\n                .build())\n            .scopes(DatabaseUserScopeArgs.builder()\n                .name(\"My cluster name\")\n                .type(\"CLUSTER\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:DatabaseUser\n    properties:\n      username: test-acc-username\n      x509Type: MANAGED\n      projectId: \u003cPROJECT-ID\u003e\n      authDatabaseName: $external\n      roles:\n        - roleName: readAnyDatabase\n          databaseName: admin\n      labels:\n        - key: '%s'\n          value: '%s'\n      scopes:\n        - name: My cluster name\n          type: CLUSTER\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.DatabaseUser(\"test\", {\n    username: testAwsIamRole.arn,\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    authDatabaseName: \"$external\",\n    awsIamType: \"ROLE\",\n    roles: [{\n        roleName: \"readAnyDatabase\",\n        databaseName: \"admin\",\n    }],\n    labels: [{\n        key: \"%s\",\n        value: \"%s\",\n    }],\n    scopes: [{\n        name: \"My cluster name\",\n        type: \"CLUSTER\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.DatabaseUser(\"test\",\n    username=test_aws_iam_role[\"arn\"],\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    auth_database_name=\"$external\",\n    aws_iam_type=\"ROLE\",\n    roles=[{\n        \"role_name\": \"readAnyDatabase\",\n        \"database_name\": \"admin\",\n    }],\n    labels=[{\n        \"key\": \"%s\",\n        \"value\": \"%s\",\n    }],\n    scopes=[{\n        \"name\": \"My cluster name\",\n        \"type\": \"CLUSTER\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.DatabaseUser(\"test\", new()\n    {\n        Username = testAwsIamRole.Arn,\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        AuthDatabaseName = \"$external\",\n        AwsIamType = \"ROLE\",\n        Roles = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserRoleArgs\n            {\n                RoleName = \"readAnyDatabase\",\n                DatabaseName = \"admin\",\n            },\n        },\n        Labels = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserLabelArgs\n            {\n                Key = \"%s\",\n                Value = \"%s\",\n            },\n        },\n        Scopes = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserScopeArgs\n            {\n                Name = \"My cluster name\",\n                Type = \"CLUSTER\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewDatabaseUser(ctx, \"test\", \u0026mongodbatlas.DatabaseUserArgs{\n\t\t\tUsername:         pulumi.Any(testAwsIamRole.Arn),\n\t\t\tProjectId:        pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tAuthDatabaseName: pulumi.String(\"$external\"),\n\t\t\tAwsIamType:       pulumi.String(\"ROLE\"),\n\t\t\tRoles: mongodbatlas.DatabaseUserRoleArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserRoleArgs{\n\t\t\t\t\tRoleName:     pulumi.String(\"readAnyDatabase\"),\n\t\t\t\t\tDatabaseName: pulumi.String(\"admin\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tLabels: mongodbatlas.DatabaseUserLabelArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserLabelArgs{\n\t\t\t\t\tKey:   pulumi.String(\"%s\"),\n\t\t\t\t\tValue: pulumi.String(\"%s\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tScopes: mongodbatlas.DatabaseUserScopeArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserScopeArgs{\n\t\t\t\t\tName: pulumi.String(\"My cluster name\"),\n\t\t\t\t\tType: pulumi.String(\"CLUSTER\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.DatabaseUser;\nimport com.pulumi.mongodbatlas.DatabaseUserArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserRoleArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserLabelArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserScopeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new DatabaseUser(\"test\", DatabaseUserArgs.builder()\n            .username(testAwsIamRole.arn())\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .authDatabaseName(\"$external\")\n            .awsIamType(\"ROLE\")\n            .roles(DatabaseUserRoleArgs.builder()\n                .roleName(\"readAnyDatabase\")\n                .databaseName(\"admin\")\n                .build())\n            .labels(DatabaseUserLabelArgs.builder()\n                .key(\"%s\")\n                .value(\"%s\")\n                .build())\n            .scopes(DatabaseUserScopeArgs.builder()\n                .name(\"My cluster name\")\n                .type(\"CLUSTER\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:DatabaseUser\n    properties:\n      username: ${testAwsIamRole.arn}\n      projectId: \u003cPROJECT-ID\u003e\n      authDatabaseName: $external\n      awsIamType: ROLE\n      roles:\n        - roleName: readAnyDatabase\n          databaseName: admin\n      labels:\n        - key: '%s'\n          value: '%s'\n      scopes:\n        - name: My cluster name\n          type: CLUSTER\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n## Example of how to create a OIDC federated authentication user\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.DatabaseUser(\"test\", {\n    username: \"64d613677e1ad50839cce4db/testUserOr\",\n    projectId: \"6414908c207f4d22f4d8f232\",\n    authDatabaseName: \"admin\",\n    oidcAuthType: \"IDP_GROUP\",\n    roles: [{\n        roleName: \"readWriteAnyDatabase\",\n        databaseName: \"admin\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.DatabaseUser(\"test\",\n    username=\"64d613677e1ad50839cce4db/testUserOr\",\n    project_id=\"6414908c207f4d22f4d8f232\",\n    auth_database_name=\"admin\",\n    oidc_auth_type=\"IDP_GROUP\",\n    roles=[{\n        \"role_name\": \"readWriteAnyDatabase\",\n        \"database_name\": \"admin\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.DatabaseUser(\"test\", new()\n    {\n        Username = \"64d613677e1ad50839cce4db/testUserOr\",\n        ProjectId = \"6414908c207f4d22f4d8f232\",\n        AuthDatabaseName = \"admin\",\n        OidcAuthType = \"IDP_GROUP\",\n        Roles = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserRoleArgs\n            {\n                RoleName = \"readWriteAnyDatabase\",\n                DatabaseName = \"admin\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewDatabaseUser(ctx, \"test\", \u0026mongodbatlas.DatabaseUserArgs{\n\t\t\tUsername:         pulumi.String(\"64d613677e1ad50839cce4db/testUserOr\"),\n\t\t\tProjectId:        pulumi.String(\"6414908c207f4d22f4d8f232\"),\n\t\t\tAuthDatabaseName: pulumi.String(\"admin\"),\n\t\t\tOidcAuthType:     pulumi.String(\"IDP_GROUP\"),\n\t\t\tRoles: mongodbatlas.DatabaseUserRoleArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserRoleArgs{\n\t\t\t\t\tRoleName:     pulumi.String(\"readWriteAnyDatabase\"),\n\t\t\t\t\tDatabaseName: pulumi.String(\"admin\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.DatabaseUser;\nimport com.pulumi.mongodbatlas.DatabaseUserArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new DatabaseUser(\"test\", DatabaseUserArgs.builder()\n            .username(\"64d613677e1ad50839cce4db/testUserOr\")\n            .projectId(\"6414908c207f4d22f4d8f232\")\n            .authDatabaseName(\"admin\")\n            .oidcAuthType(\"IDP_GROUP\")\n            .roles(DatabaseUserRoleArgs.builder()\n                .roleName(\"readWriteAnyDatabase\")\n                .databaseName(\"admin\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:DatabaseUser\n    properties:\n      username: 64d613677e1ad50839cce4db/testUserOr\n      projectId: 6414908c207f4d22f4d8f232\n      authDatabaseName: admin\n      oidcAuthType: IDP_GROUP\n      roles:\n        - roleName: readWriteAnyDatabase\n          databaseName: admin\n```\n\u003c!--End PulumiCodeChooser --\u003e\n`username` format: Atlas OIDC IdP ID (found in federation settings), followed by a '/', followed by the IdP group name\n\nNote: OIDC support is only avalible starting in [MongoDB 7.0](https://www.mongodb.com/evolved#mdbsevenzero) or later. To learn more, see the [MongoDB Atlas documentation](https://www.mongodb.com/docs/atlas/security-oidc/).\n\n## Import\n\nDatabase users can be imported using project ID and username, in the format `project_id`-`username`-`auth_database_name`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/databaseUser:DatabaseUser my_user 1112222b3bf99403840e8934-my_user-admin\n```\n~\u003e __NOTE:__ Terraform will want to change the password after importing the user if a `password` argument is specified.\n\n",
            "properties": {
                "authDatabaseName": {
                    "type": "string",
                    "description": "Database against which Atlas authenticates the user. A user must provide both a username and authentication database to log into MongoDB.\nAccepted values include:\n"
                },
                "awsIamType": {
                    "type": "string",
                    "description": "If this value is set, the new database user authenticates with AWS IAM credentials. If no value is given, Atlas uses the default value of `NONE`. The accepted types are:\n* `NONE` -\tThe user does not use AWS IAM credentials.\n* `USER` - New database user has AWS IAM user credentials.\n* `ROLE` -  New database user has credentials associated with an AWS IAM role.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/DatabaseUserLabel:DatabaseUserLabel"
                    }
                },
                "ldapAuthType": {
                    "type": "string",
                    "description": "Method by which the provided `username` is authenticated. If no value is given, Atlas uses the default value of `NONE`.\n* `NONE` -\tAtlas authenticates this user through [SCRAM-SHA](https://docs.mongodb.com/manual/core/security-scram/), not LDAP.\n* `USER` - LDAP server authenticates this user through the user's LDAP user. `username` must also be a fully qualified distinguished name, as defined in [RFC-2253](https://tools.ietf.org/html/rfc2253).\n* `GROUP` - LDAP server authenticates this user using their LDAP user and authorizes this user using their LDAP group. To learn more about LDAP security, see [Set up User Authentication and Authorization with LDAP](https://docs.atlas.mongodb.com/security-ldaps). `username` must also be a fully qualified distinguished name, as defined in [RFC-2253](https://tools.ietf.org/html/rfc2253).\n"
                },
                "oidcAuthType": {
                    "type": "string",
                    "description": "Human-readable label that indicates whether the new database user authenticates with OIDC (OpenID Connect) federated authentication. If no value is given, Atlas uses the default value of `NONE`. The accepted types are:\n* `NONE` -\tThe user does not use OIDC federated authentication.\n* `IDP_GROUP` - OIDC Workforce federated authentication group. To learn more about OIDC federated authentication, see [Set up Workforce Identity Federation with OIDC](https://www.mongodb.com/docs/atlas/security-oidc/).\n* `USER` - OIDC Workload federated authentication user. To learn more about OIDC federated authentication, see [Set up Workload Identity Federation with OIDC](https://www.mongodb.com/docs/atlas/security-oidc/).\n"
                },
                "password": {
                    "type": "string",
                    "secret": true
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create the database user.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/DatabaseUserRole:DatabaseUserRole"
                    },
                    "description": "List of userâs roles and the databases / collections on which the roles apply. A role allows the user to perform particular actions on the specified database. A role on the admin database can include privileges that apply to the other databases as well. See Roles below for more details.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/DatabaseUserScope:DatabaseUserScope"
                    }
                },
                "username": {
                    "type": "string",
                    "description": "Username for authenticating to MongoDB. USER_ARN or ROLE_ARN if `aws_iam_type` is USER or ROLE.\n"
                },
                "x509Type": {
                    "type": "string",
                    "description": "X.509 method by which the provided username is authenticated. If no value is given, Atlas uses the default value of NONE. The accepted types are:\n* `NONE` -\tThe user does not use X.509 authentication.\n* `MANAGED` - The user is being created for use with Atlas-managed X.509.Externally authenticated users can only be created on the `$external` database.\n* `CUSTOMER` -  The user is being created for use with Self-Managed X.509. Users created with this x509Type require a Common Name (CN) in the username field. Externally authenticated users can only be created on the `$external` database.\n"
                }
            },
            "required": [
                "authDatabaseName",
                "awsIamType",
                "ldapAuthType",
                "oidcAuthType",
                "projectId",
                "username",
                "x509Type"
            ],
            "inputProperties": {
                "authDatabaseName": {
                    "type": "string",
                    "description": "Database against which Atlas authenticates the user. A user must provide both a username and authentication database to log into MongoDB.\nAccepted values include:\n"
                },
                "awsIamType": {
                    "type": "string",
                    "description": "If this value is set, the new database user authenticates with AWS IAM credentials. If no value is given, Atlas uses the default value of `NONE`. The accepted types are:\n* `NONE` -\tThe user does not use AWS IAM credentials.\n* `USER` - New database user has AWS IAM user credentials.\n* `ROLE` -  New database user has credentials associated with an AWS IAM role.\n"
                },
                "labels": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/DatabaseUserLabel:DatabaseUserLabel"
                    }
                },
                "ldapAuthType": {
                    "type": "string",
                    "description": "Method by which the provided `username` is authenticated. If no value is given, Atlas uses the default value of `NONE`.\n* `NONE` -\tAtlas authenticates this user through [SCRAM-SHA](https://docs.mongodb.com/manual/core/security-scram/), not LDAP.\n* `USER` - LDAP server authenticates this user through the user's LDAP user. `username` must also be a fully qualified distinguished name, as defined in [RFC-2253](https://tools.ietf.org/html/rfc2253).\n* `GROUP` - LDAP server authenticates this user using their LDAP user and authorizes this user using their LDAP group. To learn more about LDAP security, see [Set up User Authentication and Authorization with LDAP](https://docs.atlas.mongodb.com/security-ldaps). `username` must also be a fully qualified distinguished name, as defined in [RFC-2253](https://tools.ietf.org/html/rfc2253).\n"
                },
                "oidcAuthType": {
                    "type": "string",
                    "description": "Human-readable label that indicates whether the new database user authenticates with OIDC (OpenID Connect) federated authentication. If no value is given, Atlas uses the default value of `NONE`. The accepted types are:\n* `NONE` -\tThe user does not use OIDC federated authentication.\n* `IDP_GROUP` - OIDC Workforce federated authentication group. To learn more about OIDC federated authentication, see [Set up Workforce Identity Federation with OIDC](https://www.mongodb.com/docs/atlas/security-oidc/).\n* `USER` - OIDC Workload federated authentication user. To learn more about OIDC federated authentication, see [Set up Workload Identity Federation with OIDC](https://www.mongodb.com/docs/atlas/security-oidc/).\n"
                },
                "password": {
                    "type": "string",
                    "secret": true
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create the database user.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/DatabaseUserRole:DatabaseUserRole"
                    },
                    "description": "List of userâs roles and the databases / collections on which the roles apply. A role allows the user to perform particular actions on the specified database. A role on the admin database can include privileges that apply to the other databases as well. See Roles below for more details.\n"
                },
                "scopes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/DatabaseUserScope:DatabaseUserScope"
                    }
                },
                "username": {
                    "type": "string",
                    "description": "Username for authenticating to MongoDB. USER_ARN or ROLE_ARN if `aws_iam_type` is USER or ROLE.\n"
                },
                "x509Type": {
                    "type": "string",
                    "description": "X.509 method by which the provided username is authenticated. If no value is given, Atlas uses the default value of NONE. The accepted types are:\n* `NONE` -\tThe user does not use X.509 authentication.\n* `MANAGED` - The user is being created for use with Atlas-managed X.509.Externally authenticated users can only be created on the `$external` database.\n* `CUSTOMER` -  The user is being created for use with Self-Managed X.509. Users created with this x509Type require a Common Name (CN) in the username field. Externally authenticated users can only be created on the `$external` database.\n"
                }
            },
            "requiredInputs": [
                "authDatabaseName",
                "projectId",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DatabaseUser resources.\n",
                "properties": {
                    "authDatabaseName": {
                        "type": "string",
                        "description": "Database against which Atlas authenticates the user. A user must provide both a username and authentication database to log into MongoDB.\nAccepted values include:\n"
                    },
                    "awsIamType": {
                        "type": "string",
                        "description": "If this value is set, the new database user authenticates with AWS IAM credentials. If no value is given, Atlas uses the default value of `NONE`. The accepted types are:\n* `NONE` -\tThe user does not use AWS IAM credentials.\n* `USER` - New database user has AWS IAM user credentials.\n* `ROLE` -  New database user has credentials associated with an AWS IAM role.\n"
                    },
                    "labels": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/DatabaseUserLabel:DatabaseUserLabel"
                        }
                    },
                    "ldapAuthType": {
                        "type": "string",
                        "description": "Method by which the provided `username` is authenticated. If no value is given, Atlas uses the default value of `NONE`.\n* `NONE` -\tAtlas authenticates this user through [SCRAM-SHA](https://docs.mongodb.com/manual/core/security-scram/), not LDAP.\n* `USER` - LDAP server authenticates this user through the user's LDAP user. `username` must also be a fully qualified distinguished name, as defined in [RFC-2253](https://tools.ietf.org/html/rfc2253).\n* `GROUP` - LDAP server authenticates this user using their LDAP user and authorizes this user using their LDAP group. To learn more about LDAP security, see [Set up User Authentication and Authorization with LDAP](https://docs.atlas.mongodb.com/security-ldaps). `username` must also be a fully qualified distinguished name, as defined in [RFC-2253](https://tools.ietf.org/html/rfc2253).\n"
                    },
                    "oidcAuthType": {
                        "type": "string",
                        "description": "Human-readable label that indicates whether the new database user authenticates with OIDC (OpenID Connect) federated authentication. If no value is given, Atlas uses the default value of `NONE`. The accepted types are:\n* `NONE` -\tThe user does not use OIDC federated authentication.\n* `IDP_GROUP` - OIDC Workforce federated authentication group. To learn more about OIDC federated authentication, see [Set up Workforce Identity Federation with OIDC](https://www.mongodb.com/docs/atlas/security-oidc/).\n* `USER` - OIDC Workload federated authentication user. To learn more about OIDC federated authentication, see [Set up Workload Identity Federation with OIDC](https://www.mongodb.com/docs/atlas/security-oidc/).\n"
                    },
                    "password": {
                        "type": "string",
                        "secret": true
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the database user.\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/DatabaseUserRole:DatabaseUserRole"
                        },
                        "description": "List of userâs roles and the databases / collections on which the roles apply. A role allows the user to perform particular actions on the specified database. A role on the admin database can include privileges that apply to the other databases as well. See Roles below for more details.\n"
                    },
                    "scopes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/DatabaseUserScope:DatabaseUserScope"
                        }
                    },
                    "username": {
                        "type": "string",
                        "description": "Username for authenticating to MongoDB. USER_ARN or ROLE_ARN if `aws_iam_type` is USER or ROLE.\n"
                    },
                    "x509Type": {
                        "type": "string",
                        "description": "X.509 method by which the provided username is authenticated. If no value is given, Atlas uses the default value of NONE. The accepted types are:\n* `NONE` -\tThe user does not use X.509 authentication.\n* `MANAGED` - The user is being created for use with Atlas-managed X.509.Externally authenticated users can only be created on the `$external` database.\n* `CUSTOMER` -  The user is being created for use with Self-Managed X.509. Users created with this x509Type require a Common Name (CN) in the username field. Externally authenticated users can only be created on the `$external` database.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/encryptionAtRest:EncryptionAtRest": {
            "description": "\n\n## Import\n\nEncryption at Rest Settings can be imported using project ID, in the format `project_id`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/encryptionAtRest:EncryptionAtRest example 1112222b3bf99403840e8934\n```\nFor more information see: [MongoDB Atlas API Reference for Encryption at Rest using Customer Key Management.](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Encryption-at-Rest-using-Customer-Key-Management)\n\n",
            "properties": {
                "awsKmsConfig": {
                    "$ref": "#/types/mongodbatlas:index/EncryptionAtRestAwsKmsConfig:EncryptionAtRestAwsKmsConfig"
                },
                "azureKeyVaultConfig": {
                    "$ref": "#/types/mongodbatlas:index/EncryptionAtRestAzureKeyVaultConfig:EncryptionAtRestAzureKeyVaultConfig"
                },
                "googleCloudKmsConfig": {
                    "$ref": "#/types/mongodbatlas:index/EncryptionAtRestGoogleCloudKmsConfig:EncryptionAtRestGoogleCloudKmsConfig"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier for the project.\n"
                }
            },
            "required": [
                "projectId"
            ],
            "inputProperties": {
                "awsKmsConfig": {
                    "$ref": "#/types/mongodbatlas:index/EncryptionAtRestAwsKmsConfig:EncryptionAtRestAwsKmsConfig"
                },
                "azureKeyVaultConfig": {
                    "$ref": "#/types/mongodbatlas:index/EncryptionAtRestAzureKeyVaultConfig:EncryptionAtRestAzureKeyVaultConfig"
                },
                "googleCloudKmsConfig": {
                    "$ref": "#/types/mongodbatlas:index/EncryptionAtRestGoogleCloudKmsConfig:EncryptionAtRestGoogleCloudKmsConfig"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier for the project.\n"
                }
            },
            "requiredInputs": [
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EncryptionAtRest resources.\n",
                "properties": {
                    "awsKmsConfig": {
                        "$ref": "#/types/mongodbatlas:index/EncryptionAtRestAwsKmsConfig:EncryptionAtRestAwsKmsConfig"
                    },
                    "azureKeyVaultConfig": {
                        "$ref": "#/types/mongodbatlas:index/EncryptionAtRestAzureKeyVaultConfig:EncryptionAtRestAzureKeyVaultConfig"
                    },
                    "googleCloudKmsConfig": {
                        "$ref": "#/types/mongodbatlas:index/EncryptionAtRestGoogleCloudKmsConfig:EncryptionAtRestGoogleCloudKmsConfig"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier for the project.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/eventTrigger:EventTrigger": {
            "description": "## # Resource: mongodbatlas.EventTrigger\n\n`mongodbatlas.EventTrigger` provides a Event Trigger resource. \n\nNote: If the `app_id` changes in the mongodbatlas.EventTrigger resource, it will force a replacement and delete itself from the old Atlas App Services app if it still exists then create itself in the new  Atlas App Services app. See [Atlas Triggers](https://www.mongodb.com/docs/atlas/app-services/triggers/) to learn more.   \n\n## Example Usage\n\n### S\n\n### Example Usage: Database Trigger with Function\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.EventTrigger(\"test\", {\n    projectId: \"PROJECT ID\",\n    appId: \"APPLICATION ID\",\n    name: \"NAME OF THE TRIGGER\",\n    type: \"DATABASE\",\n    functionId: \"FUNCTION ID\",\n    disabled: false,\n    configOperationTypes: [\n        \"INSERT\",\n        \"UPDATE\",\n    ],\n    configDatabase: \"DATABASE NAME\",\n    configCollection: \"COLLECTION NAME\",\n    configServiceId: \"SERVICE ID\",\n    configMatch: `{\n  \"updateDescription.updatedFields\": {\n    \"status\": \"blocked\"\n  }\n}\n`,\n    configProject: \"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\",\n    configFullDocument: false,\n    configFullDocumentBefore: false,\n    eventProcessors: {\n        awsEventbridge: {\n            configAccountId: \"AWS ACCOUNT ID\",\n            configRegion: \"AWS REGIOn\",\n        },\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.EventTrigger(\"test\",\n    project_id=\"PROJECT ID\",\n    app_id=\"APPLICATION ID\",\n    name=\"NAME OF THE TRIGGER\",\n    type=\"DATABASE\",\n    function_id=\"FUNCTION ID\",\n    disabled=False,\n    config_operation_types=[\n        \"INSERT\",\n        \"UPDATE\",\n    ],\n    config_database=\"DATABASE NAME\",\n    config_collection=\"COLLECTION NAME\",\n    config_service_id=\"SERVICE ID\",\n    config_match=\"\"\"{\n  \"updateDescription.updatedFields\": {\n    \"status\": \"blocked\"\n  }\n}\n\"\"\",\n    config_project=\"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\",\n    config_full_document=False,\n    config_full_document_before=False,\n    event_processors={\n        \"aws_eventbridge\": {\n            \"config_account_id\": \"AWS ACCOUNT ID\",\n            \"config_region\": \"AWS REGIOn\",\n        },\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.EventTrigger(\"test\", new()\n    {\n        ProjectId = \"PROJECT ID\",\n        AppId = \"APPLICATION ID\",\n        Name = \"NAME OF THE TRIGGER\",\n        Type = \"DATABASE\",\n        FunctionId = \"FUNCTION ID\",\n        Disabled = false,\n        ConfigOperationTypes = new[]\n        {\n            \"INSERT\",\n            \"UPDATE\",\n        },\n        ConfigDatabase = \"DATABASE NAME\",\n        ConfigCollection = \"COLLECTION NAME\",\n        ConfigServiceId = \"SERVICE ID\",\n        ConfigMatch = @\"{\n  \"\"updateDescription.updatedFields\"\": {\n    \"\"status\"\": \"\"blocked\"\"\n  }\n}\n\",\n        ConfigProject = \"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\",\n        ConfigFullDocument = false,\n        ConfigFullDocumentBefore = false,\n        EventProcessors = new Mongodbatlas.Inputs.EventTriggerEventProcessorsArgs\n        {\n            AwsEventbridge = new Mongodbatlas.Inputs.EventTriggerEventProcessorsAwsEventbridgeArgs\n            {\n                ConfigAccountId = \"AWS ACCOUNT ID\",\n                ConfigRegion = \"AWS REGIOn\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewEventTrigger(ctx, \"test\", \u0026mongodbatlas.EventTriggerArgs{\n\t\t\tProjectId:  pulumi.String(\"PROJECT ID\"),\n\t\t\tAppId:      pulumi.String(\"APPLICATION ID\"),\n\t\t\tName:       pulumi.String(\"NAME OF THE TRIGGER\"),\n\t\t\tType:       pulumi.String(\"DATABASE\"),\n\t\t\tFunctionId: pulumi.String(\"FUNCTION ID\"),\n\t\t\tDisabled:   pulumi.Bool(false),\n\t\t\tConfigOperationTypes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"INSERT\"),\n\t\t\t\tpulumi.String(\"UPDATE\"),\n\t\t\t},\n\t\t\tConfigDatabase:   pulumi.String(\"DATABASE NAME\"),\n\t\t\tConfigCollection: pulumi.String(\"COLLECTION NAME\"),\n\t\t\tConfigServiceId:  pulumi.String(\"SERVICE ID\"),\n\t\t\tConfigMatch: pulumi.String(`{\n  \"updateDescription.updatedFields\": {\n    \"status\": \"blocked\"\n  }\n}\n`),\n\t\t\tConfigProject:            pulumi.String(\"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\"),\n\t\t\tConfigFullDocument:       pulumi.Bool(false),\n\t\t\tConfigFullDocumentBefore: pulumi.Bool(false),\n\t\t\tEventProcessors: \u0026mongodbatlas.EventTriggerEventProcessorsArgs{\n\t\t\t\tAwsEventbridge: \u0026mongodbatlas.EventTriggerEventProcessorsAwsEventbridgeArgs{\n\t\t\t\t\tConfigAccountId: pulumi.String(\"AWS ACCOUNT ID\"),\n\t\t\t\t\tConfigRegion:    pulumi.String(\"AWS REGIOn\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.EventTrigger;\nimport com.pulumi.mongodbatlas.EventTriggerArgs;\nimport com.pulumi.mongodbatlas.inputs.EventTriggerEventProcessorsArgs;\nimport com.pulumi.mongodbatlas.inputs.EventTriggerEventProcessorsAwsEventbridgeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new EventTrigger(\"test\", EventTriggerArgs.builder()\n            .projectId(\"PROJECT ID\")\n            .appId(\"APPLICATION ID\")\n            .name(\"NAME OF THE TRIGGER\")\n            .type(\"DATABASE\")\n            .functionId(\"FUNCTION ID\")\n            .disabled(false)\n            .configOperationTypes(            \n                \"INSERT\",\n                \"UPDATE\")\n            .configDatabase(\"DATABASE NAME\")\n            .configCollection(\"COLLECTION NAME\")\n            .configServiceId(\"SERVICE ID\")\n            .configMatch(\"\"\"\n{\n  \"updateDescription.updatedFields\": {\n    \"status\": \"blocked\"\n  }\n}\n            \"\"\")\n            .configProject(\"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\")\n            .configFullDocument(false)\n            .configFullDocumentBefore(false)\n            .eventProcessors(EventTriggerEventProcessorsArgs.builder()\n                .awsEventbridge(EventTriggerEventProcessorsAwsEventbridgeArgs.builder()\n                    .configAccountId(\"AWS ACCOUNT ID\")\n                    .configRegion(\"AWS REGIOn\")\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:EventTrigger\n    properties:\n      projectId: PROJECT ID\n      appId: APPLICATION ID\n      name: NAME OF THE TRIGGER\n      type: DATABASE\n      functionId: FUNCTION ID\n      disabled: false\n      configOperationTypes:\n        - INSERT\n        - UPDATE\n      configDatabase: DATABASE NAME\n      configCollection: COLLECTION NAME\n      configServiceId: SERVICE ID\n      configMatch: |\n        {\n          \"updateDescription.updatedFields\": {\n            \"status\": \"blocked\"\n          }\n        }\n      configProject: '{\"updateDescription.updatedFields\":{\"status\":\"blocked\"}}'\n      configFullDocument: false\n      configFullDocumentBefore: false\n      eventProcessors:\n        awsEventbridge:\n          configAccountId: AWS ACCOUNT ID\n          configRegion: AWS REGIOn\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example Usage: Database Trigger with EventBridge\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.EventTrigger(\"test\", {\n    projectId: \"PROJECT ID\",\n    appId: \"APPLICATION ID\",\n    name: \"NAME OF THE TRIGGER\",\n    type: \"DATABASE\",\n    disabled: false,\n    unordered: false,\n    configOperationTypes: [\n        \"INSERT\",\n        \"UPDATE\",\n    ],\n    configOperationType: \"LOGIN\",\n    configProviders: [\"anon-user\"],\n    configDatabase: \"DATABASE NAME\",\n    configCollection: \"COLLECTION NAME\",\n    configServiceId: \"1\",\n    configMatch: \"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\",\n    configProject: \"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\",\n    configFullDocument: false,\n    configFullDocumentBefore: false,\n    configSchedule: \"*\",\n    eventProcessors: {\n        awsEventbridge: {\n            configAccountId: \"AWS ACCOUNT ID\",\n            configRegion: \"AWS REGIOn\",\n        },\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.EventTrigger(\"test\",\n    project_id=\"PROJECT ID\",\n    app_id=\"APPLICATION ID\",\n    name=\"NAME OF THE TRIGGER\",\n    type=\"DATABASE\",\n    disabled=False,\n    unordered=False,\n    config_operation_types=[\n        \"INSERT\",\n        \"UPDATE\",\n    ],\n    config_operation_type=\"LOGIN\",\n    config_providers=[\"anon-user\"],\n    config_database=\"DATABASE NAME\",\n    config_collection=\"COLLECTION NAME\",\n    config_service_id=\"1\",\n    config_match=\"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\",\n    config_project=\"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\",\n    config_full_document=False,\n    config_full_document_before=False,\n    config_schedule=\"*\",\n    event_processors={\n        \"aws_eventbridge\": {\n            \"config_account_id\": \"AWS ACCOUNT ID\",\n            \"config_region\": \"AWS REGIOn\",\n        },\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.EventTrigger(\"test\", new()\n    {\n        ProjectId = \"PROJECT ID\",\n        AppId = \"APPLICATION ID\",\n        Name = \"NAME OF THE TRIGGER\",\n        Type = \"DATABASE\",\n        Disabled = false,\n        Unordered = false,\n        ConfigOperationTypes = new[]\n        {\n            \"INSERT\",\n            \"UPDATE\",\n        },\n        ConfigOperationType = \"LOGIN\",\n        ConfigProviders = new[]\n        {\n            \"anon-user\",\n        },\n        ConfigDatabase = \"DATABASE NAME\",\n        ConfigCollection = \"COLLECTION NAME\",\n        ConfigServiceId = \"1\",\n        ConfigMatch = \"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\",\n        ConfigProject = \"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\",\n        ConfigFullDocument = false,\n        ConfigFullDocumentBefore = false,\n        ConfigSchedule = \"*\",\n        EventProcessors = new Mongodbatlas.Inputs.EventTriggerEventProcessorsArgs\n        {\n            AwsEventbridge = new Mongodbatlas.Inputs.EventTriggerEventProcessorsAwsEventbridgeArgs\n            {\n                ConfigAccountId = \"AWS ACCOUNT ID\",\n                ConfigRegion = \"AWS REGIOn\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewEventTrigger(ctx, \"test\", \u0026mongodbatlas.EventTriggerArgs{\n\t\t\tProjectId: pulumi.String(\"PROJECT ID\"),\n\t\t\tAppId:     pulumi.String(\"APPLICATION ID\"),\n\t\t\tName:      pulumi.String(\"NAME OF THE TRIGGER\"),\n\t\t\tType:      pulumi.String(\"DATABASE\"),\n\t\t\tDisabled:  pulumi.Bool(false),\n\t\t\tUnordered: pulumi.Bool(false),\n\t\t\tConfigOperationTypes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"INSERT\"),\n\t\t\t\tpulumi.String(\"UPDATE\"),\n\t\t\t},\n\t\t\tConfigOperationType: pulumi.String(\"LOGIN\"),\n\t\t\tConfigProviders: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"anon-user\"),\n\t\t\t},\n\t\t\tConfigDatabase:           pulumi.String(\"DATABASE NAME\"),\n\t\t\tConfigCollection:         pulumi.String(\"COLLECTION NAME\"),\n\t\t\tConfigServiceId:          pulumi.String(\"1\"),\n\t\t\tConfigMatch:              pulumi.String(\"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\"),\n\t\t\tConfigProject:            pulumi.String(\"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\"),\n\t\t\tConfigFullDocument:       pulumi.Bool(false),\n\t\t\tConfigFullDocumentBefore: pulumi.Bool(false),\n\t\t\tConfigSchedule:           pulumi.String(\"*\"),\n\t\t\tEventProcessors: \u0026mongodbatlas.EventTriggerEventProcessorsArgs{\n\t\t\t\tAwsEventbridge: \u0026mongodbatlas.EventTriggerEventProcessorsAwsEventbridgeArgs{\n\t\t\t\t\tConfigAccountId: pulumi.String(\"AWS ACCOUNT ID\"),\n\t\t\t\t\tConfigRegion:    pulumi.String(\"AWS REGIOn\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.EventTrigger;\nimport com.pulumi.mongodbatlas.EventTriggerArgs;\nimport com.pulumi.mongodbatlas.inputs.EventTriggerEventProcessorsArgs;\nimport com.pulumi.mongodbatlas.inputs.EventTriggerEventProcessorsAwsEventbridgeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new EventTrigger(\"test\", EventTriggerArgs.builder()\n            .projectId(\"PROJECT ID\")\n            .appId(\"APPLICATION ID\")\n            .name(\"NAME OF THE TRIGGER\")\n            .type(\"DATABASE\")\n            .disabled(false)\n            .unordered(false)\n            .configOperationTypes(            \n                \"INSERT\",\n                \"UPDATE\")\n            .configOperationType(\"LOGIN\")\n            .configProviders(\"anon-user\")\n            .configDatabase(\"DATABASE NAME\")\n            .configCollection(\"COLLECTION NAME\")\n            .configServiceId(\"1\")\n            .configMatch(\"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\")\n            .configProject(\"{\\\"updateDescription.updatedFields\\\":{\\\"status\\\":\\\"blocked\\\"}}\")\n            .configFullDocument(false)\n            .configFullDocumentBefore(false)\n            .configSchedule(\"*\")\n            .eventProcessors(EventTriggerEventProcessorsArgs.builder()\n                .awsEventbridge(EventTriggerEventProcessorsAwsEventbridgeArgs.builder()\n                    .configAccountId(\"AWS ACCOUNT ID\")\n                    .configRegion(\"AWS REGIOn\")\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:EventTrigger\n    properties:\n      projectId: PROJECT ID\n      appId: APPLICATION ID\n      name: NAME OF THE TRIGGER\n      type: DATABASE\n      disabled: false\n      unordered: false\n      configOperationTypes:\n        - INSERT\n        - UPDATE\n      configOperationType: LOGIN\n      configProviders:\n        - anon-user\n      configDatabase: DATABASE NAME\n      configCollection: COLLECTION NAME\n      configServiceId: '1'\n      configMatch: '{\"updateDescription.updatedFields\":{\"status\":\"blocked\"}}'\n      configProject: '{\"updateDescription.updatedFields\":{\"status\":\"blocked\"}}'\n      configFullDocument: false\n      configFullDocumentBefore: false\n      configSchedule: '*'\n      eventProcessors:\n        awsEventbridge:\n          configAccountId: AWS ACCOUNT ID\n          configRegion: AWS REGIOn\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example Usage: Authentication Trigger\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.EventTrigger(\"test\", {\n    projectId: \"PROJECT ID\",\n    appId: \"APPLICATION ID\",\n    name: \"NAME OF THE TRIGGER\",\n    type: \"AUTHENTICATION\",\n    functionId: \"1\",\n    disabled: false,\n    configOperationType: \"LOGIN\",\n    configProviders: [\"anon-user\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.EventTrigger(\"test\",\n    project_id=\"PROJECT ID\",\n    app_id=\"APPLICATION ID\",\n    name=\"NAME OF THE TRIGGER\",\n    type=\"AUTHENTICATION\",\n    function_id=\"1\",\n    disabled=False,\n    config_operation_type=\"LOGIN\",\n    config_providers=[\"anon-user\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.EventTrigger(\"test\", new()\n    {\n        ProjectId = \"PROJECT ID\",\n        AppId = \"APPLICATION ID\",\n        Name = \"NAME OF THE TRIGGER\",\n        Type = \"AUTHENTICATION\",\n        FunctionId = \"1\",\n        Disabled = false,\n        ConfigOperationType = \"LOGIN\",\n        ConfigProviders = new[]\n        {\n            \"anon-user\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewEventTrigger(ctx, \"test\", \u0026mongodbatlas.EventTriggerArgs{\n\t\t\tProjectId:           pulumi.String(\"PROJECT ID\"),\n\t\t\tAppId:               pulumi.String(\"APPLICATION ID\"),\n\t\t\tName:                pulumi.String(\"NAME OF THE TRIGGER\"),\n\t\t\tType:                pulumi.String(\"AUTHENTICATION\"),\n\t\t\tFunctionId:          pulumi.String(\"1\"),\n\t\t\tDisabled:            pulumi.Bool(false),\n\t\t\tConfigOperationType: pulumi.String(\"LOGIN\"),\n\t\t\tConfigProviders: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"anon-user\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.EventTrigger;\nimport com.pulumi.mongodbatlas.EventTriggerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new EventTrigger(\"test\", EventTriggerArgs.builder()\n            .projectId(\"PROJECT ID\")\n            .appId(\"APPLICATION ID\")\n            .name(\"NAME OF THE TRIGGER\")\n            .type(\"AUTHENTICATION\")\n            .functionId(\"1\")\n            .disabled(false)\n            .configOperationType(\"LOGIN\")\n            .configProviders(\"anon-user\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:EventTrigger\n    properties:\n      projectId: PROJECT ID\n      appId: APPLICATION ID\n      name: NAME OF THE TRIGGER\n      type: AUTHENTICATION\n      functionId: '1'\n      disabled: false\n      configOperationType: LOGIN\n      configProviders:\n        - anon-user\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example Usage: Scheduled Trigger\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.EventTrigger(\"test\", {\n    projectId: \"PROJECT ID\",\n    appId: \"APPLICATION ID\",\n    name: \"NAME OF THE TRIGGER\",\n    type: \"SCHEDULED\",\n    functionId: \"1\",\n    disabled: false,\n    configSchedule: \"*\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.EventTrigger(\"test\",\n    project_id=\"PROJECT ID\",\n    app_id=\"APPLICATION ID\",\n    name=\"NAME OF THE TRIGGER\",\n    type=\"SCHEDULED\",\n    function_id=\"1\",\n    disabled=False,\n    config_schedule=\"*\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.EventTrigger(\"test\", new()\n    {\n        ProjectId = \"PROJECT ID\",\n        AppId = \"APPLICATION ID\",\n        Name = \"NAME OF THE TRIGGER\",\n        Type = \"SCHEDULED\",\n        FunctionId = \"1\",\n        Disabled = false,\n        ConfigSchedule = \"*\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewEventTrigger(ctx, \"test\", \u0026mongodbatlas.EventTriggerArgs{\n\t\t\tProjectId:      pulumi.String(\"PROJECT ID\"),\n\t\t\tAppId:          pulumi.String(\"APPLICATION ID\"),\n\t\t\tName:           pulumi.String(\"NAME OF THE TRIGGER\"),\n\t\t\tType:           pulumi.String(\"SCHEDULED\"),\n\t\t\tFunctionId:     pulumi.String(\"1\"),\n\t\t\tDisabled:       pulumi.Bool(false),\n\t\t\tConfigSchedule: pulumi.String(\"*\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.EventTrigger;\nimport com.pulumi.mongodbatlas.EventTriggerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new EventTrigger(\"test\", EventTriggerArgs.builder()\n            .projectId(\"PROJECT ID\")\n            .appId(\"APPLICATION ID\")\n            .name(\"NAME OF THE TRIGGER\")\n            .type(\"SCHEDULED\")\n            .functionId(\"1\")\n            .disabled(false)\n            .configSchedule(\"*\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:EventTrigger\n    properties:\n      projectId: PROJECT ID\n      appId: APPLICATION ID\n      name: NAME OF THE TRIGGER\n      type: SCHEDULED\n      functionId: '1'\n      disabled: false\n      configSchedule: '*'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nEvent trigger can be imported using project ID, App ID and Trigger ID, in the format `project_id`--`app_id`-`trigger_id`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/eventTrigger:EventTrigger test 1112222b3bf99403840e8934--testing-example--1112222b3bf99403840e8934\n```\nFor more details on this resource see [Triggers resource](https://www.mongodb.com/docs/atlas/app-services/admin/api/v3/#tag/triggers) in Atlas App Services Documentation.\n\n",
            "properties": {
                "appId": {
                    "type": "string",
                    "description": "The ObjectID of your application.\n* For more details on `project_id` and `app_id` see: https://www.mongodb.com/docs/atlas/app-services/admin/api/v3/#section/Project-and-Application-IDs\n"
                },
                "configCollection": {
                    "type": "string",
                    "description": "Optional for `DATABASE` type. The name of the MongoDB collection that the trigger watches for change events. The collection must be part of the specified database.\n"
                },
                "configDatabase": {
                    "type": "string",
                    "description": "Required for `DATABASE` type. The name of the MongoDB database to watch.\n"
                },
                "configFullDocument": {
                    "type": "boolean",
                    "description": "Optional for `DATABASE` type. If true, indicates that `UPDATE` change events should include the most current [majority-committed](https://docs.mongodb.com/manual/reference/read-concern-majority/) version of the modified document in the fullDocument field.\n"
                },
                "configFullDocumentBefore": {
                    "type": "boolean"
                },
                "configMatch": {
                    "type": "string",
                    "description": "Optional for `DATABASE` type. A [$match](https://docs.mongodb.com/manual/reference/operator/aggregation/match/) expression document that MongoDB Realm includes in the underlying change stream pipeline for the trigger. This is useful when you want to filter change events beyond their operation type. The trigger will only fire if the expression evaluates to true for a given change event.\n"
                },
                "configOperationType": {
                    "type": "string",
                    "description": "Required for `AUTHENTICATION` type. The [authentication operation type](https://docs.mongodb.com/realm/triggers/authentication-triggers/#std-label-authentication-event-operation-types) to listen for. Possible Values: `LOGIN`, `CREATE`, `DELETE`\n"
                },
                "configOperationTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Required for `DATABASE` type. The [database event operation types](https://docs.mongodb.com/realm/triggers/database-triggers/#std-label-database-events) to listen for. This must contain at least one value. Possible Values: `INSERT`, `UPDATE`, `REPLACE`, `DELETE`\n"
                },
                "configProject": {
                    "type": "string",
                    "description": "Optional for `DATABASE` type. A [$project](https://docs.mongodb.com/manual/reference/operator/aggregation/project/) expression document that Realm uses to filter the fields that appear in change event objects.\n"
                },
                "configProviders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Required for `AUTHENTICATION` type. A list of one or more [authentication provider](https://docs.mongodb.com/realm/authentication/providers/) id values. The trigger will only listen for authentication events produced by these providers.\n"
                },
                "configSchedule": {
                    "type": "string",
                    "description": "Required for `SCHEDULED` type. A [cron expression](https://docs.mongodb.com/realm/triggers/cron-expressions/) that defines the trigger schedule.\n"
                },
                "configScheduleType": {
                    "type": "string"
                },
                "configServiceId": {
                    "type": "string",
                    "description": "Required for `DATABASE` type. The ID of the MongoDB Service associated with the trigger.\n"
                },
                "disabled": {
                    "type": "boolean",
                    "description": "Default: `false` If `true`, the trigger is disabled.\n"
                },
                "eventProcessors": {
                    "$ref": "#/types/mongodbatlas:index/EventTriggerEventProcessors:EventTriggerEventProcessors",
                    "description": "An object where each field name is an event processor ID and each value is an object that configures its corresponding event processor. The following event processors are supported: `AWS_EVENTBRIDGE` For an example configuration object, see [Send Trigger Events to AWS EventBridge](https://docs.mongodb.com/realm/triggers/eventbridge/#std-label-event_processor_example).\n* `event_processors.0.aws_eventbridge.config_account_id` - (Optional) AWS Account ID.\n* `event_processors.0.aws_eventbridge.config_region` - (Optional) Region of AWS Account.\n"
                },
                "functionId": {
                    "type": "string",
                    "description": "The ID of the function associated with the trigger.\n"
                },
                "functionName": {
                    "type": "string",
                    "description": "The name of the function associated with the trigger.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the trigger.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create the trigger.\n"
                },
                "triggerId": {
                    "type": "string",
                    "description": "The unique ID of the trigger.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the trigger. Possible Values: `DATABASE`, `AUTHENTICATION`,`SCHEDULED`\n"
                },
                "unordered": {
                    "type": "boolean",
                    "description": "Only Available for Database Triggers. If true, event ordering is disabled and this trigger can process events in parallel. If false, event ordering is enabled and the trigger executes serially.\n"
                }
            },
            "required": [
                "appId",
                "configCollection",
                "configDatabase",
                "configFullDocument",
                "configFullDocumentBefore",
                "configMatch",
                "configOperationType",
                "configOperationTypes",
                "configProject",
                "configProviders",
                "configSchedule",
                "configScheduleType",
                "configServiceId",
                "disabled",
                "functionName",
                "name",
                "projectId",
                "triggerId",
                "type",
                "unordered"
            ],
            "inputProperties": {
                "appId": {
                    "type": "string",
                    "description": "The ObjectID of your application.\n* For more details on `project_id` and `app_id` see: https://www.mongodb.com/docs/atlas/app-services/admin/api/v3/#section/Project-and-Application-IDs\n",
                    "willReplaceOnChanges": true
                },
                "configCollection": {
                    "type": "string",
                    "description": "Optional for `DATABASE` type. The name of the MongoDB collection that the trigger watches for change events. The collection must be part of the specified database.\n"
                },
                "configDatabase": {
                    "type": "string",
                    "description": "Required for `DATABASE` type. The name of the MongoDB database to watch.\n"
                },
                "configFullDocument": {
                    "type": "boolean",
                    "description": "Optional for `DATABASE` type. If true, indicates that `UPDATE` change events should include the most current [majority-committed](https://docs.mongodb.com/manual/reference/read-concern-majority/) version of the modified document in the fullDocument field.\n"
                },
                "configFullDocumentBefore": {
                    "type": "boolean"
                },
                "configMatch": {
                    "type": "string",
                    "description": "Optional for `DATABASE` type. A [$match](https://docs.mongodb.com/manual/reference/operator/aggregation/match/) expression document that MongoDB Realm includes in the underlying change stream pipeline for the trigger. This is useful when you want to filter change events beyond their operation type. The trigger will only fire if the expression evaluates to true for a given change event.\n"
                },
                "configOperationType": {
                    "type": "string",
                    "description": "Required for `AUTHENTICATION` type. The [authentication operation type](https://docs.mongodb.com/realm/triggers/authentication-triggers/#std-label-authentication-event-operation-types) to listen for. Possible Values: `LOGIN`, `CREATE`, `DELETE`\n"
                },
                "configOperationTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Required for `DATABASE` type. The [database event operation types](https://docs.mongodb.com/realm/triggers/database-triggers/#std-label-database-events) to listen for. This must contain at least one value. Possible Values: `INSERT`, `UPDATE`, `REPLACE`, `DELETE`\n"
                },
                "configProject": {
                    "type": "string",
                    "description": "Optional for `DATABASE` type. A [$project](https://docs.mongodb.com/manual/reference/operator/aggregation/project/) expression document that Realm uses to filter the fields that appear in change event objects.\n"
                },
                "configProviders": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Required for `AUTHENTICATION` type. A list of one or more [authentication provider](https://docs.mongodb.com/realm/authentication/providers/) id values. The trigger will only listen for authentication events produced by these providers.\n"
                },
                "configSchedule": {
                    "type": "string",
                    "description": "Required for `SCHEDULED` type. A [cron expression](https://docs.mongodb.com/realm/triggers/cron-expressions/) that defines the trigger schedule.\n"
                },
                "configServiceId": {
                    "type": "string",
                    "description": "Required for `DATABASE` type. The ID of the MongoDB Service associated with the trigger.\n"
                },
                "disabled": {
                    "type": "boolean",
                    "description": "Default: `false` If `true`, the trigger is disabled.\n"
                },
                "eventProcessors": {
                    "$ref": "#/types/mongodbatlas:index/EventTriggerEventProcessors:EventTriggerEventProcessors",
                    "description": "An object where each field name is an event processor ID and each value is an object that configures its corresponding event processor. The following event processors are supported: `AWS_EVENTBRIDGE` For an example configuration object, see [Send Trigger Events to AWS EventBridge](https://docs.mongodb.com/realm/triggers/eventbridge/#std-label-event_processor_example).\n* `event_processors.0.aws_eventbridge.config_account_id` - (Optional) AWS Account ID.\n* `event_processors.0.aws_eventbridge.config_region` - (Optional) Region of AWS Account.\n"
                },
                "functionId": {
                    "type": "string",
                    "description": "The ID of the function associated with the trigger.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the trigger.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create the trigger.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the trigger. Possible Values: `DATABASE`, `AUTHENTICATION`,`SCHEDULED`\n"
                },
                "unordered": {
                    "type": "boolean",
                    "description": "Only Available for Database Triggers. If true, event ordering is disabled and this trigger can process events in parallel. If false, event ordering is enabled and the trigger executes serially.\n"
                }
            },
            "requiredInputs": [
                "appId",
                "projectId",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering EventTrigger resources.\n",
                "properties": {
                    "appId": {
                        "type": "string",
                        "description": "The ObjectID of your application.\n* For more details on `project_id` and `app_id` see: https://www.mongodb.com/docs/atlas/app-services/admin/api/v3/#section/Project-and-Application-IDs\n",
                        "willReplaceOnChanges": true
                    },
                    "configCollection": {
                        "type": "string",
                        "description": "Optional for `DATABASE` type. The name of the MongoDB collection that the trigger watches for change events. The collection must be part of the specified database.\n"
                    },
                    "configDatabase": {
                        "type": "string",
                        "description": "Required for `DATABASE` type. The name of the MongoDB database to watch.\n"
                    },
                    "configFullDocument": {
                        "type": "boolean",
                        "description": "Optional for `DATABASE` type. If true, indicates that `UPDATE` change events should include the most current [majority-committed](https://docs.mongodb.com/manual/reference/read-concern-majority/) version of the modified document in the fullDocument field.\n"
                    },
                    "configFullDocumentBefore": {
                        "type": "boolean"
                    },
                    "configMatch": {
                        "type": "string",
                        "description": "Optional for `DATABASE` type. A [$match](https://docs.mongodb.com/manual/reference/operator/aggregation/match/) expression document that MongoDB Realm includes in the underlying change stream pipeline for the trigger. This is useful when you want to filter change events beyond their operation type. The trigger will only fire if the expression evaluates to true for a given change event.\n"
                    },
                    "configOperationType": {
                        "type": "string",
                        "description": "Required for `AUTHENTICATION` type. The [authentication operation type](https://docs.mongodb.com/realm/triggers/authentication-triggers/#std-label-authentication-event-operation-types) to listen for. Possible Values: `LOGIN`, `CREATE`, `DELETE`\n"
                    },
                    "configOperationTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Required for `DATABASE` type. The [database event operation types](https://docs.mongodb.com/realm/triggers/database-triggers/#std-label-database-events) to listen for. This must contain at least one value. Possible Values: `INSERT`, `UPDATE`, `REPLACE`, `DELETE`\n"
                    },
                    "configProject": {
                        "type": "string",
                        "description": "Optional for `DATABASE` type. A [$project](https://docs.mongodb.com/manual/reference/operator/aggregation/project/) expression document that Realm uses to filter the fields that appear in change event objects.\n"
                    },
                    "configProviders": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Required for `AUTHENTICATION` type. A list of one or more [authentication provider](https://docs.mongodb.com/realm/authentication/providers/) id values. The trigger will only listen for authentication events produced by these providers.\n"
                    },
                    "configSchedule": {
                        "type": "string",
                        "description": "Required for `SCHEDULED` type. A [cron expression](https://docs.mongodb.com/realm/triggers/cron-expressions/) that defines the trigger schedule.\n"
                    },
                    "configScheduleType": {
                        "type": "string"
                    },
                    "configServiceId": {
                        "type": "string",
                        "description": "Required for `DATABASE` type. The ID of the MongoDB Service associated with the trigger.\n"
                    },
                    "disabled": {
                        "type": "boolean",
                        "description": "Default: `false` If `true`, the trigger is disabled.\n"
                    },
                    "eventProcessors": {
                        "$ref": "#/types/mongodbatlas:index/EventTriggerEventProcessors:EventTriggerEventProcessors",
                        "description": "An object where each field name is an event processor ID and each value is an object that configures its corresponding event processor. The following event processors are supported: `AWS_EVENTBRIDGE` For an example configuration object, see [Send Trigger Events to AWS EventBridge](https://docs.mongodb.com/realm/triggers/eventbridge/#std-label-event_processor_example).\n* `event_processors.0.aws_eventbridge.config_account_id` - (Optional) AWS Account ID.\n* `event_processors.0.aws_eventbridge.config_region` - (Optional) Region of AWS Account.\n"
                    },
                    "functionId": {
                        "type": "string",
                        "description": "The ID of the function associated with the trigger.\n"
                    },
                    "functionName": {
                        "type": "string",
                        "description": "The name of the function associated with the trigger.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the trigger.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the trigger.\n"
                    },
                    "triggerId": {
                        "type": "string",
                        "description": "The unique ID of the trigger.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of the trigger. Possible Values: `DATABASE`, `AUTHENTICATION`,`SCHEDULED`\n"
                    },
                    "unordered": {
                        "type": "boolean",
                        "description": "Only Available for Database Triggers. If true, event ordering is disabled and this trigger can process events in parallel. If false, event ordering is enabled and the trigger executes serially.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/federatedDatabaseInstance:FederatedDatabaseInstance": {
            "description": "## # Resource: mongodbatlas.FederatedDatabaseInstance\n\n`mongodbatlas.FederatedDatabaseInstance` provides a Federated Database Instance resource.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n## Example Usage\n\n### S With MongoDB Atlas Cluster As Storage Database\n\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.FederatedDatabaseInstance(\"test\", {\n    projectId: \"PROJECT ID\",\n    name: \"TENANT NAME OF THE FEDERATED DATABASE INSTANCE\",\n    storageDatabases: [{\n        name: \"VirtualDatabase0\",\n        collections: [{\n            name: \"NAME OF THE COLLECTION\",\n            dataSources: [{\n                collection: \"COLLECTION IN THE CLUSTER\",\n                database: \"DB IN THE CLUSTER\",\n                storeName: \"CLUSTER NAME\",\n            }],\n        }],\n    }],\n    storageStores: [{\n        name: \"STORE 1 NAME\",\n        clusterName: \"CLUSTER NAME\",\n        projectId: \"PROJECT ID\",\n        provider: \"atlas\",\n        readPreference: {\n            mode: \"secondary\",\n        },\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.FederatedDatabaseInstance(\"test\",\n    project_id=\"PROJECT ID\",\n    name=\"TENANT NAME OF THE FEDERATED DATABASE INSTANCE\",\n    storage_databases=[{\n        \"name\": \"VirtualDatabase0\",\n        \"collections\": [{\n            \"name\": \"NAME OF THE COLLECTION\",\n            \"data_sources\": [{\n                \"collection\": \"COLLECTION IN THE CLUSTER\",\n                \"database\": \"DB IN THE CLUSTER\",\n                \"store_name\": \"CLUSTER NAME\",\n            }],\n        }],\n    }],\n    storage_stores=[{\n        \"name\": \"STORE 1 NAME\",\n        \"cluster_name\": \"CLUSTER NAME\",\n        \"project_id\": \"PROJECT ID\",\n        \"provider\": \"atlas\",\n        \"read_preference\": {\n            \"mode\": \"secondary\",\n        },\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.FederatedDatabaseInstance(\"test\", new()\n    {\n        ProjectId = \"PROJECT ID\",\n        Name = \"TENANT NAME OF THE FEDERATED DATABASE INSTANCE\",\n        StorageDatabases = new[]\n        {\n            new Mongodbatlas.Inputs.FederatedDatabaseInstanceStorageDatabaseArgs\n            {\n                Name = \"VirtualDatabase0\",\n                Collections = new[]\n                {\n                    new Mongodbatlas.Inputs.FederatedDatabaseInstanceStorageDatabaseCollectionArgs\n                    {\n                        Name = \"NAME OF THE COLLECTION\",\n                        DataSources = new[]\n                        {\n                            new Mongodbatlas.Inputs.FederatedDatabaseInstanceStorageDatabaseCollectionDataSourceArgs\n                            {\n                                Collection = \"COLLECTION IN THE CLUSTER\",\n                                Database = \"DB IN THE CLUSTER\",\n                                StoreName = \"CLUSTER NAME\",\n                            },\n                        },\n                    },\n                },\n            },\n        },\n        StorageStores = new[]\n        {\n            new Mongodbatlas.Inputs.FederatedDatabaseInstanceStorageStoreArgs\n            {\n                Name = \"STORE 1 NAME\",\n                ClusterName = \"CLUSTER NAME\",\n                ProjectId = \"PROJECT ID\",\n                Provider = \"atlas\",\n                ReadPreference = new Mongodbatlas.Inputs.FederatedDatabaseInstanceStorageStoreReadPreferenceArgs\n                {\n                    Mode = \"secondary\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewFederatedDatabaseInstance(ctx, \"test\", \u0026mongodbatlas.FederatedDatabaseInstanceArgs{\n\t\t\tProjectId: pulumi.String(\"PROJECT ID\"),\n\t\t\tName:      pulumi.String(\"TENANT NAME OF THE FEDERATED DATABASE INSTANCE\"),\n\t\t\tStorageDatabases: mongodbatlas.FederatedDatabaseInstanceStorageDatabaseArray{\n\t\t\t\t\u0026mongodbatlas.FederatedDatabaseInstanceStorageDatabaseArgs{\n\t\t\t\t\tName: pulumi.String(\"VirtualDatabase0\"),\n\t\t\t\t\tCollections: mongodbatlas.FederatedDatabaseInstanceStorageDatabaseCollectionArray{\n\t\t\t\t\t\t\u0026mongodbatlas.FederatedDatabaseInstanceStorageDatabaseCollectionArgs{\n\t\t\t\t\t\t\tName: pulumi.String(\"NAME OF THE COLLECTION\"),\n\t\t\t\t\t\t\tDataSources: mongodbatlas.FederatedDatabaseInstanceStorageDatabaseCollectionDataSourceArray{\n\t\t\t\t\t\t\t\t\u0026mongodbatlas.FederatedDatabaseInstanceStorageDatabaseCollectionDataSourceArgs{\n\t\t\t\t\t\t\t\t\tCollection: pulumi.String(\"COLLECTION IN THE CLUSTER\"),\n\t\t\t\t\t\t\t\t\tDatabase:   pulumi.String(\"DB IN THE CLUSTER\"),\n\t\t\t\t\t\t\t\t\tStoreName:  pulumi.String(\"CLUSTER NAME\"),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tStorageStores: mongodbatlas.FederatedDatabaseInstanceStorageStoreArray{\n\t\t\t\t\u0026mongodbatlas.FederatedDatabaseInstanceStorageStoreArgs{\n\t\t\t\t\tName:        pulumi.String(\"STORE 1 NAME\"),\n\t\t\t\t\tClusterName: pulumi.String(\"CLUSTER NAME\"),\n\t\t\t\t\tProjectId:   pulumi.String(\"PROJECT ID\"),\n\t\t\t\t\tProvider:    pulumi.String(\"atlas\"),\n\t\t\t\t\tReadPreference: \u0026mongodbatlas.FederatedDatabaseInstanceStorageStoreReadPreferenceArgs{\n\t\t\t\t\t\tMode: pulumi.String(\"secondary\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.FederatedDatabaseInstance;\nimport com.pulumi.mongodbatlas.FederatedDatabaseInstanceArgs;\nimport com.pulumi.mongodbatlas.inputs.FederatedDatabaseInstanceStorageDatabaseArgs;\nimport com.pulumi.mongodbatlas.inputs.FederatedDatabaseInstanceStorageStoreArgs;\nimport com.pulumi.mongodbatlas.inputs.FederatedDatabaseInstanceStorageStoreReadPreferenceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new FederatedDatabaseInstance(\"test\", FederatedDatabaseInstanceArgs.builder()\n            .projectId(\"PROJECT ID\")\n            .name(\"TENANT NAME OF THE FEDERATED DATABASE INSTANCE\")\n            .storageDatabases(FederatedDatabaseInstanceStorageDatabaseArgs.builder()\n                .name(\"VirtualDatabase0\")\n                .collections(FederatedDatabaseInstanceStorageDatabaseCollectionArgs.builder()\n                    .name(\"NAME OF THE COLLECTION\")\n                    .dataSources(FederatedDatabaseInstanceStorageDatabaseCollectionDataSourceArgs.builder()\n                        .collection(\"COLLECTION IN THE CLUSTER\")\n                        .database(\"DB IN THE CLUSTER\")\n                        .storeName(\"CLUSTER NAME\")\n                        .build())\n                    .build())\n                .build())\n            .storageStores(FederatedDatabaseInstanceStorageStoreArgs.builder()\n                .name(\"STORE 1 NAME\")\n                .clusterName(\"CLUSTER NAME\")\n                .projectId(\"PROJECT ID\")\n                .provider(\"atlas\")\n                .readPreference(FederatedDatabaseInstanceStorageStoreReadPreferenceArgs.builder()\n                    .mode(\"secondary\")\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:FederatedDatabaseInstance\n    properties:\n      projectId: PROJECT ID\n      name: TENANT NAME OF THE FEDERATED DATABASE INSTANCE\n      storageDatabases:\n        - name: VirtualDatabase0\n          collections:\n            - name: NAME OF THE COLLECTION\n              dataSources:\n                - collection: COLLECTION IN THE CLUSTER\n                  database: DB IN THE CLUSTER\n                  storeName: CLUSTER NAME\n      storageStores:\n        - name: STORE 1 NAME\n          clusterName: CLUSTER NAME\n          projectId: PROJECT ID\n          provider: atlas\n          readPreference:\n            mode: secondary\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### S With Amazon S3 Bucket As Storage Database\n\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.FederatedDatabaseInstance(\"test\", {\n    projectId: \"PROJECT ID\",\n    name: \"TENANT NAME OF THE FEDERATED DATABASE INSTANCE\",\n    cloudProviderConfig: {\n        aws: {\n            roleId: \"AWS ROLE ID\",\n            testS3Bucket: \"S3 BUCKET NAME\",\n        },\n    },\n    storageDatabases: [{\n        name: \"VirtualDatabase0\",\n        collections: [{\n            name: \"NAME OF THE COLLECTION\",\n            dataSources: [\n                {\n                    collection: \"COLLECTION IN THE CLUSTER\",\n                    database: \"DB IN THE CLUSTER\",\n                    storeName: \"CLUSTER NAME\",\n                },\n                {\n                    storeName: \"S3 BUCKET NAME\",\n                    path: \"S3 BUCKET PATH\",\n                },\n            ],\n        }],\n    }],\n    storageStores: [\n        {\n            name: \"STORE 1 NAME\",\n            clusterName: \"CLUSTER NAME\",\n            projectId: \"PROJECT ID\",\n            provider: \"atlas\",\n            readPreference: {\n                mode: \"secondary\",\n            },\n        },\n        {\n            bucket: \"STORE 2 NAME\",\n            delimiter: \"/\",\n            name: \"S3 BUCKET NAME\",\n            prefix: \"S3 BUCKET PREFIX\",\n            provider: \"s3\",\n            region: \"AWS REGION\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.FederatedDatabaseInstance(\"test\",\n    project_id=\"PROJECT ID\",\n    name=\"TENANT NAME OF THE FEDERATED DATABASE INSTANCE\",\n    cloud_provider_config={\n        \"aws\": {\n            \"role_id\": \"AWS ROLE ID\",\n            \"test_s3_bucket\": \"S3 BUCKET NAME\",\n        },\n    },\n    storage_databases=[{\n        \"name\": \"VirtualDatabase0\",\n        \"collections\": [{\n            \"name\": \"NAME OF THE COLLECTION\",\n            \"data_sources\": [\n                {\n                    \"collection\": \"COLLECTION IN THE CLUSTER\",\n                    \"database\": \"DB IN THE CLUSTER\",\n                    \"store_name\": \"CLUSTER NAME\",\n                },\n                {\n                    \"store_name\": \"S3 BUCKET NAME\",\n                    \"path\": \"S3 BUCKET PATH\",\n                },\n            ],\n        }],\n    }],\n    storage_stores=[\n        {\n            \"name\": \"STORE 1 NAME\",\n            \"cluster_name\": \"CLUSTER NAME\",\n            \"project_id\": \"PROJECT ID\",\n            \"provider\": \"atlas\",\n            \"read_preference\": {\n                \"mode\": \"secondary\",\n            },\n        },\n        {\n            \"bucket\": \"STORE 2 NAME\",\n            \"delimiter\": \"/\",\n            \"name\": \"S3 BUCKET NAME\",\n            \"prefix\": \"S3 BUCKET PREFIX\",\n            \"provider\": \"s3\",\n            \"region\": \"AWS REGION\",\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.FederatedDatabaseInstance(\"test\", new()\n    {\n        ProjectId = \"PROJECT ID\",\n        Name = \"TENANT NAME OF THE FEDERATED DATABASE INSTANCE\",\n        CloudProviderConfig = new Mongodbatlas.Inputs.FederatedDatabaseInstanceCloudProviderConfigArgs\n        {\n            Aws = new Mongodbatlas.Inputs.FederatedDatabaseInstanceCloudProviderConfigAwsArgs\n            {\n                RoleId = \"AWS ROLE ID\",\n                TestS3Bucket = \"S3 BUCKET NAME\",\n            },\n        },\n        StorageDatabases = new[]\n        {\n            new Mongodbatlas.Inputs.FederatedDatabaseInstanceStorageDatabaseArgs\n            {\n                Name = \"VirtualDatabase0\",\n                Collections = new[]\n                {\n                    new Mongodbatlas.Inputs.FederatedDatabaseInstanceStorageDatabaseCollectionArgs\n                    {\n                        Name = \"NAME OF THE COLLECTION\",\n                        DataSources = new[]\n                        {\n                            new Mongodbatlas.Inputs.FederatedDatabaseInstanceStorageDatabaseCollectionDataSourceArgs\n                            {\n                                Collection = \"COLLECTION IN THE CLUSTER\",\n                                Database = \"DB IN THE CLUSTER\",\n                                StoreName = \"CLUSTER NAME\",\n                            },\n                            new Mongodbatlas.Inputs.FederatedDatabaseInstanceStorageDatabaseCollectionDataSourceArgs\n                            {\n                                StoreName = \"S3 BUCKET NAME\",\n                                Path = \"S3 BUCKET PATH\",\n                            },\n                        },\n                    },\n                },\n            },\n        },\n        StorageStores = new[]\n        {\n            new Mongodbatlas.Inputs.FederatedDatabaseInstanceStorageStoreArgs\n            {\n                Name = \"STORE 1 NAME\",\n                ClusterName = \"CLUSTER NAME\",\n                ProjectId = \"PROJECT ID\",\n                Provider = \"atlas\",\n                ReadPreference = new Mongodbatlas.Inputs.FederatedDatabaseInstanceStorageStoreReadPreferenceArgs\n                {\n                    Mode = \"secondary\",\n                },\n            },\n            new Mongodbatlas.Inputs.FederatedDatabaseInstanceStorageStoreArgs\n            {\n                Bucket = \"STORE 2 NAME\",\n                Delimiter = \"/\",\n                Name = \"S3 BUCKET NAME\",\n                Prefix = \"S3 BUCKET PREFIX\",\n                Provider = \"s3\",\n                Region = \"AWS REGION\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewFederatedDatabaseInstance(ctx, \"test\", \u0026mongodbatlas.FederatedDatabaseInstanceArgs{\n\t\t\tProjectId: pulumi.String(\"PROJECT ID\"),\n\t\t\tName:      pulumi.String(\"TENANT NAME OF THE FEDERATED DATABASE INSTANCE\"),\n\t\t\tCloudProviderConfig: \u0026mongodbatlas.FederatedDatabaseInstanceCloudProviderConfigArgs{\n\t\t\t\tAws: \u0026mongodbatlas.FederatedDatabaseInstanceCloudProviderConfigAwsArgs{\n\t\t\t\t\tRoleId:       pulumi.String(\"AWS ROLE ID\"),\n\t\t\t\t\tTestS3Bucket: pulumi.String(\"S3 BUCKET NAME\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tStorageDatabases: mongodbatlas.FederatedDatabaseInstanceStorageDatabaseArray{\n\t\t\t\t\u0026mongodbatlas.FederatedDatabaseInstanceStorageDatabaseArgs{\n\t\t\t\t\tName: pulumi.String(\"VirtualDatabase0\"),\n\t\t\t\t\tCollections: mongodbatlas.FederatedDatabaseInstanceStorageDatabaseCollectionArray{\n\t\t\t\t\t\t\u0026mongodbatlas.FederatedDatabaseInstanceStorageDatabaseCollectionArgs{\n\t\t\t\t\t\t\tName: pulumi.String(\"NAME OF THE COLLECTION\"),\n\t\t\t\t\t\t\tDataSources: mongodbatlas.FederatedDatabaseInstanceStorageDatabaseCollectionDataSourceArray{\n\t\t\t\t\t\t\t\t\u0026mongodbatlas.FederatedDatabaseInstanceStorageDatabaseCollectionDataSourceArgs{\n\t\t\t\t\t\t\t\t\tCollection: pulumi.String(\"COLLECTION IN THE CLUSTER\"),\n\t\t\t\t\t\t\t\t\tDatabase:   pulumi.String(\"DB IN THE CLUSTER\"),\n\t\t\t\t\t\t\t\t\tStoreName:  pulumi.String(\"CLUSTER NAME\"),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\u0026mongodbatlas.FederatedDatabaseInstanceStorageDatabaseCollectionDataSourceArgs{\n\t\t\t\t\t\t\t\t\tStoreName: pulumi.String(\"S3 BUCKET NAME\"),\n\t\t\t\t\t\t\t\t\tPath:      pulumi.String(\"S3 BUCKET PATH\"),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tStorageStores: mongodbatlas.FederatedDatabaseInstanceStorageStoreArray{\n\t\t\t\t\u0026mongodbatlas.FederatedDatabaseInstanceStorageStoreArgs{\n\t\t\t\t\tName:        pulumi.String(\"STORE 1 NAME\"),\n\t\t\t\t\tClusterName: pulumi.String(\"CLUSTER NAME\"),\n\t\t\t\t\tProjectId:   pulumi.String(\"PROJECT ID\"),\n\t\t\t\t\tProvider:    pulumi.String(\"atlas\"),\n\t\t\t\t\tReadPreference: \u0026mongodbatlas.FederatedDatabaseInstanceStorageStoreReadPreferenceArgs{\n\t\t\t\t\t\tMode: pulumi.String(\"secondary\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.FederatedDatabaseInstanceStorageStoreArgs{\n\t\t\t\t\tBucket:    pulumi.String(\"STORE 2 NAME\"),\n\t\t\t\t\tDelimiter: pulumi.String(\"/\"),\n\t\t\t\t\tName:      pulumi.String(\"S3 BUCKET NAME\"),\n\t\t\t\t\tPrefix:    pulumi.String(\"S3 BUCKET PREFIX\"),\n\t\t\t\t\tProvider:  pulumi.String(\"s3\"),\n\t\t\t\t\tRegion:    pulumi.String(\"AWS REGION\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.FederatedDatabaseInstance;\nimport com.pulumi.mongodbatlas.FederatedDatabaseInstanceArgs;\nimport com.pulumi.mongodbatlas.inputs.FederatedDatabaseInstanceCloudProviderConfigArgs;\nimport com.pulumi.mongodbatlas.inputs.FederatedDatabaseInstanceCloudProviderConfigAwsArgs;\nimport com.pulumi.mongodbatlas.inputs.FederatedDatabaseInstanceStorageDatabaseArgs;\nimport com.pulumi.mongodbatlas.inputs.FederatedDatabaseInstanceStorageStoreArgs;\nimport com.pulumi.mongodbatlas.inputs.FederatedDatabaseInstanceStorageStoreReadPreferenceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new FederatedDatabaseInstance(\"test\", FederatedDatabaseInstanceArgs.builder()\n            .projectId(\"PROJECT ID\")\n            .name(\"TENANT NAME OF THE FEDERATED DATABASE INSTANCE\")\n            .cloudProviderConfig(FederatedDatabaseInstanceCloudProviderConfigArgs.builder()\n                .aws(FederatedDatabaseInstanceCloudProviderConfigAwsArgs.builder()\n                    .roleId(\"AWS ROLE ID\")\n                    .testS3Bucket(\"S3 BUCKET NAME\")\n                    .build())\n                .build())\n            .storageDatabases(FederatedDatabaseInstanceStorageDatabaseArgs.builder()\n                .name(\"VirtualDatabase0\")\n                .collections(FederatedDatabaseInstanceStorageDatabaseCollectionArgs.builder()\n                    .name(\"NAME OF THE COLLECTION\")\n                    .dataSources(                    \n                        FederatedDatabaseInstanceStorageDatabaseCollectionDataSourceArgs.builder()\n                            .collection(\"COLLECTION IN THE CLUSTER\")\n                            .database(\"DB IN THE CLUSTER\")\n                            .storeName(\"CLUSTER NAME\")\n                            .build(),\n                        FederatedDatabaseInstanceStorageDatabaseCollectionDataSourceArgs.builder()\n                            .storeName(\"S3 BUCKET NAME\")\n                            .path(\"S3 BUCKET PATH\")\n                            .build())\n                    .build())\n                .build())\n            .storageStores(            \n                FederatedDatabaseInstanceStorageStoreArgs.builder()\n                    .name(\"STORE 1 NAME\")\n                    .clusterName(\"CLUSTER NAME\")\n                    .projectId(\"PROJECT ID\")\n                    .provider(\"atlas\")\n                    .readPreference(FederatedDatabaseInstanceStorageStoreReadPreferenceArgs.builder()\n                        .mode(\"secondary\")\n                        .build())\n                    .build(),\n                FederatedDatabaseInstanceStorageStoreArgs.builder()\n                    .bucket(\"STORE 2 NAME\")\n                    .delimiter(\"/\")\n                    .name(\"S3 BUCKET NAME\")\n                    .prefix(\"S3 BUCKET PREFIX\")\n                    .provider(\"s3\")\n                    .region(\"AWS REGION\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:FederatedDatabaseInstance\n    properties:\n      projectId: PROJECT ID\n      name: TENANT NAME OF THE FEDERATED DATABASE INSTANCE\n      cloudProviderConfig:\n        aws:\n          roleId: AWS ROLE ID\n          testS3Bucket: S3 BUCKET NAME\n      storageDatabases:\n        - name: VirtualDatabase0\n          collections:\n            - name: NAME OF THE COLLECTION\n              dataSources:\n                - collection: COLLECTION IN THE CLUSTER\n                  database: DB IN THE CLUSTER\n                  storeName: CLUSTER NAME\n                - storeName: S3 BUCKET NAME\n                  path: S3 BUCKET PATH\n      storageStores:\n        - name: STORE 1 NAME\n          clusterName: CLUSTER NAME\n          projectId: PROJECT ID\n          provider: atlas\n          readPreference:\n            mode: secondary\n        - bucket: STORE 2 NAME\n          delimiter: /\n          name: S3 BUCKET NAME\n          prefix: S3 BUCKET PREFIX\n          provider: s3\n          region: AWS REGION\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Example specifying data process region and provider\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.FederatedDatabaseInstance(\"test\", {\n    projectId: \"PROJECT ID\",\n    name: \"NAME OF THE FEDERATED DATABASE INSTANCE\",\n    dataProcessRegion: {\n        cloudProvider: \"AWS\",\n        region: \"OREGON_USA\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.FederatedDatabaseInstance(\"test\",\n    project_id=\"PROJECT ID\",\n    name=\"NAME OF THE FEDERATED DATABASE INSTANCE\",\n    data_process_region={\n        \"cloud_provider\": \"AWS\",\n        \"region\": \"OREGON_USA\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.FederatedDatabaseInstance(\"test\", new()\n    {\n        ProjectId = \"PROJECT ID\",\n        Name = \"NAME OF THE FEDERATED DATABASE INSTANCE\",\n        DataProcessRegion = new Mongodbatlas.Inputs.FederatedDatabaseInstanceDataProcessRegionArgs\n        {\n            CloudProvider = \"AWS\",\n            Region = \"OREGON_USA\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewFederatedDatabaseInstance(ctx, \"test\", \u0026mongodbatlas.FederatedDatabaseInstanceArgs{\n\t\t\tProjectId: pulumi.String(\"PROJECT ID\"),\n\t\t\tName:      pulumi.String(\"NAME OF THE FEDERATED DATABASE INSTANCE\"),\n\t\t\tDataProcessRegion: \u0026mongodbatlas.FederatedDatabaseInstanceDataProcessRegionArgs{\n\t\t\t\tCloudProvider: pulumi.String(\"AWS\"),\n\t\t\t\tRegion:        pulumi.String(\"OREGON_USA\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.FederatedDatabaseInstance;\nimport com.pulumi.mongodbatlas.FederatedDatabaseInstanceArgs;\nimport com.pulumi.mongodbatlas.inputs.FederatedDatabaseInstanceDataProcessRegionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new FederatedDatabaseInstance(\"test\", FederatedDatabaseInstanceArgs.builder()\n            .projectId(\"PROJECT ID\")\n            .name(\"NAME OF THE FEDERATED DATABASE INSTANCE\")\n            .dataProcessRegion(FederatedDatabaseInstanceDataProcessRegionArgs.builder()\n                .cloudProvider(\"AWS\")\n                .region(\"OREGON_USA\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:FederatedDatabaseInstance\n    properties:\n      projectId: PROJECT ID\n      name: NAME OF THE FEDERATED DATABASE INSTANCE\n      dataProcessRegion:\n        cloudProvider: AWS\n        region: OREGON_USA\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n- The Federated Database Instance can be imported using project ID, name of the instance, in the format `project_id`--`name`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/federatedDatabaseInstance:FederatedDatabaseInstance mongodbatlas_federated_database_instance.example 1112222b3bf99403840e8934--test\n```\n\n- The Federated Database Instance can be imported using project ID, name of the instance and name of the AWS S3 bucket, in the format `project_id`--`name`--`aws_test_s3_bucket`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/federatedDatabaseInstance:FederatedDatabaseInstance mongodbatlas_federated_database_instance.example 1112222b3bf99403840e8934--test--s3-test\n```\n\nSee [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation) Documentation for more information.\n\n",
            "properties": {
                "cloudProviderConfig": {
                    "$ref": "#/types/mongodbatlas:index/FederatedDatabaseInstanceCloudProviderConfig:FederatedDatabaseInstanceCloudProviderConfig",
                    "description": "Cloud provider linked to this data federated instance.\n* `cloud_provider_config.aws` - (Required) AWS provider of the cloud service where the Federated Database Instance can access the S3 Bucket. Note this parameter is only required if using `cloud_provider_config` since AWS is currently the only supported Cloud vendor on this feature at this time.\n* `cloud_provider_config.aws.role_id` - (Required) Unique identifier of the role that the Federated Instance can use to access the data stores. If necessary, use the Atlas [UI](https://docs.atlas.mongodb.com/security/manage-iam-roles/) or [API](https://docs.atlas.mongodb.com/reference/api/cloud-provider-access-get-roles/) to retrieve the role ID. You must also specify the `test_s3_bucket`.\n* `cloud_provider_config.aws.test_s3_bucket` - (Required) Name of the S3 data bucket that the provided role ID is authorized to access. You must also specify the `role_id`.\n"
                },
                "dataProcessRegion": {
                    "$ref": "#/types/mongodbatlas:index/FederatedDatabaseInstanceDataProcessRegion:FederatedDatabaseInstanceDataProcessRegion",
                    "description": "The cloud provider region to which the Federated Instance routes client connections for data processing.\n* `data_process_region.cloud_provider` - (Required) Name of the cloud service provider. Atlas Federated Database only supports AWS.\n* `data_process_region.region` - (Required) Name of the region to which the Federanted Instnace routes client connections for data processing. See the [documention](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation/operation/createFederatedDatabase) for the available region.\n"
                },
                "hostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of hostnames assigned to the Federated Database Instance. Each string in the array is a hostname assigned to the Federated Database Instance.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the Atlas Federated Database Instance.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create a Federated Database Instance.\n"
                },
                "state": {
                    "type": "string",
                    "description": "Current state of the Federated Database Instance:\n* `ACTIVE` - The Federated Database Instance is active and verified. You can query the data stores associated with the Federated Database Instance.\n* `DELETED` - The Federated Database Instance was deleted.\n"
                },
                "storageDatabases": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/FederatedDatabaseInstanceStorageDatabase:FederatedDatabaseInstanceStorageDatabase"
                    },
                    "description": "Configuration details for mapping each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [databases](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-databases-reference). An empty object indicates that the Federated Database Instance has no mapping configuration for any data store.\n* `storage_databases.#.name` - Name of the database to which the Federated Database Instance maps the data contained in the data store.\n* `storage_databases.#.collections` -     Array of objects where each object represents a collection and data sources that map to a [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#mongodb-datalakeconf-datalakeconf.stores) data store.\n* `storage_databases.#.collections.#.name` - Name of the collection.\n* `storage_databases.#.collections.#.data_sources` -     Array of objects where each object represents a stores data store to map with the collection.\n* `storage_databases.#.collections.#.data_sources.#.store_name` -     Name of a data store to map to the `\u003ccollection\u003e`. Must match the name of an object in the stores array.\n* `storage_databases.#.collections.#.data_sources.#.dataset_name` -     Human-readable label that identifies the dataset that Atlas generates for an ingestion pipeline run or Online Archive.\n* `storage_databases.#.collections.#.data_sources.#.default_format` - Default format that Federated Database assumes if it encounters a file without an extension while searching the storeName.\n* `storage_databases.#.collections.#.data_sources.#.path` - File path that controls how MongoDB Cloud searches for and parses files in the storeName before mapping them to a collection. Specify / to capture all files and folders from the prefix path.\n* `storage_databases.#.collections.#.data_sources.#.database` - Human-readable label that identifies the database, which contains the collection in the cluster.\n* `storage_databases.#.collections.#.data_sources.#.allow_insecure` - Flag that validates the scheme in the specified URLs. If true, allows insecure HTTP scheme, doesn't verify the server's certificate chain and hostname, and accepts any certificate with any hostname presented by the server. If false, allows secure HTTPS scheme only.\n* `storage_databases.#.collections.#.data_sources.#.database_regex` - Regex pattern to use for creating the wildcard database.\n* `storage_databases.#.collections.#.data_sources.#.collection` - Human-readable label that identifies the collection in the database.\n* `storage_databases.#.collections.#.data_sources.#.collection_regex` - Regex pattern to use for creating the wildcard (*) collection.\n* `storage_databases.#.collections.#.data_sources.#.provenance_field_name` - Name for the field that includes the provenance of the documents in the results.\n* `storage_databases.#.collections.#.data_sources.#.storeName` - Human-readable label that identifies the data store that MongoDB Cloud maps to the collection.\n* `storage_databases.#.collections.#.data_sources.#.urls` - URLs of the publicly accessible data files. You can't specify URLs that require authentication.\n* `storage_databases.#.views` -     Array of objects where each object represents an [aggregation pipeline](https://docs.mongodb.com/manual/core/aggregation-pipeline/#id1) on a collection. To learn more about views, see [Views](https://docs.mongodb.com/manual/core/views/).\n* `storage_databases.#.views.#.name` - Name of the view.\n* `storage_databases.#.views.#.source` -  Name of the source collection for the view.\n* `storage_databases.#.views.#.pipeline`- Aggregation pipeline stage(s) to apply to the source collection.\n"
                },
                "storageStores": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/FederatedDatabaseInstanceStorageStore:FederatedDatabaseInstanceStorageStore"
                    },
                    "description": "Each object in the array represents a data store. Federated Database uses the storage.databases configuration details to map data in each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-stores-reference). An empty object indicates that the Federated Database Instance has no configured data stores.\n* `storage_stores.#.name` - Name of the data store.\n* `storage_stores.#.provider` - Defines where the data is stored.\n* `storage_stores.#.region` - Name of the AWS region in which the S3 bucket is hosted.\n* `storage_stores.#.bucket` - Name of the AWS S3 bucket.\n* `storage_stores.#.prefix` - Prefix the Federated Database Instance applies when searching for files in the S3 bucket.\n* `storage_stores.#.delimiter` - The delimiter that separates `storage_databases.#.collections.#.data_sources.#.path` segments in the data store.\n* `storage_stores.#.include_tags` - Determines whether or not to use S3 tags on the files in the given path as additional partition attributes.\n* `storage_stores.#.cluster_name` - Human-readable label of the MongoDB Cloud cluster on which the store is based.\n* `storage_stores.#.cluster_id` - ID of the Cluster the Online Archive belongs to.\n* `storage_stores.#.allow_insecure` - Flag that validates the scheme in the specified URLs.\n* `storage_stores.#.public` - Flag that indicates whether the bucket is public.\n* `storage_stores.#.default_format` - Default format that Data Lake assumes if it encounters a file without an extension while searching the storeName.\n* `storage_stores.#.urls` - Comma-separated list of publicly accessible HTTP URLs where data is stored.\n* `storage_stores.#.read_preference` - MongoDB Cloud cluster read preference, which describes how to route read requests to the cluster.\n* `storage_stores.#.read_preference.maxStalenessSeconds` - Maximum replication lag, or staleness, for reads from secondaries.\n* `storage_stores.#.read_preference.mode` - Read preference mode that specifies to which replica set member to route the read requests.\n* `storage_stores.#.read_preference.tag_sets` - List that contains tag sets or tag specification documents.\n* `storage_stores.#.read_preference.tags` - List of all tags within a tag set\n* `storage_stores.#.read_preference.tags.name` - Human-readable label of the tag.\n* `storage_stores.#.read_preference.tags.value` - Value of the tag.\n"
                }
            },
            "required": [
                "cloudProviderConfig",
                "dataProcessRegion",
                "hostnames",
                "name",
                "projectId",
                "state",
                "storageDatabases",
                "storageStores"
            ],
            "inputProperties": {
                "cloudProviderConfig": {
                    "$ref": "#/types/mongodbatlas:index/FederatedDatabaseInstanceCloudProviderConfig:FederatedDatabaseInstanceCloudProviderConfig",
                    "description": "Cloud provider linked to this data federated instance.\n* `cloud_provider_config.aws` - (Required) AWS provider of the cloud service where the Federated Database Instance can access the S3 Bucket. Note this parameter is only required if using `cloud_provider_config` since AWS is currently the only supported Cloud vendor on this feature at this time.\n* `cloud_provider_config.aws.role_id` - (Required) Unique identifier of the role that the Federated Instance can use to access the data stores. If necessary, use the Atlas [UI](https://docs.atlas.mongodb.com/security/manage-iam-roles/) or [API](https://docs.atlas.mongodb.com/reference/api/cloud-provider-access-get-roles/) to retrieve the role ID. You must also specify the `test_s3_bucket`.\n* `cloud_provider_config.aws.test_s3_bucket` - (Required) Name of the S3 data bucket that the provided role ID is authorized to access. You must also specify the `role_id`.\n"
                },
                "dataProcessRegion": {
                    "$ref": "#/types/mongodbatlas:index/FederatedDatabaseInstanceDataProcessRegion:FederatedDatabaseInstanceDataProcessRegion",
                    "description": "The cloud provider region to which the Federated Instance routes client connections for data processing.\n* `data_process_region.cloud_provider` - (Required) Name of the cloud service provider. Atlas Federated Database only supports AWS.\n* `data_process_region.region` - (Required) Name of the region to which the Federanted Instnace routes client connections for data processing. See the [documention](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation/operation/createFederatedDatabase) for the available region.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the Atlas Federated Database Instance.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create a Federated Database Instance.\n",
                    "willReplaceOnChanges": true
                },
                "storageDatabases": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/FederatedDatabaseInstanceStorageDatabase:FederatedDatabaseInstanceStorageDatabase"
                    },
                    "description": "Configuration details for mapping each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [databases](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-databases-reference). An empty object indicates that the Federated Database Instance has no mapping configuration for any data store.\n* `storage_databases.#.name` - Name of the database to which the Federated Database Instance maps the data contained in the data store.\n* `storage_databases.#.collections` -     Array of objects where each object represents a collection and data sources that map to a [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#mongodb-datalakeconf-datalakeconf.stores) data store.\n* `storage_databases.#.collections.#.name` - Name of the collection.\n* `storage_databases.#.collections.#.data_sources` -     Array of objects where each object represents a stores data store to map with the collection.\n* `storage_databases.#.collections.#.data_sources.#.store_name` -     Name of a data store to map to the `\u003ccollection\u003e`. Must match the name of an object in the stores array.\n* `storage_databases.#.collections.#.data_sources.#.dataset_name` -     Human-readable label that identifies the dataset that Atlas generates for an ingestion pipeline run or Online Archive.\n* `storage_databases.#.collections.#.data_sources.#.default_format` - Default format that Federated Database assumes if it encounters a file without an extension while searching the storeName.\n* `storage_databases.#.collections.#.data_sources.#.path` - File path that controls how MongoDB Cloud searches for and parses files in the storeName before mapping them to a collection. Specify / to capture all files and folders from the prefix path.\n* `storage_databases.#.collections.#.data_sources.#.database` - Human-readable label that identifies the database, which contains the collection in the cluster.\n* `storage_databases.#.collections.#.data_sources.#.allow_insecure` - Flag that validates the scheme in the specified URLs. If true, allows insecure HTTP scheme, doesn't verify the server's certificate chain and hostname, and accepts any certificate with any hostname presented by the server. If false, allows secure HTTPS scheme only.\n* `storage_databases.#.collections.#.data_sources.#.database_regex` - Regex pattern to use for creating the wildcard database.\n* `storage_databases.#.collections.#.data_sources.#.collection` - Human-readable label that identifies the collection in the database.\n* `storage_databases.#.collections.#.data_sources.#.collection_regex` - Regex pattern to use for creating the wildcard (*) collection.\n* `storage_databases.#.collections.#.data_sources.#.provenance_field_name` - Name for the field that includes the provenance of the documents in the results.\n* `storage_databases.#.collections.#.data_sources.#.storeName` - Human-readable label that identifies the data store that MongoDB Cloud maps to the collection.\n* `storage_databases.#.collections.#.data_sources.#.urls` - URLs of the publicly accessible data files. You can't specify URLs that require authentication.\n* `storage_databases.#.views` -     Array of objects where each object represents an [aggregation pipeline](https://docs.mongodb.com/manual/core/aggregation-pipeline/#id1) on a collection. To learn more about views, see [Views](https://docs.mongodb.com/manual/core/views/).\n* `storage_databases.#.views.#.name` - Name of the view.\n* `storage_databases.#.views.#.source` -  Name of the source collection for the view.\n* `storage_databases.#.views.#.pipeline`- Aggregation pipeline stage(s) to apply to the source collection.\n"
                },
                "storageStores": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/FederatedDatabaseInstanceStorageStore:FederatedDatabaseInstanceStorageStore"
                    },
                    "description": "Each object in the array represents a data store. Federated Database uses the storage.databases configuration details to map data in each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-stores-reference). An empty object indicates that the Federated Database Instance has no configured data stores.\n* `storage_stores.#.name` - Name of the data store.\n* `storage_stores.#.provider` - Defines where the data is stored.\n* `storage_stores.#.region` - Name of the AWS region in which the S3 bucket is hosted.\n* `storage_stores.#.bucket` - Name of the AWS S3 bucket.\n* `storage_stores.#.prefix` - Prefix the Federated Database Instance applies when searching for files in the S3 bucket.\n* `storage_stores.#.delimiter` - The delimiter that separates `storage_databases.#.collections.#.data_sources.#.path` segments in the data store.\n* `storage_stores.#.include_tags` - Determines whether or not to use S3 tags on the files in the given path as additional partition attributes.\n* `storage_stores.#.cluster_name` - Human-readable label of the MongoDB Cloud cluster on which the store is based.\n* `storage_stores.#.cluster_id` - ID of the Cluster the Online Archive belongs to.\n* `storage_stores.#.allow_insecure` - Flag that validates the scheme in the specified URLs.\n* `storage_stores.#.public` - Flag that indicates whether the bucket is public.\n* `storage_stores.#.default_format` - Default format that Data Lake assumes if it encounters a file without an extension while searching the storeName.\n* `storage_stores.#.urls` - Comma-separated list of publicly accessible HTTP URLs where data is stored.\n* `storage_stores.#.read_preference` - MongoDB Cloud cluster read preference, which describes how to route read requests to the cluster.\n* `storage_stores.#.read_preference.maxStalenessSeconds` - Maximum replication lag, or staleness, for reads from secondaries.\n* `storage_stores.#.read_preference.mode` - Read preference mode that specifies to which replica set member to route the read requests.\n* `storage_stores.#.read_preference.tag_sets` - List that contains tag sets or tag specification documents.\n* `storage_stores.#.read_preference.tags` - List of all tags within a tag set\n* `storage_stores.#.read_preference.tags.name` - Human-readable label of the tag.\n* `storage_stores.#.read_preference.tags.value` - Value of the tag.\n"
                }
            },
            "requiredInputs": [
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FederatedDatabaseInstance resources.\n",
                "properties": {
                    "cloudProviderConfig": {
                        "$ref": "#/types/mongodbatlas:index/FederatedDatabaseInstanceCloudProviderConfig:FederatedDatabaseInstanceCloudProviderConfig",
                        "description": "Cloud provider linked to this data federated instance.\n* `cloud_provider_config.aws` - (Required) AWS provider of the cloud service where the Federated Database Instance can access the S3 Bucket. Note this parameter is only required if using `cloud_provider_config` since AWS is currently the only supported Cloud vendor on this feature at this time.\n* `cloud_provider_config.aws.role_id` - (Required) Unique identifier of the role that the Federated Instance can use to access the data stores. If necessary, use the Atlas [UI](https://docs.atlas.mongodb.com/security/manage-iam-roles/) or [API](https://docs.atlas.mongodb.com/reference/api/cloud-provider-access-get-roles/) to retrieve the role ID. You must also specify the `test_s3_bucket`.\n* `cloud_provider_config.aws.test_s3_bucket` - (Required) Name of the S3 data bucket that the provided role ID is authorized to access. You must also specify the `role_id`.\n"
                    },
                    "dataProcessRegion": {
                        "$ref": "#/types/mongodbatlas:index/FederatedDatabaseInstanceDataProcessRegion:FederatedDatabaseInstanceDataProcessRegion",
                        "description": "The cloud provider region to which the Federated Instance routes client connections for data processing.\n* `data_process_region.cloud_provider` - (Required) Name of the cloud service provider. Atlas Federated Database only supports AWS.\n* `data_process_region.region` - (Required) Name of the region to which the Federanted Instnace routes client connections for data processing. See the [documention](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation/operation/createFederatedDatabase) for the available region.\n"
                    },
                    "hostnames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of hostnames assigned to the Federated Database Instance. Each string in the array is a hostname assigned to the Federated Database Instance.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the Atlas Federated Database Instance.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create a Federated Database Instance.\n",
                        "willReplaceOnChanges": true
                    },
                    "state": {
                        "type": "string",
                        "description": "Current state of the Federated Database Instance:\n* `ACTIVE` - The Federated Database Instance is active and verified. You can query the data stores associated with the Federated Database Instance.\n* `DELETED` - The Federated Database Instance was deleted.\n"
                    },
                    "storageDatabases": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/FederatedDatabaseInstanceStorageDatabase:FederatedDatabaseInstanceStorageDatabase"
                        },
                        "description": "Configuration details for mapping each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [databases](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-databases-reference). An empty object indicates that the Federated Database Instance has no mapping configuration for any data store.\n* `storage_databases.#.name` - Name of the database to which the Federated Database Instance maps the data contained in the data store.\n* `storage_databases.#.collections` -     Array of objects where each object represents a collection and data sources that map to a [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#mongodb-datalakeconf-datalakeconf.stores) data store.\n* `storage_databases.#.collections.#.name` - Name of the collection.\n* `storage_databases.#.collections.#.data_sources` -     Array of objects where each object represents a stores data store to map with the collection.\n* `storage_databases.#.collections.#.data_sources.#.store_name` -     Name of a data store to map to the `\u003ccollection\u003e`. Must match the name of an object in the stores array.\n* `storage_databases.#.collections.#.data_sources.#.dataset_name` -     Human-readable label that identifies the dataset that Atlas generates for an ingestion pipeline run or Online Archive.\n* `storage_databases.#.collections.#.data_sources.#.default_format` - Default format that Federated Database assumes if it encounters a file without an extension while searching the storeName.\n* `storage_databases.#.collections.#.data_sources.#.path` - File path that controls how MongoDB Cloud searches for and parses files in the storeName before mapping them to a collection. Specify / to capture all files and folders from the prefix path.\n* `storage_databases.#.collections.#.data_sources.#.database` - Human-readable label that identifies the database, which contains the collection in the cluster.\n* `storage_databases.#.collections.#.data_sources.#.allow_insecure` - Flag that validates the scheme in the specified URLs. If true, allows insecure HTTP scheme, doesn't verify the server's certificate chain and hostname, and accepts any certificate with any hostname presented by the server. If false, allows secure HTTPS scheme only.\n* `storage_databases.#.collections.#.data_sources.#.database_regex` - Regex pattern to use for creating the wildcard database.\n* `storage_databases.#.collections.#.data_sources.#.collection` - Human-readable label that identifies the collection in the database.\n* `storage_databases.#.collections.#.data_sources.#.collection_regex` - Regex pattern to use for creating the wildcard (*) collection.\n* `storage_databases.#.collections.#.data_sources.#.provenance_field_name` - Name for the field that includes the provenance of the documents in the results.\n* `storage_databases.#.collections.#.data_sources.#.storeName` - Human-readable label that identifies the data store that MongoDB Cloud maps to the collection.\n* `storage_databases.#.collections.#.data_sources.#.urls` - URLs of the publicly accessible data files. You can't specify URLs that require authentication.\n* `storage_databases.#.views` -     Array of objects where each object represents an [aggregation pipeline](https://docs.mongodb.com/manual/core/aggregation-pipeline/#id1) on a collection. To learn more about views, see [Views](https://docs.mongodb.com/manual/core/views/).\n* `storage_databases.#.views.#.name` - Name of the view.\n* `storage_databases.#.views.#.source` -  Name of the source collection for the view.\n* `storage_databases.#.views.#.pipeline`- Aggregation pipeline stage(s) to apply to the source collection.\n"
                    },
                    "storageStores": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/FederatedDatabaseInstanceStorageStore:FederatedDatabaseInstanceStorageStore"
                        },
                        "description": "Each object in the array represents a data store. Federated Database uses the storage.databases configuration details to map data in each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-stores-reference). An empty object indicates that the Federated Database Instance has no configured data stores.\n* `storage_stores.#.name` - Name of the data store.\n* `storage_stores.#.provider` - Defines where the data is stored.\n* `storage_stores.#.region` - Name of the AWS region in which the S3 bucket is hosted.\n* `storage_stores.#.bucket` - Name of the AWS S3 bucket.\n* `storage_stores.#.prefix` - Prefix the Federated Database Instance applies when searching for files in the S3 bucket.\n* `storage_stores.#.delimiter` - The delimiter that separates `storage_databases.#.collections.#.data_sources.#.path` segments in the data store.\n* `storage_stores.#.include_tags` - Determines whether or not to use S3 tags on the files in the given path as additional partition attributes.\n* `storage_stores.#.cluster_name` - Human-readable label of the MongoDB Cloud cluster on which the store is based.\n* `storage_stores.#.cluster_id` - ID of the Cluster the Online Archive belongs to.\n* `storage_stores.#.allow_insecure` - Flag that validates the scheme in the specified URLs.\n* `storage_stores.#.public` - Flag that indicates whether the bucket is public.\n* `storage_stores.#.default_format` - Default format that Data Lake assumes if it encounters a file without an extension while searching the storeName.\n* `storage_stores.#.urls` - Comma-separated list of publicly accessible HTTP URLs where data is stored.\n* `storage_stores.#.read_preference` - MongoDB Cloud cluster read preference, which describes how to route read requests to the cluster.\n* `storage_stores.#.read_preference.maxStalenessSeconds` - Maximum replication lag, or staleness, for reads from secondaries.\n* `storage_stores.#.read_preference.mode` - Read preference mode that specifies to which replica set member to route the read requests.\n* `storage_stores.#.read_preference.tag_sets` - List that contains tag sets or tag specification documents.\n* `storage_stores.#.read_preference.tags` - List of all tags within a tag set\n* `storage_stores.#.read_preference.tags.name` - Human-readable label of the tag.\n* `storage_stores.#.read_preference.tags.value` - Value of the tag.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/federatedQueryLimit:FederatedQueryLimit": {
            "description": "## # Resource: mongodbatlas.FederatedQueryLimit\n\n`mongodbatlas.FederatedQueryLimit` provides a Federated Database Instance Query Limits resource. To learn more about Atlas Data Federation see https://www.mongodb.com/docs/atlas/data-federation/overview/.\n\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n## Example Usage\n\n### S\n\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.FederatedQueryLimit(\"test\", {\n    projectId: \"64707f06c519c20c3a2b1b03\",\n    tenantName: \"FederatedDatabseInstance0\",\n    limitName: \"bytesProcessed.weekly\",\n    overrunPolicy: \"BLOCK\",\n    value: 5147483648,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.FederatedQueryLimit(\"test\",\n    project_id=\"64707f06c519c20c3a2b1b03\",\n    tenant_name=\"FederatedDatabseInstance0\",\n    limit_name=\"bytesProcessed.weekly\",\n    overrun_policy=\"BLOCK\",\n    value=5147483648)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.FederatedQueryLimit(\"test\", new()\n    {\n        ProjectId = \"64707f06c519c20c3a2b1b03\",\n        TenantName = \"FederatedDatabseInstance0\",\n        LimitName = \"bytesProcessed.weekly\",\n        OverrunPolicy = \"BLOCK\",\n        Value = 5147483648,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewFederatedQueryLimit(ctx, \"test\", \u0026mongodbatlas.FederatedQueryLimitArgs{\n\t\t\tProjectId:     pulumi.String(\"64707f06c519c20c3a2b1b03\"),\n\t\t\tTenantName:    pulumi.String(\"FederatedDatabseInstance0\"),\n\t\t\tLimitName:     pulumi.String(\"bytesProcessed.weekly\"),\n\t\t\tOverrunPolicy: pulumi.String(\"BLOCK\"),\n\t\t\tValue:         pulumi.Int(5147483648),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.FederatedQueryLimit;\nimport com.pulumi.mongodbatlas.FederatedQueryLimitArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new FederatedQueryLimit(\"test\", FederatedQueryLimitArgs.builder()\n            .projectId(\"64707f06c519c20c3a2b1b03\")\n            .tenantName(\"FederatedDatabseInstance0\")\n            .limitName(\"bytesProcessed.weekly\")\n            .overrunPolicy(\"BLOCK\")\n            .value(5147483648)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:FederatedQueryLimit\n    properties:\n      projectId: 64707f06c519c20c3a2b1b03\n      tenantName: FederatedDatabseInstance0\n      limitName: bytesProcessed.weekly\n      overrunPolicy: BLOCK\n      value: 5.147483648e+09\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nThe Federated Database Instance Query Limit can be imported using project ID, name of the instance and limit name, in the format:\n`project_id`--`tenant_name`--`limit_name`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/federatedQueryLimit:FederatedQueryLimit example 1112222b3bf99403840e8934--FederatedDatabaseInstance0--bytesProcessed.daily\n```\nSee [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation/operation/createOneDataFederationQueryLimit) Documentation for more information.\n\n",
            "properties": {
                "currentUsage": {
                    "type": "integer",
                    "description": "Amount that indicates the current usage of the limit.\n"
                },
                "defaultLimit": {
                    "type": "integer",
                    "description": "Default value of the limit.\n* `lastModifiedDate` - Only used for Data Federation limits. Timestamp that indicates when this usage limit was last modified. This field uses the ISO 8601 timestamp format in UTC.\n* `maximumLimit` - Maximum value of the limit.\n"
                },
                "lastModifiedDate": {
                    "type": "string"
                },
                "limitName": {
                    "type": "string",
                    "description": "String enum that indicates whether the identity provider is active or not. Accepted values are:\n* `bytesProcessed.query`: Limit on the number of bytes processed during a single data federation query.\n* `bytesProcessed.daily`: Limit on the number of bytes processed for the data federation instance for the current day.\n* `bytesProcessed.weekly`: Limit on the number of bytes processed for the data federation instance for the current week.\n* `bytesProcessed.monthly`: Limit on the number of bytes processed for the data federation instance for the current month.\n"
                },
                "maximumLimit": {
                    "type": "integer"
                },
                "overrunPolicy": {
                    "type": "string",
                    "description": "String enum that identifies action to take when the usage limit is exceeded. If limit span is set to QUERY, this is ignored because MongoDB Cloud stops the query when it exceeds the usage limit. Accepted values are \"BLOCK\" OR \"BLOCK_AND_KILL\"\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create a Federated Database Instance.\n"
                },
                "tenantName": {
                    "type": "string",
                    "description": "Name of the Atlas Federated Database Instance.\n"
                },
                "value": {
                    "type": "integer",
                    "description": "Amount to set the limit to.\n"
                }
            },
            "required": [
                "currentUsage",
                "lastModifiedDate",
                "limitName",
                "overrunPolicy",
                "projectId",
                "tenantName",
                "value"
            ],
            "inputProperties": {
                "defaultLimit": {
                    "type": "integer",
                    "description": "Default value of the limit.\n* `lastModifiedDate` - Only used for Data Federation limits. Timestamp that indicates when this usage limit was last modified. This field uses the ISO 8601 timestamp format in UTC.\n* `maximumLimit` - Maximum value of the limit.\n"
                },
                "limitName": {
                    "type": "string",
                    "description": "String enum that indicates whether the identity provider is active or not. Accepted values are:\n* `bytesProcessed.query`: Limit on the number of bytes processed during a single data federation query.\n* `bytesProcessed.daily`: Limit on the number of bytes processed for the data federation instance for the current day.\n* `bytesProcessed.weekly`: Limit on the number of bytes processed for the data federation instance for the current week.\n* `bytesProcessed.monthly`: Limit on the number of bytes processed for the data federation instance for the current month.\n"
                },
                "maximumLimit": {
                    "type": "integer"
                },
                "overrunPolicy": {
                    "type": "string",
                    "description": "String enum that identifies action to take when the usage limit is exceeded. If limit span is set to QUERY, this is ignored because MongoDB Cloud stops the query when it exceeds the usage limit. Accepted values are \"BLOCK\" OR \"BLOCK_AND_KILL\"\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create a Federated Database Instance.\n"
                },
                "tenantName": {
                    "type": "string",
                    "description": "Name of the Atlas Federated Database Instance.\n"
                },
                "value": {
                    "type": "integer",
                    "description": "Amount to set the limit to.\n"
                }
            },
            "requiredInputs": [
                "limitName",
                "overrunPolicy",
                "projectId",
                "tenantName",
                "value"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FederatedQueryLimit resources.\n",
                "properties": {
                    "currentUsage": {
                        "type": "integer",
                        "description": "Amount that indicates the current usage of the limit.\n"
                    },
                    "defaultLimit": {
                        "type": "integer",
                        "description": "Default value of the limit.\n* `lastModifiedDate` - Only used for Data Federation limits. Timestamp that indicates when this usage limit was last modified. This field uses the ISO 8601 timestamp format in UTC.\n* `maximumLimit` - Maximum value of the limit.\n"
                    },
                    "lastModifiedDate": {
                        "type": "string"
                    },
                    "limitName": {
                        "type": "string",
                        "description": "String enum that indicates whether the identity provider is active or not. Accepted values are:\n* `bytesProcessed.query`: Limit on the number of bytes processed during a single data federation query.\n* `bytesProcessed.daily`: Limit on the number of bytes processed for the data federation instance for the current day.\n* `bytesProcessed.weekly`: Limit on the number of bytes processed for the data federation instance for the current week.\n* `bytesProcessed.monthly`: Limit on the number of bytes processed for the data federation instance for the current month.\n"
                    },
                    "maximumLimit": {
                        "type": "integer"
                    },
                    "overrunPolicy": {
                        "type": "string",
                        "description": "String enum that identifies action to take when the usage limit is exceeded. If limit span is set to QUERY, this is ignored because MongoDB Cloud stops the query when it exceeds the usage limit. Accepted values are \"BLOCK\" OR \"BLOCK_AND_KILL\"\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create a Federated Database Instance.\n"
                    },
                    "tenantName": {
                        "type": "string",
                        "description": "Name of the Atlas Federated Database Instance.\n"
                    },
                    "value": {
                        "type": "integer",
                        "description": "Amount to set the limit to.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/federatedSettingsIdentityProvider:FederatedSettingsIdentityProvider": {
            "description": "## # Resource: mongodbatlas.FederatedSettingsIdentityProvider\n\n`mongodbatlas.FederatedSettingsIdentityProvider` provides an Atlas federated settings identity provider resource provides a subset of settings to be maintained post import of the existing resource.\n\n## Example Usage\n\n\u003e **IMPORTANT** If you want to use a SAML Identity Provider, you **MUST** import this resource before you can manage it with this provider. \n\nSAML IdP:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst identityProvider = new mongodbatlas.FederatedSettingsIdentityProvider(\"identity_provider\", {\n    federationSettingsId: \"627a9687f7f7f7f774de306f14\",\n    name: \"mongodb_federation_test\",\n    associatedDomains: [\"yourdomain.com\"],\n    ssoDebugEnabled: true,\n    status: \"ACTIVE\",\n    ssoUrl: \"https://mysso.oktapreview.com/app/mysso_terraformtestsso/exk17q7f7f7f7f50h8/sso/saml\",\n    issuerUri: \"http://www.okta.com/exk17q7f7f7f7fp50h8\",\n    requestBinding: \"HTTP-POST\",\n    responseSignatureAlgorithm: \"SHA-256\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nidentity_provider = mongodbatlas.FederatedSettingsIdentityProvider(\"identity_provider\",\n    federation_settings_id=\"627a9687f7f7f7f774de306f14\",\n    name=\"mongodb_federation_test\",\n    associated_domains=[\"yourdomain.com\"],\n    sso_debug_enabled=True,\n    status=\"ACTIVE\",\n    sso_url=\"https://mysso.oktapreview.com/app/mysso_terraformtestsso/exk17q7f7f7f7f50h8/sso/saml\",\n    issuer_uri=\"http://www.okta.com/exk17q7f7f7f7fp50h8\",\n    request_binding=\"HTTP-POST\",\n    response_signature_algorithm=\"SHA-256\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var identityProvider = new Mongodbatlas.FederatedSettingsIdentityProvider(\"identity_provider\", new()\n    {\n        FederationSettingsId = \"627a9687f7f7f7f774de306f14\",\n        Name = \"mongodb_federation_test\",\n        AssociatedDomains = new[]\n        {\n            \"yourdomain.com\",\n        },\n        SsoDebugEnabled = true,\n        Status = \"ACTIVE\",\n        SsoUrl = \"https://mysso.oktapreview.com/app/mysso_terraformtestsso/exk17q7f7f7f7f50h8/sso/saml\",\n        IssuerUri = \"http://www.okta.com/exk17q7f7f7f7fp50h8\",\n        RequestBinding = \"HTTP-POST\",\n        ResponseSignatureAlgorithm = \"SHA-256\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewFederatedSettingsIdentityProvider(ctx, \"identity_provider\", \u0026mongodbatlas.FederatedSettingsIdentityProviderArgs{\n\t\t\tFederationSettingsId: pulumi.String(\"627a9687f7f7f7f774de306f14\"),\n\t\t\tName:                 pulumi.String(\"mongodb_federation_test\"),\n\t\t\tAssociatedDomains: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"yourdomain.com\"),\n\t\t\t},\n\t\t\tSsoDebugEnabled:            pulumi.Bool(true),\n\t\t\tStatus:                     pulumi.String(\"ACTIVE\"),\n\t\t\tSsoUrl:                     pulumi.String(\"https://mysso.oktapreview.com/app/mysso_terraformtestsso/exk17q7f7f7f7f50h8/sso/saml\"),\n\t\t\tIssuerUri:                  pulumi.String(\"http://www.okta.com/exk17q7f7f7f7fp50h8\"),\n\t\t\tRequestBinding:             pulumi.String(\"HTTP-POST\"),\n\t\t\tResponseSignatureAlgorithm: pulumi.String(\"SHA-256\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.FederatedSettingsIdentityProvider;\nimport com.pulumi.mongodbatlas.FederatedSettingsIdentityProviderArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var identityProvider = new FederatedSettingsIdentityProvider(\"identityProvider\", FederatedSettingsIdentityProviderArgs.builder()\n            .federationSettingsId(\"627a9687f7f7f7f774de306f14\")\n            .name(\"mongodb_federation_test\")\n            .associatedDomains(\"yourdomain.com\")\n            .ssoDebugEnabled(true)\n            .status(\"ACTIVE\")\n            .ssoUrl(\"https://mysso.oktapreview.com/app/mysso_terraformtestsso/exk17q7f7f7f7f50h8/sso/saml\")\n            .issuerUri(\"http://www.okta.com/exk17q7f7f7f7fp50h8\")\n            .requestBinding(\"HTTP-POST\")\n            .responseSignatureAlgorithm(\"SHA-256\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  identityProvider:\n    type: mongodbatlas:FederatedSettingsIdentityProvider\n    name: identity_provider\n    properties:\n      federationSettingsId: 627a9687f7f7f7f774de306f14\n      name: mongodb_federation_test\n      associatedDomains:\n        - yourdomain.com\n      ssoDebugEnabled: true\n      status: ACTIVE\n      ssoUrl: https://mysso.oktapreview.com/app/mysso_terraformtestsso/exk17q7f7f7f7f50h8/sso/saml\n      issuerUri: http://www.okta.com/exk17q7f7f7f7fp50h8\n      requestBinding: HTTP-POST\n      responseSignatureAlgorithm: SHA-256\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nOIDC IdP:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst oidc = new mongodbatlas.FederatedSettingsIdentityProvider(\"oidc\", {\n    federationSettingsId: _this.id,\n    audience: tokenAudience,\n    authorizationType: \"USER\",\n    description: \"oidc\",\n    issuerUri: `https://sts.windows.net/${thisAzurermUserAssignedIdentity.tenantId}/`,\n    idpType: \"WORKLOAD\",\n    name: \"OIDC-for-azure\",\n    protocol: \"OIDC\",\n    userClaim: \"sub\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\noidc = mongodbatlas.FederatedSettingsIdentityProvider(\"oidc\",\n    federation_settings_id=this[\"id\"],\n    audience=token_audience,\n    authorization_type=\"USER\",\n    description=\"oidc\",\n    issuer_uri=f\"https://sts.windows.net/{this_azurerm_user_assigned_identity['tenantId']}/\",\n    idp_type=\"WORKLOAD\",\n    name=\"OIDC-for-azure\",\n    protocol=\"OIDC\",\n    user_claim=\"sub\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var oidc = new Mongodbatlas.FederatedSettingsIdentityProvider(\"oidc\", new()\n    {\n        FederationSettingsId = @this.Id,\n        Audience = tokenAudience,\n        AuthorizationType = \"USER\",\n        Description = \"oidc\",\n        IssuerUri = $\"https://sts.windows.net/{thisAzurermUserAssignedIdentity.TenantId}/\",\n        IdpType = \"WORKLOAD\",\n        Name = \"OIDC-for-azure\",\n        Protocol = \"OIDC\",\n        UserClaim = \"sub\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewFederatedSettingsIdentityProvider(ctx, \"oidc\", \u0026mongodbatlas.FederatedSettingsIdentityProviderArgs{\n\t\t\tFederationSettingsId: pulumi.Any(this.Id),\n\t\t\tAudience:             pulumi.Any(tokenAudience),\n\t\t\tAuthorizationType:    pulumi.String(\"USER\"),\n\t\t\tDescription:          pulumi.String(\"oidc\"),\n\t\t\tIssuerUri:            pulumi.Sprintf(\"https://sts.windows.net/%v/\", thisAzurermUserAssignedIdentity.TenantId),\n\t\t\tIdpType:              pulumi.String(\"WORKLOAD\"),\n\t\t\tName:                 pulumi.String(\"OIDC-for-azure\"),\n\t\t\tProtocol:             pulumi.String(\"OIDC\"),\n\t\t\tUserClaim:            pulumi.String(\"sub\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.FederatedSettingsIdentityProvider;\nimport com.pulumi.mongodbatlas.FederatedSettingsIdentityProviderArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var oidc = new FederatedSettingsIdentityProvider(\"oidc\", FederatedSettingsIdentityProviderArgs.builder()\n            .federationSettingsId(this_.id())\n            .audience(tokenAudience)\n            .authorizationType(\"USER\")\n            .description(\"oidc\")\n            .issuerUri(String.format(\"https://sts.windows.net/%s/\", thisAzurermUserAssignedIdentity.tenantId()))\n            .idpType(\"WORKLOAD\")\n            .name(\"OIDC-for-azure\")\n            .protocol(\"OIDC\")\n            .userClaim(\"sub\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  oidc:\n    type: mongodbatlas:FederatedSettingsIdentityProvider\n    properties:\n      federationSettingsId: ${this.id}\n      audience: ${tokenAudience}\n      authorizationType: USER\n      description: oidc\n      issuerUri: https://sts.windows.net/${thisAzurermUserAssignedIdentity.tenantId}/\n      idpType: WORKLOAD\n      name: OIDC-for-azure\n      protocol: OIDC\n      userClaim: sub\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nIdentity Provider __must__ be imported before using federation_settings_id-idp_id, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/federatedSettingsIdentityProvider:FederatedSettingsIdentityProvider identity_provider 6287a663c660f52b1c441c6c-0oad4fas87jL5Xnk12971234\n```\nFor more information see: [MongoDB Atlas API Reference.](https://www.mongodb.com/docs/atlas/reference/api/federation-configuration/)\n\n",
            "properties": {
                "associatedDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List that contains the domains associated with the identity provider.\n"
                },
                "audience": {
                    "type": "string",
                    "description": "Identifier of the intended recipient of the token used in OIDC IdP.\n"
                },
                "authorizationType": {
                    "type": "string",
                    "description": "Indicates whether authorization is granted based on group membership or user ID. Valid values are `GROUP` or `USER`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "Client identifier that is assigned to an application by the OIDC Identity Provider.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the identity provider.\n"
                },
                "federationSettingsId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                },
                "groupsClaim": {
                    "type": "string",
                    "description": "Identifier of the claim which contains OIDC IdP Group IDs in the token.\n"
                },
                "idpId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the IdP.\n"
                },
                "idpType": {
                    "type": "string"
                },
                "issuerUri": {
                    "type": "string",
                    "description": "Unique string that identifies the issuer of the IdP.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable label that identifies the identity provider.\n"
                },
                "oktaIdpId": {
                    "type": "string",
                    "description": "Unique 20-hexadecimal digit string that identifies the IdP.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "The protocol of the identity provider. Either `SAML` or `OIDC`.\n"
                },
                "requestBinding": {
                    "type": "string",
                    "description": "SAML Authentication Request Protocol HTTP method binding (`POST` or `REDIRECT`) that Federated Authentication uses to send the authentication request. Atlas supports the following binding values:\n- HTTP POST\n- HTTP REDIRECT\n"
                },
                "requestedScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Scopes that MongoDB applications will request from the authorization endpoint used for OIDC IdPs.\n"
                },
                "responseSignatureAlgorithm": {
                    "type": "string",
                    "description": "Signature algorithm that Federated Authentication uses to encrypt the identity provider signature.  Valid values include `SHA-1 `and `SHA-256`.\n"
                },
                "ssoDebugEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the identity provider has SSO debug enabled.\n"
                },
                "ssoUrl": {
                    "type": "string",
                    "description": "Unique string that identifies the intended audience of the SAML assertion.\n"
                },
                "status": {
                    "type": "string",
                    "description": "String enum that indicates whether the identity provider is active or not. Accepted values are ACTIVE or INACTIVE.\n"
                },
                "userClaim": {
                    "type": "string",
                    "description": "Identifier of the claim which contains the user ID in the token used for OIDC IdPs.\nuserClaim is required for OIDC IdP with authorizationType GROUP and USER.\n"
                }
            },
            "required": [
                "federationSettingsId",
                "idpId",
                "idpType",
                "issuerUri",
                "name",
                "oktaIdpId",
                "protocol"
            ],
            "inputProperties": {
                "associatedDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List that contains the domains associated with the identity provider.\n"
                },
                "audience": {
                    "type": "string",
                    "description": "Identifier of the intended recipient of the token used in OIDC IdP.\n"
                },
                "authorizationType": {
                    "type": "string",
                    "description": "Indicates whether authorization is granted based on group membership or user ID. Valid values are `GROUP` or `USER`.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "Client identifier that is assigned to an application by the OIDC Identity Provider.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the identity provider.\n"
                },
                "federationSettingsId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                },
                "groupsClaim": {
                    "type": "string",
                    "description": "Identifier of the claim which contains OIDC IdP Group IDs in the token.\n"
                },
                "idpType": {
                    "type": "string"
                },
                "issuerUri": {
                    "type": "string",
                    "description": "Unique string that identifies the issuer of the IdP.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable label that identifies the identity provider.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "The protocol of the identity provider. Either `SAML` or `OIDC`.\n"
                },
                "requestBinding": {
                    "type": "string",
                    "description": "SAML Authentication Request Protocol HTTP method binding (`POST` or `REDIRECT`) that Federated Authentication uses to send the authentication request. Atlas supports the following binding values:\n- HTTP POST\n- HTTP REDIRECT\n"
                },
                "requestedScopes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Scopes that MongoDB applications will request from the authorization endpoint used for OIDC IdPs.\n"
                },
                "responseSignatureAlgorithm": {
                    "type": "string",
                    "description": "Signature algorithm that Federated Authentication uses to encrypt the identity provider signature.  Valid values include `SHA-1 `and `SHA-256`.\n"
                },
                "ssoDebugEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the identity provider has SSO debug enabled.\n"
                },
                "ssoUrl": {
                    "type": "string",
                    "description": "Unique string that identifies the intended audience of the SAML assertion.\n"
                },
                "status": {
                    "type": "string",
                    "description": "String enum that indicates whether the identity provider is active or not. Accepted values are ACTIVE or INACTIVE.\n"
                },
                "userClaim": {
                    "type": "string",
                    "description": "Identifier of the claim which contains the user ID in the token used for OIDC IdPs.\nuserClaim is required for OIDC IdP with authorizationType GROUP and USER.\n"
                }
            },
            "requiredInputs": [
                "federationSettingsId",
                "issuerUri"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FederatedSettingsIdentityProvider resources.\n",
                "properties": {
                    "associatedDomains": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List that contains the domains associated with the identity provider.\n"
                    },
                    "audience": {
                        "type": "string",
                        "description": "Identifier of the intended recipient of the token used in OIDC IdP.\n"
                    },
                    "authorizationType": {
                        "type": "string",
                        "description": "Indicates whether authorization is granted based on group membership or user ID. Valid values are `GROUP` or `USER`.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "Client identifier that is assigned to an application by the OIDC Identity Provider.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the identity provider.\n"
                    },
                    "federationSettingsId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                    },
                    "groupsClaim": {
                        "type": "string",
                        "description": "Identifier of the claim which contains OIDC IdP Group IDs in the token.\n"
                    },
                    "idpId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the IdP.\n"
                    },
                    "idpType": {
                        "type": "string"
                    },
                    "issuerUri": {
                        "type": "string",
                        "description": "Unique string that identifies the issuer of the IdP.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Human-readable label that identifies the identity provider.\n"
                    },
                    "oktaIdpId": {
                        "type": "string",
                        "description": "Unique 20-hexadecimal digit string that identifies the IdP.\n"
                    },
                    "protocol": {
                        "type": "string",
                        "description": "The protocol of the identity provider. Either `SAML` or `OIDC`.\n"
                    },
                    "requestBinding": {
                        "type": "string",
                        "description": "SAML Authentication Request Protocol HTTP method binding (`POST` or `REDIRECT`) that Federated Authentication uses to send the authentication request. Atlas supports the following binding values:\n- HTTP POST\n- HTTP REDIRECT\n"
                    },
                    "requestedScopes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Scopes that MongoDB applications will request from the authorization endpoint used for OIDC IdPs.\n"
                    },
                    "responseSignatureAlgorithm": {
                        "type": "string",
                        "description": "Signature algorithm that Federated Authentication uses to encrypt the identity provider signature.  Valid values include `SHA-1 `and `SHA-256`.\n"
                    },
                    "ssoDebugEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether the identity provider has SSO debug enabled.\n"
                    },
                    "ssoUrl": {
                        "type": "string",
                        "description": "Unique string that identifies the intended audience of the SAML assertion.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "String enum that indicates whether the identity provider is active or not. Accepted values are ACTIVE or INACTIVE.\n"
                    },
                    "userClaim": {
                        "type": "string",
                        "description": "Identifier of the claim which contains the user ID in the token used for OIDC IdPs.\nuserClaim is required for OIDC IdP with authorizationType GROUP and USER.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/federatedSettingsOrgConfig:FederatedSettingsOrgConfig": {
            "description": "## # Resource: mongodbatlas.FederatedSettingsOrgConfig\n\n`mongodbatlas.FederatedSettingsOrgConfig` provides an Federated Settings Identity Providers datasource. Atlas Cloud Federated Settings Identity Providers provides federated settings outputs for the configured Identity Providers.\n\n## Example Usage\n\n\u003e **IMPORTANT** You **MUST** import this resource before you can manage it with this provider. \n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst orgConnection = new mongodbatlas.FederatedSettingsOrgConfig(\"org_connection\", {\n    federationSettingsId: \"627a9687f7f7f7f774de306f14\",\n    orgId: \"627a9683ea7ff7f74de306f14\",\n    dataAccessIdentityProviderIds: [\"64d613677e1ad50839cce4db\"],\n    domainRestrictionEnabled: false,\n    domainAllowLists: [\"mydomain.com\"],\n    postAuthRoleGrants: [\"ORG_MEMBER\"],\n    identityProviderId: \"0oaqyt9fc2ySTWnA0357\",\n});\nconst orgConfigsDs = mongodbatlas.getFederatedSettingsOrgConfigs({\n    federationSettingsId: orgConnectionMongodbatlasFederatedSettingsOrgConfig.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\norg_connection = mongodbatlas.FederatedSettingsOrgConfig(\"org_connection\",\n    federation_settings_id=\"627a9687f7f7f7f774de306f14\",\n    org_id=\"627a9683ea7ff7f74de306f14\",\n    data_access_identity_provider_ids=[\"64d613677e1ad50839cce4db\"],\n    domain_restriction_enabled=False,\n    domain_allow_lists=[\"mydomain.com\"],\n    post_auth_role_grants=[\"ORG_MEMBER\"],\n    identity_provider_id=\"0oaqyt9fc2ySTWnA0357\")\norg_configs_ds = mongodbatlas.get_federated_settings_org_configs(federation_settings_id=org_connection_mongodbatlas_federated_settings_org_config[\"id\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var orgConnection = new Mongodbatlas.FederatedSettingsOrgConfig(\"org_connection\", new()\n    {\n        FederationSettingsId = \"627a9687f7f7f7f774de306f14\",\n        OrgId = \"627a9683ea7ff7f74de306f14\",\n        DataAccessIdentityProviderIds = new[]\n        {\n            \"64d613677e1ad50839cce4db\",\n        },\n        DomainRestrictionEnabled = false,\n        DomainAllowLists = new[]\n        {\n            \"mydomain.com\",\n        },\n        PostAuthRoleGrants = new[]\n        {\n            \"ORG_MEMBER\",\n        },\n        IdentityProviderId = \"0oaqyt9fc2ySTWnA0357\",\n    });\n\n    var orgConfigsDs = Mongodbatlas.GetFederatedSettingsOrgConfigs.Invoke(new()\n    {\n        FederationSettingsId = orgConnectionMongodbatlasFederatedSettingsOrgConfig.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewFederatedSettingsOrgConfig(ctx, \"org_connection\", \u0026mongodbatlas.FederatedSettingsOrgConfigArgs{\n\t\t\tFederationSettingsId: pulumi.String(\"627a9687f7f7f7f774de306f14\"),\n\t\t\tOrgId:                pulumi.String(\"627a9683ea7ff7f74de306f14\"),\n\t\t\tDataAccessIdentityProviderIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"64d613677e1ad50839cce4db\"),\n\t\t\t},\n\t\t\tDomainRestrictionEnabled: pulumi.Bool(false),\n\t\t\tDomainAllowLists: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"mydomain.com\"),\n\t\t\t},\n\t\t\tPostAuthRoleGrants: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"ORG_MEMBER\"),\n\t\t\t},\n\t\t\tIdentityProviderId: pulumi.String(\"0oaqyt9fc2ySTWnA0357\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.LookupFederatedSettingsOrgConfigs(ctx, \u0026mongodbatlas.LookupFederatedSettingsOrgConfigsArgs{\n\t\t\tFederationSettingsId: orgConnectionMongodbatlasFederatedSettingsOrgConfig.Id,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.FederatedSettingsOrgConfig;\nimport com.pulumi.mongodbatlas.FederatedSettingsOrgConfigArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetFederatedSettingsOrgConfigsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var orgConnection = new FederatedSettingsOrgConfig(\"orgConnection\", FederatedSettingsOrgConfigArgs.builder()\n            .federationSettingsId(\"627a9687f7f7f7f774de306f14\")\n            .orgId(\"627a9683ea7ff7f74de306f14\")\n            .dataAccessIdentityProviderIds(\"64d613677e1ad50839cce4db\")\n            .domainRestrictionEnabled(false)\n            .domainAllowLists(\"mydomain.com\")\n            .postAuthRoleGrants(\"ORG_MEMBER\")\n            .identityProviderId(\"0oaqyt9fc2ySTWnA0357\")\n            .build());\n\n        final var orgConfigsDs = MongodbatlasFunctions.getFederatedSettingsOrgConfigs(GetFederatedSettingsOrgConfigsArgs.builder()\n            .federationSettingsId(orgConnectionMongodbatlasFederatedSettingsOrgConfig.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  orgConnection:\n    type: mongodbatlas:FederatedSettingsOrgConfig\n    name: org_connection\n    properties:\n      federationSettingsId: 627a9687f7f7f7f774de306f14\n      orgId: 627a9683ea7ff7f74de306f14\n      dataAccessIdentityProviderIds:\n        - 64d613677e1ad50839cce4db\n      domainRestrictionEnabled: false\n      domainAllowLists:\n        - mydomain.com\n      postAuthRoleGrants:\n        - ORG_MEMBER\n      identityProviderId: 0oaqyt9fc2ySTWnA0357\nvariables:\n  orgConfigsDs:\n    fn::invoke:\n      Function: mongodbatlas:getFederatedSettingsOrgConfigs\n      Arguments:\n        federationSettingsId: ${orgConnectionMongodbatlasFederatedSettingsOrgConfig.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nFederatedSettingsOrgConfig must be imported using federation_settings_id-org_id, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/federatedSettingsOrgConfig:FederatedSettingsOrgConfig org_connection 627a9687f7f7f7f774de306f14-627a9683ea7ff7f74de306f14\n```\nFor more information see: [MongoDB Atlas API Reference.](https://www.mongodb.com/docs/atlas/reference/api/federation-configuration/)\n\n",
            "properties": {
                "dataAccessIdentityProviderIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The collection of unique ids representing the identity providers that can be used for data access in this organization.\n"
                },
                "domainAllowLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List that contains the approved domains from which organization users can log in.\n"
                },
                "domainRestrictionEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether domain restriction is enabled for the connected organization.\n"
                },
                "federationSettingsId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "Legacy 20-hexadecimal digit string that identifies the SAML access identity provider that this connected org config is associated with. Removing the attribute or providing the value `\"\"` will detach/remove the SAML identity provider. This id can be found in two ways:\n1. Within the Federation Management UI in Atlas in the Identity Providers tab by clicking the info icon in the IdP ID row of a configured SAML identity provider\n2. `okta_idp_id` on the `mongodbatlas.FederatedSettingsIdentityProvider` resource\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                },
                "postAuthRoleGrants": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List that contains the default [roles](https://www.mongodb.com/docs/atlas/reference/user-roles/#std-label-organization-roles) granted to users who authenticate through the IdP in a connected organization.\n"
                },
                "userConflicts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/FederatedSettingsOrgConfigUserConflict:FederatedSettingsOrgConfigUserConflict"
                    },
                    "description": "List that contains the users who have an email address that doesn't match any domain on the allowed list. See below\n"
                }
            },
            "required": [
                "domainRestrictionEnabled",
                "federationSettingsId",
                "orgId",
                "userConflicts"
            ],
            "inputProperties": {
                "dataAccessIdentityProviderIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The collection of unique ids representing the identity providers that can be used for data access in this organization.\n"
                },
                "domainAllowLists": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List that contains the approved domains from which organization users can log in.\n"
                },
                "domainRestrictionEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether domain restriction is enabled for the connected organization.\n"
                },
                "federationSettingsId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                },
                "identityProviderId": {
                    "type": "string",
                    "description": "Legacy 20-hexadecimal digit string that identifies the SAML access identity provider that this connected org config is associated with. Removing the attribute or providing the value `\"\"` will detach/remove the SAML identity provider. This id can be found in two ways:\n1. Within the Federation Management UI in Atlas in the Identity Providers tab by clicking the info icon in the IdP ID row of a configured SAML identity provider\n2. `okta_idp_id` on the `mongodbatlas.FederatedSettingsIdentityProvider` resource\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                },
                "postAuthRoleGrants": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List that contains the default [roles](https://www.mongodb.com/docs/atlas/reference/user-roles/#std-label-organization-roles) granted to users who authenticate through the IdP in a connected organization.\n"
                }
            },
            "requiredInputs": [
                "domainRestrictionEnabled",
                "federationSettingsId",
                "orgId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FederatedSettingsOrgConfig resources.\n",
                "properties": {
                    "dataAccessIdentityProviderIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The collection of unique ids representing the identity providers that can be used for data access in this organization.\n"
                    },
                    "domainAllowLists": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List that contains the approved domains from which organization users can log in.\n"
                    },
                    "domainRestrictionEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether domain restriction is enabled for the connected organization.\n"
                    },
                    "federationSettingsId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                    },
                    "identityProviderId": {
                        "type": "string",
                        "description": "Legacy 20-hexadecimal digit string that identifies the SAML access identity provider that this connected org config is associated with. Removing the attribute or providing the value `\"\"` will detach/remove the SAML identity provider. This id can be found in two ways:\n1. Within the Federation Management UI in Atlas in the Identity Providers tab by clicking the info icon in the IdP ID row of a configured SAML identity provider\n2. `okta_idp_id` on the `mongodbatlas.FederatedSettingsIdentityProvider` resource\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                    },
                    "postAuthRoleGrants": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List that contains the default [roles](https://www.mongodb.com/docs/atlas/reference/user-roles/#std-label-organization-roles) granted to users who authenticate through the IdP in a connected organization.\n"
                    },
                    "userConflicts": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/FederatedSettingsOrgConfigUserConflict:FederatedSettingsOrgConfigUserConflict"
                        },
                        "description": "List that contains the users who have an email address that doesn't match any domain on the allowed list. See below\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/federatedSettingsOrgRoleMapping:FederatedSettingsOrgRoleMapping": {
            "description": "## # Resource: mongodbatlas.FederatedSettingsOrgRoleMapping\n\n`mongodbatlas.FederatedSettingsOrgRoleMapping` provides an Role Mapping resource. This allows organization role mapping to be created.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst orgGroupRoleMappingImport = new mongodbatlas.FederatedSettingsOrgRoleMapping(\"org_group_role_mapping_import\", {\n    federationSettingsId: \"627a9687f7f7f7f774de306f14\",\n    orgId: \"627a9683e7f7f7ff7fe306f14\",\n    externalGroupName: \"myGrouptest\",\n    roleAssignments: [\n        {\n            orgId: \"627a9683e7f7f7ff7fe306f14\",\n            roles: [\n                \"ORG_MEMBER\",\n                \"ORG_GROUP_CREATOR\",\n                \"ORG_BILLING_ADMIN\",\n            ],\n        },\n        {\n            groupId: \"628aa20d7f7f7f7f7098b81b8\",\n            roles: [\n                \"GROUP_OWNER\",\n                \"GROUP_DATA_ACCESS_ADMIN\",\n                \"GROUP_SEARCH_INDEX_EDITOR\",\n                \"GROUP_DATA_ACCESS_READ_ONLY\",\n            ],\n        },\n        {\n            groupId: \"628aa20d7f7f7f7f7078b81b8\",\n            roles: [\n                \"GROUP_OWNER\",\n                \"GROUP_DATA_ACCESS_ADMIN\",\n                \"GROUP_SEARCH_INDEX_EDITOR\",\n                \"GROUP_DATA_ACCESS_READ_ONLY\",\n                \"GROUP_DATA_ACCESS_READ_WRITE\",\n            ],\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\norg_group_role_mapping_import = mongodbatlas.FederatedSettingsOrgRoleMapping(\"org_group_role_mapping_import\",\n    federation_settings_id=\"627a9687f7f7f7f774de306f14\",\n    org_id=\"627a9683e7f7f7ff7fe306f14\",\n    external_group_name=\"myGrouptest\",\n    role_assignments=[\n        {\n            \"org_id\": \"627a9683e7f7f7ff7fe306f14\",\n            \"roles\": [\n                \"ORG_MEMBER\",\n                \"ORG_GROUP_CREATOR\",\n                \"ORG_BILLING_ADMIN\",\n            ],\n        },\n        {\n            \"group_id\": \"628aa20d7f7f7f7f7098b81b8\",\n            \"roles\": [\n                \"GROUP_OWNER\",\n                \"GROUP_DATA_ACCESS_ADMIN\",\n                \"GROUP_SEARCH_INDEX_EDITOR\",\n                \"GROUP_DATA_ACCESS_READ_ONLY\",\n            ],\n        },\n        {\n            \"group_id\": \"628aa20d7f7f7f7f7078b81b8\",\n            \"roles\": [\n                \"GROUP_OWNER\",\n                \"GROUP_DATA_ACCESS_ADMIN\",\n                \"GROUP_SEARCH_INDEX_EDITOR\",\n                \"GROUP_DATA_ACCESS_READ_ONLY\",\n                \"GROUP_DATA_ACCESS_READ_WRITE\",\n            ],\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var orgGroupRoleMappingImport = new Mongodbatlas.FederatedSettingsOrgRoleMapping(\"org_group_role_mapping_import\", new()\n    {\n        FederationSettingsId = \"627a9687f7f7f7f774de306f14\",\n        OrgId = \"627a9683e7f7f7ff7fe306f14\",\n        ExternalGroupName = \"myGrouptest\",\n        RoleAssignments = new[]\n        {\n            new Mongodbatlas.Inputs.FederatedSettingsOrgRoleMappingRoleAssignmentArgs\n            {\n                OrgId = \"627a9683e7f7f7ff7fe306f14\",\n                Roles = new[]\n                {\n                    \"ORG_MEMBER\",\n                    \"ORG_GROUP_CREATOR\",\n                    \"ORG_BILLING_ADMIN\",\n                },\n            },\n            new Mongodbatlas.Inputs.FederatedSettingsOrgRoleMappingRoleAssignmentArgs\n            {\n                GroupId = \"628aa20d7f7f7f7f7098b81b8\",\n                Roles = new[]\n                {\n                    \"GROUP_OWNER\",\n                    \"GROUP_DATA_ACCESS_ADMIN\",\n                    \"GROUP_SEARCH_INDEX_EDITOR\",\n                    \"GROUP_DATA_ACCESS_READ_ONLY\",\n                },\n            },\n            new Mongodbatlas.Inputs.FederatedSettingsOrgRoleMappingRoleAssignmentArgs\n            {\n                GroupId = \"628aa20d7f7f7f7f7078b81b8\",\n                Roles = new[]\n                {\n                    \"GROUP_OWNER\",\n                    \"GROUP_DATA_ACCESS_ADMIN\",\n                    \"GROUP_SEARCH_INDEX_EDITOR\",\n                    \"GROUP_DATA_ACCESS_READ_ONLY\",\n                    \"GROUP_DATA_ACCESS_READ_WRITE\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewFederatedSettingsOrgRoleMapping(ctx, \"org_group_role_mapping_import\", \u0026mongodbatlas.FederatedSettingsOrgRoleMappingArgs{\n\t\t\tFederationSettingsId: pulumi.String(\"627a9687f7f7f7f774de306f14\"),\n\t\t\tOrgId:                pulumi.String(\"627a9683e7f7f7ff7fe306f14\"),\n\t\t\tExternalGroupName:    pulumi.String(\"myGrouptest\"),\n\t\t\tRoleAssignments: mongodbatlas.FederatedSettingsOrgRoleMappingRoleAssignmentArray{\n\t\t\t\t\u0026mongodbatlas.FederatedSettingsOrgRoleMappingRoleAssignmentArgs{\n\t\t\t\t\tOrgId: pulumi.String(\"627a9683e7f7f7ff7fe306f14\"),\n\t\t\t\t\tRoles: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"ORG_MEMBER\"),\n\t\t\t\t\t\tpulumi.String(\"ORG_GROUP_CREATOR\"),\n\t\t\t\t\t\tpulumi.String(\"ORG_BILLING_ADMIN\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.FederatedSettingsOrgRoleMappingRoleAssignmentArgs{\n\t\t\t\t\tGroupId: pulumi.String(\"628aa20d7f7f7f7f7098b81b8\"),\n\t\t\t\t\tRoles: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_OWNER\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_ADMIN\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_SEARCH_INDEX_EDITOR\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_READ_ONLY\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.FederatedSettingsOrgRoleMappingRoleAssignmentArgs{\n\t\t\t\t\tGroupId: pulumi.String(\"628aa20d7f7f7f7f7078b81b8\"),\n\t\t\t\t\tRoles: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_OWNER\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_ADMIN\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_SEARCH_INDEX_EDITOR\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_READ_ONLY\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_READ_WRITE\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.FederatedSettingsOrgRoleMapping;\nimport com.pulumi.mongodbatlas.FederatedSettingsOrgRoleMappingArgs;\nimport com.pulumi.mongodbatlas.inputs.FederatedSettingsOrgRoleMappingRoleAssignmentArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var orgGroupRoleMappingImport = new FederatedSettingsOrgRoleMapping(\"orgGroupRoleMappingImport\", FederatedSettingsOrgRoleMappingArgs.builder()\n            .federationSettingsId(\"627a9687f7f7f7f774de306f14\")\n            .orgId(\"627a9683e7f7f7ff7fe306f14\")\n            .externalGroupName(\"myGrouptest\")\n            .roleAssignments(            \n                FederatedSettingsOrgRoleMappingRoleAssignmentArgs.builder()\n                    .orgId(\"627a9683e7f7f7ff7fe306f14\")\n                    .roles(                    \n                        \"ORG_MEMBER\",\n                        \"ORG_GROUP_CREATOR\",\n                        \"ORG_BILLING_ADMIN\")\n                    .build(),\n                FederatedSettingsOrgRoleMappingRoleAssignmentArgs.builder()\n                    .groupId(\"628aa20d7f7f7f7f7098b81b8\")\n                    .roles(                    \n                        \"GROUP_OWNER\",\n                        \"GROUP_DATA_ACCESS_ADMIN\",\n                        \"GROUP_SEARCH_INDEX_EDITOR\",\n                        \"GROUP_DATA_ACCESS_READ_ONLY\")\n                    .build(),\n                FederatedSettingsOrgRoleMappingRoleAssignmentArgs.builder()\n                    .groupId(\"628aa20d7f7f7f7f7078b81b8\")\n                    .roles(                    \n                        \"GROUP_OWNER\",\n                        \"GROUP_DATA_ACCESS_ADMIN\",\n                        \"GROUP_SEARCH_INDEX_EDITOR\",\n                        \"GROUP_DATA_ACCESS_READ_ONLY\",\n                        \"GROUP_DATA_ACCESS_READ_WRITE\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  orgGroupRoleMappingImport:\n    type: mongodbatlas:FederatedSettingsOrgRoleMapping\n    name: org_group_role_mapping_import\n    properties:\n      federationSettingsId: 627a9687f7f7f7f774de306f14\n      orgId: 627a9683e7f7f7ff7fe306f14\n      externalGroupName: myGrouptest\n      roleAssignments:\n        - orgId: 627a9683e7f7f7ff7fe306f14\n          roles:\n            - ORG_MEMBER\n            - ORG_GROUP_CREATOR\n            - ORG_BILLING_ADMIN\n        - groupId: 628aa20d7f7f7f7f7098b81b8\n          roles:\n            - GROUP_OWNER\n            - GROUP_DATA_ACCESS_ADMIN\n            - GROUP_SEARCH_INDEX_EDITOR\n            - GROUP_DATA_ACCESS_READ_ONLY\n        - groupId: 628aa20d7f7f7f7f7078b81b8\n          roles:\n            - GROUP_OWNER\n            - GROUP_DATA_ACCESS_ADMIN\n            - GROUP_SEARCH_INDEX_EDITOR\n            - GROUP_DATA_ACCESS_READ_ONLY\n            - GROUP_DATA_ACCESS_READ_WRITE\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nFederatedSettingsOrgRoleMapping can be imported using federation_settings_id-org_id-role_mapping_id, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/federatedSettingsOrgRoleMapping:FederatedSettingsOrgRoleMapping org_group_role_mapping_import 6287a663c7f7f7f71c441c6c-627a96837f7f7f7e306f14-628ae97f7f7468ea3727\n```\nFor more information see: [MongoDB Atlas API Reference.](https://www.mongodb.com/docs/atlas/reference/api/federation-configuration/)\n\n",
            "properties": {
                "externalGroupName": {
                    "type": "string",
                    "description": "Unique human-readable label that identifies the identity provider group to which this role mapping applies.\n"
                },
                "federationSettingsId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                },
                "roleAssignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/FederatedSettingsOrgRoleMappingRoleAssignment:FederatedSettingsOrgRoleMappingRoleAssignment"
                    },
                    "description": "Atlas roles and the unique identifiers of the groups and organizations associated with each role.\n"
                },
                "roleMappingId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies this role mapping.\n"
                }
            },
            "required": [
                "externalGroupName",
                "federationSettingsId",
                "orgId",
                "roleAssignments",
                "roleMappingId"
            ],
            "inputProperties": {
                "externalGroupName": {
                    "type": "string",
                    "description": "Unique human-readable label that identifies the identity provider group to which this role mapping applies.\n"
                },
                "federationSettingsId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                },
                "roleAssignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/FederatedSettingsOrgRoleMappingRoleAssignment:FederatedSettingsOrgRoleMappingRoleAssignment"
                    },
                    "description": "Atlas roles and the unique identifiers of the groups and organizations associated with each role.\n"
                }
            },
            "requiredInputs": [
                "externalGroupName",
                "federationSettingsId",
                "orgId",
                "roleAssignments"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FederatedSettingsOrgRoleMapping resources.\n",
                "properties": {
                    "externalGroupName": {
                        "type": "string",
                        "description": "Unique human-readable label that identifies the identity provider group to which this role mapping applies.\n"
                    },
                    "federationSettingsId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                    },
                    "roleAssignments": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/FederatedSettingsOrgRoleMappingRoleAssignment:FederatedSettingsOrgRoleMappingRoleAssignment"
                        },
                        "description": "Atlas roles and the unique identifiers of the groups and organizations associated with each role.\n"
                    },
                    "roleMappingId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies this role mapping.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/globalClusterConfig:GlobalClusterConfig": {
            "description": "## # Resource: mongodbatlas.GlobalClusterConfig\n\n`mongodbatlas.GlobalClusterConfig` provides a Global Cluster Configuration resource.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n\u003e **NOTE:** This resource can only be used with Atlas-managed clusters. See doc for `global_cluster_self_managed_sharding` attribute in `mongodbatlas.AdvancedCluster` resource for more info.\n\n\u003e **IMPORTANT:** A Global Cluster Configuration, once created, can only be deleted. You can recreate the Global Cluster with the same data only in the Atlas UI. This is because the configuration and its related collection with shard key and indexes are managed separately and they would end up in an inconsistent state. [Read more about Global Cluster Configuration](https://www.mongodb.com/docs/atlas/global-clusters/)\n\n## Examples Usage\n\n### Example Global cluster\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.AdvancedCluster(\"test\", {\n    projectId: \"\u003cYOUR-PROJECT-ID\u003e\",\n    name: \"\u003cCLUSTER-NAME\u003e\",\n    clusterType: \"GEOSHARDED\",\n    backupEnabled: true,\n    replicationSpecs: [\n        {\n            zoneName: \"Zone 1\",\n            regionConfigs: [{\n                electableSpecs: {\n                    instanceSize: \"M30\",\n                    nodeCount: 3,\n                },\n                providerName: \"AWS\",\n                priority: 7,\n                regionName: \"EU_CENTRAL_1\",\n            }],\n        },\n        {\n            zoneName: \"Zone 2\",\n            regionConfigs: [{\n                electableSpecs: {\n                    instanceSize: \"M30\",\n                    nodeCount: 3,\n                },\n                providerName: \"AWS\",\n                priority: 7,\n                regionName: \"US_EAST_2\",\n            }],\n        },\n    ],\n});\nconst config = new mongodbatlas.GlobalClusterConfig(\"config\", {\n    projectId: test.projectId,\n    clusterName: test.name,\n    managedNamespaces: [{\n        db: \"mydata\",\n        collection: \"publishers\",\n        customShardKey: \"city\",\n        isCustomShardKeyHashed: false,\n        isShardKeyUnique: false,\n    }],\n    customZoneMappings: [{\n        location: \"CA\",\n        zone: \"Zone 1\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.AdvancedCluster(\"test\",\n    project_id=\"\u003cYOUR-PROJECT-ID\u003e\",\n    name=\"\u003cCLUSTER-NAME\u003e\",\n    cluster_type=\"GEOSHARDED\",\n    backup_enabled=True,\n    replication_specs=[\n        {\n            \"zone_name\": \"Zone 1\",\n            \"region_configs\": [{\n                \"electable_specs\": {\n                    \"instance_size\": \"M30\",\n                    \"node_count\": 3,\n                },\n                \"provider_name\": \"AWS\",\n                \"priority\": 7,\n                \"region_name\": \"EU_CENTRAL_1\",\n            }],\n        },\n        {\n            \"zone_name\": \"Zone 2\",\n            \"region_configs\": [{\n                \"electable_specs\": {\n                    \"instance_size\": \"M30\",\n                    \"node_count\": 3,\n                },\n                \"provider_name\": \"AWS\",\n                \"priority\": 7,\n                \"region_name\": \"US_EAST_2\",\n            }],\n        },\n    ])\nconfig = mongodbatlas.GlobalClusterConfig(\"config\",\n    project_id=test.project_id,\n    cluster_name=test.name,\n    managed_namespaces=[{\n        \"db\": \"mydata\",\n        \"collection\": \"publishers\",\n        \"custom_shard_key\": \"city\",\n        \"is_custom_shard_key_hashed\": False,\n        \"is_shard_key_unique\": False,\n    }],\n    custom_zone_mappings=[{\n        \"location\": \"CA\",\n        \"zone\": \"Zone 1\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.AdvancedCluster(\"test\", new()\n    {\n        ProjectId = \"\u003cYOUR-PROJECT-ID\u003e\",\n        Name = \"\u003cCLUSTER-NAME\u003e\",\n        ClusterType = \"GEOSHARDED\",\n        BackupEnabled = true,\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                ZoneName = \"Zone 1\",\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M30\",\n                            NodeCount = 3,\n                        },\n                        ProviderName = \"AWS\",\n                        Priority = 7,\n                        RegionName = \"EU_CENTRAL_1\",\n                    },\n                },\n            },\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                ZoneName = \"Zone 2\",\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M30\",\n                            NodeCount = 3,\n                        },\n                        ProviderName = \"AWS\",\n                        Priority = 7,\n                        RegionName = \"US_EAST_2\",\n                    },\n                },\n            },\n        },\n    });\n\n    var config = new Mongodbatlas.GlobalClusterConfig(\"config\", new()\n    {\n        ProjectId = test.ProjectId,\n        ClusterName = test.Name,\n        ManagedNamespaces = new[]\n        {\n            new Mongodbatlas.Inputs.GlobalClusterConfigManagedNamespaceArgs\n            {\n                Db = \"mydata\",\n                Collection = \"publishers\",\n                CustomShardKey = \"city\",\n                IsCustomShardKeyHashed = false,\n                IsShardKeyUnique = false,\n            },\n        },\n        CustomZoneMappings = new[]\n        {\n            new Mongodbatlas.Inputs.GlobalClusterConfigCustomZoneMappingArgs\n            {\n                Location = \"CA\",\n                Zone = \"Zone 1\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := mongodbatlas.NewAdvancedCluster(ctx, \"test\", \u0026mongodbatlas.AdvancedClusterArgs{\n\t\t\tProjectId:     pulumi.String(\"\u003cYOUR-PROJECT-ID\u003e\"),\n\t\t\tName:          pulumi.String(\"\u003cCLUSTER-NAME\u003e\"),\n\t\t\tClusterType:   pulumi.String(\"GEOSHARDED\"),\n\t\t\tBackupEnabled: pulumi.Bool(true),\n\t\t\tReplicationSpecs: mongodbatlas.AdvancedClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tZoneName: pulumi.String(\"Zone 1\"),\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M30\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(3),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tPriority:     pulumi.Int(7),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"EU_CENTRAL_1\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tZoneName: pulumi.String(\"Zone 2\"),\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M30\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(3),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tPriority:     pulumi.Int(7),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"US_EAST_2\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewGlobalClusterConfig(ctx, \"config\", \u0026mongodbatlas.GlobalClusterConfigArgs{\n\t\t\tProjectId:   test.ProjectId,\n\t\t\tClusterName: test.Name,\n\t\t\tManagedNamespaces: mongodbatlas.GlobalClusterConfigManagedNamespaceArray{\n\t\t\t\t\u0026mongodbatlas.GlobalClusterConfigManagedNamespaceArgs{\n\t\t\t\t\tDb:                     pulumi.String(\"mydata\"),\n\t\t\t\t\tCollection:             pulumi.String(\"publishers\"),\n\t\t\t\t\tCustomShardKey:         pulumi.String(\"city\"),\n\t\t\t\t\tIsCustomShardKeyHashed: pulumi.Bool(false),\n\t\t\t\t\tIsShardKeyUnique:       pulumi.Bool(false),\n\t\t\t\t},\n\t\t\t},\n\t\t\tCustomZoneMappings: mongodbatlas.GlobalClusterConfigCustomZoneMappingArray{\n\t\t\t\t\u0026mongodbatlas.GlobalClusterConfigCustomZoneMappingArgs{\n\t\t\t\t\tLocation: pulumi.String(\"CA\"),\n\t\t\t\t\tZone:     pulumi.String(\"Zone 1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AdvancedCluster;\nimport com.pulumi.mongodbatlas.AdvancedClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.AdvancedClusterReplicationSpecArgs;\nimport com.pulumi.mongodbatlas.GlobalClusterConfig;\nimport com.pulumi.mongodbatlas.GlobalClusterConfigArgs;\nimport com.pulumi.mongodbatlas.inputs.GlobalClusterConfigManagedNamespaceArgs;\nimport com.pulumi.mongodbatlas.inputs.GlobalClusterConfigCustomZoneMappingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new AdvancedCluster(\"test\", AdvancedClusterArgs.builder()\n            .projectId(\"\u003cYOUR-PROJECT-ID\u003e\")\n            .name(\"\u003cCLUSTER-NAME\u003e\")\n            .clusterType(\"GEOSHARDED\")\n            .backupEnabled(true)\n            .replicationSpecs(            \n                AdvancedClusterReplicationSpecArgs.builder()\n                    .zoneName(\"Zone 1\")\n                    .regionConfigs(AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                        .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                            .instanceSize(\"M30\")\n                            .nodeCount(3)\n                            .build())\n                        .providerName(\"AWS\")\n                        .priority(7)\n                        .regionName(\"EU_CENTRAL_1\")\n                        .build())\n                    .build(),\n                AdvancedClusterReplicationSpecArgs.builder()\n                    .zoneName(\"Zone 2\")\n                    .regionConfigs(AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                        .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                            .instanceSize(\"M30\")\n                            .nodeCount(3)\n                            .build())\n                        .providerName(\"AWS\")\n                        .priority(7)\n                        .regionName(\"US_EAST_2\")\n                        .build())\n                    .build())\n            .build());\n\n        var config = new GlobalClusterConfig(\"config\", GlobalClusterConfigArgs.builder()\n            .projectId(test.projectId())\n            .clusterName(test.name())\n            .managedNamespaces(GlobalClusterConfigManagedNamespaceArgs.builder()\n                .db(\"mydata\")\n                .collection(\"publishers\")\n                .customShardKey(\"city\")\n                .isCustomShardKeyHashed(false)\n                .isShardKeyUnique(false)\n                .build())\n            .customZoneMappings(GlobalClusterConfigCustomZoneMappingArgs.builder()\n                .location(\"CA\")\n                .zone(\"Zone 1\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:AdvancedCluster\n    properties:\n      projectId: \u003cYOUR-PROJECT-ID\u003e\n      name: \u003cCLUSTER-NAME\u003e\n      clusterType: GEOSHARDED\n      backupEnabled: true\n      replicationSpecs:\n        - zoneName: Zone 1\n          regionConfigs:\n            - electableSpecs:\n                instanceSize: M30\n                nodeCount: 3\n              providerName: AWS\n              priority: 7\n              regionName: EU_CENTRAL_1\n        - zoneName: Zone 2\n          regionConfigs:\n            - electableSpecs:\n                instanceSize: M30\n                nodeCount: 3\n              providerName: AWS\n              priority: 7\n              regionName: US_EAST_2\n  config:\n    type: mongodbatlas:GlobalClusterConfig\n    properties:\n      projectId: ${test.projectId}\n      clusterName: ${test.name}\n      managedNamespaces:\n        - db: mydata\n          collection: publishers\n          customShardKey: city\n          isCustomShardKeyHashed: false\n          isShardKeyUnique: false\n      customZoneMappings:\n        - location: CA\n          zone: Zone 1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nGlobal Clusters can be imported using project ID and cluster name, in the format `PROJECTID-CLUSTER_NAME`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/globalClusterConfig:GlobalClusterConfig config 1112222b3bf99403840e8934-Cluster0\n```\nSee detailed information for arguments and attributes: [MongoDB API Global Clusters](https://docs.atlas.mongodb.com/reference/api/global-clusters/)\n\n",
            "properties": {
                "clusterName": {
                    "type": "string",
                    "description": "The name of the Global Cluster.\n"
                },
                "customZoneMapping": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of all custom zone mappings defined for the Global Cluster. Atlas automatically maps each location code to the closest geographical zone. Custom zone mappings allow administrators to override these automatic mappings. If your Global Cluster does not have any custom zone mappings, this document is empty.\n"
                },
                "customZoneMappings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/GlobalClusterConfigCustomZoneMapping:GlobalClusterConfigCustomZoneMapping"
                    },
                    "description": "Each element in the list maps one ISO location code to a zone in your Global Cluster. See Custom Zone Mapping below for more details.\n"
                },
                "managedNamespaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/GlobalClusterConfigManagedNamespace:GlobalClusterConfigManagedNamespace"
                    },
                    "description": "Add a managed namespaces to a Global Cluster. For more information about managed namespaces, see [Global Clusters](https://docs.atlas.mongodb.com/reference/api/global-clusters/). See Managed Namespace below for more details.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create the database user.\n"
                }
            },
            "required": [
                "clusterName",
                "customZoneMapping",
                "managedNamespaces",
                "projectId"
            ],
            "inputProperties": {
                "clusterName": {
                    "type": "string",
                    "description": "The name of the Global Cluster.\n",
                    "willReplaceOnChanges": true
                },
                "customZoneMappings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/GlobalClusterConfigCustomZoneMapping:GlobalClusterConfigCustomZoneMapping"
                    },
                    "description": "Each element in the list maps one ISO location code to a zone in your Global Cluster. See Custom Zone Mapping below for more details.\n"
                },
                "managedNamespaces": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/GlobalClusterConfigManagedNamespace:GlobalClusterConfigManagedNamespace"
                    },
                    "description": "Add a managed namespaces to a Global Cluster. For more information about managed namespaces, see [Global Clusters](https://docs.atlas.mongodb.com/reference/api/global-clusters/). See Managed Namespace below for more details.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to create the database user.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "clusterName",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering GlobalClusterConfig resources.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the Global Cluster.\n",
                        "willReplaceOnChanges": true
                    },
                    "customZoneMapping": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of all custom zone mappings defined for the Global Cluster. Atlas automatically maps each location code to the closest geographical zone. Custom zone mappings allow administrators to override these automatic mappings. If your Global Cluster does not have any custom zone mappings, this document is empty.\n"
                    },
                    "customZoneMappings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/GlobalClusterConfigCustomZoneMapping:GlobalClusterConfigCustomZoneMapping"
                        },
                        "description": "Each element in the list maps one ISO location code to a zone in your Global Cluster. See Custom Zone Mapping below for more details.\n"
                    },
                    "managedNamespaces": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/GlobalClusterConfigManagedNamespace:GlobalClusterConfigManagedNamespace"
                        },
                        "description": "Add a managed namespaces to a Global Cluster. For more information about managed namespaces, see [Global Clusters](https://docs.atlas.mongodb.com/reference/api/global-clusters/). See Managed Namespace below for more details.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the database user.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/ldapConfiguration:LdapConfiguration": {
            "description": "## # Resource: mongodbatlas.LdapConfiguration\n\n`mongodbatlas.LdapConfiguration` provides an LDAP Configuration resource. This allows an LDAP configuration for an Atlas project to be created and managed. This endpoint doesnât verify connectivity using the provided LDAP over TLS configuration details. To verify a configuration before saving it, use the resource to verify the LDAP configuration.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.Project(\"test\", {\n    name: \"NAME OF THE PROJECT\",\n    orgId: \"ORG ID\",\n});\nconst testLdapConfiguration = new mongodbatlas.LdapConfiguration(\"test\", {\n    projectId: test.id,\n    authenticationEnabled: true,\n    hostname: \"HOSTNAME\",\n    port: 636,\n    bindUsername: \"USERNAME\",\n    bindPassword: \"PASSWORD\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.Project(\"test\",\n    name=\"NAME OF THE PROJECT\",\n    org_id=\"ORG ID\")\ntest_ldap_configuration = mongodbatlas.LdapConfiguration(\"test\",\n    project_id=test.id,\n    authentication_enabled=True,\n    hostname=\"HOSTNAME\",\n    port=636,\n    bind_username=\"USERNAME\",\n    bind_password=\"PASSWORD\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.Project(\"test\", new()\n    {\n        Name = \"NAME OF THE PROJECT\",\n        OrgId = \"ORG ID\",\n    });\n\n    var testLdapConfiguration = new Mongodbatlas.LdapConfiguration(\"test\", new()\n    {\n        ProjectId = test.Id,\n        AuthenticationEnabled = true,\n        Hostname = \"HOSTNAME\",\n        Port = 636,\n        BindUsername = \"USERNAME\",\n        BindPassword = \"PASSWORD\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := mongodbatlas.NewProject(ctx, \"test\", \u0026mongodbatlas.ProjectArgs{\n\t\t\tName:  pulumi.String(\"NAME OF THE PROJECT\"),\n\t\t\tOrgId: pulumi.String(\"ORG ID\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewLdapConfiguration(ctx, \"test\", \u0026mongodbatlas.LdapConfigurationArgs{\n\t\t\tProjectId:             test.ID(),\n\t\t\tAuthenticationEnabled: pulumi.Bool(true),\n\t\t\tHostname:              pulumi.String(\"HOSTNAME\"),\n\t\t\tPort:                  pulumi.Int(636),\n\t\t\tBindUsername:          pulumi.String(\"USERNAME\"),\n\t\t\tBindPassword:          pulumi.String(\"PASSWORD\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Project;\nimport com.pulumi.mongodbatlas.ProjectArgs;\nimport com.pulumi.mongodbatlas.LdapConfiguration;\nimport com.pulumi.mongodbatlas.LdapConfigurationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new Project(\"test\", ProjectArgs.builder()\n            .name(\"NAME OF THE PROJECT\")\n            .orgId(\"ORG ID\")\n            .build());\n\n        var testLdapConfiguration = new LdapConfiguration(\"testLdapConfiguration\", LdapConfigurationArgs.builder()\n            .projectId(test.id())\n            .authenticationEnabled(true)\n            .hostname(\"HOSTNAME\")\n            .port(636)\n            .bindUsername(\"USERNAME\")\n            .bindPassword(\"PASSWORD\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:Project\n    properties:\n      name: NAME OF THE PROJECT\n      orgId: ORG ID\n  testLdapConfiguration:\n    type: mongodbatlas:LdapConfiguration\n    name: test\n    properties:\n      projectId: ${test.id}\n      authenticationEnabled: true\n      hostname: HOSTNAME\n      port: 636\n      bindUsername: USERNAME\n      bindPassword: PASSWORD\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### LDAP With User To DN Mapping\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.Project(\"test\", {\n    name: \"NAME OF THE PROJECT\",\n    orgId: \"ORG ID\",\n});\nconst testLdapConfiguration = new mongodbatlas.LdapConfiguration(\"test\", {\n    projectId: test.id,\n    authenticationEnabled: true,\n    hostname: \"HOSTNAME\",\n    port: 636,\n    bindUsername: \"USERNAME\",\n    bindPassword: \"PASSWORD\",\n    caCertificate: \"CA CERTIFICATE\",\n    authzQueryTemplate: \"{USER}?memberOf?base\",\n    userToDnMappings: [{\n        match: \"(.+)\",\n        ldapQuery: \"DC=example,DC=com??sub?(userPrincipalName={0})\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.Project(\"test\",\n    name=\"NAME OF THE PROJECT\",\n    org_id=\"ORG ID\")\ntest_ldap_configuration = mongodbatlas.LdapConfiguration(\"test\",\n    project_id=test.id,\n    authentication_enabled=True,\n    hostname=\"HOSTNAME\",\n    port=636,\n    bind_username=\"USERNAME\",\n    bind_password=\"PASSWORD\",\n    ca_certificate=\"CA CERTIFICATE\",\n    authz_query_template=\"{USER}?memberOf?base\",\n    user_to_dn_mappings=[{\n        \"match\": \"(.+)\",\n        \"ldap_query\": \"DC=example,DC=com??sub?(userPrincipalName={0})\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.Project(\"test\", new()\n    {\n        Name = \"NAME OF THE PROJECT\",\n        OrgId = \"ORG ID\",\n    });\n\n    var testLdapConfiguration = new Mongodbatlas.LdapConfiguration(\"test\", new()\n    {\n        ProjectId = test.Id,\n        AuthenticationEnabled = true,\n        Hostname = \"HOSTNAME\",\n        Port = 636,\n        BindUsername = \"USERNAME\",\n        BindPassword = \"PASSWORD\",\n        CaCertificate = \"CA CERTIFICATE\",\n        AuthzQueryTemplate = \"{USER}?memberOf?base\",\n        UserToDnMappings = new[]\n        {\n            new Mongodbatlas.Inputs.LdapConfigurationUserToDnMappingArgs\n            {\n                Match = \"(.+)\",\n                LdapQuery = \"DC=example,DC=com??sub?(userPrincipalName={0})\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := mongodbatlas.NewProject(ctx, \"test\", \u0026mongodbatlas.ProjectArgs{\n\t\t\tName:  pulumi.String(\"NAME OF THE PROJECT\"),\n\t\t\tOrgId: pulumi.String(\"ORG ID\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewLdapConfiguration(ctx, \"test\", \u0026mongodbatlas.LdapConfigurationArgs{\n\t\t\tProjectId:             test.ID(),\n\t\t\tAuthenticationEnabled: pulumi.Bool(true),\n\t\t\tHostname:              pulumi.String(\"HOSTNAME\"),\n\t\t\tPort:                  pulumi.Int(636),\n\t\t\tBindUsername:          pulumi.String(\"USERNAME\"),\n\t\t\tBindPassword:          pulumi.String(\"PASSWORD\"),\n\t\t\tCaCertificate:         pulumi.String(\"CA CERTIFICATE\"),\n\t\t\tAuthzQueryTemplate:    pulumi.String(\"{USER}?memberOf?base\"),\n\t\t\tUserToDnMappings: mongodbatlas.LdapConfigurationUserToDnMappingArray{\n\t\t\t\t\u0026mongodbatlas.LdapConfigurationUserToDnMappingArgs{\n\t\t\t\t\tMatch:     pulumi.String(\"(.+)\"),\n\t\t\t\t\tLdapQuery: pulumi.String(\"DC=example,DC=com??sub?(userPrincipalName={0})\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Project;\nimport com.pulumi.mongodbatlas.ProjectArgs;\nimport com.pulumi.mongodbatlas.LdapConfiguration;\nimport com.pulumi.mongodbatlas.LdapConfigurationArgs;\nimport com.pulumi.mongodbatlas.inputs.LdapConfigurationUserToDnMappingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new Project(\"test\", ProjectArgs.builder()\n            .name(\"NAME OF THE PROJECT\")\n            .orgId(\"ORG ID\")\n            .build());\n\n        var testLdapConfiguration = new LdapConfiguration(\"testLdapConfiguration\", LdapConfigurationArgs.builder()\n            .projectId(test.id())\n            .authenticationEnabled(true)\n            .hostname(\"HOSTNAME\")\n            .port(636)\n            .bindUsername(\"USERNAME\")\n            .bindPassword(\"PASSWORD\")\n            .caCertificate(\"CA CERTIFICATE\")\n            .authzQueryTemplate(\"{USER}?memberOf?base\")\n            .userToDnMappings(LdapConfigurationUserToDnMappingArgs.builder()\n                .match(\"(.+)\")\n                .ldapQuery(\"DC=example,DC=com??sub?(userPrincipalName={0})\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:Project\n    properties:\n      name: NAME OF THE PROJECT\n      orgId: ORG ID\n  testLdapConfiguration:\n    type: mongodbatlas:LdapConfiguration\n    name: test\n    properties:\n      projectId: ${test.id}\n      authenticationEnabled: true\n      hostname: HOSTNAME\n      port: 636\n      bindUsername: USERNAME\n      bindPassword: PASSWORD\n      caCertificate: CA CERTIFICATE\n      authzQueryTemplate: '{USER}?memberOf?base'\n      userToDnMappings:\n        - match: (.+)\n          ldapQuery: DC=example,DC=com??sub?(userPrincipalName={0})\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nLDAP Configuration must be imported using project ID, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/ldapConfiguration:LdapConfiguration test 5d09d6a59ccf6445652a444a\n```\nFor more information see: [MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/ldaps-configuration-save)\n\n",
            "properties": {
                "authenticationEnabled": {
                    "type": "boolean",
                    "description": "Specifies whether user authentication with LDAP is enabled.\n"
                },
                "authorizationEnabled": {
                    "type": "boolean",
                    "description": "Specifies whether user authorization with LDAP is enabled. You cannot enable user authorization with LDAP without first enabling user authentication with LDAP.\n"
                },
                "authzQueryTemplate": {
                    "type": "string",
                    "description": "An LDAP query template that Atlas executes to obtain the LDAP groups to which the authenticated user belongs. Used only for user authorization. Use the {USER} placeholder in the URL to substitute the authenticated username. The query is relative to the host specified with hostname. The formatting for the query must conform to RFC4515 and RFC 4516. If you do not provide a query template, Atlas attempts to use the default value: `{USER}?memberOf?base`.\n"
                },
                "bindPassword": {
                    "type": "string",
                    "description": "The password used to authenticate the `bind_username`.\n",
                    "secret": true
                },
                "bindUsername": {
                    "type": "string",
                    "description": "The user DN that Atlas uses to connect to the LDAP server. Must be the full DN, such as `CN=BindUser,CN=Users,DC=myldapserver,DC=mycompany,DC=com`.\n"
                },
                "caCertificate": {
                    "type": "string",
                    "description": "CA certificate used to verify the identify of the LDAP server. Self-signed certificates are allowed.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "The hostname or IP address of the LDAP server. The server must be visible to the internet or connected to your Atlas cluster with VPC Peering.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "The port to which the LDAP server listens for client connections. Default: `636`\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to configure LDAP.\n"
                },
                "userToDnMappings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/LdapConfigurationUserToDnMapping:LdapConfigurationUserToDnMapping"
                    },
                    "description": "Maps an LDAP username for authentication to an LDAP Distinguished Name (DN). Each document contains a `match` regular expression and either a `substitution` or `ldap_query` template used to transform the LDAP username extracted from the regular expression. Atlas steps through the each document in the array in the given order, checking the authentication username against the `match` filter. If a match is found, Atlas applies the transformation and uses the output to authenticate the user. Atlas does not check the remaining documents in the array. For more details and examples see the [MongoDB Atlas API Reference](https://docs.atlas.mongodb.com/reference/api/ldaps-configuration-save/).\n* `user_to_dn_mapping.0.match` - (Optional) A regular expression to match against a provided LDAP username. Each parenthesis-enclosed section represents a regular expression capture group used by the `substitution` or `ldap_query` template.\n* `user_to_dn_mapping.0.substitution` - (Optional) An LDAP Distinguished Name (DN) formatting template that converts the LDAP name matched by the `match` regular expression into an LDAP Distinguished Name. Each bracket-enclosed numeric value is replaced by the corresponding regular expression capture group extracted from the LDAP username that matched the `match` regular expression.\n* `user_to_dn_mapping.0.ldap_query` - (Optional) An LDAP query formatting template that inserts the LDAP name matched by the `match` regular expression into an LDAP query URI as specified by RFC 4515 and RFC 4516. Each numeric value is replaced by the corresponding regular expression capture group extracted from the LDAP username that matched the `match` regular expression.\n"
                }
            },
            "required": [
                "authenticationEnabled",
                "authorizationEnabled",
                "authzQueryTemplate",
                "bindPassword",
                "bindUsername",
                "caCertificate",
                "hostname",
                "projectId",
                "userToDnMappings"
            ],
            "inputProperties": {
                "authenticationEnabled": {
                    "type": "boolean",
                    "description": "Specifies whether user authentication with LDAP is enabled.\n"
                },
                "authorizationEnabled": {
                    "type": "boolean",
                    "description": "Specifies whether user authorization with LDAP is enabled. You cannot enable user authorization with LDAP without first enabling user authentication with LDAP.\n"
                },
                "authzQueryTemplate": {
                    "type": "string",
                    "description": "An LDAP query template that Atlas executes to obtain the LDAP groups to which the authenticated user belongs. Used only for user authorization. Use the {USER} placeholder in the URL to substitute the authenticated username. The query is relative to the host specified with hostname. The formatting for the query must conform to RFC4515 and RFC 4516. If you do not provide a query template, Atlas attempts to use the default value: `{USER}?memberOf?base`.\n"
                },
                "bindPassword": {
                    "type": "string",
                    "description": "The password used to authenticate the `bind_username`.\n",
                    "secret": true
                },
                "bindUsername": {
                    "type": "string",
                    "description": "The user DN that Atlas uses to connect to the LDAP server. Must be the full DN, such as `CN=BindUser,CN=Users,DC=myldapserver,DC=mycompany,DC=com`.\n"
                },
                "caCertificate": {
                    "type": "string",
                    "description": "CA certificate used to verify the identify of the LDAP server. Self-signed certificates are allowed.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "The hostname or IP address of the LDAP server. The server must be visible to the internet or connected to your Atlas cluster with VPC Peering.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "The port to which the LDAP server listens for client connections. Default: `636`\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to configure LDAP.\n"
                },
                "userToDnMappings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/LdapConfigurationUserToDnMapping:LdapConfigurationUserToDnMapping"
                    },
                    "description": "Maps an LDAP username for authentication to an LDAP Distinguished Name (DN). Each document contains a `match` regular expression and either a `substitution` or `ldap_query` template used to transform the LDAP username extracted from the regular expression. Atlas steps through the each document in the array in the given order, checking the authentication username against the `match` filter. If a match is found, Atlas applies the transformation and uses the output to authenticate the user. Atlas does not check the remaining documents in the array. For more details and examples see the [MongoDB Atlas API Reference](https://docs.atlas.mongodb.com/reference/api/ldaps-configuration-save/).\n* `user_to_dn_mapping.0.match` - (Optional) A regular expression to match against a provided LDAP username. Each parenthesis-enclosed section represents a regular expression capture group used by the `substitution` or `ldap_query` template.\n* `user_to_dn_mapping.0.substitution` - (Optional) An LDAP Distinguished Name (DN) formatting template that converts the LDAP name matched by the `match` regular expression into an LDAP Distinguished Name. Each bracket-enclosed numeric value is replaced by the corresponding regular expression capture group extracted from the LDAP username that matched the `match` regular expression.\n* `user_to_dn_mapping.0.ldap_query` - (Optional) An LDAP query formatting template that inserts the LDAP name matched by the `match` regular expression into an LDAP query URI as specified by RFC 4515 and RFC 4516. Each numeric value is replaced by the corresponding regular expression capture group extracted from the LDAP username that matched the `match` regular expression.\n"
                }
            },
            "requiredInputs": [
                "authenticationEnabled",
                "bindPassword",
                "bindUsername",
                "hostname",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LdapConfiguration resources.\n",
                "properties": {
                    "authenticationEnabled": {
                        "type": "boolean",
                        "description": "Specifies whether user authentication with LDAP is enabled.\n"
                    },
                    "authorizationEnabled": {
                        "type": "boolean",
                        "description": "Specifies whether user authorization with LDAP is enabled. You cannot enable user authorization with LDAP without first enabling user authentication with LDAP.\n"
                    },
                    "authzQueryTemplate": {
                        "type": "string",
                        "description": "An LDAP query template that Atlas executes to obtain the LDAP groups to which the authenticated user belongs. Used only for user authorization. Use the {USER} placeholder in the URL to substitute the authenticated username. The query is relative to the host specified with hostname. The formatting for the query must conform to RFC4515 and RFC 4516. If you do not provide a query template, Atlas attempts to use the default value: `{USER}?memberOf?base`.\n"
                    },
                    "bindPassword": {
                        "type": "string",
                        "description": "The password used to authenticate the `bind_username`.\n",
                        "secret": true
                    },
                    "bindUsername": {
                        "type": "string",
                        "description": "The user DN that Atlas uses to connect to the LDAP server. Must be the full DN, such as `CN=BindUser,CN=Users,DC=myldapserver,DC=mycompany,DC=com`.\n"
                    },
                    "caCertificate": {
                        "type": "string",
                        "description": "CA certificate used to verify the identify of the LDAP server. Self-signed certificates are allowed.\n"
                    },
                    "hostname": {
                        "type": "string",
                        "description": "The hostname or IP address of the LDAP server. The server must be visible to the internet or connected to your Atlas cluster with VPC Peering.\n"
                    },
                    "port": {
                        "type": "integer",
                        "description": "The port to which the LDAP server listens for client connections. Default: `636`\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to configure LDAP.\n"
                    },
                    "userToDnMappings": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/LdapConfigurationUserToDnMapping:LdapConfigurationUserToDnMapping"
                        },
                        "description": "Maps an LDAP username for authentication to an LDAP Distinguished Name (DN). Each document contains a `match` regular expression and either a `substitution` or `ldap_query` template used to transform the LDAP username extracted from the regular expression. Atlas steps through the each document in the array in the given order, checking the authentication username against the `match` filter. If a match is found, Atlas applies the transformation and uses the output to authenticate the user. Atlas does not check the remaining documents in the array. For more details and examples see the [MongoDB Atlas API Reference](https://docs.atlas.mongodb.com/reference/api/ldaps-configuration-save/).\n* `user_to_dn_mapping.0.match` - (Optional) A regular expression to match against a provided LDAP username. Each parenthesis-enclosed section represents a regular expression capture group used by the `substitution` or `ldap_query` template.\n* `user_to_dn_mapping.0.substitution` - (Optional) An LDAP Distinguished Name (DN) formatting template that converts the LDAP name matched by the `match` regular expression into an LDAP Distinguished Name. Each bracket-enclosed numeric value is replaced by the corresponding regular expression capture group extracted from the LDAP username that matched the `match` regular expression.\n* `user_to_dn_mapping.0.ldap_query` - (Optional) An LDAP query formatting template that inserts the LDAP name matched by the `match` regular expression into an LDAP query URI as specified by RFC 4515 and RFC 4516. Each numeric value is replaced by the corresponding regular expression capture group extracted from the LDAP username that matched the `match` regular expression.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/ldapVerify:LdapVerify": {
            "description": "## # Resource: mongodbatlas.LdapVerify\n\n`mongodbatlas.LdapVerify` provides an LDAP Verify resource. This allows a a verification of an LDAP configuration over TLS for an Atlas project. Atlas retains only the most recent request for each project.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.Project(\"test\", {\n    name: \"NAME OF THE PROJECT\",\n    orgId: \"ORG ID\",\n});\nconst testAdvancedCluster = new mongodbatlas.AdvancedCluster(\"test\", {\n    projectId: test.id,\n    name: \"NAME OF THE CLUSTER\",\n    clusterType: \"REPLICASET\",\n    backupEnabled: true,\n    replicationSpecs: [{\n        regionConfigs: [{\n            priority: 7,\n            providerName: \"AWS\",\n            regionName: \"US_EAST_1\",\n            electableSpecs: {\n                instanceSize: \"M10\",\n                nodeCount: 3,\n            },\n        }],\n    }],\n});\nconst testLdapVerify = new mongodbatlas.LdapVerify(\"test\", {\n    projectId: test.id,\n    hostname: \"HOSTNAME\",\n    port: 636,\n    bindUsername: \"USERNAME\",\n    bindPassword: \"PASSWORD\",\n}, {\n    dependsOn: [testAdvancedCluster],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.Project(\"test\",\n    name=\"NAME OF THE PROJECT\",\n    org_id=\"ORG ID\")\ntest_advanced_cluster = mongodbatlas.AdvancedCluster(\"test\",\n    project_id=test.id,\n    name=\"NAME OF THE CLUSTER\",\n    cluster_type=\"REPLICASET\",\n    backup_enabled=True,\n    replication_specs=[{\n        \"region_configs\": [{\n            \"priority\": 7,\n            \"provider_name\": \"AWS\",\n            \"region_name\": \"US_EAST_1\",\n            \"electable_specs\": {\n                \"instance_size\": \"M10\",\n                \"node_count\": 3,\n            },\n        }],\n    }])\ntest_ldap_verify = mongodbatlas.LdapVerify(\"test\",\n    project_id=test.id,\n    hostname=\"HOSTNAME\",\n    port=636,\n    bind_username=\"USERNAME\",\n    bind_password=\"PASSWORD\",\n    opts = pulumi.ResourceOptions(depends_on=[test_advanced_cluster]))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.Project(\"test\", new()\n    {\n        Name = \"NAME OF THE PROJECT\",\n        OrgId = \"ORG ID\",\n    });\n\n    var testAdvancedCluster = new Mongodbatlas.AdvancedCluster(\"test\", new()\n    {\n        ProjectId = test.Id,\n        Name = \"NAME OF THE CLUSTER\",\n        ClusterType = \"REPLICASET\",\n        BackupEnabled = true,\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        Priority = 7,\n                        ProviderName = \"AWS\",\n                        RegionName = \"US_EAST_1\",\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M10\",\n                            NodeCount = 3,\n                        },\n                    },\n                },\n            },\n        },\n    });\n\n    var testLdapVerify = new Mongodbatlas.LdapVerify(\"test\", new()\n    {\n        ProjectId = test.Id,\n        Hostname = \"HOSTNAME\",\n        Port = 636,\n        BindUsername = \"USERNAME\",\n        BindPassword = \"PASSWORD\",\n    }, new CustomResourceOptions\n    {\n        DependsOn =\n        {\n            testAdvancedCluster,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := mongodbatlas.NewProject(ctx, \"test\", \u0026mongodbatlas.ProjectArgs{\n\t\t\tName:  pulumi.String(\"NAME OF THE PROJECT\"),\n\t\t\tOrgId: pulumi.String(\"ORG ID\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestAdvancedCluster, err := mongodbatlas.NewAdvancedCluster(ctx, \"test\", \u0026mongodbatlas.AdvancedClusterArgs{\n\t\t\tProjectId:     test.ID(),\n\t\t\tName:          pulumi.String(\"NAME OF THE CLUSTER\"),\n\t\t\tClusterType:   pulumi.String(\"REPLICASET\"),\n\t\t\tBackupEnabled: pulumi.Bool(true),\n\t\t\tReplicationSpecs: mongodbatlas.AdvancedClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tPriority:     pulumi.Int(7),\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"US_EAST_1\"),\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M10\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(3),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewLdapVerify(ctx, \"test\", \u0026mongodbatlas.LdapVerifyArgs{\n\t\t\tProjectId:    test.ID(),\n\t\t\tHostname:     pulumi.String(\"HOSTNAME\"),\n\t\t\tPort:         pulumi.Int(636),\n\t\t\tBindUsername: pulumi.String(\"USERNAME\"),\n\t\t\tBindPassword: pulumi.String(\"PASSWORD\"),\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\ttestAdvancedCluster,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Project;\nimport com.pulumi.mongodbatlas.ProjectArgs;\nimport com.pulumi.mongodbatlas.AdvancedCluster;\nimport com.pulumi.mongodbatlas.AdvancedClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.AdvancedClusterReplicationSpecArgs;\nimport com.pulumi.mongodbatlas.LdapVerify;\nimport com.pulumi.mongodbatlas.LdapVerifyArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new Project(\"test\", ProjectArgs.builder()\n            .name(\"NAME OF THE PROJECT\")\n            .orgId(\"ORG ID\")\n            .build());\n\n        var testAdvancedCluster = new AdvancedCluster(\"testAdvancedCluster\", AdvancedClusterArgs.builder()\n            .projectId(test.id())\n            .name(\"NAME OF THE CLUSTER\")\n            .clusterType(\"REPLICASET\")\n            .backupEnabled(true)\n            .replicationSpecs(AdvancedClusterReplicationSpecArgs.builder()\n                .regionConfigs(AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                    .priority(7)\n                    .providerName(\"AWS\")\n                    .regionName(\"US_EAST_1\")\n                    .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                        .instanceSize(\"M10\")\n                        .nodeCount(3)\n                        .build())\n                    .build())\n                .build())\n            .build());\n\n        var testLdapVerify = new LdapVerify(\"testLdapVerify\", LdapVerifyArgs.builder()\n            .projectId(test.id())\n            .hostname(\"HOSTNAME\")\n            .port(636)\n            .bindUsername(\"USERNAME\")\n            .bindPassword(\"PASSWORD\")\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(testAdvancedCluster)\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:Project\n    properties:\n      name: NAME OF THE PROJECT\n      orgId: ORG ID\n  testAdvancedCluster:\n    type: mongodbatlas:AdvancedCluster\n    name: test\n    properties:\n      projectId: ${test.id}\n      name: NAME OF THE CLUSTER\n      clusterType: REPLICASET\n      backupEnabled: true # enable cloud backup snapshots\n      replicationSpecs:\n        - regionConfigs:\n            - priority: 7\n              providerName: AWS\n              regionName: US_EAST_1\n              electableSpecs:\n                instanceSize: M10\n                nodeCount: 3\n  testLdapVerify:\n    type: mongodbatlas:LdapVerify\n    name: test\n    properties:\n      projectId: ${test.id}\n      hostname: HOSTNAME\n      port: 636\n      bindUsername: USERNAME\n      bindPassword: PASSWORD\n    options:\n      dependson:\n        - ${testAdvancedCluster}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nLDAP Configuration must be imported using project ID and request ID, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/ldapVerify:LdapVerify test 5d09d6a59ccf6445652a444a-5d09d6a59ccf6445652a444a\n```\nFor more information see: [MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/ldaps-configuration-request-verification)\n\n",
            "properties": {
                "authzQueryTemplate": {
                    "type": "string",
                    "description": "An LDAP query template that Atlas executes to obtain the LDAP groups to which the authenticated user belongs. Used only for user authorization. Use the {USER} placeholder in the URL to substitute the authenticated username. The query is relative to the host specified with hostname. The formatting for the query must conform to RFC4515 and RFC 4516. If you do not provide a query template, Atlas attempts to use the default value: `{USER}?memberOf?base`.\n"
                },
                "bindPassword": {
                    "type": "string",
                    "description": "The password used to authenticate the `bind_username`.\n"
                },
                "bindUsername": {
                    "type": "string",
                    "description": "The user DN that Atlas uses to connect to the LDAP server. Must be the full DN, such as `CN=BindUser,CN=Users,DC=myldapserver,DC=mycompany,DC=com`.\n"
                },
                "caCertificate": {
                    "type": "string",
                    "description": "CA certificate used to verify the identify of the LDAP server. Self-signed certificates are allowed.\n"
                },
                "hostname": {
                    "type": "string",
                    "description": "The hostname or IP address of the LDAP server. The server must be visible to the internet or connected to your Atlas cluster with VPC Peering.\n"
                },
                "links": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/LdapVerifyLink:LdapVerifyLink"
                    },
                    "description": "One or more links to sub-resources. The relations in the URLs are explained in the Web Linking Specification.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "The port to which the LDAP server listens for client connections. Default: `636`\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to configure LDAP.\n"
                },
                "requestId": {
                    "type": "string",
                    "description": "The unique identifier for the request to verify the LDAP over TLS/SSL configuration.\n"
                },
                "status": {
                    "type": "string",
                    "description": "The current status of the LDAP over TLS/SSL configuration. One of the following values: `PENDING`, `SUCCESS`, and `FAILED`.\n"
                },
                "validations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/LdapVerifyValidation:LdapVerifyValidation"
                    },
                    "description": "Array of validation messages related to the verification of the provided LDAP over TLS/SSL configuration details. The array contains a document for each test that Atlas runs. Atlas stops running tests after the first failure. The following return values can be seen here: [Values](https://docs.atlas.mongodb.com/reference/api/ldaps-configuration-request-verification)\n"
                }
            },
            "required": [
                "authzQueryTemplate",
                "bindPassword",
                "bindUsername",
                "caCertificate",
                "hostname",
                "links",
                "port",
                "projectId",
                "requestId",
                "status",
                "validations"
            ],
            "inputProperties": {
                "authzQueryTemplate": {
                    "type": "string",
                    "description": "An LDAP query template that Atlas executes to obtain the LDAP groups to which the authenticated user belongs. Used only for user authorization. Use the {USER} placeholder in the URL to substitute the authenticated username. The query is relative to the host specified with hostname. The formatting for the query must conform to RFC4515 and RFC 4516. If you do not provide a query template, Atlas attempts to use the default value: `{USER}?memberOf?base`.\n",
                    "willReplaceOnChanges": true
                },
                "bindPassword": {
                    "type": "string",
                    "description": "The password used to authenticate the `bind_username`.\n",
                    "willReplaceOnChanges": true
                },
                "bindUsername": {
                    "type": "string",
                    "description": "The user DN that Atlas uses to connect to the LDAP server. Must be the full DN, such as `CN=BindUser,CN=Users,DC=myldapserver,DC=mycompany,DC=com`.\n",
                    "willReplaceOnChanges": true
                },
                "caCertificate": {
                    "type": "string",
                    "description": "CA certificate used to verify the identify of the LDAP server. Self-signed certificates are allowed.\n",
                    "willReplaceOnChanges": true
                },
                "hostname": {
                    "type": "string",
                    "description": "The hostname or IP address of the LDAP server. The server must be visible to the internet or connected to your Atlas cluster with VPC Peering.\n",
                    "willReplaceOnChanges": true
                },
                "port": {
                    "type": "integer",
                    "description": "The port to which the LDAP server listens for client connections. Default: `636`\n",
                    "willReplaceOnChanges": true
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to configure LDAP.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "bindPassword",
                "bindUsername",
                "hostname",
                "port",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering LdapVerify resources.\n",
                "properties": {
                    "authzQueryTemplate": {
                        "type": "string",
                        "description": "An LDAP query template that Atlas executes to obtain the LDAP groups to which the authenticated user belongs. Used only for user authorization. Use the {USER} placeholder in the URL to substitute the authenticated username. The query is relative to the host specified with hostname. The formatting for the query must conform to RFC4515 and RFC 4516. If you do not provide a query template, Atlas attempts to use the default value: `{USER}?memberOf?base`.\n",
                        "willReplaceOnChanges": true
                    },
                    "bindPassword": {
                        "type": "string",
                        "description": "The password used to authenticate the `bind_username`.\n",
                        "willReplaceOnChanges": true
                    },
                    "bindUsername": {
                        "type": "string",
                        "description": "The user DN that Atlas uses to connect to the LDAP server. Must be the full DN, such as `CN=BindUser,CN=Users,DC=myldapserver,DC=mycompany,DC=com`.\n",
                        "willReplaceOnChanges": true
                    },
                    "caCertificate": {
                        "type": "string",
                        "description": "CA certificate used to verify the identify of the LDAP server. Self-signed certificates are allowed.\n",
                        "willReplaceOnChanges": true
                    },
                    "hostname": {
                        "type": "string",
                        "description": "The hostname or IP address of the LDAP server. The server must be visible to the internet or connected to your Atlas cluster with VPC Peering.\n",
                        "willReplaceOnChanges": true
                    },
                    "links": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/LdapVerifyLink:LdapVerifyLink"
                        },
                        "description": "One or more links to sub-resources. The relations in the URLs are explained in the Web Linking Specification.\n"
                    },
                    "port": {
                        "type": "integer",
                        "description": "The port to which the LDAP server listens for client connections. Default: `636`\n",
                        "willReplaceOnChanges": true
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to configure LDAP.\n",
                        "willReplaceOnChanges": true
                    },
                    "requestId": {
                        "type": "string",
                        "description": "The unique identifier for the request to verify the LDAP over TLS/SSL configuration.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "The current status of the LDAP over TLS/SSL configuration. One of the following values: `PENDING`, `SUCCESS`, and `FAILED`.\n"
                    },
                    "validations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/LdapVerifyValidation:LdapVerifyValidation"
                        },
                        "description": "Array of validation messages related to the verification of the provided LDAP over TLS/SSL configuration details. The array contains a document for each test that Atlas runs. Atlas stops running tests after the first failure. The following return values can be seen here: [Values](https://docs.atlas.mongodb.com/reference/api/ldaps-configuration-request-verification)\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/maintenanceWindow:MaintenanceWindow": {
            "description": "## # Resource: mongodbatlas.MaintenanceWindow\n\n`mongodbatlas.MaintenanceWindow` provides a resource to schedule the maintenance window for your MongoDB Atlas Project and/or set to defer a scheduled maintenance up to two times. Please refer to [Maintenance Windows](https://www.mongodb.com/docs/atlas/tutorial/cluster-maintenance-window/#configure-maintenance-window) documentation for more details.\n\n\u003e **NOTE:** Only a single maintenance window resource can be defined per project.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n## Maintenance Window Considerations:\n\n- Urgent Maintenance Activities Cannot Wait: Urgent maintenance activities such as security patches cannot wait for your chosen window. Atlas will start those maintenance activities when needed.\n\nOnce maintenance is scheduled for your cluster, you cannot change your maintenance window until the current maintenance efforts have completed.\n- Maintenance Requires Replica Set Elections: Atlas performs maintenance the same way as the manual maintenance procedure. This requires at least one replica set election during the maintenance window per replica set.\n- Maintenance Starts As Close to the Hour As Possible: Maintenance always begins as close to the scheduled hour as possible, but in-progress cluster updates or expected system issues could delay the start time.\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.MaintenanceWindow(\"test\", {\n    projectId: \"\u003cyour-project-id\u003e\",\n    dayOfWeek: 3,\n    hourOfDay: 4,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.MaintenanceWindow(\"test\",\n    project_id=\"\u003cyour-project-id\u003e\",\n    day_of_week=3,\n    hour_of_day=4)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.MaintenanceWindow(\"test\", new()\n    {\n        ProjectId = \"\u003cyour-project-id\u003e\",\n        DayOfWeek = 3,\n        HourOfDay = 4,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewMaintenanceWindow(ctx, \"test\", \u0026mongodbatlas.MaintenanceWindowArgs{\n\t\t\tProjectId: pulumi.String(\"\u003cyour-project-id\u003e\"),\n\t\t\tDayOfWeek: pulumi.Int(3),\n\t\t\tHourOfDay: pulumi.Int(4),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MaintenanceWindow;\nimport com.pulumi.mongodbatlas.MaintenanceWindowArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new MaintenanceWindow(\"test\", MaintenanceWindowArgs.builder()\n            .projectId(\"\u003cyour-project-id\u003e\")\n            .dayOfWeek(3)\n            .hourOfDay(4)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:MaintenanceWindow\n    properties:\n      projectId: \u003cyour-project-id\u003e\n      dayOfWeek: 3\n      hourOfDay: 4\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.MaintenanceWindow(\"test\", {\n    projectId: \"\u003cyour-project-id\u003e\",\n    defer: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.MaintenanceWindow(\"test\",\n    project_id=\"\u003cyour-project-id\u003e\",\n    defer=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.MaintenanceWindow(\"test\", new()\n    {\n        ProjectId = \"\u003cyour-project-id\u003e\",\n        Defer = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewMaintenanceWindow(ctx, \"test\", \u0026mongodbatlas.MaintenanceWindowArgs{\n\t\t\tProjectId: pulumi.String(\"\u003cyour-project-id\u003e\"),\n\t\t\tDefer:     pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MaintenanceWindow;\nimport com.pulumi.mongodbatlas.MaintenanceWindowArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new MaintenanceWindow(\"test\", MaintenanceWindowArgs.builder()\n            .projectId(\"\u003cyour-project-id\u003e\")\n            .defer(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:MaintenanceWindow\n    properties:\n      projectId: \u003cyour-project-id\u003e\n      defer: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nMaintenance Window entries can be imported using project project_id, in the format `PROJECTID`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/maintenanceWindow:MaintenanceWindow test 5d0f1f73cf09a29120e173cf\n```\nFor more information see: [MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/maintenance-windows/)\n\n",
            "properties": {
                "autoDefer": {
                    "type": "boolean",
                    "description": "Defer any scheduled maintenance for the given project for one week.\n"
                },
                "autoDeferOnceEnabled": {
                    "type": "boolean"
                },
                "dayOfWeek": {
                    "type": "integer",
                    "description": "Day of the week when you would like the maintenance window to start as a 1-based integer: Su=1, M=2, T=3, W=4, T=5, F=6, Sa=7.\n"
                },
                "defer": {
                    "type": "boolean",
                    "description": "Defer the next scheduled maintenance for the given project for one week.\n"
                },
                "hourOfDay": {
                    "type": "integer",
                    "description": "Hour of the day when you would like the maintenance window to start. This parameter uses the 24-hour clock, where midnight is 0, noon is 12 (Time zone is UTC).\n"
                },
                "numberOfDeferrals": {
                    "type": "integer",
                    "description": "Number of times the current maintenance event for this project has been deferred, there can be a maximum of 2 deferrals.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier of the project for the Maintenance Window.\n"
                },
                "startAsap": {
                    "type": "boolean",
                    "description": "Flag indicating whether project maintenance has been directed to start immediately. If you request that maintenance begin immediately, this field returns true from the time the request was made until the time the maintenance event completes.\n"
                }
            },
            "required": [
                "autoDefer",
                "autoDeferOnceEnabled",
                "dayOfWeek",
                "defer",
                "hourOfDay",
                "numberOfDeferrals",
                "projectId",
                "startAsap"
            ],
            "inputProperties": {
                "autoDefer": {
                    "type": "boolean",
                    "description": "Defer any scheduled maintenance for the given project for one week.\n"
                },
                "autoDeferOnceEnabled": {
                    "type": "boolean"
                },
                "dayOfWeek": {
                    "type": "integer",
                    "description": "Day of the week when you would like the maintenance window to start as a 1-based integer: Su=1, M=2, T=3, W=4, T=5, F=6, Sa=7.\n"
                },
                "defer": {
                    "type": "boolean",
                    "description": "Defer the next scheduled maintenance for the given project for one week.\n"
                },
                "hourOfDay": {
                    "type": "integer",
                    "description": "Hour of the day when you would like the maintenance window to start. This parameter uses the 24-hour clock, where midnight is 0, noon is 12 (Time zone is UTC).\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique identifier of the project for the Maintenance Window.\n"
                },
                "startAsap": {
                    "type": "boolean",
                    "description": "Flag indicating whether project maintenance has been directed to start immediately. If you request that maintenance begin immediately, this field returns true from the time the request was made until the time the maintenance event completes.\n"
                }
            },
            "requiredInputs": [
                "dayOfWeek",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering MaintenanceWindow resources.\n",
                "properties": {
                    "autoDefer": {
                        "type": "boolean",
                        "description": "Defer any scheduled maintenance for the given project for one week.\n"
                    },
                    "autoDeferOnceEnabled": {
                        "type": "boolean"
                    },
                    "dayOfWeek": {
                        "type": "integer",
                        "description": "Day of the week when you would like the maintenance window to start as a 1-based integer: Su=1, M=2, T=3, W=4, T=5, F=6, Sa=7.\n"
                    },
                    "defer": {
                        "type": "boolean",
                        "description": "Defer the next scheduled maintenance for the given project for one week.\n"
                    },
                    "hourOfDay": {
                        "type": "integer",
                        "description": "Hour of the day when you would like the maintenance window to start. This parameter uses the 24-hour clock, where midnight is 0, noon is 12 (Time zone is UTC).\n"
                    },
                    "numberOfDeferrals": {
                        "type": "integer",
                        "description": "Number of times the current maintenance event for this project has been deferred, there can be a maximum of 2 deferrals.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Maintenance Window.\n"
                    },
                    "startAsap": {
                        "type": "boolean",
                        "description": "Flag indicating whether project maintenance has been directed to start immediately. If you request that maintenance begin immediately, this field returns true from the time the request was made until the time the maintenance event completes.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/networkContainer:NetworkContainer": {
            "description": "## # Resource: mongodbatlas.NetworkContainer\n\n`mongodbatlas.NetworkContainer` provides a Network Peering Container resource. The resource lets you create, edit and delete network peering containers. You must delete network peering containers before creating clusters in your project. You can't delete a network peering container if your project contains clusters. The resource requires your Project ID.  Each cloud provider requires slightly different attributes so read the argument reference carefully.\n\n Network peering container is a general term used to describe any cloud providers' VPC/VNet concept.  Containers only need to be created if the peering connection to the cloud provider will be created before the first cluster that requires the container.  If the cluster has been/will be created first Atlas automatically creates the required container per the \"containers per cloud provider\" information that follows (in this case you can obtain the container id from the cluster resource attribute `container_id`).\n\nThe following is the maximum number of Network Peering containers per cloud provider:\n\u003cbr\u003e \u0026#8226;  GCP -  One container per project.\n\u003cbr\u003e \u0026#8226;  AWS and Azure - One container per cloud provider region.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find **group_id** in the official documentation.\n\n\n## Example Usage\n\n### Example with AWS\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.NetworkContainer(\"test\", {\n    projectId: \"\u003cYOUR-PROJECT-ID\u003e\",\n    atlasCidrBlock: \"10.8.0.0/21\",\n    providerName: \"AWS\",\n    regionName: \"US_EAST_1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.NetworkContainer(\"test\",\n    project_id=\"\u003cYOUR-PROJECT-ID\u003e\",\n    atlas_cidr_block=\"10.8.0.0/21\",\n    provider_name=\"AWS\",\n    region_name=\"US_EAST_1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.NetworkContainer(\"test\", new()\n    {\n        ProjectId = \"\u003cYOUR-PROJECT-ID\u003e\",\n        AtlasCidrBlock = \"10.8.0.0/21\",\n        ProviderName = \"AWS\",\n        RegionName = \"US_EAST_1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewNetworkContainer(ctx, \"test\", \u0026mongodbatlas.NetworkContainerArgs{\n\t\t\tProjectId:      pulumi.String(\"\u003cYOUR-PROJECT-ID\u003e\"),\n\t\t\tAtlasCidrBlock: pulumi.String(\"10.8.0.0/21\"),\n\t\t\tProviderName:   pulumi.String(\"AWS\"),\n\t\t\tRegionName:     pulumi.String(\"US_EAST_1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.NetworkContainer;\nimport com.pulumi.mongodbatlas.NetworkContainerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new NetworkContainer(\"test\", NetworkContainerArgs.builder()\n            .projectId(\"\u003cYOUR-PROJECT-ID\u003e\")\n            .atlasCidrBlock(\"10.8.0.0/21\")\n            .providerName(\"AWS\")\n            .regionName(\"US_EAST_1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:NetworkContainer\n    properties:\n      projectId: \u003cYOUR-PROJECT-ID\u003e\n      atlasCidrBlock: 10.8.0.0/21\n      providerName: AWS\n      regionName: US_EAST_1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example with GCP\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.NetworkContainer(\"test\", {\n    projectId: \"\u003cYOUR-PROJECT-ID\u003e\",\n    atlasCidrBlock: \"10.8.0.0/21\",\n    providerName: \"GCP\",\n    regions: [\n        \"US_EAST_4\",\n        \"US_WEST_3\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.NetworkContainer(\"test\",\n    project_id=\"\u003cYOUR-PROJECT-ID\u003e\",\n    atlas_cidr_block=\"10.8.0.0/21\",\n    provider_name=\"GCP\",\n    regions=[\n        \"US_EAST_4\",\n        \"US_WEST_3\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.NetworkContainer(\"test\", new()\n    {\n        ProjectId = \"\u003cYOUR-PROJECT-ID\u003e\",\n        AtlasCidrBlock = \"10.8.0.0/21\",\n        ProviderName = \"GCP\",\n        Regions = new[]\n        {\n            \"US_EAST_4\",\n            \"US_WEST_3\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewNetworkContainer(ctx, \"test\", \u0026mongodbatlas.NetworkContainerArgs{\n\t\t\tProjectId:      pulumi.String(\"\u003cYOUR-PROJECT-ID\u003e\"),\n\t\t\tAtlasCidrBlock: pulumi.String(\"10.8.0.0/21\"),\n\t\t\tProviderName:   pulumi.String(\"GCP\"),\n\t\t\tRegions: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"US_EAST_4\"),\n\t\t\t\tpulumi.String(\"US_WEST_3\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.NetworkContainer;\nimport com.pulumi.mongodbatlas.NetworkContainerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new NetworkContainer(\"test\", NetworkContainerArgs.builder()\n            .projectId(\"\u003cYOUR-PROJECT-ID\u003e\")\n            .atlasCidrBlock(\"10.8.0.0/21\")\n            .providerName(\"GCP\")\n            .regions(            \n                \"US_EAST_4\",\n                \"US_WEST_3\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:NetworkContainer\n    properties:\n      projectId: \u003cYOUR-PROJECT-ID\u003e\n      atlasCidrBlock: 10.8.0.0/21\n      providerName: GCP\n      regions:\n        - US_EAST_4\n        - US_WEST_3\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example with Azure\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.NetworkContainer(\"test\", {\n    projectId: \"\u003cYOUR-PROJECT-ID\u003e\",\n    atlasCidrBlock: \"10.8.0.0/21\",\n    providerName: \"AZURE\",\n    region: \"US_EAST_2\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.NetworkContainer(\"test\",\n    project_id=\"\u003cYOUR-PROJECT-ID\u003e\",\n    atlas_cidr_block=\"10.8.0.0/21\",\n    provider_name=\"AZURE\",\n    region=\"US_EAST_2\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.NetworkContainer(\"test\", new()\n    {\n        ProjectId = \"\u003cYOUR-PROJECT-ID\u003e\",\n        AtlasCidrBlock = \"10.8.0.0/21\",\n        ProviderName = \"AZURE\",\n        Region = \"US_EAST_2\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewNetworkContainer(ctx, \"test\", \u0026mongodbatlas.NetworkContainerArgs{\n\t\t\tProjectId:      pulumi.String(\"\u003cYOUR-PROJECT-ID\u003e\"),\n\t\t\tAtlasCidrBlock: pulumi.String(\"10.8.0.0/21\"),\n\t\t\tProviderName:   pulumi.String(\"AZURE\"),\n\t\t\tRegion:         pulumi.String(\"US_EAST_2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.NetworkContainer;\nimport com.pulumi.mongodbatlas.NetworkContainerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new NetworkContainer(\"test\", NetworkContainerArgs.builder()\n            .projectId(\"\u003cYOUR-PROJECT-ID\u003e\")\n            .atlasCidrBlock(\"10.8.0.0/21\")\n            .providerName(\"AZURE\")\n            .region(\"US_EAST_2\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:NetworkContainer\n    properties:\n      projectId: \u003cYOUR-PROJECT-ID\u003e\n      atlasCidrBlock: 10.8.0.0/21\n      providerName: AZURE\n      region: US_EAST_2\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nNetwork Peering Containers can be imported using project ID and network peering container id, in the format `PROJECTID-CONTAINER-ID`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/networkContainer:NetworkContainer my_container 1112222b3bf99403840e8934-5cbf563d87d9d67253be590a\n```\nSee detailed information for arguments and attributes: [MongoDB API Network Peering Container](https://docs.atlas.mongodb.com/reference/api/vpc-create-container/)\n\n",
            "properties": {
                "atlasCidrBlock": {
                    "type": "string",
                    "description": "CIDR block that Atlas uses for the Network Peering containers in your project.  Atlas uses the specified CIDR block for all other Network Peering connections created in the project. The Atlas CIDR block must be at least a /24 and at most a /21 in one of the following [private networks](https://tools.ietf.org/html/rfc1918.html#section-3):\n* Lower bound: 10.0.0.0 -\tUpper bound: 10.255.255.255 -\tPrefix: 10/8\n* Lower bound: 172.16.0.0 -\tUpper bound:172.31.255.255 -\tPrefix:\t172.16/12\n* Lower bound: 192.168.0.0 -\tUpper bound:192.168.255.255 -\tPrefix:\t192.168/16\n\n**Atlas locks this value** if an M10+ cluster or a Network Peering connection already exists. To modify the CIDR block, ensure there are no M10+ clusters in the project and no other Network Peering connections in the project.\n\n**Important**: Atlas limits the number of MongoDB nodes per Network Peering connection based on the CIDR block and the region selected for the project. Contact [MongoDB Support](https://www.mongodb.com/contact?tck=docs_atlas) for any questions on Atlas limits of MongoDB nodes per Network Peering connection.\n"
                },
                "azureSubscriptionId": {
                    "type": "string",
                    "description": "Unique identifier of the Azure subscription in which the VNet resides.\n"
                },
                "containerId": {
                    "type": "string",
                    "description": "The Network Peering Container ID.\n"
                },
                "gcpProjectId": {
                    "type": "string",
                    "description": "Unique identifier of the GCP project in which the network peer resides. Returns null. This value is populated once you create a new network peering connection with the network peering resource.\n"
                },
                "networkName": {
                    "type": "string",
                    "description": "Unique identifier of the Network Peering connection in the Atlas project. Returns null. This value is populated once you create a new network peering connection with the network peering resource.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique identifier for the Atlas project for this Network Peering Container.\n"
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud provider for this Network Peering connection.  Accepted values are GCP, AWS, AZURE. If omitted, Atlas sets this parameter to AWS.\n"
                },
                "provisioned": {
                    "type": "boolean",
                    "description": "Indicates whether the project has Network Peering connections deployed in the container.\n"
                },
                "region": {
                    "type": "string",
                    "description": "Atlas region where the container resides, see the reference list for Atlas Azure region names [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).\n"
                },
                "regionName": {
                    "type": "string",
                    "description": "The Atlas AWS region name for where this container will exist, see the reference list for Atlas AWS region names [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/).\n"
                },
                "regions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Atlas regions where the container resides. Provide this field only if you provide an `atlas_cidr_block` smaller than `/18`. [GCP Regions values](https://docs.atlas.mongodb.com/reference/api/vpc-create-container/#request-body-parameters).\n"
                },
                "vnetName": {
                    "type": "string",
                    "description": "The name of the Azure VNet. Returns null. This value is populated once you create a new network peering connection with the network peering resource.\n"
                },
                "vpcId": {
                    "type": "string",
                    "description": "Unique identifier of Atlas' AWS VPC.\n"
                }
            },
            "required": [
                "atlasCidrBlock",
                "azureSubscriptionId",
                "containerId",
                "gcpProjectId",
                "networkName",
                "projectId",
                "provisioned",
                "region",
                "regionName",
                "regions",
                "vnetName",
                "vpcId"
            ],
            "inputProperties": {
                "atlasCidrBlock": {
                    "type": "string",
                    "description": "CIDR block that Atlas uses for the Network Peering containers in your project.  Atlas uses the specified CIDR block for all other Network Peering connections created in the project. The Atlas CIDR block must be at least a /24 and at most a /21 in one of the following [private networks](https://tools.ietf.org/html/rfc1918.html#section-3):\n* Lower bound: 10.0.0.0 -\tUpper bound: 10.255.255.255 -\tPrefix: 10/8\n* Lower bound: 172.16.0.0 -\tUpper bound:172.31.255.255 -\tPrefix:\t172.16/12\n* Lower bound: 192.168.0.0 -\tUpper bound:192.168.255.255 -\tPrefix:\t192.168/16\n\n**Atlas locks this value** if an M10+ cluster or a Network Peering connection already exists. To modify the CIDR block, ensure there are no M10+ clusters in the project and no other Network Peering connections in the project.\n\n**Important**: Atlas limits the number of MongoDB nodes per Network Peering connection based on the CIDR block and the region selected for the project. Contact [MongoDB Support](https://www.mongodb.com/contact?tck=docs_atlas) for any questions on Atlas limits of MongoDB nodes per Network Peering connection.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique identifier for the Atlas project for this Network Peering Container.\n",
                    "willReplaceOnChanges": true
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud provider for this Network Peering connection.  Accepted values are GCP, AWS, AZURE. If omitted, Atlas sets this parameter to AWS.\n"
                },
                "region": {
                    "type": "string",
                    "description": "Atlas region where the container resides, see the reference list for Atlas Azure region names [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).\n"
                },
                "regionName": {
                    "type": "string",
                    "description": "The Atlas AWS region name for where this container will exist, see the reference list for Atlas AWS region names [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/).\n"
                },
                "regions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Atlas regions where the container resides. Provide this field only if you provide an `atlas_cidr_block` smaller than `/18`. [GCP Regions values](https://docs.atlas.mongodb.com/reference/api/vpc-create-container/#request-body-parameters).\n"
                }
            },
            "requiredInputs": [
                "atlasCidrBlock",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NetworkContainer resources.\n",
                "properties": {
                    "atlasCidrBlock": {
                        "type": "string",
                        "description": "CIDR block that Atlas uses for the Network Peering containers in your project.  Atlas uses the specified CIDR block for all other Network Peering connections created in the project. The Atlas CIDR block must be at least a /24 and at most a /21 in one of the following [private networks](https://tools.ietf.org/html/rfc1918.html#section-3):\n* Lower bound: 10.0.0.0 -\tUpper bound: 10.255.255.255 -\tPrefix: 10/8\n* Lower bound: 172.16.0.0 -\tUpper bound:172.31.255.255 -\tPrefix:\t172.16/12\n* Lower bound: 192.168.0.0 -\tUpper bound:192.168.255.255 -\tPrefix:\t192.168/16\n\n**Atlas locks this value** if an M10+ cluster or a Network Peering connection already exists. To modify the CIDR block, ensure there are no M10+ clusters in the project and no other Network Peering connections in the project.\n\n**Important**: Atlas limits the number of MongoDB nodes per Network Peering connection based on the CIDR block and the region selected for the project. Contact [MongoDB Support](https://www.mongodb.com/contact?tck=docs_atlas) for any questions on Atlas limits of MongoDB nodes per Network Peering connection.\n"
                    },
                    "azureSubscriptionId": {
                        "type": "string",
                        "description": "Unique identifier of the Azure subscription in which the VNet resides.\n"
                    },
                    "containerId": {
                        "type": "string",
                        "description": "The Network Peering Container ID.\n"
                    },
                    "gcpProjectId": {
                        "type": "string",
                        "description": "Unique identifier of the GCP project in which the network peer resides. Returns null. This value is populated once you create a new network peering connection with the network peering resource.\n"
                    },
                    "networkName": {
                        "type": "string",
                        "description": "Unique identifier of the Network Peering connection in the Atlas project. Returns null. This value is populated once you create a new network peering connection with the network peering resource.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique identifier for the Atlas project for this Network Peering Container.\n",
                        "willReplaceOnChanges": true
                    },
                    "providerName": {
                        "type": "string",
                        "description": "Cloud provider for this Network Peering connection.  Accepted values are GCP, AWS, AZURE. If omitted, Atlas sets this parameter to AWS.\n"
                    },
                    "provisioned": {
                        "type": "boolean",
                        "description": "Indicates whether the project has Network Peering connections deployed in the container.\n"
                    },
                    "region": {
                        "type": "string",
                        "description": "Atlas region where the container resides, see the reference list for Atlas Azure region names [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).\n"
                    },
                    "regionName": {
                        "type": "string",
                        "description": "The Atlas AWS region name for where this container will exist, see the reference list for Atlas AWS region names [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/).\n"
                    },
                    "regions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Atlas regions where the container resides. Provide this field only if you provide an `atlas_cidr_block` smaller than `/18`. [GCP Regions values](https://docs.atlas.mongodb.com/reference/api/vpc-create-container/#request-body-parameters).\n"
                    },
                    "vnetName": {
                        "type": "string",
                        "description": "The name of the Azure VNet. Returns null. This value is populated once you create a new network peering connection with the network peering resource.\n"
                    },
                    "vpcId": {
                        "type": "string",
                        "description": "Unique identifier of Atlas' AWS VPC.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/networkPeering:NetworkPeering": {
            "description": "## # Resource: mongodbatlas.NetworkPeering\n\n`mongodbatlas.NetworkPeering` provides a Network Peering Connection resource. The resource lets you create, edit and delete network peering connections. The resource requires your Project ID.  \n\nEnsure you have first created a network container if it is required for your configuration.  See the network_container resource documentation to determine if you need a network container first.  Examples for creating both container and peering resource are shown below as well as examples for creating the peering connection only.\n\n\u003e **GCP AND AZURE ONLY:** Connect via Peering Only mode is deprecated, so no longer needed.  See [disable Peering Only mode](https://docs.atlas.mongodb.com/reference/faq/connection-changes/#disable-peering-mode) for details\n\n\u003e **AZURE ONLY:** To create the peering request with an Azure VNET, you must grant Atlas the following permissions on the virtual network.\n    Microsoft.Network/virtualNetworks/virtualNetworkPeerings/read\n    Microsoft.Network/virtualNetworks/virtualNetworkPeerings/write\n    Microsoft.Network/virtualNetworks/virtualNetworkPeerings/delete\n    Microsoft.Network/virtualNetworks/peer/action\nFor more information see https://docs.atlas.mongodb.com/security-vpc-peering/ and https://docs.atlas.mongodb.com/reference/api/vpc-create-peering-connection/\n\n\u003e **Create a Whitelist:** Ensure you whitelist the private IP ranges of the subnets in which your application is hosted in order to connect to your Atlas cluster.  See the project_ip_whitelist resource.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find **group_id** in the official documentation.\n\n\n## Example Usage\n\n### Container \u0026 Peering Connection\n\n### Example with AWS\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\n// Container example provided but not always required, \n// see network_container documentation for details. \nconst test = new mongodbatlas.NetworkContainer(\"test\", {\n    projectId: projectId,\n    atlasCidrBlock: \"10.8.0.0/21\",\n    providerName: \"AWS\",\n    regionName: \"US_EAST_1\",\n});\n// Create the peering connection request\nconst testNetworkPeering = new mongodbatlas.NetworkPeering(\"test\", {\n    accepterRegionName: \"us-east-1\",\n    projectId: projectId,\n    containerId: \"507f1f77bcf86cd799439011\",\n    providerName: \"AWS\",\n    routeTableCidrBlock: \"192.168.0.0/24\",\n    vpcId: \"vpc-abc123abc123\",\n    awsAccountId: \"abc123abc123\",\n});\n// the following assumes an AWS provider is configured\n// Accept the peering connection request\nconst peer = new aws.index.VpcPeeringConnectionAccepter(\"peer\", {\n    vpcPeeringConnectionId: testNetworkPeering.connectionId,\n    autoAccept: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\nimport pulumi_mongodbatlas as mongodbatlas\n\n# Container example provided but not always required, \n# see network_container documentation for details. \ntest = mongodbatlas.NetworkContainer(\"test\",\n    project_id=project_id,\n    atlas_cidr_block=\"10.8.0.0/21\",\n    provider_name=\"AWS\",\n    region_name=\"US_EAST_1\")\n# Create the peering connection request\ntest_network_peering = mongodbatlas.NetworkPeering(\"test\",\n    accepter_region_name=\"us-east-1\",\n    project_id=project_id,\n    container_id=\"507f1f77bcf86cd799439011\",\n    provider_name=\"AWS\",\n    route_table_cidr_block=\"192.168.0.0/24\",\n    vpc_id=\"vpc-abc123abc123\",\n    aws_account_id=\"abc123abc123\")\n# the following assumes an AWS provider is configured\n# Accept the peering connection request\npeer = aws.index.VpcPeeringConnectionAccepter(\"peer\",\n    vpc_peering_connection_id=test_network_peering.connection_id,\n    auto_accept=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Container example provided but not always required, \n    // see network_container documentation for details. \n    var test = new Mongodbatlas.NetworkContainer(\"test\", new()\n    {\n        ProjectId = projectId,\n        AtlasCidrBlock = \"10.8.0.0/21\",\n        ProviderName = \"AWS\",\n        RegionName = \"US_EAST_1\",\n    });\n\n    // Create the peering connection request\n    var testNetworkPeering = new Mongodbatlas.NetworkPeering(\"test\", new()\n    {\n        AccepterRegionName = \"us-east-1\",\n        ProjectId = projectId,\n        ContainerId = \"507f1f77bcf86cd799439011\",\n        ProviderName = \"AWS\",\n        RouteTableCidrBlock = \"192.168.0.0/24\",\n        VpcId = \"vpc-abc123abc123\",\n        AwsAccountId = \"abc123abc123\",\n    });\n\n    // the following assumes an AWS provider is configured\n    // Accept the peering connection request\n    var peer = new Aws.Index.VpcPeeringConnectionAccepter(\"peer\", new()\n    {\n        VpcPeeringConnectionId = testNetworkPeering.ConnectionId,\n        AutoAccept = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v4/go/aws\"\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Container example provided but not always required,\n\t\t// see network_container documentation for details.\n\t\t_, err := mongodbatlas.NewNetworkContainer(ctx, \"test\", \u0026mongodbatlas.NetworkContainerArgs{\n\t\t\tProjectId:      pulumi.Any(projectId),\n\t\t\tAtlasCidrBlock: pulumi.String(\"10.8.0.0/21\"),\n\t\t\tProviderName:   pulumi.String(\"AWS\"),\n\t\t\tRegionName:     pulumi.String(\"US_EAST_1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Create the peering connection request\n\t\ttestNetworkPeering, err := mongodbatlas.NewNetworkPeering(ctx, \"test\", \u0026mongodbatlas.NetworkPeeringArgs{\n\t\t\tAccepterRegionName:  pulumi.String(\"us-east-1\"),\n\t\t\tProjectId:           pulumi.Any(projectId),\n\t\t\tContainerId:         pulumi.String(\"507f1f77bcf86cd799439011\"),\n\t\t\tProviderName:        pulumi.String(\"AWS\"),\n\t\t\tRouteTableCidrBlock: pulumi.String(\"192.168.0.0/24\"),\n\t\t\tVpcId:               pulumi.String(\"vpc-abc123abc123\"),\n\t\t\tAwsAccountId:        pulumi.String(\"abc123abc123\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// the following assumes an AWS provider is configured\n\t\t// Accept the peering connection request\n\t\t_, err = aws.NewVpcPeeringConnectionAccepter(ctx, \"peer\", \u0026aws.VpcPeeringConnectionAccepterArgs{\n\t\t\tVpcPeeringConnectionId: testNetworkPeering.ConnectionId,\n\t\t\tAutoAccept:             true,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.NetworkContainer;\nimport com.pulumi.mongodbatlas.NetworkContainerArgs;\nimport com.pulumi.mongodbatlas.NetworkPeering;\nimport com.pulumi.mongodbatlas.NetworkPeeringArgs;\nimport com.pulumi.aws.vpcPeeringConnectionAccepter;\nimport com.pulumi.aws.VpcPeeringConnectionAccepterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Container example provided but not always required, \n        // see network_container documentation for details. \n        var test = new NetworkContainer(\"test\", NetworkContainerArgs.builder()\n            .projectId(projectId)\n            .atlasCidrBlock(\"10.8.0.0/21\")\n            .providerName(\"AWS\")\n            .regionName(\"US_EAST_1\")\n            .build());\n\n        // Create the peering connection request\n        var testNetworkPeering = new NetworkPeering(\"testNetworkPeering\", NetworkPeeringArgs.builder()\n            .accepterRegionName(\"us-east-1\")\n            .projectId(projectId)\n            .containerId(\"507f1f77bcf86cd799439011\")\n            .providerName(\"AWS\")\n            .routeTableCidrBlock(\"192.168.0.0/24\")\n            .vpcId(\"vpc-abc123abc123\")\n            .awsAccountId(\"abc123abc123\")\n            .build());\n\n        // the following assumes an AWS provider is configured\n        // Accept the peering connection request\n        var peer = new VpcPeeringConnectionAccepter(\"peer\", VpcPeeringConnectionAccepterArgs.builder()\n            .vpcPeeringConnectionId(testNetworkPeering.connectionId())\n            .autoAccept(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Container example provided but not always required, \n  # see network_container documentation for details.\n  test:\n    type: mongodbatlas:NetworkContainer\n    properties:\n      projectId: ${projectId}\n      atlasCidrBlock: 10.8.0.0/21\n      providerName: AWS\n      regionName: US_EAST_1\n  # Create the peering connection request\n  testNetworkPeering:\n    type: mongodbatlas:NetworkPeering\n    name: test\n    properties:\n      accepterRegionName: us-east-1\n      projectId: ${projectId}\n      containerId: 507f1f77bcf86cd799439011\n      providerName: AWS\n      routeTableCidrBlock: 192.168.0.0/24\n      vpcId: vpc-abc123abc123\n      awsAccountId: abc123abc123\n  # the following assumes an AWS provider is configured\n  # Accept the peering connection request\n  peer:\n    type: aws:vpcPeeringConnectionAccepter\n    properties:\n      vpcPeeringConnectionId: ${testNetworkPeering.connectionId}\n      autoAccept: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example with Azure\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\n// Ensure you have created the required Azure service principal first, see\n// see https://docs.atlas.mongodb.com/security-vpc-peering/\n// Container example provided but not always required, \n// see network_container documentation for details. \nconst test = new mongodbatlas.NetworkContainer(\"test\", {\n    projectId: projectId,\n    atlasCidrBlock: ATLAS_CIDR_BLOCK,\n    providerName: \"AZURE\",\n    region: \"US_EAST_2\",\n});\n// Create the peering connection request\nconst testNetworkPeering = new mongodbatlas.NetworkPeering(\"test\", {\n    projectId: projectId,\n    containerId: test.containerId,\n    providerName: \"AZURE\",\n    azureDirectoryId: AZURE_DIRECTORY_ID,\n    azureSubscriptionId: AZURE_SUBSCRIPTION_ID,\n    resourceGroupName: AZURE_RESOURCES_GROUP_NAME,\n    vnetName: AZURE_VNET_NAME,\n});\n// Create the cluster once the peering connection is completed\nconst testAdvancedCluster = new mongodbatlas.AdvancedCluster(\"test\", {\n    projectId: projectId,\n    name: \"terraform-manually-test\",\n    clusterType: \"REPLICASET\",\n    backupEnabled: true,\n    replicationSpecs: [{\n        regionConfigs: [{\n            priority: 7,\n            providerName: \"AZURE\",\n            regionName: \"US_EAST_2\",\n            electableSpecs: {\n                instanceSize: \"M10\",\n                nodeCount: 3,\n            },\n        }],\n    }],\n}, {\n    dependsOn: [testNetworkPeering],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\n# Ensure you have created the required Azure service principal first, see\n# see https://docs.atlas.mongodb.com/security-vpc-peering/\n# Container example provided but not always required, \n# see network_container documentation for details. \ntest = mongodbatlas.NetworkContainer(\"test\",\n    project_id=project_id,\n    atlas_cidr_block=atla_s__cid_r__block,\n    provider_name=\"AZURE\",\n    region=\"US_EAST_2\")\n# Create the peering connection request\ntest_network_peering = mongodbatlas.NetworkPeering(\"test\",\n    project_id=project_id,\n    container_id=test.container_id,\n    provider_name=\"AZURE\",\n    azure_directory_id=azur_e__director_y__id,\n    azure_subscription_id=azur_e__subscriptio_n__id,\n    resource_group_name=azur_e__resource_s__grou_p__name,\n    vnet_name=azur_e__vne_t__name)\n# Create the cluster once the peering connection is completed\ntest_advanced_cluster = mongodbatlas.AdvancedCluster(\"test\",\n    project_id=project_id,\n    name=\"terraform-manually-test\",\n    cluster_type=\"REPLICASET\",\n    backup_enabled=True,\n    replication_specs=[{\n        \"region_configs\": [{\n            \"priority\": 7,\n            \"provider_name\": \"AZURE\",\n            \"region_name\": \"US_EAST_2\",\n            \"electable_specs\": {\n                \"instance_size\": \"M10\",\n                \"node_count\": 3,\n            },\n        }],\n    }],\n    opts = pulumi.ResourceOptions(depends_on=[test_network_peering]))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Ensure you have created the required Azure service principal first, see\n    // see https://docs.atlas.mongodb.com/security-vpc-peering/\n    // Container example provided but not always required, \n    // see network_container documentation for details. \n    var test = new Mongodbatlas.NetworkContainer(\"test\", new()\n    {\n        ProjectId = projectId,\n        AtlasCidrBlock = ATLAS_CIDR_BLOCK,\n        ProviderName = \"AZURE\",\n        Region = \"US_EAST_2\",\n    });\n\n    // Create the peering connection request\n    var testNetworkPeering = new Mongodbatlas.NetworkPeering(\"test\", new()\n    {\n        ProjectId = projectId,\n        ContainerId = test.ContainerId,\n        ProviderName = \"AZURE\",\n        AzureDirectoryId = AZURE_DIRECTORY_ID,\n        AzureSubscriptionId = AZURE_SUBSCRIPTION_ID,\n        ResourceGroupName = AZURE_RESOURCES_GROUP_NAME,\n        VnetName = AZURE_VNET_NAME,\n    });\n\n    // Create the cluster once the peering connection is completed\n    var testAdvancedCluster = new Mongodbatlas.AdvancedCluster(\"test\", new()\n    {\n        ProjectId = projectId,\n        Name = \"terraform-manually-test\",\n        ClusterType = \"REPLICASET\",\n        BackupEnabled = true,\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        Priority = 7,\n                        ProviderName = \"AZURE\",\n                        RegionName = \"US_EAST_2\",\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M10\",\n                            NodeCount = 3,\n                        },\n                    },\n                },\n            },\n        },\n    }, new CustomResourceOptions\n    {\n        DependsOn =\n        {\n            testNetworkPeering,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Ensure you have created the required Azure service principal first, see\n\t\t// see https://docs.atlas.mongodb.com/security-vpc-peering/\n\t\t// Container example provided but not always required,\n\t\t// see network_container documentation for details.\n\t\ttest, err := mongodbatlas.NewNetworkContainer(ctx, \"test\", \u0026mongodbatlas.NetworkContainerArgs{\n\t\t\tProjectId:      pulumi.Any(projectId),\n\t\t\tAtlasCidrBlock: pulumi.Any(ATLAS_CIDR_BLOCK),\n\t\t\tProviderName:   pulumi.String(\"AZURE\"),\n\t\t\tRegion:         pulumi.String(\"US_EAST_2\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Create the peering connection request\n\t\ttestNetworkPeering, err := mongodbatlas.NewNetworkPeering(ctx, \"test\", \u0026mongodbatlas.NetworkPeeringArgs{\n\t\t\tProjectId:           pulumi.Any(projectId),\n\t\t\tContainerId:         test.ContainerId,\n\t\t\tProviderName:        pulumi.String(\"AZURE\"),\n\t\t\tAzureDirectoryId:    pulumi.Any(AZURE_DIRECTORY_ID),\n\t\t\tAzureSubscriptionId: pulumi.Any(AZURE_SUBSCRIPTION_ID),\n\t\t\tResourceGroupName:   pulumi.Any(AZURE_RESOURCES_GROUP_NAME),\n\t\t\tVnetName:            pulumi.Any(AZURE_VNET_NAME),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Create the cluster once the peering connection is completed\n\t\t_, err = mongodbatlas.NewAdvancedCluster(ctx, \"test\", \u0026mongodbatlas.AdvancedClusterArgs{\n\t\t\tProjectId:     pulumi.Any(projectId),\n\t\t\tName:          pulumi.String(\"terraform-manually-test\"),\n\t\t\tClusterType:   pulumi.String(\"REPLICASET\"),\n\t\t\tBackupEnabled: pulumi.Bool(true),\n\t\t\tReplicationSpecs: mongodbatlas.AdvancedClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tPriority:     pulumi.Int(7),\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AZURE\"),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"US_EAST_2\"),\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M10\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(3),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\ttestNetworkPeering,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.NetworkContainer;\nimport com.pulumi.mongodbatlas.NetworkContainerArgs;\nimport com.pulumi.mongodbatlas.NetworkPeering;\nimport com.pulumi.mongodbatlas.NetworkPeeringArgs;\nimport com.pulumi.mongodbatlas.AdvancedCluster;\nimport com.pulumi.mongodbatlas.AdvancedClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.AdvancedClusterReplicationSpecArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Ensure you have created the required Azure service principal first, see\n        // see https://docs.atlas.mongodb.com/security-vpc-peering/\n        // Container example provided but not always required, \n        // see network_container documentation for details. \n        var test = new NetworkContainer(\"test\", NetworkContainerArgs.builder()\n            .projectId(projectId)\n            .atlasCidrBlock(ATLAS_CIDR_BLOCK)\n            .providerName(\"AZURE\")\n            .region(\"US_EAST_2\")\n            .build());\n\n        // Create the peering connection request\n        var testNetworkPeering = new NetworkPeering(\"testNetworkPeering\", NetworkPeeringArgs.builder()\n            .projectId(projectId)\n            .containerId(test.containerId())\n            .providerName(\"AZURE\")\n            .azureDirectoryId(AZURE_DIRECTORY_ID)\n            .azureSubscriptionId(AZURE_SUBSCRIPTION_ID)\n            .resourceGroupName(AZURE_RESOURCES_GROUP_NAME)\n            .vnetName(AZURE_VNET_NAME)\n            .build());\n\n        // Create the cluster once the peering connection is completed\n        var testAdvancedCluster = new AdvancedCluster(\"testAdvancedCluster\", AdvancedClusterArgs.builder()\n            .projectId(projectId)\n            .name(\"terraform-manually-test\")\n            .clusterType(\"REPLICASET\")\n            .backupEnabled(true)\n            .replicationSpecs(AdvancedClusterReplicationSpecArgs.builder()\n                .regionConfigs(AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                    .priority(7)\n                    .providerName(\"AZURE\")\n                    .regionName(\"US_EAST_2\")\n                    .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                        .instanceSize(\"M10\")\n                        .nodeCount(3)\n                        .build())\n                    .build())\n                .build())\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(testNetworkPeering)\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Ensure you have created the required Azure service principal first, see\n  # see https://docs.atlas.mongodb.com/security-vpc-peering/\n\n  # Container example provided but not always required, \n  # see network_container documentation for details.\n  test:\n    type: mongodbatlas:NetworkContainer\n    properties:\n      projectId: ${projectId}\n      atlasCidrBlock: ${ATLAS_CIDR_BLOCK}\n      providerName: AZURE\n      region: US_EAST_2\n  # Create the peering connection request\n  testNetworkPeering:\n    type: mongodbatlas:NetworkPeering\n    name: test\n    properties:\n      projectId: ${projectId}\n      containerId: ${test.containerId}\n      providerName: AZURE\n      azureDirectoryId: ${AZURE_DIRECTORY_ID}\n      azureSubscriptionId: ${AZURE_SUBSCRIPTION_ID}\n      resourceGroupName: ${AZURE_RESOURCES_GROUP_NAME}\n      vnetName: ${AZURE_VNET_NAME}\n  # Create the cluster once the peering connection is completed\n  testAdvancedCluster:\n    type: mongodbatlas:AdvancedCluster\n    name: test\n    properties:\n      projectId: ${projectId}\n      name: terraform-manually-test\n      clusterType: REPLICASET\n      backupEnabled: true\n      replicationSpecs:\n        - regionConfigs:\n            - priority: 7\n              providerName: AZURE\n              regionName: US_EAST_2\n              electableSpecs:\n                instanceSize: M10\n                nodeCount: 3\n    options:\n      dependson:\n        - ${testNetworkPeering}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Peering Connection Only, Container Exists\nYou can create a peering connection if an appropriate container for your cloud provider already exists in your project (see the network_container resource for more information).  A container may already exist if you have already created a cluster in your project, if so you may obtain the `container_id` from the cluster resource as shown in the examples below.\n\n## Import\n\nNetwork Peering Connections can be imported using project ID and network peering id, in the format `PROJECTID-PEERID-PROVIDERNAME`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/networkPeering:NetworkPeering my_peering 1112222b3bf99403840e8934-5cbf563d87d9d67253be590a-AWS\n```\n\nUse the [MongoDB Atlas CLI][https://www.mongodb.com/docs/atlas/cli/current/command/atlas-networking-peering-list/#std-label-atlas-networking-peering-list] to obtain your `project_id` and `peering_id`. Attention gcp and azure users: The `atlas networking peering list` command returns only `AWS` peerings by default. You have to include the `--provider` parameter to list peerings for your cloud provider. Valid values are AWS, AZURE, or GCP.\n\natlas projects list\n\natlas networking peering list --projectId \u003cprojectId\u003e --provider \u003cAZURE|GCP|AWS\u003e\n\nSee detailed information for arguments and attributes: [MongoDB API Network Peering Connection](https://docs.atlas.mongodb.com/reference/api/vpc-create-peering-connection/)\n\n",
            "properties": {
                "accepterRegionName": {
                    "type": "string",
                    "description": "Specifies the AWS region where the peer VPC resides. For complete lists of supported regions, see [Amazon Web Services](https://docs.atlas.mongodb.com/reference/amazon-aws/).\n"
                },
                "atlasCidrBlock": {
                    "type": "string"
                },
                "atlasGcpProjectId": {
                    "type": "string",
                    "description": "The Atlas GCP Project ID for the GCP VPC used by your atlas cluster that is needed to set up the reciprocal connection.\n"
                },
                "atlasId": {
                    "type": "string"
                },
                "atlasVpcName": {
                    "type": "string",
                    "description": "Name of the GCP VPC used by your atlas cluster that is needed to set up the reciprocal connection.\n"
                },
                "awsAccountId": {
                    "type": "string",
                    "description": "AWS Account ID of the owner of the peer VPC.\n"
                },
                "azureDirectoryId": {
                    "type": "string",
                    "description": "Unique identifier for an Azure AD directory.\n"
                },
                "azureSubscriptionId": {
                    "type": "string",
                    "description": "Unique identifier of the Azure subscription in which the VNet resides.\n"
                },
                "connectionId": {
                    "type": "string",
                    "description": "Unique identifier of the Atlas network peering container.\n"
                },
                "containerId": {
                    "type": "string",
                    "description": "Unique identifier of the MongoDB Atlas container for the provider (GCP) or provider/region (AWS, AZURE). You can create an MongoDB Atlas container using the network_container resource or it can be obtained from the cluster returned values if a cluster has been created before the first container.\n"
                },
                "errorMessage": {
                    "type": "string",
                    "description": "When `\"status\" : \"FAILED\"`, Atlas provides a description of the error.\n"
                },
                "errorState": {
                    "type": "string",
                    "description": "Description of the Atlas error when `status` is `Failed`, Otherwise, Atlas returns `null`.\n"
                },
                "errorStateName": {
                    "type": "string",
                    "description": "Error state, if any. The VPC peering connection error state value can be one of the following: `REJECTED`, `EXPIRED`, `INVALID_ARGUMENT`.\n"
                },
                "gcpProjectId": {
                    "type": "string",
                    "description": "GCP project ID of the owner of the network peer.\n"
                },
                "networkName": {
                    "type": "string",
                    "description": "Name of the network peer to which Atlas connects.\n\n**AZURE ONLY:**\n"
                },
                "peerId": {
                    "type": "string",
                    "description": "Unique identifier of the Atlas network peer.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the MongoDB Atlas project to create the database user.\n"
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud provider to whom the peering connection is being made. (Possible Values `AWS`, `AZURE`, `GCP`).\n\n**AWS ONLY:**\n"
                },
                "resourceGroupName": {
                    "type": "string",
                    "description": "Name of your Azure resource group.\n"
                },
                "routeTableCidrBlock": {
                    "type": "string",
                    "description": "AWS VPC CIDR block or subnet.\n\n**GCP ONLY:**\n"
                },
                "status": {
                    "type": "string",
                    "description": "Status of the Atlas network peering connection.  Azure/GCP: `ADDING_PEER`, `AVAILABLE`, `FAILED`, `DELETING` GCP Only:  `WAITING_FOR_USER`.\n"
                },
                "statusName": {
                    "type": "string",
                    "description": "(AWS Only) The VPC peering connection status value can be one of the following: `INITIATING`, `PENDING_ACCEPTANCE`, `FAILED`, `FINALIZING`, `AVAILABLE`, `TERMINATING`.\n"
                },
                "vnetName": {
                    "type": "string",
                    "description": "Name of your Azure VNet.\n"
                },
                "vpcId": {
                    "type": "string",
                    "description": "Unique identifier of the AWS peer VPC (Note: this is **not** the same as the Atlas AWS VPC that is returned by the network_container resource).\n"
                }
            },
            "required": [
                "accepterRegionName",
                "atlasCidrBlock",
                "atlasGcpProjectId",
                "atlasId",
                "atlasVpcName",
                "awsAccountId",
                "azureDirectoryId",
                "azureSubscriptionId",
                "connectionId",
                "containerId",
                "errorMessage",
                "errorState",
                "errorStateName",
                "gcpProjectId",
                "networkName",
                "peerId",
                "projectId",
                "providerName",
                "resourceGroupName",
                "routeTableCidrBlock",
                "status",
                "statusName",
                "vnetName",
                "vpcId"
            ],
            "inputProperties": {
                "accepterRegionName": {
                    "type": "string",
                    "description": "Specifies the AWS region where the peer VPC resides. For complete lists of supported regions, see [Amazon Web Services](https://docs.atlas.mongodb.com/reference/amazon-aws/).\n"
                },
                "atlasCidrBlock": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "atlasGcpProjectId": {
                    "type": "string",
                    "description": "The Atlas GCP Project ID for the GCP VPC used by your atlas cluster that is needed to set up the reciprocal connection.\n"
                },
                "atlasVpcName": {
                    "type": "string",
                    "description": "Name of the GCP VPC used by your atlas cluster that is needed to set up the reciprocal connection.\n"
                },
                "awsAccountId": {
                    "type": "string",
                    "description": "AWS Account ID of the owner of the peer VPC.\n"
                },
                "azureDirectoryId": {
                    "type": "string",
                    "description": "Unique identifier for an Azure AD directory.\n",
                    "willReplaceOnChanges": true
                },
                "azureSubscriptionId": {
                    "type": "string",
                    "description": "Unique identifier of the Azure subscription in which the VNet resides.\n",
                    "willReplaceOnChanges": true
                },
                "containerId": {
                    "type": "string",
                    "description": "Unique identifier of the MongoDB Atlas container for the provider (GCP) or provider/region (AWS, AZURE). You can create an MongoDB Atlas container using the network_container resource or it can be obtained from the cluster returned values if a cluster has been created before the first container.\n",
                    "willReplaceOnChanges": true
                },
                "gcpProjectId": {
                    "type": "string",
                    "description": "GCP project ID of the owner of the network peer.\n",
                    "willReplaceOnChanges": true
                },
                "networkName": {
                    "type": "string",
                    "description": "Name of the network peer to which Atlas connects.\n\n**AZURE ONLY:**\n",
                    "willReplaceOnChanges": true
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the MongoDB Atlas project to create the database user.\n",
                    "willReplaceOnChanges": true
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud provider to whom the peering connection is being made. (Possible Values `AWS`, `AZURE`, `GCP`).\n\n**AWS ONLY:**\n"
                },
                "resourceGroupName": {
                    "type": "string",
                    "description": "Name of your Azure resource group.\n",
                    "willReplaceOnChanges": true
                },
                "routeTableCidrBlock": {
                    "type": "string",
                    "description": "AWS VPC CIDR block or subnet.\n\n**GCP ONLY:**\n"
                },
                "vnetName": {
                    "type": "string",
                    "description": "Name of your Azure VNet.\n",
                    "willReplaceOnChanges": true
                },
                "vpcId": {
                    "type": "string",
                    "description": "Unique identifier of the AWS peer VPC (Note: this is **not** the same as the Atlas AWS VPC that is returned by the network_container resource).\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "containerId",
                "projectId",
                "providerName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NetworkPeering resources.\n",
                "properties": {
                    "accepterRegionName": {
                        "type": "string",
                        "description": "Specifies the AWS region where the peer VPC resides. For complete lists of supported regions, see [Amazon Web Services](https://docs.atlas.mongodb.com/reference/amazon-aws/).\n"
                    },
                    "atlasCidrBlock": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "atlasGcpProjectId": {
                        "type": "string",
                        "description": "The Atlas GCP Project ID for the GCP VPC used by your atlas cluster that is needed to set up the reciprocal connection.\n"
                    },
                    "atlasId": {
                        "type": "string"
                    },
                    "atlasVpcName": {
                        "type": "string",
                        "description": "Name of the GCP VPC used by your atlas cluster that is needed to set up the reciprocal connection.\n"
                    },
                    "awsAccountId": {
                        "type": "string",
                        "description": "AWS Account ID of the owner of the peer VPC.\n"
                    },
                    "azureDirectoryId": {
                        "type": "string",
                        "description": "Unique identifier for an Azure AD directory.\n",
                        "willReplaceOnChanges": true
                    },
                    "azureSubscriptionId": {
                        "type": "string",
                        "description": "Unique identifier of the Azure subscription in which the VNet resides.\n",
                        "willReplaceOnChanges": true
                    },
                    "connectionId": {
                        "type": "string",
                        "description": "Unique identifier of the Atlas network peering container.\n"
                    },
                    "containerId": {
                        "type": "string",
                        "description": "Unique identifier of the MongoDB Atlas container for the provider (GCP) or provider/region (AWS, AZURE). You can create an MongoDB Atlas container using the network_container resource or it can be obtained from the cluster returned values if a cluster has been created before the first container.\n",
                        "willReplaceOnChanges": true
                    },
                    "errorMessage": {
                        "type": "string",
                        "description": "When `\"status\" : \"FAILED\"`, Atlas provides a description of the error.\n"
                    },
                    "errorState": {
                        "type": "string",
                        "description": "Description of the Atlas error when `status` is `Failed`, Otherwise, Atlas returns `null`.\n"
                    },
                    "errorStateName": {
                        "type": "string",
                        "description": "Error state, if any. The VPC peering connection error state value can be one of the following: `REJECTED`, `EXPIRED`, `INVALID_ARGUMENT`.\n"
                    },
                    "gcpProjectId": {
                        "type": "string",
                        "description": "GCP project ID of the owner of the network peer.\n",
                        "willReplaceOnChanges": true
                    },
                    "networkName": {
                        "type": "string",
                        "description": "Name of the network peer to which Atlas connects.\n\n**AZURE ONLY:**\n",
                        "willReplaceOnChanges": true
                    },
                    "peerId": {
                        "type": "string",
                        "description": "Unique identifier of the Atlas network peer.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the MongoDB Atlas project to create the database user.\n",
                        "willReplaceOnChanges": true
                    },
                    "providerName": {
                        "type": "string",
                        "description": "Cloud provider to whom the peering connection is being made. (Possible Values `AWS`, `AZURE`, `GCP`).\n\n**AWS ONLY:**\n"
                    },
                    "resourceGroupName": {
                        "type": "string",
                        "description": "Name of your Azure resource group.\n",
                        "willReplaceOnChanges": true
                    },
                    "routeTableCidrBlock": {
                        "type": "string",
                        "description": "AWS VPC CIDR block or subnet.\n\n**GCP ONLY:**\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Status of the Atlas network peering connection.  Azure/GCP: `ADDING_PEER`, `AVAILABLE`, `FAILED`, `DELETING` GCP Only:  `WAITING_FOR_USER`.\n"
                    },
                    "statusName": {
                        "type": "string",
                        "description": "(AWS Only) The VPC peering connection status value can be one of the following: `INITIATING`, `PENDING_ACCEPTANCE`, `FAILED`, `FINALIZING`, `AVAILABLE`, `TERMINATING`.\n"
                    },
                    "vnetName": {
                        "type": "string",
                        "description": "Name of your Azure VNet.\n",
                        "willReplaceOnChanges": true
                    },
                    "vpcId": {
                        "type": "string",
                        "description": "Unique identifier of the AWS peer VPC (Note: this is **not** the same as the Atlas AWS VPC that is returned by the network_container resource).\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/onlineArchive:OnlineArchive": {
            "description": "## # Resource: mongodbatlas.OnlineArchive\n\n`mongodbatlas.OnlineArchive` resource provides access to create, edit, pause and resume an online archive for a collection. \n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n\u003e **IMPORTANT:** The collection must exists before performing an online archive.\n\n\u003e **IMPORTANT:** There are fields that are immutable after creation, i.e if `date_field` value does not exist in the collection, the online archive state will be pending forever, and this field cannot be updated, that means a destroy is required, known error `ONLINE_ARCHIVE_CANNOT_MODIFY_FIELD`\n\n## Example Usage\n\n### S\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.OnlineArchive(\"test\", {\n    projectId: projectId,\n    clusterName: clusterName,\n    collName: collectionName,\n    dbName: databaseName,\n    partitionFields: [\n        {\n            fieldName: \"dateField\",\n            order: 0,\n        },\n        {\n            fieldName: \"firstName\",\n            order: 1,\n        },\n        {\n            fieldName: \"lastName\",\n            order: 2,\n        },\n    ],\n    criteria: {\n        type: \"DATE\",\n        dateField: \"dateField\",\n        expireAfterDays: 5,\n    },\n    schedule: {\n        type: \"DAILY\",\n        endHour: 1,\n        endMinute: 1,\n        startHour: 1,\n        startMinute: 1,\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.OnlineArchive(\"test\",\n    project_id=project_id,\n    cluster_name=cluster_name,\n    coll_name=collection_name,\n    db_name=database_name,\n    partition_fields=[\n        {\n            \"field_name\": \"dateField\",\n            \"order\": 0,\n        },\n        {\n            \"field_name\": \"firstName\",\n            \"order\": 1,\n        },\n        {\n            \"field_name\": \"lastName\",\n            \"order\": 2,\n        },\n    ],\n    criteria={\n        \"type\": \"DATE\",\n        \"date_field\": \"dateField\",\n        \"expire_after_days\": 5,\n    },\n    schedule={\n        \"type\": \"DAILY\",\n        \"end_hour\": 1,\n        \"end_minute\": 1,\n        \"start_hour\": 1,\n        \"start_minute\": 1,\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.OnlineArchive(\"test\", new()\n    {\n        ProjectId = projectId,\n        ClusterName = clusterName,\n        CollName = collectionName,\n        DbName = databaseName,\n        PartitionFields = new[]\n        {\n            new Mongodbatlas.Inputs.OnlineArchivePartitionFieldArgs\n            {\n                FieldName = \"dateField\",\n                Order = 0,\n            },\n            new Mongodbatlas.Inputs.OnlineArchivePartitionFieldArgs\n            {\n                FieldName = \"firstName\",\n                Order = 1,\n            },\n            new Mongodbatlas.Inputs.OnlineArchivePartitionFieldArgs\n            {\n                FieldName = \"lastName\",\n                Order = 2,\n            },\n        },\n        Criteria = new Mongodbatlas.Inputs.OnlineArchiveCriteriaArgs\n        {\n            Type = \"DATE\",\n            DateField = \"dateField\",\n            ExpireAfterDays = 5,\n        },\n        Schedule = new Mongodbatlas.Inputs.OnlineArchiveScheduleArgs\n        {\n            Type = \"DAILY\",\n            EndHour = 1,\n            EndMinute = 1,\n            StartHour = 1,\n            StartMinute = 1,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewOnlineArchive(ctx, \"test\", \u0026mongodbatlas.OnlineArchiveArgs{\n\t\t\tProjectId:   pulumi.Any(projectId),\n\t\t\tClusterName: pulumi.Any(clusterName),\n\t\t\tCollName:    pulumi.Any(collectionName),\n\t\t\tDbName:      pulumi.Any(databaseName),\n\t\t\tPartitionFields: mongodbatlas.OnlineArchivePartitionFieldArray{\n\t\t\t\t\u0026mongodbatlas.OnlineArchivePartitionFieldArgs{\n\t\t\t\t\tFieldName: pulumi.String(\"dateField\"),\n\t\t\t\t\tOrder:     pulumi.Int(0),\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.OnlineArchivePartitionFieldArgs{\n\t\t\t\t\tFieldName: pulumi.String(\"firstName\"),\n\t\t\t\t\tOrder:     pulumi.Int(1),\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.OnlineArchivePartitionFieldArgs{\n\t\t\t\t\tFieldName: pulumi.String(\"lastName\"),\n\t\t\t\t\tOrder:     pulumi.Int(2),\n\t\t\t\t},\n\t\t\t},\n\t\t\tCriteria: \u0026mongodbatlas.OnlineArchiveCriteriaArgs{\n\t\t\t\tType:            pulumi.String(\"DATE\"),\n\t\t\t\tDateField:       pulumi.String(\"dateField\"),\n\t\t\t\tExpireAfterDays: pulumi.Int(5),\n\t\t\t},\n\t\t\tSchedule: \u0026mongodbatlas.OnlineArchiveScheduleArgs{\n\t\t\t\tType:        pulumi.String(\"DAILY\"),\n\t\t\t\tEndHour:     pulumi.Int(1),\n\t\t\t\tEndMinute:   pulumi.Int(1),\n\t\t\t\tStartHour:   pulumi.Int(1),\n\t\t\t\tStartMinute: pulumi.Int(1),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.OnlineArchive;\nimport com.pulumi.mongodbatlas.OnlineArchiveArgs;\nimport com.pulumi.mongodbatlas.inputs.OnlineArchivePartitionFieldArgs;\nimport com.pulumi.mongodbatlas.inputs.OnlineArchiveCriteriaArgs;\nimport com.pulumi.mongodbatlas.inputs.OnlineArchiveScheduleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new OnlineArchive(\"test\", OnlineArchiveArgs.builder()\n            .projectId(projectId)\n            .clusterName(clusterName)\n            .collName(collectionName)\n            .dbName(databaseName)\n            .partitionFields(            \n                OnlineArchivePartitionFieldArgs.builder()\n                    .fieldName(\"dateField\")\n                    .order(0)\n                    .build(),\n                OnlineArchivePartitionFieldArgs.builder()\n                    .fieldName(\"firstName\")\n                    .order(1)\n                    .build(),\n                OnlineArchivePartitionFieldArgs.builder()\n                    .fieldName(\"lastName\")\n                    .order(2)\n                    .build())\n            .criteria(OnlineArchiveCriteriaArgs.builder()\n                .type(\"DATE\")\n                .dateField(\"dateField\")\n                .expireAfterDays(5)\n                .build())\n            .schedule(OnlineArchiveScheduleArgs.builder()\n                .type(\"DAILY\")\n                .endHour(1)\n                .endMinute(1)\n                .startHour(1)\n                .startMinute(1)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:OnlineArchive\n    properties:\n      projectId: ${projectId}\n      clusterName: ${clusterName}\n      collName: ${collectionName}\n      dbName: ${databaseName}\n      partitionFields:\n        - fieldName: dateField\n          order: 0\n        - fieldName: firstName\n          order: 1\n        - fieldName: lastName\n          order: 2\n      criteria:\n        type: DATE\n        dateField: dateField\n        expireAfterDays: 5\n      schedule:\n        type: DAILY\n        endHour: 1\n        endMinute: 1\n        startHour: 1\n        startMinute: 1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nFor custom criteria example\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.OnlineArchive(\"test\", {\n    projectId: projectId,\n    clusterName: clusterName,\n    collName: collectionName,\n    dbName: databaseName,\n    partitionFields: [\n        {\n            fieldName: \"firstName\",\n            order: 0,\n        },\n        {\n            fieldName: \"secondName\",\n            order: 1,\n        },\n    ],\n    criteria: {\n        type: \"CUSTOM\",\n        query: \"{ \\\"department\\\": \\\"engineering\\\" }\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.OnlineArchive(\"test\",\n    project_id=project_id,\n    cluster_name=cluster_name,\n    coll_name=collection_name,\n    db_name=database_name,\n    partition_fields=[\n        {\n            \"field_name\": \"firstName\",\n            \"order\": 0,\n        },\n        {\n            \"field_name\": \"secondName\",\n            \"order\": 1,\n        },\n    ],\n    criteria={\n        \"type\": \"CUSTOM\",\n        \"query\": \"{ \\\"department\\\": \\\"engineering\\\" }\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.OnlineArchive(\"test\", new()\n    {\n        ProjectId = projectId,\n        ClusterName = clusterName,\n        CollName = collectionName,\n        DbName = databaseName,\n        PartitionFields = new[]\n        {\n            new Mongodbatlas.Inputs.OnlineArchivePartitionFieldArgs\n            {\n                FieldName = \"firstName\",\n                Order = 0,\n            },\n            new Mongodbatlas.Inputs.OnlineArchivePartitionFieldArgs\n            {\n                FieldName = \"secondName\",\n                Order = 1,\n            },\n        },\n        Criteria = new Mongodbatlas.Inputs.OnlineArchiveCriteriaArgs\n        {\n            Type = \"CUSTOM\",\n            Query = \"{ \\\"department\\\": \\\"engineering\\\" }\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewOnlineArchive(ctx, \"test\", \u0026mongodbatlas.OnlineArchiveArgs{\n\t\t\tProjectId:   pulumi.Any(projectId),\n\t\t\tClusterName: pulumi.Any(clusterName),\n\t\t\tCollName:    pulumi.Any(collectionName),\n\t\t\tDbName:      pulumi.Any(databaseName),\n\t\t\tPartitionFields: mongodbatlas.OnlineArchivePartitionFieldArray{\n\t\t\t\t\u0026mongodbatlas.OnlineArchivePartitionFieldArgs{\n\t\t\t\t\tFieldName: pulumi.String(\"firstName\"),\n\t\t\t\t\tOrder:     pulumi.Int(0),\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.OnlineArchivePartitionFieldArgs{\n\t\t\t\t\tFieldName: pulumi.String(\"secondName\"),\n\t\t\t\t\tOrder:     pulumi.Int(1),\n\t\t\t\t},\n\t\t\t},\n\t\t\tCriteria: \u0026mongodbatlas.OnlineArchiveCriteriaArgs{\n\t\t\t\tType:  pulumi.String(\"CUSTOM\"),\n\t\t\t\tQuery: pulumi.String(\"{ \\\"department\\\": \\\"engineering\\\" }\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.OnlineArchive;\nimport com.pulumi.mongodbatlas.OnlineArchiveArgs;\nimport com.pulumi.mongodbatlas.inputs.OnlineArchivePartitionFieldArgs;\nimport com.pulumi.mongodbatlas.inputs.OnlineArchiveCriteriaArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new OnlineArchive(\"test\", OnlineArchiveArgs.builder()\n            .projectId(projectId)\n            .clusterName(clusterName)\n            .collName(collectionName)\n            .dbName(databaseName)\n            .partitionFields(            \n                OnlineArchivePartitionFieldArgs.builder()\n                    .fieldName(\"firstName\")\n                    .order(0)\n                    .build(),\n                OnlineArchivePartitionFieldArgs.builder()\n                    .fieldName(\"secondName\")\n                    .order(1)\n                    .build())\n            .criteria(OnlineArchiveCriteriaArgs.builder()\n                .type(\"CUSTOM\")\n                .query(\"{ \\\"department\\\": \\\"engineering\\\" }\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:OnlineArchive\n    properties:\n      projectId: ${projectId}\n      clusterName: ${clusterName}\n      collName: ${collectionName}\n      dbName: ${databaseName}\n      partitionFields:\n        - fieldName: firstName\n          order: 0\n        - fieldName: secondName\n          order: 1\n      criteria:\n        type: CUSTOM\n        query: '{ \"department\": \"engineering\" }'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nDefining custom provider and region example\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.OnlineArchive(\"test\", {\n    projectId: projectId,\n    clusterName: clusterName,\n    collName: collectionName,\n    dbName: databaseName,\n    dataProcessRegion: {\n        cloudProvider: \"AZURE\",\n        region: \"US_EAST_2\",\n    },\n    partitionFields: [{\n        fieldName: \"firstName\",\n        order: 0,\n    }],\n    criteria: {\n        type: \"CUSTOM\",\n        query: \"{ \\\"department\\\": \\\"engineering\\\" }\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.OnlineArchive(\"test\",\n    project_id=project_id,\n    cluster_name=cluster_name,\n    coll_name=collection_name,\n    db_name=database_name,\n    data_process_region={\n        \"cloud_provider\": \"AZURE\",\n        \"region\": \"US_EAST_2\",\n    },\n    partition_fields=[{\n        \"field_name\": \"firstName\",\n        \"order\": 0,\n    }],\n    criteria={\n        \"type\": \"CUSTOM\",\n        \"query\": \"{ \\\"department\\\": \\\"engineering\\\" }\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.OnlineArchive(\"test\", new()\n    {\n        ProjectId = projectId,\n        ClusterName = clusterName,\n        CollName = collectionName,\n        DbName = databaseName,\n        DataProcessRegion = new Mongodbatlas.Inputs.OnlineArchiveDataProcessRegionArgs\n        {\n            CloudProvider = \"AZURE\",\n            Region = \"US_EAST_2\",\n        },\n        PartitionFields = new[]\n        {\n            new Mongodbatlas.Inputs.OnlineArchivePartitionFieldArgs\n            {\n                FieldName = \"firstName\",\n                Order = 0,\n            },\n        },\n        Criteria = new Mongodbatlas.Inputs.OnlineArchiveCriteriaArgs\n        {\n            Type = \"CUSTOM\",\n            Query = \"{ \\\"department\\\": \\\"engineering\\\" }\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewOnlineArchive(ctx, \"test\", \u0026mongodbatlas.OnlineArchiveArgs{\n\t\t\tProjectId:   pulumi.Any(projectId),\n\t\t\tClusterName: pulumi.Any(clusterName),\n\t\t\tCollName:    pulumi.Any(collectionName),\n\t\t\tDbName:      pulumi.Any(databaseName),\n\t\t\tDataProcessRegion: \u0026mongodbatlas.OnlineArchiveDataProcessRegionArgs{\n\t\t\t\tCloudProvider: pulumi.String(\"AZURE\"),\n\t\t\t\tRegion:        pulumi.String(\"US_EAST_2\"),\n\t\t\t},\n\t\t\tPartitionFields: mongodbatlas.OnlineArchivePartitionFieldArray{\n\t\t\t\t\u0026mongodbatlas.OnlineArchivePartitionFieldArgs{\n\t\t\t\t\tFieldName: pulumi.String(\"firstName\"),\n\t\t\t\t\tOrder:     pulumi.Int(0),\n\t\t\t\t},\n\t\t\t},\n\t\t\tCriteria: \u0026mongodbatlas.OnlineArchiveCriteriaArgs{\n\t\t\t\tType:  pulumi.String(\"CUSTOM\"),\n\t\t\t\tQuery: pulumi.String(\"{ \\\"department\\\": \\\"engineering\\\" }\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.OnlineArchive;\nimport com.pulumi.mongodbatlas.OnlineArchiveArgs;\nimport com.pulumi.mongodbatlas.inputs.OnlineArchiveDataProcessRegionArgs;\nimport com.pulumi.mongodbatlas.inputs.OnlineArchivePartitionFieldArgs;\nimport com.pulumi.mongodbatlas.inputs.OnlineArchiveCriteriaArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new OnlineArchive(\"test\", OnlineArchiveArgs.builder()\n            .projectId(projectId)\n            .clusterName(clusterName)\n            .collName(collectionName)\n            .dbName(databaseName)\n            .dataProcessRegion(OnlineArchiveDataProcessRegionArgs.builder()\n                .cloudProvider(\"AZURE\")\n                .region(\"US_EAST_2\")\n                .build())\n            .partitionFields(OnlineArchivePartitionFieldArgs.builder()\n                .fieldName(\"firstName\")\n                .order(0)\n                .build())\n            .criteria(OnlineArchiveCriteriaArgs.builder()\n                .type(\"CUSTOM\")\n                .query(\"{ \\\"department\\\": \\\"engineering\\\" }\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:OnlineArchive\n    properties:\n      projectId: ${projectId}\n      clusterName: ${clusterName}\n      collName: ${collectionName}\n      dbName: ${databaseName}\n      dataProcessRegion:\n        cloudProvider: AZURE\n        region: US_EAST_2\n      partitionFields:\n        - fieldName: firstName\n          order: 0\n      criteria:\n        type: CUSTOM\n        query: '{ \"department\": \"engineering\" }'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import \n\n```bash\nterraform import mongodbatlas_online_archive.users_archive \u003cproject_id\u003e-\u003ccluster_name\u003e-\u003carchive_id\u003e\n```\n\nSee [MongoDB Atlas API](https://docs.atlas.mongodb.com/reference/api/online-archive-create-one/) Documentation for more information.\n",
            "properties": {
                "archiveId": {
                    "type": "string",
                    "description": "ID of the online archive.\n"
                },
                "clusterName": {
                    "type": "string",
                    "description": "Name of the cluster that contains the collection.\n"
                },
                "collName": {
                    "type": "string",
                    "description": "Name of the collection.\n"
                },
                "collectionType": {
                    "type": "string",
                    "description": "Type of MongoDB collection that you want to return. This value can be \"TIMESERIES\" or \"STANDARD\". Default is \"STANDARD\".\n"
                },
                "criteria": {
                    "$ref": "#/types/mongodbatlas:index/OnlineArchiveCriteria:OnlineArchiveCriteria",
                    "description": "Criteria to use for archiving data. See criteria.\n"
                },
                "dataExpirationRule": {
                    "$ref": "#/types/mongodbatlas:index/OnlineArchiveDataExpirationRule:OnlineArchiveDataExpirationRule",
                    "description": "Rule for specifying when data should be deleted from the archive. See data expiration rule.\n"
                },
                "dataProcessRegion": {
                    "$ref": "#/types/mongodbatlas:index/OnlineArchiveDataProcessRegion:OnlineArchiveDataProcessRegion",
                    "description": "Settings to configure the region where you wish to store your archived data. See data process region. This field is immutable hence cannot be updated.\n"
                },
                "dbName": {
                    "type": "string",
                    "description": "Name of the database that contains the collection.\n"
                },
                "partitionFields": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/OnlineArchivePartitionField:OnlineArchivePartitionField"
                    },
                    "description": "Fields to use to partition data. You can specify up to two frequently queried fields (or up to three fields when one of them is `date_field`) to use for partitioning data. Queries that donât contain the specified fields require a full collection scan of all archived documents, which takes longer and increases your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived. See partition fields.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "State of the online archive. This is required for pausing an active online archive or resuming a paused online archive. If the collection has another active online archive, the resume request fails.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project\n"
                },
                "schedule": {
                    "$ref": "#/types/mongodbatlas:index/OnlineArchiveSchedule:OnlineArchiveSchedule",
                    "description": "Regular frequency and duration when archiving process occurs. See schedule.\n"
                },
                "state": {
                    "type": "string",
                    "description": "Status of the online archive. Valid values are: Pending, Archiving, Idle, Pausing, Paused, Orphaned and Deleted\n"
                },
                "syncCreation": {
                    "type": "boolean"
                }
            },
            "required": [
                "archiveId",
                "clusterName",
                "collName",
                "collectionType",
                "criteria",
                "dataProcessRegion",
                "dbName",
                "partitionFields",
                "paused",
                "projectId",
                "state"
            ],
            "inputProperties": {
                "clusterName": {
                    "type": "string",
                    "description": "Name of the cluster that contains the collection.\n",
                    "willReplaceOnChanges": true
                },
                "collName": {
                    "type": "string",
                    "description": "Name of the collection.\n"
                },
                "collectionType": {
                    "type": "string",
                    "description": "Type of MongoDB collection that you want to return. This value can be \"TIMESERIES\" or \"STANDARD\". Default is \"STANDARD\".\n"
                },
                "criteria": {
                    "$ref": "#/types/mongodbatlas:index/OnlineArchiveCriteria:OnlineArchiveCriteria",
                    "description": "Criteria to use for archiving data. See criteria.\n"
                },
                "dataExpirationRule": {
                    "$ref": "#/types/mongodbatlas:index/OnlineArchiveDataExpirationRule:OnlineArchiveDataExpirationRule",
                    "description": "Rule for specifying when data should be deleted from the archive. See data expiration rule.\n"
                },
                "dataProcessRegion": {
                    "$ref": "#/types/mongodbatlas:index/OnlineArchiveDataProcessRegion:OnlineArchiveDataProcessRegion",
                    "description": "Settings to configure the region where you wish to store your archived data. See data process region. This field is immutable hence cannot be updated.\n"
                },
                "dbName": {
                    "type": "string",
                    "description": "Name of the database that contains the collection.\n"
                },
                "partitionFields": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/OnlineArchivePartitionField:OnlineArchivePartitionField"
                    },
                    "description": "Fields to use to partition data. You can specify up to two frequently queried fields (or up to three fields when one of them is `date_field`) to use for partitioning data. Queries that donât contain the specified fields require a full collection scan of all archived documents, which takes longer and increases your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived. See partition fields.\n"
                },
                "paused": {
                    "type": "boolean",
                    "description": "State of the online archive. This is required for pausing an active online archive or resuming a paused online archive. If the collection has another active online archive, the resume request fails.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project\n",
                    "willReplaceOnChanges": true
                },
                "schedule": {
                    "$ref": "#/types/mongodbatlas:index/OnlineArchiveSchedule:OnlineArchiveSchedule",
                    "description": "Regular frequency and duration when archiving process occurs. See schedule.\n"
                },
                "syncCreation": {
                    "type": "boolean"
                }
            },
            "requiredInputs": [
                "clusterName",
                "collName",
                "criteria",
                "dbName",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OnlineArchive resources.\n",
                "properties": {
                    "archiveId": {
                        "type": "string",
                        "description": "ID of the online archive.\n"
                    },
                    "clusterName": {
                        "type": "string",
                        "description": "Name of the cluster that contains the collection.\n",
                        "willReplaceOnChanges": true
                    },
                    "collName": {
                        "type": "string",
                        "description": "Name of the collection.\n"
                    },
                    "collectionType": {
                        "type": "string",
                        "description": "Type of MongoDB collection that you want to return. This value can be \"TIMESERIES\" or \"STANDARD\". Default is \"STANDARD\".\n"
                    },
                    "criteria": {
                        "$ref": "#/types/mongodbatlas:index/OnlineArchiveCriteria:OnlineArchiveCriteria",
                        "description": "Criteria to use for archiving data. See criteria.\n"
                    },
                    "dataExpirationRule": {
                        "$ref": "#/types/mongodbatlas:index/OnlineArchiveDataExpirationRule:OnlineArchiveDataExpirationRule",
                        "description": "Rule for specifying when data should be deleted from the archive. See data expiration rule.\n"
                    },
                    "dataProcessRegion": {
                        "$ref": "#/types/mongodbatlas:index/OnlineArchiveDataProcessRegion:OnlineArchiveDataProcessRegion",
                        "description": "Settings to configure the region where you wish to store your archived data. See data process region. This field is immutable hence cannot be updated.\n"
                    },
                    "dbName": {
                        "type": "string",
                        "description": "Name of the database that contains the collection.\n"
                    },
                    "partitionFields": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/OnlineArchivePartitionField:OnlineArchivePartitionField"
                        },
                        "description": "Fields to use to partition data. You can specify up to two frequently queried fields (or up to three fields when one of them is `date_field`) to use for partitioning data. Queries that donât contain the specified fields require a full collection scan of all archived documents, which takes longer and increases your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived. See partition fields.\n"
                    },
                    "paused": {
                        "type": "boolean",
                        "description": "State of the online archive. This is required for pausing an active online archive or resuming a paused online archive. If the collection has another active online archive, the resume request fails.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project\n",
                        "willReplaceOnChanges": true
                    },
                    "schedule": {
                        "$ref": "#/types/mongodbatlas:index/OnlineArchiveSchedule:OnlineArchiveSchedule",
                        "description": "Regular frequency and duration when archiving process occurs. See schedule.\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "Status of the online archive. Valid values are: Pending, Archiving, Idle, Pausing, Paused, Orphaned and Deleted\n"
                    },
                    "syncCreation": {
                        "type": "boolean"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/orgInvitation:OrgInvitation": {
            "description": "## Example Usage\n\n### S\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test0 = new mongodbatlas.OrgInvitation(\"test0\", {\n    username: \"test0-acc-username\",\n    orgId: \"\u003cORG-ID\u003e\",\n    roles: [\"ORG_OWNER\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest0 = mongodbatlas.OrgInvitation(\"test0\",\n    username=\"test0-acc-username\",\n    org_id=\"\u003cORG-ID\u003e\",\n    roles=[\"ORG_OWNER\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test0 = new Mongodbatlas.OrgInvitation(\"test0\", new()\n    {\n        Username = \"test0-acc-username\",\n        OrgId = \"\u003cORG-ID\u003e\",\n        Roles = new[]\n        {\n            \"ORG_OWNER\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewOrgInvitation(ctx, \"test0\", \u0026mongodbatlas.OrgInvitationArgs{\n\t\t\tUsername: pulumi.String(\"test0-acc-username\"),\n\t\t\tOrgId:    pulumi.String(\"\u003cORG-ID\u003e\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"ORG_OWNER\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.OrgInvitation;\nimport com.pulumi.mongodbatlas.OrgInvitationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test0 = new OrgInvitation(\"test0\", OrgInvitationArgs.builder()\n            .username(\"test0-acc-username\")\n            .orgId(\"\u003cORG-ID\u003e\")\n            .roles(\"ORG_OWNER\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test0:\n    type: mongodbatlas:OrgInvitation\n    properties:\n      username: test0-acc-username\n      orgId: \u003cORG-ID\u003e\n      roles:\n        - ORG_OWNER\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test0 = new mongodbatlas.OrgInvitation(\"test0\", {\n    username: \"test0-acc-username\",\n    orgId: \"\u003cORG-ID\u003e\",\n    roles: [\n        \"ORG_MEMBER\",\n        \"ORG_BILLING_ADMIN\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest0 = mongodbatlas.OrgInvitation(\"test0\",\n    username=\"test0-acc-username\",\n    org_id=\"\u003cORG-ID\u003e\",\n    roles=[\n        \"ORG_MEMBER\",\n        \"ORG_BILLING_ADMIN\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test0 = new Mongodbatlas.OrgInvitation(\"test0\", new()\n    {\n        Username = \"test0-acc-username\",\n        OrgId = \"\u003cORG-ID\u003e\",\n        Roles = new[]\n        {\n            \"ORG_MEMBER\",\n            \"ORG_BILLING_ADMIN\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewOrgInvitation(ctx, \"test0\", \u0026mongodbatlas.OrgInvitationArgs{\n\t\t\tUsername: pulumi.String(\"test0-acc-username\"),\n\t\t\tOrgId:    pulumi.String(\"\u003cORG-ID\u003e\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"ORG_MEMBER\"),\n\t\t\t\tpulumi.String(\"ORG_BILLING_ADMIN\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.OrgInvitation;\nimport com.pulumi.mongodbatlas.OrgInvitationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test0 = new OrgInvitation(\"test0\", OrgInvitationArgs.builder()\n            .username(\"test0-acc-username\")\n            .orgId(\"\u003cORG-ID\u003e\")\n            .roles(            \n                \"ORG_MEMBER\",\n                \"ORG_BILLING_ADMIN\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test0:\n    type: mongodbatlas:OrgInvitation\n    properties:\n      username: test0-acc-username\n      orgId: \u003cORG-ID\u003e\n      roles:\n        - ORG_MEMBER\n        - ORG_BILLING_ADMIN\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test1 = new mongodbatlas.OrgInvitation(\"test1\", {\n    username: \"test1-acc-username\",\n    orgId: \"\u003cORG-ID\u003e\",\n    teamsIds: [\n        \"\u003cTEAM-0-ID\u003e\",\n        \"\u003cTEAM-1-ID\u003e\",\n    ],\n    roles: [\"ORG_MEMBER\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest1 = mongodbatlas.OrgInvitation(\"test1\",\n    username=\"test1-acc-username\",\n    org_id=\"\u003cORG-ID\u003e\",\n    teams_ids=[\n        \"\u003cTEAM-0-ID\u003e\",\n        \"\u003cTEAM-1-ID\u003e\",\n    ],\n    roles=[\"ORG_MEMBER\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test1 = new Mongodbatlas.OrgInvitation(\"test1\", new()\n    {\n        Username = \"test1-acc-username\",\n        OrgId = \"\u003cORG-ID\u003e\",\n        TeamsIds = new[]\n        {\n            \"\u003cTEAM-0-ID\u003e\",\n            \"\u003cTEAM-1-ID\u003e\",\n        },\n        Roles = new[]\n        {\n            \"ORG_MEMBER\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewOrgInvitation(ctx, \"test1\", \u0026mongodbatlas.OrgInvitationArgs{\n\t\t\tUsername: pulumi.String(\"test1-acc-username\"),\n\t\t\tOrgId:    pulumi.String(\"\u003cORG-ID\u003e\"),\n\t\t\tTeamsIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"\u003cTEAM-0-ID\u003e\"),\n\t\t\t\tpulumi.String(\"\u003cTEAM-1-ID\u003e\"),\n\t\t\t},\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"ORG_MEMBER\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.OrgInvitation;\nimport com.pulumi.mongodbatlas.OrgInvitationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test1 = new OrgInvitation(\"test1\", OrgInvitationArgs.builder()\n            .username(\"test1-acc-username\")\n            .orgId(\"\u003cORG-ID\u003e\")\n            .teamsIds(            \n                \"\u003cTEAM-0-ID\u003e\",\n                \"\u003cTEAM-1-ID\u003e\")\n            .roles(\"ORG_MEMBER\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test1:\n    type: mongodbatlas:OrgInvitation\n    properties:\n      username: test1-acc-username\n      orgId: \u003cORG-ID\u003e\n      teamsIds:\n        - \u003cTEAM-0-ID\u003e\n        - \u003cTEAM-1-ID\u003e\n      roles:\n        - ORG_MEMBER\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n~\u003e __IMPORTANT:__\nAn organization invitation can __not__ be imported once it has been accepted.\n\nImport a user's invitation to an organization by separating the `org_id` and the `username` with a hyphen:\n\n```sh\n$ pulumi import mongodbatlas:index/orgInvitation:OrgInvitation my_user 1112222b3bf99403840e8934-my_user@mongodb.com\n```\n",
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when Atlas sent the invitation.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when the invitation expires. Users have 30 days to accept an invitation.\n"
                },
                "invitationId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the invitation in Atlas.\n"
                },
                "inviterUsername": {
                    "type": "string",
                    "description": "Atlas user who invited `username` to the organization.\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization to which you want to invite a user.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Atlas roles to assign to the invited user. If the user accepts the invitation, Atlas assigns these roles to them. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles a user can have.\n"
                },
                "teamsIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of unique 24-hexadecimal digit strings that identify the teams that the user was invited to join.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Email address of the invited user. This is the address to which Atlas sends the invite. If the user accepts the invitation, they log in to Atlas with this username.\n"
                }
            },
            "required": [
                "createdAt",
                "expiresAt",
                "invitationId",
                "inviterUsername",
                "orgId",
                "roles",
                "teamsIds",
                "username"
            ],
            "inputProperties": {
                "orgId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the organization to which you want to invite a user.\n",
                    "willReplaceOnChanges": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Atlas roles to assign to the invited user. If the user accepts the invitation, Atlas assigns these roles to them. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles a user can have.\n"
                },
                "teamsIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "An array of unique 24-hexadecimal digit strings that identify the teams that the user was invited to join.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Email address of the invited user. This is the address to which Atlas sends the invite. If the user accepts the invitation, they log in to Atlas with this username.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "orgId",
                "roles",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OrgInvitation resources.\n",
                "properties": {
                    "createdAt": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when Atlas sent the invitation.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when the invitation expires. Users have 30 days to accept an invitation.\n"
                    },
                    "invitationId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the invitation in Atlas.\n"
                    },
                    "inviterUsername": {
                        "type": "string",
                        "description": "Atlas user who invited `username` to the organization.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the organization to which you want to invite a user.\n",
                        "willReplaceOnChanges": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Atlas roles to assign to the invited user. If the user accepts the invitation, Atlas assigns these roles to them. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles a user can have.\n"
                    },
                    "teamsIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "An array of unique 24-hexadecimal digit strings that identify the teams that the user was invited to join.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Email address of the invited user. This is the address to which Atlas sends the invite. If the user accepts the invitation, they log in to Atlas with this username.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/organization:Organization": {
            "description": "## # Resource: mongodbatlas.Organization\n\n`mongodbatlas.Organization` provides programmatic management (including creation) of a MongoDB Atlas Organization resource.\n\n\u003e **IMPORTANT NOTE:**  When you establish an Atlas organization using this resource, it automatically generates a set of initial public and private Programmatic API Keys. These key values are vital to store because you'll need to use them to grant access to the newly created Atlas organization. To use this resource, `role_names` for new API Key must have the ORG_OWNER role specified.\n\n\u003e **IMPORTANT NOTE:** To use this resource, the requesting API Key must have the Organization Owner role. The requesting API Key's organization must be a paying organization. To learn more, see Configure a Paying Organization in the MongoDB Atlas documentation.\n\n\u003e **NOTE** Import command is currently not supported for this resource.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.Organization(\"test\", {\n    orgOwnerId: \"6205e5fffff79cde6f\",\n    name: \"testCreateORG\",\n    description: \"test API key from Org Creation Test\",\n    roleNames: [\"ORG_OWNER\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.Organization(\"test\",\n    org_owner_id=\"6205e5fffff79cde6f\",\n    name=\"testCreateORG\",\n    description=\"test API key from Org Creation Test\",\n    role_names=[\"ORG_OWNER\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.Organization(\"test\", new()\n    {\n        OrgOwnerId = \"6205e5fffff79cde6f\",\n        Name = \"testCreateORG\",\n        Description = \"test API key from Org Creation Test\",\n        RoleNames = new[]\n        {\n            \"ORG_OWNER\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewOrganization(ctx, \"test\", \u0026mongodbatlas.OrganizationArgs{\n\t\t\tOrgOwnerId:  pulumi.String(\"6205e5fffff79cde6f\"),\n\t\t\tName:        pulumi.String(\"testCreateORG\"),\n\t\t\tDescription: pulumi.String(\"test API key from Org Creation Test\"),\n\t\t\tRoleNames: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"ORG_OWNER\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Organization;\nimport com.pulumi.mongodbatlas.OrganizationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new Organization(\"test\", OrganizationArgs.builder()\n            .orgOwnerId(\"6205e5fffff79cde6f\")\n            .name(\"testCreateORG\")\n            .description(\"test API key from Org Creation Test\")\n            .roleNames(\"ORG_OWNER\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:Organization\n    properties:\n      orgOwnerId: 6205e5fffff79cde6f\n      name: testCreateORG\n      description: test API key from Org Creation Test\n      roleNames:\n        - ORG_OWNER\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "apiAccessListRequired": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to require API operations to originate from an IP Address added to the API access list for the specified organization.\n"
                },
                "description": {
                    "type": "string"
                },
                "federationSettingsId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the federation to link the newly created organization to. If specified, the proposed Organization Owner of the new organization must have the Organization Owner role in an organization associated with the federation.\n"
                },
                "multiFactorAuthRequired": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to require users to set up Multi-Factor Authentication (MFA) before accessing the specified organization. To learn more, see: https://www.mongodb.com/docs/atlas/security-multi-factor-authentication/.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the organization you want to create. (Cannot be changed via this Provider after creation.)\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "The organization id.\n"
                },
                "orgOwnerId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the Atlas user that you want to assign the Organization Owner role. This user must be a member of the same organization as the calling API key.  This is only required when authenticating with Programmatic API Keys. [MongoDB Atlas Admin API - Get User By Username](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/MongoDB-Cloud-Users/operation/getUserByUsername)\n"
                },
                "privateKey": {
                    "type": "string",
                    "secret": true
                },
                "publicKey": {
                    "type": "string",
                    "description": "Public API key value set for the specified organization API key.\n",
                    "secret": true
                },
                "restrictEmployeeAccess": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to block MongoDB Support from accessing Atlas infrastructure for any deployment in the specified organization without explicit permission. Once this setting is turned on, you can grant MongoDB Support a 24-hour bypass access to the Atlas deployment to resolve support issues. To learn more, see: https://www.mongodb.com/docs/atlas/security-restrict-support-access/.\n"
                },
                "roleNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Organization roles that the Programmatic API key needs to have. Ensure that you provide at least one role and ensure all roles are valid for the Organization.  You must specify an array even if you are only associating a single role with the Programmatic API key. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles that you can assign to a Programmatic API key.\n"
                }
            },
            "required": [
                "apiAccessListRequired",
                "description",
                "multiFactorAuthRequired",
                "name",
                "orgId",
                "orgOwnerId",
                "privateKey",
                "publicKey",
                "restrictEmployeeAccess",
                "roleNames"
            ],
            "inputProperties": {
                "apiAccessListRequired": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to require API operations to originate from an IP Address added to the API access list for the specified organization.\n"
                },
                "description": {
                    "type": "string"
                },
                "federationSettingsId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the federation to link the newly created organization to. If specified, the proposed Organization Owner of the new organization must have the Organization Owner role in an organization associated with the federation.\n"
                },
                "multiFactorAuthRequired": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to require users to set up Multi-Factor Authentication (MFA) before accessing the specified organization. To learn more, see: https://www.mongodb.com/docs/atlas/security-multi-factor-authentication/.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the organization you want to create. (Cannot be changed via this Provider after creation.)\n"
                },
                "orgOwnerId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the Atlas user that you want to assign the Organization Owner role. This user must be a member of the same organization as the calling API key.  This is only required when authenticating with Programmatic API Keys. [MongoDB Atlas Admin API - Get User By Username](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/MongoDB-Cloud-Users/operation/getUserByUsername)\n"
                },
                "restrictEmployeeAccess": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to block MongoDB Support from accessing Atlas infrastructure for any deployment in the specified organization without explicit permission. Once this setting is turned on, you can grant MongoDB Support a 24-hour bypass access to the Atlas deployment to resolve support issues. To learn more, see: https://www.mongodb.com/docs/atlas/security-restrict-support-access/.\n"
                },
                "roleNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Organization roles that the Programmatic API key needs to have. Ensure that you provide at least one role and ensure all roles are valid for the Organization.  You must specify an array even if you are only associating a single role with the Programmatic API key. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles that you can assign to a Programmatic API key.\n"
                }
            },
            "requiredInputs": [
                "description",
                "orgOwnerId",
                "roleNames"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Organization resources.\n",
                "properties": {
                    "apiAccessListRequired": {
                        "type": "boolean",
                        "description": "Flag that indicates whether to require API operations to originate from an IP Address added to the API access list for the specified organization.\n"
                    },
                    "description": {
                        "type": "string"
                    },
                    "federationSettingsId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the federation to link the newly created organization to. If specified, the proposed Organization Owner of the new organization must have the Organization Owner role in an organization associated with the federation.\n"
                    },
                    "multiFactorAuthRequired": {
                        "type": "boolean",
                        "description": "Flag that indicates whether to require users to set up Multi-Factor Authentication (MFA) before accessing the specified organization. To learn more, see: https://www.mongodb.com/docs/atlas/security-multi-factor-authentication/.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the organization you want to create. (Cannot be changed via this Provider after creation.)\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "The organization id.\n"
                    },
                    "orgOwnerId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the Atlas user that you want to assign the Organization Owner role. This user must be a member of the same organization as the calling API key.  This is only required when authenticating with Programmatic API Keys. [MongoDB Atlas Admin API - Get User By Username](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/MongoDB-Cloud-Users/operation/getUserByUsername)\n"
                    },
                    "privateKey": {
                        "type": "string",
                        "secret": true
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "Public API key value set for the specified organization API key.\n",
                        "secret": true
                    },
                    "restrictEmployeeAccess": {
                        "type": "boolean",
                        "description": "Flag that indicates whether to block MongoDB Support from accessing Atlas infrastructure for any deployment in the specified organization without explicit permission. Once this setting is turned on, you can grant MongoDB Support a 24-hour bypass access to the Atlas deployment to resolve support issues. To learn more, see: https://www.mongodb.com/docs/atlas/security-restrict-support-access/.\n"
                    },
                    "roleNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Organization roles that the Programmatic API key needs to have. Ensure that you provide at least one role and ensure all roles are valid for the Organization.  You must specify an array even if you are only associating a single role with the Programmatic API key. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles that you can assign to a Programmatic API key.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/privateEndpointRegionalMode:PrivateEndpointRegionalMode": {
            "description": "## # Resource: private_endpoint_regional_mode\n\n`mongodbatlas.PrivateEndpointRegionalMode` provides a Private Endpoint Regional Mode resource. This represents a regionalized private endpoint setting for a Project. Enable it to allow region specific private endpoints.\n\n\u003e **IMPORTANT:**You must have one of the following roles to successfully handle the resource:\n  * Organization Owner\n  * Project Owner\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n\u003e **WARNING:**Your [connection strings](https://www.mongodb.com/docs/atlas/reference/faq/connection-changes/#std-label-connstring-privatelink) to existing multi-region and global sharded clusters change when you enable this setting.  You must update your applications to use the new connection strings. This might cause downtime.\n\n## Import\n\nPrivate Endpoint Regional Mode can be imported using project id in format `{project_id}`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/privateEndpointRegionalMode:PrivateEndpointRegionalMode test 1112222b3bf99403840e8934\n```\nSee detailed information for arguments and attributes: __Private Endpoints__ [Get Regional Mode](https://www.mongodb.com/docs/atlas/reference/api/private-endpoints-get-regional-mode/) | [Update Regional Mode](https://www.mongodb.com/docs/atlas/reference/api/private-endpoints-update-regional-mode/)\n\n",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the regionalized private endpoint setting is enabled for the project.   Set this value to true to create more than one private endpoint in a cloud provider region to connect to multi-region and global Atlas sharded clusters. You can enable this setting only if your Atlas project contains no replica sets. You can't disable this setting if you have:\n* More than one private endpoint in more than one region, or\n* More than one private endpoint in one region and one private endpoint in one or more regions.\nYou can create only sharded clusters when you enable the regionalized private endpoint setting. You can't create replica sets.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique identifier for the project.\n"
                }
            },
            "required": [
                "enabled",
                "projectId"
            ],
            "inputProperties": {
                "enabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the regionalized private endpoint setting is enabled for the project.   Set this value to true to create more than one private endpoint in a cloud provider region to connect to multi-region and global Atlas sharded clusters. You can enable this setting only if your Atlas project contains no replica sets. You can't disable this setting if you have:\n* More than one private endpoint in more than one region, or\n* More than one private endpoint in one region and one private endpoint in one or more regions.\nYou can create only sharded clusters when you enable the regionalized private endpoint setting. You can't create replica sets.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique identifier for the project.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PrivateEndpointRegionalMode resources.\n",
                "properties": {
                    "enabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether the regionalized private endpoint setting is enabled for the project.   Set this value to true to create more than one private endpoint in a cloud provider region to connect to multi-region and global Atlas sharded clusters. You can enable this setting only if your Atlas project contains no replica sets. You can't disable this setting if you have:\n* More than one private endpoint in more than one region, or\n* More than one private endpoint in one region and one private endpoint in one or more regions.\nYou can create only sharded clusters when you enable the regionalized private endpoint setting. You can't create replica sets.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique identifier for the project.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/privateLinkEndpoint:PrivateLinkEndpoint": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.PrivateLinkEndpoint(\"test\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    providerName: \"AWS/AZURE\",\n    region: \"US_EAST_1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.PrivateLinkEndpoint(\"test\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    provider_name=\"AWS/AZURE\",\n    region=\"US_EAST_1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.PrivateLinkEndpoint(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        ProviderName = \"AWS/AZURE\",\n        Region = \"US_EAST_1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewPrivateLinkEndpoint(ctx, \"test\", \u0026mongodbatlas.PrivateLinkEndpointArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tProviderName: pulumi.String(\"AWS/AZURE\"),\n\t\t\tRegion:       pulumi.String(\"US_EAST_1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.PrivateLinkEndpoint;\nimport com.pulumi.mongodbatlas.PrivateLinkEndpointArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new PrivateLinkEndpoint(\"test\", PrivateLinkEndpointArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .providerName(\"AWS/AZURE\")\n            .region(\"US_EAST_1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:PrivateLinkEndpoint\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      providerName: AWS/AZURE\n      region: US_EAST_1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Available complete examples\n- Setup private connection to a MongoDB Atlas Cluster with AWS VPC\n\n## Import\n\nPrivate Endpoint Service can be imported using project ID, private link ID, provider name and region, in the format `{project_id}-{private_link_id}-{provider_name}-{region}`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/privateLinkEndpoint:PrivateLinkEndpoint test 1112222b3bf99403840e8934-3242342343112-AWS-us-east-1\n```\nSee detailed information for arguments and attributes: [MongoDB API Private Endpoint Service](https://docs.atlas.mongodb.com/reference/api/private-endpoints-service-create-one/)\n\n",
            "properties": {
                "endpointGroupNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "GCP network endpoint groups corresponding to the Private Service Connect endpoint service.\n"
                },
                "endpointServiceName": {
                    "type": "string",
                    "description": "Name of the PrivateLink endpoint service in AWS. Returns null while the endpoint service is being created.\n"
                },
                "errorMessage": {
                    "type": "string",
                    "description": "Error message pertaining to the AWS PrivateLink connection. Returns null if there are no errors.\nAWS:\n"
                },
                "interfaceEndpoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Unique identifiers of the interface endpoints in your VPC that you added to the AWS PrivateLink connection.\nAZURE:\n"
                },
                "privateEndpoints": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "All private endpoints that you have added to this Azure Private Link Service.\n"
                },
                "privateLinkId": {
                    "type": "string",
                    "description": "Unique identifier of the AWS PrivateLink connection.\n"
                },
                "privateLinkServiceName": {
                    "type": "string",
                    "description": "Name of the Azure Private Link Service that Atlas manages.\nGCP:\n"
                },
                "privateLinkServiceResourceId": {
                    "type": "string"
                },
                "projectId": {
                    "type": "string",
                    "description": "Required \tUnique identifier for the project.\n"
                },
                "providerName": {
                    "type": "string",
                    "description": "Name of the cloud provider for which you want to create the private endpoint service. Atlas accepts `AWS`, `AZURE` or `GCP`.\n"
                },
                "region": {
                    "type": "string",
                    "description": "Cloud provider region in which you want to create the private endpoint connection.\nAccepted values are: [AWS regions](https://docs.atlas.mongodb.com/reference/amazon-aws/#amazon-aws), [AZURE regions](https://docs.atlas.mongodb.com/reference/microsoft-azure/#microsoft-azure) and [GCP regions](https://docs.atlas.mongodb.com/reference/google-gcp/#std-label-google-gcp)\n"
                },
                "regionName": {
                    "type": "string",
                    "description": "GCP region for the Private Service Connect endpoint service.\n"
                },
                "serviceAttachmentNames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Unique alphanumeric and special character strings that identify the service attachments associated with the GCP Private Service Connect endpoint service. Returns an empty list while Atlas creates the service attachments.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Status of the AWS PrivateLink connection or Status of the Azure Private Link Service. Atlas returns one of the following values:\nAWS:\n* `AVAILABLE` \tAtlas is creating the network load balancer and VPC endpoint service.\n* `WAITING_FOR_USER` The Atlas network load balancer and VPC endpoint service are created and ready to receive connection requests. When you receive this status, create an interface endpoint to continue configuring the AWS PrivateLink connection.\n* `FAILED` \tA system failure has occurred.\n* `DELETING` \tThe AWS PrivateLink connection is being deleted.\nAZURE:\n* `AVAILABLE` \tAtlas created the load balancer and the Private Link Service.\n* `INITIATING` \tAtlas is creating the load balancer and the Private Link Service.\n* `FAILED` \tAtlas failed to create the load balancer and the Private Link service.\n* `DELETING` \tAtlas is deleting the Private Link service.\nGCP:\n* `AVAILABLE` \tAtlas created the load balancer and the GCP Private Service Connect service.\n* `INITIATING` \tAtlas is creating the load balancer and the GCP Private Service Connect service.\n* `FAILED`  \tAtlas failed to create the load balancer and the GCP Private Service Connect service.\n* `DELETING` \tAtlas is deleting the GCP Private Service Connect service.\n"
                }
            },
            "required": [
                "endpointGroupNames",
                "endpointServiceName",
                "errorMessage",
                "interfaceEndpoints",
                "privateEndpoints",
                "privateLinkId",
                "privateLinkServiceName",
                "privateLinkServiceResourceId",
                "projectId",
                "providerName",
                "region",
                "regionName",
                "serviceAttachmentNames",
                "status"
            ],
            "inputProperties": {
                "projectId": {
                    "type": "string",
                    "description": "Required \tUnique identifier for the project.\n",
                    "willReplaceOnChanges": true
                },
                "providerName": {
                    "type": "string",
                    "description": "Name of the cloud provider for which you want to create the private endpoint service. Atlas accepts `AWS`, `AZURE` or `GCP`.\n",
                    "willReplaceOnChanges": true
                },
                "region": {
                    "type": "string",
                    "description": "Cloud provider region in which you want to create the private endpoint connection.\nAccepted values are: [AWS regions](https://docs.atlas.mongodb.com/reference/amazon-aws/#amazon-aws), [AZURE regions](https://docs.atlas.mongodb.com/reference/microsoft-azure/#microsoft-azure) and [GCP regions](https://docs.atlas.mongodb.com/reference/google-gcp/#std-label-google-gcp)\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "projectId",
                "providerName",
                "region"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PrivateLinkEndpoint resources.\n",
                "properties": {
                    "endpointGroupNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "GCP network endpoint groups corresponding to the Private Service Connect endpoint service.\n"
                    },
                    "endpointServiceName": {
                        "type": "string",
                        "description": "Name of the PrivateLink endpoint service in AWS. Returns null while the endpoint service is being created.\n"
                    },
                    "errorMessage": {
                        "type": "string",
                        "description": "Error message pertaining to the AWS PrivateLink connection. Returns null if there are no errors.\nAWS:\n"
                    },
                    "interfaceEndpoints": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Unique identifiers of the interface endpoints in your VPC that you added to the AWS PrivateLink connection.\nAZURE:\n"
                    },
                    "privateEndpoints": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "All private endpoints that you have added to this Azure Private Link Service.\n"
                    },
                    "privateLinkId": {
                        "type": "string",
                        "description": "Unique identifier of the AWS PrivateLink connection.\n"
                    },
                    "privateLinkServiceName": {
                        "type": "string",
                        "description": "Name of the Azure Private Link Service that Atlas manages.\nGCP:\n"
                    },
                    "privateLinkServiceResourceId": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Required \tUnique identifier for the project.\n",
                        "willReplaceOnChanges": true
                    },
                    "providerName": {
                        "type": "string",
                        "description": "Name of the cloud provider for which you want to create the private endpoint service. Atlas accepts `AWS`, `AZURE` or `GCP`.\n",
                        "willReplaceOnChanges": true
                    },
                    "region": {
                        "type": "string",
                        "description": "Cloud provider region in which you want to create the private endpoint connection.\nAccepted values are: [AWS regions](https://docs.atlas.mongodb.com/reference/amazon-aws/#amazon-aws), [AZURE regions](https://docs.atlas.mongodb.com/reference/microsoft-azure/#microsoft-azure) and [GCP regions](https://docs.atlas.mongodb.com/reference/google-gcp/#std-label-google-gcp)\n",
                        "willReplaceOnChanges": true
                    },
                    "regionName": {
                        "type": "string",
                        "description": "GCP region for the Private Service Connect endpoint service.\n"
                    },
                    "serviceAttachmentNames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Unique alphanumeric and special character strings that identify the service attachments associated with the GCP Private Service Connect endpoint service. Returns an empty list while Atlas creates the service attachments.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Status of the AWS PrivateLink connection or Status of the Azure Private Link Service. Atlas returns one of the following values:\nAWS:\n* `AVAILABLE` \tAtlas is creating the network load balancer and VPC endpoint service.\n* `WAITING_FOR_USER` The Atlas network load balancer and VPC endpoint service are created and ready to receive connection requests. When you receive this status, create an interface endpoint to continue configuring the AWS PrivateLink connection.\n* `FAILED` \tA system failure has occurred.\n* `DELETING` \tThe AWS PrivateLink connection is being deleted.\nAZURE:\n* `AVAILABLE` \tAtlas created the load balancer and the Private Link Service.\n* `INITIATING` \tAtlas is creating the load balancer and the Private Link Service.\n* `FAILED` \tAtlas failed to create the load balancer and the Private Link service.\n* `DELETING` \tAtlas is deleting the Private Link service.\nGCP:\n* `AVAILABLE` \tAtlas created the load balancer and the GCP Private Service Connect service.\n* `INITIATING` \tAtlas is creating the load balancer and the GCP Private Service Connect service.\n* `FAILED`  \tAtlas failed to create the load balancer and the GCP Private Service Connect service.\n* `DELETING` \tAtlas is deleting the GCP Private Service Connect service.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/privateLinkEndpointService:PrivateLinkEndpointService": {
            "description": "\n\n## Import\n\nPrivate Endpoint Link Connection can be imported using project ID and username, in the format `{project_id}--{private_link_id}--{endpoint_service_id}--{provider_name}`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/privateLinkEndpointService:PrivateLinkEndpointService test 1112222b3bf99403840e8934--3242342343112--vpce-4242342343--AWS\n```\nSee detailed information for arguments and attributes: [MongoDB API Private Endpoint Link Connection](https://docs.atlas.mongodb.com/reference/api/private-endpoints-endpoint-create-one/)\n\n",
            "properties": {
                "awsConnectionStatus": {
                    "type": "string",
                    "description": "Status of the interface endpoint for AWS.\nReturns one of the following values:\n* `NONE` - Atlas created the network load balancer and VPC endpoint service, but AWS hasnât yet created the VPC endpoint.\n* `PENDING_ACCEPTANCE` - AWS has received the connection request from your VPC endpoint to the Atlas VPC endpoint service.\n* `PENDING` - AWS is establishing the connection between your VPC endpoint and the Atlas VPC endpoint service.\n* `AVAILABLE` - Atlas VPC resources are connected to the VPC endpoint in your VPC. You can connect to Atlas clusters in this region using AWS PrivateLink.\n* `REJECTED` - AWS failed to establish a connection between Atlas VPC resources to the VPC endpoint in your VPC.\n* `DELETING` - Atlas is removing the interface endpoint from the private endpoint connection.\n"
                },
                "azureStatus": {
                    "type": "string",
                    "description": "Status of the interface endpoint for AZURE.\nReturns one of the following values:\n* `INITIATING` - Atlas has not yet accepted the connection to your private endpoint.\n* `AVAILABLE` - Atlas approved the connection to your private endpoint.\n* `FAILED` - Atlas failed to accept the connection your private endpoint.\n* `DELETING` - Atlas is removing the connection to your private endpoint from the Private Link service.\n"
                },
                "deleteRequested": {
                    "type": "boolean",
                    "description": "Indicates if Atlas received a request to remove the interface endpoint from the private endpoint connection.\n"
                },
                "endpointGroupName": {
                    "type": "string",
                    "description": "(Optional) Unique identifier of the endpoint group. The endpoint group encompasses all of the endpoints that you created in GCP.\n"
                },
                "endpointServiceId": {
                    "type": "string",
                    "description": "Unique identifier of the interface endpoint you created in your VPC with the `AWS`, `AZURE` or `GCP` resource.\n"
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/PrivateLinkEndpointServiceEndpoint:PrivateLinkEndpointServiceEndpoint"
                    },
                    "description": "Collection of individual private endpoints that comprise your endpoint group. Only for `GCP`. See below.\n"
                },
                "errorMessage": {
                    "type": "string",
                    "description": "Error message pertaining to the interface endpoint. Returns null if there are no errors.\n"
                },
                "gcpProjectId": {
                    "type": "string",
                    "description": "Unique identifier of the GCP project in which you created your endpoints. Only for `GCP`.\n"
                },
                "gcpStatus": {
                    "type": "string",
                    "description": "Status of the interface endpoint for GCP.\nReturns one of the following values:\n* `INITIATING` - Atlas has not yet accepted the connection to your private endpoint.\n* `AVAILABLE` - Atlas approved the connection to your private endpoint.\n* `FAILED` - Atlas failed to accept the connection your private endpoint.\n* `DELETING` - Atlas is removing the connection to your private endpoint from the Private Link service.\n"
                },
                "interfaceEndpointId": {
                    "type": "string",
                    "description": "Unique identifier of the interface endpoint.\n"
                },
                "privateEndpointConnectionName": {
                    "type": "string",
                    "description": "Name of the connection for this private endpoint that Atlas generates.\n"
                },
                "privateEndpointIpAddress": {
                    "type": "string",
                    "description": "Private IP address of the private endpoint network interface you created in your Azure VNet. Only for `AZURE`.\n"
                },
                "privateEndpointResourceId": {
                    "type": "string",
                    "description": "Unique identifier of the private endpoint.\n"
                },
                "privateLinkId": {
                    "type": "string",
                    "description": "Unique identifier of the `AWS` or `AZURE` PrivateLink connection which is created by `mongodbatlas.PrivateLinkEndpoint` resource.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique identifier for the project.\n"
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud provider for which you want to create a private endpoint. Atlas accepts `AWS`, `AZURE` or `GCP`.\n"
                }
            },
            "required": [
                "awsConnectionStatus",
                "azureStatus",
                "deleteRequested",
                "endpointGroupName",
                "endpointServiceId",
                "endpoints",
                "errorMessage",
                "gcpStatus",
                "interfaceEndpointId",
                "privateEndpointConnectionName",
                "privateEndpointIpAddress",
                "privateEndpointResourceId",
                "privateLinkId",
                "projectId",
                "providerName"
            ],
            "inputProperties": {
                "endpointServiceId": {
                    "type": "string",
                    "description": "Unique identifier of the interface endpoint you created in your VPC with the `AWS`, `AZURE` or `GCP` resource.\n",
                    "willReplaceOnChanges": true
                },
                "endpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/PrivateLinkEndpointServiceEndpoint:PrivateLinkEndpointServiceEndpoint"
                    },
                    "description": "Collection of individual private endpoints that comprise your endpoint group. Only for `GCP`. See below.\n"
                },
                "gcpProjectId": {
                    "type": "string",
                    "description": "Unique identifier of the GCP project in which you created your endpoints. Only for `GCP`.\n",
                    "willReplaceOnChanges": true
                },
                "privateEndpointIpAddress": {
                    "type": "string",
                    "description": "Private IP address of the private endpoint network interface you created in your Azure VNet. Only for `AZURE`.\n"
                },
                "privateLinkId": {
                    "type": "string",
                    "description": "Unique identifier of the `AWS` or `AZURE` PrivateLink connection which is created by `mongodbatlas.PrivateLinkEndpoint` resource.\n",
                    "willReplaceOnChanges": true
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique identifier for the project.\n",
                    "willReplaceOnChanges": true
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud provider for which you want to create a private endpoint. Atlas accepts `AWS`, `AZURE` or `GCP`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "endpointServiceId",
                "privateLinkId",
                "projectId",
                "providerName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PrivateLinkEndpointService resources.\n",
                "properties": {
                    "awsConnectionStatus": {
                        "type": "string",
                        "description": "Status of the interface endpoint for AWS.\nReturns one of the following values:\n* `NONE` - Atlas created the network load balancer and VPC endpoint service, but AWS hasnât yet created the VPC endpoint.\n* `PENDING_ACCEPTANCE` - AWS has received the connection request from your VPC endpoint to the Atlas VPC endpoint service.\n* `PENDING` - AWS is establishing the connection between your VPC endpoint and the Atlas VPC endpoint service.\n* `AVAILABLE` - Atlas VPC resources are connected to the VPC endpoint in your VPC. You can connect to Atlas clusters in this region using AWS PrivateLink.\n* `REJECTED` - AWS failed to establish a connection between Atlas VPC resources to the VPC endpoint in your VPC.\n* `DELETING` - Atlas is removing the interface endpoint from the private endpoint connection.\n"
                    },
                    "azureStatus": {
                        "type": "string",
                        "description": "Status of the interface endpoint for AZURE.\nReturns one of the following values:\n* `INITIATING` - Atlas has not yet accepted the connection to your private endpoint.\n* `AVAILABLE` - Atlas approved the connection to your private endpoint.\n* `FAILED` - Atlas failed to accept the connection your private endpoint.\n* `DELETING` - Atlas is removing the connection to your private endpoint from the Private Link service.\n"
                    },
                    "deleteRequested": {
                        "type": "boolean",
                        "description": "Indicates if Atlas received a request to remove the interface endpoint from the private endpoint connection.\n"
                    },
                    "endpointGroupName": {
                        "type": "string",
                        "description": "(Optional) Unique identifier of the endpoint group. The endpoint group encompasses all of the endpoints that you created in GCP.\n"
                    },
                    "endpointServiceId": {
                        "type": "string",
                        "description": "Unique identifier of the interface endpoint you created in your VPC with the `AWS`, `AZURE` or `GCP` resource.\n",
                        "willReplaceOnChanges": true
                    },
                    "endpoints": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/PrivateLinkEndpointServiceEndpoint:PrivateLinkEndpointServiceEndpoint"
                        },
                        "description": "Collection of individual private endpoints that comprise your endpoint group. Only for `GCP`. See below.\n"
                    },
                    "errorMessage": {
                        "type": "string",
                        "description": "Error message pertaining to the interface endpoint. Returns null if there are no errors.\n"
                    },
                    "gcpProjectId": {
                        "type": "string",
                        "description": "Unique identifier of the GCP project in which you created your endpoints. Only for `GCP`.\n",
                        "willReplaceOnChanges": true
                    },
                    "gcpStatus": {
                        "type": "string",
                        "description": "Status of the interface endpoint for GCP.\nReturns one of the following values:\n* `INITIATING` - Atlas has not yet accepted the connection to your private endpoint.\n* `AVAILABLE` - Atlas approved the connection to your private endpoint.\n* `FAILED` - Atlas failed to accept the connection your private endpoint.\n* `DELETING` - Atlas is removing the connection to your private endpoint from the Private Link service.\n"
                    },
                    "interfaceEndpointId": {
                        "type": "string",
                        "description": "Unique identifier of the interface endpoint.\n"
                    },
                    "privateEndpointConnectionName": {
                        "type": "string",
                        "description": "Name of the connection for this private endpoint that Atlas generates.\n"
                    },
                    "privateEndpointIpAddress": {
                        "type": "string",
                        "description": "Private IP address of the private endpoint network interface you created in your Azure VNet. Only for `AZURE`.\n"
                    },
                    "privateEndpointResourceId": {
                        "type": "string",
                        "description": "Unique identifier of the private endpoint.\n"
                    },
                    "privateLinkId": {
                        "type": "string",
                        "description": "Unique identifier of the `AWS` or `AZURE` PrivateLink connection which is created by `mongodbatlas.PrivateLinkEndpoint` resource.\n",
                        "willReplaceOnChanges": true
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique identifier for the project.\n",
                        "willReplaceOnChanges": true
                    },
                    "providerName": {
                        "type": "string",
                        "description": "Cloud provider for which you want to create a private endpoint. Atlas accepts `AWS`, `AZURE` or `GCP`.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/privatelinkEndpointServerless:PrivatelinkEndpointServerless": {
            "description": "## # Resource: privatelink_endpoint_serverless\n\n`privatelink_endpoint_serverless` Provides a Serverless PrivateLink Endpoint resource.\nThis is the first of two resources required to configure PrivateLink for Serverless, the second is mongodbatlas_privatelink_endpoint_service_serverless.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n## Example Usage\n\n### AWS Example\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testServerlessInstance = new mongodbatlas.ServerlessInstance(\"test\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    name: \"test-db\",\n    providerSettingsBackingProviderName: \"AWS\",\n    providerSettingsProviderName: \"SERVERLESS\",\n    providerSettingsRegionName: \"US_EAST_1\",\n    continuousBackupEnabled: true,\n});\nconst test = new mongodbatlas.PrivatelinkEndpointServerless(\"test\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: testServerlessInstance.name,\n    providerName: \"AWS\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_serverless_instance = mongodbatlas.ServerlessInstance(\"test\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    name=\"test-db\",\n    provider_settings_backing_provider_name=\"AWS\",\n    provider_settings_provider_name=\"SERVERLESS\",\n    provider_settings_region_name=\"US_EAST_1\",\n    continuous_backup_enabled=True)\ntest = mongodbatlas.PrivatelinkEndpointServerless(\"test\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=test_serverless_instance.name,\n    provider_name=\"AWS\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testServerlessInstance = new Mongodbatlas.ServerlessInstance(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        Name = \"test-db\",\n        ProviderSettingsBackingProviderName = \"AWS\",\n        ProviderSettingsProviderName = \"SERVERLESS\",\n        ProviderSettingsRegionName = \"US_EAST_1\",\n        ContinuousBackupEnabled = true,\n    });\n\n    var test = new Mongodbatlas.PrivatelinkEndpointServerless(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = testServerlessInstance.Name,\n        ProviderName = \"AWS\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestServerlessInstance, err := mongodbatlas.NewServerlessInstance(ctx, \"test\", \u0026mongodbatlas.ServerlessInstanceArgs{\n\t\t\tProjectId:                           pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tName:                                pulumi.String(\"test-db\"),\n\t\t\tProviderSettingsBackingProviderName: pulumi.String(\"AWS\"),\n\t\t\tProviderSettingsProviderName:        pulumi.String(\"SERVERLESS\"),\n\t\t\tProviderSettingsRegionName:          pulumi.String(\"US_EAST_1\"),\n\t\t\tContinuousBackupEnabled:             pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewPrivatelinkEndpointServerless(ctx, \"test\", \u0026mongodbatlas.PrivatelinkEndpointServerlessArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tInstanceName: testServerlessInstance.Name,\n\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ServerlessInstance;\nimport com.pulumi.mongodbatlas.ServerlessInstanceArgs;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServerless;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServerlessArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testServerlessInstance = new ServerlessInstance(\"testServerlessInstance\", ServerlessInstanceArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .name(\"test-db\")\n            .providerSettingsBackingProviderName(\"AWS\")\n            .providerSettingsProviderName(\"SERVERLESS\")\n            .providerSettingsRegionName(\"US_EAST_1\")\n            .continuousBackupEnabled(true)\n            .build());\n\n        var test = new PrivatelinkEndpointServerless(\"test\", PrivatelinkEndpointServerlessArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(testServerlessInstance.name())\n            .providerName(\"AWS\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:PrivatelinkEndpointServerless\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      instanceName: ${testServerlessInstance.name}\n      providerName: AWS\n  testServerlessInstance:\n    type: mongodbatlas:ServerlessInstance\n    name: test\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      name: test-db\n      providerSettingsBackingProviderName: AWS\n      providerSettingsProviderName: SERVERLESS\n      providerSettingsRegionName: US_EAST_1\n      continuousBackupEnabled: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nServerless privatelink endpoint can be imported using project ID and endpoint ID, in the format `project_id`--`endpoint_id`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/privatelinkEndpointServerless:PrivatelinkEndpointServerless test 1112222b3bf99403840e8934--serverless_name--vpce-jjg5e24qp93513h03\n```\nFor more information see: [MongoDB Atlas API - Serverless Private Endpoints](https://www.mongodb.com/docs/atlas/reference/api/serverless-private-endpoints-get-one/).\n\n",
            "properties": {
                "endpointId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the private endpoint.\n"
                },
                "endpointServiceName": {
                    "type": "string",
                    "description": "Unique string that identifies the PrivateLink endpoint service.\n"
                },
                "instanceName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the serverless instance.\n"
                },
                "privateLinkServiceResourceId": {
                    "type": "string",
                    "description": "Root-relative path that identifies the Azure Private Link Service that MongoDB Cloud manages.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-digit hexadecimal string that identifies the project.\n"
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud provider name; AWS is currently supported\n"
                },
                "status": {
                    "type": "string",
                    "description": "Human-readable label that indicates the current operating status of the private endpoint. Values include: RESERVATION_REQUESTED, RESERVED, INITIATING, AVAILABLE, FAILED, DELETING.\n"
                }
            },
            "required": [
                "endpointId",
                "endpointServiceName",
                "instanceName",
                "privateLinkServiceResourceId",
                "projectId",
                "providerName",
                "status"
            ],
            "inputProperties": {
                "instanceName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the serverless instance.\n",
                    "willReplaceOnChanges": true
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-digit hexadecimal string that identifies the project.\n",
                    "willReplaceOnChanges": true
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud provider name; AWS is currently supported\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "instanceName",
                "projectId",
                "providerName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PrivatelinkEndpointServerless resources.\n",
                "properties": {
                    "endpointId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the private endpoint.\n"
                    },
                    "endpointServiceName": {
                        "type": "string",
                        "description": "Unique string that identifies the PrivateLink endpoint service.\n"
                    },
                    "instanceName": {
                        "type": "string",
                        "description": "Human-readable label that identifies the serverless instance.\n",
                        "willReplaceOnChanges": true
                    },
                    "privateLinkServiceResourceId": {
                        "type": "string",
                        "description": "Root-relative path that identifies the Azure Private Link Service that MongoDB Cloud manages.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-digit hexadecimal string that identifies the project.\n",
                        "willReplaceOnChanges": true
                    },
                    "providerName": {
                        "type": "string",
                        "description": "Cloud provider name; AWS is currently supported\n",
                        "willReplaceOnChanges": true
                    },
                    "status": {
                        "type": "string",
                        "description": "Human-readable label that indicates the current operating status of the private endpoint. Values include: RESERVATION_REQUESTED, RESERVED, INITIATING, AVAILABLE, FAILED, DELETING.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/privatelinkEndpointServiceDataFederationOnlineArchive:PrivatelinkEndpointServiceDataFederationOnlineArchive": {
            "description": "## # Resource: mongodbatlas.PrivatelinkEndpointServiceDataFederationOnlineArchive\n\n`mongodbatlas.PrivatelinkEndpointServiceDataFederationOnlineArchive` provides a Private Endpoint Service resource for Data Federation and Online Archive. The resource allows you to create and manage a private endpoint for Federated Database Instances and Online Archives to the specified project.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n\u003e **NOTE:** Updates are limited to the `comment` argument.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst atlas_project = new mongodbatlas.Project(\"atlas-project\", {\n    orgId: atlasOrgId,\n    name: atlasProjectName,\n});\nconst test = new mongodbatlas.PrivatelinkEndpointServiceDataFederationOnlineArchive(\"test\", {\n    projectId: atlas_project.id,\n    endpointId: \"vpce-046cf43c79424d4c9\",\n    providerName: \"AWS\",\n    comment: \"Test\",\n    region: \"US_EAST_1\",\n    customerEndpointDnsName: \"vpce-046cf43c79424d4c9-nmls2y9k.vpce-svc-0824460b72e1a420e.us-east-1.vpce.amazonaws.com\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\natlas_project = mongodbatlas.Project(\"atlas-project\",\n    org_id=atlas_org_id,\n    name=atlas_project_name)\ntest = mongodbatlas.PrivatelinkEndpointServiceDataFederationOnlineArchive(\"test\",\n    project_id=atlas_project.id,\n    endpoint_id=\"vpce-046cf43c79424d4c9\",\n    provider_name=\"AWS\",\n    comment=\"Test\",\n    region=\"US_EAST_1\",\n    customer_endpoint_dns_name=\"vpce-046cf43c79424d4c9-nmls2y9k.vpce-svc-0824460b72e1a420e.us-east-1.vpce.amazonaws.com\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var atlas_project = new Mongodbatlas.Project(\"atlas-project\", new()\n    {\n        OrgId = atlasOrgId,\n        Name = atlasProjectName,\n    });\n\n    var test = new Mongodbatlas.PrivatelinkEndpointServiceDataFederationOnlineArchive(\"test\", new()\n    {\n        ProjectId = atlas_project.Id,\n        EndpointId = \"vpce-046cf43c79424d4c9\",\n        ProviderName = \"AWS\",\n        Comment = \"Test\",\n        Region = \"US_EAST_1\",\n        CustomerEndpointDnsName = \"vpce-046cf43c79424d4c9-nmls2y9k.vpce-svc-0824460b72e1a420e.us-east-1.vpce.amazonaws.com\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewProject(ctx, \"atlas-project\", \u0026mongodbatlas.ProjectArgs{\n\t\t\tOrgId: pulumi.Any(atlasOrgId),\n\t\t\tName:  pulumi.Any(atlasProjectName),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewPrivatelinkEndpointServiceDataFederationOnlineArchive(ctx, \"test\", \u0026mongodbatlas.PrivatelinkEndpointServiceDataFederationOnlineArchiveArgs{\n\t\t\tProjectId:               atlas_project.ID(),\n\t\t\tEndpointId:              pulumi.String(\"vpce-046cf43c79424d4c9\"),\n\t\t\tProviderName:            pulumi.String(\"AWS\"),\n\t\t\tComment:                 pulumi.String(\"Test\"),\n\t\t\tRegion:                  pulumi.String(\"US_EAST_1\"),\n\t\t\tCustomerEndpointDnsName: pulumi.String(\"vpce-046cf43c79424d4c9-nmls2y9k.vpce-svc-0824460b72e1a420e.us-east-1.vpce.amazonaws.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Project;\nimport com.pulumi.mongodbatlas.ProjectArgs;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceDataFederationOnlineArchive;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceDataFederationOnlineArchiveArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var atlas_project = new Project(\"atlas-project\", ProjectArgs.builder()\n            .orgId(atlasOrgId)\n            .name(atlasProjectName)\n            .build());\n\n        var test = new PrivatelinkEndpointServiceDataFederationOnlineArchive(\"test\", PrivatelinkEndpointServiceDataFederationOnlineArchiveArgs.builder()\n            .projectId(atlas_project.id())\n            .endpointId(\"vpce-046cf43c79424d4c9\")\n            .providerName(\"AWS\")\n            .comment(\"Test\")\n            .region(\"US_EAST_1\")\n            .customerEndpointDnsName(\"vpce-046cf43c79424d4c9-nmls2y9k.vpce-svc-0824460b72e1a420e.us-east-1.vpce.amazonaws.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  atlas-project:\n    type: mongodbatlas:Project\n    properties:\n      orgId: ${atlasOrgId}\n      name: ${atlasProjectName}\n  test:\n    type: mongodbatlas:PrivatelinkEndpointServiceDataFederationOnlineArchive\n    properties:\n      projectId: ${[\"atlas-project\"].id}\n      endpointId: vpce-046cf43c79424d4c9\n      providerName: AWS\n      comment: Test\n      region: US_EAST_1\n      customerEndpointDnsName: vpce-046cf43c79424d4c9-nmls2y9k.vpce-svc-0824460b72e1a420e.us-east-1.vpce.amazonaws.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nPrivate Endpoint Service resource for Data Federation and Online Archive can be imported using project ID, endpoint ID, in the format `project_id`--`endpoint_id`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/privatelinkEndpointServiceDataFederationOnlineArchive:PrivatelinkEndpointServiceDataFederationOnlineArchive example 1112222b3bf99403840e8934--vpce-3bf78b0ddee411ba1\n```\nSee [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation/operation/createDataFederationPrivateEndpoint) Documentation for more information.\n\n",
            "properties": {
                "comment": {
                    "type": "string",
                    "description": "Human-readable string to associate with this private endpoint.\n"
                },
                "customerEndpointDnsName": {
                    "type": "string",
                    "description": "Human-readable label to identify VPC endpoint DNS name.\n"
                },
                "endpointId": {
                    "type": "string",
                    "description": "Unique 22-character alphanumeric string that identifies the private endpoint. See [Atlas Data Lake supports Amazon Web Services private endpoints using the AWS PrivateLink feature](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation/operation/createDataFederationPrivateEndpoint:~:text=Atlas%20Data%20Lake%20supports%20Amazon%20Web%20Services%20private%20endpoints%20using%20the%20AWS%20PrivateLink%20feature).\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies your project.\n"
                },
                "providerName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the cloud service provider.\n"
                },
                "region": {
                    "type": "string",
                    "description": "Human-readable label to identify the region of VPC endpoint.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).\n"
                },
                "type": {
                    "type": "string",
                    "description": "Human-readable label that identifies the resource type associated with this private endpoint.\n"
                }
            },
            "required": [
                "endpointId",
                "projectId",
                "providerName",
                "type"
            ],
            "inputProperties": {
                "comment": {
                    "type": "string",
                    "description": "Human-readable string to associate with this private endpoint.\n"
                },
                "customerEndpointDnsName": {
                    "type": "string",
                    "description": "Human-readable label to identify VPC endpoint DNS name.\n",
                    "willReplaceOnChanges": true
                },
                "endpointId": {
                    "type": "string",
                    "description": "Unique 22-character alphanumeric string that identifies the private endpoint. See [Atlas Data Lake supports Amazon Web Services private endpoints using the AWS PrivateLink feature](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation/operation/createDataFederationPrivateEndpoint:~:text=Atlas%20Data%20Lake%20supports%20Amazon%20Web%20Services%20private%20endpoints%20using%20the%20AWS%20PrivateLink%20feature).\n",
                    "willReplaceOnChanges": true
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies your project.\n",
                    "willReplaceOnChanges": true
                },
                "providerName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the cloud service provider.\n",
                    "willReplaceOnChanges": true
                },
                "region": {
                    "type": "string",
                    "description": "Human-readable label to identify the region of VPC endpoint.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "endpointId",
                "projectId",
                "providerName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PrivatelinkEndpointServiceDataFederationOnlineArchive resources.\n",
                "properties": {
                    "comment": {
                        "type": "string",
                        "description": "Human-readable string to associate with this private endpoint.\n"
                    },
                    "customerEndpointDnsName": {
                        "type": "string",
                        "description": "Human-readable label to identify VPC endpoint DNS name.\n",
                        "willReplaceOnChanges": true
                    },
                    "endpointId": {
                        "type": "string",
                        "description": "Unique 22-character alphanumeric string that identifies the private endpoint. See [Atlas Data Lake supports Amazon Web Services private endpoints using the AWS PrivateLink feature](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation/operation/createDataFederationPrivateEndpoint:~:text=Atlas%20Data%20Lake%20supports%20Amazon%20Web%20Services%20private%20endpoints%20using%20the%20AWS%20PrivateLink%20feature).\n",
                        "willReplaceOnChanges": true
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies your project.\n",
                        "willReplaceOnChanges": true
                    },
                    "providerName": {
                        "type": "string",
                        "description": "Human-readable label that identifies the cloud service provider.\n",
                        "willReplaceOnChanges": true
                    },
                    "region": {
                        "type": "string",
                        "description": "Human-readable label to identify the region of VPC endpoint.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).\n",
                        "willReplaceOnChanges": true
                    },
                    "type": {
                        "type": "string",
                        "description": "Human-readable label that identifies the resource type associated with this private endpoint.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/privatelinkEndpointServiceServerless:PrivatelinkEndpointServiceServerless": {
            "description": "## # Resource: privatelink_endpoint_service_serverless\n\n`privatelink_endpoint_service_serverless` Provides a Serverless PrivateLink Endpoint Service resource.\nThis is the second of two resources required to configure PrivateLink for Serverless, the first is mongodbatlas_privatelink_endpoint_serverless.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\u003e **NOTE:** Create waits for all serverless instances on the project to IDLE in order for their operations to complete. This ensures the latest connection strings can be retrieved following creation of this resource. Default timeout is 2hrs.\n\n## Example with AWS\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testServerlessInstance = new mongodbatlas.ServerlessInstance(\"test\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    name: \"test-db\",\n    providerSettingsBackingProviderName: \"AWS\",\n    providerSettingsProviderName: \"SERVERLESS\",\n    providerSettingsRegionName: \"US_EAST_1\",\n    continuousBackupEnabled: true,\n});\nconst test = new mongodbatlas.PrivatelinkEndpointServerless(\"test\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: testServerlessInstance.name,\n    providerName: \"AWS\",\n});\nconst ptfeService = new aws.index.VpcEndpoint(\"ptfe_service\", {\n    vpcId: \"vpc-7fc0a543\",\n    serviceName: test.endpointServiceName,\n    vpcEndpointType: \"Interface\",\n    subnetIds: [\"subnet-de0406d2\"],\n    securityGroupIds: [\"sg-3f238186\"],\n});\nconst testPrivatelinkEndpointServiceServerless = new mongodbatlas.PrivatelinkEndpointServiceServerless(\"test\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: testServerlessInstance.name,\n    endpointId: test.endpointId,\n    cloudProviderEndpointId: ptfeService.id,\n    providerName: \"AWS\",\n    comment: \"New serverless endpoint\",\n});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_serverless_instance = mongodbatlas.ServerlessInstance(\"test\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    name=\"test-db\",\n    provider_settings_backing_provider_name=\"AWS\",\n    provider_settings_provider_name=\"SERVERLESS\",\n    provider_settings_region_name=\"US_EAST_1\",\n    continuous_backup_enabled=True)\ntest = mongodbatlas.PrivatelinkEndpointServerless(\"test\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=test_serverless_instance.name,\n    provider_name=\"AWS\")\nptfe_service = aws.index.VpcEndpoint(\"ptfe_service\",\n    vpc_id=vpc-7fc0a543,\n    service_name=test.endpoint_service_name,\n    vpc_endpoint_type=Interface,\n    subnet_ids=[subnet-de0406d2],\n    security_group_ids=[sg-3f238186])\ntest_privatelink_endpoint_service_serverless = mongodbatlas.PrivatelinkEndpointServiceServerless(\"test\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=test_serverless_instance.name,\n    endpoint_id=test.endpoint_id,\n    cloud_provider_endpoint_id=ptfe_service[\"id\"],\n    provider_name=\"AWS\",\n    comment=\"New serverless endpoint\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testServerlessInstance = new Mongodbatlas.ServerlessInstance(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        Name = \"test-db\",\n        ProviderSettingsBackingProviderName = \"AWS\",\n        ProviderSettingsProviderName = \"SERVERLESS\",\n        ProviderSettingsRegionName = \"US_EAST_1\",\n        ContinuousBackupEnabled = true,\n    });\n\n    var test = new Mongodbatlas.PrivatelinkEndpointServerless(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = testServerlessInstance.Name,\n        ProviderName = \"AWS\",\n    });\n\n    var ptfeService = new Aws.Index.VpcEndpoint(\"ptfe_service\", new()\n    {\n        VpcId = \"vpc-7fc0a543\",\n        ServiceName = test.EndpointServiceName,\n        VpcEndpointType = \"Interface\",\n        SubnetIds = new[]\n        {\n            \"subnet-de0406d2\",\n        },\n        SecurityGroupIds = new[]\n        {\n            \"sg-3f238186\",\n        },\n    });\n\n    var testPrivatelinkEndpointServiceServerless = new Mongodbatlas.PrivatelinkEndpointServiceServerless(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = testServerlessInstance.Name,\n        EndpointId = test.EndpointId,\n        CloudProviderEndpointId = ptfeService.Id,\n        ProviderName = \"AWS\",\n        Comment = \"New serverless endpoint\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v4/go/aws\"\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestServerlessInstance, err := mongodbatlas.NewServerlessInstance(ctx, \"test\", \u0026mongodbatlas.ServerlessInstanceArgs{\n\t\t\tProjectId:                           pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tName:                                pulumi.String(\"test-db\"),\n\t\t\tProviderSettingsBackingProviderName: pulumi.String(\"AWS\"),\n\t\t\tProviderSettingsProviderName:        pulumi.String(\"SERVERLESS\"),\n\t\t\tProviderSettingsRegionName:          pulumi.String(\"US_EAST_1\"),\n\t\t\tContinuousBackupEnabled:             pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttest, err := mongodbatlas.NewPrivatelinkEndpointServerless(ctx, \"test\", \u0026mongodbatlas.PrivatelinkEndpointServerlessArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tInstanceName: testServerlessInstance.Name,\n\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tptfeService, err := aws.NewVpcEndpoint(ctx, \"ptfe_service\", \u0026aws.VpcEndpointArgs{\n\t\t\tVpcId:           \"vpc-7fc0a543\",\n\t\t\tServiceName:     test.EndpointServiceName,\n\t\t\tVpcEndpointType: \"Interface\",\n\t\t\tSubnetIds: []string{\n\t\t\t\t\"subnet-de0406d2\",\n\t\t\t},\n\t\t\tSecurityGroupIds: []string{\n\t\t\t\t\"sg-3f238186\",\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewPrivatelinkEndpointServiceServerless(ctx, \"test\", \u0026mongodbatlas.PrivatelinkEndpointServiceServerlessArgs{\n\t\t\tProjectId:               pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tInstanceName:            testServerlessInstance.Name,\n\t\t\tEndpointId:              test.EndpointId,\n\t\t\tCloudProviderEndpointId: ptfeService.Id,\n\t\t\tProviderName:            pulumi.String(\"AWS\"),\n\t\t\tComment:                 pulumi.String(\"New serverless endpoint\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ServerlessInstance;\nimport com.pulumi.mongodbatlas.ServerlessInstanceArgs;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServerless;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServerlessArgs;\nimport com.pulumi.aws.vpcEndpoint;\nimport com.pulumi.aws.VpcEndpointArgs;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceServerless;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceServerlessArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testServerlessInstance = new ServerlessInstance(\"testServerlessInstance\", ServerlessInstanceArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .name(\"test-db\")\n            .providerSettingsBackingProviderName(\"AWS\")\n            .providerSettingsProviderName(\"SERVERLESS\")\n            .providerSettingsRegionName(\"US_EAST_1\")\n            .continuousBackupEnabled(true)\n            .build());\n\n        var test = new PrivatelinkEndpointServerless(\"test\", PrivatelinkEndpointServerlessArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(testServerlessInstance.name())\n            .providerName(\"AWS\")\n            .build());\n\n        var ptfeService = new VpcEndpoint(\"ptfeService\", VpcEndpointArgs.builder()\n            .vpcId(\"vpc-7fc0a543\")\n            .serviceName(test.endpointServiceName())\n            .vpcEndpointType(\"Interface\")\n            .subnetIds(\"subnet-de0406d2\")\n            .securityGroupIds(\"sg-3f238186\")\n            .build());\n\n        var testPrivatelinkEndpointServiceServerless = new PrivatelinkEndpointServiceServerless(\"testPrivatelinkEndpointServiceServerless\", PrivatelinkEndpointServiceServerlessArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(testServerlessInstance.name())\n            .endpointId(test.endpointId())\n            .cloudProviderEndpointId(ptfeService.id())\n            .providerName(\"AWS\")\n            .comment(\"New serverless endpoint\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:PrivatelinkEndpointServerless\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      instanceName: ${testServerlessInstance.name}\n      providerName: AWS\n  ptfeService:\n    type: aws:vpcEndpoint\n    name: ptfe_service\n    properties:\n      vpcId: vpc-7fc0a543\n      serviceName: ${test.endpointServiceName}\n      vpcEndpointType: Interface\n      subnetIds:\n        - subnet-de0406d2\n      securityGroupIds:\n        - sg-3f238186\n  testPrivatelinkEndpointServiceServerless:\n    type: mongodbatlas:PrivatelinkEndpointServiceServerless\n    name: test\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      instanceName: ${testServerlessInstance.name}\n      endpointId: ${test.endpointId}\n      cloudProviderEndpointId: ${ptfeService.id}\n      providerName: AWS\n      comment: New serverless endpoint\n  testServerlessInstance:\n    type: mongodbatlas:ServerlessInstance\n    name: test\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      name: test-db\n      providerSettingsBackingProviderName: AWS\n      providerSettingsProviderName: SERVERLESS\n      providerSettingsRegionName: US_EAST_1\n      continuousBackupEnabled: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Example with AZURE\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as azurerm from \"@pulumi/azurerm\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.PrivatelinkEndpointServerless(\"test\", {\n    projectId: projectId,\n    providerName: \"AZURE\",\n});\nconst testPrivateEndpoint = new azurerm.index.PrivateEndpoint(\"test\", {\n    name: \"endpoint-test\",\n    location: testAzurermResourceGroup.location,\n    resourceGroupName: resourceGroupName,\n    subnetId: testAzurermSubnet.id,\n    privateServiceConnection: [{\n        name: test.privateLinkServiceName,\n        privateConnectionResourceId: test.privateLinkServiceResourceId,\n        isManualConnection: true,\n        requestMessage: \"Azure Private Link test\",\n    }],\n});\nconst testServerlessInstance = new mongodbatlas.ServerlessInstance(\"test\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    name: \"test-db\",\n    providerSettingsBackingProviderName: \"AZURE\",\n    providerSettingsProviderName: \"SERVERLESS\",\n    providerSettingsRegionName: \"US_EAST\",\n    continuousBackupEnabled: true,\n});\nconst testPrivatelinkEndpointServiceServerless = new mongodbatlas.PrivatelinkEndpointServiceServerless(\"test\", {\n    projectId: test.projectId,\n    instanceName: testServerlessInstance.name,\n    endpointId: test.endpointId,\n    cloudProviderEndpointId: testPrivateEndpoint.id,\n    privateEndpointIpAddress: testPrivateEndpoint.privateServiceConnection[0].privateIpAddress,\n    providerName: \"AZURE\",\n    comment: \"test\",\n});\n```\n```python\nimport pulumi\nimport pulumi_azurerm as azurerm\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.PrivatelinkEndpointServerless(\"test\",\n    project_id=project_id,\n    provider_name=\"AZURE\")\ntest_private_endpoint = azurerm.index.PrivateEndpoint(\"test\",\n    name=endpoint-test,\n    location=test_azurerm_resource_group.location,\n    resource_group_name=resource_group_name,\n    subnet_id=test_azurerm_subnet.id,\n    private_service_connection=[{\n        name: test.private_link_service_name,\n        privateConnectionResourceId: test.private_link_service_resource_id,\n        isManualConnection: True,\n        requestMessage: Azure Private Link test,\n    }])\ntest_serverless_instance = mongodbatlas.ServerlessInstance(\"test\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    name=\"test-db\",\n    provider_settings_backing_provider_name=\"AZURE\",\n    provider_settings_provider_name=\"SERVERLESS\",\n    provider_settings_region_name=\"US_EAST\",\n    continuous_backup_enabled=True)\ntest_privatelink_endpoint_service_serverless = mongodbatlas.PrivatelinkEndpointServiceServerless(\"test\",\n    project_id=test.project_id,\n    instance_name=test_serverless_instance.name,\n    endpoint_id=test.endpoint_id,\n    cloud_provider_endpoint_id=test_private_endpoint[\"id\"],\n    private_endpoint_ip_address=test_private_endpoint[\"privateServiceConnection\"][0][\"privateIpAddress\"],\n    provider_name=\"AZURE\",\n    comment=\"test\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Azurerm = Pulumi.Azurerm;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.PrivatelinkEndpointServerless(\"test\", new()\n    {\n        ProjectId = projectId,\n        ProviderName = \"AZURE\",\n    });\n\n    var testPrivateEndpoint = new Azurerm.Index.PrivateEndpoint(\"test\", new()\n    {\n        Name = \"endpoint-test\",\n        Location = testAzurermResourceGroup.Location,\n        ResourceGroupName = resourceGroupName,\n        SubnetId = testAzurermSubnet.Id,\n        PrivateServiceConnection = new[]\n        {\n            \n            {\n                { \"name\", test.PrivateLinkServiceName },\n                { \"privateConnectionResourceId\", test.PrivateLinkServiceResourceId },\n                { \"isManualConnection\", true },\n                { \"requestMessage\", \"Azure Private Link test\" },\n            },\n        },\n    });\n\n    var testServerlessInstance = new Mongodbatlas.ServerlessInstance(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        Name = \"test-db\",\n        ProviderSettingsBackingProviderName = \"AZURE\",\n        ProviderSettingsProviderName = \"SERVERLESS\",\n        ProviderSettingsRegionName = \"US_EAST\",\n        ContinuousBackupEnabled = true,\n    });\n\n    var testPrivatelinkEndpointServiceServerless = new Mongodbatlas.PrivatelinkEndpointServiceServerless(\"test\", new()\n    {\n        ProjectId = test.ProjectId,\n        InstanceName = testServerlessInstance.Name,\n        EndpointId = test.EndpointId,\n        CloudProviderEndpointId = testPrivateEndpoint.Id,\n        PrivateEndpointIpAddress = testPrivateEndpoint.PrivateServiceConnection[0].PrivateIpAddress,\n        ProviderName = \"AZURE\",\n        Comment = \"test\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-azurerm/sdk/go/azurerm\"\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := mongodbatlas.NewPrivatelinkEndpointServerless(ctx, \"test\", \u0026mongodbatlas.PrivatelinkEndpointServerlessArgs{\n\t\t\tProjectId:    pulumi.Any(projectId),\n\t\t\tProviderName: pulumi.String(\"AZURE\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestPrivateEndpoint, err := azurerm.NewPrivateEndpoint(ctx, \"test\", \u0026azurerm.PrivateEndpointArgs{\n\t\t\tName:              \"endpoint-test\",\n\t\t\tLocation:          testAzurermResourceGroup.Location,\n\t\t\tResourceGroupName: resourceGroupName,\n\t\t\tSubnetId:          testAzurermSubnet.Id,\n\t\t\tPrivateServiceConnection: []map[string]interface{}{\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"name\":                        test.PrivateLinkServiceName,\n\t\t\t\t\t\"privateConnectionResourceId\": test.PrivateLinkServiceResourceId,\n\t\t\t\t\t\"isManualConnection\":          true,\n\t\t\t\t\t\"requestMessage\":              \"Azure Private Link test\",\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestServerlessInstance, err := mongodbatlas.NewServerlessInstance(ctx, \"test\", \u0026mongodbatlas.ServerlessInstanceArgs{\n\t\t\tProjectId:                           pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tName:                                pulumi.String(\"test-db\"),\n\t\t\tProviderSettingsBackingProviderName: pulumi.String(\"AZURE\"),\n\t\t\tProviderSettingsProviderName:        pulumi.String(\"SERVERLESS\"),\n\t\t\tProviderSettingsRegionName:          pulumi.String(\"US_EAST\"),\n\t\t\tContinuousBackupEnabled:             pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewPrivatelinkEndpointServiceServerless(ctx, \"test\", \u0026mongodbatlas.PrivatelinkEndpointServiceServerlessArgs{\n\t\t\tProjectId:                test.ProjectId,\n\t\t\tInstanceName:             testServerlessInstance.Name,\n\t\t\tEndpointId:               test.EndpointId,\n\t\t\tCloudProviderEndpointId:  testPrivateEndpoint.Id,\n\t\t\tPrivateEndpointIpAddress: testPrivateEndpoint.PrivateServiceConnection[0].PrivateIpAddress,\n\t\t\tProviderName:             pulumi.String(\"AZURE\"),\n\t\t\tComment:                  pulumi.String(\"test\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServerless;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServerlessArgs;\nimport com.pulumi.azurerm.privateEndpoint;\nimport com.pulumi.azurerm.PrivateEndpointArgs;\nimport com.pulumi.mongodbatlas.ServerlessInstance;\nimport com.pulumi.mongodbatlas.ServerlessInstanceArgs;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceServerless;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceServerlessArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new PrivatelinkEndpointServerless(\"test\", PrivatelinkEndpointServerlessArgs.builder()\n            .projectId(projectId)\n            .providerName(\"AZURE\")\n            .build());\n\n        var testPrivateEndpoint = new PrivateEndpoint(\"testPrivateEndpoint\", PrivateEndpointArgs.builder()\n            .name(\"endpoint-test\")\n            .location(testAzurermResourceGroup.location())\n            .resourceGroupName(resourceGroupName)\n            .subnetId(testAzurermSubnet.id())\n            .privateServiceConnection(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n            .build());\n\n        var testServerlessInstance = new ServerlessInstance(\"testServerlessInstance\", ServerlessInstanceArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .name(\"test-db\")\n            .providerSettingsBackingProviderName(\"AZURE\")\n            .providerSettingsProviderName(\"SERVERLESS\")\n            .providerSettingsRegionName(\"US_EAST\")\n            .continuousBackupEnabled(true)\n            .build());\n\n        var testPrivatelinkEndpointServiceServerless = new PrivatelinkEndpointServiceServerless(\"testPrivatelinkEndpointServiceServerless\", PrivatelinkEndpointServiceServerlessArgs.builder()\n            .projectId(test.projectId())\n            .instanceName(testServerlessInstance.name())\n            .endpointId(test.endpointId())\n            .cloudProviderEndpointId(testPrivateEndpoint.id())\n            .privateEndpointIpAddress(testPrivateEndpoint.privateServiceConnection()[0].privateIpAddress())\n            .providerName(\"AZURE\")\n            .comment(\"test\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:PrivatelinkEndpointServerless\n    properties:\n      projectId: ${projectId}\n      providerName: AZURE\n  testPrivateEndpoint:\n    type: azurerm:privateEndpoint\n    name: test\n    properties:\n      name: endpoint-test\n      location: ${testAzurermResourceGroup.location}\n      resourceGroupName: ${resourceGroupName}\n      subnetId: ${testAzurermSubnet.id}\n      privateServiceConnection:\n        - name: ${test.privateLinkServiceName}\n          privateConnectionResourceId: ${test.privateLinkServiceResourceId}\n          isManualConnection: true\n          requestMessage: Azure Private Link test\n  testPrivatelinkEndpointServiceServerless:\n    type: mongodbatlas:PrivatelinkEndpointServiceServerless\n    name: test\n    properties:\n      projectId: ${test.projectId}\n      instanceName: ${testServerlessInstance.name}\n      endpointId: ${test.endpointId}\n      cloudProviderEndpointId: ${testPrivateEndpoint.id}\n      privateEndpointIpAddress: ${testPrivateEndpoint.privateServiceConnection[0].privateIpAddress}\n      providerName: AZURE\n      comment: test\n  testServerlessInstance:\n    type: mongodbatlas:ServerlessInstance\n    name: test\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      name: test-db\n      providerSettingsBackingProviderName: AZURE\n      providerSettingsProviderName: SERVERLESS\n      providerSettingsRegionName: US_EAST\n      continuousBackupEnabled: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Available complete examples\n- Setup private connection to a MongoDB Atlas Serverless Instance with AWS VPC\n\n## Import\n\nServerless privatelink endpoint can be imported using project ID and endpoint ID, in the format `project_id`--`endpoint_id`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/privatelinkEndpointServiceServerless:PrivatelinkEndpointServiceServerless test 1112222b3bf99403840e8934--serverless_name--vpce-jjg5e24qp93513h03\n```\nFor more information see: [MongoDB Atlas API - Serverless Private Endpoints](https://www.mongodb.com/docs/atlas/reference/api/serverless-private-endpoints-get-one/).\n\n",
            "properties": {
                "cloudProviderEndpointId": {
                    "type": "string",
                    "description": "Unique string that identifies the private endpoint's network interface.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Human-readable string to associate with this private endpoint.\n"
                },
                "endpointId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the private endpoint.\n"
                },
                "instanceName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the serverless instance.\n"
                },
                "privateEndpointIpAddress": {
                    "type": "string",
                    "description": "IPv4 address of the private endpoint in your Azure VNet that someone added to this private endpoint service.\n"
                },
                "privateLinkServiceResourceId": {
                    "type": "string",
                    "description": "Root-relative path that identifies the Azure Private Link Service that MongoDB Cloud manages.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-digit hexadecimal string that identifies the project.\n"
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud provider for which you want to create a private endpoint. Atlas accepts `AWS`, `AZURE`.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Human-readable label that indicates the current operating status of the private endpoint. Values include: RESERVATION_REQUESTED, RESERVED, INITIATING, AVAILABLE, FAILED, DELETING.\n"
                }
            },
            "required": [
                "cloudProviderEndpointId",
                "endpointId",
                "instanceName",
                "privateEndpointIpAddress",
                "privateLinkServiceResourceId",
                "projectId",
                "providerName",
                "status"
            ],
            "inputProperties": {
                "cloudProviderEndpointId": {
                    "type": "string",
                    "description": "Unique string that identifies the private endpoint's network interface.\n",
                    "willReplaceOnChanges": true
                },
                "comment": {
                    "type": "string",
                    "description": "Human-readable string to associate with this private endpoint.\n"
                },
                "endpointId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the private endpoint.\n",
                    "willReplaceOnChanges": true
                },
                "instanceName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the serverless instance.\n",
                    "willReplaceOnChanges": true
                },
                "privateEndpointIpAddress": {
                    "type": "string",
                    "description": "IPv4 address of the private endpoint in your Azure VNet that someone added to this private endpoint service.\n",
                    "willReplaceOnChanges": true
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-digit hexadecimal string that identifies the project.\n",
                    "willReplaceOnChanges": true
                },
                "providerName": {
                    "type": "string",
                    "description": "Cloud provider for which you want to create a private endpoint. Atlas accepts `AWS`, `AZURE`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "endpointId",
                "instanceName",
                "projectId",
                "providerName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PrivatelinkEndpointServiceServerless resources.\n",
                "properties": {
                    "cloudProviderEndpointId": {
                        "type": "string",
                        "description": "Unique string that identifies the private endpoint's network interface.\n",
                        "willReplaceOnChanges": true
                    },
                    "comment": {
                        "type": "string",
                        "description": "Human-readable string to associate with this private endpoint.\n"
                    },
                    "endpointId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the private endpoint.\n",
                        "willReplaceOnChanges": true
                    },
                    "instanceName": {
                        "type": "string",
                        "description": "Human-readable label that identifies the serverless instance.\n",
                        "willReplaceOnChanges": true
                    },
                    "privateEndpointIpAddress": {
                        "type": "string",
                        "description": "IPv4 address of the private endpoint in your Azure VNet that someone added to this private endpoint service.\n",
                        "willReplaceOnChanges": true
                    },
                    "privateLinkServiceResourceId": {
                        "type": "string",
                        "description": "Root-relative path that identifies the Azure Private Link Service that MongoDB Cloud manages.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-digit hexadecimal string that identifies the project.\n",
                        "willReplaceOnChanges": true
                    },
                    "providerName": {
                        "type": "string",
                        "description": "Cloud provider for which you want to create a private endpoint. Atlas accepts `AWS`, `AZURE`.\n",
                        "willReplaceOnChanges": true
                    },
                    "status": {
                        "type": "string",
                        "description": "Human-readable label that indicates the current operating status of the private endpoint. Values include: RESERVATION_REQUESTED, RESERVED, INITIATING, AVAILABLE, FAILED, DELETING.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/project:Project": {
            "description": "## # Resource: mongodbatlas.Project\n\n`mongodbatlas.Project` provides a Project resource. This allows project to be created.\n\n\u003e **NOTE:** If Backup Compliance Policy is enabled for the project for which this backup schedule is defined, you cannot delete the Atlas project if any snapshots exist.  See [Backup Compliance Policy Prohibited Actions and Considerations](https://www.mongodb.com/docs/atlas/backup/cloud-backup/backup-compliance-policy/#configure-a-backup-compliance-policy).\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = mongodbatlas.getRolesOrgId({});\nconst testProject = new mongodbatlas.Project(\"test\", {\n    name: \"project-name\",\n    orgId: test.then(test =\u003e test.orgId),\n    projectOwnerId: \"\u003cOWNER_ACCOUNT_ID\u003e\",\n    teams: [\n        {\n            teamId: \"5e0fa8c99ccf641c722fe645\",\n            roleNames: [\"GROUP_OWNER\"],\n        },\n        {\n            teamId: \"5e1dd7b4f2a30ba80a70cd4rw\",\n            roleNames: [\n                \"GROUP_READ_ONLY\",\n                \"GROUP_DATA_ACCESS_READ_WRITE\",\n            ],\n        },\n    ],\n    limits: [\n        {\n            name: \"atlas.project.deployment.clusters\",\n            value: 26,\n        },\n        {\n            name: \"atlas.project.deployment.nodesPerPrivateLinkRegion\",\n            value: 51,\n        },\n    ],\n    isCollectDatabaseSpecificsStatisticsEnabled: true,\n    isDataExplorerEnabled: true,\n    isExtendedStorageSizesEnabled: true,\n    isPerformanceAdvisorEnabled: true,\n    isRealtimePerformancePanelEnabled: true,\n    isSchemaAdvisorEnabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.get_roles_org_id()\ntest_project = mongodbatlas.Project(\"test\",\n    name=\"project-name\",\n    org_id=test.org_id,\n    project_owner_id=\"\u003cOWNER_ACCOUNT_ID\u003e\",\n    teams=[\n        {\n            \"team_id\": \"5e0fa8c99ccf641c722fe645\",\n            \"role_names\": [\"GROUP_OWNER\"],\n        },\n        {\n            \"team_id\": \"5e1dd7b4f2a30ba80a70cd4rw\",\n            \"role_names\": [\n                \"GROUP_READ_ONLY\",\n                \"GROUP_DATA_ACCESS_READ_WRITE\",\n            ],\n        },\n    ],\n    limits=[\n        {\n            \"name\": \"atlas.project.deployment.clusters\",\n            \"value\": 26,\n        },\n        {\n            \"name\": \"atlas.project.deployment.nodesPerPrivateLinkRegion\",\n            \"value\": 51,\n        },\n    ],\n    is_collect_database_specifics_statistics_enabled=True,\n    is_data_explorer_enabled=True,\n    is_extended_storage_sizes_enabled=True,\n    is_performance_advisor_enabled=True,\n    is_realtime_performance_panel_enabled=True,\n    is_schema_advisor_enabled=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Mongodbatlas.GetRolesOrgId.Invoke();\n\n    var testProject = new Mongodbatlas.Project(\"test\", new()\n    {\n        Name = \"project-name\",\n        OrgId = test.Apply(getRolesOrgIdResult =\u003e getRolesOrgIdResult.OrgId),\n        ProjectOwnerId = \"\u003cOWNER_ACCOUNT_ID\u003e\",\n        Teams = new[]\n        {\n            new Mongodbatlas.Inputs.ProjectTeamArgs\n            {\n                TeamId = \"5e0fa8c99ccf641c722fe645\",\n                RoleNames = new[]\n                {\n                    \"GROUP_OWNER\",\n                },\n            },\n            new Mongodbatlas.Inputs.ProjectTeamArgs\n            {\n                TeamId = \"5e1dd7b4f2a30ba80a70cd4rw\",\n                RoleNames = new[]\n                {\n                    \"GROUP_READ_ONLY\",\n                    \"GROUP_DATA_ACCESS_READ_WRITE\",\n                },\n            },\n        },\n        Limits = new[]\n        {\n            new Mongodbatlas.Inputs.ProjectLimitArgs\n            {\n                Name = \"atlas.project.deployment.clusters\",\n                Value = 26,\n            },\n            new Mongodbatlas.Inputs.ProjectLimitArgs\n            {\n                Name = \"atlas.project.deployment.nodesPerPrivateLinkRegion\",\n                Value = 51,\n            },\n        },\n        IsCollectDatabaseSpecificsStatisticsEnabled = true,\n        IsDataExplorerEnabled = true,\n        IsExtendedStorageSizesEnabled = true,\n        IsPerformanceAdvisorEnabled = true,\n        IsRealtimePerformancePanelEnabled = true,\n        IsSchemaAdvisorEnabled = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := mongodbatlas.GetRolesOrgId(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewProject(ctx, \"test\", \u0026mongodbatlas.ProjectArgs{\n\t\t\tName:           pulumi.String(\"project-name\"),\n\t\t\tOrgId:          pulumi.String(test.OrgId),\n\t\t\tProjectOwnerId: pulumi.String(\"\u003cOWNER_ACCOUNT_ID\u003e\"),\n\t\t\tTeams: mongodbatlas.ProjectTeamArray{\n\t\t\t\t\u0026mongodbatlas.ProjectTeamArgs{\n\t\t\t\t\tTeamId: pulumi.String(\"5e0fa8c99ccf641c722fe645\"),\n\t\t\t\t\tRoleNames: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_OWNER\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.ProjectTeamArgs{\n\t\t\t\t\tTeamId: pulumi.String(\"5e1dd7b4f2a30ba80a70cd4rw\"),\n\t\t\t\t\tRoleNames: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_READ_ONLY\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_READ_WRITE\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tLimits: mongodbatlas.ProjectLimitArray{\n\t\t\t\t\u0026mongodbatlas.ProjectLimitArgs{\n\t\t\t\t\tName:  pulumi.String(\"atlas.project.deployment.clusters\"),\n\t\t\t\t\tValue: pulumi.Int(26),\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.ProjectLimitArgs{\n\t\t\t\t\tName:  pulumi.String(\"atlas.project.deployment.nodesPerPrivateLinkRegion\"),\n\t\t\t\t\tValue: pulumi.Int(51),\n\t\t\t\t},\n\t\t\t},\n\t\t\tIsCollectDatabaseSpecificsStatisticsEnabled: pulumi.Bool(true),\n\t\t\tIsDataExplorerEnabled:                       pulumi.Bool(true),\n\t\t\tIsExtendedStorageSizesEnabled:               pulumi.Bool(true),\n\t\t\tIsPerformanceAdvisorEnabled:                 pulumi.Bool(true),\n\t\t\tIsRealtimePerformancePanelEnabled:           pulumi.Bool(true),\n\t\t\tIsSchemaAdvisorEnabled:                      pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.Project;\nimport com.pulumi.mongodbatlas.ProjectArgs;\nimport com.pulumi.mongodbatlas.inputs.ProjectTeamArgs;\nimport com.pulumi.mongodbatlas.inputs.ProjectLimitArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getRolesOrgId();\n\n        var testProject = new Project(\"testProject\", ProjectArgs.builder()\n            .name(\"project-name\")\n            .orgId(test.applyValue(getRolesOrgIdResult -\u003e getRolesOrgIdResult.orgId()))\n            .projectOwnerId(\"\u003cOWNER_ACCOUNT_ID\u003e\")\n            .teams(            \n                ProjectTeamArgs.builder()\n                    .teamId(\"5e0fa8c99ccf641c722fe645\")\n                    .roleNames(\"GROUP_OWNER\")\n                    .build(),\n                ProjectTeamArgs.builder()\n                    .teamId(\"5e1dd7b4f2a30ba80a70cd4rw\")\n                    .roleNames(                    \n                        \"GROUP_READ_ONLY\",\n                        \"GROUP_DATA_ACCESS_READ_WRITE\")\n                    .build())\n            .limits(            \n                ProjectLimitArgs.builder()\n                    .name(\"atlas.project.deployment.clusters\")\n                    .value(26)\n                    .build(),\n                ProjectLimitArgs.builder()\n                    .name(\"atlas.project.deployment.nodesPerPrivateLinkRegion\")\n                    .value(51)\n                    .build())\n            .isCollectDatabaseSpecificsStatisticsEnabled(true)\n            .isDataExplorerEnabled(true)\n            .isExtendedStorageSizesEnabled(true)\n            .isPerformanceAdvisorEnabled(true)\n            .isRealtimePerformancePanelEnabled(true)\n            .isSchemaAdvisorEnabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testProject:\n    type: mongodbatlas:Project\n    name: test\n    properties:\n      name: project-name\n      orgId: ${test.orgId}\n      projectOwnerId: \u003cOWNER_ACCOUNT_ID\u003e\n      teams:\n        - teamId: 5e0fa8c99ccf641c722fe645\n          roleNames:\n            - GROUP_OWNER\n        - teamId: 5e1dd7b4f2a30ba80a70cd4rw\n          roleNames:\n            - GROUP_READ_ONLY\n            - GROUP_DATA_ACCESS_READ_WRITE\n      limits:\n        - name: atlas.project.deployment.clusters\n          value: 26\n        - name: atlas.project.deployment.nodesPerPrivateLinkRegion\n          value: 51\n      isCollectDatabaseSpecificsStatisticsEnabled: true\n      isDataExplorerEnabled: true\n      isExtendedStorageSizesEnabled: true\n      isPerformanceAdvisorEnabled: true\n      isRealtimePerformancePanelEnabled: true\n      isSchemaAdvisorEnabled: true\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getRolesOrgId\n      Arguments: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nProject must be imported using project ID, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/project:Project my_project 5d09d6a59ccf6445652a444a\n```\nFor more information see: [MongoDB Atlas Admin API Projects](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Projects) and [MongoDB Atlas Admin API Teams](https://docs.atlas.mongodb.com/reference/api/teams/) Documentation for more information.\n\n",
            "properties": {
                "clusterCount": {
                    "type": "integer",
                    "description": "The number of Atlas clusters deployed in the project.\n"
                },
                "created": {
                    "type": "string",
                    "description": "The ISO-8601-formatted timestamp of when Atlas created the project.\n"
                },
                "ipAddresses": {
                    "$ref": "#/types/mongodbatlas:index/ProjectIpAddresses:ProjectIpAddresses",
                    "description": "IP addresses in a project categorized by services. See IP Addresses.\n"
                },
                "isCollectDatabaseSpecificsStatisticsEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable statistics in [cluster metrics](https://www.mongodb.com/docs/atlas/monitor-cluster-metrics/) collection for the project. By default, this flag is set to true.\n"
                },
                "isDataExplorerEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable Data Explorer for the project. If enabled, you can query your database with an easy to use interface.  When Data Explorer is disabled, you cannot terminate slow operations from the [Real-Time Performance Panel](https://www.mongodb.com/docs/atlas/real-time-performance-panel/#std-label-real-time-metrics-status-tab) or create indexes from the [Performance Advisor](https://www.mongodb.com/docs/atlas/performance-advisor/#std-label-performance-advisor). You can still view Performance Advisor recommendations, but you must create those indexes from [mongosh](https://www.mongodb.com/docs/mongodb-shell/#mongodb-binary-bin.mongosh). By default, this flag is set to true.\n"
                },
                "isExtendedStorageSizesEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable extended storage sizes for the specified project. Clusters with extended storage sizes must be on AWS or GCP, and cannot span multiple regions. When extending storage size, initial syncs and cross-project snapshot restores will be slow. This setting should only be used as a measure of temporary relief; consider sharding if more storage is required.\n"
                },
                "isPerformanceAdvisorEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable Performance Advisor and Profiler for the project. If enabled, you can analyze database logs to recommend performance improvements. By default, this flag is set to true.\n"
                },
                "isRealtimePerformancePanelEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable Real Time Performance Panel for the project. If enabled, you can see real time metrics from your MongoDB database. By default, this flag is set to true.\n"
                },
                "isSchemaAdvisorEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable Schema Advisor for the project. If enabled, you receive customized recommendations to optimize your data model and enhance performance. Disable this setting to disable schema suggestions in the [Performance Advisor](https://www.mongodb.com/docs/atlas/performance-advisor/#std-label-performance-advisor) and the [Data Explorer](https://www.mongodb.com/docs/atlas/atlas-ui/#std-label-atlas-ui). By default, this flag is set to true.\n"
                },
                "limits": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ProjectLimit:ProjectLimit"
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of the project you want to create.\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "The ID of the organization you want to create the project within.\n"
                },
                "projectOwnerId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the Atlas user account to be granted the [Project Owner](https://docs.atlas.mongodb.com/reference/user-roles/#mongodb-authrole-Project-Owner) role on the specified project. If you set this parameter, it overrides the default value of the oldest [Organization Owner](https://docs.atlas.mongodb.com/reference/user-roles/#mongodb-authrole-Organization-Owner).\n"
                },
                "regionUsageRestrictions": {
                    "type": "string",
                    "description": "Designates that this project can be used for government regions only.  If not set the project will default to standard regions.   You cannot deploy clusters across government and standard regions in the same project. AWS is the only cloud provider for AtlasGov.  For more information see [MongoDB Atlas for Government](https://www.mongodb.com/docs/atlas/government/api/#creating-a-project).\n"
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the project. See below.\n"
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ProjectTeam:ProjectTeam"
                    }
                },
                "withDefaultAlertsSettings": {
                    "type": "boolean",
                    "description": "It allows users to disable the creation of the default alert settings. By default, this flag is set to true.\n"
                }
            },
            "required": [
                "clusterCount",
                "created",
                "ipAddresses",
                "isCollectDatabaseSpecificsStatisticsEnabled",
                "isDataExplorerEnabled",
                "isExtendedStorageSizesEnabled",
                "isPerformanceAdvisorEnabled",
                "isRealtimePerformancePanelEnabled",
                "isSchemaAdvisorEnabled",
                "name",
                "orgId",
                "regionUsageRestrictions",
                "withDefaultAlertsSettings"
            ],
            "inputProperties": {
                "isCollectDatabaseSpecificsStatisticsEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable statistics in [cluster metrics](https://www.mongodb.com/docs/atlas/monitor-cluster-metrics/) collection for the project. By default, this flag is set to true.\n"
                },
                "isDataExplorerEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable Data Explorer for the project. If enabled, you can query your database with an easy to use interface.  When Data Explorer is disabled, you cannot terminate slow operations from the [Real-Time Performance Panel](https://www.mongodb.com/docs/atlas/real-time-performance-panel/#std-label-real-time-metrics-status-tab) or create indexes from the [Performance Advisor](https://www.mongodb.com/docs/atlas/performance-advisor/#std-label-performance-advisor). You can still view Performance Advisor recommendations, but you must create those indexes from [mongosh](https://www.mongodb.com/docs/mongodb-shell/#mongodb-binary-bin.mongosh). By default, this flag is set to true.\n"
                },
                "isExtendedStorageSizesEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable extended storage sizes for the specified project. Clusters with extended storage sizes must be on AWS or GCP, and cannot span multiple regions. When extending storage size, initial syncs and cross-project snapshot restores will be slow. This setting should only be used as a measure of temporary relief; consider sharding if more storage is required.\n"
                },
                "isPerformanceAdvisorEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable Performance Advisor and Profiler for the project. If enabled, you can analyze database logs to recommend performance improvements. By default, this flag is set to true.\n"
                },
                "isRealtimePerformancePanelEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable Real Time Performance Panel for the project. If enabled, you can see real time metrics from your MongoDB database. By default, this flag is set to true.\n"
                },
                "isSchemaAdvisorEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether to enable Schema Advisor for the project. If enabled, you receive customized recommendations to optimize your data model and enhance performance. Disable this setting to disable schema suggestions in the [Performance Advisor](https://www.mongodb.com/docs/atlas/performance-advisor/#std-label-performance-advisor) and the [Data Explorer](https://www.mongodb.com/docs/atlas/atlas-ui/#std-label-atlas-ui). By default, this flag is set to true.\n"
                },
                "limits": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ProjectLimit:ProjectLimit"
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of the project you want to create.\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "The ID of the organization you want to create the project within.\n"
                },
                "projectOwnerId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the Atlas user account to be granted the [Project Owner](https://docs.atlas.mongodb.com/reference/user-roles/#mongodb-authrole-Project-Owner) role on the specified project. If you set this parameter, it overrides the default value of the oldest [Organization Owner](https://docs.atlas.mongodb.com/reference/user-roles/#mongodb-authrole-Organization-Owner).\n"
                },
                "regionUsageRestrictions": {
                    "type": "string",
                    "description": "Designates that this project can be used for government regions only.  If not set the project will default to standard regions.   You cannot deploy clusters across government and standard regions in the same project. AWS is the only cloud provider for AtlasGov.  For more information see [MongoDB Atlas for Government](https://www.mongodb.com/docs/atlas/government/api/#creating-a-project).\n"
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the project. See below.\n"
                },
                "teams": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ProjectTeam:ProjectTeam"
                    }
                },
                "withDefaultAlertsSettings": {
                    "type": "boolean",
                    "description": "It allows users to disable the creation of the default alert settings. By default, this flag is set to true.\n"
                }
            },
            "requiredInputs": [
                "orgId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Project resources.\n",
                "properties": {
                    "clusterCount": {
                        "type": "integer",
                        "description": "The number of Atlas clusters deployed in the project.\n"
                    },
                    "created": {
                        "type": "string",
                        "description": "The ISO-8601-formatted timestamp of when Atlas created the project.\n"
                    },
                    "ipAddresses": {
                        "$ref": "#/types/mongodbatlas:index/ProjectIpAddresses:ProjectIpAddresses",
                        "description": "IP addresses in a project categorized by services. See IP Addresses.\n"
                    },
                    "isCollectDatabaseSpecificsStatisticsEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether to enable statistics in [cluster metrics](https://www.mongodb.com/docs/atlas/monitor-cluster-metrics/) collection for the project. By default, this flag is set to true.\n"
                    },
                    "isDataExplorerEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether to enable Data Explorer for the project. If enabled, you can query your database with an easy to use interface.  When Data Explorer is disabled, you cannot terminate slow operations from the [Real-Time Performance Panel](https://www.mongodb.com/docs/atlas/real-time-performance-panel/#std-label-real-time-metrics-status-tab) or create indexes from the [Performance Advisor](https://www.mongodb.com/docs/atlas/performance-advisor/#std-label-performance-advisor). You can still view Performance Advisor recommendations, but you must create those indexes from [mongosh](https://www.mongodb.com/docs/mongodb-shell/#mongodb-binary-bin.mongosh). By default, this flag is set to true.\n"
                    },
                    "isExtendedStorageSizesEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether to enable extended storage sizes for the specified project. Clusters with extended storage sizes must be on AWS or GCP, and cannot span multiple regions. When extending storage size, initial syncs and cross-project snapshot restores will be slow. This setting should only be used as a measure of temporary relief; consider sharding if more storage is required.\n"
                    },
                    "isPerformanceAdvisorEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether to enable Performance Advisor and Profiler for the project. If enabled, you can analyze database logs to recommend performance improvements. By default, this flag is set to true.\n"
                    },
                    "isRealtimePerformancePanelEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether to enable Real Time Performance Panel for the project. If enabled, you can see real time metrics from your MongoDB database. By default, this flag is set to true.\n"
                    },
                    "isSchemaAdvisorEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether to enable Schema Advisor for the project. If enabled, you receive customized recommendations to optimize your data model and enhance performance. Disable this setting to disable schema suggestions in the [Performance Advisor](https://www.mongodb.com/docs/atlas/performance-advisor/#std-label-performance-advisor) and the [Data Explorer](https://www.mongodb.com/docs/atlas/atlas-ui/#std-label-atlas-ui). By default, this flag is set to true.\n"
                    },
                    "limits": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/ProjectLimit:ProjectLimit"
                        }
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the project you want to create.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "The ID of the organization you want to create the project within.\n"
                    },
                    "projectOwnerId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the Atlas user account to be granted the [Project Owner](https://docs.atlas.mongodb.com/reference/user-roles/#mongodb-authrole-Project-Owner) role on the specified project. If you set this parameter, it overrides the default value of the oldest [Organization Owner](https://docs.atlas.mongodb.com/reference/user-roles/#mongodb-authrole-Organization-Owner).\n"
                    },
                    "regionUsageRestrictions": {
                        "type": "string",
                        "description": "Designates that this project can be used for government regions only.  If not set the project will default to standard regions.   You cannot deploy clusters across government and standard regions in the same project. AWS is the only cloud provider for AtlasGov.  For more information see [MongoDB Atlas for Government](https://www.mongodb.com/docs/atlas/government/api/#creating-a-project).\n"
                    },
                    "tags": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the project. See below.\n"
                    },
                    "teams": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/ProjectTeam:ProjectTeam"
                        }
                    },
                    "withDefaultAlertsSettings": {
                        "type": "boolean",
                        "description": "It allows users to disable the creation of the default alert settings. By default, this flag is set to true.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/projectApiKey:ProjectApiKey": {
            "description": "## Example Usage\n\n### Create And Assign PAK Together\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.ProjectApiKey(\"test\", {\n    description: \"Description of your API key\",\n    projectAssignments: [{\n        projectId: \"64259ee860c43338194b0f8e\",\n        roleNames: [\"GROUP_OWNER\"],\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.ProjectApiKey(\"test\",\n    description=\"Description of your API key\",\n    project_assignments=[{\n        \"project_id\": \"64259ee860c43338194b0f8e\",\n        \"role_names\": [\"GROUP_OWNER\"],\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.ProjectApiKey(\"test\", new()\n    {\n        Description = \"Description of your API key\",\n        ProjectAssignments = new[]\n        {\n            new Mongodbatlas.Inputs.ProjectApiKeyProjectAssignmentArgs\n            {\n                ProjectId = \"64259ee860c43338194b0f8e\",\n                RoleNames = new[]\n                {\n                    \"GROUP_OWNER\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewProjectApiKey(ctx, \"test\", \u0026mongodbatlas.ProjectApiKeyArgs{\n\t\t\tDescription: pulumi.String(\"Description of your API key\"),\n\t\t\tProjectAssignments: mongodbatlas.ProjectApiKeyProjectAssignmentArray{\n\t\t\t\t\u0026mongodbatlas.ProjectApiKeyProjectAssignmentArgs{\n\t\t\t\t\tProjectId: pulumi.String(\"64259ee860c43338194b0f8e\"),\n\t\t\t\t\tRoleNames: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_OWNER\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ProjectApiKey;\nimport com.pulumi.mongodbatlas.ProjectApiKeyArgs;\nimport com.pulumi.mongodbatlas.inputs.ProjectApiKeyProjectAssignmentArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new ProjectApiKey(\"test\", ProjectApiKeyArgs.builder()\n            .description(\"Description of your API key\")\n            .projectAssignments(ProjectApiKeyProjectAssignmentArgs.builder()\n                .projectId(\"64259ee860c43338194b0f8e\")\n                .roleNames(\"GROUP_OWNER\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:ProjectApiKey\n    properties:\n      description: Description of your API key\n      projectAssignments:\n        - projectId: 64259ee860c43338194b0f8e\n          roleNames:\n            - GROUP_OWNER\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Create And Assign PAK To Multiple Projects\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.ProjectApiKey(\"test\", {\n    description: \"Description of your API key\",\n    projectAssignments: [\n        {\n            projectId: \"64259ee860c43338194b0f8e\",\n            roleNames: [\n                \"GROUP_READ_ONLY\",\n                \"GROUP_OWNER\",\n            ],\n        },\n        {\n            projectId: \"74259ee860c43338194b0f8e\",\n            roleNames: [\"GROUP_READ_ONLY\"],\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.ProjectApiKey(\"test\",\n    description=\"Description of your API key\",\n    project_assignments=[\n        {\n            \"project_id\": \"64259ee860c43338194b0f8e\",\n            \"role_names\": [\n                \"GROUP_READ_ONLY\",\n                \"GROUP_OWNER\",\n            ],\n        },\n        {\n            \"project_id\": \"74259ee860c43338194b0f8e\",\n            \"role_names\": [\"GROUP_READ_ONLY\"],\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.ProjectApiKey(\"test\", new()\n    {\n        Description = \"Description of your API key\",\n        ProjectAssignments = new[]\n        {\n            new Mongodbatlas.Inputs.ProjectApiKeyProjectAssignmentArgs\n            {\n                ProjectId = \"64259ee860c43338194b0f8e\",\n                RoleNames = new[]\n                {\n                    \"GROUP_READ_ONLY\",\n                    \"GROUP_OWNER\",\n                },\n            },\n            new Mongodbatlas.Inputs.ProjectApiKeyProjectAssignmentArgs\n            {\n                ProjectId = \"74259ee860c43338194b0f8e\",\n                RoleNames = new[]\n                {\n                    \"GROUP_READ_ONLY\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewProjectApiKey(ctx, \"test\", \u0026mongodbatlas.ProjectApiKeyArgs{\n\t\t\tDescription: pulumi.String(\"Description of your API key\"),\n\t\t\tProjectAssignments: mongodbatlas.ProjectApiKeyProjectAssignmentArray{\n\t\t\t\t\u0026mongodbatlas.ProjectApiKeyProjectAssignmentArgs{\n\t\t\t\t\tProjectId: pulumi.String(\"64259ee860c43338194b0f8e\"),\n\t\t\t\t\tRoleNames: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_READ_ONLY\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_OWNER\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.ProjectApiKeyProjectAssignmentArgs{\n\t\t\t\t\tProjectId: pulumi.String(\"74259ee860c43338194b0f8e\"),\n\t\t\t\t\tRoleNames: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_READ_ONLY\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ProjectApiKey;\nimport com.pulumi.mongodbatlas.ProjectApiKeyArgs;\nimport com.pulumi.mongodbatlas.inputs.ProjectApiKeyProjectAssignmentArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new ProjectApiKey(\"test\", ProjectApiKeyArgs.builder()\n            .description(\"Description of your API key\")\n            .projectAssignments(            \n                ProjectApiKeyProjectAssignmentArgs.builder()\n                    .projectId(\"64259ee860c43338194b0f8e\")\n                    .roleNames(                    \n                        \"GROUP_READ_ONLY\",\n                        \"GROUP_OWNER\")\n                    .build(),\n                ProjectApiKeyProjectAssignmentArgs.builder()\n                    .projectId(\"74259ee860c43338194b0f8e\")\n                    .roleNames(\"GROUP_READ_ONLY\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:ProjectApiKey\n    properties:\n      description: Description of your API key\n      projectAssignments:\n        - projectId: 64259ee860c43338194b0f8e\n          roleNames:\n            - GROUP_READ_ONLY\n            - GROUP_OWNER\n        - projectId: 74259ee860c43338194b0f8e\n          roleNames:\n            - GROUP_READ_ONLY\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nAPI Keys must be imported using project ID, API Key ID e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/projectApiKey:ProjectApiKey test 5d09d6a59ccf6445652a444a-6576974933969669\n```\nSee [MongoDB Atlas API - API Key](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Programmatic-API-Keys/operation/createProjectApiKey) - Documentation for more information.\n\n",
            "properties": {
                "apiKeyId": {
                    "type": "string",
                    "description": "Unique identifier for this Project API key.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Description of this Project API key.\n"
                },
                "privateKey": {
                    "type": "string",
                    "secret": true
                },
                "projectAssignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ProjectApiKeyProjectAssignment:ProjectApiKeyProjectAssignment"
                    }
                },
                "publicKey": {
                    "type": "string"
                }
            },
            "required": [
                "apiKeyId",
                "description",
                "privateKey",
                "projectAssignments",
                "publicKey"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Description of this Project API key.\n"
                },
                "projectAssignments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ProjectApiKeyProjectAssignment:ProjectApiKeyProjectAssignment"
                    }
                }
            },
            "requiredInputs": [
                "description",
                "projectAssignments"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectApiKey resources.\n",
                "properties": {
                    "apiKeyId": {
                        "type": "string",
                        "description": "Unique identifier for this Project API key.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "Description of this Project API key.\n"
                    },
                    "privateKey": {
                        "type": "string",
                        "secret": true
                    },
                    "projectAssignments": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/ProjectApiKeyProjectAssignment:ProjectApiKeyProjectAssignment"
                        }
                    },
                    "publicKey": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/projectInvitation:ProjectInvitation": {
            "description": "## Example Usage\n\n### S\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.ProjectInvitation(\"test\", {\n    username: \"test-acc-username\",\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    roles: [\"GROUP_DATA_ACCESS_READ_WRITE\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.ProjectInvitation(\"test\",\n    username=\"test-acc-username\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    roles=[\"GROUP_DATA_ACCESS_READ_WRITE\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.ProjectInvitation(\"test\", new()\n    {\n        Username = \"test-acc-username\",\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        Roles = new[]\n        {\n            \"GROUP_DATA_ACCESS_READ_WRITE\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewProjectInvitation(ctx, \"test\", \u0026mongodbatlas.ProjectInvitationArgs{\n\t\t\tUsername:  pulumi.String(\"test-acc-username\"),\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_READ_WRITE\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ProjectInvitation;\nimport com.pulumi.mongodbatlas.ProjectInvitationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new ProjectInvitation(\"test\", ProjectInvitationArgs.builder()\n            .username(\"test-acc-username\")\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .roles(\"GROUP_DATA_ACCESS_READ_WRITE\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:ProjectInvitation\n    properties:\n      username: test-acc-username\n      projectId: \u003cPROJECT-ID\u003e\n      roles:\n        - GROUP_DATA_ACCESS_READ_WRITE\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.ProjectInvitation(\"test\", {\n    username: \"test-acc-username\",\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    roles: [\n        \"GROUP_READ_ONLY\",\n        \"GROUP_DATA_ACCESS_READ_ONLY\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.ProjectInvitation(\"test\",\n    username=\"test-acc-username\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    roles=[\n        \"GROUP_READ_ONLY\",\n        \"GROUP_DATA_ACCESS_READ_ONLY\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.ProjectInvitation(\"test\", new()\n    {\n        Username = \"test-acc-username\",\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        Roles = new[]\n        {\n            \"GROUP_READ_ONLY\",\n            \"GROUP_DATA_ACCESS_READ_ONLY\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewProjectInvitation(ctx, \"test\", \u0026mongodbatlas.ProjectInvitationArgs{\n\t\t\tUsername:  pulumi.String(\"test-acc-username\"),\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"GROUP_READ_ONLY\"),\n\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_READ_ONLY\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ProjectInvitation;\nimport com.pulumi.mongodbatlas.ProjectInvitationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new ProjectInvitation(\"test\", ProjectInvitationArgs.builder()\n            .username(\"test-acc-username\")\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .roles(            \n                \"GROUP_READ_ONLY\",\n                \"GROUP_DATA_ACCESS_READ_ONLY\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:ProjectInvitation\n    properties:\n      username: test-acc-username\n      projectId: \u003cPROJECT-ID\u003e\n      roles:\n        - GROUP_READ_ONLY\n        - GROUP_DATA_ACCESS_READ_ONLY\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n~\u003e __IMPORTANT:__\nA project invitation can __not__ be imported once it has been accepted.\n\nImport a user's invitation to a project by separating the `project_id` and the `username` with a hyphen:\n\n```sh\n$ pulumi import mongodbatlas:index/projectInvitation:ProjectInvitation my_user 1112222b3bf99403840e8934-my_user@mongodb.com\n```\n",
            "properties": {
                "createdAt": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when Atlas sent the invitation.\n"
                },
                "expiresAt": {
                    "type": "string",
                    "description": "Timestamp in ISO 8601 date and time format in UTC when the invitation expires. Users have 30 days to accept an invitation.\n"
                },
                "invitationId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the invitation in Atlas.\n"
                },
                "inviterUsername": {
                    "type": "string",
                    "description": "Atlas user who invited `username` to the project.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the project to which you want to invite a user.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Atlas roles to assign to the invited user. If the user accepts the invitation, Atlas assigns these roles to them. Refer to the [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) for information on valid roles.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Email address to which Atlas sent the invitation. The user uses this email address as their Atlas username if they accept this invitation.\n"
                }
            },
            "required": [
                "createdAt",
                "expiresAt",
                "invitationId",
                "inviterUsername",
                "projectId",
                "roles",
                "username"
            ],
            "inputProperties": {
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies the project to which you want to invite a user.\n",
                    "willReplaceOnChanges": true
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Atlas roles to assign to the invited user. If the user accepts the invitation, Atlas assigns these roles to them. Refer to the [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) for information on valid roles.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Email address to which Atlas sent the invitation. The user uses this email address as their Atlas username if they accept this invitation.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "projectId",
                "roles",
                "username"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectInvitation resources.\n",
                "properties": {
                    "createdAt": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when Atlas sent the invitation.\n"
                    },
                    "expiresAt": {
                        "type": "string",
                        "description": "Timestamp in ISO 8601 date and time format in UTC when the invitation expires. Users have 30 days to accept an invitation.\n"
                    },
                    "invitationId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the invitation in Atlas.\n"
                    },
                    "inviterUsername": {
                        "type": "string",
                        "description": "Atlas user who invited `username` to the project.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the project to which you want to invite a user.\n",
                        "willReplaceOnChanges": true
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Atlas roles to assign to the invited user. If the user accepts the invitation, Atlas assigns these roles to them. Refer to the [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) for information on valid roles.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Email address to which Atlas sent the invitation. The user uses this email address as their Atlas username if they accept this invitation.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/projectIpAccessList:ProjectIpAccessList": {
            "description": "## # Resource: mongodbatlas.ProjectIpAccessList\n\n`mongodbatlas.ProjectIpAccessList` provides an IP Access List entry resource. The access list grants access from IPs, CIDRs or AWS Security Groups (if VPC Peering is enabled) to clusters within the Project.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n\u003e **IMPORTANT:**\nWhen you remove an entry from the access list, existing connections from the removed address(es) may remain open for a variable amount of time. How much time passes before Atlas closes the connection depends on several factors, including how the connection was established, the particular behavior of the application or driver using the address, and the connection protocol (e.g., TCP or UDP). This is particularly important to consider when changing an existing IP address or CIDR block as they cannot be updated via the Provider (comments can however), hence a change will force the destruction and recreation of entries.   \n\n\n## Example Usage\n\n### Using CIDR Block\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.ProjectIpAccessList(\"test\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    cidrBlock: \"1.2.3.4/32\",\n    comment: \"cidr block for tf acc testing\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.ProjectIpAccessList(\"test\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    cidr_block=\"1.2.3.4/32\",\n    comment=\"cidr block for tf acc testing\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.ProjectIpAccessList(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        CidrBlock = \"1.2.3.4/32\",\n        Comment = \"cidr block for tf acc testing\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewProjectIpAccessList(ctx, \"test\", \u0026mongodbatlas.ProjectIpAccessListArgs{\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tCidrBlock: pulumi.String(\"1.2.3.4/32\"),\n\t\t\tComment:   pulumi.String(\"cidr block for tf acc testing\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ProjectIpAccessList;\nimport com.pulumi.mongodbatlas.ProjectIpAccessListArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new ProjectIpAccessList(\"test\", ProjectIpAccessListArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .cidrBlock(\"1.2.3.4/32\")\n            .comment(\"cidr block for tf acc testing\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:ProjectIpAccessList\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      cidrBlock: 1.2.3.4/32\n      comment: cidr block for tf acc testing\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Using IP Address\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.ProjectIpAccessList(\"test\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    ipAddress: \"2.3.4.5\",\n    comment: \"ip address for tf acc testing\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.ProjectIpAccessList(\"test\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    ip_address=\"2.3.4.5\",\n    comment=\"ip address for tf acc testing\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.ProjectIpAccessList(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        IpAddress = \"2.3.4.5\",\n        Comment = \"ip address for tf acc testing\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewProjectIpAccessList(ctx, \"test\", \u0026mongodbatlas.ProjectIpAccessListArgs{\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tIpAddress: pulumi.String(\"2.3.4.5\"),\n\t\t\tComment:   pulumi.String(\"ip address for tf acc testing\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ProjectIpAccessList;\nimport com.pulumi.mongodbatlas.ProjectIpAccessListArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new ProjectIpAccessList(\"test\", ProjectIpAccessListArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .ipAddress(\"2.3.4.5\")\n            .comment(\"ip address for tf acc testing\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:ProjectIpAccessList\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      ipAddress: 2.3.4.5\n      comment: ip address for tf acc testing\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Using an AWS Security Group\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.NetworkContainer(\"test\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    atlasCidrBlock: \"192.168.208.0/21\",\n    providerName: \"AWS\",\n    regionName: \"US_EAST_1\",\n});\nconst testNetworkPeering = new mongodbatlas.NetworkPeering(\"test\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    containerId: test.containerId,\n    accepterRegionName: \"us-east-1\",\n    providerName: \"AWS\",\n    routeTableCidrBlock: \"172.31.0.0/16\",\n    vpcId: \"vpc-0d93d6f69f1578bd8\",\n    awsAccountId: \"232589400519\",\n});\nconst testProjectIpAccessList = new mongodbatlas.ProjectIpAccessList(\"test\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    awsSecurityGroup: \"sg-0026348ec11780bd1\",\n    comment: \"TestAcc for awsSecurityGroup\",\n}, {\n    dependsOn: [testNetworkPeering],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.NetworkContainer(\"test\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    atlas_cidr_block=\"192.168.208.0/21\",\n    provider_name=\"AWS\",\n    region_name=\"US_EAST_1\")\ntest_network_peering = mongodbatlas.NetworkPeering(\"test\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    container_id=test.container_id,\n    accepter_region_name=\"us-east-1\",\n    provider_name=\"AWS\",\n    route_table_cidr_block=\"172.31.0.0/16\",\n    vpc_id=\"vpc-0d93d6f69f1578bd8\",\n    aws_account_id=\"232589400519\")\ntest_project_ip_access_list = mongodbatlas.ProjectIpAccessList(\"test\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    aws_security_group=\"sg-0026348ec11780bd1\",\n    comment=\"TestAcc for awsSecurityGroup\",\n    opts = pulumi.ResourceOptions(depends_on=[test_network_peering]))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.NetworkContainer(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        AtlasCidrBlock = \"192.168.208.0/21\",\n        ProviderName = \"AWS\",\n        RegionName = \"US_EAST_1\",\n    });\n\n    var testNetworkPeering = new Mongodbatlas.NetworkPeering(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        ContainerId = test.ContainerId,\n        AccepterRegionName = \"us-east-1\",\n        ProviderName = \"AWS\",\n        RouteTableCidrBlock = \"172.31.0.0/16\",\n        VpcId = \"vpc-0d93d6f69f1578bd8\",\n        AwsAccountId = \"232589400519\",\n    });\n\n    var testProjectIpAccessList = new Mongodbatlas.ProjectIpAccessList(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        AwsSecurityGroup = \"sg-0026348ec11780bd1\",\n        Comment = \"TestAcc for awsSecurityGroup\",\n    }, new CustomResourceOptions\n    {\n        DependsOn =\n        {\n            testNetworkPeering,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := mongodbatlas.NewNetworkContainer(ctx, \"test\", \u0026mongodbatlas.NetworkContainerArgs{\n\t\t\tProjectId:      pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tAtlasCidrBlock: pulumi.String(\"192.168.208.0/21\"),\n\t\t\tProviderName:   pulumi.String(\"AWS\"),\n\t\t\tRegionName:     pulumi.String(\"US_EAST_1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestNetworkPeering, err := mongodbatlas.NewNetworkPeering(ctx, \"test\", \u0026mongodbatlas.NetworkPeeringArgs{\n\t\t\tProjectId:           pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tContainerId:         test.ContainerId,\n\t\t\tAccepterRegionName:  pulumi.String(\"us-east-1\"),\n\t\t\tProviderName:        pulumi.String(\"AWS\"),\n\t\t\tRouteTableCidrBlock: pulumi.String(\"172.31.0.0/16\"),\n\t\t\tVpcId:               pulumi.String(\"vpc-0d93d6f69f1578bd8\"),\n\t\t\tAwsAccountId:        pulumi.String(\"232589400519\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewProjectIpAccessList(ctx, \"test\", \u0026mongodbatlas.ProjectIpAccessListArgs{\n\t\t\tProjectId:        pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tAwsSecurityGroup: pulumi.String(\"sg-0026348ec11780bd1\"),\n\t\t\tComment:          pulumi.String(\"TestAcc for awsSecurityGroup\"),\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\ttestNetworkPeering,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.NetworkContainer;\nimport com.pulumi.mongodbatlas.NetworkContainerArgs;\nimport com.pulumi.mongodbatlas.NetworkPeering;\nimport com.pulumi.mongodbatlas.NetworkPeeringArgs;\nimport com.pulumi.mongodbatlas.ProjectIpAccessList;\nimport com.pulumi.mongodbatlas.ProjectIpAccessListArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new NetworkContainer(\"test\", NetworkContainerArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .atlasCidrBlock(\"192.168.208.0/21\")\n            .providerName(\"AWS\")\n            .regionName(\"US_EAST_1\")\n            .build());\n\n        var testNetworkPeering = new NetworkPeering(\"testNetworkPeering\", NetworkPeeringArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .containerId(test.containerId())\n            .accepterRegionName(\"us-east-1\")\n            .providerName(\"AWS\")\n            .routeTableCidrBlock(\"172.31.0.0/16\")\n            .vpcId(\"vpc-0d93d6f69f1578bd8\")\n            .awsAccountId(\"232589400519\")\n            .build());\n\n        var testProjectIpAccessList = new ProjectIpAccessList(\"testProjectIpAccessList\", ProjectIpAccessListArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .awsSecurityGroup(\"sg-0026348ec11780bd1\")\n            .comment(\"TestAcc for awsSecurityGroup\")\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(testNetworkPeering)\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:NetworkContainer\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      atlasCidrBlock: 192.168.208.0/21\n      providerName: AWS\n      regionName: US_EAST_1\n  testNetworkPeering:\n    type: mongodbatlas:NetworkPeering\n    name: test\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      containerId: ${test.containerId}\n      accepterRegionName: us-east-1\n      providerName: AWS\n      routeTableCidrBlock: 172.31.0.0/16\n      vpcId: vpc-0d93d6f69f1578bd8\n      awsAccountId: '232589400519'\n  testProjectIpAccessList:\n    type: mongodbatlas:ProjectIpAccessList\n    name: test\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      awsSecurityGroup: sg-0026348ec11780bd1\n      comment: TestAcc for awsSecurityGroup\n    options:\n      dependson:\n        - ${testNetworkPeering}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\u003e **IMPORTANT:** In order to use AWS Security Group(s) VPC Peering must be enabled like above example.\n\n## Import\n\nIP Access List entries can be imported using the `project_id` and `cidr_block` or `ip_address`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/projectIpAccessList:ProjectIpAccessList test 5d0f1f74cf09a29120e123cd-10.242.88.0/21\n```\nFor more information see: [MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/access-lists/)\n\n",
            "properties": {
                "awsSecurityGroup": {
                    "type": "string",
                    "description": "Unique identifier of the AWS security group to add to the access list. Your access list entry can include only one `awsSecurityGroup`, one `cidrBlock`, or one `ipAddress`.\n"
                },
                "cidrBlock": {
                    "type": "string",
                    "description": "Range of IP addresses in CIDR notation to be added to the access list. Your access list entry can include only one `awsSecurityGroup`, one `cidrBlock`, or one `ipAddress`.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Comment to add to the access list entry.\n\n\u003e **NOTE:** One of the following attributes must set:  `aws_security_group`, `cidr_block`  or `ip_address`.\n"
                },
                "ipAddress": {
                    "type": "string",
                    "description": "Single IP address to be added to the access list. Mutually exclusive with `awsSecurityGroup` and `cidrBlock`.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique identifier for the project to which you want to add one or more access list entries.\n"
                },
                "timeouts": {
                    "$ref": "#/types/mongodbatlas:index/ProjectIpAccessListTimeouts:ProjectIpAccessListTimeouts"
                }
            },
            "required": [
                "awsSecurityGroup",
                "cidrBlock",
                "comment",
                "ipAddress",
                "projectId"
            ],
            "inputProperties": {
                "awsSecurityGroup": {
                    "type": "string",
                    "description": "Unique identifier of the AWS security group to add to the access list. Your access list entry can include only one `awsSecurityGroup`, one `cidrBlock`, or one `ipAddress`.\n"
                },
                "cidrBlock": {
                    "type": "string",
                    "description": "Range of IP addresses in CIDR notation to be added to the access list. Your access list entry can include only one `awsSecurityGroup`, one `cidrBlock`, or one `ipAddress`.\n"
                },
                "comment": {
                    "type": "string",
                    "description": "Comment to add to the access list entry.\n\n\u003e **NOTE:** One of the following attributes must set:  `aws_security_group`, `cidr_block`  or `ip_address`.\n"
                },
                "ipAddress": {
                    "type": "string",
                    "description": "Single IP address to be added to the access list. Mutually exclusive with `awsSecurityGroup` and `cidrBlock`.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique identifier for the project to which you want to add one or more access list entries.\n"
                },
                "timeouts": {
                    "$ref": "#/types/mongodbatlas:index/ProjectIpAccessListTimeouts:ProjectIpAccessListTimeouts"
                }
            },
            "requiredInputs": [
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ProjectIpAccessList resources.\n",
                "properties": {
                    "awsSecurityGroup": {
                        "type": "string",
                        "description": "Unique identifier of the AWS security group to add to the access list. Your access list entry can include only one `awsSecurityGroup`, one `cidrBlock`, or one `ipAddress`.\n"
                    },
                    "cidrBlock": {
                        "type": "string",
                        "description": "Range of IP addresses in CIDR notation to be added to the access list. Your access list entry can include only one `awsSecurityGroup`, one `cidrBlock`, or one `ipAddress`.\n"
                    },
                    "comment": {
                        "type": "string",
                        "description": "Comment to add to the access list entry.\n\n\u003e **NOTE:** One of the following attributes must set:  `aws_security_group`, `cidr_block`  or `ip_address`.\n"
                    },
                    "ipAddress": {
                        "type": "string",
                        "description": "Single IP address to be added to the access list. Mutually exclusive with `awsSecurityGroup` and `cidrBlock`.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique identifier for the project to which you want to add one or more access list entries.\n"
                    },
                    "timeouts": {
                        "$ref": "#/types/mongodbatlas:index/ProjectIpAccessListTimeouts:ProjectIpAccessListTimeouts"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/pushBasedLogExport:PushBasedLogExport": {
            "description": "## Example Usage\n\n### S\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nexport = async () =\u003e {\n    const project_tf = new mongodbatlas.Project(\"project-tf\", {\n        name: atlasProjectName,\n        orgId: atlasOrgId,\n    });\n    // Set up cloud provider access in Atlas using the created IAM role\n    const setupOnly = new mongodbatlas.CloudProviderAccessSetup(\"setup_only\", {\n        projectId: project_tf.id,\n        providerName: \"AWS\",\n    });\n    const authRole = new mongodbatlas.CloudProviderAccessAuthorization(\"auth_role\", {\n        projectId: project_tf.id,\n        roleId: setupOnly.roleId,\n        aws: {\n            iamAssumedRoleArn: testRole.arn,\n        },\n    });\n    // Set up push-based log export with authorized IAM role\n    const testPushBasedLogExport = new mongodbatlas.PushBasedLogExport(\"test\", {\n        projectId: project_tf.id,\n        bucketName: logBucket.bucket,\n        iamRoleId: authRole.roleId,\n        prefixPath: \"push-based-log-test\",\n    });\n    const test = mongodbatlas.getPushBasedLogExportOutput({\n        projectId: testPushBasedLogExport.projectId,\n    });\n    return {\n        test: test.apply(test =\u003e test.prefixPath),\n    };\n}\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nproject_tf = mongodbatlas.Project(\"project-tf\",\n    name=atlas_project_name,\n    org_id=atlas_org_id)\n# Set up cloud provider access in Atlas using the created IAM role\nsetup_only = mongodbatlas.CloudProviderAccessSetup(\"setup_only\",\n    project_id=project_tf.id,\n    provider_name=\"AWS\")\nauth_role = mongodbatlas.CloudProviderAccessAuthorization(\"auth_role\",\n    project_id=project_tf.id,\n    role_id=setup_only.role_id,\n    aws={\n        \"iam_assumed_role_arn\": test_role[\"arn\"],\n    })\n# Set up push-based log export with authorized IAM role\ntest_push_based_log_export = mongodbatlas.PushBasedLogExport(\"test\",\n    project_id=project_tf.id,\n    bucket_name=log_bucket[\"bucket\"],\n    iam_role_id=auth_role.role_id,\n    prefix_path=\"push-based-log-test\")\ntest = mongodbatlas.get_push_based_log_export_output(project_id=test_push_based_log_export.project_id)\npulumi.export(\"test\", test.prefix_path)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var project_tf = new Mongodbatlas.Project(\"project-tf\", new()\n    {\n        Name = atlasProjectName,\n        OrgId = atlasOrgId,\n    });\n\n    // Set up cloud provider access in Atlas using the created IAM role\n    var setupOnly = new Mongodbatlas.CloudProviderAccessSetup(\"setup_only\", new()\n    {\n        ProjectId = project_tf.Id,\n        ProviderName = \"AWS\",\n    });\n\n    var authRole = new Mongodbatlas.CloudProviderAccessAuthorization(\"auth_role\", new()\n    {\n        ProjectId = project_tf.Id,\n        RoleId = setupOnly.RoleId,\n        Aws = new Mongodbatlas.Inputs.CloudProviderAccessAuthorizationAwsArgs\n        {\n            IamAssumedRoleArn = testRole.Arn,\n        },\n    });\n\n    // Set up push-based log export with authorized IAM role\n    var testPushBasedLogExport = new Mongodbatlas.PushBasedLogExport(\"test\", new()\n    {\n        ProjectId = project_tf.Id,\n        BucketName = logBucket.Bucket,\n        IamRoleId = authRole.RoleId,\n        PrefixPath = \"push-based-log-test\",\n    });\n\n    var test = Mongodbatlas.GetPushBasedLogExport.Invoke(new()\n    {\n        ProjectId = testPushBasedLogExport.ProjectId,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"test\"] = test.Apply(getPushBasedLogExportResult =\u003e getPushBasedLogExportResult.PrefixPath),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewProject(ctx, \"project-tf\", \u0026mongodbatlas.ProjectArgs{\n\t\t\tName:  pulumi.Any(atlasProjectName),\n\t\t\tOrgId: pulumi.Any(atlasOrgId),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Set up cloud provider access in Atlas using the created IAM role\n\t\tsetupOnly, err := mongodbatlas.NewCloudProviderAccessSetup(ctx, \"setup_only\", \u0026mongodbatlas.CloudProviderAccessSetupArgs{\n\t\t\tProjectId:    project_tf.ID(),\n\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tauthRole, err := mongodbatlas.NewCloudProviderAccessAuthorization(ctx, \"auth_role\", \u0026mongodbatlas.CloudProviderAccessAuthorizationArgs{\n\t\t\tProjectId: project_tf.ID(),\n\t\t\tRoleId:    setupOnly.RoleId,\n\t\t\tAws: \u0026mongodbatlas.CloudProviderAccessAuthorizationAwsArgs{\n\t\t\t\tIamAssumedRoleArn: pulumi.Any(testRole.Arn),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Set up push-based log export with authorized IAM role\n\t\ttestPushBasedLogExport, err := mongodbatlas.NewPushBasedLogExport(ctx, \"test\", \u0026mongodbatlas.PushBasedLogExportArgs{\n\t\t\tProjectId:  project_tf.ID(),\n\t\t\tBucketName: pulumi.Any(logBucket.Bucket),\n\t\t\tIamRoleId:  authRole.RoleId,\n\t\t\tPrefixPath: pulumi.String(\"push-based-log-test\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttest := mongodbatlas.LookupPushBasedLogExportOutput(ctx, mongodbatlas.GetPushBasedLogExportOutputArgs{\n\t\t\tProjectId: testPushBasedLogExport.ProjectId,\n\t\t}, nil)\n\t\tctx.Export(\"test\", test.ApplyT(func(test mongodbatlas.GetPushBasedLogExportResult) (*string, error) {\n\t\t\treturn \u0026test.PrefixPath, nil\n\t\t}).(pulumi.StringPtrOutput))\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Project;\nimport com.pulumi.mongodbatlas.ProjectArgs;\nimport com.pulumi.mongodbatlas.CloudProviderAccessSetup;\nimport com.pulumi.mongodbatlas.CloudProviderAccessSetupArgs;\nimport com.pulumi.mongodbatlas.CloudProviderAccessAuthorization;\nimport com.pulumi.mongodbatlas.CloudProviderAccessAuthorizationArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudProviderAccessAuthorizationAwsArgs;\nimport com.pulumi.mongodbatlas.PushBasedLogExport;\nimport com.pulumi.mongodbatlas.PushBasedLogExportArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetPushBasedLogExportArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var project_tf = new Project(\"project-tf\", ProjectArgs.builder()\n            .name(atlasProjectName)\n            .orgId(atlasOrgId)\n            .build());\n\n        // Set up cloud provider access in Atlas using the created IAM role\n        var setupOnly = new CloudProviderAccessSetup(\"setupOnly\", CloudProviderAccessSetupArgs.builder()\n            .projectId(project_tf.id())\n            .providerName(\"AWS\")\n            .build());\n\n        var authRole = new CloudProviderAccessAuthorization(\"authRole\", CloudProviderAccessAuthorizationArgs.builder()\n            .projectId(project_tf.id())\n            .roleId(setupOnly.roleId())\n            .aws(CloudProviderAccessAuthorizationAwsArgs.builder()\n                .iamAssumedRoleArn(testRole.arn())\n                .build())\n            .build());\n\n        // Set up push-based log export with authorized IAM role\n        var testPushBasedLogExport = new PushBasedLogExport(\"testPushBasedLogExport\", PushBasedLogExportArgs.builder()\n            .projectId(project_tf.id())\n            .bucketName(logBucket.bucket())\n            .iamRoleId(authRole.roleId())\n            .prefixPath(\"push-based-log-test\")\n            .build());\n\n        final var test = MongodbatlasFunctions.getPushBasedLogExport(GetPushBasedLogExportArgs.builder()\n            .projectId(testPushBasedLogExport.projectId())\n            .build());\n\n        ctx.export(\"test\", test.applyValue(getPushBasedLogExportResult -\u003e getPushBasedLogExportResult).applyValue(test -\u003e test.applyValue(getPushBasedLogExportResult -\u003e getPushBasedLogExportResult.prefixPath())));\n    }\n}\n```\n```yaml\nresources:\n  project-tf:\n    type: mongodbatlas:Project\n    properties:\n      name: ${atlasProjectName}\n      orgId: ${atlasOrgId}\n  # Set up cloud provider access in Atlas using the created IAM role\n  setupOnly:\n    type: mongodbatlas:CloudProviderAccessSetup\n    name: setup_only\n    properties:\n      projectId: ${[\"project-tf\"].id}\n      providerName: AWS\n  authRole:\n    type: mongodbatlas:CloudProviderAccessAuthorization\n    name: auth_role\n    properties:\n      projectId: ${[\"project-tf\"].id}\n      roleId: ${setupOnly.roleId}\n      aws:\n        iamAssumedRoleArn: ${testRole.arn}\n  # Set up push-based log export with authorized IAM role\n  testPushBasedLogExport:\n    type: mongodbatlas:PushBasedLogExport\n    name: test\n    properties:\n      projectId: ${[\"project-tf\"].id}\n      bucketName: ${logBucket.bucket}\n      iamRoleId: ${authRole.roleId}\n      prefixPath: push-based-log-test\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getPushBasedLogExport\n      Arguments:\n        projectId: ${testPushBasedLogExport.projectId}\noutputs:\n  test: ${test.prefixPath}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "bucketName": {
                    "type": "string",
                    "description": "The name of the bucket to which the agent sends the logs to.\n"
                },
                "createDate": {
                    "type": "string",
                    "description": "Date and time that this feature was enabled on.\n"
                },
                "iamRoleId": {
                    "type": "string",
                    "description": "ID of the AWS IAM role that is used to write to the S3 bucket.\n"
                },
                "prefixPath": {
                    "type": "string",
                    "description": "S3 directory in which vector writes in order to store the logs. An empty string denotes the root directory.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies your project. Use the /groups endpoint to retrieve all projects to which the authenticated user has access.\n"
                },
                "state": {
                    "type": "string",
                    "description": "Describes whether or not the feature is enabled and what status it is in.\n"
                },
                "timeouts": {
                    "$ref": "#/types/mongodbatlas:index/PushBasedLogExportTimeouts:PushBasedLogExportTimeouts"
                }
            },
            "required": [
                "bucketName",
                "createDate",
                "iamRoleId",
                "prefixPath",
                "projectId",
                "state"
            ],
            "inputProperties": {
                "bucketName": {
                    "type": "string",
                    "description": "The name of the bucket to which the agent sends the logs to.\n"
                },
                "iamRoleId": {
                    "type": "string",
                    "description": "ID of the AWS IAM role that is used to write to the S3 bucket.\n"
                },
                "prefixPath": {
                    "type": "string",
                    "description": "S3 directory in which vector writes in order to store the logs. An empty string denotes the root directory.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies your project. Use the /groups endpoint to retrieve all projects to which the authenticated user has access.\n"
                },
                "timeouts": {
                    "$ref": "#/types/mongodbatlas:index/PushBasedLogExportTimeouts:PushBasedLogExportTimeouts"
                }
            },
            "requiredInputs": [
                "bucketName",
                "iamRoleId",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PushBasedLogExport resources.\n",
                "properties": {
                    "bucketName": {
                        "type": "string",
                        "description": "The name of the bucket to which the agent sends the logs to.\n"
                    },
                    "createDate": {
                        "type": "string",
                        "description": "Date and time that this feature was enabled on.\n"
                    },
                    "iamRoleId": {
                        "type": "string",
                        "description": "ID of the AWS IAM role that is used to write to the S3 bucket.\n"
                    },
                    "prefixPath": {
                        "type": "string",
                        "description": "S3 directory in which vector writes in order to store the logs. An empty string denotes the root directory.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies your project. Use the /groups endpoint to retrieve all projects to which the authenticated user has access.\n"
                    },
                    "state": {
                        "type": "string",
                        "description": "Describes whether or not the feature is enabled and what status it is in.\n"
                    },
                    "timeouts": {
                        "$ref": "#/types/mongodbatlas:index/PushBasedLogExportTimeouts:PushBasedLogExportTimeouts"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/searchDeployment:SearchDeployment": {
            "description": "## # Resource: mongodbatlas.SearchDeployment\n\n`mongodbatlas.SearchDeployment` provides a Search Deployment resource. The resource lets you create, edit and delete dedicated search nodes in a cluster.\n\n\u003e **NOTE:** For details on supported cloud providers and existing limitations you can visit the [Search Node Documentation](https://www.mongodb.com/docs/atlas/cluster-config/multi-cloud-distribution/#search-nodes-for-workload-isolation).\n\n\u003e **NOTE:** Only a single search deployment resource can be defined for each cluster.\n\n## Example Usage\n\n### S\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Project;\nimport com.pulumi.mongodbatlas.ProjectArgs;\nimport com.pulumi.mongodbatlas.AdvancedCluster;\nimport com.pulumi.mongodbatlas.AdvancedClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.AdvancedClusterReplicationSpecArgs;\nimport com.pulumi.mongodbatlas.SearchDeployment;\nimport com.pulumi.mongodbatlas.SearchDeploymentArgs;\nimport com.pulumi.mongodbatlas.inputs.SearchDeploymentSpecArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetSearchDeploymentArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleProject = new Project(\"exampleProject\", ProjectArgs.builder()\n            .name(\"project-name\")\n            .orgId(orgId)\n            .build());\n\n        var exampleAdvancedCluster = new AdvancedCluster(\"exampleAdvancedCluster\", AdvancedClusterArgs.builder()\n            .projectId(exampleProject.id())\n            .name(\"ClusterExample\")\n            .clusterType(\"REPLICASET\")\n            .replicationSpecs(AdvancedClusterReplicationSpecArgs.builder()\n                .regionConfigs(AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                    .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                        .instanceSize(\"M10\")\n                        .nodeCount(3)\n                        .build())\n                    .providerName(\"AWS\")\n                    .priority(7)\n                    .regionName(\"US_EAST_1\")\n                    .build())\n                .build())\n            .build());\n\n        var exampleSearchDeployment = new SearchDeployment(\"exampleSearchDeployment\", SearchDeploymentArgs.builder()\n            .projectId(exampleProject.id())\n            .clusterName(exampleAdvancedCluster.name())\n            .specs(SearchDeploymentSpecArgs.builder()\n                .instance_size(\"S20_HIGHCPU_NVME\")\n                .node_count(2)\n                .build())\n            .build());\n\n        final var example = MongodbatlasFunctions.getSearchDeployment(GetSearchDeploymentArgs.builder()\n            .projectId(exampleSearchDeployment.projectId())\n            .clusterName(exampleSearchDeployment.clusterName())\n            .build());\n\n        ctx.export(\"mongodbatlasSearchDeploymentId\", example.applyValue(getSearchDeploymentResult -\u003e getSearchDeploymentResult).applyValue(example -\u003e example.applyValue(getSearchDeploymentResult -\u003e getSearchDeploymentResult.id())));\n    }\n}\n```\n```yaml\nresources:\n  exampleProject:\n    type: mongodbatlas:Project\n    name: example\n    properties:\n      name: project-name\n      orgId: ${orgId}\n  exampleAdvancedCluster:\n    type: mongodbatlas:AdvancedCluster\n    name: example\n    properties:\n      projectId: ${exampleProject.id}\n      name: ClusterExample\n      clusterType: REPLICASET\n      replicationSpecs:\n        - regionConfigs:\n            - electableSpecs:\n                instanceSize: M10\n                nodeCount: 3\n              providerName: AWS\n              priority: 7\n              regionName: US_EAST_1\n  exampleSearchDeployment:\n    type: mongodbatlas:SearchDeployment\n    name: example\n    properties:\n      projectId: ${exampleProject.id}\n      clusterName: ${exampleAdvancedCluster.name}\n      specs:\n        - instance_size: S20_HIGHCPU_NVME\n          node_count: 2\nvariables:\n  example:\n    fn::invoke:\n      Function: mongodbatlas:getSearchDeployment\n      Arguments:\n        projectId: ${exampleSearchDeployment.projectId}\n        clusterName: ${exampleSearchDeployment.clusterName}\noutputs:\n  mongodbatlasSearchDeploymentId: ${example.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "clusterName": {
                    "type": "string",
                    "description": "Label that identifies the cluster to return the search nodes for.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal character string that identifies the project.\n"
                },
                "specs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/SearchDeploymentSpec:SearchDeploymentSpec"
                    },
                    "description": "List of settings that configure the search nodes for your cluster. This list is currently limited to defining a single element.\n"
                },
                "stateName": {
                    "type": "string",
                    "description": "Human-readable label that indicates the current operating condition of this search deployment.\n"
                },
                "timeouts": {
                    "$ref": "#/types/mongodbatlas:index/SearchDeploymentTimeouts:SearchDeploymentTimeouts"
                }
            },
            "required": [
                "clusterName",
                "projectId",
                "specs",
                "stateName"
            ],
            "inputProperties": {
                "clusterName": {
                    "type": "string",
                    "description": "Label that identifies the cluster to return the search nodes for.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal character string that identifies the project.\n"
                },
                "specs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/SearchDeploymentSpec:SearchDeploymentSpec"
                    },
                    "description": "List of settings that configure the search nodes for your cluster. This list is currently limited to defining a single element.\n"
                },
                "timeouts": {
                    "$ref": "#/types/mongodbatlas:index/SearchDeploymentTimeouts:SearchDeploymentTimeouts"
                }
            },
            "requiredInputs": [
                "clusterName",
                "projectId",
                "specs"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SearchDeployment resources.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "Label that identifies the cluster to return the search nodes for.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal character string that identifies the project.\n"
                    },
                    "specs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/SearchDeploymentSpec:SearchDeploymentSpec"
                        },
                        "description": "List of settings that configure the search nodes for your cluster. This list is currently limited to defining a single element.\n"
                    },
                    "stateName": {
                        "type": "string",
                        "description": "Human-readable label that indicates the current operating condition of this search deployment.\n"
                    },
                    "timeouts": {
                        "$ref": "#/types/mongodbatlas:index/SearchDeploymentTimeouts:SearchDeploymentTimeouts"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/searchIndex:SearchIndex": {
            "description": "## # Resource: mongodbatlas.SearchIndex\n\n`mongodbatlas.SearchIndex` provides a Search Index resource. This allows indexes to be created.\n\n## Example Usage\n\n### Basic search index\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test_basic_search_index = new mongodbatlas.SearchIndex(\"test-basic-search-index\", {\n    name: \"test-basic-search-index\",\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    clusterName: \"\u003cCLUSTER_NAME\u003e\",\n    analyzer: \"lucene.standard\",\n    collectionName: \"collection_test\",\n    database: \"database_test\",\n    mappingsDynamic: true,\n    searchAnalyzer: \"lucene.standard\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_basic_search_index = mongodbatlas.SearchIndex(\"test-basic-search-index\",\n    name=\"test-basic-search-index\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    cluster_name=\"\u003cCLUSTER_NAME\u003e\",\n    analyzer=\"lucene.standard\",\n    collection_name=\"collection_test\",\n    database=\"database_test\",\n    mappings_dynamic=True,\n    search_analyzer=\"lucene.standard\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test_basic_search_index = new Mongodbatlas.SearchIndex(\"test-basic-search-index\", new()\n    {\n        Name = \"test-basic-search-index\",\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        ClusterName = \"\u003cCLUSTER_NAME\u003e\",\n        Analyzer = \"lucene.standard\",\n        CollectionName = \"collection_test\",\n        Database = \"database_test\",\n        MappingsDynamic = true,\n        SearchAnalyzer = \"lucene.standard\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewSearchIndex(ctx, \"test-basic-search-index\", \u0026mongodbatlas.SearchIndexArgs{\n\t\t\tName:            pulumi.String(\"test-basic-search-index\"),\n\t\t\tProjectId:       pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tClusterName:     pulumi.String(\"\u003cCLUSTER_NAME\u003e\"),\n\t\t\tAnalyzer:        pulumi.String(\"lucene.standard\"),\n\t\t\tCollectionName:  pulumi.String(\"collection_test\"),\n\t\t\tDatabase:        pulumi.String(\"database_test\"),\n\t\t\tMappingsDynamic: pulumi.Bool(true),\n\t\t\tSearchAnalyzer:  pulumi.String(\"lucene.standard\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.SearchIndex;\nimport com.pulumi.mongodbatlas.SearchIndexArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test_basic_search_index = new SearchIndex(\"test-basic-search-index\", SearchIndexArgs.builder()\n            .name(\"test-basic-search-index\")\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .clusterName(\"\u003cCLUSTER_NAME\u003e\")\n            .analyzer(\"lucene.standard\")\n            .collectionName(\"collection_test\")\n            .database(\"database_test\")\n            .mappingsDynamic(true)\n            .searchAnalyzer(\"lucene.standard\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test-basic-search-index:\n    type: mongodbatlas:SearchIndex\n    properties:\n      name: test-basic-search-index\n      projectId: \u003cPROJECT_ID\u003e\n      clusterName: \u003cCLUSTER_NAME\u003e\n      analyzer: lucene.standard\n      collectionName: collection_test\n      database: database_test\n      mappingsDynamic: true\n      searchAnalyzer: lucene.standard\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Basic vector index\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test_basic_search_vector = new mongodbatlas.SearchIndex(\"test-basic-search-vector\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    clusterName: \"\u003cCLUSTER_NAME\u003e\",\n    collectionName: \"collection_test\",\n    database: \"database_test\",\n    type: \"vectorSearch\",\n    fields: `[{\n      \"type\": \"vector\",\n      \"path\": \"plot_embedding\",\n      \"numDimensions\": 1536,\n      \"similarity\": \"euclidean\"\n}]\n`,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_basic_search_vector = mongodbatlas.SearchIndex(\"test-basic-search-vector\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    cluster_name=\"\u003cCLUSTER_NAME\u003e\",\n    collection_name=\"collection_test\",\n    database=\"database_test\",\n    type=\"vectorSearch\",\n    fields=\"\"\"[{\n      \"type\": \"vector\",\n      \"path\": \"plot_embedding\",\n      \"numDimensions\": 1536,\n      \"similarity\": \"euclidean\"\n}]\n\"\"\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test_basic_search_vector = new Mongodbatlas.SearchIndex(\"test-basic-search-vector\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        ClusterName = \"\u003cCLUSTER_NAME\u003e\",\n        CollectionName = \"collection_test\",\n        Database = \"database_test\",\n        Type = \"vectorSearch\",\n        Fields = @\"[{\n      \"\"type\"\": \"\"vector\"\",\n      \"\"path\"\": \"\"plot_embedding\"\",\n      \"\"numDimensions\"\": 1536,\n      \"\"similarity\"\": \"\"euclidean\"\"\n}]\n\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewSearchIndex(ctx, \"test-basic-search-vector\", \u0026mongodbatlas.SearchIndexArgs{\n\t\t\tProjectId:      pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tClusterName:    pulumi.String(\"\u003cCLUSTER_NAME\u003e\"),\n\t\t\tCollectionName: pulumi.String(\"collection_test\"),\n\t\t\tDatabase:       pulumi.String(\"database_test\"),\n\t\t\tType:           pulumi.String(\"vectorSearch\"),\n\t\t\tFields: pulumi.String(`[{\n      \"type\": \"vector\",\n      \"path\": \"plot_embedding\",\n      \"numDimensions\": 1536,\n      \"similarity\": \"euclidean\"\n}]\n`),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.SearchIndex;\nimport com.pulumi.mongodbatlas.SearchIndexArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test_basic_search_vector = new SearchIndex(\"test-basic-search-vector\", SearchIndexArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .clusterName(\"\u003cCLUSTER_NAME\u003e\")\n            .collectionName(\"collection_test\")\n            .database(\"database_test\")\n            .type(\"vectorSearch\")\n            .fields(\"\"\"\n[{\n      \"type\": \"vector\",\n      \"path\": \"plot_embedding\",\n      \"numDimensions\": 1536,\n      \"similarity\": \"euclidean\"\n}]\n            \"\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test-basic-search-vector:\n    type: mongodbatlas:SearchIndex\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      clusterName: \u003cCLUSTER_NAME\u003e\n      collectionName: collection_test\n      database: database_test\n      type: vectorSearch\n      fields: |\n        [{\n              \"type\": \"vector\",\n              \"path\": \"plot_embedding\",\n              \"numDimensions\": 1536,\n              \"similarity\": \"euclidean\"\n        }]\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Advanced search index (with custom analyzers)\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test_advanced_search_index = new mongodbatlas.SearchIndex(\"test-advanced-search-index\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    clusterName: \"\u003cCLUSTER_NAME\u003e\",\n    analyzer: \"lucene.standard\",\n    collectionName: \"collection_test\",\n    database: \"database_test\",\n    mappingsDynamic: false,\n    mappingsFields: `{\n      \"address\": {\n        \"type\": \"document\",\n        \"fields\": {\n          \"city\": {\n            \"type\": \"string\",\n            \"analyzer\": \"lucene.simple\",\n            \"ignoreAbove\": 255\n          },\n          \"state\": {\n            \"type\": \"string\",\n            \"analyzer\": \"lucene.english\"\n          }\n        }\n      },\n      \"company\": {\n        \"type\": \"string\",\n        \"analyzer\": \"lucene.whitespace\",\n        \"multi\": {\n          \"mySecondaryAnalyzer\": {\n            \"type\": \"string\",\n            \"analyzer\": \"lucene.french\"\n          }\n        }\n      },\n      \"employees\": {\n        \"type\": \"string\",\n        \"analyzer\": \"lucene.standard\"\n      }\n}\n`,\n    name: \"test-advanced-search-index\",\n    searchAnalyzer: \"lucene.standard\",\n    analyzers: ` [{\n \"name\": \"index_analyzer_test_name\",\n \"charFilters\": [{\n\"type\": \"mapping\",\n\"mappings\": {\"\\\\\\\\\" : \"/\"}\n   \\x09}],\n \"tokenizer\": {\n \"type\": \"nGram\",\n \"minGram\": 2,\n \"maxGram\": 5\n\\x09},\n \"tokenFilters\": [{\n\"type\": \"length\",\n\"min\": 20,\n\"max\": 33\n   \\x09}]\n }]\n`,\n    synonyms: [{\n        analyzer: \"lucene.simple\",\n        name: \"synonym_test\",\n        sourceCollection: \"collection_test\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_advanced_search_index = mongodbatlas.SearchIndex(\"test-advanced-search-index\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    cluster_name=\"\u003cCLUSTER_NAME\u003e\",\n    analyzer=\"lucene.standard\",\n    collection_name=\"collection_test\",\n    database=\"database_test\",\n    mappings_dynamic=False,\n    mappings_fields=\"\"\"{\n      \"address\": {\n        \"type\": \"document\",\n        \"fields\": {\n          \"city\": {\n            \"type\": \"string\",\n            \"analyzer\": \"lucene.simple\",\n            \"ignoreAbove\": 255\n          },\n          \"state\": {\n            \"type\": \"string\",\n            \"analyzer\": \"lucene.english\"\n          }\n        }\n      },\n      \"company\": {\n        \"type\": \"string\",\n        \"analyzer\": \"lucene.whitespace\",\n        \"multi\": {\n          \"mySecondaryAnalyzer\": {\n            \"type\": \"string\",\n            \"analyzer\": \"lucene.french\"\n          }\n        }\n      },\n      \"employees\": {\n        \"type\": \"string\",\n        \"analyzer\": \"lucene.standard\"\n      }\n}\n\"\"\",\n    name=\"test-advanced-search-index\",\n    search_analyzer=\"lucene.standard\",\n    analyzers=\"\"\" [{\n \"name\": \"index_analyzer_test_name\",\n \"charFilters\": [{\n\"type\": \"mapping\",\n\"mappings\": {\"\\\\\" : \"/\"}\n   \\x09}],\n \"tokenizer\": {\n \"type\": \"nGram\",\n \"minGram\": 2,\n \"maxGram\": 5\n\\x09},\n \"tokenFilters\": [{\n\"type\": \"length\",\n\"min\": 20,\n\"max\": 33\n   \\x09}]\n }]\n\"\"\",\n    synonyms=[{\n        \"analyzer\": \"lucene.simple\",\n        \"name\": \"synonym_test\",\n        \"source_collection\": \"collection_test\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test_advanced_search_index = new Mongodbatlas.SearchIndex(\"test-advanced-search-index\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        ClusterName = \"\u003cCLUSTER_NAME\u003e\",\n        Analyzer = \"lucene.standard\",\n        CollectionName = \"collection_test\",\n        Database = \"database_test\",\n        MappingsDynamic = false,\n        MappingsFields = @\"{\n      \"\"address\"\": {\n        \"\"type\"\": \"\"document\"\",\n        \"\"fields\"\": {\n          \"\"city\"\": {\n            \"\"type\"\": \"\"string\"\",\n            \"\"analyzer\"\": \"\"lucene.simple\"\",\n            \"\"ignoreAbove\"\": 255\n          },\n          \"\"state\"\": {\n            \"\"type\"\": \"\"string\"\",\n            \"\"analyzer\"\": \"\"lucene.english\"\"\n          }\n        }\n      },\n      \"\"company\"\": {\n        \"\"type\"\": \"\"string\"\",\n        \"\"analyzer\"\": \"\"lucene.whitespace\"\",\n        \"\"multi\"\": {\n          \"\"mySecondaryAnalyzer\"\": {\n            \"\"type\"\": \"\"string\"\",\n            \"\"analyzer\"\": \"\"lucene.french\"\"\n          }\n        }\n      },\n      \"\"employees\"\": {\n        \"\"type\"\": \"\"string\"\",\n        \"\"analyzer\"\": \"\"lucene.standard\"\"\n      }\n}\n\",\n        Name = \"test-advanced-search-index\",\n        SearchAnalyzer = \"lucene.standard\",\n        Analyzers = @\" [{\n \"\"name\"\": \"\"index_analyzer_test_name\"\",\n \"\"charFilters\"\": [{\n\"\"type\"\": \"\"mapping\"\",\n\"\"mappings\"\": {\"\"\\\\\"\" : \"\"/\"\"}\n   \t}],\n \"\"tokenizer\"\": {\n \"\"type\"\": \"\"nGram\"\",\n \"\"minGram\"\": 2,\n \"\"maxGram\"\": 5\n\t},\n \"\"tokenFilters\"\": [{\n\"\"type\"\": \"\"length\"\",\n\"\"min\"\": 20,\n\"\"max\"\": 33\n   \t}]\n }]\n\",\n        Synonyms = new[]\n        {\n            new Mongodbatlas.Inputs.SearchIndexSynonymArgs\n            {\n                Analyzer = \"lucene.simple\",\n                Name = \"synonym_test\",\n                SourceCollection = \"collection_test\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewSearchIndex(ctx, \"test-advanced-search-index\", \u0026mongodbatlas.SearchIndexArgs{\n\t\t\tProjectId:       pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tClusterName:     pulumi.String(\"\u003cCLUSTER_NAME\u003e\"),\n\t\t\tAnalyzer:        pulumi.String(\"lucene.standard\"),\n\t\t\tCollectionName:  pulumi.String(\"collection_test\"),\n\t\t\tDatabase:        pulumi.String(\"database_test\"),\n\t\t\tMappingsDynamic: pulumi.Bool(false),\n\t\t\tMappingsFields: pulumi.String(`{\n      \"address\": {\n        \"type\": \"document\",\n        \"fields\": {\n          \"city\": {\n            \"type\": \"string\",\n            \"analyzer\": \"lucene.simple\",\n            \"ignoreAbove\": 255\n          },\n          \"state\": {\n            \"type\": \"string\",\n            \"analyzer\": \"lucene.english\"\n          }\n        }\n      },\n      \"company\": {\n        \"type\": \"string\",\n        \"analyzer\": \"lucene.whitespace\",\n        \"multi\": {\n          \"mySecondaryAnalyzer\": {\n            \"type\": \"string\",\n            \"analyzer\": \"lucene.french\"\n          }\n        }\n      },\n      \"employees\": {\n        \"type\": \"string\",\n        \"analyzer\": \"lucene.standard\"\n      }\n}\n`),\n\t\t\tName:           pulumi.String(\"test-advanced-search-index\"),\n\t\t\tSearchAnalyzer: pulumi.String(\"lucene.standard\"),\n\t\t\tAnalyzers: pulumi.String(` [{\n \"name\": \"index_analyzer_test_name\",\n \"charFilters\": [{\n\"type\": \"mapping\",\n\"mappings\": {\"\\\\\" : \"/\"}\n   \t}],\n \"tokenizer\": {\n \"type\": \"nGram\",\n \"minGram\": 2,\n \"maxGram\": 5\n\t},\n \"tokenFilters\": [{\n\"type\": \"length\",\n\"min\": 20,\n\"max\": 33\n   \t}]\n }]\n`),\n\t\t\tSynonyms: mongodbatlas.SearchIndexSynonymArray{\n\t\t\t\t\u0026mongodbatlas.SearchIndexSynonymArgs{\n\t\t\t\t\tAnalyzer:         pulumi.String(\"lucene.simple\"),\n\t\t\t\t\tName:             pulumi.String(\"synonym_test\"),\n\t\t\t\t\tSourceCollection: pulumi.String(\"collection_test\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.SearchIndex;\nimport com.pulumi.mongodbatlas.SearchIndexArgs;\nimport com.pulumi.mongodbatlas.inputs.SearchIndexSynonymArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test_advanced_search_index = new SearchIndex(\"test-advanced-search-index\", SearchIndexArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .clusterName(\"\u003cCLUSTER_NAME\u003e\")\n            .analyzer(\"lucene.standard\")\n            .collectionName(\"collection_test\")\n            .database(\"database_test\")\n            .mappingsDynamic(false)\n            .mappingsFields(\"\"\"\n{\n      \"address\": {\n        \"type\": \"document\",\n        \"fields\": {\n          \"city\": {\n            \"type\": \"string\",\n            \"analyzer\": \"lucene.simple\",\n            \"ignoreAbove\": 255\n          },\n          \"state\": {\n            \"type\": \"string\",\n            \"analyzer\": \"lucene.english\"\n          }\n        }\n      },\n      \"company\": {\n        \"type\": \"string\",\n        \"analyzer\": \"lucene.whitespace\",\n        \"multi\": {\n          \"mySecondaryAnalyzer\": {\n            \"type\": \"string\",\n            \"analyzer\": \"lucene.french\"\n          }\n        }\n      },\n      \"employees\": {\n        \"type\": \"string\",\n        \"analyzer\": \"lucene.standard\"\n      }\n}\n            \"\"\")\n            .name(\"test-advanced-search-index\")\n            .searchAnalyzer(\"lucene.standard\")\n            .analyzers(\"\"\"\n [{\n \"name\": \"index_analyzer_test_name\",\n \"charFilters\": [{\n\"type\": \"mapping\",\n\"mappings\": {\"\\\\\" : \"/\"}\n   \t}],\n \"tokenizer\": {\n \"type\": \"nGram\",\n \"minGram\": 2,\n \"maxGram\": 5\n\t},\n \"tokenFilters\": [{\n\"type\": \"length\",\n\"min\": 20,\n\"max\": 33\n   \t}]\n }]\n            \"\"\")\n            .synonyms(SearchIndexSynonymArgs.builder()\n                .analyzer(\"lucene.simple\")\n                .name(\"synonym_test\")\n                .sourceCollection(\"collection_test\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test-advanced-search-index:\n    type: mongodbatlas:SearchIndex\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      clusterName: \u003cCLUSTER_NAME\u003e\n      analyzer: lucene.standard\n      collectionName: collection_test\n      database: database_test\n      mappingsDynamic: false\n      mappingsFields: |\n        {\n              \"address\": {\n                \"type\": \"document\",\n                \"fields\": {\n                  \"city\": {\n                    \"type\": \"string\",\n                    \"analyzer\": \"lucene.simple\",\n                    \"ignoreAbove\": 255\n                  },\n                  \"state\": {\n                    \"type\": \"string\",\n                    \"analyzer\": \"lucene.english\"\n                  }\n                }\n              },\n              \"company\": {\n                \"type\": \"string\",\n                \"analyzer\": \"lucene.whitespace\",\n                \"multi\": {\n                  \"mySecondaryAnalyzer\": {\n                    \"type\": \"string\",\n                    \"analyzer\": \"lucene.french\"\n                  }\n                }\n              },\n              \"employees\": {\n                \"type\": \"string\",\n                \"analyzer\": \"lucene.standard\"\n              }\n        }\n      name: test-advanced-search-index\n      searchAnalyzer: lucene.standard\n      analyzers: |2\n         [{\n         \"name\": \"index_analyzer_test_name\",\n         \"charFilters\": [{\n        \"type\": \"mapping\",\n        \"mappings\": {\"\\\\\" : \"/\"}\n           \t}],\n         \"tokenizer\": {\n         \"type\": \"nGram\",\n         \"minGram\": 2,\n         \"maxGram\": 5\n        \t},\n         \"tokenFilters\": [{\n        \"type\": \"length\",\n        \"min\": 20,\n        \"max\": 33\n           \t}]\n         }]\n      synonyms:\n        - analyzer: lucene.simple\n          name: synonym_test\n          sourceCollection: collection_test\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "analyzer": {
                    "type": "string",
                    "description": "[Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index. Defaults to [lucene.standard](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/standard/#std-label-ref-standard-analyzer)\n"
                },
                "analyzers": {
                    "type": "string",
                    "description": "[Custom analyzers](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-custom-analyzers) to use in this index. This is an array of JSON objects.\n```\nanalyzers = \u003c\u003c-EOF\n[{\n\"name\": \"index_analyzer_test_name\",\n\"charFilters\": [{\n\"type\": \"mapping\",\n\"mappings\": {\"\\\\\" : \"/\"}\n}],\n\"tokenizer\": {\n\"type\": \"nGram\",\n\"minGram\": 2,\n\"maxGram\": 5\n},\n\"tokenFilters\": [{\n\"type\": \"length\",\n\"min\": 20,\n\"max\": 33\n}]\n}]\nEOF\n```\n"
                },
                "clusterName": {
                    "type": "string",
                    "description": "The name of the cluster where you want to create the search index within.\n"
                },
                "collectionName": {
                    "type": "string",
                    "description": "Name of the collection the index is on.\n"
                },
                "database": {
                    "type": "string",
                    "description": "Name of the database the collection is in.\n"
                },
                "fields": {
                    "type": "string",
                    "description": "Array of [Fields](https://www.mongodb.com/docs/atlas/atlas-search/field-types/knn-vector/#std-label-fts-data-types-knn-vector) to configure this `vectorSearch` index. It is mandatory for vector searches and it must contain at least one `vector` type field. This field needs to be a JSON string in order to be decoded correctly.\n"
                },
                "indexId": {
                    "type": "string",
                    "description": "The unique identifier of the Atlas Search index.\n"
                },
                "mappingsDynamic": {
                    "type": "boolean",
                    "description": "Indicates whether the search index uses dynamic or static mapping. For dynamic mapping, set the value to `true`. For static mapping, specify the fields to index using `mappings_fields`\n"
                },
                "mappingsFields": {
                    "type": "string",
                    "description": "attribute is required in search indexes when `mappings_dynamic` is false. This field needs to be a JSON string in order to be decoded correctly.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the search index you want to create.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The ID of the organization or project you want to create the search index within.\n"
                },
                "searchAnalyzer": {
                    "type": "string",
                    "description": "[Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when searching the index. Defaults to [lucene.standard](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/standard/#std-label-ref-standard-analyzer)\n"
                },
                "status": {
                    "type": "string",
                    "description": "Current status of the index.\n"
                },
                "storedSource": {
                    "type": "string",
                    "description": "String that can be \"true\" (store all fields), \"false\" (default, don't store any field), or a JSON string that contains the list of fields to store (include) or not store (exclude) on Atlas Search. To learn more, see [Stored Source Fields](https://www.mongodb.com/docs/atlas/atlas-search/stored-source-definition/).\n"
                },
                "synonyms": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/SearchIndexSynonym:SearchIndexSynonym"
                    },
                    "description": "Synonyms mapping definition to use in this index.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of index: `search` or `vectorSearch`. Default type is `search`.\n"
                },
                "waitForIndexBuildCompletion": {
                    "type": "boolean"
                }
            },
            "required": [
                "clusterName",
                "collectionName",
                "database",
                "indexId",
                "name",
                "projectId",
                "status"
            ],
            "inputProperties": {
                "analyzer": {
                    "type": "string",
                    "description": "[Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index. Defaults to [lucene.standard](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/standard/#std-label-ref-standard-analyzer)\n"
                },
                "analyzers": {
                    "type": "string",
                    "description": "[Custom analyzers](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-custom-analyzers) to use in this index. This is an array of JSON objects.\n```\nanalyzers = \u003c\u003c-EOF\n[{\n\"name\": \"index_analyzer_test_name\",\n\"charFilters\": [{\n\"type\": \"mapping\",\n\"mappings\": {\"\\\\\" : \"/\"}\n}],\n\"tokenizer\": {\n\"type\": \"nGram\",\n\"minGram\": 2,\n\"maxGram\": 5\n},\n\"tokenFilters\": [{\n\"type\": \"length\",\n\"min\": 20,\n\"max\": 33\n}]\n}]\nEOF\n```\n"
                },
                "clusterName": {
                    "type": "string",
                    "description": "The name of the cluster where you want to create the search index within.\n",
                    "willReplaceOnChanges": true
                },
                "collectionName": {
                    "type": "string",
                    "description": "Name of the collection the index is on.\n"
                },
                "database": {
                    "type": "string",
                    "description": "Name of the database the collection is in.\n"
                },
                "fields": {
                    "type": "string",
                    "description": "Array of [Fields](https://www.mongodb.com/docs/atlas/atlas-search/field-types/knn-vector/#std-label-fts-data-types-knn-vector) to configure this `vectorSearch` index. It is mandatory for vector searches and it must contain at least one `vector` type field. This field needs to be a JSON string in order to be decoded correctly.\n"
                },
                "mappingsDynamic": {
                    "type": "boolean",
                    "description": "Indicates whether the search index uses dynamic or static mapping. For dynamic mapping, set the value to `true`. For static mapping, specify the fields to index using `mappings_fields`\n"
                },
                "mappingsFields": {
                    "type": "string",
                    "description": "attribute is required in search indexes when `mappings_dynamic` is false. This field needs to be a JSON string in order to be decoded correctly.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the search index you want to create.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The ID of the organization or project you want to create the search index within.\n",
                    "willReplaceOnChanges": true
                },
                "searchAnalyzer": {
                    "type": "string",
                    "description": "[Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when searching the index. Defaults to [lucene.standard](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/standard/#std-label-ref-standard-analyzer)\n"
                },
                "storedSource": {
                    "type": "string",
                    "description": "String that can be \"true\" (store all fields), \"false\" (default, don't store any field), or a JSON string that contains the list of fields to store (include) or not store (exclude) on Atlas Search. To learn more, see [Stored Source Fields](https://www.mongodb.com/docs/atlas/atlas-search/stored-source-definition/).\n"
                },
                "synonyms": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/SearchIndexSynonym:SearchIndexSynonym"
                    },
                    "description": "Synonyms mapping definition to use in this index.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of index: `search` or `vectorSearch`. Default type is `search`.\n"
                },
                "waitForIndexBuildCompletion": {
                    "type": "boolean"
                }
            },
            "requiredInputs": [
                "clusterName",
                "collectionName",
                "database",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SearchIndex resources.\n",
                "properties": {
                    "analyzer": {
                        "type": "string",
                        "description": "[Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index. Defaults to [lucene.standard](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/standard/#std-label-ref-standard-analyzer)\n"
                    },
                    "analyzers": {
                        "type": "string",
                        "description": "[Custom analyzers](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-custom-analyzers) to use in this index. This is an array of JSON objects.\n```\nanalyzers = \u003c\u003c-EOF\n[{\n\"name\": \"index_analyzer_test_name\",\n\"charFilters\": [{\n\"type\": \"mapping\",\n\"mappings\": {\"\\\\\" : \"/\"}\n}],\n\"tokenizer\": {\n\"type\": \"nGram\",\n\"minGram\": 2,\n\"maxGram\": 5\n},\n\"tokenFilters\": [{\n\"type\": \"length\",\n\"min\": 20,\n\"max\": 33\n}]\n}]\nEOF\n```\n"
                    },
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the cluster where you want to create the search index within.\n",
                        "willReplaceOnChanges": true
                    },
                    "collectionName": {
                        "type": "string",
                        "description": "Name of the collection the index is on.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "Name of the database the collection is in.\n"
                    },
                    "fields": {
                        "type": "string",
                        "description": "Array of [Fields](https://www.mongodb.com/docs/atlas/atlas-search/field-types/knn-vector/#std-label-fts-data-types-knn-vector) to configure this `vectorSearch` index. It is mandatory for vector searches and it must contain at least one `vector` type field. This field needs to be a JSON string in order to be decoded correctly.\n"
                    },
                    "indexId": {
                        "type": "string",
                        "description": "The unique identifier of the Atlas Search index.\n"
                    },
                    "mappingsDynamic": {
                        "type": "boolean",
                        "description": "Indicates whether the search index uses dynamic or static mapping. For dynamic mapping, set the value to `true`. For static mapping, specify the fields to index using `mappings_fields`\n"
                    },
                    "mappingsFields": {
                        "type": "string",
                        "description": "attribute is required in search indexes when `mappings_dynamic` is false. This field needs to be a JSON string in order to be decoded correctly.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the search index you want to create.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The ID of the organization or project you want to create the search index within.\n",
                        "willReplaceOnChanges": true
                    },
                    "searchAnalyzer": {
                        "type": "string",
                        "description": "[Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when searching the index. Defaults to [lucene.standard](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/standard/#std-label-ref-standard-analyzer)\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Current status of the index.\n"
                    },
                    "storedSource": {
                        "type": "string",
                        "description": "String that can be \"true\" (store all fields), \"false\" (default, don't store any field), or a JSON string that contains the list of fields to store (include) or not store (exclude) on Atlas Search. To learn more, see [Stored Source Fields](https://www.mongodb.com/docs/atlas/atlas-search/stored-source-definition/).\n"
                    },
                    "synonyms": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/SearchIndexSynonym:SearchIndexSynonym"
                        },
                        "description": "Synonyms mapping definition to use in this index.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of index: `search` or `vectorSearch`. Default type is `search`.\n"
                    },
                    "waitForIndexBuildCompletion": {
                        "type": "boolean"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/serverlessInstance:ServerlessInstance": {
            "description": "## # Resource: mongodbatlas.ServerlessInstance\n\n`mongodbatlas.ServerlessInstance` provides a Serverless Instance resource. This allows serverless instances to be created.\n\n\u003e **NOTE:**  Serverless instances do not support some Atlas features at this time.\nFor a full list of unsupported features, see [Serverless Instance Limitations](https://docs.atlas.mongodb.com/reference/serverless-instance-limitations/).\n\n## Example Usage\n\n### Basic\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.ServerlessInstance(\"test\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    name: \"\u003cSERVERLESS_INSTANCE_NAME\u003e\",\n    providerSettingsBackingProviderName: \"AWS\",\n    providerSettingsProviderName: \"SERVERLESS\",\n    providerSettingsRegionName: \"US_EAST_1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.ServerlessInstance(\"test\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    name=\"\u003cSERVERLESS_INSTANCE_NAME\u003e\",\n    provider_settings_backing_provider_name=\"AWS\",\n    provider_settings_provider_name=\"SERVERLESS\",\n    provider_settings_region_name=\"US_EAST_1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.ServerlessInstance(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        Name = \"\u003cSERVERLESS_INSTANCE_NAME\u003e\",\n        ProviderSettingsBackingProviderName = \"AWS\",\n        ProviderSettingsProviderName = \"SERVERLESS\",\n        ProviderSettingsRegionName = \"US_EAST_1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewServerlessInstance(ctx, \"test\", \u0026mongodbatlas.ServerlessInstanceArgs{\n\t\t\tProjectId:                           pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tName:                                pulumi.String(\"\u003cSERVERLESS_INSTANCE_NAME\u003e\"),\n\t\t\tProviderSettingsBackingProviderName: pulumi.String(\"AWS\"),\n\t\t\tProviderSettingsProviderName:        pulumi.String(\"SERVERLESS\"),\n\t\t\tProviderSettingsRegionName:          pulumi.String(\"US_EAST_1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ServerlessInstance;\nimport com.pulumi.mongodbatlas.ServerlessInstanceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new ServerlessInstance(\"test\", ServerlessInstanceArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .name(\"\u003cSERVERLESS_INSTANCE_NAME\u003e\")\n            .providerSettingsBackingProviderName(\"AWS\")\n            .providerSettingsProviderName(\"SERVERLESS\")\n            .providerSettingsRegionName(\"US_EAST_1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:ServerlessInstance\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      name: \u003cSERVERLESS_INSTANCE_NAME\u003e\n      providerSettingsBackingProviderName: AWS\n      providerSettingsProviderName: SERVERLESS\n      providerSettingsRegionName: US_EAST_1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n**NOTE:**  `mongodbatlas.ServerlessInstance` and `mongodbatlas.PrivatelinkEndpointServiceServerless` resources have a circular dependency in some respects.\\\nThat is, the `serverless_instance` must exist before the `privatelink_endpoint_service` can be created,\\\nand the `privatelink_endpoint_service` must exist before the `serverless_instance` gets its respective `connection_strings_private_endpoint_srv` values.\n\nBecause of this, the `serverless_instance` data source has particular value as a source of the `connection_strings_private_endpoint_srv`.\\\nWhen using the data_source in-tandem with the afforementioned resources, we can create and retrieve the `connection_strings_private_endpoint_srv` in a single `pulumi up`.\n\nFollow this example to setup private connection to a serverless instance using aws vpc and get the connection strings in a single `pulumi up`\n\n## Import\n\nServerless Instance can be imported using the group ID and serverless instance name, in the format `GROUP_ID-SERVERLESS_INSTANCE_NAME`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/serverlessInstance:ServerlessInstance my_serverless_instance 1112222b3bf99403840e8934-My Serverless Instance\n```\n\nFor more information see: [MongoDB Atlas API - Serverless Instance](https://docs.atlas.mongodb.com/reference/api/serverless-instances/) Documentation.\n\n",
            "properties": {
                "autoIndexing": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the serverless instance uses [Serverless Auto Indexing](https://www.mongodb.com/docs/atlas/performance-advisor/auto-index-serverless/). This parameter defaults to true.\n"
                },
                "connectionStringsPrivateEndpointSrvs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of Serverless Private Endpoint Connections\n"
                },
                "connectionStringsStandardSrv": {
                    "type": "string",
                    "description": "Public `mongodb+srv://` connection string that you can use to connect to this serverless instance.\n"
                },
                "continuousBackupEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the serverless instance uses [Serverless Continuous Backup](https://www.mongodb.com/docs/atlas/configure-serverless-backup). If this parameter is false or not used, the serverless instance uses [Basic Backup](https://www.mongodb.com/docs/atlas/configure-serverless-backup).\n"
                },
                "createDate": {
                    "type": "string",
                    "description": "Timestamp that indicates when MongoDB Cloud created the serverless instance. The timestamp displays in the ISO 8601 date and time format in UTC.\n"
                },
                "links": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ServerlessInstanceLink:ServerlessInstanceLink"
                    }
                },
                "mongoDbVersion": {
                    "type": "string",
                    "description": "Version of MongoDB that the serverless instance runs, in `\u003cmajor version\u003e`.`\u003cminor version\u003e` format.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable label that identifies the serverless instance.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The ID of the organization or project you want to create the serverless instance within.\n"
                },
                "providerSettingsBackingProviderName": {
                    "type": "string",
                    "description": "Cloud service provider on which MongoDB Cloud provisioned the serverless instance.\n"
                },
                "providerSettingsProviderName": {
                    "type": "string",
                    "description": "Cloud service provider that applies to the provisioned the serverless instance.\n"
                },
                "providerSettingsRegionName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the physical location of your MongoDB serverless instance. The region you choose can affect network latency for clients accessing your databases.\n"
                },
                "stateName": {
                    "type": "string",
                    "description": "Stage of deployment of this serverless instance when the resource made its request.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ServerlessInstanceTag:ServerlessInstanceTag"
                    },
                    "description": "Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.\n"
                },
                "terminationProtectionEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n"
                }
            },
            "required": [
                "autoIndexing",
                "connectionStringsPrivateEndpointSrvs",
                "connectionStringsStandardSrv",
                "continuousBackupEnabled",
                "createDate",
                "links",
                "mongoDbVersion",
                "name",
                "projectId",
                "providerSettingsBackingProviderName",
                "providerSettingsProviderName",
                "providerSettingsRegionName",
                "stateName",
                "terminationProtectionEnabled"
            ],
            "inputProperties": {
                "autoIndexing": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the serverless instance uses [Serverless Auto Indexing](https://www.mongodb.com/docs/atlas/performance-advisor/auto-index-serverless/). This parameter defaults to true.\n"
                },
                "continuousBackupEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether the serverless instance uses [Serverless Continuous Backup](https://www.mongodb.com/docs/atlas/configure-serverless-backup). If this parameter is false or not used, the serverless instance uses [Basic Backup](https://www.mongodb.com/docs/atlas/configure-serverless-backup).\n"
                },
                "links": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ServerlessInstanceLink:ServerlessInstanceLink"
                    }
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable label that identifies the serverless instance.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "The ID of the organization or project you want to create the serverless instance within.\n"
                },
                "providerSettingsBackingProviderName": {
                    "type": "string",
                    "description": "Cloud service provider on which MongoDB Cloud provisioned the serverless instance.\n"
                },
                "providerSettingsProviderName": {
                    "type": "string",
                    "description": "Cloud service provider that applies to the provisioned the serverless instance.\n"
                },
                "providerSettingsRegionName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the physical location of your MongoDB serverless instance. The region you choose can affect network latency for clients accessing your databases.\n"
                },
                "stateName": {
                    "type": "string",
                    "description": "Stage of deployment of this serverless instance when the resource made its request.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/ServerlessInstanceTag:ServerlessInstanceTag"
                    },
                    "description": "Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.\n"
                },
                "terminationProtectionEnabled": {
                    "type": "boolean",
                    "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n"
                }
            },
            "requiredInputs": [
                "projectId",
                "providerSettingsBackingProviderName",
                "providerSettingsProviderName",
                "providerSettingsRegionName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ServerlessInstance resources.\n",
                "properties": {
                    "autoIndexing": {
                        "type": "boolean",
                        "description": "Flag that indicates whether the serverless instance uses [Serverless Auto Indexing](https://www.mongodb.com/docs/atlas/performance-advisor/auto-index-serverless/). This parameter defaults to true.\n"
                    },
                    "connectionStringsPrivateEndpointSrvs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of Serverless Private Endpoint Connections\n"
                    },
                    "connectionStringsStandardSrv": {
                        "type": "string",
                        "description": "Public `mongodb+srv://` connection string that you can use to connect to this serverless instance.\n"
                    },
                    "continuousBackupEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether the serverless instance uses [Serverless Continuous Backup](https://www.mongodb.com/docs/atlas/configure-serverless-backup). If this parameter is false or not used, the serverless instance uses [Basic Backup](https://www.mongodb.com/docs/atlas/configure-serverless-backup).\n"
                    },
                    "createDate": {
                        "type": "string",
                        "description": "Timestamp that indicates when MongoDB Cloud created the serverless instance. The timestamp displays in the ISO 8601 date and time format in UTC.\n"
                    },
                    "links": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/ServerlessInstanceLink:ServerlessInstanceLink"
                        }
                    },
                    "mongoDbVersion": {
                        "type": "string",
                        "description": "Version of MongoDB that the serverless instance runs, in `\u003cmajor version\u003e`.`\u003cminor version\u003e` format.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Human-readable label that identifies the serverless instance.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The ID of the organization or project you want to create the serverless instance within.\n"
                    },
                    "providerSettingsBackingProviderName": {
                        "type": "string",
                        "description": "Cloud service provider on which MongoDB Cloud provisioned the serverless instance.\n"
                    },
                    "providerSettingsProviderName": {
                        "type": "string",
                        "description": "Cloud service provider that applies to the provisioned the serverless instance.\n"
                    },
                    "providerSettingsRegionName": {
                        "type": "string",
                        "description": "Human-readable label that identifies the physical location of your MongoDB serverless instance. The region you choose can affect network latency for clients accessing your databases.\n"
                    },
                    "stateName": {
                        "type": "string",
                        "description": "Stage of deployment of this serverless instance when the resource made its request.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/ServerlessInstanceTag:ServerlessInstanceTag"
                        },
                        "description": "Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.\n"
                    },
                    "terminationProtectionEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/streamConnection:StreamConnection": {
            "description": "## # Resource: mongodbatlas.StreamConnection\n\n`mongodbatlas.StreamConnection` provides a Stream Connection resource. The resource lets you create, edit, and delete stream instance connections.\n\n\u003e **IMPORTANT:** All arguments including the Kafka authentication password will be stored in the raw state as plaintext. Read more about sensitive data in state.\n\n\n## Example Usage\n\n### Example Cluster Connection\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.StreamConnection(\"test\", {\n    projectId: projectId,\n    instanceName: \"InstanceName\",\n    connectionName: \"ConnectionName\",\n    type: \"Cluster\",\n    clusterName: \"Cluster0\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.StreamConnection(\"test\",\n    project_id=project_id,\n    instance_name=\"InstanceName\",\n    connection_name=\"ConnectionName\",\n    type=\"Cluster\",\n    cluster_name=\"Cluster0\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.StreamConnection(\"test\", new()\n    {\n        ProjectId = projectId,\n        InstanceName = \"InstanceName\",\n        ConnectionName = \"ConnectionName\",\n        Type = \"Cluster\",\n        ClusterName = \"Cluster0\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewStreamConnection(ctx, \"test\", \u0026mongodbatlas.StreamConnectionArgs{\n\t\t\tProjectId:      pulumi.Any(projectId),\n\t\t\tInstanceName:   pulumi.String(\"InstanceName\"),\n\t\t\tConnectionName: pulumi.String(\"ConnectionName\"),\n\t\t\tType:           pulumi.String(\"Cluster\"),\n\t\t\tClusterName:    pulumi.String(\"Cluster0\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.StreamConnection;\nimport com.pulumi.mongodbatlas.StreamConnectionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new StreamConnection(\"test\", StreamConnectionArgs.builder()\n            .projectId(projectId)\n            .instanceName(\"InstanceName\")\n            .connectionName(\"ConnectionName\")\n            .type(\"Cluster\")\n            .clusterName(\"Cluster0\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:StreamConnection\n    properties:\n      projectId: ${projectId}\n      instanceName: InstanceName\n      connectionName: ConnectionName\n      type: Cluster\n      clusterName: Cluster0\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example Kafka Plaintext Connection\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.StreamConnection(\"test\", {\n    projectId: projectId,\n    instanceName: \"NewInstance\",\n    connectionName: \"KafkaConnection\",\n    type: \"Kafka\",\n    authentication: {\n        mechanism: \"SCRAM-256\",\n        username: \"user\",\n        password: \"somepassword\",\n    },\n    security: {\n        protocol: \"PLAINTEXT\",\n    },\n    config: {\n        \"auto.offset.reset\": \"latest\",\n    },\n    bootstrapServers: \"localhost:9091,localhost:9092\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.StreamConnection(\"test\",\n    project_id=project_id,\n    instance_name=\"NewInstance\",\n    connection_name=\"KafkaConnection\",\n    type=\"Kafka\",\n    authentication={\n        \"mechanism\": \"SCRAM-256\",\n        \"username\": \"user\",\n        \"password\": \"somepassword\",\n    },\n    security={\n        \"protocol\": \"PLAINTEXT\",\n    },\n    config={\n        \"auto.offset.reset\": \"latest\",\n    },\n    bootstrap_servers=\"localhost:9091,localhost:9092\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.StreamConnection(\"test\", new()\n    {\n        ProjectId = projectId,\n        InstanceName = \"NewInstance\",\n        ConnectionName = \"KafkaConnection\",\n        Type = \"Kafka\",\n        Authentication = new Mongodbatlas.Inputs.StreamConnectionAuthenticationArgs\n        {\n            Mechanism = \"SCRAM-256\",\n            Username = \"user\",\n            Password = \"somepassword\",\n        },\n        Security = new Mongodbatlas.Inputs.StreamConnectionSecurityArgs\n        {\n            Protocol = \"PLAINTEXT\",\n        },\n        Config = \n        {\n            { \"auto.offset.reset\", \"latest\" },\n        },\n        BootstrapServers = \"localhost:9091,localhost:9092\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewStreamConnection(ctx, \"test\", \u0026mongodbatlas.StreamConnectionArgs{\n\t\t\tProjectId:      pulumi.Any(projectId),\n\t\t\tInstanceName:   pulumi.String(\"NewInstance\"),\n\t\t\tConnectionName: pulumi.String(\"KafkaConnection\"),\n\t\t\tType:           pulumi.String(\"Kafka\"),\n\t\t\tAuthentication: \u0026mongodbatlas.StreamConnectionAuthenticationArgs{\n\t\t\t\tMechanism: pulumi.String(\"SCRAM-256\"),\n\t\t\t\tUsername:  pulumi.String(\"user\"),\n\t\t\t\tPassword:  pulumi.String(\"somepassword\"),\n\t\t\t},\n\t\t\tSecurity: \u0026mongodbatlas.StreamConnectionSecurityArgs{\n\t\t\t\tProtocol: pulumi.String(\"PLAINTEXT\"),\n\t\t\t},\n\t\t\tConfig: pulumi.StringMap{\n\t\t\t\t\"auto.offset.reset\": pulumi.String(\"latest\"),\n\t\t\t},\n\t\t\tBootstrapServers: pulumi.String(\"localhost:9091,localhost:9092\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.StreamConnection;\nimport com.pulumi.mongodbatlas.StreamConnectionArgs;\nimport com.pulumi.mongodbatlas.inputs.StreamConnectionAuthenticationArgs;\nimport com.pulumi.mongodbatlas.inputs.StreamConnectionSecurityArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new StreamConnection(\"test\", StreamConnectionArgs.builder()\n            .projectId(projectId)\n            .instanceName(\"NewInstance\")\n            .connectionName(\"KafkaConnection\")\n            .type(\"Kafka\")\n            .authentication(StreamConnectionAuthenticationArgs.builder()\n                .mechanism(\"SCRAM-256\")\n                .username(\"user\")\n                .password(\"somepassword\")\n                .build())\n            .security(StreamConnectionSecurityArgs.builder()\n                .protocol(\"PLAINTEXT\")\n                .build())\n            .config(Map.of(\"auto.offset.reset\", \"latest\"))\n            .bootstrapServers(\"localhost:9091,localhost:9092\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:StreamConnection\n    properties:\n      projectId: ${projectId}\n      instanceName: NewInstance\n      connectionName: KafkaConnection\n      type: Kafka\n      authentication:\n        mechanism: SCRAM-256\n        username: user\n        password: somepassword\n      security:\n        protocol: PLAINTEXT\n      config:\n        auto.offset.reset: latest\n      bootstrapServers: localhost:9091,localhost:9092\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example Kafka SSL Connection\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.StreamConnection;\nimport com.pulumi.mongodbatlas.StreamConnectionArgs;\nimport com.pulumi.mongodbatlas.inputs.StreamConnectionAuthenticationArgs;\nimport com.pulumi.mongodbatlas.inputs.StreamConnectionSecurityArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new StreamConnection(\"test\", StreamConnectionArgs.builder()\n            .projectId(projectId)\n            .instanceName(\"NewInstance\")\n            .connectionName(\"KafkaConnection\")\n            .type(\"Kafka\")\n            .authentication(StreamConnectionAuthenticationArgs.builder()\n                .mechanism(\"PLAIN\")\n                .username(\"user\")\n                .password(\"somepassword\")\n                .build())\n            .security(StreamConnectionSecurityArgs.builder()\n                .protocol(\"SSL\")\n                .broker_public_certificate(\"-----BEGIN CERTIFICATE-----\u003cCONTENT\u003e-----END CERTIFICATE-----\")\n                .build())\n            .config(Map.of(\"auto.offset.reset\", \"latest\"))\n            .bootstrapServers(\"localhost:9091,localhost:9092\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:StreamConnection\n    properties:\n      projectId: ${projectId}\n      instanceName: NewInstance\n      connectionName: KafkaConnection\n      type: Kafka\n      authentication:\n        mechanism: PLAIN\n        username: user\n        password: somepassword\n      security:\n        protocol: SSL\n        broker_public_certificate: '-----BEGIN CERTIFICATE-----\u003cCONTENT\u003e-----END CERTIFICATE-----'\n      config:\n        auto.offset.reset: latest\n      bootstrapServers: localhost:9091,localhost:9092\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nYou can import a stream connection resource using the instance name, project ID, and connection name. The format must be `INSTANCE_NAME-PROJECT_ID-CONNECTION_NAME`. For example:\n\n```sh\n$ pulumi import mongodbatlas:index/streamConnection:StreamConnection test \"DefaultInstance-12251446ae5f3f6ec7968b13-NewConnection\"\n```\nTo learn more, see: [MongoDB Atlas API - Stream Connection](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamConnection) Documentation.\nThe Terraform Provider Examples Section also contains details on the overall support for Atlas Streams Processing in Terraform.\n\n",
            "properties": {
                "authentication": {
                    "$ref": "#/types/mongodbatlas:index/StreamConnectionAuthentication:StreamConnectionAuthentication"
                },
                "bootstrapServers": {
                    "type": "string"
                },
                "clusterName": {
                    "type": "string"
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "connectionName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the stream connection. In the case of the Sample type, this is the name of the sample source.\n"
                },
                "dbRoleToExecute": {
                    "$ref": "#/types/mongodbatlas:index/StreamConnectionDbRoleToExecute:StreamConnectionDbRoleToExecute"
                },
                "instanceName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the stream instance.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies your project.\n"
                },
                "security": {
                    "$ref": "#/types/mongodbatlas:index/StreamConnectionSecurity:StreamConnectionSecurity"
                },
                "type": {
                    "type": "string",
                    "description": "Type of connection. Can be either `Cluster`, `Kafka` or `Sample`.\n"
                }
            },
            "required": [
                "connectionName",
                "instanceName",
                "projectId",
                "type"
            ],
            "inputProperties": {
                "authentication": {
                    "$ref": "#/types/mongodbatlas:index/StreamConnectionAuthentication:StreamConnectionAuthentication"
                },
                "bootstrapServers": {
                    "type": "string"
                },
                "clusterName": {
                    "type": "string"
                },
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "connectionName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the stream connection. In the case of the Sample type, this is the name of the sample source.\n"
                },
                "dbRoleToExecute": {
                    "$ref": "#/types/mongodbatlas:index/StreamConnectionDbRoleToExecute:StreamConnectionDbRoleToExecute"
                },
                "instanceName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the stream instance.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies your project.\n"
                },
                "security": {
                    "$ref": "#/types/mongodbatlas:index/StreamConnectionSecurity:StreamConnectionSecurity"
                },
                "type": {
                    "type": "string",
                    "description": "Type of connection. Can be either `Cluster`, `Kafka` or `Sample`.\n"
                }
            },
            "requiredInputs": [
                "connectionName",
                "instanceName",
                "projectId",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering StreamConnection resources.\n",
                "properties": {
                    "authentication": {
                        "$ref": "#/types/mongodbatlas:index/StreamConnectionAuthentication:StreamConnectionAuthentication"
                    },
                    "bootstrapServers": {
                        "type": "string"
                    },
                    "clusterName": {
                        "type": "string"
                    },
                    "config": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    },
                    "connectionName": {
                        "type": "string",
                        "description": "Human-readable label that identifies the stream connection. In the case of the Sample type, this is the name of the sample source.\n"
                    },
                    "dbRoleToExecute": {
                        "$ref": "#/types/mongodbatlas:index/StreamConnectionDbRoleToExecute:StreamConnectionDbRoleToExecute"
                    },
                    "instanceName": {
                        "type": "string",
                        "description": "Human-readable label that identifies the stream instance.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies your project.\n"
                    },
                    "security": {
                        "$ref": "#/types/mongodbatlas:index/StreamConnectionSecurity:StreamConnectionSecurity"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of connection. Can be either `Cluster`, `Kafka` or `Sample`.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/streamInstance:StreamInstance": {
            "description": "## # Resource: mongodbatlas.StreamInstance\n\n`mongodbatlas.StreamInstance` provides a Stream Instance resource. The resource lets you create, edit, and delete stream instances in a project.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.StreamInstance;\nimport com.pulumi.mongodbatlas.StreamInstanceArgs;\nimport com.pulumi.mongodbatlas.inputs.StreamInstanceDataProcessRegionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new StreamInstance(\"test\", StreamInstanceArgs.builder()\n            .projectId(projectId)\n            .instanceName(\"InstanceName\")\n            .dataProcessRegion(StreamInstanceDataProcessRegionArgs.builder()\n                .region(\"VIRGINIA_USA\")\n                .cloud_provider(\"AWS\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:StreamInstance\n    properties:\n      projectId: ${projectId}\n      instanceName: InstanceName\n      dataProcessRegion:\n        region: VIRGINIA_USA\n        cloud_provider: AWS\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nYou can import stream instance resource using the project ID and instance name, in the format `PROJECT_ID-INSTANCE_NAME`. For example:\n\n```sh\n$ pulumi import mongodbatlas:index/streamInstance:StreamInstance test 650972848269185c55f40ca1-InstanceName\n```\nTo learn more, see: [MongoDB Atlas API - Stream Instance](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) Documentation.\nThe Terraform Provider Examples Section also contains details on the overall support for Atlas Streams Processing in Terraform.\n\n",
            "properties": {
                "dataProcessRegion": {
                    "$ref": "#/types/mongodbatlas:index/StreamInstanceDataProcessRegion:StreamInstanceDataProcessRegion",
                    "description": "Cloud service provider and region where MongoDB Cloud performs stream processing. See data process region.\n"
                },
                "hostnames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List that contains the hostnames assigned to the stream instance.\n"
                },
                "instanceName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the stream instance.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies your project.\n"
                },
                "streamConfig": {
                    "$ref": "#/types/mongodbatlas:index/StreamInstanceStreamConfig:StreamInstanceStreamConfig",
                    "description": "Configuration options for an Atlas Stream Processing Instance. See stream config\n"
                }
            },
            "required": [
                "dataProcessRegion",
                "hostnames",
                "instanceName",
                "projectId",
                "streamConfig"
            ],
            "inputProperties": {
                "dataProcessRegion": {
                    "$ref": "#/types/mongodbatlas:index/StreamInstanceDataProcessRegion:StreamInstanceDataProcessRegion",
                    "description": "Cloud service provider and region where MongoDB Cloud performs stream processing. See data process region.\n"
                },
                "instanceName": {
                    "type": "string",
                    "description": "Human-readable label that identifies the stream instance.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Unique 24-hexadecimal digit string that identifies your project.\n"
                },
                "streamConfig": {
                    "$ref": "#/types/mongodbatlas:index/StreamInstanceStreamConfig:StreamInstanceStreamConfig",
                    "description": "Configuration options for an Atlas Stream Processing Instance. See stream config\n"
                }
            },
            "requiredInputs": [
                "dataProcessRegion",
                "instanceName",
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering StreamInstance resources.\n",
                "properties": {
                    "dataProcessRegion": {
                        "$ref": "#/types/mongodbatlas:index/StreamInstanceDataProcessRegion:StreamInstanceDataProcessRegion",
                        "description": "Cloud service provider and region where MongoDB Cloud performs stream processing. See data process region.\n"
                    },
                    "hostnames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List that contains the hostnames assigned to the stream instance.\n"
                    },
                    "instanceName": {
                        "type": "string",
                        "description": "Human-readable label that identifies the stream instance.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies your project.\n"
                    },
                    "streamConfig": {
                        "$ref": "#/types/mongodbatlas:index/StreamInstanceStreamConfig:StreamInstanceStreamConfig",
                        "description": "Configuration options for an Atlas Stream Processing Instance. See stream config\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/team:Team": {
            "description": "## # Resource: mongodbatlas.Team\n\n`mongodbatlas.Team` provides a Team resource. The resource lets you create, edit and delete Teams. Also, Teams can be assigned to multiple projects, and team membersâ access to the project is determined by the teamâs project role.\n\n\u003e **IMPORTANT:** MongoDB Atlas Team are limited to a maximum of 250 teams in an organization and 100 teams per project.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.Team(\"test\", {\n    orgId: \"\u003cORGANIZATION-ID\u003e\",\n    name: \"myNewTeam\",\n    usernames: [\n        \"user1@email.com\",\n        \"user2@email.com\",\n        \"user3@email.com\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.Team(\"test\",\n    org_id=\"\u003cORGANIZATION-ID\u003e\",\n    name=\"myNewTeam\",\n    usernames=[\n        \"user1@email.com\",\n        \"user2@email.com\",\n        \"user3@email.com\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.Team(\"test\", new()\n    {\n        OrgId = \"\u003cORGANIZATION-ID\u003e\",\n        Name = \"myNewTeam\",\n        Usernames = new[]\n        {\n            \"user1@email.com\",\n            \"user2@email.com\",\n            \"user3@email.com\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewTeam(ctx, \"test\", \u0026mongodbatlas.TeamArgs{\n\t\t\tOrgId: pulumi.String(\"\u003cORGANIZATION-ID\u003e\"),\n\t\t\tName:  pulumi.String(\"myNewTeam\"),\n\t\t\tUsernames: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"user1@email.com\"),\n\t\t\t\tpulumi.String(\"user2@email.com\"),\n\t\t\t\tpulumi.String(\"user3@email.com\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Team;\nimport com.pulumi.mongodbatlas.TeamArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new Team(\"test\", TeamArgs.builder()\n            .orgId(\"\u003cORGANIZATION-ID\u003e\")\n            .name(\"myNewTeam\")\n            .usernames(            \n                \"user1@email.com\",\n                \"user2@email.com\",\n                \"user3@email.com\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:Team\n    properties:\n      orgId: \u003cORGANIZATION-ID\u003e\n      name: myNewTeam\n      usernames:\n        - user1@email.com\n        - user2@email.com\n        - user3@email.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nTeams can be imported using the organization ID and team id, in the format ORGID-TEAMID, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/team:Team my_team 1112222b3bf99403840e8934-1112222b3bf99403840e8935\n```\nSee detailed information for arguments and attributes: [MongoDB API Teams](https://docs.atlas.mongodb.com/reference/api/teams-create-one/)\n\n",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the team you want to create.\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "The unique identifier for the organization you want to associate the team with.\n"
                },
                "teamId": {
                    "type": "string",
                    "description": "The unique identifier for the team.\n"
                },
                "usernames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The Atlas usernames (email address). You can only add Atlas users who are part of the organization. Users who have not accepted an invitation to join the organization cannot be added as team members. There is a maximum of 250 Atlas users per team.\n"
                }
            },
            "required": [
                "name",
                "orgId",
                "teamId",
                "usernames"
            ],
            "inputProperties": {
                "name": {
                    "type": "string",
                    "description": "The name of the team you want to create.\n"
                },
                "orgId": {
                    "type": "string",
                    "description": "The unique identifier for the organization you want to associate the team with.\n",
                    "willReplaceOnChanges": true
                },
                "usernames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The Atlas usernames (email address). You can only add Atlas users who are part of the organization. Users who have not accepted an invitation to join the organization cannot be added as team members. There is a maximum of 250 Atlas users per team.\n"
                }
            },
            "requiredInputs": [
                "orgId",
                "usernames"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Team resources.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the team you want to create.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "The unique identifier for the organization you want to associate the team with.\n",
                        "willReplaceOnChanges": true
                    },
                    "teamId": {
                        "type": "string",
                        "description": "The unique identifier for the team.\n"
                    },
                    "usernames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The Atlas usernames (email address). You can only add Atlas users who are part of the organization. Users who have not accepted an invitation to join the organization cannot be added as team members. There is a maximum of 250 Atlas users per team.\n"
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/teams:Teams": {
            "description": "**WARNING:** This resource is deprecated, use `mongodbatlas.Team`\n\nThis resource is deprecated. Please transition to using `mongodbatlas.Team` which defines the same underlying implementation, aligning the name of the resource with the implementation which manages a single team.\n",
            "properties": {
                "name": {
                    "type": "string"
                },
                "orgId": {
                    "type": "string"
                },
                "teamId": {
                    "type": "string"
                },
                "usernames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "name",
                "orgId",
                "teamId",
                "usernames"
            ],
            "inputProperties": {
                "name": {
                    "type": "string"
                },
                "orgId": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "usernames": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "requiredInputs": [
                "orgId",
                "usernames"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Teams resources.\n",
                "properties": {
                    "name": {
                        "type": "string"
                    },
                    "orgId": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "teamId": {
                        "type": "string"
                    },
                    "usernames": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/thirdPartyIntegration:ThirdPartyIntegration": {
            "description": "## # Resource: mongodbatlas.ThirdPartyIntegration\n\n`mongodbatlas.ThirdPartyIntegration` Provides a Third-Party Integration Settings for the given type.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n\u003e **NOTE:** Slack integrations now use the OAuth2 verification method and must be initially configured, or updated from a legacy integration, through the Atlas third-party service integrations page. Legacy tokens will soon no longer be supported.[Read more about slack setup](https://docs.atlas.mongodb.com/tutorial/third-party-service-integrations/)\n\n\u003e **IMPORTANT** Each project can only have one configuration per {INTEGRATION-TYPE}.\n\n\u003e **IMPORTANT:** All arguments including the secrets will be stored in the raw state as plain-text. Read more about sensitive data in state.\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testDatadog = new mongodbatlas.ThirdPartyIntegration(\"test_datadog\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    type: \"DATADOG\",\n    apiKey: \"\u003cAPI-KEY\u003e\",\n    region: \"\u003cREGION\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_datadog = mongodbatlas.ThirdPartyIntegration(\"test_datadog\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    type=\"DATADOG\",\n    api_key=\"\u003cAPI-KEY\u003e\",\n    region=\"\u003cREGION\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testDatadog = new Mongodbatlas.ThirdPartyIntegration(\"test_datadog\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        Type = \"DATADOG\",\n        ApiKey = \"\u003cAPI-KEY\u003e\",\n        Region = \"\u003cREGION\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewThirdPartyIntegration(ctx, \"test_datadog\", \u0026mongodbatlas.ThirdPartyIntegrationArgs{\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tType:      pulumi.String(\"DATADOG\"),\n\t\t\tApiKey:    pulumi.String(\"\u003cAPI-KEY\u003e\"),\n\t\t\tRegion:    pulumi.String(\"\u003cREGION\u003e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ThirdPartyIntegration;\nimport com.pulumi.mongodbatlas.ThirdPartyIntegrationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testDatadog = new ThirdPartyIntegration(\"testDatadog\", ThirdPartyIntegrationArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .type(\"DATADOG\")\n            .apiKey(\"\u003cAPI-KEY\u003e\")\n            .region(\"\u003cREGION\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testDatadog:\n    type: mongodbatlas:ThirdPartyIntegration\n    name: test_datadog\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      type: DATADOG\n      apiKey: \u003cAPI-KEY\u003e\n      region: \u003cREGION\u003e\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nThird-Party Integration Settings can be imported using project ID and the integration type, in the format `project_id`-`type`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/thirdPartyIntegration:ThirdPartyIntegration test_datadog 1112222b3bf99403840e8934-DATADOG\n```\nSee [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Third-Party-Integrations/operation/createThirdPartyIntegration) Documentation for more information.\n\n",
            "properties": {
                "apiKey": {
                    "type": "string",
                    "secret": true
                },
                "channelName": {
                    "type": "string"
                },
                "enabled": {
                    "type": "boolean"
                },
                "microsoftTeamsWebhookUrl": {
                    "type": "string",
                    "secret": true
                },
                "password": {
                    "type": "string",
                    "secret": true
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to get all Third-Party service integrations\n"
                },
                "region": {
                    "type": "string"
                },
                "routingKey": {
                    "type": "string",
                    "secret": true
                },
                "secret": {
                    "type": "string",
                    "secret": true
                },
                "serviceDiscovery": {
                    "type": "string",
                    "secret": true
                },
                "serviceKey": {
                    "type": "string",
                    "secret": true
                },
                "teamName": {
                    "type": "string"
                },
                "type": {
                    "type": "string",
                    "description": "Third-Party Integration Settings type \n* PAGER_DUTY\n* DATADOG\n* OPS_GENIE\n* VICTOR_OPS\n* WEBHOOK\n* MICROSOFT_TEAMS\n* PROMETHEUS\n\n\n* `PAGER_DUTY`\n"
                },
                "url": {
                    "type": "string"
                },
                "userName": {
                    "type": "string",
                    "secret": true
                }
            },
            "required": [
                "apiKey",
                "channelName",
                "enabled",
                "microsoftTeamsWebhookUrl",
                "password",
                "projectId",
                "region",
                "routingKey",
                "serviceDiscovery",
                "serviceKey",
                "teamName",
                "type",
                "url",
                "userName"
            ],
            "inputProperties": {
                "apiKey": {
                    "type": "string",
                    "secret": true
                },
                "channelName": {
                    "type": "string"
                },
                "enabled": {
                    "type": "boolean"
                },
                "microsoftTeamsWebhookUrl": {
                    "type": "string",
                    "secret": true
                },
                "password": {
                    "type": "string",
                    "secret": true
                },
                "projectId": {
                    "type": "string",
                    "description": "The unique ID for the project to get all Third-Party service integrations\n",
                    "willReplaceOnChanges": true
                },
                "region": {
                    "type": "string"
                },
                "routingKey": {
                    "type": "string",
                    "secret": true
                },
                "secret": {
                    "type": "string",
                    "secret": true
                },
                "serviceDiscovery": {
                    "type": "string",
                    "secret": true
                },
                "serviceKey": {
                    "type": "string",
                    "secret": true
                },
                "teamName": {
                    "type": "string"
                },
                "type": {
                    "type": "string",
                    "description": "Third-Party Integration Settings type \n* PAGER_DUTY\n* DATADOG\n* OPS_GENIE\n* VICTOR_OPS\n* WEBHOOK\n* MICROSOFT_TEAMS\n* PROMETHEUS\n\n\n* `PAGER_DUTY`\n",
                    "willReplaceOnChanges": true
                },
                "url": {
                    "type": "string"
                },
                "userName": {
                    "type": "string",
                    "secret": true
                }
            },
            "requiredInputs": [
                "projectId",
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ThirdPartyIntegration resources.\n",
                "properties": {
                    "apiKey": {
                        "type": "string",
                        "secret": true
                    },
                    "channelName": {
                        "type": "string"
                    },
                    "enabled": {
                        "type": "boolean"
                    },
                    "microsoftTeamsWebhookUrl": {
                        "type": "string",
                        "secret": true
                    },
                    "password": {
                        "type": "string",
                        "secret": true
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to get all Third-Party service integrations\n",
                        "willReplaceOnChanges": true
                    },
                    "region": {
                        "type": "string"
                    },
                    "routingKey": {
                        "type": "string",
                        "secret": true
                    },
                    "secret": {
                        "type": "string",
                        "secret": true
                    },
                    "serviceDiscovery": {
                        "type": "string",
                        "secret": true
                    },
                    "serviceKey": {
                        "type": "string",
                        "secret": true
                    },
                    "teamName": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string",
                        "description": "Third-Party Integration Settings type \n* PAGER_DUTY\n* DATADOG\n* OPS_GENIE\n* VICTOR_OPS\n* WEBHOOK\n* MICROSOFT_TEAMS\n* PROMETHEUS\n\n\n* `PAGER_DUTY`\n",
                        "willReplaceOnChanges": true
                    },
                    "url": {
                        "type": "string"
                    },
                    "userName": {
                        "type": "string",
                        "secret": true
                    }
                },
                "type": "object"
            }
        },
        "mongodbatlas:index/x509AuthenticationDatabaseUser:X509AuthenticationDatabaseUser": {
            "description": "## # Resource: mongodbatlas.X509AuthenticationDatabaseUser\n\n`mongodbatlas.X509AuthenticationDatabaseUser` provides a X509 Authentication Database User resource. The mongodbatlas.X509AuthenticationDatabaseUser resource lets you manage MongoDB users who authenticate using X.509 certificates. You can manage these X.509 certificates or let Atlas do it for you.\n\n| Management  | Description  |\n|---|---|\n| Atlas  | Atlas manages your Certificate Authority and can generate certificates for your MongoDB users. No additional X.509 configuration is required.  |\n| Customer  |  You must provide a Certificate Authority and generate certificates for your MongoDB users. |\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n\u003e **NOTE:** Before provider version 1.14.0, Self-managed X.509 Authentication was disabled for the project when this resource was deleted. Starting from that version onward, it will not be disabled, allowing other users to continue using X.509 within the same project.\n\n## Example Usage\n\n### S\n\n### Example Usage: Generate an Atlas-managed X.509 certificate for a MongoDB user\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nresources:\n  user:\n    type: mongodbatlas:DatabaseUser\n    properties:\n      projectId: 64b926dd56206839b1c8bae9\n      username: myUsername\n      x509Type: MANAGED\n      databaseName: $external\n      roles:\n        - roleName: atlasAdmin\n          databaseName: admin\n      labels:\n        - key: My Key\n          value: My Value\n  test:\n    type: mongodbatlas:X509AuthenticationDatabaseUser\n    properties:\n      projectId: ${user.projectId}\n      username: ${user.username}\n      monthsUntilExpiration: 2\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example Usage: Save a self-managed X.509 certificate for an Atlas project and use it with a dababase user\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nresources:\n  test:\n    type: mongodbatlas:X509AuthenticationDatabaseUser\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      customerX509Cas: |\n        -----BEGIN CERTIFICATE-----\n        MIICmTCCAgICCQDZnHzklxsT9TANBgkqhkiG9w0BAQsFADCBkDELMAkGA1UEBhMC\n        VVMxDjAMBgNVBAgMBVRleGFzMQ8wDQYDVQQHDAZBdXN0aW4xETAPBgNVBAoMCHRl\n        c3QuY29tMQ0wCwYDVQQLDARUZXN0MREwDwYDVQQDDAh0ZXN0LmNvbTErMCkGCSqG\n        SIb3DQEJARYcbWVsaXNzYS5wbHVua2V0dEBtb25nb2RiLmNvbTAeFw0yMDAyMDQy\n        MDQ2MDFaFw0yMTAyMDMyMDQ2MDFaMIGQMQswCQYDVQQGEwJVUzEOMAwGA1UECAwF\n        VGV4YXMxDzANBgNVBAcMBkF1c3RpbjERMA8GA1UECgwIdGVzdC5jb20xDTALBgNV\n        BAsMBFRlc3QxETAPBgNVBAMMCHRlc3QuY29tMSswKQYJKoZIhvcNAQkBFhxtZWxp\n        c3NhLnBsdW5rZXR0QG1vbmdvZGIuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB\n        iQKBgQCf1LRqr1zftzdYx2Aj9G76tb0noMPtj6faGLlPji1+m6Rn7RWD9L0ntWAr\n        cURxvypa9jZ9MXFzDtLevvd3tHEmfrUT3ukNDX6+Jtc4kWm+Dh2A70Pd+deKZ2/O\n        Fh8audEKAESGXnTbeJCeQa1XKlIkjqQHBNwES5h1b9vJtFoLJwIDAQABMA0GCSqG\n        SIb3DQEBCwUAA4GBADMUncjEPV/MiZUcVNGmktP6BPmEqMXQWUDpdGW2+Tg2JtUA\n        7MMILtepBkFzLO+GlpZxeAlXO0wxiNgEmCRONgh4+t2w3e7a8GFijYQ99FHrAC5A\n        iul59bdl18gVqXia1Yeq/iK7Ohfy/Jwd7Hsm530elwkM/ZEkYDjBlZSXYdyz\n        -----END CERTIFICATE-----\"\n  user:\n    type: mongodbatlas:DatabaseUser\n    properties:\n      projectId: 64b926dd56206839b1c8bae9\n      username: myUsername\n      x509Type: CUSTOMER\n      databaseName: $external\n      roles:\n        - roleName: atlasAdmin\n          databaseName: admin\n      labels:\n        - key: My Key\n          value: My Value\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nX.509 Certificates for a User can be imported using project ID and username, in the format `project_id-username`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/x509AuthenticationDatabaseUser:X509AuthenticationDatabaseUser test 1112222b3bf99403840e8934-myUsername\n```\nFor more information see: [MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/x509-configuration-get-certificates/)\n\nCurrent X.509 Configuration can be imported using project ID, in the format `project_id`, e.g.\n\n```sh\n$ pulumi import mongodbatlas:index/x509AuthenticationDatabaseUser:X509AuthenticationDatabaseUser test 1112222b3bf99403840e8934\n```\nFor more information see: [MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/x509-configuration-get-certificates/)\n\n",
            "properties": {
                "certificates": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/mongodbatlas:index/X509AuthenticationDatabaseUserCertificate:X509AuthenticationDatabaseUserCertificate"
                    },
                    "description": "Array of objects where each details one unexpired database user certificate.\n"
                },
                "currentCertificate": {
                    "type": "string",
                    "description": "Contains the last X.509 certificate and private key created for a database user.\n",
                    "secret": true
                },
                "customerX509Cas": {
                    "type": "string",
                    "description": "PEM string containing one or more customer CAs for database user authentication.\n",
                    "secret": true
                },
                "monthsUntilExpiration": {
                    "type": "integer",
                    "description": "A number of months that the created certificate is valid for before expiry, up to 24 months. By default is 3.\n"
                },
                "projectId": {
                    "type": "string",
                    "description": "Identifier for the Atlas project associated with the X.509 configuration.\n"
                },
                "username": {
                    "type": "string",
                    "description": "Username of the database user to create a certificate for.\n"
                }
            },
            "required": [
                "certificates",
                "currentCertificate",
                "projectId"
            ],
            "inputProperties": {
                "customerX509Cas": {
                    "type": "string",
                    "description": "PEM string containing one or more customer CAs for database user authentication.\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                },
                "monthsUntilExpiration": {
                    "type": "integer",
                    "description": "A number of months that the created certificate is valid for before expiry, up to 24 months. By default is 3.\n",
                    "willReplaceOnChanges": true
                },
                "projectId": {
                    "type": "string",
                    "description": "Identifier for the Atlas project associated with the X.509 configuration.\n",
                    "willReplaceOnChanges": true
                },
                "username": {
                    "type": "string",
                    "description": "Username of the database user to create a certificate for.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "projectId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering X509AuthenticationDatabaseUser resources.\n",
                "properties": {
                    "certificates": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/X509AuthenticationDatabaseUserCertificate:X509AuthenticationDatabaseUserCertificate"
                        },
                        "description": "Array of objects where each details one unexpired database user certificate.\n"
                    },
                    "currentCertificate": {
                        "type": "string",
                        "description": "Contains the last X.509 certificate and private key created for a database user.\n",
                        "secret": true
                    },
                    "customerX509Cas": {
                        "type": "string",
                        "description": "PEM string containing one or more customer CAs for database user authentication.\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "monthsUntilExpiration": {
                        "type": "integer",
                        "description": "A number of months that the created certificate is valid for before expiry, up to 24 months. By default is 3.\n",
                        "willReplaceOnChanges": true
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Identifier for the Atlas project associated with the X.509 configuration.\n",
                        "willReplaceOnChanges": true
                    },
                    "username": {
                        "type": "string",
                        "description": "Username of the database user to create a certificate for.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "mongodbatlas:index/get509AuthenticationDatabaseUser:get509AuthenticationDatabaseUser": {
            "deprecationMessage": "mongodbatlas.index/get509authenticationdatabaseuser.get509AuthenticationDatabaseUser has been deprecated in favor of mongodbatlas.index/getx509authenticationdatabaseuser.getX509AuthenticationDatabaseUser",
            "description": "## # Data Source: mongodbatlas.X509AuthenticationDatabaseUser\n\n`mongodbatlas.X509AuthenticationDatabaseUser` describes a X509 Authentication Database User. This represents a X509 Authentication Database User.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n## Example Usage\n\n### S\n\n### Example Usage: Generate an Atlas-managed X.509 certificate for a MongoDB user\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nresources:\n  user:\n    type: mongodbatlas:DatabaseUser\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      username: myUsername\n      x509Type: MANAGED\n      databaseName: $external\n      roles:\n        - roleName: atlasAdmin\n          databaseName: admin\n      labels:\n        - key: My Key\n          value: My Value\n  testX509AuthenticationDatabaseUser:\n    type: mongodbatlas:X509AuthenticationDatabaseUser\n    name: test\n    properties:\n      projectId: ${user.projectId}\n      username: ${user.username}\n      monthsUntilExpiration: 2\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getX509AuthenticationDatabaseUser\n      Arguments:\n        projectId: ${testX509AuthenticationDatabaseUser.projectId}\n        username: ${testX509AuthenticationDatabaseUser.username}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example Usage: Save a customer-managed X.509 configuration for an Atlas project\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testX509AuthenticationDatabaseUser = new mongodbatlas.X509AuthenticationDatabaseUser(\"test\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    customerX509Cas: `-----BEGIN CERTIFICATE-----\nMIICmTCCAgICCQDZnHzklxsT9TANBgkqhkiG9w0BAQsFADCBkDELMAkGA1UEBhMC\nVVMxDjAMBgNVBAgMBVRleGFzMQ8wDQYDVQQHDAZBdXN0aW4xETAPBgNVBAoMCHRl\nc3QuY29tMQ0wCwYDVQQLDARUZXN0MREwDwYDVQQDDAh0ZXN0LmNvbTErMCkGCSqG\nSIb3DQEJARYcbWVsaXNzYS5wbHVua2V0dEBtb25nb2RiLmNvbTAeFw0yMDAyMDQy\nMDQ2MDFaFw0yMTAyMDMyMDQ2MDFaMIGQMQswCQYDVQQGEwJVUzEOMAwGA1UECAwF\nVGV4YXMxDzANBgNVBAcMBkF1c3RpbjERMA8GA1UECgwIdGVzdC5jb20xDTALBgNV\nBAsMBFRlc3QxETAPBgNVBAMMCHRlc3QuY29tMSswKQYJKoZIhvcNAQkBFhxtZWxp\nc3NhLnBsdW5rZXR0QG1vbmdvZGIuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB\niQKBgQCf1LRqr1zftzdYx2Aj9G76tb0noMPtj6faGLlPji1+m6Rn7RWD9L0ntWAr\ncURxvypa9jZ9MXFzDtLevvd3tHEmfrUT3ukNDX6+Jtc4kWm+Dh2A70Pd+deKZ2/O\nFh8audEKAESGXnTbeJCeQa1XKlIkjqQHBNwES5h1b9vJtFoLJwIDAQABMA0GCSqG\nSIb3DQEBCwUAA4GBADMUncjEPV/MiZUcVNGmktP6BPmEqMXQWUDpdGW2+Tg2JtUA\n7MMILtepBkFzLO+GlpZxeAlXO0wxiNgEmCRONgh4+t2w3e7a8GFijYQ99FHrAC5A\niul59bdl18gVqXia1Yeq/iK7Ohfy/Jwd7Hsm530elwkM/ZEkYDjBlZSXYdyz\n-----END CERTIFICATE-----\"\n`,\n});\nconst test = mongodbatlas.getX509AuthenticationDatabaseUserOutput({\n    projectId: testX509AuthenticationDatabaseUser.projectId,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_x509_authentication_database_user = mongodbatlas.X509AuthenticationDatabaseUser(\"test\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    customer_x509_cas=\"\"\"-----BEGIN CERTIFICATE-----\nMIICmTCCAgICCQDZnHzklxsT9TANBgkqhkiG9w0BAQsFADCBkDELMAkGA1UEBhMC\nVVMxDjAMBgNVBAgMBVRleGFzMQ8wDQYDVQQHDAZBdXN0aW4xETAPBgNVBAoMCHRl\nc3QuY29tMQ0wCwYDVQQLDARUZXN0MREwDwYDVQQDDAh0ZXN0LmNvbTErMCkGCSqG\nSIb3DQEJARYcbWVsaXNzYS5wbHVua2V0dEBtb25nb2RiLmNvbTAeFw0yMDAyMDQy\nMDQ2MDFaFw0yMTAyMDMyMDQ2MDFaMIGQMQswCQYDVQQGEwJVUzEOMAwGA1UECAwF\nVGV4YXMxDzANBgNVBAcMBkF1c3RpbjERMA8GA1UECgwIdGVzdC5jb20xDTALBgNV\nBAsMBFRlc3QxETAPBgNVBAMMCHRlc3QuY29tMSswKQYJKoZIhvcNAQkBFhxtZWxp\nc3NhLnBsdW5rZXR0QG1vbmdvZGIuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB\niQKBgQCf1LRqr1zftzdYx2Aj9G76tb0noMPtj6faGLlPji1+m6Rn7RWD9L0ntWAr\ncURxvypa9jZ9MXFzDtLevvd3tHEmfrUT3ukNDX6+Jtc4kWm+Dh2A70Pd+deKZ2/O\nFh8audEKAESGXnTbeJCeQa1XKlIkjqQHBNwES5h1b9vJtFoLJwIDAQABMA0GCSqG\nSIb3DQEBCwUAA4GBADMUncjEPV/MiZUcVNGmktP6BPmEqMXQWUDpdGW2+Tg2JtUA\n7MMILtepBkFzLO+GlpZxeAlXO0wxiNgEmCRONgh4+t2w3e7a8GFijYQ99FHrAC5A\niul59bdl18gVqXia1Yeq/iK7Ohfy/Jwd7Hsm530elwkM/ZEkYDjBlZSXYdyz\n-----END CERTIFICATE-----\"\n\"\"\")\ntest = mongodbatlas.get_x509_authentication_database_user_output(project_id=test_x509_authentication_database_user.project_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testX509AuthenticationDatabaseUser = new Mongodbatlas.X509AuthenticationDatabaseUser(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        CustomerX509Cas = @\"-----BEGIN CERTIFICATE-----\nMIICmTCCAgICCQDZnHzklxsT9TANBgkqhkiG9w0BAQsFADCBkDELMAkGA1UEBhMC\nVVMxDjAMBgNVBAgMBVRleGFzMQ8wDQYDVQQHDAZBdXN0aW4xETAPBgNVBAoMCHRl\nc3QuY29tMQ0wCwYDVQQLDARUZXN0MREwDwYDVQQDDAh0ZXN0LmNvbTErMCkGCSqG\nSIb3DQEJARYcbWVsaXNzYS5wbHVua2V0dEBtb25nb2RiLmNvbTAeFw0yMDAyMDQy\nMDQ2MDFaFw0yMTAyMDMyMDQ2MDFaMIGQMQswCQYDVQQGEwJVUzEOMAwGA1UECAwF\nVGV4YXMxDzANBgNVBAcMBkF1c3RpbjERMA8GA1UECgwIdGVzdC5jb20xDTALBgNV\nBAsMBFRlc3QxETAPBgNVBAMMCHRlc3QuY29tMSswKQYJKoZIhvcNAQkBFhxtZWxp\nc3NhLnBsdW5rZXR0QG1vbmdvZGIuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB\niQKBgQCf1LRqr1zftzdYx2Aj9G76tb0noMPtj6faGLlPji1+m6Rn7RWD9L0ntWAr\ncURxvypa9jZ9MXFzDtLevvd3tHEmfrUT3ukNDX6+Jtc4kWm+Dh2A70Pd+deKZ2/O\nFh8audEKAESGXnTbeJCeQa1XKlIkjqQHBNwES5h1b9vJtFoLJwIDAQABMA0GCSqG\nSIb3DQEBCwUAA4GBADMUncjEPV/MiZUcVNGmktP6BPmEqMXQWUDpdGW2+Tg2JtUA\n7MMILtepBkFzLO+GlpZxeAlXO0wxiNgEmCRONgh4+t2w3e7a8GFijYQ99FHrAC5A\niul59bdl18gVqXia1Yeq/iK7Ohfy/Jwd7Hsm530elwkM/ZEkYDjBlZSXYdyz\n-----END CERTIFICATE-----\"\"\n\",\n    });\n\n    var test = Mongodbatlas.GetX509AuthenticationDatabaseUser.Invoke(new()\n    {\n        ProjectId = testX509AuthenticationDatabaseUser.ProjectId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestX509AuthenticationDatabaseUser, err := mongodbatlas.NewX509AuthenticationDatabaseUser(ctx, \"test\", \u0026mongodbatlas.X509AuthenticationDatabaseUserArgs{\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tCustomerX509Cas: pulumi.String(`-----BEGIN CERTIFICATE-----\nMIICmTCCAgICCQDZnHzklxsT9TANBgkqhkiG9w0BAQsFADCBkDELMAkGA1UEBhMC\nVVMxDjAMBgNVBAgMBVRleGFzMQ8wDQYDVQQHDAZBdXN0aW4xETAPBgNVBAoMCHRl\nc3QuY29tMQ0wCwYDVQQLDARUZXN0MREwDwYDVQQDDAh0ZXN0LmNvbTErMCkGCSqG\nSIb3DQEJARYcbWVsaXNzYS5wbHVua2V0dEBtb25nb2RiLmNvbTAeFw0yMDAyMDQy\nMDQ2MDFaFw0yMTAyMDMyMDQ2MDFaMIGQMQswCQYDVQQGEwJVUzEOMAwGA1UECAwF\nVGV4YXMxDzANBgNVBAcMBkF1c3RpbjERMA8GA1UECgwIdGVzdC5jb20xDTALBgNV\nBAsMBFRlc3QxETAPBgNVBAMMCHRlc3QuY29tMSswKQYJKoZIhvcNAQkBFhxtZWxp\nc3NhLnBsdW5rZXR0QG1vbmdvZGIuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB\niQKBgQCf1LRqr1zftzdYx2Aj9G76tb0noMPtj6faGLlPji1+m6Rn7RWD9L0ntWAr\ncURxvypa9jZ9MXFzDtLevvd3tHEmfrUT3ukNDX6+Jtc4kWm+Dh2A70Pd+deKZ2/O\nFh8audEKAESGXnTbeJCeQa1XKlIkjqQHBNwES5h1b9vJtFoLJwIDAQABMA0GCSqG\nSIb3DQEBCwUAA4GBADMUncjEPV/MiZUcVNGmktP6BPmEqMXQWUDpdGW2+Tg2JtUA\n7MMILtepBkFzLO+GlpZxeAlXO0wxiNgEmCRONgh4+t2w3e7a8GFijYQ99FHrAC5A\niul59bdl18gVqXia1Yeq/iK7Ohfy/Jwd7Hsm530elwkM/ZEkYDjBlZSXYdyz\n-----END CERTIFICATE-----\"\n`),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupX509AuthenticationDatabaseUserOutput(ctx, mongodbatlas.GetX509AuthenticationDatabaseUserOutputArgs{\n\t\t\tProjectId: testX509AuthenticationDatabaseUser.ProjectId,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.X509AuthenticationDatabaseUser;\nimport com.pulumi.mongodbatlas.X509AuthenticationDatabaseUserArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetX509AuthenticationDatabaseUserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testX509AuthenticationDatabaseUser = new X509AuthenticationDatabaseUser(\"testX509AuthenticationDatabaseUser\", X509AuthenticationDatabaseUserArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .customerX509Cas(\"\"\"\n-----BEGIN CERTIFICATE-----\nMIICmTCCAgICCQDZnHzklxsT9TANBgkqhkiG9w0BAQsFADCBkDELMAkGA1UEBhMC\nVVMxDjAMBgNVBAgMBVRleGFzMQ8wDQYDVQQHDAZBdXN0aW4xETAPBgNVBAoMCHRl\nc3QuY29tMQ0wCwYDVQQLDARUZXN0MREwDwYDVQQDDAh0ZXN0LmNvbTErMCkGCSqG\nSIb3DQEJARYcbWVsaXNzYS5wbHVua2V0dEBtb25nb2RiLmNvbTAeFw0yMDAyMDQy\nMDQ2MDFaFw0yMTAyMDMyMDQ2MDFaMIGQMQswCQYDVQQGEwJVUzEOMAwGA1UECAwF\nVGV4YXMxDzANBgNVBAcMBkF1c3RpbjERMA8GA1UECgwIdGVzdC5jb20xDTALBgNV\nBAsMBFRlc3QxETAPBgNVBAMMCHRlc3QuY29tMSswKQYJKoZIhvcNAQkBFhxtZWxp\nc3NhLnBsdW5rZXR0QG1vbmdvZGIuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB\niQKBgQCf1LRqr1zftzdYx2Aj9G76tb0noMPtj6faGLlPji1+m6Rn7RWD9L0ntWAr\ncURxvypa9jZ9MXFzDtLevvd3tHEmfrUT3ukNDX6+Jtc4kWm+Dh2A70Pd+deKZ2/O\nFh8audEKAESGXnTbeJCeQa1XKlIkjqQHBNwES5h1b9vJtFoLJwIDAQABMA0GCSqG\nSIb3DQEBCwUAA4GBADMUncjEPV/MiZUcVNGmktP6BPmEqMXQWUDpdGW2+Tg2JtUA\n7MMILtepBkFzLO+GlpZxeAlXO0wxiNgEmCRONgh4+t2w3e7a8GFijYQ99FHrAC5A\niul59bdl18gVqXia1Yeq/iK7Ohfy/Jwd7Hsm530elwkM/ZEkYDjBlZSXYdyz\n-----END CERTIFICATE-----\"\n            \"\"\")\n            .build());\n\n        final var test = MongodbatlasFunctions.getX509AuthenticationDatabaseUser(GetX509AuthenticationDatabaseUserArgs.builder()\n            .projectId(testX509AuthenticationDatabaseUser.projectId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testX509AuthenticationDatabaseUser:\n    type: mongodbatlas:X509AuthenticationDatabaseUser\n    name: test\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      customerX509Cas: |\n        -----BEGIN CERTIFICATE-----\n        MIICmTCCAgICCQDZnHzklxsT9TANBgkqhkiG9w0BAQsFADCBkDELMAkGA1UEBhMC\n        VVMxDjAMBgNVBAgMBVRleGFzMQ8wDQYDVQQHDAZBdXN0aW4xETAPBgNVBAoMCHRl\n        c3QuY29tMQ0wCwYDVQQLDARUZXN0MREwDwYDVQQDDAh0ZXN0LmNvbTErMCkGCSqG\n        SIb3DQEJARYcbWVsaXNzYS5wbHVua2V0dEBtb25nb2RiLmNvbTAeFw0yMDAyMDQy\n        MDQ2MDFaFw0yMTAyMDMyMDQ2MDFaMIGQMQswCQYDVQQGEwJVUzEOMAwGA1UECAwF\n        VGV4YXMxDzANBgNVBAcMBkF1c3RpbjERMA8GA1UECgwIdGVzdC5jb20xDTALBgNV\n        BAsMBFRlc3QxETAPBgNVBAMMCHRlc3QuY29tMSswKQYJKoZIhvcNAQkBFhxtZWxp\n        c3NhLnBsdW5rZXR0QG1vbmdvZGIuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB\n        iQKBgQCf1LRqr1zftzdYx2Aj9G76tb0noMPtj6faGLlPji1+m6Rn7RWD9L0ntWAr\n        cURxvypa9jZ9MXFzDtLevvd3tHEmfrUT3ukNDX6+Jtc4kWm+Dh2A70Pd+deKZ2/O\n        Fh8audEKAESGXnTbeJCeQa1XKlIkjqQHBNwES5h1b9vJtFoLJwIDAQABMA0GCSqG\n        SIb3DQEBCwUAA4GBADMUncjEPV/MiZUcVNGmktP6BPmEqMXQWUDpdGW2+Tg2JtUA\n        7MMILtepBkFzLO+GlpZxeAlXO0wxiNgEmCRONgh4+t2w3e7a8GFijYQ99FHrAC5A\n        iul59bdl18gVqXia1Yeq/iK7Ohfy/Jwd7Hsm530elwkM/ZEkYDjBlZSXYdyz\n        -----END CERTIFICATE-----\"\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getX509AuthenticationDatabaseUser\n      Arguments:\n        projectId: ${testX509AuthenticationDatabaseUser.projectId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking get509AuthenticationDatabaseUser.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "Identifier for the Atlas project associated with the X.509 configuration.\n",
                        "willReplaceOnChanges": true
                    },
                    "username": {
                        "type": "string",
                        "description": "Username of the database user to create a certificate for.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by get509AuthenticationDatabaseUser.\n",
                "properties": {
                    "certificates": {
                        "description": "Array of objects where each details one unexpired database user certificate.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/get509AuthenticationDatabaseUserCertificate:get509AuthenticationDatabaseUserCertificate"
                        },
                        "type": "array"
                    },
                    "customerX509Cas": {
                        "secret": true,
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "username": {
                        "type": "string"
                    }
                },
                "required": [
                    "certificates",
                    "customerX509Cas",
                    "projectId",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getAccessListApiKey:getAccessListApiKey": {
            "description": "## Example Usage\n\n### Using CIDR Block\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nresources:\n  testAccessListApiKey:\n    type: mongodbatlas:AccessListApiKey\n    name: test\n    properties:\n      orgId: \u003cORG-ID\u003e\n      cidrBlock: 1.2.3.4/32\n      apiKey: a29120e123cd\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getAccessListApiKey\n      Arguments:\n        orgId: ${testAccessListApiKey.orgId}\n        cidrBlock: ${testAccessListApiKey.cidrBlock}\n        apiKeyId: ${testAccessListApiKey.apiKeyId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Using IP Address\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nresources:\n  testAccessListApiKey:\n    type: mongodbatlas:AccessListApiKey\n    name: test\n    properties:\n      orgId: \u003cORG-ID\u003e\n      ipAddress: 2.3.4.5\n      apiKey: a29120e123cd\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getAccessListApiKey\n      Arguments:\n        orgId: ${testAccessListApiKey.orgId}\n        ipAddress: ${testAccessListApiKey.ipAddress}\n        apiKeyId: ${testAccessListApiKey.apiKeyId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAccessListApiKey.\n",
                "properties": {
                    "apiKeyId": {
                        "type": "string",
                        "description": "Unique identifier for the Organization API Key for which you want to retrieve an access list entry.\n*\n-\u003e**NOTE:** You must set either the `cidr_block` attribute or the `ip_address` attribute. Don't set both.\n"
                    },
                    "ipAddress": {
                        "type": "string",
                        "description": "Single IP address to be added to the access list.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                    }
                },
                "type": "object",
                "required": [
                    "apiKeyId",
                    "ipAddress",
                    "orgId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAccessListApiKey.\n",
                "properties": {
                    "accessCount": {
                        "type": "integer"
                    },
                    "apiKeyId": {
                        "type": "string"
                    },
                    "cidrBlock": {
                        "type": "string"
                    },
                    "created": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "ipAddress": {
                        "type": "string"
                    },
                    "lastUsed": {
                        "type": "string"
                    },
                    "lastUsedAddress": {
                        "type": "string"
                    },
                    "orgId": {
                        "type": "string"
                    }
                },
                "required": [
                    "accessCount",
                    "apiKeyId",
                    "cidrBlock",
                    "created",
                    "ipAddress",
                    "lastUsed",
                    "lastUsedAddress",
                    "orgId",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getAccessListApiKeys:getAccessListApiKeys": {
            "description": "## Example Usage\n\n### Using CIDR Block\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nresources:\n  testAccessListApiKey:\n    type: mongodbatlas:AccessListApiKey\n    name: test\n    properties:\n      orgId: \u003cORG-ID\u003e\n      cidrBlock: 1.2.3.4/32\n      apiKey: a29120e123cd\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getAccessListApiKey\n      Arguments:\n        orgId: ${testAccessListApiKey.orgId}\n        cidrBlock: ${testAccessListApiKey.cidrBlock}\n        apiKeyId: ${testAccessListApiKey.apiKeyId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Using IP Address\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nresources:\n  testAccessListApiKey:\n    type: mongodbatlas:AccessListApiKey\n    name: test\n    properties:\n      orgId: \u003cORG-ID\u003e\n      ipAddress: 2.3.4.5\n      apiKey: a29120e123cd\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getAccessListApiKey\n      Arguments:\n        orgId: ${testAccessListApiKey.orgId}\n        ipAddress: ${testAccessListApiKey.ipAddress}\n        apiKeyId: ${testAccessListApiKey.apiKeyId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAccessListApiKeys.\n",
                "properties": {
                    "apiKeyId": {
                        "type": "string"
                    },
                    "itemsPerPage": {
                        "type": "integer",
                        "description": "Number of items to return per page, up to a maximum of 500. Defaults to `100`.\n"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "pageNum": {
                        "type": "integer",
                        "description": "The page to return. Defaults to `1`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "apiKeyId",
                    "orgId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAccessListApiKeys.\n",
                "properties": {
                    "apiKeyId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "results": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAccessListApiKeysResult:getAccessListApiKeysResult"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "apiKeyId",
                    "orgId",
                    "results",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getAdvancedCluster:getAdvancedCluster": {
            "description": "## # Data Source: mongodbatlas.AdvancedCluster\n\n`mongodbatlas.AdvancedCluster` describes an Advanced Cluster. The data source requires your Project ID.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n\u003e **IMPORTANT:**\n\u003cbr\u003e \u0026#8226; Changes to cluster configurations can affect costs. Before making changes, please see [Billing](https://docs.atlas.mongodb.com/billing/).\n\u003cbr\u003e \u0026#8226; If your Atlas project contains a custom role that uses actions introduced in a specific MongoDB version, you cannot create a cluster with a MongoDB version less than that version unless you delete the custom role.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst exampleAdvancedCluster = new mongodbatlas.AdvancedCluster(\"example\", {\n    projectId: \"\u003cYOUR-PROJECT-ID\u003e\",\n    name: \"cluster-test\",\n    clusterType: \"REPLICASET\",\n    replicationSpecs: [{\n        regionConfigs: [{\n            electableSpecs: {\n                instanceSize: \"M5\",\n            },\n            providerName: \"TENANT\",\n            backingProviderName: \"AWS\",\n            regionName: \"US_EAST_1\",\n            priority: 7,\n        }],\n    }],\n});\nconst example = mongodbatlas.getAdvancedClusterOutput({\n    projectId: exampleAdvancedCluster.projectId,\n    name: exampleAdvancedCluster.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nexample_advanced_cluster = mongodbatlas.AdvancedCluster(\"example\",\n    project_id=\"\u003cYOUR-PROJECT-ID\u003e\",\n    name=\"cluster-test\",\n    cluster_type=\"REPLICASET\",\n    replication_specs=[{\n        \"region_configs\": [{\n            \"electable_specs\": {\n                \"instance_size\": \"M5\",\n            },\n            \"provider_name\": \"TENANT\",\n            \"backing_provider_name\": \"AWS\",\n            \"region_name\": \"US_EAST_1\",\n            \"priority\": 7,\n        }],\n    }])\nexample = mongodbatlas.get_advanced_cluster_output(project_id=example_advanced_cluster.project_id,\n    name=example_advanced_cluster.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleAdvancedCluster = new Mongodbatlas.AdvancedCluster(\"example\", new()\n    {\n        ProjectId = \"\u003cYOUR-PROJECT-ID\u003e\",\n        Name = \"cluster-test\",\n        ClusterType = \"REPLICASET\",\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M5\",\n                        },\n                        ProviderName = \"TENANT\",\n                        BackingProviderName = \"AWS\",\n                        RegionName = \"US_EAST_1\",\n                        Priority = 7,\n                    },\n                },\n            },\n        },\n    });\n\n    var example = Mongodbatlas.GetAdvancedCluster.Invoke(new()\n    {\n        ProjectId = exampleAdvancedCluster.ProjectId,\n        Name = exampleAdvancedCluster.Name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleAdvancedCluster, err := mongodbatlas.NewAdvancedCluster(ctx, \"example\", \u0026mongodbatlas.AdvancedClusterArgs{\n\t\t\tProjectId:   pulumi.String(\"\u003cYOUR-PROJECT-ID\u003e\"),\n\t\t\tName:        pulumi.String(\"cluster-test\"),\n\t\t\tClusterType: pulumi.String(\"REPLICASET\"),\n\t\t\tReplicationSpecs: mongodbatlas.AdvancedClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M5\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName:        pulumi.String(\"TENANT\"),\n\t\t\t\t\t\t\tBackingProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tRegionName:          pulumi.String(\"US_EAST_1\"),\n\t\t\t\t\t\t\tPriority:            pulumi.Int(7),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupAdvancedClusterOutput(ctx, mongodbatlas.GetAdvancedClusterOutputArgs{\n\t\t\tProjectId: exampleAdvancedCluster.ProjectId,\n\t\t\tName:      exampleAdvancedCluster.Name,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AdvancedCluster;\nimport com.pulumi.mongodbatlas.AdvancedClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.AdvancedClusterReplicationSpecArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetAdvancedClusterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleAdvancedCluster = new AdvancedCluster(\"exampleAdvancedCluster\", AdvancedClusterArgs.builder()\n            .projectId(\"\u003cYOUR-PROJECT-ID\u003e\")\n            .name(\"cluster-test\")\n            .clusterType(\"REPLICASET\")\n            .replicationSpecs(AdvancedClusterReplicationSpecArgs.builder()\n                .regionConfigs(AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                    .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                        .instanceSize(\"M5\")\n                        .build())\n                    .providerName(\"TENANT\")\n                    .backingProviderName(\"AWS\")\n                    .regionName(\"US_EAST_1\")\n                    .priority(7)\n                    .build())\n                .build())\n            .build());\n\n        final var example = MongodbatlasFunctions.getAdvancedCluster(GetAdvancedClusterArgs.builder()\n            .projectId(exampleAdvancedCluster.projectId())\n            .name(exampleAdvancedCluster.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleAdvancedCluster:\n    type: mongodbatlas:AdvancedCluster\n    name: example\n    properties:\n      projectId: \u003cYOUR-PROJECT-ID\u003e\n      name: cluster-test\n      clusterType: REPLICASET\n      replicationSpecs:\n        - regionConfigs:\n            - electableSpecs:\n                instanceSize: M5\n              providerName: TENANT\n              backingProviderName: AWS\n              regionName: US_EAST_1\n              priority: 7\nvariables:\n  example:\n    fn::invoke:\n      Function: mongodbatlas:getAdvancedCluster\n      Arguments:\n        projectId: ${exampleAdvancedCluster.projectId}\n        name: ${exampleAdvancedCluster.name}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Example using latest sharding configurations with independent shard scaling in the cluster\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst exampleAdvancedCluster = new mongodbatlas.AdvancedCluster(\"example\", {\n    projectId: \"\u003cYOUR-PROJECT-ID\u003e\",\n    name: \"cluster-test\",\n    backupEnabled: false,\n    clusterType: \"SHARDED\",\n    replicationSpecs: [\n        {\n            regionConfigs: [{\n                electableSpecs: {\n                    instanceSize: \"M30\",\n                    diskIops: 3000,\n                    nodeCount: 3,\n                },\n                providerName: \"AWS\",\n                priority: 7,\n                regionName: \"EU_WEST_1\",\n            }],\n        },\n        {\n            regionConfigs: [{\n                electableSpecs: {\n                    instanceSize: \"M40\",\n                    diskIops: 3000,\n                    nodeCount: 3,\n                },\n                providerName: \"AWS\",\n                priority: 7,\n                regionName: \"EU_WEST_1\",\n            }],\n        },\n    ],\n});\nconst example = mongodbatlas.getAdvancedClusterOutput({\n    projectId: exampleAdvancedCluster.projectId,\n    name: exampleAdvancedCluster.name,\n    useReplicationSpecPerShard: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nexample_advanced_cluster = mongodbatlas.AdvancedCluster(\"example\",\n    project_id=\"\u003cYOUR-PROJECT-ID\u003e\",\n    name=\"cluster-test\",\n    backup_enabled=False,\n    cluster_type=\"SHARDED\",\n    replication_specs=[\n        {\n            \"region_configs\": [{\n                \"electable_specs\": {\n                    \"instance_size\": \"M30\",\n                    \"disk_iops\": 3000,\n                    \"node_count\": 3,\n                },\n                \"provider_name\": \"AWS\",\n                \"priority\": 7,\n                \"region_name\": \"EU_WEST_1\",\n            }],\n        },\n        {\n            \"region_configs\": [{\n                \"electable_specs\": {\n                    \"instance_size\": \"M40\",\n                    \"disk_iops\": 3000,\n                    \"node_count\": 3,\n                },\n                \"provider_name\": \"AWS\",\n                \"priority\": 7,\n                \"region_name\": \"EU_WEST_1\",\n            }],\n        },\n    ])\nexample = mongodbatlas.get_advanced_cluster_output(project_id=example_advanced_cluster.project_id,\n    name=example_advanced_cluster.name,\n    use_replication_spec_per_shard=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleAdvancedCluster = new Mongodbatlas.AdvancedCluster(\"example\", new()\n    {\n        ProjectId = \"\u003cYOUR-PROJECT-ID\u003e\",\n        Name = \"cluster-test\",\n        BackupEnabled = false,\n        ClusterType = \"SHARDED\",\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M30\",\n                            DiskIops = 3000,\n                            NodeCount = 3,\n                        },\n                        ProviderName = \"AWS\",\n                        Priority = 7,\n                        RegionName = \"EU_WEST_1\",\n                    },\n                },\n            },\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M40\",\n                            DiskIops = 3000,\n                            NodeCount = 3,\n                        },\n                        ProviderName = \"AWS\",\n                        Priority = 7,\n                        RegionName = \"EU_WEST_1\",\n                    },\n                },\n            },\n        },\n    });\n\n    var example = Mongodbatlas.GetAdvancedCluster.Invoke(new()\n    {\n        ProjectId = exampleAdvancedCluster.ProjectId,\n        Name = exampleAdvancedCluster.Name,\n        UseReplicationSpecPerShard = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleAdvancedCluster, err := mongodbatlas.NewAdvancedCluster(ctx, \"example\", \u0026mongodbatlas.AdvancedClusterArgs{\n\t\t\tProjectId:     pulumi.String(\"\u003cYOUR-PROJECT-ID\u003e\"),\n\t\t\tName:          pulumi.String(\"cluster-test\"),\n\t\t\tBackupEnabled: pulumi.Bool(false),\n\t\t\tClusterType:   pulumi.String(\"SHARDED\"),\n\t\t\tReplicationSpecs: mongodbatlas.AdvancedClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M30\"),\n\t\t\t\t\t\t\t\tDiskIops:     pulumi.Int(3000),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(3),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tPriority:     pulumi.Int(7),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"EU_WEST_1\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M40\"),\n\t\t\t\t\t\t\t\tDiskIops:     pulumi.Int(3000),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(3),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tPriority:     pulumi.Int(7),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"EU_WEST_1\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupAdvancedClusterOutput(ctx, mongodbatlas.GetAdvancedClusterOutputArgs{\n\t\t\tProjectId:                  exampleAdvancedCluster.ProjectId,\n\t\t\tName:                       exampleAdvancedCluster.Name,\n\t\t\tUseReplicationSpecPerShard: pulumi.Bool(true),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AdvancedCluster;\nimport com.pulumi.mongodbatlas.AdvancedClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.AdvancedClusterReplicationSpecArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetAdvancedClusterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleAdvancedCluster = new AdvancedCluster(\"exampleAdvancedCluster\", AdvancedClusterArgs.builder()\n            .projectId(\"\u003cYOUR-PROJECT-ID\u003e\")\n            .name(\"cluster-test\")\n            .backupEnabled(false)\n            .clusterType(\"SHARDED\")\n            .replicationSpecs(            \n                AdvancedClusterReplicationSpecArgs.builder()\n                    .regionConfigs(AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                        .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                            .instanceSize(\"M30\")\n                            .diskIops(3000)\n                            .nodeCount(3)\n                            .build())\n                        .providerName(\"AWS\")\n                        .priority(7)\n                        .regionName(\"EU_WEST_1\")\n                        .build())\n                    .build(),\n                AdvancedClusterReplicationSpecArgs.builder()\n                    .regionConfigs(AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                        .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                            .instanceSize(\"M40\")\n                            .diskIops(3000)\n                            .nodeCount(3)\n                            .build())\n                        .providerName(\"AWS\")\n                        .priority(7)\n                        .regionName(\"EU_WEST_1\")\n                        .build())\n                    .build())\n            .build());\n\n        final var example = MongodbatlasFunctions.getAdvancedCluster(GetAdvancedClusterArgs.builder()\n            .projectId(exampleAdvancedCluster.projectId())\n            .name(exampleAdvancedCluster.name())\n            .useReplicationSpecPerShard(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleAdvancedCluster:\n    type: mongodbatlas:AdvancedCluster\n    name: example\n    properties:\n      projectId: \u003cYOUR-PROJECT-ID\u003e\n      name: cluster-test\n      backupEnabled: false\n      clusterType: SHARDED\n      replicationSpecs:\n        - regionConfigs:\n            - electableSpecs:\n                instanceSize: M30\n                diskIops: 3000\n                nodeCount: 3\n              providerName: AWS\n              priority: 7\n              regionName: EU_WEST_1\n        - regionConfigs:\n            - electableSpecs:\n                instanceSize: M40\n                diskIops: 3000\n                nodeCount: 3\n              providerName: AWS\n              priority: 7\n              regionName: EU_WEST_1\nvariables:\n  example:\n    fn::invoke:\n      Function: mongodbatlas:getAdvancedCluster\n      Arguments:\n        projectId: ${exampleAdvancedCluster.projectId}\n        name: ${exampleAdvancedCluster.name}\n        useReplicationSpecPerShard: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAdvancedCluster.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Name of the cluster as it appears in Atlas. Once the cluster is created, its name cannot be changed.\n"
                    },
                    "pitEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates if the cluster uses Continuous Cloud Backup.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the database user.\n"
                    },
                    "useReplicationSpecPerShard": {
                        "type": "boolean",
                        "description": "Set this field to true to allow the data source to use the latest schema representing each shard with an individual `replication_specs` object. This enables representing clusters with independent shard scaling.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAdvancedCluster.\n",
                "properties": {
                    "advancedConfigurations": {
                        "description": "Get the advanced configuration options. See Advanced Configuration below for more details.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAdvancedClusterAdvancedConfiguration:getAdvancedClusterAdvancedConfiguration"
                        },
                        "type": "array"
                    },
                    "backupEnabled": {
                        "type": "boolean"
                    },
                    "biConnectorConfigs": {
                        "description": "Configuration settings applied to BI Connector for Atlas on this cluster. See below. **NOTE** Prior version of provider had parameter as `bi_connector`\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAdvancedClusterBiConnectorConfig:getAdvancedClusterBiConnectorConfig"
                        },
                        "type": "array"
                    },
                    "clusterType": {
                        "description": "Type of the cluster that you want to create.\n",
                        "type": "string"
                    },
                    "connectionStrings": {
                        "description": "Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAdvancedClusterConnectionString:getAdvancedClusterConnectionString"
                        },
                        "type": "array"
                    },
                    "createDate": {
                        "type": "string"
                    },
                    "diskSizeGb": {
                        "deprecationMessage": "This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown",
                        "description": "Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.\n",
                        "type": "number"
                    },
                    "encryptionAtRestProvider": {
                        "description": "Possible values are AWS, GCP, AZURE or NONE.\n",
                        "type": "string"
                    },
                    "globalClusterSelfManagedSharding": {
                        "description": "Flag that indicates if cluster uses Atlas-Managed Sharding (false) or Self-Managed Sharding (true).\n",
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "labels": {
                        "deprecationMessage": "This parameter is deprecated and will be removed by September 2024. Please transition to tags.",
                        "description": "Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below. **(DEPRECATED.)** Use `tags` instead.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAdvancedClusterLabel:getAdvancedClusterLabel"
                        },
                        "type": "array"
                    },
                    "mongoDbMajorVersion": {
                        "description": "Version of the cluster to deploy.\n",
                        "type": "string"
                    },
                    "mongoDbVersion": {
                        "description": "Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "paused": {
                        "description": "Flag that indicates whether the cluster is paused or not.\n",
                        "type": "boolean"
                    },
                    "pitEnabled": {
                        "description": "Flag that indicates if the cluster uses Continuous Cloud Backup.\n",
                        "type": "boolean"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "replicationSpecs": {
                        "description": "List of settings that configure your cluster regions. If `use_replication_spec_per_shard = true`, this array has one object per shard representing node configurations in each shard. For replica sets there is only one object representing node configurations. See below.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAdvancedClusterReplicationSpec:getAdvancedClusterReplicationSpec"
                        },
                        "type": "array"
                    },
                    "rootCertType": {
                        "description": "Certificate Authority that MongoDB Atlas clusters use.\n",
                        "type": "string"
                    },
                    "stateName": {
                        "description": "Current state of the cluster. The possible states are:\n",
                        "type": "string"
                    },
                    "tags": {
                        "description": "Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAdvancedClusterTag:getAdvancedClusterTag"
                        },
                        "type": "array"
                    },
                    "terminationProtectionEnabled": {
                        "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n",
                        "type": "boolean"
                    },
                    "useReplicationSpecPerShard": {
                        "type": "boolean"
                    },
                    "versionReleaseSystem": {
                        "description": "Release cadence that Atlas uses for this cluster.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "advancedConfigurations",
                    "backupEnabled",
                    "biConnectorConfigs",
                    "clusterType",
                    "connectionStrings",
                    "createDate",
                    "diskSizeGb",
                    "encryptionAtRestProvider",
                    "globalClusterSelfManagedSharding",
                    "labels",
                    "mongoDbMajorVersion",
                    "mongoDbVersion",
                    "name",
                    "paused",
                    "pitEnabled",
                    "projectId",
                    "replicationSpecs",
                    "rootCertType",
                    "stateName",
                    "tags",
                    "terminationProtectionEnabled",
                    "versionReleaseSystem",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getAdvancedClusters:getAdvancedClusters": {
            "description": "## # Data Source: mongodbatlas.getAdvancedClusters\n\n`mongodbatlas.getAdvancedClusters` describes all Advanced Clusters by the provided project_id. The data source requires your Project ID.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n\u003e **IMPORTANT:**\n\u003cbr\u003e \u0026#8226; Changes to cluster configurations can affect costs. Before making changes, please see [Billing](https://docs.atlas.mongodb.com/billing/).\n\u003cbr\u003e \u0026#8226; If your Atlas project contains a custom role that uses actions introduced in a specific MongoDB version, you cannot create a cluster with a MongoDB version less than that version unless you delete the custom role.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst exampleAdvancedCluster = new mongodbatlas.AdvancedCluster(\"example\", {\n    projectId: \"\u003cYOUR-PROJECT-ID\u003e\",\n    name: \"cluster-test\",\n    clusterType: \"REPLICASET\",\n    replicationSpecs: [{\n        regionConfigs: [{\n            electableSpecs: {\n                instanceSize: \"M5\",\n            },\n            providerName: \"TENANT\",\n            backingProviderName: \"AWS\",\n            regionName: \"US_EAST_1\",\n            priority: 7,\n        }],\n    }],\n});\nconst example = mongodbatlas.getAdvancedClustersOutput({\n    projectId: exampleAdvancedCluster.projectId,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nexample_advanced_cluster = mongodbatlas.AdvancedCluster(\"example\",\n    project_id=\"\u003cYOUR-PROJECT-ID\u003e\",\n    name=\"cluster-test\",\n    cluster_type=\"REPLICASET\",\n    replication_specs=[{\n        \"region_configs\": [{\n            \"electable_specs\": {\n                \"instance_size\": \"M5\",\n            },\n            \"provider_name\": \"TENANT\",\n            \"backing_provider_name\": \"AWS\",\n            \"region_name\": \"US_EAST_1\",\n            \"priority\": 7,\n        }],\n    }])\nexample = mongodbatlas.get_advanced_clusters_output(project_id=example_advanced_cluster.project_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleAdvancedCluster = new Mongodbatlas.AdvancedCluster(\"example\", new()\n    {\n        ProjectId = \"\u003cYOUR-PROJECT-ID\u003e\",\n        Name = \"cluster-test\",\n        ClusterType = \"REPLICASET\",\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M5\",\n                        },\n                        ProviderName = \"TENANT\",\n                        BackingProviderName = \"AWS\",\n                        RegionName = \"US_EAST_1\",\n                        Priority = 7,\n                    },\n                },\n            },\n        },\n    });\n\n    var example = Mongodbatlas.GetAdvancedClusters.Invoke(new()\n    {\n        ProjectId = exampleAdvancedCluster.ProjectId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texampleAdvancedCluster, err := mongodbatlas.NewAdvancedCluster(ctx, \"example\", \u0026mongodbatlas.AdvancedClusterArgs{\n\t\t\tProjectId:   pulumi.String(\"\u003cYOUR-PROJECT-ID\u003e\"),\n\t\t\tName:        pulumi.String(\"cluster-test\"),\n\t\t\tClusterType: pulumi.String(\"REPLICASET\"),\n\t\t\tReplicationSpecs: mongodbatlas.AdvancedClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M5\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName:        pulumi.String(\"TENANT\"),\n\t\t\t\t\t\t\tBackingProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tRegionName:          pulumi.String(\"US_EAST_1\"),\n\t\t\t\t\t\t\tPriority:            pulumi.Int(7),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupAdvancedClustersOutput(ctx, mongodbatlas.GetAdvancedClustersOutputArgs{\n\t\t\tProjectId: exampleAdvancedCluster.ProjectId,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AdvancedCluster;\nimport com.pulumi.mongodbatlas.AdvancedClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.AdvancedClusterReplicationSpecArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetAdvancedClustersArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleAdvancedCluster = new AdvancedCluster(\"exampleAdvancedCluster\", AdvancedClusterArgs.builder()\n            .projectId(\"\u003cYOUR-PROJECT-ID\u003e\")\n            .name(\"cluster-test\")\n            .clusterType(\"REPLICASET\")\n            .replicationSpecs(AdvancedClusterReplicationSpecArgs.builder()\n                .regionConfigs(AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                    .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                        .instanceSize(\"M5\")\n                        .build())\n                    .providerName(\"TENANT\")\n                    .backingProviderName(\"AWS\")\n                    .regionName(\"US_EAST_1\")\n                    .priority(7)\n                    .build())\n                .build())\n            .build());\n\n        final var example = MongodbatlasFunctions.getAdvancedClusters(GetAdvancedClustersArgs.builder()\n            .projectId(exampleAdvancedCluster.projectId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleAdvancedCluster:\n    type: mongodbatlas:AdvancedCluster\n    name: example\n    properties:\n      projectId: \u003cYOUR-PROJECT-ID\u003e\n      name: cluster-test\n      clusterType: REPLICASET\n      replicationSpecs:\n        - regionConfigs:\n            - electableSpecs:\n                instanceSize: M5\n              providerName: TENANT\n              backingProviderName: AWS\n              regionName: US_EAST_1\n              priority: 7\nvariables:\n  example:\n    fn::invoke:\n      Function: mongodbatlas:getAdvancedClusters\n      Arguments:\n        projectId: ${exampleAdvancedCluster.projectId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Example using latest sharding configurations with independent shard scaling in the cluster\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst example = new mongodbatlas.AdvancedCluster(\"example\", {\n    projectId: \"\u003cYOUR-PROJECT-ID\u003e\",\n    name: \"cluster-test\",\n    backupEnabled: false,\n    clusterType: \"SHARDED\",\n    replicationSpecs: [\n        {\n            regionConfigs: [{\n                electableSpecs: {\n                    instanceSize: \"M30\",\n                    diskIops: 3000,\n                    nodeCount: 3,\n                },\n                providerName: \"AWS\",\n                priority: 7,\n                regionName: \"EU_WEST_1\",\n            }],\n        },\n        {\n            regionConfigs: [{\n                electableSpecs: {\n                    instanceSize: \"M40\",\n                    diskIops: 3000,\n                    nodeCount: 3,\n                },\n                providerName: \"AWS\",\n                priority: 7,\n                regionName: \"EU_WEST_1\",\n            }],\n        },\n    ],\n});\nconst example-asym = mongodbatlas.getAdvancedClusterOutput({\n    projectId: example.projectId,\n    name: example.name,\n    useReplicationSpecPerShard: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nexample = mongodbatlas.AdvancedCluster(\"example\",\n    project_id=\"\u003cYOUR-PROJECT-ID\u003e\",\n    name=\"cluster-test\",\n    backup_enabled=False,\n    cluster_type=\"SHARDED\",\n    replication_specs=[\n        {\n            \"region_configs\": [{\n                \"electable_specs\": {\n                    \"instance_size\": \"M30\",\n                    \"disk_iops\": 3000,\n                    \"node_count\": 3,\n                },\n                \"provider_name\": \"AWS\",\n                \"priority\": 7,\n                \"region_name\": \"EU_WEST_1\",\n            }],\n        },\n        {\n            \"region_configs\": [{\n                \"electable_specs\": {\n                    \"instance_size\": \"M40\",\n                    \"disk_iops\": 3000,\n                    \"node_count\": 3,\n                },\n                \"provider_name\": \"AWS\",\n                \"priority\": 7,\n                \"region_name\": \"EU_WEST_1\",\n            }],\n        },\n    ])\nexample_asym = mongodbatlas.get_advanced_cluster_output(project_id=example.project_id,\n    name=example.name,\n    use_replication_spec_per_shard=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Mongodbatlas.AdvancedCluster(\"example\", new()\n    {\n        ProjectId = \"\u003cYOUR-PROJECT-ID\u003e\",\n        Name = \"cluster-test\",\n        BackupEnabled = false,\n        ClusterType = \"SHARDED\",\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M30\",\n                            DiskIops = 3000,\n                            NodeCount = 3,\n                        },\n                        ProviderName = \"AWS\",\n                        Priority = 7,\n                        RegionName = \"EU_WEST_1\",\n                    },\n                },\n            },\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M40\",\n                            DiskIops = 3000,\n                            NodeCount = 3,\n                        },\n                        ProviderName = \"AWS\",\n                        Priority = 7,\n                        RegionName = \"EU_WEST_1\",\n                    },\n                },\n            },\n        },\n    });\n\n    var example_asym = Mongodbatlas.GetAdvancedCluster.Invoke(new()\n    {\n        ProjectId = example.ProjectId,\n        Name = example.Name,\n        UseReplicationSpecPerShard = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := mongodbatlas.NewAdvancedCluster(ctx, \"example\", \u0026mongodbatlas.AdvancedClusterArgs{\n\t\t\tProjectId:     pulumi.String(\"\u003cYOUR-PROJECT-ID\u003e\"),\n\t\t\tName:          pulumi.String(\"cluster-test\"),\n\t\t\tBackupEnabled: pulumi.Bool(false),\n\t\t\tClusterType:   pulumi.String(\"SHARDED\"),\n\t\t\tReplicationSpecs: mongodbatlas.AdvancedClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M30\"),\n\t\t\t\t\t\t\t\tDiskIops:     pulumi.Int(3000),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(3),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tPriority:     pulumi.Int(7),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"EU_WEST_1\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M40\"),\n\t\t\t\t\t\t\t\tDiskIops:     pulumi.Int(3000),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(3),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tPriority:     pulumi.Int(7),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"EU_WEST_1\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupAdvancedClusterOutput(ctx, mongodbatlas.GetAdvancedClusterOutputArgs{\n\t\t\tProjectId:                  example.ProjectId,\n\t\t\tName:                       example.Name,\n\t\t\tUseReplicationSpecPerShard: pulumi.Bool(true),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AdvancedCluster;\nimport com.pulumi.mongodbatlas.AdvancedClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.AdvancedClusterReplicationSpecArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetAdvancedClusterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new AdvancedCluster(\"example\", AdvancedClusterArgs.builder()\n            .projectId(\"\u003cYOUR-PROJECT-ID\u003e\")\n            .name(\"cluster-test\")\n            .backupEnabled(false)\n            .clusterType(\"SHARDED\")\n            .replicationSpecs(            \n                AdvancedClusterReplicationSpecArgs.builder()\n                    .regionConfigs(AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                        .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                            .instanceSize(\"M30\")\n                            .diskIops(3000)\n                            .nodeCount(3)\n                            .build())\n                        .providerName(\"AWS\")\n                        .priority(7)\n                        .regionName(\"EU_WEST_1\")\n                        .build())\n                    .build(),\n                AdvancedClusterReplicationSpecArgs.builder()\n                    .regionConfigs(AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                        .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                            .instanceSize(\"M40\")\n                            .diskIops(3000)\n                            .nodeCount(3)\n                            .build())\n                        .providerName(\"AWS\")\n                        .priority(7)\n                        .regionName(\"EU_WEST_1\")\n                        .build())\n                    .build())\n            .build());\n\n        final var example-asym = MongodbatlasFunctions.getAdvancedCluster(GetAdvancedClusterArgs.builder()\n            .projectId(example.projectId())\n            .name(example.name())\n            .useReplicationSpecPerShard(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: mongodbatlas:AdvancedCluster\n    properties:\n      projectId: \u003cYOUR-PROJECT-ID\u003e\n      name: cluster-test\n      backupEnabled: false\n      clusterType: SHARDED\n      replicationSpecs:\n        - regionConfigs:\n            - electableSpecs:\n                instanceSize: M30\n                diskIops: 3000\n                nodeCount: 3\n              providerName: AWS\n              priority: 7\n              regionName: EU_WEST_1\n        - regionConfigs:\n            - electableSpecs:\n                instanceSize: M40\n                diskIops: 3000\n                nodeCount: 3\n              providerName: AWS\n              priority: 7\n              regionName: EU_WEST_1\nvariables:\n  example-asym:\n    fn::invoke:\n      Function: mongodbatlas:getAdvancedCluster\n      Arguments:\n        projectId: ${example.projectId}\n        name: ${example.name}\n        useReplicationSpecPerShard: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAdvancedClusters.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to get the clusters.\n"
                    },
                    "useReplicationSpecPerShard": {
                        "type": "boolean",
                        "description": "Set this field to true to allow the data source to use the latest schema representing each shard with an individual `replication_specs` object. This enables representing clusters with independent shard scaling. **Note:** If not set to true, this data source return all clusters except clusters with asymmetric shards.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAdvancedClusters.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "description": "A list where each represents a Cluster. See below for more details.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAdvancedClustersResult:getAdvancedClustersResult"
                        },
                        "type": "array"
                    },
                    "useReplicationSpecPerShard": {
                        "type": "boolean"
                    }
                },
                "required": [
                    "projectId",
                    "results",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getAlertConfiguration:getAlertConfiguration": {
            "description": "## # Data Source: mongodbatlas.AlertConfiguration\n\n`mongodbatlas.AlertConfiguration` describes an Alert Configuration.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find **group_id** in the official documentation.\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testAlertConfiguration = new mongodbatlas.AlertConfiguration(\"test\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    eventType: \"OUTSIDE_METRIC_THRESHOLD\",\n    enabled: true,\n    notifications: [{\n        typeName: \"GROUP\",\n        intervalMin: 5,\n        delayMin: 0,\n        smsEnabled: false,\n        emailEnabled: true,\n    }],\n    matchers: [{\n        fieldName: \"HOSTNAME_AND_PORT\",\n        operator: \"EQUALS\",\n        value: \"SECONDARY\",\n    }],\n    metricThresholdConfig: {\n        metricName: \"ASSERT_REGULAR\",\n        operator: \"LESS_THAN\",\n        threshold: 99,\n        units: \"RAW\",\n        mode: \"AVERAGE\",\n    },\n});\nconst test = mongodbatlas.getAlertConfigurationOutput({\n    projectId: testAlertConfiguration.projectId,\n    alertConfigurationId: testAlertConfiguration.alertConfigurationId,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_alert_configuration = mongodbatlas.AlertConfiguration(\"test\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    event_type=\"OUTSIDE_METRIC_THRESHOLD\",\n    enabled=True,\n    notifications=[{\n        \"type_name\": \"GROUP\",\n        \"interval_min\": 5,\n        \"delay_min\": 0,\n        \"sms_enabled\": False,\n        \"email_enabled\": True,\n    }],\n    matchers=[{\n        \"field_name\": \"HOSTNAME_AND_PORT\",\n        \"operator\": \"EQUALS\",\n        \"value\": \"SECONDARY\",\n    }],\n    metric_threshold_config={\n        \"metric_name\": \"ASSERT_REGULAR\",\n        \"operator\": \"LESS_THAN\",\n        \"threshold\": 99,\n        \"units\": \"RAW\",\n        \"mode\": \"AVERAGE\",\n    })\ntest = mongodbatlas.get_alert_configuration_output(project_id=test_alert_configuration.project_id,\n    alert_configuration_id=test_alert_configuration.alert_configuration_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testAlertConfiguration = new Mongodbatlas.AlertConfiguration(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        EventType = \"OUTSIDE_METRIC_THRESHOLD\",\n        Enabled = true,\n        Notifications = new[]\n        {\n            new Mongodbatlas.Inputs.AlertConfigurationNotificationArgs\n            {\n                TypeName = \"GROUP\",\n                IntervalMin = 5,\n                DelayMin = 0,\n                SmsEnabled = false,\n                EmailEnabled = true,\n            },\n        },\n        Matchers = new[]\n        {\n            new Mongodbatlas.Inputs.AlertConfigurationMatcherArgs\n            {\n                FieldName = \"HOSTNAME_AND_PORT\",\n                Operator = \"EQUALS\",\n                Value = \"SECONDARY\",\n            },\n        },\n        MetricThresholdConfig = new Mongodbatlas.Inputs.AlertConfigurationMetricThresholdConfigArgs\n        {\n            MetricName = \"ASSERT_REGULAR\",\n            Operator = \"LESS_THAN\",\n            Threshold = 99,\n            Units = \"RAW\",\n            Mode = \"AVERAGE\",\n        },\n    });\n\n    var test = Mongodbatlas.GetAlertConfiguration.Invoke(new()\n    {\n        ProjectId = testAlertConfiguration.ProjectId,\n        AlertConfigurationId = testAlertConfiguration.AlertConfigurationId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestAlertConfiguration, err := mongodbatlas.NewAlertConfiguration(ctx, \"test\", \u0026mongodbatlas.AlertConfigurationArgs{\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tEventType: pulumi.String(\"OUTSIDE_METRIC_THRESHOLD\"),\n\t\t\tEnabled:   pulumi.Bool(true),\n\t\t\tNotifications: mongodbatlas.AlertConfigurationNotificationArray{\n\t\t\t\t\u0026mongodbatlas.AlertConfigurationNotificationArgs{\n\t\t\t\t\tTypeName:     pulumi.String(\"GROUP\"),\n\t\t\t\t\tIntervalMin:  pulumi.Int(5),\n\t\t\t\t\tDelayMin:     pulumi.Int(0),\n\t\t\t\t\tSmsEnabled:   pulumi.Bool(false),\n\t\t\t\t\tEmailEnabled: pulumi.Bool(true),\n\t\t\t\t},\n\t\t\t},\n\t\t\tMatchers: mongodbatlas.AlertConfigurationMatcherArray{\n\t\t\t\t\u0026mongodbatlas.AlertConfigurationMatcherArgs{\n\t\t\t\t\tFieldName: pulumi.String(\"HOSTNAME_AND_PORT\"),\n\t\t\t\t\tOperator:  pulumi.String(\"EQUALS\"),\n\t\t\t\t\tValue:     pulumi.String(\"SECONDARY\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tMetricThresholdConfig: \u0026mongodbatlas.AlertConfigurationMetricThresholdConfigArgs{\n\t\t\t\tMetricName: pulumi.String(\"ASSERT_REGULAR\"),\n\t\t\t\tOperator:   pulumi.String(\"LESS_THAN\"),\n\t\t\t\tThreshold:  pulumi.Float64(99),\n\t\t\t\tUnits:      pulumi.String(\"RAW\"),\n\t\t\t\tMode:       pulumi.String(\"AVERAGE\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupAlertConfigurationOutput(ctx, mongodbatlas.GetAlertConfigurationOutputArgs{\n\t\t\tProjectId:            testAlertConfiguration.ProjectId,\n\t\t\tAlertConfigurationId: testAlertConfiguration.AlertConfigurationId,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AlertConfiguration;\nimport com.pulumi.mongodbatlas.AlertConfigurationArgs;\nimport com.pulumi.mongodbatlas.inputs.AlertConfigurationNotificationArgs;\nimport com.pulumi.mongodbatlas.inputs.AlertConfigurationMatcherArgs;\nimport com.pulumi.mongodbatlas.inputs.AlertConfigurationMetricThresholdConfigArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetAlertConfigurationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testAlertConfiguration = new AlertConfiguration(\"testAlertConfiguration\", AlertConfigurationArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .eventType(\"OUTSIDE_METRIC_THRESHOLD\")\n            .enabled(true)\n            .notifications(AlertConfigurationNotificationArgs.builder()\n                .typeName(\"GROUP\")\n                .intervalMin(5)\n                .delayMin(0)\n                .smsEnabled(false)\n                .emailEnabled(true)\n                .build())\n            .matchers(AlertConfigurationMatcherArgs.builder()\n                .fieldName(\"HOSTNAME_AND_PORT\")\n                .operator(\"EQUALS\")\n                .value(\"SECONDARY\")\n                .build())\n            .metricThresholdConfig(AlertConfigurationMetricThresholdConfigArgs.builder()\n                .metricName(\"ASSERT_REGULAR\")\n                .operator(\"LESS_THAN\")\n                .threshold(99)\n                .units(\"RAW\")\n                .mode(\"AVERAGE\")\n                .build())\n            .build());\n\n        final var test = MongodbatlasFunctions.getAlertConfiguration(GetAlertConfigurationArgs.builder()\n            .projectId(testAlertConfiguration.projectId())\n            .alertConfigurationId(testAlertConfiguration.alertConfigurationId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testAlertConfiguration:\n    type: mongodbatlas:AlertConfiguration\n    name: test\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      eventType: OUTSIDE_METRIC_THRESHOLD\n      enabled: true\n      notifications:\n        - typeName: GROUP\n          intervalMin: 5\n          delayMin: 0\n          smsEnabled: false\n          emailEnabled: true\n      matchers:\n        - fieldName: HOSTNAME_AND_PORT\n          operator: EQUALS\n          value: SECONDARY\n      metricThresholdConfig:\n        metricName: ASSERT_REGULAR\n        operator: LESS_THAN\n        threshold: 99\n        units: RAW\n        mode: AVERAGE\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getAlertConfiguration\n      Arguments:\n        projectId: ${testAlertConfiguration.projectId}\n        alertConfigurationId: ${testAlertConfiguration.alertConfigurationId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\u003e **NOTE:** In order to allow for a fast pace of change to alert variables some validations have been removed from this resource in order to unblock alert creation. Impacted areas have links to the MongoDB Atlas API documentation so always check it for the most current information: https://docs.atlas.mongodb.com/reference/api/alert-configurations-create-config/\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testAlertConfiguration = new mongodbatlas.AlertConfiguration(\"test\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    eventType: \"REPLICATION_OPLOG_WINDOW_RUNNING_OUT\",\n    enabled: true,\n    notifications: [{\n        typeName: \"GROUP\",\n        intervalMin: 5,\n        delayMin: 0,\n        smsEnabled: false,\n        emailEnabled: true,\n        roles: [\"GROUP_CLUSTER_MANAGER\"],\n    }],\n    matchers: [{\n        fieldName: \"HOSTNAME_AND_PORT\",\n        operator: \"EQUALS\",\n        value: \"SECONDARY\",\n    }],\n    thresholdConfig: {\n        operator: \"LESS_THAN\",\n        threshold: 1,\n        units: \"HOURS\",\n    },\n});\nconst test = mongodbatlas.getAlertConfigurationOutput({\n    projectId: testAlertConfiguration.projectId,\n    alertConfigurationId: testAlertConfiguration.alertConfigurationId,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_alert_configuration = mongodbatlas.AlertConfiguration(\"test\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    event_type=\"REPLICATION_OPLOG_WINDOW_RUNNING_OUT\",\n    enabled=True,\n    notifications=[{\n        \"type_name\": \"GROUP\",\n        \"interval_min\": 5,\n        \"delay_min\": 0,\n        \"sms_enabled\": False,\n        \"email_enabled\": True,\n        \"roles\": [\"GROUP_CLUSTER_MANAGER\"],\n    }],\n    matchers=[{\n        \"field_name\": \"HOSTNAME_AND_PORT\",\n        \"operator\": \"EQUALS\",\n        \"value\": \"SECONDARY\",\n    }],\n    threshold_config={\n        \"operator\": \"LESS_THAN\",\n        \"threshold\": 1,\n        \"units\": \"HOURS\",\n    })\ntest = mongodbatlas.get_alert_configuration_output(project_id=test_alert_configuration.project_id,\n    alert_configuration_id=test_alert_configuration.alert_configuration_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testAlertConfiguration = new Mongodbatlas.AlertConfiguration(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        EventType = \"REPLICATION_OPLOG_WINDOW_RUNNING_OUT\",\n        Enabled = true,\n        Notifications = new[]\n        {\n            new Mongodbatlas.Inputs.AlertConfigurationNotificationArgs\n            {\n                TypeName = \"GROUP\",\n                IntervalMin = 5,\n                DelayMin = 0,\n                SmsEnabled = false,\n                EmailEnabled = true,\n                Roles = new[]\n                {\n                    \"GROUP_CLUSTER_MANAGER\",\n                },\n            },\n        },\n        Matchers = new[]\n        {\n            new Mongodbatlas.Inputs.AlertConfigurationMatcherArgs\n            {\n                FieldName = \"HOSTNAME_AND_PORT\",\n                Operator = \"EQUALS\",\n                Value = \"SECONDARY\",\n            },\n        },\n        ThresholdConfig = new Mongodbatlas.Inputs.AlertConfigurationThresholdConfigArgs\n        {\n            Operator = \"LESS_THAN\",\n            Threshold = 1,\n            Units = \"HOURS\",\n        },\n    });\n\n    var test = Mongodbatlas.GetAlertConfiguration.Invoke(new()\n    {\n        ProjectId = testAlertConfiguration.ProjectId,\n        AlertConfigurationId = testAlertConfiguration.AlertConfigurationId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestAlertConfiguration, err := mongodbatlas.NewAlertConfiguration(ctx, \"test\", \u0026mongodbatlas.AlertConfigurationArgs{\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tEventType: pulumi.String(\"REPLICATION_OPLOG_WINDOW_RUNNING_OUT\"),\n\t\t\tEnabled:   pulumi.Bool(true),\n\t\t\tNotifications: mongodbatlas.AlertConfigurationNotificationArray{\n\t\t\t\t\u0026mongodbatlas.AlertConfigurationNotificationArgs{\n\t\t\t\t\tTypeName:     pulumi.String(\"GROUP\"),\n\t\t\t\t\tIntervalMin:  pulumi.Int(5),\n\t\t\t\t\tDelayMin:     pulumi.Int(0),\n\t\t\t\t\tSmsEnabled:   pulumi.Bool(false),\n\t\t\t\t\tEmailEnabled: pulumi.Bool(true),\n\t\t\t\t\tRoles: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_CLUSTER_MANAGER\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tMatchers: mongodbatlas.AlertConfigurationMatcherArray{\n\t\t\t\t\u0026mongodbatlas.AlertConfigurationMatcherArgs{\n\t\t\t\t\tFieldName: pulumi.String(\"HOSTNAME_AND_PORT\"),\n\t\t\t\t\tOperator:  pulumi.String(\"EQUALS\"),\n\t\t\t\t\tValue:     pulumi.String(\"SECONDARY\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tThresholdConfig: \u0026mongodbatlas.AlertConfigurationThresholdConfigArgs{\n\t\t\t\tOperator:  pulumi.String(\"LESS_THAN\"),\n\t\t\t\tThreshold: pulumi.Float64(1),\n\t\t\t\tUnits:     pulumi.String(\"HOURS\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupAlertConfigurationOutput(ctx, mongodbatlas.GetAlertConfigurationOutputArgs{\n\t\t\tProjectId:            testAlertConfiguration.ProjectId,\n\t\t\tAlertConfigurationId: testAlertConfiguration.AlertConfigurationId,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AlertConfiguration;\nimport com.pulumi.mongodbatlas.AlertConfigurationArgs;\nimport com.pulumi.mongodbatlas.inputs.AlertConfigurationNotificationArgs;\nimport com.pulumi.mongodbatlas.inputs.AlertConfigurationMatcherArgs;\nimport com.pulumi.mongodbatlas.inputs.AlertConfigurationThresholdConfigArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetAlertConfigurationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testAlertConfiguration = new AlertConfiguration(\"testAlertConfiguration\", AlertConfigurationArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .eventType(\"REPLICATION_OPLOG_WINDOW_RUNNING_OUT\")\n            .enabled(true)\n            .notifications(AlertConfigurationNotificationArgs.builder()\n                .typeName(\"GROUP\")\n                .intervalMin(5)\n                .delayMin(0)\n                .smsEnabled(false)\n                .emailEnabled(true)\n                .roles(\"GROUP_CLUSTER_MANAGER\")\n                .build())\n            .matchers(AlertConfigurationMatcherArgs.builder()\n                .fieldName(\"HOSTNAME_AND_PORT\")\n                .operator(\"EQUALS\")\n                .value(\"SECONDARY\")\n                .build())\n            .thresholdConfig(AlertConfigurationThresholdConfigArgs.builder()\n                .operator(\"LESS_THAN\")\n                .threshold(1)\n                .units(\"HOURS\")\n                .build())\n            .build());\n\n        final var test = MongodbatlasFunctions.getAlertConfiguration(GetAlertConfigurationArgs.builder()\n            .projectId(testAlertConfiguration.projectId())\n            .alertConfigurationId(testAlertConfiguration.alertConfigurationId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testAlertConfiguration:\n    type: mongodbatlas:AlertConfiguration\n    name: test\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      eventType: REPLICATION_OPLOG_WINDOW_RUNNING_OUT\n      enabled: true\n      notifications:\n        - typeName: GROUP\n          intervalMin: 5\n          delayMin: 0\n          smsEnabled: false\n          emailEnabled: true\n          roles:\n            - GROUP_CLUSTER_MANAGER\n      matchers:\n        - fieldName: HOSTNAME_AND_PORT\n          operator: EQUALS\n          value: SECONDARY\n      thresholdConfig:\n        operator: LESS_THAN\n        threshold: 1\n        units: HOURS\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getAlertConfiguration\n      Arguments:\n        projectId: ${testAlertConfiguration.projectId}\n        alertConfigurationId: ${testAlertConfiguration.alertConfigurationId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nUtilize data_source to generate resource hcl and import statement. Useful if you have a specific alert_configuration_id and are looking to manage it as is in state. To import all alerts, refer to the documentation on data_source_mongodbatlas_alert_configurations\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = mongodbatlas.getAlertConfiguration({\n    projectId: projectId,\n    alertConfigurationId: alertConfigurationId,\n    outputs: [\n        {\n            type: \"resource_hcl\",\n            label: \"test\",\n        },\n        {\n            type: \"resource_import\",\n            label: \"test\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.get_alert_configuration(project_id=project_id,\n    alert_configuration_id=alert_configuration_id,\n    outputs=[\n        {\n            \"type\": \"resource_hcl\",\n            \"label\": \"test\",\n        },\n        {\n            \"type\": \"resource_import\",\n            \"label\": \"test\",\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Mongodbatlas.GetAlertConfiguration.Invoke(new()\n    {\n        ProjectId = projectId,\n        AlertConfigurationId = alertConfigurationId,\n        Outputs = new[]\n        {\n            new Mongodbatlas.Inputs.GetAlertConfigurationOutputInputArgs\n            {\n                Type = \"resource_hcl\",\n                Label = \"test\",\n            },\n            new Mongodbatlas.Inputs.GetAlertConfigurationOutputInputArgs\n            {\n                Type = \"resource_import\",\n                Label = \"test\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.LookupAlertConfiguration(ctx, \u0026mongodbatlas.LookupAlertConfigurationArgs{\n\t\t\tProjectId:            projectId,\n\t\t\tAlertConfigurationId: alertConfigurationId,\n\t\t\tOutputs: []mongodbatlas.GetAlertConfigurationOutput{\n\t\t\t\t{\n\t\t\t\t\tType:  \"resource_hcl\",\n\t\t\t\t\tLabel: pulumi.StringRef(\"test\"),\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType:  \"resource_import\",\n\t\t\t\t\tLabel: pulumi.StringRef(\"test\"),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetAlertConfigurationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getAlertConfiguration(GetAlertConfigurationArgs.builder()\n            .projectId(projectId)\n            .alertConfigurationId(alertConfigurationId)\n            .outputs(            \n                GetAlertConfigurationOutputArgs.builder()\n                    .type(\"resource_hcl\")\n                    .label(\"test\")\n                    .build(),\n                GetAlertConfigurationOutputArgs.builder()\n                    .type(\"resource_import\")\n                    .label(\"test\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getAlertConfiguration\n      Arguments:\n        projectId: ${projectId}\n        alertConfigurationId: ${alertConfigurationId}\n        outputs:\n          - type: resource_hcl\n            label: test\n          - type: resource_import\n            label: test\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAlertConfiguration.\n",
                "properties": {
                    "alertConfigurationId": {
                        "type": "string",
                        "description": "Unique identifier for the alert configuration.\n"
                    },
                    "outputs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAlertConfigurationOutput:getAlertConfigurationOutput"
                        },
                        "description": "List of formatted output requested for this alert configuration\n* `output.#.type` - (Required) If the output is requested, you must specify its type. The format is computed as `output.#.value`, the following are the supported types:\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The ID of the project where the alert configuration will create.\n"
                    }
                },
                "type": "object",
                "required": [
                    "alertConfigurationId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAlertConfiguration.\n",
                "properties": {
                    "alertConfigurationId": {
                        "type": "string"
                    },
                    "created": {
                        "description": "Timestamp in ISO 8601 date and time format in UTC when this alert configuration was created.\n",
                        "type": "string"
                    },
                    "enabled": {
                        "description": "If set to true, the alert configuration is enabled. If enabled is not exported it is set to false.\n",
                        "type": "boolean"
                    },
                    "eventType": {
                        "description": "The type of event that will trigger an alert.\n",
                        "type": "string"
                    },
                    "id": {
                        "type": "string"
                    },
                    "matchers": {
                        "description": "Rules to apply when matching an object against this alert configuration. See matchers.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAlertConfigurationMatcher:getAlertConfigurationMatcher"
                        },
                        "type": "array"
                    },
                    "metricThresholdConfigs": {
                        "description": "The threshold that causes an alert to be triggered. Required if `event_type_name` : `OUTSIDE_METRIC_THRESHOLD` or `OUTSIDE_SERVERLESS_METRIC_THRESHOLD`. See metric threshold config.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAlertConfigurationMetricThresholdConfig:getAlertConfigurationMetricThresholdConfig"
                        },
                        "type": "array"
                    },
                    "notifications": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAlertConfigurationNotification:getAlertConfigurationNotification"
                        },
                        "type": "array"
                    },
                    "outputs": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAlertConfigurationOutput:getAlertConfigurationOutput"
                        },
                        "type": "array"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "thresholdConfigs": {
                        "description": "Threshold that triggers an alert. Required if `event_type_name` is any value other than `OUTSIDE_METRIC_THRESHOLD` or `OUTSIDE_SERVERLESS_METRIC_THRESHOLD`. See threshold config.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAlertConfigurationThresholdConfig:getAlertConfigurationThresholdConfig"
                        },
                        "type": "array"
                    },
                    "updated": {
                        "description": "Timestamp in ISO 8601 date and time format in UTC when this alert configuration was last updated.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "alertConfigurationId",
                    "created",
                    "enabled",
                    "eventType",
                    "id",
                    "matchers",
                    "metricThresholdConfigs",
                    "notifications",
                    "projectId",
                    "thresholdConfigs",
                    "updated"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getAlertConfigurations:getAlertConfigurations": {
            "description": "## # Data Source: mongodbatlas.getAlertConfigurations\n\n`mongodbatlas.getAlertConfigurations` describes all Alert Configurations by the provided project_id. The data source requires your Project ID.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAlertConfigurations.\n",
                "properties": {
                    "listOptions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAlertConfigurationsListOption:getAlertConfigurationsListOption"
                        },
                        "description": "Arguments that dictate how many and which results are returned by the data source\n* `list_options.page_num` - Which page of results to retrieve (default to first page)\n* `list_options.items_per_page` - How many alerts to retrieve per page (default 100)\n* `list_options.include_count` - Whether to include total count of results in the response (default false)\n"
                    },
                    "outputTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of requested string formatted output to be included on each individual result. Options are `resource_hcl` and `resource_import`. Available to make it easy to gather resource statements for existing alert configurations, and corresponding import statements to import said resource state into the statefile.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to get the alert configurations.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAlertConfigurations.\n",
                "properties": {
                    "id": {
                        "type": "string"
                    },
                    "listOptions": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAlertConfigurationsListOption:getAlertConfigurationsListOption"
                        },
                        "type": "array"
                    },
                    "outputTypes": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "projectId": {
                        "description": "The ID of the project where the alert configuration exists\n",
                        "type": "string"
                    },
                    "results": {
                        "description": "A list of alert configurations for the project_id, constrained by the `list_options`.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAlertConfigurationsResult:getAlertConfigurationsResult"
                        },
                        "type": "array"
                    },
                    "totalCount": {
                        "description": "Total count of results\n",
                        "type": "integer"
                    }
                },
                "required": [
                    "id",
                    "projectId",
                    "results",
                    "totalCount"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getApiKey:getApiKey": {
            "description": "## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getApiKey.\n",
                "properties": {
                    "apiKeyId": {
                        "type": "string",
                        "description": "Unique identifier for the organization API key.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Unique identifier for the organization.\n"
                    }
                },
                "type": "object",
                "required": [
                    "apiKeyId",
                    "orgId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getApiKey.\n",
                "properties": {
                    "apiKeyId": {
                        "type": "string"
                    },
                    "description": {
                        "description": "Description of this Organization API key.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "publicKey": {
                        "description": "Public key for this Organization API key.\n",
                        "type": "string"
                    },
                    "roleNames": {
                        "description": "Name of the role. This resource returns all the roles the user has in Atlas.\nThe following are valid roles:\n* `ORG_OWNER`\n* `ORG_GROUP_CREATOR`\n* `ORG_BILLING_ADMIN`\n* `ORG_READ_ONLY`\n* `ORG_MEMBER`\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "apiKeyId",
                    "description",
                    "orgId",
                    "publicKey",
                    "roleNames",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getApiKeys:getApiKeys": {
            "description": "## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getApiKeys.\n",
                "properties": {
                    "itemsPerPage": {
                        "type": "integer",
                        "description": "Number of items to return per page, up to a maximum of 500. Defaults to `100`.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Unique identifier for the organization whose API keys you want to retrieve.\n"
                    },
                    "pageNum": {
                        "type": "integer",
                        "description": "The page to return. Defaults to `1`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "orgId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getApiKeys.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "results": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getApiKeysResult:getApiKeysResult"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "orgId",
                    "results",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getAtlasUser:getAtlasUser": {
            "description": "## # Data Source: mongodbatlas.getAtlasUser\n\n`mongodbatlas.getAtlasUser` Provides a MongoDB Atlas User.\n\n\u003e **NOTE:** If you are the owner of a MongoDB Atlas organization or project, you can also retrieve the user profile for any user with membership in that organization or project.\n\n## Example Usage\n\n### Using user_id attribute to query\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = mongodbatlas.getAtlasUser({\n    userId: \"\u003cUSER_ID\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.get_atlas_user(user_id=\"\u003cUSER_ID\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Mongodbatlas.GetAtlasUser.Invoke(new()\n    {\n        UserId = \"\u003cUSER_ID\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.GetAtlasUser(ctx, \u0026mongodbatlas.GetAtlasUserArgs{\n\t\t\tUserId: pulumi.StringRef(\"\u003cUSER_ID\u003e\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetAtlasUserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getAtlasUser(GetAtlasUserArgs.builder()\n            .userId(\"\u003cUSER_ID\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getAtlasUser\n      Arguments:\n        userId: \u003cUSER_ID\u003e\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Using username attribute to query\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = mongodbatlas.getAtlasUser({\n    username: \"\u003cUSERNAME\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.get_atlas_user(username=\"\u003cUSERNAME\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Mongodbatlas.GetAtlasUser.Invoke(new()\n    {\n        Username = \"\u003cUSERNAME\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.GetAtlasUser(ctx, \u0026mongodbatlas.GetAtlasUserArgs{\n\t\t\tUsername: pulumi.StringRef(\"\u003cUSERNAME\u003e\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetAtlasUserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getAtlasUser(GetAtlasUserArgs.builder()\n            .username(\"\u003cUSERNAME\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getAtlasUser\n      Arguments:\n        username: \u003cUSERNAME\u003e\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAtlasUser.\n",
                "properties": {
                    "userId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies this user.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Email address that belongs to the MongoDB Atlas user account. You can't modify this address after creating the user.\n\n\u003e **IMPORTANT:** Either `user_id` or `username` must be configurated.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getAtlasUser.\n",
                "properties": {
                    "country": {
                        "description": "Two alphabet characters that identifies MongoDB Atlas user's geographic location. This parameter uses the ISO 3166-1a2 code format.\n",
                        "type": "string"
                    },
                    "createdAt": {
                        "description": "Date and time when the current account is created. This value is in the ISO 8601 timestamp format in UTC.\n",
                        "type": "string"
                    },
                    "emailAddress": {
                        "description": "Email address that belongs to the MongoDB Atlas user.\n",
                        "type": "string"
                    },
                    "firstName": {
                        "description": "First or given name that belongs to the MongoDB Atlas user.\n",
                        "type": "string"
                    },
                    "id": {
                        "deprecationMessage": "Please use user_id id attribute instead",
                        "type": "string"
                    },
                    "lastAuth": {
                        "description": "Date and time when the current account last authenticated. This value is in the ISO 8601 timestamp format in UTC.\n",
                        "type": "string"
                    },
                    "lastName": {
                        "description": "Last name, family name, or surname that belongs to the MongoDB Atlas user.\n",
                        "type": "string"
                    },
                    "links": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAtlasUserLink:getAtlasUserLink"
                        },
                        "type": "array"
                    },
                    "mobileNumber": {
                        "description": "Mobile phone number that belongs to the MongoDB Atlas user.\n",
                        "type": "string"
                    },
                    "roles": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAtlasUserRole:getAtlasUserRole"
                        },
                        "type": "array"
                    },
                    "teamIds": {
                        "description": "List of unique 24-hexadecimal digit strings that identifies the teams to which this MongoDB Atlas user belongs.\n* `links.#.href` - Uniform Resource Locator (URL) that points another API resource to which this response has some relationship. This URL often begins with https://cloud.mongodb.com/api/atlas.\n* `links.#.rel` - Uniform Resource Locator (URL) that defines the semantic relationship between this resource and another API resource. This URL often begins with https://cloud.mongodb.com/api/atlas.\n* `roles.#.group_id` - Unique 24-hexadecimal digit string that identifies the project to which this role belongs. You can set a value for this parameter or orgId but not both in the same request.\n* `roles.#.org_id` - Unique 24-hexadecimal digit string that identifies the organization to which this role belongs. You can set a value for this parameter or groupId but not both in the same request.\n* `roles.#.role_name` - Human-readable label that identifies the collection of privileges that MongoDB Atlas grants a specific API key, user, or team. These roles include organization- and project-level roles. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#service-user-roles) describes the valid roles that can be assigned.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "userId": {
                        "type": "string"
                    },
                    "username": {
                        "type": "string"
                    }
                },
                "required": [
                    "country",
                    "createdAt",
                    "emailAddress",
                    "firstName",
                    "id",
                    "lastAuth",
                    "lastName",
                    "links",
                    "mobileNumber",
                    "roles",
                    "teamIds"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getAtlasUsers:getAtlasUsers": {
            "description": "## # Data Source: atlas_users\n\n`atlas_users` provides Atlas Users associated with a specified Organization, Project, or Team.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n## Example Usage\n\n### Using org_id attribute to query Organization Atlas Users\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = mongodbatlas.getAtlasUsers({\n    orgId: \"\u003cORG_ID\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.get_atlas_users(org_id=\"\u003cORG_ID\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Mongodbatlas.GetAtlasUsers.Invoke(new()\n    {\n        OrgId = \"\u003cORG_ID\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.LookupAtlasUsers(ctx, \u0026mongodbatlas.LookupAtlasUsersArgs{\n\t\t\tOrgId: pulumi.StringRef(\"\u003cORG_ID\u003e\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetAtlasUsersArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getAtlasUsers(GetAtlasUsersArgs.builder()\n            .orgId(\"\u003cORG_ID\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getAtlasUsers\n      Arguments:\n        orgId: \u003cORG_ID\u003e\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Using project_id attribute to query Project Atlas Users\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = mongodbatlas.getAtlasUsers({\n    projectId: \"\u003cPROJECT_ID\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.get_atlas_users(project_id=\"\u003cPROJECT_ID\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Mongodbatlas.GetAtlasUsers.Invoke(new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.LookupAtlasUsers(ctx, \u0026mongodbatlas.LookupAtlasUsersArgs{\n\t\t\tProjectId: pulumi.StringRef(\"\u003cPROJECT_ID\u003e\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetAtlasUsersArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getAtlasUsers(GetAtlasUsersArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getAtlasUsers\n      Arguments:\n        projectId: \u003cPROJECT_ID\u003e\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Using team_id and org_id attribute to query Team Atlas Users\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = mongodbatlas.getAtlasUsers({\n    teamId: \"\u003cTEAM_ID\u003e\",\n    orgId: \"\u003cORG_ID\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.get_atlas_users(team_id=\"\u003cTEAM_ID\u003e\",\n    org_id=\"\u003cORG_ID\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Mongodbatlas.GetAtlasUsers.Invoke(new()\n    {\n        TeamId = \"\u003cTEAM_ID\u003e\",\n        OrgId = \"\u003cORG_ID\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.LookupAtlasUsers(ctx, \u0026mongodbatlas.LookupAtlasUsersArgs{\n\t\t\tTeamId: pulumi.StringRef(\"\u003cTEAM_ID\u003e\"),\n\t\t\tOrgId:  pulumi.StringRef(\"\u003cORG_ID\u003e\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetAtlasUsersArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getAtlasUsers(GetAtlasUsersArgs.builder()\n            .teamId(\"\u003cTEAM_ID\u003e\")\n            .orgId(\"\u003cORG_ID\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getAtlasUsers\n      Arguments:\n        teamId: \u003cTEAM_ID\u003e\n        orgId: \u003cORG_ID\u003e\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAtlasUsers.\n",
                "properties": {
                    "itemsPerPage": {
                        "type": "integer",
                        "description": "Number of items that the response returns per page, up to a maximum of `500`. Defaults to `100`.\n\n\u003e **IMPORTANT:** Either `org_id`, `project_id`, or `team_id` with `org_id` must be configurated.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the organization whose users you want to return. Also needed when `team_id` attributes is defined.\n"
                    },
                    "pageNum": {
                        "type": "integer",
                        "description": "Number of the page that displays the current set of the total objects that the response returns. Defaults to `1`.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the project whose users you want to return.\n"
                    },
                    "teamId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the team whose users you want to return.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getAtlasUsers.\n",
                "properties": {
                    "id": {
                        "deprecationMessage": "Please use each user's id attribute instead",
                        "type": "string"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "description": "A list where each element contains a Atlas User.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getAtlasUsersResult:getAtlasUsersResult"
                        },
                        "type": "array"
                    },
                    "teamId": {
                        "type": "string"
                    },
                    "totalCount": {
                        "description": "Count of the total number of items in the result set. It may be greater than the number of objects in the results array if the entire result set is paginated.\n",
                        "type": "integer"
                    }
                },
                "required": [
                    "id",
                    "results",
                    "totalCount"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getAuditing:getAuditing": {
            "description": "## # Data Source: mongodbatlas.Auditing\n\n`mongodbatlas.Auditing` describes a Auditing.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find **group_id** in the official documentation.\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testAuditing = new mongodbatlas.Auditing(\"test\", {\n    projectId: \"\u003cproject-id\u003e\",\n    auditFilter: \"{ 'atype': 'authenticate', 'param': {   'user': 'auditAdmin',   'db': 'admin',   'mechanism': 'SCRAM-SHA-1' }}\",\n    auditAuthorizationSuccess: false,\n    enabled: true,\n});\nconst test = mongodbatlas.getAuditingOutput({\n    projectId: testAuditing.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_auditing = mongodbatlas.Auditing(\"test\",\n    project_id=\"\u003cproject-id\u003e\",\n    audit_filter=\"{ 'atype': 'authenticate', 'param': {   'user': 'auditAdmin',   'db': 'admin',   'mechanism': 'SCRAM-SHA-1' }}\",\n    audit_authorization_success=False,\n    enabled=True)\ntest = mongodbatlas.get_auditing_output(project_id=test_auditing.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testAuditing = new Mongodbatlas.Auditing(\"test\", new()\n    {\n        ProjectId = \"\u003cproject-id\u003e\",\n        AuditFilter = \"{ 'atype': 'authenticate', 'param': {   'user': 'auditAdmin',   'db': 'admin',   'mechanism': 'SCRAM-SHA-1' }}\",\n        AuditAuthorizationSuccess = false,\n        Enabled = true,\n    });\n\n    var test = Mongodbatlas.GetAuditing.Invoke(new()\n    {\n        ProjectId = testAuditing.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestAuditing, err := mongodbatlas.NewAuditing(ctx, \"test\", \u0026mongodbatlas.AuditingArgs{\n\t\t\tProjectId:                 pulumi.String(\"\u003cproject-id\u003e\"),\n\t\t\tAuditFilter:               pulumi.String(\"{ 'atype': 'authenticate', 'param': {   'user': 'auditAdmin',   'db': 'admin',   'mechanism': 'SCRAM-SHA-1' }}\"),\n\t\t\tAuditAuthorizationSuccess: pulumi.Bool(false),\n\t\t\tEnabled:                   pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupAuditingOutput(ctx, mongodbatlas.GetAuditingOutputArgs{\n\t\t\tProjectId: testAuditing.ID(),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Auditing;\nimport com.pulumi.mongodbatlas.AuditingArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetAuditingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testAuditing = new Auditing(\"testAuditing\", AuditingArgs.builder()\n            .projectId(\"\u003cproject-id\u003e\")\n            .auditFilter(\"{ 'atype': 'authenticate', 'param': {   'user': 'auditAdmin',   'db': 'admin',   'mechanism': 'SCRAM-SHA-1' }}\")\n            .auditAuthorizationSuccess(false)\n            .enabled(true)\n            .build());\n\n        final var test = MongodbatlasFunctions.getAuditing(GetAuditingArgs.builder()\n            .projectId(testAuditing.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testAuditing:\n    type: mongodbatlas:Auditing\n    name: test\n    properties:\n      projectId: \u003cproject-id\u003e\n      auditFilter: '{ ''atype'': ''authenticate'', ''param'': {   ''user'': ''auditAdmin'',   ''db'': ''admin'',   ''mechanism'': ''SCRAM-SHA-1'' }}'\n      auditAuthorizationSuccess: false\n      enabled: true\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getAuditing\n      Arguments:\n        projectId: ${testAuditing.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAuditing.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the database user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAuditing.\n",
                "properties": {
                    "auditAuthorizationSuccess": {
                        "description": "JSON-formatted audit filter used by the project\n",
                        "type": "boolean"
                    },
                    "auditFilter": {
                        "description": "Indicates whether the auditing system captures successful authentication attempts for audit filters using the \"atype\" : \"authCheck\" auditing event. For more information, see auditAuthorizationSuccess\n",
                        "type": "string"
                    },
                    "configurationType": {
                        "description": "Denotes the configuration method for the audit filter. Possible values are: NONE - auditing not configured for the project.m FILTER_BUILDER - auditing configured via Atlas UI filter builderm FILTER_JSON - auditing configured via Atlas custom filter or API.\n",
                        "type": "string"
                    },
                    "enabled": {
                        "description": "Denotes whether or not the project associated with the {GROUP-ID} has database auditing enabled.\n",
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    }
                },
                "required": [
                    "auditAuthorizationSuccess",
                    "auditFilter",
                    "configurationType",
                    "enabled",
                    "projectId",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getBackupCompliancePolicy:getBackupCompliancePolicy": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst myCluster = new mongodbatlas.AdvancedCluster(\"my_cluster\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    name: \"clusterTest\",\n    clusterType: \"REPLICASET\",\n    backupEnabled: true,\n    replicationSpecs: [{\n        regionConfigs: [{\n            priority: 7,\n            providerName: \"AWS\",\n            regionName: \"EU_CENTRAL_1\",\n            electableSpecs: {\n                instanceSize: \"M10\",\n                nodeCount: 3,\n            },\n        }],\n    }],\n});\nconst testCloudBackupSchedule = new mongodbatlas.CloudBackupSchedule(\"test\", {\n    projectId: myCluster.projectId,\n    clusterName: myCluster.name,\n    referenceHourOfDay: 3,\n    referenceMinuteOfHour: 45,\n    restoreWindowDays: 4,\n    policyItemHourly: {\n        frequencyInterval: 1,\n        retentionUnit: \"days\",\n        retentionValue: 1,\n    },\n    policyItemDaily: {\n        frequencyInterval: 1,\n        retentionUnit: \"days\",\n        retentionValue: 2,\n    },\n    policyItemWeeklies: [{\n        frequencyInterval: 4,\n        retentionUnit: \"weeks\",\n        retentionValue: 3,\n    }],\n    policyItemMonthlies: [{\n        frequencyInterval: 5,\n        retentionUnit: \"months\",\n        retentionValue: 4,\n    }],\n    policyItemYearlies: [{\n        frequencyInterval: 1,\n        retentionUnit: \"years\",\n        retentionValue: 1,\n    }],\n});\nconst test = mongodbatlas.getCloudBackupScheduleOutput({\n    projectId: testCloudBackupSchedule.projectId,\n    clusterName: testCloudBackupSchedule.clusterName,\n});\nconst backupPolicy = mongodbatlas.getBackupCompliancePolicyOutput({\n    projectId: testCloudBackupSchedule.id,\n});\nconst backupPolicyBackupCompliancePolicy = new mongodbatlas.BackupCompliancePolicy(\"backup_policy\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    authorizedEmail: \"user@email.com\",\n    authorizedUserFirstName: \"First\",\n    authorizedUserLastName: \"Last\",\n    copyProtectionEnabled: false,\n    pitEnabled: false,\n    encryptionAtRestEnabled: false,\n    restoreWindowDays: 7,\n    onDemandPolicyItem: {\n        frequencyInterval: 0,\n        retentionUnit: \"days\",\n        retentionValue: 3,\n    },\n    policyItemHourly: {\n        frequencyInterval: 6,\n        retentionUnit: \"days\",\n        retentionValue: 7,\n    },\n    policyItemDaily: {\n        frequencyInterval: 0,\n        retentionUnit: \"days\",\n        retentionValue: 7,\n    },\n    policyItemWeeklies: [{\n        frequencyInterval: 0,\n        retentionUnit: \"weeks\",\n        retentionValue: 4,\n    }],\n    policyItemMonthlies: [{\n        frequencyInterval: 0,\n        retentionUnit: \"months\",\n        retentionValue: 12,\n    }],\n    policyItemYearlies: [{\n        frequencyInterval: 1,\n        retentionUnit: \"years\",\n        retentionValue: 1,\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nmy_cluster = mongodbatlas.AdvancedCluster(\"my_cluster\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    name=\"clusterTest\",\n    cluster_type=\"REPLICASET\",\n    backup_enabled=True,\n    replication_specs=[{\n        \"region_configs\": [{\n            \"priority\": 7,\n            \"provider_name\": \"AWS\",\n            \"region_name\": \"EU_CENTRAL_1\",\n            \"electable_specs\": {\n                \"instance_size\": \"M10\",\n                \"node_count\": 3,\n            },\n        }],\n    }])\ntest_cloud_backup_schedule = mongodbatlas.CloudBackupSchedule(\"test\",\n    project_id=my_cluster.project_id,\n    cluster_name=my_cluster.name,\n    reference_hour_of_day=3,\n    reference_minute_of_hour=45,\n    restore_window_days=4,\n    policy_item_hourly={\n        \"frequency_interval\": 1,\n        \"retention_unit\": \"days\",\n        \"retention_value\": 1,\n    },\n    policy_item_daily={\n        \"frequency_interval\": 1,\n        \"retention_unit\": \"days\",\n        \"retention_value\": 2,\n    },\n    policy_item_weeklies=[{\n        \"frequency_interval\": 4,\n        \"retention_unit\": \"weeks\",\n        \"retention_value\": 3,\n    }],\n    policy_item_monthlies=[{\n        \"frequency_interval\": 5,\n        \"retention_unit\": \"months\",\n        \"retention_value\": 4,\n    }],\n    policy_item_yearlies=[{\n        \"frequency_interval\": 1,\n        \"retention_unit\": \"years\",\n        \"retention_value\": 1,\n    }])\ntest = mongodbatlas.get_cloud_backup_schedule_output(project_id=test_cloud_backup_schedule.project_id,\n    cluster_name=test_cloud_backup_schedule.cluster_name)\nbackup_policy = mongodbatlas.get_backup_compliance_policy_output(project_id=test_cloud_backup_schedule.id)\nbackup_policy_backup_compliance_policy = mongodbatlas.BackupCompliancePolicy(\"backup_policy\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    authorized_email=\"user@email.com\",\n    authorized_user_first_name=\"First\",\n    authorized_user_last_name=\"Last\",\n    copy_protection_enabled=False,\n    pit_enabled=False,\n    encryption_at_rest_enabled=False,\n    restore_window_days=7,\n    on_demand_policy_item={\n        \"frequency_interval\": 0,\n        \"retention_unit\": \"days\",\n        \"retention_value\": 3,\n    },\n    policy_item_hourly={\n        \"frequency_interval\": 6,\n        \"retention_unit\": \"days\",\n        \"retention_value\": 7,\n    },\n    policy_item_daily={\n        \"frequency_interval\": 0,\n        \"retention_unit\": \"days\",\n        \"retention_value\": 7,\n    },\n    policy_item_weeklies=[{\n        \"frequency_interval\": 0,\n        \"retention_unit\": \"weeks\",\n        \"retention_value\": 4,\n    }],\n    policy_item_monthlies=[{\n        \"frequency_interval\": 0,\n        \"retention_unit\": \"months\",\n        \"retention_value\": 12,\n    }],\n    policy_item_yearlies=[{\n        \"frequency_interval\": 1,\n        \"retention_unit\": \"years\",\n        \"retention_value\": 1,\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myCluster = new Mongodbatlas.AdvancedCluster(\"my_cluster\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        Name = \"clusterTest\",\n        ClusterType = \"REPLICASET\",\n        BackupEnabled = true,\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        Priority = 7,\n                        ProviderName = \"AWS\",\n                        RegionName = \"EU_CENTRAL_1\",\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M10\",\n                            NodeCount = 3,\n                        },\n                    },\n                },\n            },\n        },\n    });\n\n    var testCloudBackupSchedule = new Mongodbatlas.CloudBackupSchedule(\"test\", new()\n    {\n        ProjectId = myCluster.ProjectId,\n        ClusterName = myCluster.Name,\n        ReferenceHourOfDay = 3,\n        ReferenceMinuteOfHour = 45,\n        RestoreWindowDays = 4,\n        PolicyItemHourly = new Mongodbatlas.Inputs.CloudBackupSchedulePolicyItemHourlyArgs\n        {\n            FrequencyInterval = 1,\n            RetentionUnit = \"days\",\n            RetentionValue = 1,\n        },\n        PolicyItemDaily = new Mongodbatlas.Inputs.CloudBackupSchedulePolicyItemDailyArgs\n        {\n            FrequencyInterval = 1,\n            RetentionUnit = \"days\",\n            RetentionValue = 2,\n        },\n        PolicyItemWeeklies = new[]\n        {\n            new Mongodbatlas.Inputs.CloudBackupSchedulePolicyItemWeeklyArgs\n            {\n                FrequencyInterval = 4,\n                RetentionUnit = \"weeks\",\n                RetentionValue = 3,\n            },\n        },\n        PolicyItemMonthlies = new[]\n        {\n            new Mongodbatlas.Inputs.CloudBackupSchedulePolicyItemMonthlyArgs\n            {\n                FrequencyInterval = 5,\n                RetentionUnit = \"months\",\n                RetentionValue = 4,\n            },\n        },\n        PolicyItemYearlies = new[]\n        {\n            new Mongodbatlas.Inputs.CloudBackupSchedulePolicyItemYearlyArgs\n            {\n                FrequencyInterval = 1,\n                RetentionUnit = \"years\",\n                RetentionValue = 1,\n            },\n        },\n    });\n\n    var test = Mongodbatlas.GetCloudBackupSchedule.Invoke(new()\n    {\n        ProjectId = testCloudBackupSchedule.ProjectId,\n        ClusterName = testCloudBackupSchedule.ClusterName,\n    });\n\n    var backupPolicy = Mongodbatlas.GetBackupCompliancePolicy.Invoke(new()\n    {\n        ProjectId = testCloudBackupSchedule.Id,\n    });\n\n    var backupPolicyBackupCompliancePolicy = new Mongodbatlas.BackupCompliancePolicy(\"backup_policy\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        AuthorizedEmail = \"user@email.com\",\n        AuthorizedUserFirstName = \"First\",\n        AuthorizedUserLastName = \"Last\",\n        CopyProtectionEnabled = false,\n        PitEnabled = false,\n        EncryptionAtRestEnabled = false,\n        RestoreWindowDays = 7,\n        OnDemandPolicyItem = new Mongodbatlas.Inputs.BackupCompliancePolicyOnDemandPolicyItemArgs\n        {\n            FrequencyInterval = 0,\n            RetentionUnit = \"days\",\n            RetentionValue = 3,\n        },\n        PolicyItemHourly = new Mongodbatlas.Inputs.BackupCompliancePolicyPolicyItemHourlyArgs\n        {\n            FrequencyInterval = 6,\n            RetentionUnit = \"days\",\n            RetentionValue = 7,\n        },\n        PolicyItemDaily = new Mongodbatlas.Inputs.BackupCompliancePolicyPolicyItemDailyArgs\n        {\n            FrequencyInterval = 0,\n            RetentionUnit = \"days\",\n            RetentionValue = 7,\n        },\n        PolicyItemWeeklies = new[]\n        {\n            new Mongodbatlas.Inputs.BackupCompliancePolicyPolicyItemWeeklyArgs\n            {\n                FrequencyInterval = 0,\n                RetentionUnit = \"weeks\",\n                RetentionValue = 4,\n            },\n        },\n        PolicyItemMonthlies = new[]\n        {\n            new Mongodbatlas.Inputs.BackupCompliancePolicyPolicyItemMonthlyArgs\n            {\n                FrequencyInterval = 0,\n                RetentionUnit = \"months\",\n                RetentionValue = 12,\n            },\n        },\n        PolicyItemYearlies = new[]\n        {\n            new Mongodbatlas.Inputs.BackupCompliancePolicyPolicyItemYearlyArgs\n            {\n                FrequencyInterval = 1,\n                RetentionUnit = \"years\",\n                RetentionValue = 1,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmyCluster, err := mongodbatlas.NewAdvancedCluster(ctx, \"my_cluster\", \u0026mongodbatlas.AdvancedClusterArgs{\n\t\t\tProjectId:     pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tName:          pulumi.String(\"clusterTest\"),\n\t\t\tClusterType:   pulumi.String(\"REPLICASET\"),\n\t\t\tBackupEnabled: pulumi.Bool(true),\n\t\t\tReplicationSpecs: mongodbatlas.AdvancedClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tPriority:     pulumi.Int(7),\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"EU_CENTRAL_1\"),\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M10\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(3),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestCloudBackupSchedule, err := mongodbatlas.NewCloudBackupSchedule(ctx, \"test\", \u0026mongodbatlas.CloudBackupScheduleArgs{\n\t\t\tProjectId:             myCluster.ProjectId,\n\t\t\tClusterName:           myCluster.Name,\n\t\t\tReferenceHourOfDay:    pulumi.Int(3),\n\t\t\tReferenceMinuteOfHour: pulumi.Int(45),\n\t\t\tRestoreWindowDays:     pulumi.Int(4),\n\t\t\tPolicyItemHourly: \u0026mongodbatlas.CloudBackupSchedulePolicyItemHourlyArgs{\n\t\t\t\tFrequencyInterval: pulumi.Int(1),\n\t\t\t\tRetentionUnit:     pulumi.String(\"days\"),\n\t\t\t\tRetentionValue:    pulumi.Int(1),\n\t\t\t},\n\t\t\tPolicyItemDaily: \u0026mongodbatlas.CloudBackupSchedulePolicyItemDailyArgs{\n\t\t\t\tFrequencyInterval: pulumi.Int(1),\n\t\t\t\tRetentionUnit:     pulumi.String(\"days\"),\n\t\t\t\tRetentionValue:    pulumi.Int(2),\n\t\t\t},\n\t\t\tPolicyItemWeeklies: mongodbatlas.CloudBackupSchedulePolicyItemWeeklyArray{\n\t\t\t\t\u0026mongodbatlas.CloudBackupSchedulePolicyItemWeeklyArgs{\n\t\t\t\t\tFrequencyInterval: pulumi.Int(4),\n\t\t\t\t\tRetentionUnit:     pulumi.String(\"weeks\"),\n\t\t\t\t\tRetentionValue:    pulumi.Int(3),\n\t\t\t\t},\n\t\t\t},\n\t\t\tPolicyItemMonthlies: mongodbatlas.CloudBackupSchedulePolicyItemMonthlyArray{\n\t\t\t\t\u0026mongodbatlas.CloudBackupSchedulePolicyItemMonthlyArgs{\n\t\t\t\t\tFrequencyInterval: pulumi.Int(5),\n\t\t\t\t\tRetentionUnit:     pulumi.String(\"months\"),\n\t\t\t\t\tRetentionValue:    pulumi.Int(4),\n\t\t\t\t},\n\t\t\t},\n\t\t\tPolicyItemYearlies: mongodbatlas.CloudBackupSchedulePolicyItemYearlyArray{\n\t\t\t\t\u0026mongodbatlas.CloudBackupSchedulePolicyItemYearlyArgs{\n\t\t\t\t\tFrequencyInterval: pulumi.Int(1),\n\t\t\t\t\tRetentionUnit:     pulumi.String(\"years\"),\n\t\t\t\t\tRetentionValue:    pulumi.Int(1),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupCloudBackupScheduleOutput(ctx, mongodbatlas.GetCloudBackupScheduleOutputArgs{\n\t\t\tProjectId:   testCloudBackupSchedule.ProjectId,\n\t\t\tClusterName: testCloudBackupSchedule.ClusterName,\n\t\t}, nil)\n\t\t_ = mongodbatlas.LookupBackupCompliancePolicyOutput(ctx, mongodbatlas.GetBackupCompliancePolicyOutputArgs{\n\t\t\tProjectId: testCloudBackupSchedule.ID(),\n\t\t}, nil)\n\t\t_, err = mongodbatlas.NewBackupCompliancePolicy(ctx, \"backup_policy\", \u0026mongodbatlas.BackupCompliancePolicyArgs{\n\t\t\tProjectId:               pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tAuthorizedEmail:         pulumi.String(\"user@email.com\"),\n\t\t\tAuthorizedUserFirstName: pulumi.String(\"First\"),\n\t\t\tAuthorizedUserLastName:  pulumi.String(\"Last\"),\n\t\t\tCopyProtectionEnabled:   pulumi.Bool(false),\n\t\t\tPitEnabled:              pulumi.Bool(false),\n\t\t\tEncryptionAtRestEnabled: pulumi.Bool(false),\n\t\t\tRestoreWindowDays:       pulumi.Int(7),\n\t\t\tOnDemandPolicyItem: \u0026mongodbatlas.BackupCompliancePolicyOnDemandPolicyItemArgs{\n\t\t\t\tFrequencyInterval: pulumi.Int(0),\n\t\t\t\tRetentionUnit:     pulumi.String(\"days\"),\n\t\t\t\tRetentionValue:    pulumi.Int(3),\n\t\t\t},\n\t\t\tPolicyItemHourly: \u0026mongodbatlas.BackupCompliancePolicyPolicyItemHourlyArgs{\n\t\t\t\tFrequencyInterval: pulumi.Int(6),\n\t\t\t\tRetentionUnit:     pulumi.String(\"days\"),\n\t\t\t\tRetentionValue:    pulumi.Int(7),\n\t\t\t},\n\t\t\tPolicyItemDaily: \u0026mongodbatlas.BackupCompliancePolicyPolicyItemDailyArgs{\n\t\t\t\tFrequencyInterval: pulumi.Int(0),\n\t\t\t\tRetentionUnit:     pulumi.String(\"days\"),\n\t\t\t\tRetentionValue:    pulumi.Int(7),\n\t\t\t},\n\t\t\tPolicyItemWeeklies: mongodbatlas.BackupCompliancePolicyPolicyItemWeeklyArray{\n\t\t\t\t\u0026mongodbatlas.BackupCompliancePolicyPolicyItemWeeklyArgs{\n\t\t\t\t\tFrequencyInterval: pulumi.Int(0),\n\t\t\t\t\tRetentionUnit:     pulumi.String(\"weeks\"),\n\t\t\t\t\tRetentionValue:    pulumi.Int(4),\n\t\t\t\t},\n\t\t\t},\n\t\t\tPolicyItemMonthlies: mongodbatlas.BackupCompliancePolicyPolicyItemMonthlyArray{\n\t\t\t\t\u0026mongodbatlas.BackupCompliancePolicyPolicyItemMonthlyArgs{\n\t\t\t\t\tFrequencyInterval: pulumi.Int(0),\n\t\t\t\t\tRetentionUnit:     pulumi.String(\"months\"),\n\t\t\t\t\tRetentionValue:    pulumi.Int(12),\n\t\t\t\t},\n\t\t\t},\n\t\t\tPolicyItemYearlies: mongodbatlas.BackupCompliancePolicyPolicyItemYearlyArray{\n\t\t\t\t\u0026mongodbatlas.BackupCompliancePolicyPolicyItemYearlyArgs{\n\t\t\t\t\tFrequencyInterval: pulumi.Int(1),\n\t\t\t\t\tRetentionUnit:     pulumi.String(\"years\"),\n\t\t\t\t\tRetentionValue:    pulumi.Int(1),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AdvancedCluster;\nimport com.pulumi.mongodbatlas.AdvancedClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.AdvancedClusterReplicationSpecArgs;\nimport com.pulumi.mongodbatlas.CloudBackupSchedule;\nimport com.pulumi.mongodbatlas.CloudBackupScheduleArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudBackupSchedulePolicyItemHourlyArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudBackupSchedulePolicyItemDailyArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudBackupSchedulePolicyItemWeeklyArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudBackupSchedulePolicyItemMonthlyArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudBackupSchedulePolicyItemYearlyArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetCloudBackupScheduleArgs;\nimport com.pulumi.mongodbatlas.inputs.GetBackupCompliancePolicyArgs;\nimport com.pulumi.mongodbatlas.BackupCompliancePolicy;\nimport com.pulumi.mongodbatlas.BackupCompliancePolicyArgs;\nimport com.pulumi.mongodbatlas.inputs.BackupCompliancePolicyOnDemandPolicyItemArgs;\nimport com.pulumi.mongodbatlas.inputs.BackupCompliancePolicyPolicyItemHourlyArgs;\nimport com.pulumi.mongodbatlas.inputs.BackupCompliancePolicyPolicyItemDailyArgs;\nimport com.pulumi.mongodbatlas.inputs.BackupCompliancePolicyPolicyItemWeeklyArgs;\nimport com.pulumi.mongodbatlas.inputs.BackupCompliancePolicyPolicyItemMonthlyArgs;\nimport com.pulumi.mongodbatlas.inputs.BackupCompliancePolicyPolicyItemYearlyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myCluster = new AdvancedCluster(\"myCluster\", AdvancedClusterArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .name(\"clusterTest\")\n            .clusterType(\"REPLICASET\")\n            .backupEnabled(true)\n            .replicationSpecs(AdvancedClusterReplicationSpecArgs.builder()\n                .regionConfigs(AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                    .priority(7)\n                    .providerName(\"AWS\")\n                    .regionName(\"EU_CENTRAL_1\")\n                    .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                        .instanceSize(\"M10\")\n                        .nodeCount(3)\n                        .build())\n                    .build())\n                .build())\n            .build());\n\n        var testCloudBackupSchedule = new CloudBackupSchedule(\"testCloudBackupSchedule\", CloudBackupScheduleArgs.builder()\n            .projectId(myCluster.projectId())\n            .clusterName(myCluster.name())\n            .referenceHourOfDay(3)\n            .referenceMinuteOfHour(45)\n            .restoreWindowDays(4)\n            .policyItemHourly(CloudBackupSchedulePolicyItemHourlyArgs.builder()\n                .frequencyInterval(1)\n                .retentionUnit(\"days\")\n                .retentionValue(1)\n                .build())\n            .policyItemDaily(CloudBackupSchedulePolicyItemDailyArgs.builder()\n                .frequencyInterval(1)\n                .retentionUnit(\"days\")\n                .retentionValue(2)\n                .build())\n            .policyItemWeeklies(CloudBackupSchedulePolicyItemWeeklyArgs.builder()\n                .frequencyInterval(4)\n                .retentionUnit(\"weeks\")\n                .retentionValue(3)\n                .build())\n            .policyItemMonthlies(CloudBackupSchedulePolicyItemMonthlyArgs.builder()\n                .frequencyInterval(5)\n                .retentionUnit(\"months\")\n                .retentionValue(4)\n                .build())\n            .policyItemYearlies(CloudBackupSchedulePolicyItemYearlyArgs.builder()\n                .frequencyInterval(1)\n                .retentionUnit(\"years\")\n                .retentionValue(1)\n                .build())\n            .build());\n\n        final var test = MongodbatlasFunctions.getCloudBackupSchedule(GetCloudBackupScheduleArgs.builder()\n            .projectId(testCloudBackupSchedule.projectId())\n            .clusterName(testCloudBackupSchedule.clusterName())\n            .build());\n\n        final var backupPolicy = MongodbatlasFunctions.getBackupCompliancePolicy(GetBackupCompliancePolicyArgs.builder()\n            .projectId(testCloudBackupSchedule.id())\n            .build());\n\n        var backupPolicyBackupCompliancePolicy = new BackupCompliancePolicy(\"backupPolicyBackupCompliancePolicy\", BackupCompliancePolicyArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .authorizedEmail(\"user@email.com\")\n            .authorizedUserFirstName(\"First\")\n            .authorizedUserLastName(\"Last\")\n            .copyProtectionEnabled(false)\n            .pitEnabled(false)\n            .encryptionAtRestEnabled(false)\n            .restoreWindowDays(7)\n            .onDemandPolicyItem(BackupCompliancePolicyOnDemandPolicyItemArgs.builder()\n                .frequencyInterval(0)\n                .retentionUnit(\"days\")\n                .retentionValue(3)\n                .build())\n            .policyItemHourly(BackupCompliancePolicyPolicyItemHourlyArgs.builder()\n                .frequencyInterval(6)\n                .retentionUnit(\"days\")\n                .retentionValue(7)\n                .build())\n            .policyItemDaily(BackupCompliancePolicyPolicyItemDailyArgs.builder()\n                .frequencyInterval(0)\n                .retentionUnit(\"days\")\n                .retentionValue(7)\n                .build())\n            .policyItemWeeklies(BackupCompliancePolicyPolicyItemWeeklyArgs.builder()\n                .frequencyInterval(0)\n                .retentionUnit(\"weeks\")\n                .retentionValue(4)\n                .build())\n            .policyItemMonthlies(BackupCompliancePolicyPolicyItemMonthlyArgs.builder()\n                .frequencyInterval(0)\n                .retentionUnit(\"months\")\n                .retentionValue(12)\n                .build())\n            .policyItemYearlies(BackupCompliancePolicyPolicyItemYearlyArgs.builder()\n                .frequencyInterval(1)\n                .retentionUnit(\"years\")\n                .retentionValue(1)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myCluster:\n    type: mongodbatlas:AdvancedCluster\n    name: my_cluster\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      name: clusterTest\n      clusterType: REPLICASET\n      backupEnabled: true # enable cloud backup snapshots\n      replicationSpecs:\n        - regionConfigs:\n            - priority: 7\n              providerName: AWS\n              regionName: EU_CENTRAL_1\n              electableSpecs:\n                instanceSize: M10\n                nodeCount: 3\n  testCloudBackupSchedule:\n    type: mongodbatlas:CloudBackupSchedule\n    name: test\n    properties:\n      projectId: ${myCluster.projectId}\n      clusterName: ${myCluster.name}\n      referenceHourOfDay: 3\n      referenceMinuteOfHour: 45\n      restoreWindowDays: 4 # This will now add the desired policy items to the existing mongodbatlas_cloud_backup_schedule resource\n      policyItemHourly:\n        frequencyInterval: 1\n        retentionUnit: days\n        retentionValue: 1\n      policyItemDaily:\n        frequencyInterval: 1\n        retentionUnit: days\n        retentionValue: 2\n      policyItemWeeklies:\n        - frequencyInterval: 4\n          retentionUnit: weeks\n          retentionValue: 3\n      policyItemMonthlies:\n        - frequencyInterval: 5\n          retentionUnit: months\n          retentionValue: 4\n      policyItemYearlies:\n        - frequencyInterval: 1\n          retentionUnit: years\n          retentionValue: 1\n  backupPolicyBackupCompliancePolicy:\n    type: mongodbatlas:BackupCompliancePolicy\n    name: backup_policy\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      authorizedEmail: user@email.com\n      authorizedUserFirstName: First\n      authorizedUserLastName: Last\n      copyProtectionEnabled: false\n      pitEnabled: false\n      encryptionAtRestEnabled: false\n      restoreWindowDays: 7\n      onDemandPolicyItem:\n        frequencyInterval: 0\n        retentionUnit: days\n        retentionValue: 3\n      policyItemHourly:\n        frequencyInterval: 6\n        retentionUnit: days\n        retentionValue: 7\n      policyItemDaily:\n        frequencyInterval: 0\n        retentionUnit: days\n        retentionValue: 7\n      policyItemWeeklies:\n        - frequencyInterval: 0\n          retentionUnit: weeks\n          retentionValue: 4\n      policyItemMonthlies:\n        - frequencyInterval: 0\n          retentionUnit: months\n          retentionValue: 12\n      policyItemYearlies:\n        - frequencyInterval: 1\n          retentionUnit: years\n          retentionValue: 1\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getCloudBackupSchedule\n      Arguments:\n        projectId: ${testCloudBackupSchedule.projectId}\n        clusterName: ${testCloudBackupSchedule.clusterName}\n  backupPolicy:\n    fn::invoke:\n      Function: mongodbatlas:getBackupCompliancePolicy\n      Arguments:\n        projectId: ${testCloudBackupSchedule.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getBackupCompliancePolicy.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies your project\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getBackupCompliancePolicy.\n",
                "properties": {
                    "authorizedEmail": {
                        "description": "Email address of the user who is authorized to update the Backup Compliance Policy settings.\n",
                        "type": "string"
                    },
                    "authorizedUserFirstName": {
                        "description": "First name of the user who authorized to update the Backup Compliance Policy settings.\n",
                        "type": "string"
                    },
                    "authorizedUserLastName": {
                        "description": "Last name of the user who authorized to update the Backup Compliance Policy settings.\n",
                        "type": "string"
                    },
                    "copyProtectionEnabled": {
                        "description": "Flag that indicates whether to enable additional backup copies for the cluster. If unspecified, this value defaults to false.\n",
                        "type": "boolean"
                    },
                    "encryptionAtRestEnabled": {
                        "description": "Flag that indicates whether Encryption at Rest using Customer Key Management is required for all clusters with a Backup Compliance Policy. If unspecified, this value defaults to false.\n",
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "onDemandPolicyItem": {
                        "$ref": "#/types/mongodbatlas:index/getBackupCompliancePolicyOnDemandPolicyItem:getBackupCompliancePolicyOnDemandPolicyItem"
                    },
                    "pitEnabled": {
                        "description": "Flag that indicates whether the cluster uses Continuous Cloud Backups with a Backup Compliance Policy. If unspecified, this value defaults to false.\n",
                        "type": "boolean"
                    },
                    "policyItemDaily": {
                        "$ref": "#/types/mongodbatlas:index/getBackupCompliancePolicyPolicyItemDaily:getBackupCompliancePolicyPolicyItemDaily"
                    },
                    "policyItemHourly": {
                        "$ref": "#/types/mongodbatlas:index/getBackupCompliancePolicyPolicyItemHourly:getBackupCompliancePolicyPolicyItemHourly"
                    },
                    "policyItemMonthlies": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getBackupCompliancePolicyPolicyItemMonthly:getBackupCompliancePolicyPolicyItemMonthly"
                        },
                        "type": "array"
                    },
                    "policyItemWeeklies": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getBackupCompliancePolicyPolicyItemWeekly:getBackupCompliancePolicyPolicyItemWeekly"
                        },
                        "type": "array"
                    },
                    "policyItemYearlies": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getBackupCompliancePolicyPolicyItemYearly:getBackupCompliancePolicyPolicyItemYearly"
                        },
                        "type": "array"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "restoreWindowDays": {
                        "description": "Number of previous days that you can restore back to with Continuous Cloud Backup with a Backup Compliance Policy. You must specify a positive, non-zero integer, and the maximum retention window can't exceed the hourly retention time. This parameter applies only to Continuous Cloud Backups with a Backup Compliance Policy.\n",
                        "type": "integer"
                    },
                    "state": {
                        "description": "Label that indicates the state of the Backup Compliance Policy settings. MongoDB Cloud ignores this setting when you enable or update the Backup Compliance Policy settings.\n",
                        "type": "string"
                    },
                    "updatedDate": {
                        "description": "ISO 8601 timestamp format in UTC that indicates when the user updated the Data Protection Policy settings. MongoDB Cloud ignores this setting when you enable or update the Backup Compliance Policy settings.\n",
                        "type": "string"
                    },
                    "updatedUser": {
                        "description": "Email address that identifies the user who updated the Backup Compliance Policy settings. MongoDB Cloud ignores this email setting when you enable or update the Backup Compliance Policy settings.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "authorizedEmail",
                    "authorizedUserFirstName",
                    "authorizedUserLastName",
                    "copyProtectionEnabled",
                    "encryptionAtRestEnabled",
                    "onDemandPolicyItem",
                    "pitEnabled",
                    "policyItemDaily",
                    "policyItemHourly",
                    "policyItemMonthlies",
                    "policyItemWeeklies",
                    "policyItemYearlies",
                    "projectId",
                    "restoreWindowDays",
                    "state",
                    "updatedDate",
                    "updatedUser",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getCloudBackupSchedule:getCloudBackupSchedule": {
            "description": "## # Data Source: mongodbatlas.CloudBackupSchedule\n\n`mongodbatlas.CloudBackupSchedule` provides a Cloud Backup Schedule datasource. An Atlas Cloud Backup Schedule provides the current cloud backup schedule for the cluster. \n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudBackupSchedule.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the Atlas cluster that contains the snapshots backup policy you want to retrieve.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster.\n"
                    },
                    "useZoneIdForCopySettings": {
                        "type": "boolean",
                        "description": "Set this field to `true` to allow the data source to use the latest schema that populates `copy_settings.#.zone_id` instead of the deprecated `copy_settings.#.replication_spec_id`. These fields also enable you to reference cluster zones using independent shard scaling, which no longer supports `replication_spec.*.id`. To learn more, see the 1.18.0 upgrade guide.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudBackupSchedule.\n",
                "properties": {
                    "autoExportEnabled": {
                        "description": "Flag that indicates whether automatic export of cloud backup snapshots to the AWS bucket is enabled. Value can be one of the following:\n* true - enables automatic export of cloud backup snapshots to the AWS bucket\n* false - disables automatic export of cloud backup snapshots to the AWS bucket (default)\n",
                        "type": "boolean"
                    },
                    "clusterId": {
                        "description": "Unique identifier of the Atlas cluster.\n",
                        "type": "string"
                    },
                    "clusterName": {
                        "type": "string"
                    },
                    "copySettings": {
                        "description": "List that contains a document for each copy setting item in the desired backup policy. See below\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudBackupScheduleCopySetting:getCloudBackupScheduleCopySetting"
                        },
                        "type": "array"
                    },
                    "exports": {
                        "description": "Policy for automatically exporting Cloud Backup Snapshots. See below\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudBackupScheduleExport:getCloudBackupScheduleExport"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "idPolicy": {
                        "description": "Unique identifier of the backup policy.\n",
                        "type": "string"
                    },
                    "nextSnapshot": {
                        "description": "UTC ISO 8601 formatted point in time when Atlas will take the next snapshot.\n",
                        "type": "string"
                    },
                    "policyItemDailies": {
                        "description": "(Optional) Daily policy item. See below\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudBackupSchedulePolicyItemDaily:getCloudBackupSchedulePolicyItemDaily"
                        },
                        "type": "array"
                    },
                    "policyItemHourlies": {
                        "description": "(Optional) Hourly policy item. See below\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudBackupSchedulePolicyItemHourly:getCloudBackupSchedulePolicyItemHourly"
                        },
                        "type": "array"
                    },
                    "policyItemMonthlies": {
                        "description": "(Optional) Monthly policy item. See below\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudBackupSchedulePolicyItemMonthly:getCloudBackupSchedulePolicyItemMonthly"
                        },
                        "type": "array"
                    },
                    "policyItemWeeklies": {
                        "description": "(Optional) Weekly policy item. See below\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudBackupSchedulePolicyItemWeekly:getCloudBackupSchedulePolicyItemWeekly"
                        },
                        "type": "array"
                    },
                    "policyItemYearlies": {
                        "description": "(Optional) Yearly policy item. See below\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudBackupSchedulePolicyItemYearly:getCloudBackupSchedulePolicyItemYearly"
                        },
                        "type": "array"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "referenceHourOfDay": {
                        "description": "UTC Hour of day between 0 and 23 representing which hour of the day that Atlas takes a snapshot.\n",
                        "type": "integer"
                    },
                    "referenceMinuteOfHour": {
                        "description": "UTC Minute of day between 0 and 59 representing which minute of the `reference_hour_of_day` that Atlas takes the snapshot.\n",
                        "type": "integer"
                    },
                    "restoreWindowDays": {
                        "description": "Specifies a restore window in days for cloud backup to maintain.\n",
                        "type": "integer"
                    },
                    "useOrgAndGroupNamesInExportPrefix": {
                        "description": "Specify true to use organization and project names instead of organization and project UUIDs in the path for the metadata files that Atlas uploads to your S3 bucket after it finishes exporting the snapshots. To learn more about the metadata files that Atlas uploads, see [Export Cloud Backup Snapshot](https://www.mongodb.com/docs/atlas/backup/cloud-backup/export/#std-label-cloud-provider-snapshot-export).\n",
                        "type": "boolean"
                    },
                    "useZoneIdForCopySettings": {
                        "type": "boolean"
                    }
                },
                "required": [
                    "autoExportEnabled",
                    "clusterId",
                    "clusterName",
                    "copySettings",
                    "exports",
                    "idPolicy",
                    "nextSnapshot",
                    "policyItemDailies",
                    "policyItemHourlies",
                    "policyItemMonthlies",
                    "policyItemWeeklies",
                    "policyItemYearlies",
                    "projectId",
                    "referenceHourOfDay",
                    "referenceMinuteOfHour",
                    "restoreWindowDays",
                    "useOrgAndGroupNamesInExportPrefix",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshot:getCloudBackupSnapshot": {
            "description": "## # Data Source: mongodbatlas.CloudBackupSnapshot\n\n`mongodbatlas.CloudBackupSnapshot` provides an Cloud Backup Snapshot datasource. Atlas Cloud Backup Snapshots provide localized backup storage using the native snapshot functionality of the clusterâs cloud service.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testCloudBackupSnapshot = new mongodbatlas.CloudBackupSnapshot(\"test\", {\n    projectId: \"5d0f1f73cf09a29120e173cf\",\n    clusterName: \"MyClusterTest\",\n    description: \"SomeDescription\",\n    retentionInDays: 1,\n});\nconst test = mongodbatlas.getCloudBackupSnapshotOutput({\n    snapshotId: \"5d1285acd5ec13b6c2d1726a\",\n    projectId: testCloudBackupSnapshot.projectId,\n    clusterName: testCloudBackupSnapshot.clusterName,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_cloud_backup_snapshot = mongodbatlas.CloudBackupSnapshot(\"test\",\n    project_id=\"5d0f1f73cf09a29120e173cf\",\n    cluster_name=\"MyClusterTest\",\n    description=\"SomeDescription\",\n    retention_in_days=1)\ntest = mongodbatlas.get_cloud_backup_snapshot_output(snapshot_id=\"5d1285acd5ec13b6c2d1726a\",\n    project_id=test_cloud_backup_snapshot.project_id,\n    cluster_name=test_cloud_backup_snapshot.cluster_name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testCloudBackupSnapshot = new Mongodbatlas.CloudBackupSnapshot(\"test\", new()\n    {\n        ProjectId = \"5d0f1f73cf09a29120e173cf\",\n        ClusterName = \"MyClusterTest\",\n        Description = \"SomeDescription\",\n        RetentionInDays = 1,\n    });\n\n    var test = Mongodbatlas.GetCloudBackupSnapshot.Invoke(new()\n    {\n        SnapshotId = \"5d1285acd5ec13b6c2d1726a\",\n        ProjectId = testCloudBackupSnapshot.ProjectId,\n        ClusterName = testCloudBackupSnapshot.ClusterName,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestCloudBackupSnapshot, err := mongodbatlas.NewCloudBackupSnapshot(ctx, \"test\", \u0026mongodbatlas.CloudBackupSnapshotArgs{\n\t\t\tProjectId:       pulumi.String(\"5d0f1f73cf09a29120e173cf\"),\n\t\t\tClusterName:     pulumi.String(\"MyClusterTest\"),\n\t\t\tDescription:     pulumi.String(\"SomeDescription\"),\n\t\t\tRetentionInDays: pulumi.Int(1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupCloudBackupSnapshotOutput(ctx, mongodbatlas.GetCloudBackupSnapshotOutputArgs{\n\t\t\tSnapshotId:  pulumi.String(\"5d1285acd5ec13b6c2d1726a\"),\n\t\t\tProjectId:   testCloudBackupSnapshot.ProjectId,\n\t\t\tClusterName: testCloudBackupSnapshot.ClusterName,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshot;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetCloudBackupSnapshotArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testCloudBackupSnapshot = new CloudBackupSnapshot(\"testCloudBackupSnapshot\", CloudBackupSnapshotArgs.builder()\n            .projectId(\"5d0f1f73cf09a29120e173cf\")\n            .clusterName(\"MyClusterTest\")\n            .description(\"SomeDescription\")\n            .retentionInDays(1)\n            .build());\n\n        final var test = MongodbatlasFunctions.getCloudBackupSnapshot(GetCloudBackupSnapshotArgs.builder()\n            .snapshotId(\"5d1285acd5ec13b6c2d1726a\")\n            .projectId(testCloudBackupSnapshot.projectId())\n            .clusterName(testCloudBackupSnapshot.clusterName())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testCloudBackupSnapshot:\n    type: mongodbatlas:CloudBackupSnapshot\n    name: test\n    properties:\n      projectId: 5d0f1f73cf09a29120e173cf\n      clusterName: MyClusterTest\n      description: SomeDescription\n      retentionInDays: 1\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getCloudBackupSnapshot\n      Arguments:\n        snapshotId: 5d1285acd5ec13b6c2d1726a\n        projectId: ${testCloudBackupSnapshot.projectId}\n        clusterName: ${testCloudBackupSnapshot.clusterName}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudBackupSnapshot.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the Atlas cluster that contains the snapshot you want to retrieve.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster.\n"
                    },
                    "snapshotId": {
                        "type": "string",
                        "description": "The unique identifier of the snapshot you want to retrieve.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId",
                    "snapshotId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudBackupSnapshot.\n",
                "properties": {
                    "cloudProvider": {
                        "description": "Cloud provider that stores this snapshot.\n",
                        "type": "string"
                    },
                    "clusterName": {
                        "type": "string"
                    },
                    "createdAt": {
                        "description": "UTC ISO 8601 formatted point in time when Atlas took the snapshot.\n",
                        "type": "string"
                    },
                    "description": {
                        "description": "UDescription of the snapshot. Only present for on-demand snapshots.\n",
                        "type": "string"
                    },
                    "expiresAt": {
                        "description": "UTC ISO 8601 formatted point in time when Atlas will delete the snapshot.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "masterKeyUuid": {
                        "description": "Unique ID of the AWS KMS Customer Master Key used to encrypt the snapshot. Only visible for clusters using Encryption at Rest via Customer KMS.\n",
                        "type": "string"
                    },
                    "members": {
                        "description": "Block of List of snapshots and the cloud provider where the snapshots are stored. See below\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudBackupSnapshotMember:getCloudBackupSnapshotMember"
                        },
                        "type": "array"
                    },
                    "mongodVersion": {
                        "description": "Version of the MongoDB server.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "replicaSetName": {
                        "description": "Label given to a shard or config server from which Atlas took this snapshot.\n",
                        "type": "string"
                    },
                    "snapshotId": {
                        "type": "string"
                    },
                    "snapshotIds": {
                        "description": "Unique identifiers of the snapshots created for the shards and config server for a sharded cluster.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "snapshotType": {
                        "description": "Specified the type of snapshot. Valid values are onDemand and scheduled.\n",
                        "type": "string"
                    },
                    "status": {
                        "description": "Current status of the snapshot. One of the following values: queued, inProgress, completed, failed.\n",
                        "type": "string"
                    },
                    "storageSizeBytes": {
                        "description": "Specifies the size of the snapshot in bytes.\n",
                        "type": "integer"
                    },
                    "type": {
                        "description": "Specifies the type of cluster: replicaSet or shardedCluster.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "cloudProvider",
                    "clusterName",
                    "createdAt",
                    "description",
                    "expiresAt",
                    "masterKeyUuid",
                    "members",
                    "mongodVersion",
                    "projectId",
                    "replicaSetName",
                    "snapshotId",
                    "snapshotIds",
                    "snapshotType",
                    "status",
                    "storageSizeBytes",
                    "type",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotExportBucket:getCloudBackupSnapshotExportBucket": {
            "description": "## # Data Source: mongodbatlas.CloudBackupSnapshotExportBucket\n\n`mongodbatlas.CloudBackupSnapshotExportBucket` datasource allows you to retrieve all the buckets for the specified project.\n\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testCloudBackupSnapshotExportBucket = new mongodbatlas.CloudBackupSnapshotExportBucket(\"test\", {\n    projectId: \"{PROJECT_ID}\",\n    iamRoleId: \"{IAM_ROLE_ID}\",\n    bucketName: \"example-bucket\",\n    cloudProvider: \"AWS\",\n});\nconst test = mongodbatlas.getCloudBackupSnapshotExportBucketOutput({\n    projectId: \"{PROJECT_ID}\",\n    exportBucketId: testCloudBackupSnapshotExportBucket.exportBucketId,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_cloud_backup_snapshot_export_bucket = mongodbatlas.CloudBackupSnapshotExportBucket(\"test\",\n    project_id=\"{PROJECT_ID}\",\n    iam_role_id=\"{IAM_ROLE_ID}\",\n    bucket_name=\"example-bucket\",\n    cloud_provider=\"AWS\")\ntest = mongodbatlas.get_cloud_backup_snapshot_export_bucket_output(project_id=\"{PROJECT_ID}\",\n    export_bucket_id=test_cloud_backup_snapshot_export_bucket.export_bucket_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testCloudBackupSnapshotExportBucket = new Mongodbatlas.CloudBackupSnapshotExportBucket(\"test\", new()\n    {\n        ProjectId = \"{PROJECT_ID}\",\n        IamRoleId = \"{IAM_ROLE_ID}\",\n        BucketName = \"example-bucket\",\n        CloudProvider = \"AWS\",\n    });\n\n    var test = Mongodbatlas.GetCloudBackupSnapshotExportBucket.Invoke(new()\n    {\n        ProjectId = \"{PROJECT_ID}\",\n        ExportBucketId = testCloudBackupSnapshotExportBucket.ExportBucketId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestCloudBackupSnapshotExportBucket, err := mongodbatlas.NewCloudBackupSnapshotExportBucket(ctx, \"test\", \u0026mongodbatlas.CloudBackupSnapshotExportBucketArgs{\n\t\t\tProjectId:     pulumi.String(\"{PROJECT_ID}\"),\n\t\t\tIamRoleId:     pulumi.String(\"{IAM_ROLE_ID}\"),\n\t\t\tBucketName:    pulumi.String(\"example-bucket\"),\n\t\t\tCloudProvider: pulumi.String(\"AWS\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupCloudBackupSnapshotExportBucketOutput(ctx, mongodbatlas.GetCloudBackupSnapshotExportBucketOutputArgs{\n\t\t\tProjectId:      pulumi.String(\"{PROJECT_ID}\"),\n\t\t\tExportBucketId: testCloudBackupSnapshotExportBucket.ExportBucketId,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportBucket;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportBucketArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetCloudBackupSnapshotExportBucketArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testCloudBackupSnapshotExportBucket = new CloudBackupSnapshotExportBucket(\"testCloudBackupSnapshotExportBucket\", CloudBackupSnapshotExportBucketArgs.builder()\n            .projectId(\"{PROJECT_ID}\")\n            .iamRoleId(\"{IAM_ROLE_ID}\")\n            .bucketName(\"example-bucket\")\n            .cloudProvider(\"AWS\")\n            .build());\n\n        final var test = MongodbatlasFunctions.getCloudBackupSnapshotExportBucket(GetCloudBackupSnapshotExportBucketArgs.builder()\n            .projectId(\"{PROJECT_ID}\")\n            .exportBucketId(testCloudBackupSnapshotExportBucket.exportBucketId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testCloudBackupSnapshotExportBucket:\n    type: mongodbatlas:CloudBackupSnapshotExportBucket\n    name: test\n    properties:\n      projectId: '{PROJECT_ID}'\n      iamRoleId: '{IAM_ROLE_ID}'\n      bucketName: example-bucket\n      cloudProvider: AWS\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getCloudBackupSnapshotExportBucket\n      Arguments:\n        projectId: '{PROJECT_ID}'\n        exportBucketId: ${testCloudBackupSnapshotExportBucket.exportBucketId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudBackupSnapshotExportBucket.\n",
                "properties": {
                    "exportBucketId": {
                        "type": "string",
                        "description": "Unique identifier of the snapshot export bucket.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "exportBucketId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudBackupSnapshotExportBucket.\n",
                "properties": {
                    "bucketName": {
                        "description": "Name of the bucket that the provided role ID is authorized to access.\n",
                        "type": "string"
                    },
                    "cloudProvider": {
                        "description": "Name of the provider of the cloud service where Atlas can access the S3 bucket.\n",
                        "type": "string"
                    },
                    "exportBucketId": {
                        "type": "string"
                    },
                    "iamRoleId": {
                        "description": "Unique identifier of the role that Atlas can use to access the bucket.\n",
                        "type": "string"
                    },
                    "id": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "roleId": {
                        "description": "Unique identifier of the Azure Service Principal that Atlas can use to access the Azure Blob Storage Container.\n",
                        "type": "string"
                    },
                    "serviceUrl": {
                        "description": "URL that identifies the blob Endpoint of the Azure Blob Storage Account.\n",
                        "type": "string"
                    },
                    "tenantId": {
                        "description": "UUID that identifies the Azure Active Directory Tenant ID.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "bucketName",
                    "cloudProvider",
                    "exportBucketId",
                    "iamRoleId",
                    "id",
                    "projectId",
                    "roleId",
                    "serviceUrl",
                    "tenantId"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotExportBuckets:getCloudBackupSnapshotExportBuckets": {
            "description": "## # Data Source: mongodbatlas.getCloudBackupSnapshotExportBuckets\n\n`mongodbatlas.getCloudBackupSnapshotExportBuckets` datasource allows you to retrieve all the buckets for the specified project.\n\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testCloudBackupSnapshotExportBucket = new mongodbatlas.CloudBackupSnapshotExportBucket(\"test\", {\n    projectId: \"{PROJECT_ID}\",\n    iamRoleId: \"{IAM_ROLE_ID}\",\n    bucketName: \"example-bucket\",\n    cloudProvider: \"AWS\",\n});\nconst test = mongodbatlas.getCloudBackupSnapshotExportBuckets({\n    projectId: \"{PROJECT_ID}\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_cloud_backup_snapshot_export_bucket = mongodbatlas.CloudBackupSnapshotExportBucket(\"test\",\n    project_id=\"{PROJECT_ID}\",\n    iam_role_id=\"{IAM_ROLE_ID}\",\n    bucket_name=\"example-bucket\",\n    cloud_provider=\"AWS\")\ntest = mongodbatlas.get_cloud_backup_snapshot_export_buckets(project_id=\"{PROJECT_ID}\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testCloudBackupSnapshotExportBucket = new Mongodbatlas.CloudBackupSnapshotExportBucket(\"test\", new()\n    {\n        ProjectId = \"{PROJECT_ID}\",\n        IamRoleId = \"{IAM_ROLE_ID}\",\n        BucketName = \"example-bucket\",\n        CloudProvider = \"AWS\",\n    });\n\n    var test = Mongodbatlas.GetCloudBackupSnapshotExportBuckets.Invoke(new()\n    {\n        ProjectId = \"{PROJECT_ID}\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewCloudBackupSnapshotExportBucket(ctx, \"test\", \u0026mongodbatlas.CloudBackupSnapshotExportBucketArgs{\n\t\t\tProjectId:     pulumi.String(\"{PROJECT_ID}\"),\n\t\t\tIamRoleId:     pulumi.String(\"{IAM_ROLE_ID}\"),\n\t\t\tBucketName:    pulumi.String(\"example-bucket\"),\n\t\t\tCloudProvider: pulumi.String(\"AWS\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.LookupCloudBackupSnapshotExportBuckets(ctx, \u0026mongodbatlas.LookupCloudBackupSnapshotExportBucketsArgs{\n\t\t\tProjectId: \"{PROJECT_ID}\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportBucket;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportBucketArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetCloudBackupSnapshotExportBucketsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testCloudBackupSnapshotExportBucket = new CloudBackupSnapshotExportBucket(\"testCloudBackupSnapshotExportBucket\", CloudBackupSnapshotExportBucketArgs.builder()\n            .projectId(\"{PROJECT_ID}\")\n            .iamRoleId(\"{IAM_ROLE_ID}\")\n            .bucketName(\"example-bucket\")\n            .cloudProvider(\"AWS\")\n            .build());\n\n        final var test = MongodbatlasFunctions.getCloudBackupSnapshotExportBuckets(GetCloudBackupSnapshotExportBucketsArgs.builder()\n            .projectId(\"{PROJECT_ID}\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testCloudBackupSnapshotExportBucket:\n    type: mongodbatlas:CloudBackupSnapshotExportBucket\n    name: test\n    properties:\n      projectId: '{PROJECT_ID}'\n      iamRoleId: '{IAM_ROLE_ID}'\n      bucketName: example-bucket\n      cloudProvider: AWS\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getCloudBackupSnapshotExportBuckets\n      Arguments:\n        projectId: '{PROJECT_ID}'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudBackupSnapshotExportBuckets.\n",
                "properties": {
                    "itemsPerPage": {
                        "type": "integer",
                        "description": "Number of items to return per page, up to a maximum of 500. Defaults to `100`.\n"
                    },
                    "pageNum": {
                        "type": "integer",
                        "description": "The page to return. Defaults to `1`.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudBackupSnapshotExportBuckets.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "projectId": {
                        "description": "The unique identifier of the project for the Atlas cluster.\n",
                        "type": "string"
                    },
                    "results": {
                        "description": "Includes CloudProviderSnapshotExportBucket object for each item detailed in the results array section.\n* `totalCount` - Count of the total number of items in the result set. It may be greater than the number of objects in the results array if the entire result set is paginated.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudBackupSnapshotExportBucketsResult:getCloudBackupSnapshotExportBucketsResult"
                        },
                        "type": "array"
                    },
                    "totalCount": {
                        "type": "integer"
                    }
                },
                "required": [
                    "projectId",
                    "results",
                    "totalCount",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotExportJob:getCloudBackupSnapshotExportJob": {
            "description": "## # Data Source: mongodbatlas_cloud_backup_snapshot_export_Job\n\n`mongodbatlas.CloudBackupSnapshotExportJob` datasource allows you to retrieve a snapshot export job for the specified project and cluster.\n\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testCloudBackupSnapshotExportBucket = new mongodbatlas.CloudBackupSnapshotExportBucket(\"test\", {\n    projectId: \"{PROJECT_ID}\",\n    iamRoleId: \"{IAM_ROLE_ID}\",\n    bucketName: \"example_bucket\",\n    cloudProvider: \"AWS\",\n});\nconst testCloudBackupSnapshotExportJob = new mongodbatlas.CloudBackupSnapshotExportJob(\"test\", {\n    projectId: \"{PROJECT_ID}\",\n    clusterName: \"{CLUSTER_NAME}\",\n    snapshotId: \"{SNAPSHOT_ID}\",\n    exportBucketId: testCloudBackupSnapshotExportBucket.exportBucketId,\n    customDatas: [{\n        key: \"exported by\",\n        value: \"myName\",\n    }],\n});\nconst test = mongodbatlas.getCloudBackupSnapshotExportJobOutput({\n    projectId: \"{PROJECT_ID}\",\n    clusterName: \"{CLUSTER_NAME}\",\n    exportJobId: testCloudBackupSnapshotExportJob.exportJobId,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_cloud_backup_snapshot_export_bucket = mongodbatlas.CloudBackupSnapshotExportBucket(\"test\",\n    project_id=\"{PROJECT_ID}\",\n    iam_role_id=\"{IAM_ROLE_ID}\",\n    bucket_name=\"example_bucket\",\n    cloud_provider=\"AWS\")\ntest_cloud_backup_snapshot_export_job = mongodbatlas.CloudBackupSnapshotExportJob(\"test\",\n    project_id=\"{PROJECT_ID}\",\n    cluster_name=\"{CLUSTER_NAME}\",\n    snapshot_id=\"{SNAPSHOT_ID}\",\n    export_bucket_id=test_cloud_backup_snapshot_export_bucket.export_bucket_id,\n    custom_datas=[{\n        \"key\": \"exported by\",\n        \"value\": \"myName\",\n    }])\ntest = mongodbatlas.get_cloud_backup_snapshot_export_job_output(project_id=\"{PROJECT_ID}\",\n    cluster_name=\"{CLUSTER_NAME}\",\n    export_job_id=test_cloud_backup_snapshot_export_job.export_job_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testCloudBackupSnapshotExportBucket = new Mongodbatlas.CloudBackupSnapshotExportBucket(\"test\", new()\n    {\n        ProjectId = \"{PROJECT_ID}\",\n        IamRoleId = \"{IAM_ROLE_ID}\",\n        BucketName = \"example_bucket\",\n        CloudProvider = \"AWS\",\n    });\n\n    var testCloudBackupSnapshotExportJob = new Mongodbatlas.CloudBackupSnapshotExportJob(\"test\", new()\n    {\n        ProjectId = \"{PROJECT_ID}\",\n        ClusterName = \"{CLUSTER_NAME}\",\n        SnapshotId = \"{SNAPSHOT_ID}\",\n        ExportBucketId = testCloudBackupSnapshotExportBucket.ExportBucketId,\n        CustomDatas = new[]\n        {\n            new Mongodbatlas.Inputs.CloudBackupSnapshotExportJobCustomDataArgs\n            {\n                Key = \"exported by\",\n                Value = \"myName\",\n            },\n        },\n    });\n\n    var test = Mongodbatlas.GetCloudBackupSnapshotExportJob.Invoke(new()\n    {\n        ProjectId = \"{PROJECT_ID}\",\n        ClusterName = \"{CLUSTER_NAME}\",\n        ExportJobId = testCloudBackupSnapshotExportJob.ExportJobId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestCloudBackupSnapshotExportBucket, err := mongodbatlas.NewCloudBackupSnapshotExportBucket(ctx, \"test\", \u0026mongodbatlas.CloudBackupSnapshotExportBucketArgs{\n\t\t\tProjectId:     pulumi.String(\"{PROJECT_ID}\"),\n\t\t\tIamRoleId:     pulumi.String(\"{IAM_ROLE_ID}\"),\n\t\t\tBucketName:    pulumi.String(\"example_bucket\"),\n\t\t\tCloudProvider: pulumi.String(\"AWS\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestCloudBackupSnapshotExportJob, err := mongodbatlas.NewCloudBackupSnapshotExportJob(ctx, \"test\", \u0026mongodbatlas.CloudBackupSnapshotExportJobArgs{\n\t\t\tProjectId:      pulumi.String(\"{PROJECT_ID}\"),\n\t\t\tClusterName:    pulumi.String(\"{CLUSTER_NAME}\"),\n\t\t\tSnapshotId:     pulumi.String(\"{SNAPSHOT_ID}\"),\n\t\t\tExportBucketId: testCloudBackupSnapshotExportBucket.ExportBucketId,\n\t\t\tCustomDatas: mongodbatlas.CloudBackupSnapshotExportJobCustomDataArray{\n\t\t\t\t\u0026mongodbatlas.CloudBackupSnapshotExportJobCustomDataArgs{\n\t\t\t\t\tKey:   pulumi.String(\"exported by\"),\n\t\t\t\t\tValue: pulumi.String(\"myName\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupCloudBackupSnapshotExportJobOutput(ctx, mongodbatlas.GetCloudBackupSnapshotExportJobOutputArgs{\n\t\t\tProjectId:   pulumi.String(\"{PROJECT_ID}\"),\n\t\t\tClusterName: pulumi.String(\"{CLUSTER_NAME}\"),\n\t\t\tExportJobId: testCloudBackupSnapshotExportJob.ExportJobId,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportBucket;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportBucketArgs;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportJob;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportJobArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudBackupSnapshotExportJobCustomDataArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetCloudBackupSnapshotExportJobArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testCloudBackupSnapshotExportBucket = new CloudBackupSnapshotExportBucket(\"testCloudBackupSnapshotExportBucket\", CloudBackupSnapshotExportBucketArgs.builder()\n            .projectId(\"{PROJECT_ID}\")\n            .iamRoleId(\"{IAM_ROLE_ID}\")\n            .bucketName(\"example_bucket\")\n            .cloudProvider(\"AWS\")\n            .build());\n\n        var testCloudBackupSnapshotExportJob = new CloudBackupSnapshotExportJob(\"testCloudBackupSnapshotExportJob\", CloudBackupSnapshotExportJobArgs.builder()\n            .projectId(\"{PROJECT_ID}\")\n            .clusterName(\"{CLUSTER_NAME}\")\n            .snapshotId(\"{SNAPSHOT_ID}\")\n            .exportBucketId(testCloudBackupSnapshotExportBucket.exportBucketId())\n            .customDatas(CloudBackupSnapshotExportJobCustomDataArgs.builder()\n                .key(\"exported by\")\n                .value(\"myName\")\n                .build())\n            .build());\n\n        final var test = MongodbatlasFunctions.getCloudBackupSnapshotExportJob(GetCloudBackupSnapshotExportJobArgs.builder()\n            .projectId(\"{PROJECT_ID}\")\n            .clusterName(\"{CLUSTER_NAME}\")\n            .exportJobId(testCloudBackupSnapshotExportJob.exportJobId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testCloudBackupSnapshotExportBucket:\n    type: mongodbatlas:CloudBackupSnapshotExportBucket\n    name: test\n    properties:\n      projectId: '{PROJECT_ID}'\n      iamRoleId: '{IAM_ROLE_ID}'\n      bucketName: example_bucket\n      cloudProvider: AWS\n  testCloudBackupSnapshotExportJob:\n    type: mongodbatlas:CloudBackupSnapshotExportJob\n    name: test\n    properties:\n      projectId: '{PROJECT_ID}'\n      clusterName: '{CLUSTER_NAME}'\n      snapshotId: '{SNAPSHOT_ID}'\n      exportBucketId: ${testCloudBackupSnapshotExportBucket.exportBucketId}\n      customDatas:\n        - key: exported by\n          value: myName\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getCloudBackupSnapshotExportJob\n      Arguments:\n        projectId: '{PROJECT_ID}'\n        clusterName: '{CLUSTER_NAME}'\n        exportJobId: ${testCloudBackupSnapshotExportJob.exportJobId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudBackupSnapshotExportJob.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "Name of the Atlas cluster whose export job you want to retrieve.\n"
                    },
                    "exportJobId": {
                        "type": "string",
                        "description": "Unique identifier of the export job to retrieve.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the project which contains the Atlas cluster whose snapshot you want to retrieve.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "exportJobId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudBackupSnapshotExportJob.\n",
                "properties": {
                    "clusterName": {
                        "type": "string"
                    },
                    "components": {
                        "description": "_Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudBackupSnapshotExportJobComponent:getCloudBackupSnapshotExportJobComponent"
                        },
                        "type": "array"
                    },
                    "createdAt": {
                        "description": "Timestamp in ISO 8601 date and time format in UTC when the export job was created.\n",
                        "type": "string"
                    },
                    "customDatas": {
                        "description": "Custom data to include in the metadata file named `.complete` that Atlas uploads to the bucket when the export job finishes. Custom data can be specified as key and value pairs.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudBackupSnapshotExportJobCustomData:getCloudBackupSnapshotExportJobCustomData"
                        },
                        "type": "array"
                    },
                    "errMsg": {
                        "deprecationMessage": "This parameter is deprecated and will be removed in version 1.20.0.",
                        "description": "Error message, only if the export job failed. **Note:** This attribute is deprecated as it is not being used.\n",
                        "type": "string"
                    },
                    "exportBucketId": {
                        "description": "Unique identifier of the AWS bucket to export the Cloud Backup snapshot to.\n",
                        "type": "string"
                    },
                    "exportJobId": {
                        "description": "Unique identifier of the export job.\n* `prefix ` - Full path on the cloud provider bucket to the folder where the snapshot is exported. The path is in the following format:`/exported_snapshots/{ORG-NAME}/{PROJECT-NAME}/{CLUSTER-NAME}/{SNAPSHOT-INITIATION-DATE}/{TIMESTAMP}`\n",
                        "type": "string"
                    },
                    "exportStatusExportedCollections": {
                        "type": "integer"
                    },
                    "exportStatusTotalCollections": {
                        "type": "integer"
                    },
                    "finishedAt": {
                        "description": "Timestamp in ISO 8601 date and time format in UTC when the export job completes.\n",
                        "type": "string"
                    },
                    "id": {
                        "type": "string"
                    },
                    "prefix": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "snapshotId": {
                        "description": "Unique identifier of the Cloud Backup snapshot to export.\n",
                        "type": "string"
                    },
                    "state": {
                        "description": "Status of the export job. Value can be one of the following:\n* `Queued` - indicates that the export job is queued\n* `InProgress` - indicates that the snapshot is being exported\n* `Successful` - indicates that the export job has completed successfully\n* `Failed` - indicates that the export job has failed\n",
                        "type": "string"
                    }
                },
                "required": [
                    "clusterName",
                    "components",
                    "createdAt",
                    "customDatas",
                    "errMsg",
                    "exportBucketId",
                    "exportJobId",
                    "exportStatusExportedCollections",
                    "exportStatusTotalCollections",
                    "finishedAt",
                    "id",
                    "prefix",
                    "projectId",
                    "snapshotId",
                    "state"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotExportJobs:getCloudBackupSnapshotExportJobs": {
            "description": "## # Data Source: mongodbatlas.getCloudBackupSnapshotExportJobs\n\n`mongodbatlas.getCloudBackupSnapshotExportJobs` datasource allows you to retrieve all the buckets for the specified project.\n\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testCloudBackupSnapshotExportBucket = new mongodbatlas.CloudBackupSnapshotExportBucket(\"test\", {\n    projectId: \"{PROJECT_ID}\",\n    iamRoleId: \"{IAM_ROLE_ID}\",\n    bucketName: \"example_bucket\",\n    cloudProvider: \"AWS\",\n});\nconst testCloudBackupSnapshotExportJob = new mongodbatlas.CloudBackupSnapshotExportJob(\"test\", {\n    projectId: \"{PROJECT_ID}\",\n    clusterName: \"{CLUSTER_NAME}\",\n    snapshotId: \"{SNAPSHOT_ID}\",\n    exportBucketId: testCloudBackupSnapshotExportBucket.exportBucketId,\n    customDatas: [{\n        key: \"exported by\",\n        value: \"myName\",\n    }],\n});\nconst test = mongodbatlas.getCloudBackupSnapshotExportJobs({\n    projectId: \"{PROJECT_ID}\",\n    clusterName: \"{CLUSTER_NAME}\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_cloud_backup_snapshot_export_bucket = mongodbatlas.CloudBackupSnapshotExportBucket(\"test\",\n    project_id=\"{PROJECT_ID}\",\n    iam_role_id=\"{IAM_ROLE_ID}\",\n    bucket_name=\"example_bucket\",\n    cloud_provider=\"AWS\")\ntest_cloud_backup_snapshot_export_job = mongodbatlas.CloudBackupSnapshotExportJob(\"test\",\n    project_id=\"{PROJECT_ID}\",\n    cluster_name=\"{CLUSTER_NAME}\",\n    snapshot_id=\"{SNAPSHOT_ID}\",\n    export_bucket_id=test_cloud_backup_snapshot_export_bucket.export_bucket_id,\n    custom_datas=[{\n        \"key\": \"exported by\",\n        \"value\": \"myName\",\n    }])\ntest = mongodbatlas.get_cloud_backup_snapshot_export_jobs(project_id=\"{PROJECT_ID}\",\n    cluster_name=\"{CLUSTER_NAME}\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testCloudBackupSnapshotExportBucket = new Mongodbatlas.CloudBackupSnapshotExportBucket(\"test\", new()\n    {\n        ProjectId = \"{PROJECT_ID}\",\n        IamRoleId = \"{IAM_ROLE_ID}\",\n        BucketName = \"example_bucket\",\n        CloudProvider = \"AWS\",\n    });\n\n    var testCloudBackupSnapshotExportJob = new Mongodbatlas.CloudBackupSnapshotExportJob(\"test\", new()\n    {\n        ProjectId = \"{PROJECT_ID}\",\n        ClusterName = \"{CLUSTER_NAME}\",\n        SnapshotId = \"{SNAPSHOT_ID}\",\n        ExportBucketId = testCloudBackupSnapshotExportBucket.ExportBucketId,\n        CustomDatas = new[]\n        {\n            new Mongodbatlas.Inputs.CloudBackupSnapshotExportJobCustomDataArgs\n            {\n                Key = \"exported by\",\n                Value = \"myName\",\n            },\n        },\n    });\n\n    var test = Mongodbatlas.GetCloudBackupSnapshotExportJobs.Invoke(new()\n    {\n        ProjectId = \"{PROJECT_ID}\",\n        ClusterName = \"{CLUSTER_NAME}\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestCloudBackupSnapshotExportBucket, err := mongodbatlas.NewCloudBackupSnapshotExportBucket(ctx, \"test\", \u0026mongodbatlas.CloudBackupSnapshotExportBucketArgs{\n\t\t\tProjectId:     pulumi.String(\"{PROJECT_ID}\"),\n\t\t\tIamRoleId:     pulumi.String(\"{IAM_ROLE_ID}\"),\n\t\t\tBucketName:    pulumi.String(\"example_bucket\"),\n\t\t\tCloudProvider: pulumi.String(\"AWS\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewCloudBackupSnapshotExportJob(ctx, \"test\", \u0026mongodbatlas.CloudBackupSnapshotExportJobArgs{\n\t\t\tProjectId:      pulumi.String(\"{PROJECT_ID}\"),\n\t\t\tClusterName:    pulumi.String(\"{CLUSTER_NAME}\"),\n\t\t\tSnapshotId:     pulumi.String(\"{SNAPSHOT_ID}\"),\n\t\t\tExportBucketId: testCloudBackupSnapshotExportBucket.ExportBucketId,\n\t\t\tCustomDatas: mongodbatlas.CloudBackupSnapshotExportJobCustomDataArray{\n\t\t\t\t\u0026mongodbatlas.CloudBackupSnapshotExportJobCustomDataArgs{\n\t\t\t\t\tKey:   pulumi.String(\"exported by\"),\n\t\t\t\t\tValue: pulumi.String(\"myName\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.LookupCloudBackupSnapshotExportJobs(ctx, \u0026mongodbatlas.LookupCloudBackupSnapshotExportJobsArgs{\n\t\t\tProjectId:   \"{PROJECT_ID}\",\n\t\t\tClusterName: \"{CLUSTER_NAME}\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportBucket;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportBucketArgs;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportJob;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotExportJobArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudBackupSnapshotExportJobCustomDataArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetCloudBackupSnapshotExportJobsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testCloudBackupSnapshotExportBucket = new CloudBackupSnapshotExportBucket(\"testCloudBackupSnapshotExportBucket\", CloudBackupSnapshotExportBucketArgs.builder()\n            .projectId(\"{PROJECT_ID}\")\n            .iamRoleId(\"{IAM_ROLE_ID}\")\n            .bucketName(\"example_bucket\")\n            .cloudProvider(\"AWS\")\n            .build());\n\n        var testCloudBackupSnapshotExportJob = new CloudBackupSnapshotExportJob(\"testCloudBackupSnapshotExportJob\", CloudBackupSnapshotExportJobArgs.builder()\n            .projectId(\"{PROJECT_ID}\")\n            .clusterName(\"{CLUSTER_NAME}\")\n            .snapshotId(\"{SNAPSHOT_ID}\")\n            .exportBucketId(testCloudBackupSnapshotExportBucket.exportBucketId())\n            .customDatas(CloudBackupSnapshotExportJobCustomDataArgs.builder()\n                .key(\"exported by\")\n                .value(\"myName\")\n                .build())\n            .build());\n\n        final var test = MongodbatlasFunctions.getCloudBackupSnapshotExportJobs(GetCloudBackupSnapshotExportJobsArgs.builder()\n            .projectId(\"{PROJECT_ID}\")\n            .clusterName(\"{CLUSTER_NAME}\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testCloudBackupSnapshotExportBucket:\n    type: mongodbatlas:CloudBackupSnapshotExportBucket\n    name: test\n    properties:\n      projectId: '{PROJECT_ID}'\n      iamRoleId: '{IAM_ROLE_ID}'\n      bucketName: example_bucket\n      cloudProvider: AWS\n  testCloudBackupSnapshotExportJob:\n    type: mongodbatlas:CloudBackupSnapshotExportJob\n    name: test\n    properties:\n      projectId: '{PROJECT_ID}'\n      clusterName: '{CLUSTER_NAME}'\n      snapshotId: '{SNAPSHOT_ID}'\n      exportBucketId: ${testCloudBackupSnapshotExportBucket.exportBucketId}\n      customDatas:\n        - key: exported by\n          value: myName\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getCloudBackupSnapshotExportJobs\n      Arguments:\n        projectId: '{PROJECT_ID}'\n        clusterName: '{CLUSTER_NAME}'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudBackupSnapshotExportJobs.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "Name of the Atlas cluster whose export job you want to retrieve.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer",
                        "description": "Number of items to return per page, up to a maximum of 500. Defaults to `100`.\n"
                    },
                    "pageNum": {
                        "type": "integer",
                        "description": "The page to return. Defaults to `1`.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudBackupSnapshotExportJobs.\n",
                "properties": {
                    "clusterName": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "projectId": {
                        "description": "The unique identifier of the project for the Atlas cluster.\n",
                        "type": "string"
                    },
                    "results": {
                        "description": "Includes CloudProviderSnapshotExportJob object for each item detailed in the results array section.\n* `totalCount` - Count of the total number of items in the result set. It may be greater than the number of objects in the results array if the entire result set is paginated.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudBackupSnapshotExportJobsResult:getCloudBackupSnapshotExportJobsResult"
                        },
                        "type": "array"
                    },
                    "totalCount": {
                        "type": "integer"
                    }
                },
                "required": [
                    "clusterName",
                    "projectId",
                    "results",
                    "totalCount",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotRestoreJob:getCloudBackupSnapshotRestoreJob": {
            "description": "## # Data Source: mongodbatlas.CloudBackupSnapshotRestoreJob\n\n`mongodbatlas.CloudBackupSnapshotRestoreJob` provides a Cloud Backup Snapshot Restore Job datasource. Gets all the cloud backup snapshot restore jobs for the specified cluster.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n## Example Usage\n\nFirst create a snapshot of the desired cluster. Then request that snapshot be restored in an automated fashion to the designated cluster and project.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nresources:\n  testCloudBackupSnapshot:\n    type: mongodbatlas:CloudBackupSnapshot\n    name: test\n    properties:\n      projectId: 5cf5a45a9ccf6400e60981b6\n      clusterName: MyCluster\n      description: MyDescription\n      retentionInDays: 1\n  testCloudBackupSnapshotRestoreJob:\n    type: mongodbatlas:CloudBackupSnapshotRestoreJob\n    name: test\n    properties:\n      projectId: 5cf5a45a9ccf6400e60981b6\n      clusterName: MyCluster\n      snapshotId: ${testCloudBackupSnapshot.id}\n      deliveryType:\n        - automated: true\n          targetClusterName: MyCluster\n          targetProjectId: 5cf5a45a9ccf6400e60981b6\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getCloudBackupSnapshotRestoreJob\n      Arguments:\n        projectId: ${testCloudBackupSnapshotRestoreJob.projectId}\n        clusterName: ${testCloudBackupSnapshotRestoreJob.clusterName}\n        snapshotRestoreJobId: ${testCloudBackupSnapshotRestoreJob.snapshotRestoreJobId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudBackupSnapshotRestoreJob.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the Atlas cluster for which you want to retrieve the restore job.\n",
                        "willReplaceOnChanges": true
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster.\n",
                        "willReplaceOnChanges": true
                    },
                    "snapshotRestoreJobId": {
                        "type": "string",
                        "description": "The unique identifier of the restore job to retrieve.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId",
                    "snapshotRestoreJobId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudBackupSnapshotRestoreJob.\n",
                "properties": {
                    "cancelled": {
                        "description": "Indicates whether the restore job was canceled.\n",
                        "type": "boolean"
                    },
                    "clusterName": {
                        "type": "string"
                    },
                    "deliveryType": {
                        "description": "Type of restore job to create. Possible values are: automated and download.\n",
                        "type": "string"
                    },
                    "deliveryUrls": {
                        "description": "One or more URLs for the compressed snapshot files for manual download. Only visible if deliveryType is download.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "expired": {
                        "description": "Indicates whether the restore job expired.\n",
                        "type": "boolean"
                    },
                    "expiresAt": {
                        "description": "UTC ISO 8601 formatted point in time when the restore job expires.\n",
                        "type": "string"
                    },
                    "finishedAt": {
                        "description": "UTC ISO 8601 formatted point in time when the restore job completed.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "oplogInc": {
                        "type": "integer"
                    },
                    "oplogTs": {
                        "type": "integer"
                    },
                    "pointInTimeUtcSeconds": {
                        "type": "integer"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "snapshotId": {
                        "description": "Unique identifier of the source snapshot ID of the restore job.\n",
                        "type": "string"
                    },
                    "snapshotRestoreJobId": {
                        "type": "string"
                    },
                    "targetClusterName": {
                        "description": "Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.\n",
                        "type": "string"
                    },
                    "targetProjectId": {
                        "description": "Name of the target Atlas project of the restore job. Only visible if deliveryType is automated.\n",
                        "type": "string"
                    },
                    "timestamp": {
                        "description": "Timestamp in ISO 8601 date and time format in UTC when the snapshot associated to snapshotId was taken.\n* `oplogTs` - Timestamp in the number of seconds that have elapsed since the UNIX epoch.\n* `oplogInc` - Oplog operation number from which to you want to restore this snapshot.\n* `pointInTimeUTCSeconds` - Timestamp in the number of seconds that have elapsed since the UNIX epoch.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "cancelled",
                    "clusterName",
                    "deliveryType",
                    "deliveryUrls",
                    "expired",
                    "expiresAt",
                    "finishedAt",
                    "oplogInc",
                    "oplogTs",
                    "pointInTimeUtcSeconds",
                    "projectId",
                    "snapshotId",
                    "snapshotRestoreJobId",
                    "targetClusterName",
                    "targetProjectId",
                    "timestamp",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshotRestoreJobs:getCloudBackupSnapshotRestoreJobs": {
            "description": "## # Data Source: mongodbatlas.getCloudBackupSnapshotRestoreJobs\n\n`mongodbatlas.getCloudBackupSnapshotRestoreJobs` provides a Cloud Backup Snapshot Restore Jobs datasource. Gets all the cloud backup snapshot restore jobs for the specified cluster.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n## Example Usage\n\nFirst create a snapshot of the desired cluster. Then request that snapshot be restored in an automated fashion to the designated cluster and project.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testCloudBackupSnapshot = new mongodbatlas.CloudBackupSnapshot(\"test\", {\n    projectId: \"5cf5a45a9ccf6400e60981b6\",\n    clusterName: \"MyCluster\",\n    description: \"MyDescription\",\n    retentionInDays: 1,\n});\nconst testCloudBackupSnapshotRestoreJob = new mongodbatlas.CloudBackupSnapshotRestoreJob(\"test\", {\n    projectId: \"5cf5a45a9ccf6400e60981b6\",\n    clusterName: \"MyCluster\",\n    snapshotId: testCloudBackupSnapshot.id,\n    deliveryTypeConfig: {\n        automated: true,\n        targetClusterName: \"MyCluster\",\n        targetProjectId: \"5cf5a45a9ccf6400e60981b6\",\n    },\n});\nconst test = pulumi.all([testCloudBackupSnapshotRestoreJob.projectId, testCloudBackupSnapshotRestoreJob.clusterName]).apply(([projectId, clusterName]) =\u003e mongodbatlas.getCloudBackupSnapshotRestoreJobsOutput({\n    projectId: projectId,\n    clusterName: clusterName,\n    pageNum: 1,\n    itemsPerPage: 5,\n}));\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_cloud_backup_snapshot = mongodbatlas.CloudBackupSnapshot(\"test\",\n    project_id=\"5cf5a45a9ccf6400e60981b6\",\n    cluster_name=\"MyCluster\",\n    description=\"MyDescription\",\n    retention_in_days=1)\ntest_cloud_backup_snapshot_restore_job = mongodbatlas.CloudBackupSnapshotRestoreJob(\"test\",\n    project_id=\"5cf5a45a9ccf6400e60981b6\",\n    cluster_name=\"MyCluster\",\n    snapshot_id=test_cloud_backup_snapshot.id,\n    delivery_type_config={\n        \"automated\": True,\n        \"target_cluster_name\": \"MyCluster\",\n        \"target_project_id\": \"5cf5a45a9ccf6400e60981b6\",\n    })\ntest = pulumi.Output.all(\n    project_id=test_cloud_backup_snapshot_restore_job.project_id,\n    cluster_name=test_cloud_backup_snapshot_restore_job.cluster_name\n).apply(lambda resolved_outputs: mongodbatlas.get_cloud_backup_snapshot_restore_jobs_output(project_id=resolved_outputs['project_id'],\n    cluster_name=resolved_outputs['cluster_name'],\n    page_num=1,\n    items_per_page=5))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testCloudBackupSnapshot = new Mongodbatlas.CloudBackupSnapshot(\"test\", new()\n    {\n        ProjectId = \"5cf5a45a9ccf6400e60981b6\",\n        ClusterName = \"MyCluster\",\n        Description = \"MyDescription\",\n        RetentionInDays = 1,\n    });\n\n    var testCloudBackupSnapshotRestoreJob = new Mongodbatlas.CloudBackupSnapshotRestoreJob(\"test\", new()\n    {\n        ProjectId = \"5cf5a45a9ccf6400e60981b6\",\n        ClusterName = \"MyCluster\",\n        SnapshotId = testCloudBackupSnapshot.Id,\n        DeliveryTypeConfig = new Mongodbatlas.Inputs.CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs\n        {\n            Automated = true,\n            TargetClusterName = \"MyCluster\",\n            TargetProjectId = \"5cf5a45a9ccf6400e60981b6\",\n        },\n    });\n\n    var test = Mongodbatlas.GetCloudBackupSnapshotRestoreJobs.Invoke(new()\n    {\n        ProjectId = testCloudBackupSnapshotRestoreJob.ProjectId,\n        ClusterName = testCloudBackupSnapshotRestoreJob.ClusterName,\n        PageNum = 1,\n        ItemsPerPage = 5,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestCloudBackupSnapshot, err := mongodbatlas.NewCloudBackupSnapshot(ctx, \"test\", \u0026mongodbatlas.CloudBackupSnapshotArgs{\n\t\t\tProjectId:       pulumi.String(\"5cf5a45a9ccf6400e60981b6\"),\n\t\t\tClusterName:     pulumi.String(\"MyCluster\"),\n\t\t\tDescription:     pulumi.String(\"MyDescription\"),\n\t\t\tRetentionInDays: pulumi.Int(1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestCloudBackupSnapshotRestoreJob, err := mongodbatlas.NewCloudBackupSnapshotRestoreJob(ctx, \"test\", \u0026mongodbatlas.CloudBackupSnapshotRestoreJobArgs{\n\t\t\tProjectId:   pulumi.String(\"5cf5a45a9ccf6400e60981b6\"),\n\t\t\tClusterName: pulumi.String(\"MyCluster\"),\n\t\t\tSnapshotId:  testCloudBackupSnapshot.ID(),\n\t\t\tDeliveryTypeConfig: \u0026mongodbatlas.CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs{\n\t\t\t\tAutomated:         pulumi.Bool(true),\n\t\t\t\tTargetClusterName: pulumi.String(\"MyCluster\"),\n\t\t\t\tTargetProjectId:   pulumi.String(\"5cf5a45a9ccf6400e60981b6\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = pulumi.All(testCloudBackupSnapshotRestoreJob.ProjectId, testCloudBackupSnapshotRestoreJob.ClusterName).ApplyT(func(_args []interface{}) (mongodbatlas.GetCloudBackupSnapshotRestoreJobsResult, error) {\n\t\t\tprojectId := _args[0].(string)\n\t\t\tclusterName := _args[1].(string)\n\t\t\treturn mongodbatlas.GetCloudBackupSnapshotRestoreJobsResult(interface{}(mongodbatlas.LookupCloudBackupSnapshotRestoreJobsOutput(ctx, mongodbatlas.GetCloudBackupSnapshotRestoreJobsOutputArgs{\n\t\t\t\tProjectId:    projectId,\n\t\t\t\tClusterName:  clusterName,\n\t\t\t\tPageNum:      1,\n\t\t\t\tItemsPerPage: 5,\n\t\t\t}, nil))), nil\n\t\t}).(mongodbatlas.GetCloudBackupSnapshotRestoreJobsResultOutput)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshot;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotArgs;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotRestoreJob;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotRestoreJobArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetCloudBackupSnapshotRestoreJobsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testCloudBackupSnapshot = new CloudBackupSnapshot(\"testCloudBackupSnapshot\", CloudBackupSnapshotArgs.builder()\n            .projectId(\"5cf5a45a9ccf6400e60981b6\")\n            .clusterName(\"MyCluster\")\n            .description(\"MyDescription\")\n            .retentionInDays(1)\n            .build());\n\n        var testCloudBackupSnapshotRestoreJob = new CloudBackupSnapshotRestoreJob(\"testCloudBackupSnapshotRestoreJob\", CloudBackupSnapshotRestoreJobArgs.builder()\n            .projectId(\"5cf5a45a9ccf6400e60981b6\")\n            .clusterName(\"MyCluster\")\n            .snapshotId(testCloudBackupSnapshot.id())\n            .deliveryTypeConfig(CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs.builder()\n                .automated(true)\n                .targetClusterName(\"MyCluster\")\n                .targetProjectId(\"5cf5a45a9ccf6400e60981b6\")\n                .build())\n            .build());\n\n        final var test = MongodbatlasFunctions.getCloudBackupSnapshotRestoreJobs(GetCloudBackupSnapshotRestoreJobsArgs.builder()\n            .projectId(testCloudBackupSnapshotRestoreJob.projectId())\n            .clusterName(testCloudBackupSnapshotRestoreJob.clusterName())\n            .pageNum(1)\n            .itemsPerPage(5)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testCloudBackupSnapshot:\n    type: mongodbatlas:CloudBackupSnapshot\n    name: test\n    properties:\n      projectId: 5cf5a45a9ccf6400e60981b6\n      clusterName: MyCluster\n      description: MyDescription\n      retentionInDays: 1\n  testCloudBackupSnapshotRestoreJob:\n    type: mongodbatlas:CloudBackupSnapshotRestoreJob\n    name: test\n    properties:\n      projectId: 5cf5a45a9ccf6400e60981b6\n      clusterName: MyCluster\n      snapshotId: ${testCloudBackupSnapshot.id}\n      deliveryTypeConfig:\n        automated: true\n        targetClusterName: MyCluster\n        targetProjectId: 5cf5a45a9ccf6400e60981b6\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getCloudBackupSnapshotRestoreJobs\n      Arguments:\n        projectId: ${testCloudBackupSnapshotRestoreJob.projectId}\n        clusterName: ${testCloudBackupSnapshotRestoreJob.clusterName}\n        pageNum: 1\n        itemsPerPage: 5\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudBackupSnapshotRestoreJobs.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the Atlas cluster for which you want to retrieve restore jobs.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer",
                        "description": "Number of items to return per page, up to a maximum of 500. Defaults to `100`.\n"
                    },
                    "pageNum": {
                        "type": "integer",
                        "description": "The page to return. Defaults to `1`.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Atlas cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudBackupSnapshotRestoreJobs.\n",
                "properties": {
                    "clusterName": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "description": "Includes cloudProviderSnapshotRestoreJob object for each item detailed in the results array section.\n* `totalCount` - Count of the total number of items in the result set. It may be greater than the number of objects in the results array if the entire result set is paginated.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudBackupSnapshotRestoreJobsResult:getCloudBackupSnapshotRestoreJobsResult"
                        },
                        "type": "array"
                    },
                    "totalCount": {
                        "type": "integer"
                    }
                },
                "required": [
                    "clusterName",
                    "projectId",
                    "results",
                    "totalCount",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getCloudBackupSnapshots:getCloudBackupSnapshots": {
            "description": "## # Data Source: mongodbatlas.getCloudBackupSnapshots\n\n`mongodbatlas.getCloudBackupSnapshots` provides an Cloud Backup Snapshot datasource. Atlas Cloud Backup Snapshots provide localized backup storage using the native snapshot functionality of the clusterâs cloud service.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.cloudBackupSnapshots;\nimport com.pulumi.mongodbatlas.CloudBackupSnapshotsArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetCloudBackupSnapshotsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testCloudBackupSnapshots = new CloudBackupSnapshots(\"testCloudBackupSnapshots\", CloudBackupSnapshotsArgs.builder()\n            .groupId(\"5d0f1f73cf09a29120e173cf\")\n            .clusterName(\"MyClusterTest\")\n            .description(\"SomeDescription\")\n            .retentionInDays(1)\n            .build());\n\n        final var test = MongodbatlasFunctions.getCloudBackupSnapshots(GetCloudBackupSnapshotsArgs.builder()\n            .groupId(testCloudBackupSnapshots.groupId())\n            .clusterName(testCloudBackupSnapshots.clusterName())\n            .pageNum(1)\n            .itemsPerPage(5)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testCloudBackupSnapshots:\n    type: mongodbatlas:cloudBackupSnapshots\n    name: test\n    properties:\n      groupId: 5d0f1f73cf09a29120e173cf\n      clusterName: MyClusterTest\n      description: SomeDescription\n      retentionInDays: 1\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getCloudBackupSnapshots\n      Arguments:\n        groupId: ${testCloudBackupSnapshots.groupId}\n        clusterName: ${testCloudBackupSnapshots.clusterName}\n        pageNum: 1\n        itemsPerPage: 5\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudBackupSnapshots.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the Atlas cluster that contains the snapshot you want to retrieve.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer",
                        "description": "Number of items to return per page, up to a maximum of 500. Defaults to `100`.\n"
                    },
                    "pageNum": {
                        "type": "integer",
                        "description": "The page to return. Defaults to `1`.\n"
                    },
                    "projectId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudBackupSnapshots.\n",
                "properties": {
                    "clusterName": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "description": "Includes cloudProviderSnapshot object for each item detailed in the results array section.\n* `totalCount` - Count of the total number of items in the result set. It may be greater than the number of objects in the results array if the entire result set is paginated.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudBackupSnapshotsResult:getCloudBackupSnapshotsResult"
                        },
                        "type": "array"
                    },
                    "totalCount": {
                        "type": "integer"
                    }
                },
                "required": [
                    "clusterName",
                    "projectId",
                    "results",
                    "totalCount",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getCloudProviderAccessSetup:getCloudProviderAccessSetup": {
            "description": "## # Data Source: mongodbatlas.CloudProviderAccessSetup\n\n`mongodbatlas.CloudProviderAccessSetup` allows you to get a single role for a provider access role setup, currently only AWS and Azure are supported.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n## Example Usage\n\n### With AWS\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testRole = new mongodbatlas.CloudProviderAccessSetup(\"test_role\", {\n    projectId: \"64259ee860c43338194b0f8e\",\n    providerName: \"AWS\",\n});\nconst singleSetup = mongodbatlas.getCloudProviderAccessSetupOutput({\n    projectId: testRole.projectId,\n    providerName: testRole.providerName,\n    roleId: testRole.roleId,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_role = mongodbatlas.CloudProviderAccessSetup(\"test_role\",\n    project_id=\"64259ee860c43338194b0f8e\",\n    provider_name=\"AWS\")\nsingle_setup = mongodbatlas.get_cloud_provider_access_setup_output(project_id=test_role.project_id,\n    provider_name=test_role.provider_name,\n    role_id=test_role.role_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testRole = new Mongodbatlas.CloudProviderAccessSetup(\"test_role\", new()\n    {\n        ProjectId = \"64259ee860c43338194b0f8e\",\n        ProviderName = \"AWS\",\n    });\n\n    var singleSetup = Mongodbatlas.GetCloudProviderAccessSetup.Invoke(new()\n    {\n        ProjectId = testRole.ProjectId,\n        ProviderName = testRole.ProviderName,\n        RoleId = testRole.RoleId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestRole, err := mongodbatlas.NewCloudProviderAccessSetup(ctx, \"test_role\", \u0026mongodbatlas.CloudProviderAccessSetupArgs{\n\t\t\tProjectId:    pulumi.String(\"64259ee860c43338194b0f8e\"),\n\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupCloudProviderAccessSetupOutput(ctx, mongodbatlas.GetCloudProviderAccessSetupOutputArgs{\n\t\t\tProjectId:    testRole.ProjectId,\n\t\t\tProviderName: testRole.ProviderName,\n\t\t\tRoleId:       testRole.RoleId,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CloudProviderAccessSetup;\nimport com.pulumi.mongodbatlas.CloudProviderAccessSetupArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetCloudProviderAccessSetupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testRole = new CloudProviderAccessSetup(\"testRole\", CloudProviderAccessSetupArgs.builder()\n            .projectId(\"64259ee860c43338194b0f8e\")\n            .providerName(\"AWS\")\n            .build());\n\n        final var singleSetup = MongodbatlasFunctions.getCloudProviderAccessSetup(GetCloudProviderAccessSetupArgs.builder()\n            .projectId(testRole.projectId())\n            .providerName(testRole.providerName())\n            .roleId(testRole.roleId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testRole:\n    type: mongodbatlas:CloudProviderAccessSetup\n    name: test_role\n    properties:\n      projectId: 64259ee860c43338194b0f8e\n      providerName: AWS\nvariables:\n  singleSetup:\n    fn::invoke:\n      Function: mongodbatlas:getCloudProviderAccessSetup\n      Arguments:\n        projectId: ${testRole.projectId}\n        providerName: ${testRole.providerName}\n        roleId: ${testRole.roleId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### With AZURE\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testRole = new mongodbatlas.CloudProviderAccessSetup(\"test_role\", {\n    projectId: \"64259ee860c43338194b0f8e\",\n    providerName: \"AZURE\",\n    azureConfigs: [{\n        atlasAzureAppId: \"9f2deb0d-be22-4524-a403-df531868bac0\",\n        servicePrincipalId: \"22f1d2a6-d0e9-482a-83a4-b8dd7dddc2c1\",\n        tenantId: \"91402384-d71e-22f5-22dd-759e272cdc1c\",\n    }],\n});\nconst singleSetup = mongodbatlas.getCloudProviderAccessSetupOutput({\n    projectId: testRole.projectId,\n    providerName: testRole.providerName,\n    roleId: testRole.roleId,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_role = mongodbatlas.CloudProviderAccessSetup(\"test_role\",\n    project_id=\"64259ee860c43338194b0f8e\",\n    provider_name=\"AZURE\",\n    azure_configs=[{\n        \"atlas_azure_app_id\": \"9f2deb0d-be22-4524-a403-df531868bac0\",\n        \"service_principal_id\": \"22f1d2a6-d0e9-482a-83a4-b8dd7dddc2c1\",\n        \"tenant_id\": \"91402384-d71e-22f5-22dd-759e272cdc1c\",\n    }])\nsingle_setup = mongodbatlas.get_cloud_provider_access_setup_output(project_id=test_role.project_id,\n    provider_name=test_role.provider_name,\n    role_id=test_role.role_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testRole = new Mongodbatlas.CloudProviderAccessSetup(\"test_role\", new()\n    {\n        ProjectId = \"64259ee860c43338194b0f8e\",\n        ProviderName = \"AZURE\",\n        AzureConfigs = new[]\n        {\n            new Mongodbatlas.Inputs.CloudProviderAccessSetupAzureConfigArgs\n            {\n                AtlasAzureAppId = \"9f2deb0d-be22-4524-a403-df531868bac0\",\n                ServicePrincipalId = \"22f1d2a6-d0e9-482a-83a4-b8dd7dddc2c1\",\n                TenantId = \"91402384-d71e-22f5-22dd-759e272cdc1c\",\n            },\n        },\n    });\n\n    var singleSetup = Mongodbatlas.GetCloudProviderAccessSetup.Invoke(new()\n    {\n        ProjectId = testRole.ProjectId,\n        ProviderName = testRole.ProviderName,\n        RoleId = testRole.RoleId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestRole, err := mongodbatlas.NewCloudProviderAccessSetup(ctx, \"test_role\", \u0026mongodbatlas.CloudProviderAccessSetupArgs{\n\t\t\tProjectId:    pulumi.String(\"64259ee860c43338194b0f8e\"),\n\t\t\tProviderName: pulumi.String(\"AZURE\"),\n\t\t\tAzureConfigs: mongodbatlas.CloudProviderAccessSetupAzureConfigArray{\n\t\t\t\t\u0026mongodbatlas.CloudProviderAccessSetupAzureConfigArgs{\n\t\t\t\t\tAtlasAzureAppId:    pulumi.String(\"9f2deb0d-be22-4524-a403-df531868bac0\"),\n\t\t\t\t\tServicePrincipalId: pulumi.String(\"22f1d2a6-d0e9-482a-83a4-b8dd7dddc2c1\"),\n\t\t\t\t\tTenantId:           pulumi.String(\"91402384-d71e-22f5-22dd-759e272cdc1c\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupCloudProviderAccessSetupOutput(ctx, mongodbatlas.GetCloudProviderAccessSetupOutputArgs{\n\t\t\tProjectId:    testRole.ProjectId,\n\t\t\tProviderName: testRole.ProviderName,\n\t\t\tRoleId:       testRole.RoleId,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CloudProviderAccessSetup;\nimport com.pulumi.mongodbatlas.CloudProviderAccessSetupArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudProviderAccessSetupAzureConfigArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetCloudProviderAccessSetupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testRole = new CloudProviderAccessSetup(\"testRole\", CloudProviderAccessSetupArgs.builder()\n            .projectId(\"64259ee860c43338194b0f8e\")\n            .providerName(\"AZURE\")\n            .azureConfigs(CloudProviderAccessSetupAzureConfigArgs.builder()\n                .atlasAzureAppId(\"9f2deb0d-be22-4524-a403-df531868bac0\")\n                .servicePrincipalId(\"22f1d2a6-d0e9-482a-83a4-b8dd7dddc2c1\")\n                .tenantId(\"91402384-d71e-22f5-22dd-759e272cdc1c\")\n                .build())\n            .build());\n\n        final var singleSetup = MongodbatlasFunctions.getCloudProviderAccessSetup(GetCloudProviderAccessSetupArgs.builder()\n            .projectId(testRole.projectId())\n            .providerName(testRole.providerName())\n            .roleId(testRole.roleId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testRole:\n    type: mongodbatlas:CloudProviderAccessSetup\n    name: test_role\n    properties:\n      projectId: 64259ee860c43338194b0f8e\n      providerName: AZURE\n      azureConfigs:\n        - atlasAzureAppId: 9f2deb0d-be22-4524-a403-df531868bac0\n          servicePrincipalId: 22f1d2a6-d0e9-482a-83a4-b8dd7dddc2c1\n          tenantId: 91402384-d71e-22f5-22dd-759e272cdc1c\nvariables:\n  singleSetup:\n    fn::invoke:\n      Function: mongodbatlas:getCloudProviderAccessSetup\n      Arguments:\n        projectId: ${testRole.projectId}\n        providerName: ${testRole.providerName}\n        roleId: ${testRole.roleId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCloudProviderAccessSetup.\n",
                "properties": {
                    "azureConfigs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudProviderAccessSetupAzureConfig:getCloudProviderAccessSetupAzureConfig"
                        },
                        "description": "azure related configurations\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to get all Cloud Provider Access\n"
                    },
                    "providerName": {
                        "type": "string",
                        "description": "cloud provider name, currently only AWS is supported\n"
                    },
                    "roleId": {
                        "type": "string",
                        "description": "unique role id among all the aws roles provided by mongodb atlas\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId",
                    "providerName",
                    "roleId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCloudProviderAccessSetup.\n",
                "properties": {
                    "aws": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "aws related role information\n",
                        "type": "object"
                    },
                    "awsConfigs": {
                        "description": "aws related role information\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudProviderAccessSetupAwsConfig:getCloudProviderAccessSetupAwsConfig"
                        },
                        "type": "array"
                    },
                    "azureConfigs": {
                        "description": "azure related configurations\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCloudProviderAccessSetupAzureConfig:getCloudProviderAccessSetupAzureConfig"
                        },
                        "type": "array"
                    },
                    "createdDate": {
                        "description": "Date on which this role was created.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "lastUpdatedDate": {
                        "description": "Date and time when this Azure Service Principal was last updated. This parameter expresses its value in the ISO 8601 timestamp format in UTC.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "providerName": {
                        "type": "string"
                    },
                    "roleId": {
                        "type": "string"
                    }
                },
                "required": [
                    "aws",
                    "awsConfigs",
                    "createdDate",
                    "lastUpdatedDate",
                    "projectId",
                    "providerName",
                    "roleId",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getCluster:getCluster": {
            "description": "## # Data Source: mongodbatlas.Cluster\n\n`mongodbatlas.Cluster` describes a Cluster. The data source requires your Project ID.\n\n\u003e **IMPORTANT:**\n\u003cbr\u003e \u0026#8226; Multi Region Cluster: The `mongodbatlas.Cluster` data source doesn't return the `container_id` for each region utilized by the cluster. For retrieving the `container_id`, we recommend the `mongodbatlas.AdvancedCluster` data source instead.\n\u003cbr\u003e \u0026#8226; Changes to cluster configurations can affect costs. Before making changes, please see [Billing](https://docs.atlas.mongodb.com/billing/).\n\u003cbr\u003e \u0026#8226; If your Atlas project contains a custom role that uses actions introduced in a specific MongoDB version, you cannot create a cluster with a MongoDB version less than that version unless you delete the custom role.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testCluster = new mongodbatlas.Cluster(\"test\", {\n    projectId: \"\u003cYOUR-PROJECT-ID\u003e\",\n    name: \"cluster-test\",\n    clusterType: \"REPLICASET\",\n    replicationSpecs: [{\n        numShards: 1,\n        regionsConfigs: [{\n            regionName: \"US_EAST_1\",\n            electableNodes: 3,\n            priority: 7,\n            readOnlyNodes: 0,\n        }],\n    }],\n    cloudBackup: true,\n    autoScalingDiskGbEnabled: true,\n    providerName: \"AWS\",\n    providerInstanceSizeName: \"M40\",\n});\nconst test = mongodbatlas.getClusterOutput({\n    projectId: testCluster.projectId,\n    name: testCluster.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_cluster = mongodbatlas.Cluster(\"test\",\n    project_id=\"\u003cYOUR-PROJECT-ID\u003e\",\n    name=\"cluster-test\",\n    cluster_type=\"REPLICASET\",\n    replication_specs=[{\n        \"num_shards\": 1,\n        \"regions_configs\": [{\n            \"region_name\": \"US_EAST_1\",\n            \"electable_nodes\": 3,\n            \"priority\": 7,\n            \"read_only_nodes\": 0,\n        }],\n    }],\n    cloud_backup=True,\n    auto_scaling_disk_gb_enabled=True,\n    provider_name=\"AWS\",\n    provider_instance_size_name=\"M40\")\ntest = mongodbatlas.get_cluster_output(project_id=test_cluster.project_id,\n    name=test_cluster.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testCluster = new Mongodbatlas.Cluster(\"test\", new()\n    {\n        ProjectId = \"\u003cYOUR-PROJECT-ID\u003e\",\n        Name = \"cluster-test\",\n        ClusterType = \"REPLICASET\",\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.ClusterReplicationSpecArgs\n            {\n                NumShards = 1,\n                RegionsConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.ClusterReplicationSpecRegionsConfigArgs\n                    {\n                        RegionName = \"US_EAST_1\",\n                        ElectableNodes = 3,\n                        Priority = 7,\n                        ReadOnlyNodes = 0,\n                    },\n                },\n            },\n        },\n        CloudBackup = true,\n        AutoScalingDiskGbEnabled = true,\n        ProviderName = \"AWS\",\n        ProviderInstanceSizeName = \"M40\",\n    });\n\n    var test = Mongodbatlas.GetCluster.Invoke(new()\n    {\n        ProjectId = testCluster.ProjectId,\n        Name = testCluster.Name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestCluster, err := mongodbatlas.NewCluster(ctx, \"test\", \u0026mongodbatlas.ClusterArgs{\n\t\t\tProjectId:   pulumi.String(\"\u003cYOUR-PROJECT-ID\u003e\"),\n\t\t\tName:        pulumi.String(\"cluster-test\"),\n\t\t\tClusterType: pulumi.String(\"REPLICASET\"),\n\t\t\tReplicationSpecs: mongodbatlas.ClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecArgs{\n\t\t\t\t\tNumShards: pulumi.Int(1),\n\t\t\t\t\tRegionsConfigs: mongodbatlas.ClusterReplicationSpecRegionsConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecRegionsConfigArgs{\n\t\t\t\t\t\t\tRegionName:     pulumi.String(\"US_EAST_1\"),\n\t\t\t\t\t\t\tElectableNodes: pulumi.Int(3),\n\t\t\t\t\t\t\tPriority:       pulumi.Int(7),\n\t\t\t\t\t\t\tReadOnlyNodes:  pulumi.Int(0),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tCloudBackup:              pulumi.Bool(true),\n\t\t\tAutoScalingDiskGbEnabled: pulumi.Bool(true),\n\t\t\tProviderName:             pulumi.String(\"AWS\"),\n\t\t\tProviderInstanceSizeName: pulumi.String(\"M40\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupClusterOutput(ctx, mongodbatlas.GetClusterOutputArgs{\n\t\t\tProjectId: testCluster.ProjectId,\n\t\t\tName:      testCluster.Name,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Cluster;\nimport com.pulumi.mongodbatlas.ClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.ClusterReplicationSpecArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetClusterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testCluster = new Cluster(\"testCluster\", ClusterArgs.builder()\n            .projectId(\"\u003cYOUR-PROJECT-ID\u003e\")\n            .name(\"cluster-test\")\n            .clusterType(\"REPLICASET\")\n            .replicationSpecs(ClusterReplicationSpecArgs.builder()\n                .numShards(1)\n                .regionsConfigs(ClusterReplicationSpecRegionsConfigArgs.builder()\n                    .regionName(\"US_EAST_1\")\n                    .electableNodes(3)\n                    .priority(7)\n                    .readOnlyNodes(0)\n                    .build())\n                .build())\n            .cloudBackup(true)\n            .autoScalingDiskGbEnabled(true)\n            .providerName(\"AWS\")\n            .providerInstanceSizeName(\"M40\")\n            .build());\n\n        final var test = MongodbatlasFunctions.getCluster(GetClusterArgs.builder()\n            .projectId(testCluster.projectId())\n            .name(testCluster.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testCluster:\n    type: mongodbatlas:Cluster\n    name: test\n    properties:\n      projectId: \u003cYOUR-PROJECT-ID\u003e\n      name: cluster-test\n      clusterType: REPLICASET\n      replicationSpecs:\n        - numShards: 1\n          regionsConfigs:\n            - regionName: US_EAST_1\n              electableNodes: 3\n              priority: 7\n              readOnlyNodes: 0\n      cloudBackup: true\n      autoScalingDiskGbEnabled: true # Provider Settings \"block\"\n      providerName: AWS\n      providerInstanceSizeName: M40\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getCluster\n      Arguments:\n        projectId: ${testCluster.projectId}\n        name: ${testCluster.name}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCluster.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Name of the cluster as it appears in Atlas. Once the cluster is created, its name cannot be changed.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the database user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCluster.\n",
                "properties": {
                    "advancedConfigurations": {
                        "description": "Get the advanced configuration options. See Advanced Configuration below for more details.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getClusterAdvancedConfiguration:getClusterAdvancedConfiguration"
                        },
                        "type": "array"
                    },
                    "autoScalingComputeEnabled": {
                        "description": "Specifies whether cluster tier auto-scaling is enabled. The default is false.\n",
                        "type": "boolean"
                    },
                    "autoScalingComputeScaleDownEnabled": {
                        "description": "Specifies whether cluster tier auto-down-scaling is enabled.\n",
                        "type": "boolean"
                    },
                    "autoScalingDiskGbEnabled": {
                        "description": "Indicates whether disk auto-scaling is enabled.\n",
                        "type": "boolean"
                    },
                    "backingProviderName": {
                        "description": "Indicates Cloud service provider on which the server for a multi-tenant cluster is provisioned.\n",
                        "type": "string"
                    },
                    "backupEnabled": {
                        "description": "Legacy Option, Indicates whether Atlas continuous backups are enabled for the cluster.\n",
                        "type": "boolean"
                    },
                    "biConnectorConfigs": {
                        "description": "Indicates BI Connector for Atlas configuration on this cluster. BI Connector for Atlas is only available for M10+ clusters. See BI Connector below for more details.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getClusterBiConnectorConfig:getClusterBiConnectorConfig"
                        },
                        "type": "array"
                    },
                    "clusterType": {
                        "description": "Indicates the type of the cluster that you want to modify. You cannot convert a sharded cluster deployment to a replica set deployment.\n",
                        "type": "string"
                    },
                    "connectionStrings": {
                        "description": "Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/).\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getClusterConnectionString:getClusterConnectionString"
                        },
                        "type": "array"
                    },
                    "containerId": {
                        "description": "The Network Peering Container ID.\n",
                        "type": "string"
                    },
                    "diskSizeGb": {
                        "description": "Indicates the size in gigabytes of the serverâs root volume (AWS/GCP Only).\n",
                        "type": "number"
                    },
                    "encryptionAtRestProvider": {
                        "description": "Indicates whether Encryption at Rest is enabled or disabled.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "labels": {
                        "deprecationMessage": "This parameter is deprecated and will be removed by September 2024. Please transition to tags.",
                        "description": "Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below. **DEPRECATED** Use `tags` instead.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getClusterLabel:getClusterLabel"
                        },
                        "type": "array"
                    },
                    "mongoDbMajorVersion": {
                        "description": "Indicates the version of the cluster to deploy.\n",
                        "type": "string"
                    },
                    "mongoDbVersion": {
                        "description": "Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.\n",
                        "type": "string"
                    },
                    "mongoUri": {
                        "description": "Base connection string for the cluster. Atlas only displays this field after the cluster is operational, not while it builds the cluster.\n",
                        "type": "string"
                    },
                    "mongoUriUpdated": {
                        "description": "Lists when the connection string was last updated. The connection string changes, for example, if you change a replica set to a sharded cluster.\n",
                        "type": "string"
                    },
                    "mongoUriWithOptions": {
                        "description": "Describes connection string for connecting to the Atlas cluster. Includes the replicaSet, ssl, and authSource query parameters in the connection string with values appropriate for the cluster.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "The name of the current plugin\n",
                        "type": "string"
                    },
                    "numShards": {
                        "description": "Number of shards to deploy in the specified zone.\n",
                        "type": "integer"
                    },
                    "paused": {
                        "description": "Flag that indicates whether the cluster is paused or not.\n",
                        "type": "boolean"
                    },
                    "pitEnabled": {
                        "description": "Flag that indicates if the cluster uses Continuous Cloud Backup.\n",
                        "type": "boolean"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "providerAutoScalingComputeMaxInstanceSize": {
                        "description": "Maximum instance size to which your cluster can automatically scale.\n",
                        "type": "string"
                    },
                    "providerAutoScalingComputeMinInstanceSize": {
                        "description": "Minimum instance size to which your cluster can automatically scale.\n",
                        "type": "string"
                    },
                    "providerBackupEnabled": {
                        "type": "boolean"
                    },
                    "providerDiskIops": {
                        "description": "Indicates the maximum input/output operations per second (IOPS) the system can perform. The possible values depend on the selected providerSettings.instanceSizeName and diskSizeGB.\n",
                        "type": "integer"
                    },
                    "providerDiskTypeName": {
                        "description": "Describes Azure disk type of the serverâs root volume (Azure Only).\n",
                        "type": "string"
                    },
                    "providerEncryptEbsVolume": {
                        "description": "**(DEPRECATED)** Indicates whether the Amazon EBS encryption is enabled. This feature encrypts the serverâs root volume for both data at rest within the volume and data moving between the volume and the instance. By default this attribute is always enabled, per deprecation process showing the real value at `provider_encrypt_ebs_volume_flag` computed attribute.\n",
                        "type": "boolean"
                    },
                    "providerEncryptEbsVolumeFlag": {
                        "type": "boolean"
                    },
                    "providerInstanceSizeName": {
                        "description": "Atlas provides different instance sizes, each with a default storage capacity and RAM size.\n",
                        "type": "string"
                    },
                    "providerName": {
                        "description": "Indicates the cloud service provider on which the servers are provisioned.\n",
                        "type": "string"
                    },
                    "providerRegionName": {
                        "description": "Indicates Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the Atlas Region name, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).\n",
                        "type": "string"
                    },
                    "providerVolumeType": {
                        "description": "Indicates the type of the volume. The possible values are: `STANDARD` and `PROVISIONED`.\n\u003e **NOTE:** `STANDARD` is not available for NVME clusters.\n",
                        "type": "string"
                    },
                    "replicationFactor": {
                        "description": "(Deprecated) Number of replica set members. Each member keeps a copy of your databases, providing high availability and data redundancy. The possible values are 3, 5, or 7. The default value is 3.\n",
                        "type": "integer"
                    },
                    "replicationSpecs": {
                        "description": "Configuration for cluster regions.  See Replication Spec below for more details.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getClusterReplicationSpec:getClusterReplicationSpec"
                        },
                        "type": "array"
                    },
                    "snapshotBackupPolicies": {
                        "description": "current snapshot schedule and retention settings for the cluster.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getClusterSnapshotBackupPolicy:getClusterSnapshotBackupPolicy"
                        },
                        "type": "array"
                    },
                    "srvAddress": {
                        "description": "Connection string for connecting to the Atlas cluster. The +srv modifier forces the connection to use TLS/SSL. See the mongoURI for additional options.\n",
                        "type": "string"
                    },
                    "stateName": {
                        "description": "Indicates the current state of the cluster. The possible states are:\n- IDLE\n- CREATING\n- UPDATING\n- DELETING\n- DELETED\n- REPAIRING\n",
                        "type": "string"
                    },
                    "tags": {
                        "description": "Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getClusterTag:getClusterTag"
                        },
                        "type": "array"
                    },
                    "terminationProtectionEnabled": {
                        "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n",
                        "type": "boolean"
                    },
                    "versionReleaseSystem": {
                        "description": "Release cadence that Atlas uses for this cluster.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "advancedConfigurations",
                    "autoScalingComputeEnabled",
                    "autoScalingComputeScaleDownEnabled",
                    "autoScalingDiskGbEnabled",
                    "backingProviderName",
                    "backupEnabled",
                    "biConnectorConfigs",
                    "clusterType",
                    "connectionStrings",
                    "containerId",
                    "diskSizeGb",
                    "encryptionAtRestProvider",
                    "labels",
                    "mongoDbMajorVersion",
                    "mongoDbVersion",
                    "mongoUri",
                    "mongoUriUpdated",
                    "mongoUriWithOptions",
                    "name",
                    "numShards",
                    "paused",
                    "pitEnabled",
                    "projectId",
                    "providerAutoScalingComputeMaxInstanceSize",
                    "providerAutoScalingComputeMinInstanceSize",
                    "providerBackupEnabled",
                    "providerDiskIops",
                    "providerDiskTypeName",
                    "providerEncryptEbsVolume",
                    "providerEncryptEbsVolumeFlag",
                    "providerInstanceSizeName",
                    "providerName",
                    "providerRegionName",
                    "providerVolumeType",
                    "replicationFactor",
                    "replicationSpecs",
                    "snapshotBackupPolicies",
                    "srvAddress",
                    "stateName",
                    "tags",
                    "terminationProtectionEnabled",
                    "versionReleaseSystem",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getClusterOutageSimulation:getClusterOutageSimulation": {
            "description": "## Example Usage\n\n### S\n\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst outageSimulation = mongodbatlas.getClusterOutageSimulation({\n    projectId: \"64707f06c519c20c3a2b1b03\",\n    clusterName: \"Cluster0\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\noutage_simulation = mongodbatlas.get_cluster_outage_simulation(project_id=\"64707f06c519c20c3a2b1b03\",\n    cluster_name=\"Cluster0\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var outageSimulation = Mongodbatlas.GetClusterOutageSimulation.Invoke(new()\n    {\n        ProjectId = \"64707f06c519c20c3a2b1b03\",\n        ClusterName = \"Cluster0\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.LookupClusterOutageSimulation(ctx, \u0026mongodbatlas.LookupClusterOutageSimulationArgs{\n\t\t\tProjectId:   \"64707f06c519c20c3a2b1b03\",\n\t\t\tClusterName: \"Cluster0\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetClusterOutageSimulationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var outageSimulation = MongodbatlasFunctions.getClusterOutageSimulation(GetClusterOutageSimulationArgs.builder()\n            .projectId(\"64707f06c519c20c3a2b1b03\")\n            .clusterName(\"Cluster0\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  outageSimulation:\n    fn::invoke:\n      Function: mongodbatlas:getClusterOutageSimulation\n      Arguments:\n        projectId: 64707f06c519c20c3a2b1b03\n        clusterName: Cluster0\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getClusterOutageSimulation.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "Name of the Atlas Cluster that is undergoing outage simulation.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project that contains the cluster that is undergoing outage simulation.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getClusterOutageSimulation.\n",
                "properties": {
                    "clusterName": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "outageFilters": {
                        "description": "List of settings that specify the type of cluster outage simulation.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getClusterOutageSimulationOutageFilter:getClusterOutageSimulationOutageFilter"
                        },
                        "type": "array"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "simulationId": {
                        "description": "Unique 24-hexadecimal character string that identifies the outage simulation.\n",
                        "type": "string"
                    },
                    "startRequestDate": {
                        "description": "Date and time when MongoDB Cloud started the regional outage simulation.\n",
                        "type": "string"
                    },
                    "state": {
                        "description": "Current phase of the outage simulation:\n* `START_REQUESTED` - User has requested cluster outage simulation.\n* `STARTING` - MongoDB Cloud is starting cluster outage simulation.\n* `SIMULATING` - MongoDB Cloud is simulating cluster outage.\n* `RECOVERY_REQUESTED` - User has requested recovery from the simulated outage.\n* `RECOVERING` - MongoDB Cloud is recovering the cluster from the simulated outage.\n* `COMPLETE` - MongoDB Cloud has completed the cluster outage simulation.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "clusterName",
                    "outageFilters",
                    "projectId",
                    "simulationId",
                    "startRequestDate",
                    "state",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getClusters:getClusters": {
            "description": "## # Data Source: mongodbatlas.getClusters\n\n`mongodbatlas.Cluster` describes all Clusters by the provided project_id. The data source requires your Project ID.\n\n\u003e **IMPORTANT:**\n\u003cbr\u003e \u0026#8226; Multi Region Cluster: The `mongodbatlas.Cluster` data source doesn't return the `container_id` for each region utilized by the cluster. For retrieving the `container_id`, we recommend the `mongodbatlas.AdvancedCluster` data source instead.\n\u003cbr\u003e \u0026#8226; Changes to cluster configurations can affect costs. Before making changes, please see [Billing](https://docs.atlas.mongodb.com/billing/).\n\u003cbr\u003e \u0026#8226; If your Atlas project contains a custom role that uses actions introduced in a specific MongoDB version, you cannot create a cluster with a MongoDB version less than that version unless you delete the custom role.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testCluster = new mongodbatlas.Cluster(\"test\", {\n    projectId: \"\u003cYOUR-PROJECT-ID\u003e\",\n    name: \"cluster-test\",\n    clusterType: \"REPLICASET\",\n    replicationSpecs: [{\n        numShards: 1,\n        regionsConfigs: [{\n            regionName: \"US_EAST_1\",\n            electableNodes: 3,\n            priority: 7,\n            readOnlyNodes: 0,\n        }],\n    }],\n    cloudBackup: true,\n    autoScalingDiskGbEnabled: true,\n    providerName: \"AWS\",\n    providerInstanceSizeName: \"M40\",\n});\nconst test = mongodbatlas.getClustersOutput({\n    projectId: testCluster.projectId,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_cluster = mongodbatlas.Cluster(\"test\",\n    project_id=\"\u003cYOUR-PROJECT-ID\u003e\",\n    name=\"cluster-test\",\n    cluster_type=\"REPLICASET\",\n    replication_specs=[{\n        \"num_shards\": 1,\n        \"regions_configs\": [{\n            \"region_name\": \"US_EAST_1\",\n            \"electable_nodes\": 3,\n            \"priority\": 7,\n            \"read_only_nodes\": 0,\n        }],\n    }],\n    cloud_backup=True,\n    auto_scaling_disk_gb_enabled=True,\n    provider_name=\"AWS\",\n    provider_instance_size_name=\"M40\")\ntest = mongodbatlas.get_clusters_output(project_id=test_cluster.project_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testCluster = new Mongodbatlas.Cluster(\"test\", new()\n    {\n        ProjectId = \"\u003cYOUR-PROJECT-ID\u003e\",\n        Name = \"cluster-test\",\n        ClusterType = \"REPLICASET\",\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.ClusterReplicationSpecArgs\n            {\n                NumShards = 1,\n                RegionsConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.ClusterReplicationSpecRegionsConfigArgs\n                    {\n                        RegionName = \"US_EAST_1\",\n                        ElectableNodes = 3,\n                        Priority = 7,\n                        ReadOnlyNodes = 0,\n                    },\n                },\n            },\n        },\n        CloudBackup = true,\n        AutoScalingDiskGbEnabled = true,\n        ProviderName = \"AWS\",\n        ProviderInstanceSizeName = \"M40\",\n    });\n\n    var test = Mongodbatlas.GetClusters.Invoke(new()\n    {\n        ProjectId = testCluster.ProjectId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestCluster, err := mongodbatlas.NewCluster(ctx, \"test\", \u0026mongodbatlas.ClusterArgs{\n\t\t\tProjectId:   pulumi.String(\"\u003cYOUR-PROJECT-ID\u003e\"),\n\t\t\tName:        pulumi.String(\"cluster-test\"),\n\t\t\tClusterType: pulumi.String(\"REPLICASET\"),\n\t\t\tReplicationSpecs: mongodbatlas.ClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecArgs{\n\t\t\t\t\tNumShards: pulumi.Int(1),\n\t\t\t\t\tRegionsConfigs: mongodbatlas.ClusterReplicationSpecRegionsConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.ClusterReplicationSpecRegionsConfigArgs{\n\t\t\t\t\t\t\tRegionName:     pulumi.String(\"US_EAST_1\"),\n\t\t\t\t\t\t\tElectableNodes: pulumi.Int(3),\n\t\t\t\t\t\t\tPriority:       pulumi.Int(7),\n\t\t\t\t\t\t\tReadOnlyNodes:  pulumi.Int(0),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tCloudBackup:              pulumi.Bool(true),\n\t\t\tAutoScalingDiskGbEnabled: pulumi.Bool(true),\n\t\t\tProviderName:             pulumi.String(\"AWS\"),\n\t\t\tProviderInstanceSizeName: pulumi.String(\"M40\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupClustersOutput(ctx, mongodbatlas.GetClustersOutputArgs{\n\t\t\tProjectId: testCluster.ProjectId,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Cluster;\nimport com.pulumi.mongodbatlas.ClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.ClusterReplicationSpecArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetClustersArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testCluster = new Cluster(\"testCluster\", ClusterArgs.builder()\n            .projectId(\"\u003cYOUR-PROJECT-ID\u003e\")\n            .name(\"cluster-test\")\n            .clusterType(\"REPLICASET\")\n            .replicationSpecs(ClusterReplicationSpecArgs.builder()\n                .numShards(1)\n                .regionsConfigs(ClusterReplicationSpecRegionsConfigArgs.builder()\n                    .regionName(\"US_EAST_1\")\n                    .electableNodes(3)\n                    .priority(7)\n                    .readOnlyNodes(0)\n                    .build())\n                .build())\n            .cloudBackup(true)\n            .autoScalingDiskGbEnabled(true)\n            .providerName(\"AWS\")\n            .providerInstanceSizeName(\"M40\")\n            .build());\n\n        final var test = MongodbatlasFunctions.getClusters(GetClustersArgs.builder()\n            .projectId(testCluster.projectId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testCluster:\n    type: mongodbatlas:Cluster\n    name: test\n    properties:\n      projectId: \u003cYOUR-PROJECT-ID\u003e\n      name: cluster-test\n      clusterType: REPLICASET\n      replicationSpecs:\n        - numShards: 1\n          regionsConfigs:\n            - regionName: US_EAST_1\n              electableNodes: 3\n              priority: 7\n              readOnlyNodes: 0\n      cloudBackup: true\n      autoScalingDiskGbEnabled: true # Provider Settings \"block\"\n      providerName: AWS\n      providerInstanceSizeName: M40\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getClusters\n      Arguments:\n        projectId: ${testCluster.projectId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getClusters.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to get the clusters.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getClusters.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "description": "A list where each represents a Cluster. See Cluster below for more details.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getClustersResult:getClustersResult"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "projectId",
                    "results",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getControlPlaneIpAddresses:getControlPlaneIpAddresses": {
            "description": "## # Data Source: mongodbatlas.getControlPlaneIpAddresses\n\n`mongodbatlas.getControlPlaneIpAddresses` returns all control plane IP addresses.\n\n## Example Usage\n\n### S\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nexport = async () =\u003e {\n    const test = await mongodbatlas.getControlPlaneIpAddresses({});\n    return {\n        \"outbound-aws-ip-addresses\": test.outbound?.aws,\n    };\n}\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.get_control_plane_ip_addresses()\npulumi.export(\"outbound-aws-ip-addresses\", test.outbound.aws)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Mongodbatlas.GetControlPlaneIpAddresses.Invoke();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"outbound-aws-ip-addresses\"] = test.Apply(getControlPlaneIpAddressesResult =\u003e getControlPlaneIpAddressesResult.Outbound?.Aws),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := mongodbatlas.GetControlPlaneIpAddresses(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"outbound-aws-ip-addresses\", test.Outbound.Aws)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getControlPlaneIpAddresses();\n\n        ctx.export(\"outbound-aws-ip-addresses\", test.applyValue(getControlPlaneIpAddressesResult -\u003e getControlPlaneIpAddressesResult.outbound().aws()));\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getControlPlaneIpAddresses\n      Arguments: {}\noutputs:\n  outbound-aws-ip-addresses: ${test.outbound.aws}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getControlPlaneIpAddresses.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "inbound": {
                        "$ref": "#/types/mongodbatlas:index/getControlPlaneIpAddressesInbound:getControlPlaneIpAddressesInbound",
                        "description": "List of inbound IP addresses to the Atlas control plane, categorized by cloud provider. If your application allows outbound HTTP requests only to specific IP addresses, you must allow access to the following IP addresses so that your API requests can reach the Atlas control plane.\n"
                    },
                    "outbound": {
                        "$ref": "#/types/mongodbatlas:index/getControlPlaneIpAddressesOutbound:getControlPlaneIpAddressesOutbound",
                        "description": "List of outbound IP addresses from the Atlas control plane, categorized by cloud provider. If your network allows inbound HTTP requests only from specific IP addresses, you must allow access from the following IP addresses so that Atlas can communicate with your webhooks and KMS.\n"
                    }
                },
                "required": [
                    "inbound",
                    "outbound",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getCustomDbRole:getCustomDbRole": {
            "description": "## # Data Source: mongodbatlas.CustomDbRole\n\n`mongodbatlas.CustomDbRole` describes a Custom DB Role. This represents a custom db role.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testRole = new mongodbatlas.CustomDbRole(\"test_role\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    roleName: \"myCustomRole\",\n    actions: [\n        {\n            action: \"UPDATE\",\n            resources: [{\n                collectionName: \"\",\n                databaseName: \"anyDatabase\",\n            }],\n        },\n        {\n            action: \"INSERT\",\n            resources: [{\n                collectionName: \"\",\n                databaseName: \"anyDatabase\",\n            }],\n        },\n    ],\n});\nconst test = mongodbatlas.getCustomDbRoleOutput({\n    projectId: testRole.projectId,\n    roleName: testRole.roleName,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_role = mongodbatlas.CustomDbRole(\"test_role\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    role_name=\"myCustomRole\",\n    actions=[\n        {\n            \"action\": \"UPDATE\",\n            \"resources\": [{\n                \"collection_name\": \"\",\n                \"database_name\": \"anyDatabase\",\n            }],\n        },\n        {\n            \"action\": \"INSERT\",\n            \"resources\": [{\n                \"collection_name\": \"\",\n                \"database_name\": \"anyDatabase\",\n            }],\n        },\n    ])\ntest = mongodbatlas.get_custom_db_role_output(project_id=test_role.project_id,\n    role_name=test_role.role_name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testRole = new Mongodbatlas.CustomDbRole(\"test_role\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        RoleName = \"myCustomRole\",\n        Actions = new[]\n        {\n            new Mongodbatlas.Inputs.CustomDbRoleActionArgs\n            {\n                Action = \"UPDATE\",\n                Resources = new[]\n                {\n                    new Mongodbatlas.Inputs.CustomDbRoleActionResourceArgs\n                    {\n                        CollectionName = \"\",\n                        DatabaseName = \"anyDatabase\",\n                    },\n                },\n            },\n            new Mongodbatlas.Inputs.CustomDbRoleActionArgs\n            {\n                Action = \"INSERT\",\n                Resources = new[]\n                {\n                    new Mongodbatlas.Inputs.CustomDbRoleActionResourceArgs\n                    {\n                        CollectionName = \"\",\n                        DatabaseName = \"anyDatabase\",\n                    },\n                },\n            },\n        },\n    });\n\n    var test = Mongodbatlas.GetCustomDbRole.Invoke(new()\n    {\n        ProjectId = testRole.ProjectId,\n        RoleName = testRole.RoleName,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestRole, err := mongodbatlas.NewCustomDbRole(ctx, \"test_role\", \u0026mongodbatlas.CustomDbRoleArgs{\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tRoleName:  pulumi.String(\"myCustomRole\"),\n\t\t\tActions: mongodbatlas.CustomDbRoleActionArray{\n\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionArgs{\n\t\t\t\t\tAction: pulumi.String(\"UPDATE\"),\n\t\t\t\t\tResources: mongodbatlas.CustomDbRoleActionResourceArray{\n\t\t\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionResourceArgs{\n\t\t\t\t\t\t\tCollectionName: pulumi.String(\"\"),\n\t\t\t\t\t\t\tDatabaseName:   pulumi.String(\"anyDatabase\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionArgs{\n\t\t\t\t\tAction: pulumi.String(\"INSERT\"),\n\t\t\t\t\tResources: mongodbatlas.CustomDbRoleActionResourceArray{\n\t\t\t\t\t\t\u0026mongodbatlas.CustomDbRoleActionResourceArgs{\n\t\t\t\t\t\t\tCollectionName: pulumi.String(\"\"),\n\t\t\t\t\t\t\tDatabaseName:   pulumi.String(\"anyDatabase\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupCustomDbRoleOutput(ctx, mongodbatlas.GetCustomDbRoleOutputArgs{\n\t\t\tProjectId: testRole.ProjectId,\n\t\t\tRoleName:  testRole.RoleName,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CustomDbRole;\nimport com.pulumi.mongodbatlas.CustomDbRoleArgs;\nimport com.pulumi.mongodbatlas.inputs.CustomDbRoleActionArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetCustomDbRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testRole = new CustomDbRole(\"testRole\", CustomDbRoleArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .roleName(\"myCustomRole\")\n            .actions(            \n                CustomDbRoleActionArgs.builder()\n                    .action(\"UPDATE\")\n                    .resources(CustomDbRoleActionResourceArgs.builder()\n                        .collectionName(\"\")\n                        .databaseName(\"anyDatabase\")\n                        .build())\n                    .build(),\n                CustomDbRoleActionArgs.builder()\n                    .action(\"INSERT\")\n                    .resources(CustomDbRoleActionResourceArgs.builder()\n                        .collectionName(\"\")\n                        .databaseName(\"anyDatabase\")\n                        .build())\n                    .build())\n            .build());\n\n        final var test = MongodbatlasFunctions.getCustomDbRole(GetCustomDbRoleArgs.builder()\n            .projectId(testRole.projectId())\n            .roleName(testRole.roleName())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testRole:\n    type: mongodbatlas:CustomDbRole\n    name: test_role\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      roleName: myCustomRole\n      actions:\n        - action: UPDATE\n          resources:\n            - collectionName:\n              databaseName: anyDatabase\n        - action: INSERT\n          resources:\n            - collectionName:\n              databaseName: anyDatabase\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getCustomDbRole\n      Arguments:\n        projectId: ${testRole.projectId}\n        roleName: ${testRole.roleName}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCustomDbRole.\n",
                "properties": {
                    "inheritedRoles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCustomDbRoleInheritedRole:getCustomDbRoleInheritedRole"
                        }
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the database user.\n"
                    },
                    "roleName": {
                        "type": "string",
                        "description": "Name of the custom role.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId",
                    "roleName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCustomDbRole.\n",
                "properties": {
                    "actions": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCustomDbRoleAction:getCustomDbRoleAction"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "inheritedRoles": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCustomDbRoleInheritedRole:getCustomDbRoleInheritedRole"
                        },
                        "type": "array"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "roleName": {
                        "description": "(Required) Name of the inherited role. This can either be another custom role or a built-in role.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "actions",
                    "projectId",
                    "roleName",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getCustomDbRoles:getCustomDbRoles": {
            "description": "## # Data Source: mongodbatlas.getCustomDbRoles\n\n`mongodbatlas.getCustomDbRoles` describes all Custom DB Roles. This represents a custom db roles.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nresources:\n  testDatabaseUser:\n    type: mongodbatlas:DatabaseUser\n    name: test\n    properties:\n      username: test-acc-username\n      password: test-acc-password\n      projectId: \u003cPROJECT-ID\u003e\n      databaseName: admin\n      roles:\n        - roleName: readWrite\n          databaseName: admin\n        - roleName: atlasAdmin\n          databaseName: admin\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getCustomDbRoles\n      Arguments:\n        projectId: ${testMongodbatlasCustomDbRole.projectId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCustomDbRoles.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to get all custom db roles.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCustomDbRoles.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "description": "A list where each represents a custom db roles.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getCustomDbRolesResult:getCustomDbRolesResult"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "projectId",
                    "results",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getCustomDnsConfigurationClusterAws:getCustomDnsConfigurationClusterAws": {
            "description": "## # Data Source: mongodbatlas.CustomDnsConfigurationClusterAws\n\n`mongodbatlas.CustomDnsConfigurationClusterAws` describes a Custom DNS Configuration for Atlas Clusters on AWS.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find **group_id** in the official documentation.\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testCustomDnsConfigurationClusterAws = new mongodbatlas.CustomDnsConfigurationClusterAws(\"test\", {\n    projectId: \"\u003cproject-id\u003e\",\n    enabled: true,\n});\nconst test = mongodbatlas.getCustomDnsConfigurationClusterAwsOutput({\n    projectId: testCustomDnsConfigurationClusterAws.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_custom_dns_configuration_cluster_aws = mongodbatlas.CustomDnsConfigurationClusterAws(\"test\",\n    project_id=\"\u003cproject-id\u003e\",\n    enabled=True)\ntest = mongodbatlas.get_custom_dns_configuration_cluster_aws_output(project_id=test_custom_dns_configuration_cluster_aws.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testCustomDnsConfigurationClusterAws = new Mongodbatlas.CustomDnsConfigurationClusterAws(\"test\", new()\n    {\n        ProjectId = \"\u003cproject-id\u003e\",\n        Enabled = true,\n    });\n\n    var test = Mongodbatlas.GetCustomDnsConfigurationClusterAws.Invoke(new()\n    {\n        ProjectId = testCustomDnsConfigurationClusterAws.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestCustomDnsConfigurationClusterAws, err := mongodbatlas.NewCustomDnsConfigurationClusterAws(ctx, \"test\", \u0026mongodbatlas.CustomDnsConfigurationClusterAwsArgs{\n\t\t\tProjectId: pulumi.String(\"\u003cproject-id\u003e\"),\n\t\t\tEnabled:   pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupCustomDnsConfigurationClusterAwsOutput(ctx, mongodbatlas.GetCustomDnsConfigurationClusterAwsOutputArgs{\n\t\t\tProjectId: testCustomDnsConfigurationClusterAws.ID(),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.CustomDnsConfigurationClusterAws;\nimport com.pulumi.mongodbatlas.CustomDnsConfigurationClusterAwsArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetCustomDnsConfigurationClusterAwsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testCustomDnsConfigurationClusterAws = new CustomDnsConfigurationClusterAws(\"testCustomDnsConfigurationClusterAws\", CustomDnsConfigurationClusterAwsArgs.builder()\n            .projectId(\"\u003cproject-id\u003e\")\n            .enabled(true)\n            .build());\n\n        final var test = MongodbatlasFunctions.getCustomDnsConfigurationClusterAws(GetCustomDnsConfigurationClusterAwsArgs.builder()\n            .projectId(testCustomDnsConfigurationClusterAws.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testCustomDnsConfigurationClusterAws:\n    type: mongodbatlas:CustomDnsConfigurationClusterAws\n    name: test\n    properties:\n      projectId: \u003cproject-id\u003e\n      enabled: true\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getCustomDnsConfigurationClusterAws\n      Arguments:\n        projectId: ${testCustomDnsConfigurationClusterAws.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCustomDnsConfigurationClusterAws.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "Unique identifier for the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCustomDnsConfigurationClusterAws.\n",
                "properties": {
                    "enabled": {
                        "description": "Indicates whether the project's clusters deployed to AWS use custom DNS.\n",
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    }
                },
                "required": [
                    "enabled",
                    "projectId",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getDataLakePipeline:getDataLakePipeline": {
            "description": "## # Data Source: mongodbatlas.DataLakePipeline\n\n`mongodbatlas.DataLakePipeline` describes a Data Lake Pipeline.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `group_id` in the official documentation.\n\n## Example Usage\n\n### S\n\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Project;\nimport com.pulumi.mongodbatlas.ProjectArgs;\nimport com.pulumi.mongodbatlas.AdvancedCluster;\nimport com.pulumi.mongodbatlas.AdvancedClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.AdvancedClusterReplicationSpecArgs;\nimport com.pulumi.mongodbatlas.DataLakePipeline;\nimport com.pulumi.mongodbatlas.DataLakePipelineArgs;\nimport com.pulumi.mongodbatlas.inputs.DataLakePipelineSinkArgs;\nimport com.pulumi.mongodbatlas.inputs.DataLakePipelineSourceArgs;\nimport com.pulumi.mongodbatlas.inputs.DataLakePipelineTransformationArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetDataLakePipelineArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var projectTest = new Project(\"projectTest\", ProjectArgs.builder()\n            .name(\"NAME OF THE PROJECT\")\n            .orgId(\"ORGANIZATION ID\")\n            .build());\n\n        var automatedBackupTest = new AdvancedCluster(\"automatedBackupTest\", AdvancedClusterArgs.builder()\n            .projectId(projectId)\n            .name(\"automated-backup-test\")\n            .clusterType(\"REPLICASET\")\n            .backupEnabled(true)\n            .replicationSpecs(AdvancedClusterReplicationSpecArgs.builder()\n                .regionConfigs(AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                    .priority(7)\n                    .providerName(\"GCP\")\n                    .regionName(\"US_EAST_4\")\n                    .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                        .instanceSize(\"M10\")\n                        .nodeCount(3)\n                        .build())\n                    .build())\n                .build())\n            .build());\n\n        var pipeline = new DataLakePipeline(\"pipeline\", DataLakePipelineArgs.builder()\n            .projectId(projectTest.projectId())\n            .name(\"DataLakePipelineName\")\n            .sink(DataLakePipelineSinkArgs.builder()\n                .type(\"DLS\")\n                .partitionFields(DataLakePipelineSinkPartitionFieldArgs.builder()\n                    .name(\"access\")\n                    .order(0)\n                    .build())\n                .build())\n            .source(DataLakePipelineSourceArgs.builder()\n                .type(\"ON_DEMAND_CPS\")\n                .clusterName(automatedBackupTest.name())\n                .databaseName(\"sample_airbnb\")\n                .collectionName(\"listingsAndReviews\")\n                .build())\n            .transformations(            \n                DataLakePipelineTransformationArgs.builder()\n                    .field(\"test\")\n                    .type(\"EXCLUDE\")\n                    .build(),\n                DataLakePipelineTransformationArgs.builder()\n                    .field(\"test22\")\n                    .type(\"EXCLUDE\")\n                    .build())\n            .build());\n\n        final var pipelineDataSource = MongodbatlasFunctions.getDataLakePipeline(GetDataLakePipelineArgs.builder()\n            .projectId(pipeline.projectId())\n            .name(pipeline.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  projectTest:\n    type: mongodbatlas:Project\n    properties:\n      name: NAME OF THE PROJECT\n      orgId: ORGANIZATION ID\n  automatedBackupTest:\n    type: mongodbatlas:AdvancedCluster\n    name: automated_backup_test\n    properties:\n      projectId: ${projectId}\n      name: automated-backup-test\n      clusterType: REPLICASET\n      backupEnabled: true # enable cloud backup snapshots\n      replicationSpecs:\n        - regionConfigs:\n            - priority: 7\n              providerName: GCP\n              regionName: US_EAST_4\n              electableSpecs:\n                instanceSize: M10\n                nodeCount: 3\n  pipeline:\n    type: mongodbatlas:DataLakePipeline\n    properties:\n      projectId: ${projectTest.projectId}\n      name: DataLakePipelineName\n      sink:\n        type: DLS\n        partitionFields:\n          - name: access\n            order: 0\n      source:\n        type: ON_DEMAND_CPS\n        clusterName: ${automatedBackupTest.name}\n        databaseName: sample_airbnb\n        collectionName: listingsAndReviews\n      transformations:\n        - field: test\n          type: EXCLUDE\n        - field: test22\n          type: EXCLUDE\nvariables:\n  pipelineDataSource:\n    fn::invoke:\n      Function: mongodbatlas:getDataLakePipeline\n      Arguments:\n        projectId: ${pipeline.projectId}\n        name: ${pipeline.name}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDataLakePipeline.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "Name of the Atlas Data Lake Pipeline.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create a Data Lake Pipeline.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDataLakePipeline.\n",
                "properties": {
                    "createdDate": {
                        "description": "Timestamp that indicates when the Data Lake Pipeline was created.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.\n",
                        "type": "string"
                    },
                    "ingestionSchedules": {
                        "description": "List of backup schedule policy items that you can use as a Data Lake Pipeline source.\n* `ingestion_schedules.#.id` - Unique 24-hexadecimal digit string that identifies this backup policy item.\n* `ingestion_schedules.#.frequency_type` - Human-readable label that identifies the frequency type associated with the backup policy.\n* `ingestion_schedules.#.frequency_interval` - Number that indicates the frequency interval for a set of snapshots.\n* `ingestion_schedules.#.retention_unit` - Unit of time in which MongoDB Atlas measures snapshot retention.\n* `ingestion_schedules.#.retention_value` - Duration in days, weeks, or months that MongoDB Atlas retains the snapshot.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getDataLakePipelineIngestionSchedule:getDataLakePipelineIngestionSchedule"
                        },
                        "type": "array"
                    },
                    "lastUpdatedDate": {
                        "description": "Timestamp that indicates the last time that the Data Lake Pipeline was updated.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "projectId": {
                        "description": "Unique 24-hexadecimal character string that identifies the project.\n* `policyItemId` - Unique 24-hexadecimal character string that identifies a policy item.\n",
                        "type": "string"
                    },
                    "sinks": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getDataLakePipelineSink:getDataLakePipelineSink"
                        },
                        "type": "array"
                    },
                    "snapshots": {
                        "description": "List of backup snapshots that you can use to trigger an on demand pipeline run.\n* `snapshots.#.id` - Unique 24-hexadecimal digit string that identifies the snapshot.\n* `snapshots.#.provider` - Human-readable label that identifies the cloud provider that stores this snapshot.\n* `snapshots.#.created_at` - Date and time when MongoDB Atlas took the snapshot.\n* `snapshots.#.expires_at` - Date and time when MongoDB Atlas deletes the snapshot.\n* `snapshots.#.frequency_type` - Human-readable label that identifies how often this snapshot triggers.\n* `snapshots.#.master_key` - Unique string that identifies the Amazon Web Services (AWS) Key Management Service (KMS) Customer Master Key (CMK) used to encrypt the snapshot.\n* `snapshots.#.mongod_version` - Version of the MongoDB host that this snapshot backs up.\n* `snapshots.#.replica_set_name` - Human-readable label that identifies the replica set from which MongoDB Atlas took this snapshot.\n* `snapshots.#.type` - Human-readable label that categorizes the cluster as a replica set or sharded cluster.\n* `snapshots.#.snapshot_type` - Human-readable label that identifies when this snapshot triggers.\n* `snapshots.#.status` - Human-readable label that indicates the stage of the backup process for this snapshot.\n* `snapshots.#.size` - List of backup snapshots that you can use to trigger an on demand pipeline run.\n* `snapshots.#.copy_region` - List that identifies the regions to which MongoDB Atlas copies the snapshot.\n* `snapshots.#.policies` - List that contains unique identifiers for the policy items.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getDataLakePipelineSnapshot:getDataLakePipelineSnapshot"
                        },
                        "type": "array"
                    },
                    "sources": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getDataLakePipelineSource:getDataLakePipelineSource"
                        },
                        "type": "array"
                    },
                    "state": {
                        "description": "State of this Data Lake Pipeline.\n",
                        "type": "string"
                    },
                    "transformations": {
                        "description": "Fields to be excluded for this Data Lake Pipeline.\n* `transformations.#.field` - Key in the document.\n* `transformations.#.type` - Type of transformation applied during the export of the namespace in a Data Lake Pipeline.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getDataLakePipelineTransformation:getDataLakePipelineTransformation"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "createdDate",
                    "id",
                    "ingestionSchedules",
                    "lastUpdatedDate",
                    "name",
                    "projectId",
                    "sinks",
                    "snapshots",
                    "sources",
                    "state",
                    "transformations"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getDataLakePipelineRun:getDataLakePipelineRun": {
            "description": "## # Data Source: mongodbatlas.getDataLakePipelineRun\n\n`mongodbatlas.getDataLakePipelineRun` describes a Data Lake Pipeline Run.\n\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.DataLakePipeline;\nimport com.pulumi.mongodbatlas.DataLakePipelineArgs;\nimport com.pulumi.mongodbatlas.inputs.DataLakePipelineSinkArgs;\nimport com.pulumi.mongodbatlas.inputs.DataLakePipelineSourceArgs;\nimport com.pulumi.mongodbatlas.inputs.DataLakePipelineTransformationArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetDataLakePipelineRunsArgs;\nimport com.pulumi.mongodbatlas.inputs.GetDataLakePipelineRunArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var pipeline = new DataLakePipeline(\"pipeline\", DataLakePipelineArgs.builder()\n            .projectId(projectTest.projectId())\n            .name(\"DataLakePipelineName\")\n            .sink(DataLakePipelineSinkArgs.builder()\n                .type(\"DLS\")\n                .partitionFields(DataLakePipelineSinkPartitionFieldArgs.builder()\n                    .name(\"access\")\n                    .order(0)\n                    .build())\n                .build())\n            .source(DataLakePipelineSourceArgs.builder()\n                .type(\"ON_DEMAND_CPS\")\n                .clusterName(clusterTest.name())\n                .databaseName(\"sample_airbnb\")\n                .collectionName(\"listingsAndReviews\")\n                .build())\n            .transformations(            \n                DataLakePipelineTransformationArgs.builder()\n                    .field(\"test\")\n                    .type(\"EXCLUDE\")\n                    .build(),\n                DataLakePipelineTransformationArgs.builder()\n                    .field(\"test22\")\n                    .type(\"EXCLUDE\")\n                    .build())\n            .build());\n\n        final var pipelineRun = MongodbatlasFunctions.getDataLakePipelineRuns(GetDataLakePipelineRunsArgs.builder()\n            .projectId(projectTest.projectId())\n            .name(pipeline.name())\n            .build());\n\n        final var test = MongodbatlasFunctions.getDataLakePipelineRun(GetDataLakePipelineRunArgs.builder()\n            .projectId(projectTest.projectId())\n            .pipelineName(pipeline.name())\n            .pipelineRunId(pipelineRunMongodbatlasDataLakePipelineRuns.results()[0].pipelineRunId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  pipeline:\n    type: mongodbatlas:DataLakePipeline\n    properties:\n      projectId: ${projectTest.projectId}\n      name: DataLakePipelineName\n      sink:\n        type: DLS\n        partitionFields:\n          - name: access\n            order: 0\n      source:\n        type: ON_DEMAND_CPS\n        clusterName: ${clusterTest.name}\n        databaseName: sample_airbnb\n        collectionName: listingsAndReviews\n      transformations:\n        - field: test\n          type: EXCLUDE\n        - field: test22\n          type: EXCLUDE\nvariables:\n  pipelineRun:\n    fn::invoke:\n      Function: mongodbatlas:getDataLakePipelineRuns\n      Arguments:\n        projectId: ${projectTest.projectId}\n        name: ${pipeline.name}\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getDataLakePipelineRun\n      Arguments:\n        projectId: ${projectTest.projectId}\n        pipelineName: ${pipeline.name}\n        pipelineRunId: ${pipelineRunMongodbatlasDataLakePipelineRuns.results[0].pipelineRunId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDataLakePipelineRun.\n",
                "properties": {
                    "pipelineName": {
                        "type": "string",
                        "description": "Human-readable label that identifies the Data Lake Pipeline.\n"
                    },
                    "pipelineRunId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal character string that identifies a Data Lake Pipeline run.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies your project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "pipelineName",
                    "pipelineRunId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDataLakePipelineRun.\n",
                "properties": {
                    "backupFrequencyType": {
                        "description": "Backup schedule interval of the Data Lake Pipeline.\n",
                        "type": "string"
                    },
                    "createdDate": {
                        "description": "Timestamp that indicates when the pipeline run was created.\n",
                        "type": "string"
                    },
                    "datasetName": {
                        "description": "Human-readable label that identifies the dataset that Atlas generates during this pipeline run.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "Unique 24-hexadecimal character string that identifies a Data Lake Pipeline run.\n",
                        "type": "string"
                    },
                    "lastUpdatedDate": {
                        "description": "Unique 24-hexadecimal character string that identifies a Data Lake Pipeline run.\n",
                        "type": "string"
                    },
                    "phase": {
                        "description": "Processing phase of the Data Lake Pipeline.\n",
                        "type": "string"
                    },
                    "pipelineId": {
                        "description": "Unique 24-hexadecimal character string that identifies a Data Lake Pipeline.\n",
                        "type": "string"
                    },
                    "pipelineName": {
                        "type": "string"
                    },
                    "pipelineRunId": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "snapshotId": {
                        "description": "Unique 24-hexadecimal character string that identifies the snapshot of a cluster.\n",
                        "type": "string"
                    },
                    "state": {
                        "description": "State of the pipeline run.\n",
                        "type": "string"
                    },
                    "stats": {
                        "description": "Runtime statistics for this Data Lake Pipeline run.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getDataLakePipelineRunStat:getDataLakePipelineRunStat"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "backupFrequencyType",
                    "createdDate",
                    "datasetName",
                    "id",
                    "lastUpdatedDate",
                    "phase",
                    "pipelineId",
                    "pipelineName",
                    "pipelineRunId",
                    "projectId",
                    "snapshotId",
                    "state",
                    "stats"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getDataLakePipelineRuns:getDataLakePipelineRuns": {
            "description": "## # Data Source: mongodbatlas.getDataLakePipelineRuns\n\n`mongodbatlas.getDataLakePipelineRun` describes Data Lake Pipeline Runs.\n\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.DataLakePipeline;\nimport com.pulumi.mongodbatlas.DataLakePipelineArgs;\nimport com.pulumi.mongodbatlas.inputs.DataLakePipelineSinkArgs;\nimport com.pulumi.mongodbatlas.inputs.DataLakePipelineSourceArgs;\nimport com.pulumi.mongodbatlas.inputs.DataLakePipelineTransformationArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetDataLakePipelineRunsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var pipeline = new DataLakePipeline(\"pipeline\", DataLakePipelineArgs.builder()\n            .projectId(projectTest.projectId())\n            .name(\"DataLakePipelineName\")\n            .sink(DataLakePipelineSinkArgs.builder()\n                .type(\"DLS\")\n                .partitionFields(DataLakePipelineSinkPartitionFieldArgs.builder()\n                    .name(\"access\")\n                    .order(0)\n                    .build())\n                .build())\n            .source(DataLakePipelineSourceArgs.builder()\n                .type(\"ON_DEMAND_CPS\")\n                .clusterName(clusterTest.name())\n                .databaseName(\"sample_airbnb\")\n                .collectionName(\"listingsAndReviews\")\n                .build())\n            .transformations(            \n                DataLakePipelineTransformationArgs.builder()\n                    .field(\"test\")\n                    .type(\"EXCLUDE\")\n                    .build(),\n                DataLakePipelineTransformationArgs.builder()\n                    .field(\"test22\")\n                    .type(\"EXCLUDE\")\n                    .build())\n            .build());\n\n        final var test = MongodbatlasFunctions.getDataLakePipelineRuns(GetDataLakePipelineRunsArgs.builder()\n            .projectId(projectTest.projectId())\n            .pipelineName(pipeline.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  pipeline:\n    type: mongodbatlas:DataLakePipeline\n    properties:\n      projectId: ${projectTest.projectId}\n      name: DataLakePipelineName\n      sink:\n        type: DLS\n        partitionFields:\n          - name: access\n            order: 0\n      source:\n        type: ON_DEMAND_CPS\n        clusterName: ${clusterTest.name}\n        databaseName: sample_airbnb\n        collectionName: listingsAndReviews\n      transformations:\n        - field: test\n          type: EXCLUDE\n        - field: test22\n          type: EXCLUDE\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getDataLakePipelineRuns\n      Arguments:\n        projectId: ${projectTest.projectId}\n        pipelineName: ${pipeline.name}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDataLakePipelineRuns.\n",
                "properties": {
                    "pipelineName": {
                        "type": "string",
                        "description": "Human-readable label that identifies the Data Lake Pipeline.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies your project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "pipelineName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDataLakePipelineRuns.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "pipelineName": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "description": "A list where each represents a Data Lake Pipeline Run.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getDataLakePipelineRunsResult:getDataLakePipelineRunsResult"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "pipelineName",
                    "projectId",
                    "results",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getDataLakePipelines:getDataLakePipelines": {
            "description": "## # Data Source: mongodbatlas.getDataLakePipelines\n\n`mongodbatlas.getDataLakePipelines` describes Data Lake Pipelines.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `group_id` in the official documentation.\n\n## Example Usage\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDataLakePipelines.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create a data lake pipeline.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDataLakePipelines.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "description": "Unique 24-hexadecimal character string that identifies the project.\n* `policyItemId` - Unique 24-hexadecimal character string that identifies a policy item.\n",
                        "type": "string"
                    },
                    "results": {
                        "description": "A list where each represents a Data Lake Pipeline.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getDataLakePipelinesResult:getDataLakePipelinesResult"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "projectId",
                    "results",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getDatabaseUser:getDatabaseUser": {
            "description": "## # Data Source: mongodbatlas.DatabaseUser\n\n`mongodbatlas.DatabaseUser` describes a Database User. This represents a database user which will be applied to all clusters within the project.\n\nEach user has a set of roles that provide access to the projectâs databases. User's roles apply to all the clusters in the project: if two clusters have a `products` database and a user has a role granting `read` access on the products database, the user has that access on both clusters.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testDatabaseUser = new mongodbatlas.DatabaseUser(\"test\", {\n    username: \"test-acc-username\",\n    password: \"test-acc-password\",\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    authDatabaseName: \"admin\",\n    roles: [\n        {\n            roleName: \"readWrite\",\n            databaseName: \"admin\",\n        },\n        {\n            roleName: \"atlasAdmin\",\n            databaseName: \"admin\",\n        },\n    ],\n    labels: [\n        {\n            key: \"key 1\",\n            value: \"value 1\",\n        },\n        {\n            key: \"key 2\",\n            value: \"value 2\",\n        },\n    ],\n});\nconst test = mongodbatlas.getDatabaseUserOutput({\n    projectId: testDatabaseUser.projectId,\n    username: testDatabaseUser.username,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_database_user = mongodbatlas.DatabaseUser(\"test\",\n    username=\"test-acc-username\",\n    password=\"test-acc-password\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    auth_database_name=\"admin\",\n    roles=[\n        {\n            \"role_name\": \"readWrite\",\n            \"database_name\": \"admin\",\n        },\n        {\n            \"role_name\": \"atlasAdmin\",\n            \"database_name\": \"admin\",\n        },\n    ],\n    labels=[\n        {\n            \"key\": \"key 1\",\n            \"value\": \"value 1\",\n        },\n        {\n            \"key\": \"key 2\",\n            \"value\": \"value 2\",\n        },\n    ])\ntest = mongodbatlas.get_database_user_output(project_id=test_database_user.project_id,\n    username=test_database_user.username)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testDatabaseUser = new Mongodbatlas.DatabaseUser(\"test\", new()\n    {\n        Username = \"test-acc-username\",\n        Password = \"test-acc-password\",\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        AuthDatabaseName = \"admin\",\n        Roles = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserRoleArgs\n            {\n                RoleName = \"readWrite\",\n                DatabaseName = \"admin\",\n            },\n            new Mongodbatlas.Inputs.DatabaseUserRoleArgs\n            {\n                RoleName = \"atlasAdmin\",\n                DatabaseName = \"admin\",\n            },\n        },\n        Labels = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserLabelArgs\n            {\n                Key = \"key 1\",\n                Value = \"value 1\",\n            },\n            new Mongodbatlas.Inputs.DatabaseUserLabelArgs\n            {\n                Key = \"key 2\",\n                Value = \"value 2\",\n            },\n        },\n    });\n\n    var test = Mongodbatlas.GetDatabaseUser.Invoke(new()\n    {\n        ProjectId = testDatabaseUser.ProjectId,\n        Username = testDatabaseUser.Username,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestDatabaseUser, err := mongodbatlas.NewDatabaseUser(ctx, \"test\", \u0026mongodbatlas.DatabaseUserArgs{\n\t\t\tUsername:         pulumi.String(\"test-acc-username\"),\n\t\t\tPassword:         pulumi.String(\"test-acc-password\"),\n\t\t\tProjectId:        pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tAuthDatabaseName: pulumi.String(\"admin\"),\n\t\t\tRoles: mongodbatlas.DatabaseUserRoleArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserRoleArgs{\n\t\t\t\t\tRoleName:     pulumi.String(\"readWrite\"),\n\t\t\t\t\tDatabaseName: pulumi.String(\"admin\"),\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.DatabaseUserRoleArgs{\n\t\t\t\t\tRoleName:     pulumi.String(\"atlasAdmin\"),\n\t\t\t\t\tDatabaseName: pulumi.String(\"admin\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tLabels: mongodbatlas.DatabaseUserLabelArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserLabelArgs{\n\t\t\t\t\tKey:   pulumi.String(\"key 1\"),\n\t\t\t\t\tValue: pulumi.String(\"value 1\"),\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.DatabaseUserLabelArgs{\n\t\t\t\t\tKey:   pulumi.String(\"key 2\"),\n\t\t\t\t\tValue: pulumi.String(\"value 2\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupDatabaseUserOutput(ctx, mongodbatlas.GetDatabaseUserOutputArgs{\n\t\t\tProjectId: testDatabaseUser.ProjectId,\n\t\t\tUsername:  testDatabaseUser.Username,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.DatabaseUser;\nimport com.pulumi.mongodbatlas.DatabaseUserArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserRoleArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserLabelArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetDatabaseUserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testDatabaseUser = new DatabaseUser(\"testDatabaseUser\", DatabaseUserArgs.builder()\n            .username(\"test-acc-username\")\n            .password(\"test-acc-password\")\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .authDatabaseName(\"admin\")\n            .roles(            \n                DatabaseUserRoleArgs.builder()\n                    .roleName(\"readWrite\")\n                    .databaseName(\"admin\")\n                    .build(),\n                DatabaseUserRoleArgs.builder()\n                    .roleName(\"atlasAdmin\")\n                    .databaseName(\"admin\")\n                    .build())\n            .labels(            \n                DatabaseUserLabelArgs.builder()\n                    .key(\"key 1\")\n                    .value(\"value 1\")\n                    .build(),\n                DatabaseUserLabelArgs.builder()\n                    .key(\"key 2\")\n                    .value(\"value 2\")\n                    .build())\n            .build());\n\n        final var test = MongodbatlasFunctions.getDatabaseUser(GetDatabaseUserArgs.builder()\n            .projectId(testDatabaseUser.projectId())\n            .username(testDatabaseUser.username())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testDatabaseUser:\n    type: mongodbatlas:DatabaseUser\n    name: test\n    properties:\n      username: test-acc-username\n      password: test-acc-password\n      projectId: \u003cPROJECT-ID\u003e\n      authDatabaseName: admin\n      roles:\n        - roleName: readWrite\n          databaseName: admin\n        - roleName: atlasAdmin\n          databaseName: admin\n      labels:\n        - key: key 1\n          value: value 1\n        - key: key 2\n          value: value 2\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getDatabaseUser\n      Arguments:\n        projectId: ${testDatabaseUser.projectId}\n        username: ${testDatabaseUser.username}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n**Example of usage with a OIDC federated authentication user**\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testDatabaseUser = new mongodbatlas.DatabaseUser(\"test\", {\n    username: \"64d613677e1ad50839cce4db/testUserOrGroup\",\n    projectId: \"6414908c207f4d22f4d8f232\",\n    authDatabaseName: \"admin\",\n    oidcAuthType: \"IDP_GROUP\",\n    roles: [{\n        roleName: \"readWriteAnyDatabase\",\n        databaseName: \"admin\",\n    }],\n});\nconst test = mongodbatlas.getDatabaseUserOutput({\n    username: testDatabaseUser.username,\n    projectId: \"6414908c207f4d22f4d8f232\",\n    authDatabaseName: \"admin\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_database_user = mongodbatlas.DatabaseUser(\"test\",\n    username=\"64d613677e1ad50839cce4db/testUserOrGroup\",\n    project_id=\"6414908c207f4d22f4d8f232\",\n    auth_database_name=\"admin\",\n    oidc_auth_type=\"IDP_GROUP\",\n    roles=[{\n        \"role_name\": \"readWriteAnyDatabase\",\n        \"database_name\": \"admin\",\n    }])\ntest = mongodbatlas.get_database_user_output(username=test_database_user.username,\n    project_id=\"6414908c207f4d22f4d8f232\",\n    auth_database_name=\"admin\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testDatabaseUser = new Mongodbatlas.DatabaseUser(\"test\", new()\n    {\n        Username = \"64d613677e1ad50839cce4db/testUserOrGroup\",\n        ProjectId = \"6414908c207f4d22f4d8f232\",\n        AuthDatabaseName = \"admin\",\n        OidcAuthType = \"IDP_GROUP\",\n        Roles = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserRoleArgs\n            {\n                RoleName = \"readWriteAnyDatabase\",\n                DatabaseName = \"admin\",\n            },\n        },\n    });\n\n    var test = Mongodbatlas.GetDatabaseUser.Invoke(new()\n    {\n        Username = testDatabaseUser.Username,\n        ProjectId = \"6414908c207f4d22f4d8f232\",\n        AuthDatabaseName = \"admin\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestDatabaseUser, err := mongodbatlas.NewDatabaseUser(ctx, \"test\", \u0026mongodbatlas.DatabaseUserArgs{\n\t\t\tUsername:         pulumi.String(\"64d613677e1ad50839cce4db/testUserOrGroup\"),\n\t\t\tProjectId:        pulumi.String(\"6414908c207f4d22f4d8f232\"),\n\t\t\tAuthDatabaseName: pulumi.String(\"admin\"),\n\t\t\tOidcAuthType:     pulumi.String(\"IDP_GROUP\"),\n\t\t\tRoles: mongodbatlas.DatabaseUserRoleArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserRoleArgs{\n\t\t\t\t\tRoleName:     pulumi.String(\"readWriteAnyDatabase\"),\n\t\t\t\t\tDatabaseName: pulumi.String(\"admin\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupDatabaseUserOutput(ctx, mongodbatlas.GetDatabaseUserOutputArgs{\n\t\t\tUsername:         testDatabaseUser.Username,\n\t\t\tProjectId:        pulumi.String(\"6414908c207f4d22f4d8f232\"),\n\t\t\tAuthDatabaseName: pulumi.String(\"admin\"),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.DatabaseUser;\nimport com.pulumi.mongodbatlas.DatabaseUserArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserRoleArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetDatabaseUserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testDatabaseUser = new DatabaseUser(\"testDatabaseUser\", DatabaseUserArgs.builder()\n            .username(\"64d613677e1ad50839cce4db/testUserOrGroup\")\n            .projectId(\"6414908c207f4d22f4d8f232\")\n            .authDatabaseName(\"admin\")\n            .oidcAuthType(\"IDP_GROUP\")\n            .roles(DatabaseUserRoleArgs.builder()\n                .roleName(\"readWriteAnyDatabase\")\n                .databaseName(\"admin\")\n                .build())\n            .build());\n\n        final var test = MongodbatlasFunctions.getDatabaseUser(GetDatabaseUserArgs.builder()\n            .username(testDatabaseUser.username())\n            .projectId(\"6414908c207f4d22f4d8f232\")\n            .authDatabaseName(\"admin\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testDatabaseUser:\n    type: mongodbatlas:DatabaseUser\n    name: test\n    properties:\n      username: 64d613677e1ad50839cce4db/testUserOrGroup\n      projectId: 6414908c207f4d22f4d8f232\n      authDatabaseName: admin\n      oidcAuthType: IDP_GROUP\n      roles:\n        - roleName: readWriteAnyDatabase\n          databaseName: admin\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getDatabaseUser\n      Arguments:\n        username: ${testDatabaseUser.username}\n        projectId: 6414908c207f4d22f4d8f232\n        authDatabaseName: admin\n```\n\u003c!--End PulumiCodeChooser --\u003e\nNote: OIDC support is only avalible starting in [MongoDB 7.0](https://www.mongodb.com/evolved#mdbsevenzero) or later. To learn more, see the [MongoDB Atlas documentation](https://www.mongodb.com/docs/atlas/security-oidc/).\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDatabaseUser.\n",
                "properties": {
                    "authDatabaseName": {
                        "type": "string",
                        "description": "The userâs authentication database. A user must provide both a username and authentication database to log into MongoDB. In Atlas deployments of MongoDB, the authentication database is almost always the admin database, for X509 it is $external.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the database user.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Username for authenticating to MongoDB.\n"
                    }
                },
                "type": "object",
                "required": [
                    "authDatabaseName",
                    "projectId",
                    "username"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDatabaseUser.\n",
                "properties": {
                    "authDatabaseName": {
                        "type": "string"
                    },
                    "awsIamType": {
                        "description": "The new database user authenticates with AWS IAM credentials. Default is `NONE`, `USER` means user has AWS IAM user credentials, `ROLE` - means user has credentials associated with an AWS IAM role.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "Autogenerated Unique ID for this data source.\n",
                        "type": "string"
                    },
                    "labels": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getDatabaseUserLabel:getDatabaseUserLabel"
                        },
                        "type": "array"
                    },
                    "ldapAuthType": {
                        "description": "Method by which the provided username is authenticated. Default is `NONE`. Other valid values are: `USER`, `GROUP`.\n",
                        "type": "string"
                    },
                    "oidcAuthType": {
                        "description": "(Optional) Human-readable label that indicates whether the new database user authenticates with OIDC (OpenID Connect) federated authentication. If no value is given, Atlas uses the default value of `NONE`. The accepted types are:\n* `NONE` -\tThe user does not use OIDC federated authentication.\n* `IDP_GROUP` - OIDC Workforce federated authentication group. To learn more about OIDC federated authentication, see [Set up Workforce Identity Federation with OIDC](https://www.mongodb.com/docs/atlas/security-oidc/).\n* `USER` - OIDC Workload federated authentication user. To learn more about OIDC federated authentication, see [Set up Workload Identity Federation with OIDC](https://www.mongodb.com/docs/atlas/security-oidc/).\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "roles": {
                        "description": "List of userâs roles and the databases / collections on which the roles apply. A role allows the user to perform particular actions on the specified database. A role on the admin database can include privileges that apply to the other databases as well. See Roles below for more details.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getDatabaseUserRole:getDatabaseUserRole"
                        },
                        "type": "array"
                    },
                    "scopes": {
                        "description": "Array of clusters and Atlas Data Lakes that this user has access to.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getDatabaseUserScope:getDatabaseUserScope"
                        },
                        "type": "array"
                    },
                    "username": {
                        "type": "string"
                    },
                    "x509Type": {
                        "description": "X.509 method by which the provided username is authenticated.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "authDatabaseName",
                    "awsIamType",
                    "id",
                    "labels",
                    "ldapAuthType",
                    "oidcAuthType",
                    "projectId",
                    "roles",
                    "scopes",
                    "username",
                    "x509Type"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getDatabaseUsers:getDatabaseUsers": {
            "description": "## # Data Source: mongodbatlas.getDatabaseUsers\n\n`mongodbatlas.getDatabaseUsers` describes all Database Users. This represents a database user which will be applied to all clusters within the project.\n\nEach user has a set of roles that provide access to the projectâs databases. User's roles apply to all the clusters in the project: if two clusters have a `products` database and a user has a role granting `read` access on the products database, the user has that access on both clusters.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testDatabaseUser = new mongodbatlas.DatabaseUser(\"test\", {\n    username: \"test-acc-username\",\n    password: \"test-acc-password\",\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    authDatabaseName: \"admin\",\n    roles: [\n        {\n            roleName: \"readWrite\",\n            databaseName: \"admin\",\n        },\n        {\n            roleName: \"atlasAdmin\",\n            databaseName: \"admin\",\n        },\n    ],\n    labels: [\n        {\n            key: \"key 1\",\n            value: \"value 1\",\n        },\n        {\n            key: \"key 2\",\n            value: \"value 2\",\n        },\n    ],\n});\nconst test = mongodbatlas.getDatabaseUsersOutput({\n    projectId: testDatabaseUser.projectId,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_database_user = mongodbatlas.DatabaseUser(\"test\",\n    username=\"test-acc-username\",\n    password=\"test-acc-password\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    auth_database_name=\"admin\",\n    roles=[\n        {\n            \"role_name\": \"readWrite\",\n            \"database_name\": \"admin\",\n        },\n        {\n            \"role_name\": \"atlasAdmin\",\n            \"database_name\": \"admin\",\n        },\n    ],\n    labels=[\n        {\n            \"key\": \"key 1\",\n            \"value\": \"value 1\",\n        },\n        {\n            \"key\": \"key 2\",\n            \"value\": \"value 2\",\n        },\n    ])\ntest = mongodbatlas.get_database_users_output(project_id=test_database_user.project_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testDatabaseUser = new Mongodbatlas.DatabaseUser(\"test\", new()\n    {\n        Username = \"test-acc-username\",\n        Password = \"test-acc-password\",\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        AuthDatabaseName = \"admin\",\n        Roles = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserRoleArgs\n            {\n                RoleName = \"readWrite\",\n                DatabaseName = \"admin\",\n            },\n            new Mongodbatlas.Inputs.DatabaseUserRoleArgs\n            {\n                RoleName = \"atlasAdmin\",\n                DatabaseName = \"admin\",\n            },\n        },\n        Labels = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserLabelArgs\n            {\n                Key = \"key 1\",\n                Value = \"value 1\",\n            },\n            new Mongodbatlas.Inputs.DatabaseUserLabelArgs\n            {\n                Key = \"key 2\",\n                Value = \"value 2\",\n            },\n        },\n    });\n\n    var test = Mongodbatlas.GetDatabaseUsers.Invoke(new()\n    {\n        ProjectId = testDatabaseUser.ProjectId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestDatabaseUser, err := mongodbatlas.NewDatabaseUser(ctx, \"test\", \u0026mongodbatlas.DatabaseUserArgs{\n\t\t\tUsername:         pulumi.String(\"test-acc-username\"),\n\t\t\tPassword:         pulumi.String(\"test-acc-password\"),\n\t\t\tProjectId:        pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tAuthDatabaseName: pulumi.String(\"admin\"),\n\t\t\tRoles: mongodbatlas.DatabaseUserRoleArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserRoleArgs{\n\t\t\t\t\tRoleName:     pulumi.String(\"readWrite\"),\n\t\t\t\t\tDatabaseName: pulumi.String(\"admin\"),\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.DatabaseUserRoleArgs{\n\t\t\t\t\tRoleName:     pulumi.String(\"atlasAdmin\"),\n\t\t\t\t\tDatabaseName: pulumi.String(\"admin\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tLabels: mongodbatlas.DatabaseUserLabelArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserLabelArgs{\n\t\t\t\t\tKey:   pulumi.String(\"key 1\"),\n\t\t\t\t\tValue: pulumi.String(\"value 1\"),\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.DatabaseUserLabelArgs{\n\t\t\t\t\tKey:   pulumi.String(\"key 2\"),\n\t\t\t\t\tValue: pulumi.String(\"value 2\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupDatabaseUsersOutput(ctx, mongodbatlas.GetDatabaseUsersOutputArgs{\n\t\t\tProjectId: testDatabaseUser.ProjectId,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.DatabaseUser;\nimport com.pulumi.mongodbatlas.DatabaseUserArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserRoleArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserLabelArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetDatabaseUsersArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testDatabaseUser = new DatabaseUser(\"testDatabaseUser\", DatabaseUserArgs.builder()\n            .username(\"test-acc-username\")\n            .password(\"test-acc-password\")\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .authDatabaseName(\"admin\")\n            .roles(            \n                DatabaseUserRoleArgs.builder()\n                    .roleName(\"readWrite\")\n                    .databaseName(\"admin\")\n                    .build(),\n                DatabaseUserRoleArgs.builder()\n                    .roleName(\"atlasAdmin\")\n                    .databaseName(\"admin\")\n                    .build())\n            .labels(            \n                DatabaseUserLabelArgs.builder()\n                    .key(\"key 1\")\n                    .value(\"value 1\")\n                    .build(),\n                DatabaseUserLabelArgs.builder()\n                    .key(\"key 2\")\n                    .value(\"value 2\")\n                    .build())\n            .build());\n\n        final var test = MongodbatlasFunctions.getDatabaseUsers(GetDatabaseUsersArgs.builder()\n            .projectId(testDatabaseUser.projectId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testDatabaseUser:\n    type: mongodbatlas:DatabaseUser\n    name: test\n    properties:\n      username: test-acc-username\n      password: test-acc-password\n      projectId: \u003cPROJECT-ID\u003e\n      authDatabaseName: admin\n      roles:\n        - roleName: readWrite\n          databaseName: admin\n        - roleName: atlasAdmin\n          databaseName: admin\n      labels:\n        - key: key 1\n          value: value 1\n        - key: key 2\n          value: value 2\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getDatabaseUsers\n      Arguments:\n        projectId: ${testDatabaseUser.projectId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n**Example of usage with a OIDC federated authentication user**\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testDatabaseUser = new mongodbatlas.DatabaseUser(\"test\", {\n    username: \"64d613677e1ad50839cce4db/testUserOrGroup\",\n    projectId: \"6414908c207f4d22f4d8f232\",\n    authDatabaseName: \"admin\",\n    oidcAuthType: \"IDP_GROUP\",\n    roles: [{\n        roleName: \"readWriteAnyDatabase\",\n        databaseName: \"admin\",\n    }],\n});\nconst test = mongodbatlas.getDatabaseUsers({\n    projectId: \"6414908c207f4d22f4d8f232\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_database_user = mongodbatlas.DatabaseUser(\"test\",\n    username=\"64d613677e1ad50839cce4db/testUserOrGroup\",\n    project_id=\"6414908c207f4d22f4d8f232\",\n    auth_database_name=\"admin\",\n    oidc_auth_type=\"IDP_GROUP\",\n    roles=[{\n        \"role_name\": \"readWriteAnyDatabase\",\n        \"database_name\": \"admin\",\n    }])\ntest = mongodbatlas.get_database_users(project_id=\"6414908c207f4d22f4d8f232\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testDatabaseUser = new Mongodbatlas.DatabaseUser(\"test\", new()\n    {\n        Username = \"64d613677e1ad50839cce4db/testUserOrGroup\",\n        ProjectId = \"6414908c207f4d22f4d8f232\",\n        AuthDatabaseName = \"admin\",\n        OidcAuthType = \"IDP_GROUP\",\n        Roles = new[]\n        {\n            new Mongodbatlas.Inputs.DatabaseUserRoleArgs\n            {\n                RoleName = \"readWriteAnyDatabase\",\n                DatabaseName = \"admin\",\n            },\n        },\n    });\n\n    var test = Mongodbatlas.GetDatabaseUsers.Invoke(new()\n    {\n        ProjectId = \"6414908c207f4d22f4d8f232\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewDatabaseUser(ctx, \"test\", \u0026mongodbatlas.DatabaseUserArgs{\n\t\t\tUsername:         pulumi.String(\"64d613677e1ad50839cce4db/testUserOrGroup\"),\n\t\t\tProjectId:        pulumi.String(\"6414908c207f4d22f4d8f232\"),\n\t\t\tAuthDatabaseName: pulumi.String(\"admin\"),\n\t\t\tOidcAuthType:     pulumi.String(\"IDP_GROUP\"),\n\t\t\tRoles: mongodbatlas.DatabaseUserRoleArray{\n\t\t\t\t\u0026mongodbatlas.DatabaseUserRoleArgs{\n\t\t\t\t\tRoleName:     pulumi.String(\"readWriteAnyDatabase\"),\n\t\t\t\t\tDatabaseName: pulumi.String(\"admin\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.LookupDatabaseUsers(ctx, \u0026mongodbatlas.LookupDatabaseUsersArgs{\n\t\t\tProjectId: \"6414908c207f4d22f4d8f232\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.DatabaseUser;\nimport com.pulumi.mongodbatlas.DatabaseUserArgs;\nimport com.pulumi.mongodbatlas.inputs.DatabaseUserRoleArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetDatabaseUsersArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testDatabaseUser = new DatabaseUser(\"testDatabaseUser\", DatabaseUserArgs.builder()\n            .username(\"64d613677e1ad50839cce4db/testUserOrGroup\")\n            .projectId(\"6414908c207f4d22f4d8f232\")\n            .authDatabaseName(\"admin\")\n            .oidcAuthType(\"IDP_GROUP\")\n            .roles(DatabaseUserRoleArgs.builder()\n                .roleName(\"readWriteAnyDatabase\")\n                .databaseName(\"admin\")\n                .build())\n            .build());\n\n        final var test = MongodbatlasFunctions.getDatabaseUsers(GetDatabaseUsersArgs.builder()\n            .projectId(\"6414908c207f4d22f4d8f232\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testDatabaseUser:\n    type: mongodbatlas:DatabaseUser\n    name: test\n    properties:\n      username: 64d613677e1ad50839cce4db/testUserOrGroup\n      projectId: 6414908c207f4d22f4d8f232\n      authDatabaseName: admin\n      oidcAuthType: IDP_GROUP\n      roles:\n        - roleName: readWriteAnyDatabase\n          databaseName: admin\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getDatabaseUsers\n      Arguments:\n        projectId: 6414908c207f4d22f4d8f232\n```\n\u003c!--End PulumiCodeChooser --\u003e\nNote: OIDC support is only avalible starting in [MongoDB 7.0](https://www.mongodb.com/evolved#mdbsevenzero) or later. To learn more, see the [MongoDB Atlas documentation](https://www.mongodb.com/docs/atlas/security-oidc/).\n",
            "inputs": {
                "description": "A collection of arguments for invoking getDatabaseUsers.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to get all database users.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getDatabaseUsers.\n",
                "properties": {
                    "id": {
                        "description": "Autogenerated Unique ID for this data source.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "description": "ID of the Atlas project the user belongs to.\n",
                        "type": "string"
                    },
                    "results": {
                        "description": "A list where each represents a Database user.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getDatabaseUsersResult:getDatabaseUsersResult"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "id",
                    "projectId",
                    "results"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getEventTrigger:getEventTrigger": {
            "description": "## # Data Source: mongodbatlas.EventTrigger\n\n`mongodbatlas.EventTrigger` describes an Event Trigger. \n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getEventTrigger.\n",
                "properties": {
                    "appId": {
                        "type": "string",
                        "description": "The ObjectID of your application.\n* For more details on `project_id` and `app_id` see: https://www.mongodb.com/docs/atlas/app-services/admin/api/v3/#section/Project-and-Application-IDs\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the trigger.\n"
                    },
                    "triggerId": {
                        "type": "string",
                        "description": "The unique ID of the trigger.\n"
                    }
                },
                "type": "object",
                "required": [
                    "appId",
                    "projectId",
                    "triggerId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getEventTrigger.\n",
                "properties": {
                    "appId": {
                        "type": "string"
                    },
                    "configCollection": {
                        "description": "The name of the MongoDB collection that the trigger watches for change events.\n",
                        "type": "string"
                    },
                    "configDatabase": {
                        "description": "The name of the MongoDB database to watch.\n",
                        "type": "string"
                    },
                    "configFullDocument": {
                        "description": "If true, indicates that `UPDATE` change events should include the most current [majority-committed](https://docs.mongodb.com/manual/reference/read-concern-majority/) version of the modified document in the fullDocument field.\n",
                        "type": "boolean"
                    },
                    "configFullDocumentBefore": {
                        "type": "boolean"
                    },
                    "configMatch": {
                        "description": "A [$match](https://docs.mongodb.com/manual/reference/operator/aggregation/match/) expression document that MongoDB Realm includes in the underlying change stream pipeline for the trigger.\n",
                        "type": "string"
                    },
                    "configOperationType": {
                        "description": "The [authentication operation type](https://docs.mongodb.com/realm/triggers/authentication-triggers/#std-label-authentication-event-operation-types) to listen for.\n",
                        "type": "string"
                    },
                    "configOperationTypes": {
                        "description": "The [database event operation types](https://docs.mongodb.com/realm/triggers/database-triggers/#std-label-database-events) to listen for.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "configProject": {
                        "description": "A [$project](https://docs.mongodb.com/manual/reference/operator/aggregation/project/) expression document that Realm uses to filter the fields that appear in change event objects.\n",
                        "type": "string"
                    },
                    "configProviders": {
                        "description": "A list of one or more [authentication provider](https://docs.mongodb.com/realm/authentication/providers/) id values. The trigger will only listen for authentication events produced by these providers.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "configSchedule": {
                        "description": "A [cron expression](https://docs.mongodb.com/realm/triggers/cron-expressions/) that defines the trigger schedule.\n",
                        "type": "string"
                    },
                    "configScheduleType": {
                        "type": "string"
                    },
                    "configServiceId": {
                        "description": "The ID of the MongoDB Service associated with the trigger.\n",
                        "type": "string"
                    },
                    "disabled": {
                        "description": "Status of a trigger.\n",
                        "type": "boolean"
                    },
                    "eventProcessors": {
                        "description": "An object where each field name is an event processor ID and each value is an object that configures its corresponding event processor.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getEventTriggerEventProcessor:getEventTriggerEventProcessor"
                        },
                        "type": "array"
                    },
                    "functionId": {
                        "description": "The ID of the function associated with the trigger.\n",
                        "type": "string"
                    },
                    "functionName": {
                        "description": "The name of the function associated with the trigger.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "The name of the trigger.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "triggerId": {
                        "type": "string"
                    },
                    "type": {
                        "description": "The type of the trigger.\n",
                        "type": "string"
                    },
                    "unordered": {
                        "description": "Only Available for Database Triggers. If true, event ordering is disabled and this trigger can process events in parallel. If false, event ordering is enabled and the trigger executes serially.\n",
                        "type": "boolean"
                    }
                },
                "required": [
                    "appId",
                    "configCollection",
                    "configDatabase",
                    "configFullDocument",
                    "configFullDocumentBefore",
                    "configMatch",
                    "configOperationType",
                    "configOperationTypes",
                    "configProject",
                    "configProviders",
                    "configSchedule",
                    "configScheduleType",
                    "configServiceId",
                    "disabled",
                    "eventProcessors",
                    "functionId",
                    "functionName",
                    "name",
                    "projectId",
                    "triggerId",
                    "type",
                    "unordered",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getEventTriggers:getEventTriggers": {
            "description": "## # Data Source: mongodbatlas.getEventTriggers\n\n`mongodbatlas.getEventTriggers` describes all Event Triggers.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getEventTriggers.\n",
                "properties": {
                    "appId": {
                        "type": "string",
                        "description": "The ObjectID of your application.\n* For more details on `project_id` and `app_id` see: https://www.mongodb.com/docs/atlas/app-services/admin/api/v3/#section/Project-and-Application-IDs\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to get all event triggers.\n"
                    }
                },
                "type": "object",
                "required": [
                    "appId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getEventTriggers.\n",
                "properties": {
                    "appId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "description": "A list where each represents a Event Trigger.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getEventTriggersResult:getEventTriggersResult"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "appId",
                    "projectId",
                    "results",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getFederatedDatabaseInstance:getFederatedDatabaseInstance": {
            "description": "## # Data Source: mongodbatlas.FederatedDatabaseInstance\n\n`mongodbatlas.FederatedDatabaseInstance` provides a Federated Database Instance data source.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n\u003e **IMPORTANT:** All arguments including the password will be stored in the raw state as plain text. Read more about sensitive data in state.\n\n## Example Usage\n\n### S With MongoDB Atlas Cluster As Storage Database\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = mongodbatlas.getFederatedDatabaseInstance({\n    projectId: \"PROJECT ID\",\n    name: \"TENANT NAME OF THE FEDERATED DATABASE INSTANCE\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.get_federated_database_instance(project_id=\"PROJECT ID\",\n    name=\"TENANT NAME OF THE FEDERATED DATABASE INSTANCE\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Mongodbatlas.GetFederatedDatabaseInstance.Invoke(new()\n    {\n        ProjectId = \"PROJECT ID\",\n        Name = \"TENANT NAME OF THE FEDERATED DATABASE INSTANCE\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.LookupFederatedDatabaseInstance(ctx, \u0026mongodbatlas.LookupFederatedDatabaseInstanceArgs{\n\t\t\tProjectId: \"PROJECT ID\",\n\t\t\tName:      \"TENANT NAME OF THE FEDERATED DATABASE INSTANCE\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetFederatedDatabaseInstanceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getFederatedDatabaseInstance(GetFederatedDatabaseInstanceArgs.builder()\n            .projectId(\"PROJECT ID\")\n            .name(\"TENANT NAME OF THE FEDERATED DATABASE INSTANCE\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getFederatedDatabaseInstance\n      Arguments:\n        projectId: PROJECT ID\n        name: TENANT NAME OF THE FEDERATED DATABASE INSTANCE\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n### S With Amazon S3 Bucket As Storage Database\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = mongodbatlas.getFederatedDatabaseInstance({\n    projectId: \"PROJECT ID\",\n    name: \"TENANT NAME OF THE FEDERATED DATABASE INSTANCE\",\n    cloudProviderConfig: {\n        aws: {\n            testS3Bucket: \"Amazon S3 Bucket Name\",\n        },\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.get_federated_database_instance(project_id=\"PROJECT ID\",\n    name=\"TENANT NAME OF THE FEDERATED DATABASE INSTANCE\",\n    cloud_provider_config={\n        \"aws\": {\n            \"test_s3_bucket\": \"Amazon S3 Bucket Name\",\n        },\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Mongodbatlas.GetFederatedDatabaseInstance.Invoke(new()\n    {\n        ProjectId = \"PROJECT ID\",\n        Name = \"TENANT NAME OF THE FEDERATED DATABASE INSTANCE\",\n        CloudProviderConfig = new Mongodbatlas.Inputs.GetFederatedDatabaseInstanceCloudProviderConfigInputArgs\n        {\n            Aws = new Mongodbatlas.Inputs.GetFederatedDatabaseInstanceCloudProviderConfigAwsInputArgs\n            {\n                TestS3Bucket = \"Amazon S3 Bucket Name\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.LookupFederatedDatabaseInstance(ctx, \u0026mongodbatlas.LookupFederatedDatabaseInstanceArgs{\n\t\t\tProjectId: \"PROJECT ID\",\n\t\t\tName:      \"TENANT NAME OF THE FEDERATED DATABASE INSTANCE\",\n\t\t\tCloudProviderConfig: mongodbatlas.GetFederatedDatabaseInstanceCloudProviderConfig{\n\t\t\t\tAws: mongodbatlas.GetFederatedDatabaseInstanceCloudProviderConfigAws{\n\t\t\t\t\tTestS3Bucket: \"Amazon S3 Bucket Name\",\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetFederatedDatabaseInstanceArgs;\nimport com.pulumi.mongodbatlas.inputs.GetFederatedDatabaseInstanceCloudProviderConfigArgs;\nimport com.pulumi.mongodbatlas.inputs.GetFederatedDatabaseInstanceCloudProviderConfigAwsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getFederatedDatabaseInstance(GetFederatedDatabaseInstanceArgs.builder()\n            .projectId(\"PROJECT ID\")\n            .name(\"TENANT NAME OF THE FEDERATED DATABASE INSTANCE\")\n            .cloudProviderConfig(GetFederatedDatabaseInstanceCloudProviderConfigArgs.builder()\n                .aws(GetFederatedDatabaseInstanceCloudProviderConfigAwsArgs.builder()\n                    .testS3Bucket(\"Amazon S3 Bucket Name\")\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getFederatedDatabaseInstance\n      Arguments:\n        projectId: PROJECT ID\n        name: TENANT NAME OF THE FEDERATED DATABASE INSTANCE\n        cloudProviderConfig:\n          aws:\n            testS3Bucket: Amazon S3 Bucket Name\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getFederatedDatabaseInstance.\n",
                "properties": {
                    "cloudProviderConfig": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedDatabaseInstanceCloudProviderConfig:getFederatedDatabaseInstanceCloudProviderConfig"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the Atlas Federated Database Instance.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create a Federated Database Instance.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getFederatedDatabaseInstance.\n",
                "properties": {
                    "cloudProviderConfig": {
                        "$ref": "#/types/mongodbatlas:index/getFederatedDatabaseInstanceCloudProviderConfig:getFederatedDatabaseInstanceCloudProviderConfig"
                    },
                    "dataProcessRegions": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getFederatedDatabaseInstanceDataProcessRegion:getFederatedDatabaseInstanceDataProcessRegion"
                        },
                        "type": "array"
                    },
                    "hostnames": {
                        "description": "The list of hostnames assigned to the Federated Database Instance. Each string in the array is a hostname assigned to the Federated Database Instance.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "state": {
                        "description": "Current state of the Federated Database Instance:\n* `ACTIVE` - The Federated Database Instance is active and verified. You can query the data stores associated with the Federated Database Instance.\n* `DELETED` - The Federated Database Instance was deleted.\n",
                        "type": "string"
                    },
                    "storageDatabases": {
                        "description": "Configuration details for mapping each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [databases](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-databases-reference). An empty object indicates that the Federated Database Instance has no mapping configuration for any data store.\n* `storage_databases.#.name` - Name of the database to which the Federated Database Instance maps the data contained in the data store.\n* `storage_databases.#.collections` -     Array of objects where each object represents a collection and data sources that map to a [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#mongodb-datalakeconf-datalakeconf.stores) data store.\n* `storage_databases.#.collections.#.name` - Name of the collection.\n* `storage_databases.#.collections.#.data_sources` -     Array of objects where each object represents a stores data store to map with the collection.\n* `storage_databases.#.collections.#.data_sources.#.store_name` -     Name of a data store to map to the `\u003ccollection\u003e`. Must match the name of an object in the stores array.\n* `storage_databases.#.collections.#.data_sources.#.dataset_name` -     Human-readable label that identifies the dataset that Atlas generates for an ingestion pipeline run or Online Archive.\n* `storage_databases.#.collections.#.data_sources.#.default_format` - Default format that Federated Database assumes if it encounters a file without an extension while searching the storeName.\n* `storage_databases.#.collections.#.data_sources.#.path` - File path that controls how MongoDB Cloud searches for and parses files in the storeName before mapping them to a collection. Specify / to capture all files and folders from the prefix path.\n* `storage_databases.#.collections.#.data_sources.#.database` - Human-readable label that identifies the database, which contains the collection in the cluster.\n* `storage_databases.#.collections.#.data_sources.#.allow_insecure` - Flag that validates the scheme in the specified URLs. If true, allows insecure HTTP scheme, doesn't verify the server's certificate chain and hostname, and accepts any certificate with any hostname presented by the server. If false, allows secure HTTPS scheme only.\n* `storage_databases.#.collections.#.data_sources.#.database_regex` - Regex pattern to use for creating the wildcard database.\n* `storage_databases.#.collections.#.data_sources.#.collection` - Human-readable label that identifies the collection in the database.\n* `storage_databases.#.collections.#.data_sources.#.collection_regex` - Regex pattern to use for creating the wildcard (*) collection.\n* `storage_databases.#.collections.#.data_sources.#.provenance_field_name` - Name for the field that includes the provenance of the documents in the results.\n* `storage_databases.#.collections.#.data_sources.#.storeName` - Human-readable label that identifies the data store that MongoDB Cloud maps to the collection.\n* `storage_databases.#.collections.#.data_sources.#.urls` - URLs of the publicly accessible data files. You can't specify URLs that require authentication.\n* `storage_databases.#.views` -     Array of objects where each object represents an [aggregation pipeline](https://docs.mongodb.com/manual/core/aggregation-pipeline/#id1) on a collection. To learn more about views, see [Views](https://docs.mongodb.com/manual/core/views/).\n* `storage_databases.#.views.#.name` - Name of the view.\n* `storage_databases.#.views.#.source` -  Name of the source collection for the view.\n* `storage_databases.#.views.#.pipeline`- Aggregation pipeline stage(s) to apply to the source collection.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getFederatedDatabaseInstanceStorageDatabase:getFederatedDatabaseInstanceStorageDatabase"
                        },
                        "type": "array"
                    },
                    "storageStores": {
                        "description": "Each object in the array represents a data store. Federated Database uses the storage.databases configuration details to map data in each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-stores-reference). An empty object indicates that the Federated Database Instance has no configured data stores.\n* `storage_stores.#.name` - Name of the data store.\n* `storage_stores.#.provider` - Defines where the data is stored.\n* `storage_stores.#.region` - Name of the AWS region in which the S3 bucket is hosted.\n* `storage_stores.#.bucket` - Name of the AWS S3 bucket.\n* `storage_stores.#.prefix` - Prefix the Federated Database Instance applies when searching for files in the S3 bucket.\n* `storage_stores.#.delimiter` - The delimiter that separates `storage_databases.#.collections.#.data_sources.#.path` segments in the data store.\n* `storage_stores.#.include_tags` - Determines whether or not to use S3 tags on the files in the given path as additional partition attributes.\n* `storage_stores.#.cluster_name` - Human-readable label of the MongoDB Cloud cluster on which the store is based.\n* `storage_stores.#.cluster_id` - ID of the Cluster the Online Archive belongs to.\n* `storage_stores.#.allow_insecure` - Flag that validates the scheme in the specified URLs.\n* `storage_stores.#.public` - Flag that indicates whether the bucket is public.\n* `storage_stores.#.default_format` - Default format that Data Lake assumes if it encounters a file without an extension while searching the storeName.\n* `storage_stores.#.urls` - Comma-separated list of publicly accessible HTTP URLs where data is stored.\n* `storage_stores.#.read_preference` - MongoDB Cloud cluster read preference, which describes how to route read requests to the cluster.\n* `storage_stores.#.read_preference.maxStalenessSeconds` - Maximum replication lag, or staleness, for reads from secondaries.\n* `storage_stores.#.read_preference.mode` - Read preference mode that specifies to which replica set member to route the read requests.\n* `storage_stores.#.read_preference.tag_sets` - List that contains tag sets or tag specification documents.\n* `storage_stores.#.read_preference.tags` - List of all tags within a tag set\n* `storage_stores.#.read_preference.tags.name` - Human-readable label of the tag.\n* `storage_stores.#.read_preference.tags.value` - Value of the tag.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getFederatedDatabaseInstanceStorageStore:getFederatedDatabaseInstanceStorageStore"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "cloudProviderConfig",
                    "dataProcessRegions",
                    "hostnames",
                    "name",
                    "projectId",
                    "state",
                    "storageDatabases",
                    "storageStores",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getFederatedDatabaseInstances:getFederatedDatabaseInstances": {
            "description": "## # Data Source: mongodbatlas.getFederatedDatabaseInstances\n\n`mongodbatlas_federated_database_instancess` provides a Federated Database Instance data source.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n\u003e **IMPORTANT:** All arguments including the password will be stored in the raw state as plain text. Read more about sensitive data in state.\n\n## Example Usage\n\n### S\n\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetFederatedDatabaseInstancesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getFederatedDatabaseInstances(GetFederatedDatabaseInstancesArgs.builder()\n            .projectId(\"PROJECT ID\")\n            .name(\"TENANT NAME OF THE FEDERATED DATABASE INSTANCE\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getFederatedDatabaseInstances\n      Arguments:\n        projectId: PROJECT ID\n        name: TENANT NAME OF THE FEDERATED DATABASE INSTANCE\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getFederatedDatabaseInstances.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create a Federated Database Instance.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getFederatedDatabaseInstances.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "description": "Includes Federated Database instance for each item detailed in the results array section.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getFederatedDatabaseInstancesResult:getFederatedDatabaseInstancesResult"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "projectId",
                    "results",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getFederatedQueryLimit:getFederatedQueryLimit": {
            "description": "## # Data Source: mongodbatlas.FederatedQueryLimit\n\n`mongodbatlas.FederatedQueryLimit` provides a Federated Database Instance Query Limit data source. To learn more about Atlas Data Federation see https://www.mongodb.com/docs/atlas/data-federation/overview/. \n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = mongodbatlas.getFederatedQueryLimit({\n    projectId: \"PROJECT_ID\",\n    tenantName: \"FEDERATED_DATABASE_INSTANCE_NAME\",\n    limitName: \"LIMIT_NAME\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.get_federated_query_limit(project_id=\"PROJECT_ID\",\n    tenant_name=\"FEDERATED_DATABASE_INSTANCE_NAME\",\n    limit_name=\"LIMIT_NAME\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Mongodbatlas.GetFederatedQueryLimit.Invoke(new()\n    {\n        ProjectId = \"PROJECT_ID\",\n        TenantName = \"FEDERATED_DATABASE_INSTANCE_NAME\",\n        LimitName = \"LIMIT_NAME\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.LookupFederatedQueryLimit(ctx, \u0026mongodbatlas.LookupFederatedQueryLimitArgs{\n\t\t\tProjectId:  \"PROJECT_ID\",\n\t\t\tTenantName: \"FEDERATED_DATABASE_INSTANCE_NAME\",\n\t\t\tLimitName:  \"LIMIT_NAME\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetFederatedQueryLimitArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getFederatedQueryLimit(GetFederatedQueryLimitArgs.builder()\n            .projectId(\"PROJECT_ID\")\n            .tenantName(\"FEDERATED_DATABASE_INSTANCE_NAME\")\n            .limitName(\"LIMIT_NAME\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getFederatedQueryLimit\n      Arguments:\n        projectId: PROJECT_ID\n        tenantName: FEDERATED_DATABASE_INSTANCE_NAME\n        limitName: LIMIT_NAME\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getFederatedQueryLimit.\n",
                "properties": {
                    "limitName": {
                        "type": "string",
                        "description": "String enum that indicates whether the identity provider is active or not. Accepted values are:\n* `bytesProcessed.query`: Limit on the number of bytes processed during a single data federation query.\n* `bytesProcessed.daily`: Limit on the number of bytes processed for the data federation instance for the current day.\n* `bytesProcessed.weekly`: Limit on the number of bytes processed for the data federation instance for the current week.\n* `bytesProcessed.monthly`: Limit on the number of bytes processed for the data federation instance for the current month.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create a Federated Database Instance.\n"
                    },
                    "tenantName": {
                        "type": "string",
                        "description": "Name of the Atlas Federated Database Instance.\n"
                    }
                },
                "type": "object",
                "required": [
                    "limitName",
                    "projectId",
                    "tenantName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getFederatedQueryLimit.\n",
                "properties": {
                    "currentUsage": {
                        "description": "Amount that indicates the current usage of the limit.\n",
                        "type": "integer"
                    },
                    "defaultLimit": {
                        "description": "Default value of the limit.\n* `lastModifiedDate` - Only used for Data Federation limits. Timestamp that indicates when this usage limit was last modified. This field uses the ISO 8601 timestamp format in UTC.\n* `maximumLimit` - Maximum value of the limit.\n",
                        "type": "integer"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "lastModifiedDate": {
                        "type": "string"
                    },
                    "limitName": {
                        "type": "string"
                    },
                    "maximumLimit": {
                        "type": "integer"
                    },
                    "overrunPolicy": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "tenantName": {
                        "type": "string"
                    },
                    "value": {
                        "type": "integer"
                    }
                },
                "required": [
                    "currentUsage",
                    "defaultLimit",
                    "lastModifiedDate",
                    "limitName",
                    "maximumLimit",
                    "overrunPolicy",
                    "projectId",
                    "tenantName",
                    "value",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getFederatedQueryLimits:getFederatedQueryLimits": {
            "description": "## # Data Source: mongodbatlas.getFederatedQueryLimits\n\n`mongodbatlas.getFederatedQueryLimits` provides a Federated Database Instance Query Limits data source. To learn more about Atlas Data Federation see https://www.mongodb.com/docs/atlas/data-federation/overview/. \n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n## Example Usage\n\n### S\n\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = mongodbatlas.getFederatedQueryLimits({\n    projectId: \"PROJECT_ID\",\n    tenantName: \"FEDERATED_DATABASE_INSTANCE_NAME\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.get_federated_query_limits(project_id=\"PROJECT_ID\",\n    tenant_name=\"FEDERATED_DATABASE_INSTANCE_NAME\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Mongodbatlas.GetFederatedQueryLimits.Invoke(new()\n    {\n        ProjectId = \"PROJECT_ID\",\n        TenantName = \"FEDERATED_DATABASE_INSTANCE_NAME\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.LookupFederatedQueryLimits(ctx, \u0026mongodbatlas.LookupFederatedQueryLimitsArgs{\n\t\t\tProjectId:  \"PROJECT_ID\",\n\t\t\tTenantName: \"FEDERATED_DATABASE_INSTANCE_NAME\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetFederatedQueryLimitsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getFederatedQueryLimits(GetFederatedQueryLimitsArgs.builder()\n            .projectId(\"PROJECT_ID\")\n            .tenantName(\"FEDERATED_DATABASE_INSTANCE_NAME\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getFederatedQueryLimits\n      Arguments:\n        projectId: PROJECT_ID\n        tenantName: FEDERATED_DATABASE_INSTANCE_NAME\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getFederatedQueryLimits.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create a Federated Database Instance.\n"
                    },
                    "tenantName": {
                        "type": "string",
                        "description": "Name of the Atlas Federated Database Instance.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId",
                    "tenantName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getFederatedQueryLimits.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "description": "Includes Federated Database instance query limits for each item detailed in the results array section.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getFederatedQueryLimitsResult:getFederatedQueryLimitsResult"
                        },
                        "type": "array"
                    },
                    "tenantName": {
                        "type": "string"
                    }
                },
                "required": [
                    "projectId",
                    "results",
                    "tenantName",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getFederatedSettings:getFederatedSettings": {
            "description": "## # Data Source: mongodbatlas.getFederatedSettings\n\n`mongodbatlas.getFederatedSettings` provides a federated settings data source. Atlas Cloud federated settings provides federated settings outputs.\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst settings = mongodbatlas.getFederatedSettings({\n    orgId: \"627a9683e7f7f7ff7fe306f14\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nsettings = mongodbatlas.get_federated_settings(org_id=\"627a9683e7f7f7ff7fe306f14\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var settings = Mongodbatlas.GetFederatedSettings.Invoke(new()\n    {\n        OrgId = \"627a9683e7f7f7ff7fe306f14\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.GetFederatedSettings(ctx, \u0026mongodbatlas.GetFederatedSettingsArgs{\n\t\t\tOrgId: \"627a9683e7f7f7ff7fe306f14\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetFederatedSettingsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var settings = MongodbatlasFunctions.getFederatedSettings(GetFederatedSettingsArgs.builder()\n            .orgId(\"627a9683e7f7f7ff7fe306f14\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  settings:\n    fn::invoke:\n      Function: mongodbatlas:getFederatedSettings\n      Arguments:\n        orgId: 627a9683e7f7f7ff7fe306f14\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getFederatedSettings.\n",
                "properties": {
                    "orgId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                    }
                },
                "type": "object",
                "required": [
                    "orgId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getFederatedSettings.\n",
                "properties": {
                    "federatedDomains": {
                        "description": "List that contains the domains associated with the organization's identity provider.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "hasRoleMappings": {
                        "description": "Flag that indicates whether this organization has role mappings configured.\n",
                        "type": "boolean"
                    },
                    "id": {
                        "description": "Unique 24-hexadecimal digit string that identifies this federation.\n",
                        "type": "string"
                    },
                    "identityProviderId": {
                        "description": "Unique 20-hexadecimal digit string that identifies the identity provider connected to this organization.\n",
                        "type": "string"
                    },
                    "identityProviderStatus": {
                        "description": "Value that indicates whether the identity provider is active. Atlas returns ACTIVE if the identity provider is active and INACTIVE if the identity provider is inactive.\n",
                        "type": "string"
                    },
                    "orgId": {
                        "type": "string"
                    }
                },
                "required": [
                    "federatedDomains",
                    "hasRoleMappings",
                    "id",
                    "identityProviderId",
                    "identityProviderStatus",
                    "orgId"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProvider:getFederatedSettingsIdentityProvider": {
            "description": "## # Data Source: mongodbatlas.FederatedSettingsIdentityProvider\n\n`mongodbatlas.FederatedSettingsIdentityProvider` provides a federated settings identity provider data source. Atlas federated settings identity provider provides federated settings outputs for the configured identity provider.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst identityProvider = new mongodbatlas.FederatedSettingsIdentityProvider(\"identity_provider\", {\n    federationSettingsId: \"627a9687f7f7f7f774de306f14\",\n    name: \"mongodb_federation_test\",\n    associatedDomains: [\"yourdomain.com\"],\n    ssoDebugEnabled: true,\n    status: \"ACTIVE\",\n    ssoUrl: \"https://mysso.oktapreview.com/app/mysso_terraformtest_1/exk177f7f7f70h8/sso/saml\",\n    issuerUri: \"http://www.okta.com/exk17f7f7f7f7p50h8\",\n    requestBinding: \"HTTP-POST\",\n    responseSignatureAlgorithm: \"SHA-256\",\n});\nconst identityProviderDs = mongodbatlas.getFederatedSettingsIdentityProviderOutput({\n    federationSettingsId: identityProvider.id,\n    identityProviderId: \"0oad4fas87jL5Xnk12971234\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nidentity_provider = mongodbatlas.FederatedSettingsIdentityProvider(\"identity_provider\",\n    federation_settings_id=\"627a9687f7f7f7f774de306f14\",\n    name=\"mongodb_federation_test\",\n    associated_domains=[\"yourdomain.com\"],\n    sso_debug_enabled=True,\n    status=\"ACTIVE\",\n    sso_url=\"https://mysso.oktapreview.com/app/mysso_terraformtest_1/exk177f7f7f70h8/sso/saml\",\n    issuer_uri=\"http://www.okta.com/exk17f7f7f7f7p50h8\",\n    request_binding=\"HTTP-POST\",\n    response_signature_algorithm=\"SHA-256\")\nidentity_provider_ds = mongodbatlas.get_federated_settings_identity_provider_output(federation_settings_id=identity_provider.id,\n    identity_provider_id=\"0oad4fas87jL5Xnk12971234\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var identityProvider = new Mongodbatlas.FederatedSettingsIdentityProvider(\"identity_provider\", new()\n    {\n        FederationSettingsId = \"627a9687f7f7f7f774de306f14\",\n        Name = \"mongodb_federation_test\",\n        AssociatedDomains = new[]\n        {\n            \"yourdomain.com\",\n        },\n        SsoDebugEnabled = true,\n        Status = \"ACTIVE\",\n        SsoUrl = \"https://mysso.oktapreview.com/app/mysso_terraformtest_1/exk177f7f7f70h8/sso/saml\",\n        IssuerUri = \"http://www.okta.com/exk17f7f7f7f7p50h8\",\n        RequestBinding = \"HTTP-POST\",\n        ResponseSignatureAlgorithm = \"SHA-256\",\n    });\n\n    var identityProviderDs = Mongodbatlas.GetFederatedSettingsIdentityProvider.Invoke(new()\n    {\n        FederationSettingsId = identityProvider.Id,\n        IdentityProviderId = \"0oad4fas87jL5Xnk12971234\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tidentityProvider, err := mongodbatlas.NewFederatedSettingsIdentityProvider(ctx, \"identity_provider\", \u0026mongodbatlas.FederatedSettingsIdentityProviderArgs{\n\t\t\tFederationSettingsId: pulumi.String(\"627a9687f7f7f7f774de306f14\"),\n\t\t\tName:                 pulumi.String(\"mongodb_federation_test\"),\n\t\t\tAssociatedDomains: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"yourdomain.com\"),\n\t\t\t},\n\t\t\tSsoDebugEnabled:            pulumi.Bool(true),\n\t\t\tStatus:                     pulumi.String(\"ACTIVE\"),\n\t\t\tSsoUrl:                     pulumi.String(\"https://mysso.oktapreview.com/app/mysso_terraformtest_1/exk177f7f7f70h8/sso/saml\"),\n\t\t\tIssuerUri:                  pulumi.String(\"http://www.okta.com/exk17f7f7f7f7p50h8\"),\n\t\t\tRequestBinding:             pulumi.String(\"HTTP-POST\"),\n\t\t\tResponseSignatureAlgorithm: pulumi.String(\"SHA-256\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupFederatedSettingsIdentityProviderOutput(ctx, mongodbatlas.GetFederatedSettingsIdentityProviderOutputArgs{\n\t\t\tFederationSettingsId: identityProvider.ID(),\n\t\t\tIdentityProviderId:   pulumi.String(\"0oad4fas87jL5Xnk12971234\"),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.FederatedSettingsIdentityProvider;\nimport com.pulumi.mongodbatlas.FederatedSettingsIdentityProviderArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetFederatedSettingsIdentityProviderArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var identityProvider = new FederatedSettingsIdentityProvider(\"identityProvider\", FederatedSettingsIdentityProviderArgs.builder()\n            .federationSettingsId(\"627a9687f7f7f7f774de306f14\")\n            .name(\"mongodb_federation_test\")\n            .associatedDomains(\"yourdomain.com\")\n            .ssoDebugEnabled(true)\n            .status(\"ACTIVE\")\n            .ssoUrl(\"https://mysso.oktapreview.com/app/mysso_terraformtest_1/exk177f7f7f70h8/sso/saml\")\n            .issuerUri(\"http://www.okta.com/exk17f7f7f7f7p50h8\")\n            .requestBinding(\"HTTP-POST\")\n            .responseSignatureAlgorithm(\"SHA-256\")\n            .build());\n\n        final var identityProviderDs = MongodbatlasFunctions.getFederatedSettingsIdentityProvider(GetFederatedSettingsIdentityProviderArgs.builder()\n            .federationSettingsId(identityProvider.id())\n            .identityProviderId(\"0oad4fas87jL5Xnk12971234\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  identityProvider:\n    type: mongodbatlas:FederatedSettingsIdentityProvider\n    name: identity_provider\n    properties:\n      federationSettingsId: 627a9687f7f7f7f774de306f14\n      name: mongodb_federation_test\n      associatedDomains:\n        - yourdomain.com\n      ssoDebugEnabled: true\n      status: ACTIVE\n      ssoUrl: https://mysso.oktapreview.com/app/mysso_terraformtest_1/exk177f7f7f70h8/sso/saml\n      issuerUri: http://www.okta.com/exk17f7f7f7f7p50h8\n      requestBinding: HTTP-POST\n      responseSignatureAlgorithm: SHA-256\nvariables:\n  identityProviderDs:\n    fn::invoke:\n      Function: mongodbatlas:getFederatedSettingsIdentityProvider\n      Arguments:\n        federationSettingsId: ${identityProvider.id}\n        identityProviderId: 0oad4fas87jL5Xnk12971234\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getFederatedSettingsIdentityProvider.\n",
                "properties": {
                    "federationSettingsId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                    },
                    "identityProviderId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the IdP.\n"
                    }
                },
                "type": "object",
                "required": [
                    "federationSettingsId",
                    "identityProviderId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getFederatedSettingsIdentityProvider.\n",
                "properties": {
                    "acsUrl": {
                        "description": "Assertion consumer service URL to which the IdP sends the SAML response.\n",
                        "type": "string"
                    },
                    "associatedDomains": {
                        "description": "List that contains the configured domains from which users can log in for this IdP.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "associatedOrgs": {
                        "description": "List that contains the organizations from which users can log in for this IdP.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getFederatedSettingsIdentityProviderAssociatedOrg:getFederatedSettingsIdentityProviderAssociatedOrg"
                        },
                        "type": "array"
                    },
                    "audience": {
                        "description": "Identifier of the intended recipient of the token.\n",
                        "type": "string"
                    },
                    "audienceUri": {
                        "description": "Identifier for the intended audience of the SAML Assertion.\n",
                        "type": "string"
                    },
                    "authorizationType": {
                        "description": "Indicates whether authorization is granted based on group membership or user ID. Valid values are `GROUP` or `USER`.\n",
                        "type": "string"
                    },
                    "clientId": {
                        "description": "Client identifier that is assigned to an application by the Identity Provider.\n",
                        "type": "string"
                    },
                    "description": {
                        "description": "The description of the identity provider.\n",
                        "type": "string"
                    },
                    "displayName": {
                        "description": "Human-readable label that identifies the IdP.\n",
                        "type": "string"
                    },
                    "federationSettingsId": {
                        "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n",
                        "type": "string"
                    },
                    "groupsClaim": {
                        "description": "Identifier of the claim which contains IdP Group IDs in the token.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "identityProviderId": {
                        "type": "string"
                    },
                    "idpId": {
                        "description": "Unique 24-hexadecimal digit string that identifies the IdP\n",
                        "type": "string"
                    },
                    "idpType": {
                        "description": "Type of the identity provider. Valid values are `WORKFORCE` or `WORKLOAD`.\n",
                        "type": "string"
                    },
                    "issuerUri": {
                        "description": "Identifier for the issuer of the SAML Assertion.\n",
                        "type": "string"
                    },
                    "oktaIdpId": {
                        "description": "Unique 20-hexadecimal digit string that identifies the IdP.\n",
                        "type": "string"
                    },
                    "pemFileInfos": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getFederatedSettingsIdentityProviderPemFileInfo:getFederatedSettingsIdentityProviderPemFileInfo"
                        },
                        "type": "array"
                    },
                    "protocol": {
                        "description": "The protocol of the identity provider. Valid values are `SAML` or `OIDC`.\n",
                        "type": "string"
                    },
                    "requestBinding": {
                        "description": "SAML Authentication Request Protocol binding used to send the AuthNRequest. Atlas supports the following binding values:\n- HTTP POST\n- HTTP REDIRECT\n",
                        "type": "string"
                    },
                    "requestedScopes": {
                        "description": "Scopes that MongoDB applications will request from the authorization endpoint.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "responseSignatureAlgorithm": {
                        "description": "Algorithm used to encrypt the IdP signature. Atlas supports the following signature algorithm values:\n- SHA-1\n- SHA-256\n",
                        "type": "string"
                    },
                    "ssoDebugEnabled": {
                        "description": "Flag that indicates whether the IdP has enabled Bypass SAML Mode. Enabling this mode generates a URL that allows you bypass SAML and login to your organizations at any point. You can authenticate with this special URL only when Bypass Mode is enabled. Set this parameter to true during testing. This keeps you from getting locked out of MongoDB.\n",
                        "type": "boolean"
                    },
                    "ssoUrl": {
                        "description": "URL of the receiver of the SAML AuthNRequest.\n",
                        "type": "string"
                    },
                    "status": {
                        "description": "Label that indicates whether the identity provider is active. The IdP is Inactive until you map at least one domain to the IdP.\n",
                        "type": "string"
                    },
                    "userClaim": {
                        "description": "Identifier of the claim which contains the user ID in the token.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "acsUrl",
                    "associatedDomains",
                    "associatedOrgs",
                    "audience",
                    "audienceUri",
                    "authorizationType",
                    "clientId",
                    "description",
                    "displayName",
                    "federationSettingsId",
                    "groupsClaim",
                    "identityProviderId",
                    "idpId",
                    "idpType",
                    "issuerUri",
                    "oktaIdpId",
                    "pemFileInfos",
                    "protocol",
                    "requestBinding",
                    "requestedScopes",
                    "responseSignatureAlgorithm",
                    "ssoDebugEnabled",
                    "ssoUrl",
                    "status",
                    "userClaim",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getFederatedSettingsIdentityProviders:getFederatedSettingsIdentityProviders": {
            "description": "## # Data Source: mongodbatlas.getFederatedSettingsIdentityProviders\n\n`mongodbatlas.getFederatedSettingsIdentityProviders` provides an Federated Settings Identity Providers datasource. Atlas Cloud Federated Settings Identity Providers provides federated settings outputs for the configured Identity Providers.\n\nNote: This implementation returns a maximum of 100 results.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.FederatedSettingsIdentityProvider;\nimport com.pulumi.mongodbatlas.FederatedSettingsIdentityProviderArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetFederatedSettingsIdentityProvidersArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var identityProvider = new FederatedSettingsIdentityProvider(\"identityProvider\", FederatedSettingsIdentityProviderArgs.builder()\n            .federationSettingsId(\"627a9687f7f7f7f774de306f\")\n            .name(\"mongodb_federation_test\")\n            .associatedDomains(\"yourdomain.com\")\n            .ssoDebugEnabled(true)\n            .status(\"ACTIVE\")\n            .build());\n\n        final var identittyProvider = MongodbatlasFunctions.getFederatedSettingsIdentityProviders(GetFederatedSettingsIdentityProvidersArgs.builder()\n            .federationSettingsId(identityProvider.id())\n            .pageNum(1)\n            .itemsPerPage(5)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  identityProvider:\n    type: mongodbatlas:FederatedSettingsIdentityProvider\n    name: identity_provider\n    properties:\n      federationSettingsId: 627a9687f7f7f7f774de306f\n      name: mongodb_federation_test\n      associatedDomains:\n        - yourdomain.com\n      ssoDebugEnabled: true\n      status: ACTIVE\nvariables:\n  identittyProvider:\n    fn::invoke:\n      Function: mongodbatlas:getFederatedSettingsIdentityProviders\n      Arguments:\n        federationSettingsId: ${identityProvider.id}\n        pageNum: 1\n        itemsPerPage: 5\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getFederatedSettingsIdentityProviders.\n",
                "properties": {
                    "federationSettingsId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                    },
                    "idpTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The types of the target identity providers. Valid values are `WORKFORCE` and `WORKLOAD`.\n"
                    },
                    "protocols": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The protocols of the target identity providers. Valid values are `SAML` and `OIDC`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "federationSettingsId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getFederatedSettingsIdentityProviders.\n",
                "properties": {
                    "federationSettingsId": {
                        "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "idpTypes": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "protocols": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "results": {
                        "description": "Includes cloudProviderSnapshot object for each item detailed in the results array section.\n* `totalCount` - Count of the total number of items in the result set. It may be greater than the number of objects in the results array if the entire result set is paginated.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getFederatedSettingsIdentityProvidersResult:getFederatedSettingsIdentityProvidersResult"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "federationSettingsId",
                    "results",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getFederatedSettingsOrgConfig:getFederatedSettingsOrgConfig": {
            "description": "## # Data Source: mongodbatlas.FederatedSettingsOrgConfig\n\n`mongodbatlas.FederatedSettingsOrgConfig` provides an Federated Settings Identity Providers datasource. Atlas Cloud Federated Settings Organizational configuration provides federated settings outputs for the configured Organizational configuration.\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst orgConnection = new mongodbatlas.FederatedSettingsOrgConfig(\"org_connection\", {\n    federationSettingsId: \"627a9687f7f7f7f774de306f14\",\n    orgId: \"627a9683ea7ff7f74de306f14\",\n    dataAccessIdentityProviderIds: [\"64d613677e1ad50839cce4db\"],\n    domainRestrictionEnabled: false,\n    domainAllowLists: [\"mydomain.com\"],\n    postAuthRoleGrants: [\"ORG_MEMBER\"],\n    identityProviderId: \"0oaqyt9fc2ySTWnA0357\",\n});\nconst orgConfigsDs = mongodbatlas.getFederatedSettingsOrgConfig({\n    federationSettingsId: orgConnectionMongodbatlasFederatedSettingsOrgConfig.id,\n    orgId: \"627a9683ea7ff7f74de306f14\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\norg_connection = mongodbatlas.FederatedSettingsOrgConfig(\"org_connection\",\n    federation_settings_id=\"627a9687f7f7f7f774de306f14\",\n    org_id=\"627a9683ea7ff7f74de306f14\",\n    data_access_identity_provider_ids=[\"64d613677e1ad50839cce4db\"],\n    domain_restriction_enabled=False,\n    domain_allow_lists=[\"mydomain.com\"],\n    post_auth_role_grants=[\"ORG_MEMBER\"],\n    identity_provider_id=\"0oaqyt9fc2ySTWnA0357\")\norg_configs_ds = mongodbatlas.get_federated_settings_org_config(federation_settings_id=org_connection_mongodbatlas_federated_settings_org_config[\"id\"],\n    org_id=\"627a9683ea7ff7f74de306f14\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var orgConnection = new Mongodbatlas.FederatedSettingsOrgConfig(\"org_connection\", new()\n    {\n        FederationSettingsId = \"627a9687f7f7f7f774de306f14\",\n        OrgId = \"627a9683ea7ff7f74de306f14\",\n        DataAccessIdentityProviderIds = new[]\n        {\n            \"64d613677e1ad50839cce4db\",\n        },\n        DomainRestrictionEnabled = false,\n        DomainAllowLists = new[]\n        {\n            \"mydomain.com\",\n        },\n        PostAuthRoleGrants = new[]\n        {\n            \"ORG_MEMBER\",\n        },\n        IdentityProviderId = \"0oaqyt9fc2ySTWnA0357\",\n    });\n\n    var orgConfigsDs = Mongodbatlas.GetFederatedSettingsOrgConfig.Invoke(new()\n    {\n        FederationSettingsId = orgConnectionMongodbatlasFederatedSettingsOrgConfig.Id,\n        OrgId = \"627a9683ea7ff7f74de306f14\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewFederatedSettingsOrgConfig(ctx, \"org_connection\", \u0026mongodbatlas.FederatedSettingsOrgConfigArgs{\n\t\t\tFederationSettingsId: pulumi.String(\"627a9687f7f7f7f774de306f14\"),\n\t\t\tOrgId:                pulumi.String(\"627a9683ea7ff7f74de306f14\"),\n\t\t\tDataAccessIdentityProviderIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"64d613677e1ad50839cce4db\"),\n\t\t\t},\n\t\t\tDomainRestrictionEnabled: pulumi.Bool(false),\n\t\t\tDomainAllowLists: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"mydomain.com\"),\n\t\t\t},\n\t\t\tPostAuthRoleGrants: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"ORG_MEMBER\"),\n\t\t\t},\n\t\t\tIdentityProviderId: pulumi.String(\"0oaqyt9fc2ySTWnA0357\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.LookupFederatedSettingsOrgConfig(ctx, \u0026mongodbatlas.LookupFederatedSettingsOrgConfigArgs{\n\t\t\tFederationSettingsId: orgConnectionMongodbatlasFederatedSettingsOrgConfig.Id,\n\t\t\tOrgId:                \"627a9683ea7ff7f74de306f14\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.FederatedSettingsOrgConfig;\nimport com.pulumi.mongodbatlas.FederatedSettingsOrgConfigArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetFederatedSettingsOrgConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var orgConnection = new FederatedSettingsOrgConfig(\"orgConnection\", FederatedSettingsOrgConfigArgs.builder()\n            .federationSettingsId(\"627a9687f7f7f7f774de306f14\")\n            .orgId(\"627a9683ea7ff7f74de306f14\")\n            .dataAccessIdentityProviderIds(\"64d613677e1ad50839cce4db\")\n            .domainRestrictionEnabled(false)\n            .domainAllowLists(\"mydomain.com\")\n            .postAuthRoleGrants(\"ORG_MEMBER\")\n            .identityProviderId(\"0oaqyt9fc2ySTWnA0357\")\n            .build());\n\n        final var orgConfigsDs = MongodbatlasFunctions.getFederatedSettingsOrgConfig(GetFederatedSettingsOrgConfigArgs.builder()\n            .federationSettingsId(orgConnectionMongodbatlasFederatedSettingsOrgConfig.id())\n            .orgId(\"627a9683ea7ff7f74de306f14\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  orgConnection:\n    type: mongodbatlas:FederatedSettingsOrgConfig\n    name: org_connection\n    properties:\n      federationSettingsId: 627a9687f7f7f7f774de306f14\n      orgId: 627a9683ea7ff7f74de306f14\n      dataAccessIdentityProviderIds:\n        - 64d613677e1ad50839cce4db\n      domainRestrictionEnabled: false\n      domainAllowLists:\n        - mydomain.com\n      postAuthRoleGrants:\n        - ORG_MEMBER\n      identityProviderId: 0oaqyt9fc2ySTWnA0357\nvariables:\n  orgConfigsDs:\n    fn::invoke:\n      Function: mongodbatlas:getFederatedSettingsOrgConfig\n      Arguments:\n        federationSettingsId: ${orgConnectionMongodbatlasFederatedSettingsOrgConfig.id}\n        orgId: 627a9683ea7ff7f74de306f14\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getFederatedSettingsOrgConfig.\n",
                "properties": {
                    "federationSettingsId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                    }
                },
                "type": "object",
                "required": [
                    "federationSettingsId",
                    "orgId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getFederatedSettingsOrgConfig.\n",
                "properties": {
                    "dataAccessIdentityProviderIds": {
                        "description": "The collection of unique ids representing the identity providers that can be used for data access in this organization.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "domainAllowLists": {
                        "description": "List that contains the approved domains from which organization users can log in.  Note: If the organization uses an identity provider,  `domain_allow_list` includes: any SSO domains associated with organization's identity provider and any custom domains associated with the specific organization.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "domainRestrictionEnabled": {
                        "description": "Flag that indicates whether domain restriction is enabled for the connected organization.  User Conflicts returns null when `domain_restriction_enabled` is false.\n",
                        "type": "boolean"
                    },
                    "federationSettingsId": {
                        "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "identityProviderId": {
                        "description": "Legacy 20-hexadecimal digit string that identifies the SAML access identity provider that this connected org config is associated with. This id can be found in two ways:\n1. Within the Federation Management UI in Atlas in the Identity Providers tab by clicking the info icon in the IdP ID row of a configured SAML identity provider\n2. `okta_idp_id` on the `mongodbatlas.FederatedSettingsIdentityProvider` resource\n",
                        "type": "string"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "postAuthRoleGrants": {
                        "description": "List that contains the default [roles](https://www.mongodb.com/docs/atlas/reference/user-roles/#std-label-organization-roles) granted to users who authenticate through the IdP in a connected organization.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "roleMappings": {
                        "description": "Role mappings that are configured in this organization. See below\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getFederatedSettingsOrgConfigRoleMapping:getFederatedSettingsOrgConfigRoleMapping"
                        },
                        "type": "array"
                    },
                    "userConflicts": {
                        "description": "List that contains the users who have an email address that doesn't match any domain on the allowed list. See below\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getFederatedSettingsOrgConfigUserConflict:getFederatedSettingsOrgConfigUserConflict"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "dataAccessIdentityProviderIds",
                    "domainAllowLists",
                    "domainRestrictionEnabled",
                    "federationSettingsId",
                    "identityProviderId",
                    "orgId",
                    "postAuthRoleGrants",
                    "roleMappings",
                    "userConflicts",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getFederatedSettingsOrgConfigs:getFederatedSettingsOrgConfigs": {
            "description": "## # Data Source: mongodbatlas.getFederatedSettingsOrgConfigs\n\n`mongodbatlas.getFederatedSettingsOrgConfigs` provides an Federated Settings Identity Providers datasource. Atlas Cloud Federated Settings Identity Providers provides federated settings outputs for the configured Identity Providers.\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst orgConnection = new mongodbatlas.FederatedSettingsOrgConfig(\"org_connection\", {\n    federationSettingsId: \"627a9687f7f7f7f774de306f14\",\n    orgId: \"627a9683ea7ff7f74de306f14\",\n    dataAccessIdentityProviderIds: [\"64d613677e1ad50839cce4db\"],\n    domainRestrictionEnabled: false,\n    domainAllowLists: [\"mydomain.com\"],\n    postAuthRoleGrants: [\"ORG_MEMBER\"],\n    identityProviderId: \"0oaqyt9fc2ySTWnA0357\",\n});\nconst orgConfigsDs = mongodbatlas.getFederatedSettingsOrgConfigs({\n    federationSettingsId: orgConnectionMongodbatlasFederatedSettingsOrgConfig.federationSettingsId,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\norg_connection = mongodbatlas.FederatedSettingsOrgConfig(\"org_connection\",\n    federation_settings_id=\"627a9687f7f7f7f774de306f14\",\n    org_id=\"627a9683ea7ff7f74de306f14\",\n    data_access_identity_provider_ids=[\"64d613677e1ad50839cce4db\"],\n    domain_restriction_enabled=False,\n    domain_allow_lists=[\"mydomain.com\"],\n    post_auth_role_grants=[\"ORG_MEMBER\"],\n    identity_provider_id=\"0oaqyt9fc2ySTWnA0357\")\norg_configs_ds = mongodbatlas.get_federated_settings_org_configs(federation_settings_id=org_connection_mongodbatlas_federated_settings_org_config[\"federationSettingsId\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var orgConnection = new Mongodbatlas.FederatedSettingsOrgConfig(\"org_connection\", new()\n    {\n        FederationSettingsId = \"627a9687f7f7f7f774de306f14\",\n        OrgId = \"627a9683ea7ff7f74de306f14\",\n        DataAccessIdentityProviderIds = new[]\n        {\n            \"64d613677e1ad50839cce4db\",\n        },\n        DomainRestrictionEnabled = false,\n        DomainAllowLists = new[]\n        {\n            \"mydomain.com\",\n        },\n        PostAuthRoleGrants = new[]\n        {\n            \"ORG_MEMBER\",\n        },\n        IdentityProviderId = \"0oaqyt9fc2ySTWnA0357\",\n    });\n\n    var orgConfigsDs = Mongodbatlas.GetFederatedSettingsOrgConfigs.Invoke(new()\n    {\n        FederationSettingsId = orgConnectionMongodbatlasFederatedSettingsOrgConfig.FederationSettingsId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewFederatedSettingsOrgConfig(ctx, \"org_connection\", \u0026mongodbatlas.FederatedSettingsOrgConfigArgs{\n\t\t\tFederationSettingsId: pulumi.String(\"627a9687f7f7f7f774de306f14\"),\n\t\t\tOrgId:                pulumi.String(\"627a9683ea7ff7f74de306f14\"),\n\t\t\tDataAccessIdentityProviderIds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"64d613677e1ad50839cce4db\"),\n\t\t\t},\n\t\t\tDomainRestrictionEnabled: pulumi.Bool(false),\n\t\t\tDomainAllowLists: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"mydomain.com\"),\n\t\t\t},\n\t\t\tPostAuthRoleGrants: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"ORG_MEMBER\"),\n\t\t\t},\n\t\t\tIdentityProviderId: pulumi.String(\"0oaqyt9fc2ySTWnA0357\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.LookupFederatedSettingsOrgConfigs(ctx, \u0026mongodbatlas.LookupFederatedSettingsOrgConfigsArgs{\n\t\t\tFederationSettingsId: orgConnectionMongodbatlasFederatedSettingsOrgConfig.FederationSettingsId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.FederatedSettingsOrgConfig;\nimport com.pulumi.mongodbatlas.FederatedSettingsOrgConfigArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetFederatedSettingsOrgConfigsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var orgConnection = new FederatedSettingsOrgConfig(\"orgConnection\", FederatedSettingsOrgConfigArgs.builder()\n            .federationSettingsId(\"627a9687f7f7f7f774de306f14\")\n            .orgId(\"627a9683ea7ff7f74de306f14\")\n            .dataAccessIdentityProviderIds(\"64d613677e1ad50839cce4db\")\n            .domainRestrictionEnabled(false)\n            .domainAllowLists(\"mydomain.com\")\n            .postAuthRoleGrants(\"ORG_MEMBER\")\n            .identityProviderId(\"0oaqyt9fc2ySTWnA0357\")\n            .build());\n\n        final var orgConfigsDs = MongodbatlasFunctions.getFederatedSettingsOrgConfigs(GetFederatedSettingsOrgConfigsArgs.builder()\n            .federationSettingsId(orgConnectionMongodbatlasFederatedSettingsOrgConfig.federationSettingsId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  orgConnection:\n    type: mongodbatlas:FederatedSettingsOrgConfig\n    name: org_connection\n    properties:\n      federationSettingsId: 627a9687f7f7f7f774de306f14\n      orgId: 627a9683ea7ff7f74de306f14\n      dataAccessIdentityProviderIds:\n        - 64d613677e1ad50839cce4db\n      domainRestrictionEnabled: false\n      domainAllowLists:\n        - mydomain.com\n      postAuthRoleGrants:\n        - ORG_MEMBER\n      identityProviderId: 0oaqyt9fc2ySTWnA0357\nvariables:\n  orgConfigsDs:\n    fn::invoke:\n      Function: mongodbatlas:getFederatedSettingsOrgConfigs\n      Arguments:\n        federationSettingsId: ${orgConnectionMongodbatlasFederatedSettingsOrgConfig.federationSettingsId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getFederatedSettingsOrgConfigs.\n",
                "properties": {
                    "federationSettingsId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer",
                        "description": "Number of items to return per page, up to a maximum of 500. Defaults to `100`.\n"
                    },
                    "pageNum": {
                        "type": "integer",
                        "description": "The page to return. Defaults to `1`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "federationSettingsId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getFederatedSettingsOrgConfigs.\n",
                "properties": {
                    "federationSettingsId": {
                        "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "results": {
                        "description": "Includes cloudProviderSnapshot object for each item detailed in the results array section.\n* `totalCount` - Count of the total number of items in the result set. It may be greater than the number of objects in the results array if the entire result set is paginated.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getFederatedSettingsOrgConfigsResult:getFederatedSettingsOrgConfigsResult"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "federationSettingsId",
                    "results",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getFederatedSettingsOrgRoleMapping:getFederatedSettingsOrgRoleMapping": {
            "description": "## # Data Source: mongodbatlas.FederatedSettingsOrgRoleMapping\n\n`mongodbatlas.FederatedSettingsOrgRoleMapping` provides an Federated Settings Org Role Mapping datasource. Atlas Cloud Federated Settings Org Role Mapping provides federated settings outputs for the configured Org Role Mapping.\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst orgGroupRoleMappingImport = new mongodbatlas.FederatedSettingsOrgRoleMapping(\"org_group_role_mapping_import\", {\n    federationSettingsId: federatedSettings.id,\n    orgId: \"627a9683e7f7f7ff7fe306f14\",\n    externalGroupName: \"myGrouptest\",\n    roleAssignments: [\n        {\n            orgId: \"627a9683e7f7f7ff7fe306f14\",\n            roles: [\n                \"ORG_MEMBER\",\n                \"ORG_GROUP_CREATOR\",\n                \"ORG_BILLING_ADMIN\",\n            ],\n        },\n        {\n            groupId: \"628aa20db7f7f7f98b81b8\",\n            roles: [\n                \"GROUP_OWNER\",\n                \"GROUP_DATA_ACCESS_ADMIN\",\n                \"GROUP_SEARCH_INDEX_EDITOR\",\n                \"GROUP_DATA_ACCESS_READ_ONLY\",\n            ],\n        },\n        {\n            groupId: \"62b477f7f7f7f5e741489c\",\n            roles: [\n                \"GROUP_OWNER\",\n                \"GROUP_DATA_ACCESS_ADMIN\",\n                \"GROUP_SEARCH_INDEX_EDITOR\",\n                \"GROUP_DATA_ACCESS_READ_ONLY\",\n                \"GROUP_DATA_ACCESS_READ_WRITE\",\n            ],\n        },\n    ],\n});\nconst roleMapping = mongodbatlas.getFederatedSettingsOrgRoleMappingOutput({\n    federationSettingsId: orgGroupRoleMappingImport.id,\n    orgId: \"627a9683e7f7f7ff7fe306f14\",\n    roleMappingId: \"627a9673e7f7f7ff7fe306f14\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\norg_group_role_mapping_import = mongodbatlas.FederatedSettingsOrgRoleMapping(\"org_group_role_mapping_import\",\n    federation_settings_id=federated_settings[\"id\"],\n    org_id=\"627a9683e7f7f7ff7fe306f14\",\n    external_group_name=\"myGrouptest\",\n    role_assignments=[\n        {\n            \"org_id\": \"627a9683e7f7f7ff7fe306f14\",\n            \"roles\": [\n                \"ORG_MEMBER\",\n                \"ORG_GROUP_CREATOR\",\n                \"ORG_BILLING_ADMIN\",\n            ],\n        },\n        {\n            \"group_id\": \"628aa20db7f7f7f98b81b8\",\n            \"roles\": [\n                \"GROUP_OWNER\",\n                \"GROUP_DATA_ACCESS_ADMIN\",\n                \"GROUP_SEARCH_INDEX_EDITOR\",\n                \"GROUP_DATA_ACCESS_READ_ONLY\",\n            ],\n        },\n        {\n            \"group_id\": \"62b477f7f7f7f5e741489c\",\n            \"roles\": [\n                \"GROUP_OWNER\",\n                \"GROUP_DATA_ACCESS_ADMIN\",\n                \"GROUP_SEARCH_INDEX_EDITOR\",\n                \"GROUP_DATA_ACCESS_READ_ONLY\",\n                \"GROUP_DATA_ACCESS_READ_WRITE\",\n            ],\n        },\n    ])\nrole_mapping = mongodbatlas.get_federated_settings_org_role_mapping_output(federation_settings_id=org_group_role_mapping_import.id,\n    org_id=\"627a9683e7f7f7ff7fe306f14\",\n    role_mapping_id=\"627a9673e7f7f7ff7fe306f14\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var orgGroupRoleMappingImport = new Mongodbatlas.FederatedSettingsOrgRoleMapping(\"org_group_role_mapping_import\", new()\n    {\n        FederationSettingsId = federatedSettings.Id,\n        OrgId = \"627a9683e7f7f7ff7fe306f14\",\n        ExternalGroupName = \"myGrouptest\",\n        RoleAssignments = new[]\n        {\n            new Mongodbatlas.Inputs.FederatedSettingsOrgRoleMappingRoleAssignmentArgs\n            {\n                OrgId = \"627a9683e7f7f7ff7fe306f14\",\n                Roles = new[]\n                {\n                    \"ORG_MEMBER\",\n                    \"ORG_GROUP_CREATOR\",\n                    \"ORG_BILLING_ADMIN\",\n                },\n            },\n            new Mongodbatlas.Inputs.FederatedSettingsOrgRoleMappingRoleAssignmentArgs\n            {\n                GroupId = \"628aa20db7f7f7f98b81b8\",\n                Roles = new[]\n                {\n                    \"GROUP_OWNER\",\n                    \"GROUP_DATA_ACCESS_ADMIN\",\n                    \"GROUP_SEARCH_INDEX_EDITOR\",\n                    \"GROUP_DATA_ACCESS_READ_ONLY\",\n                },\n            },\n            new Mongodbatlas.Inputs.FederatedSettingsOrgRoleMappingRoleAssignmentArgs\n            {\n                GroupId = \"62b477f7f7f7f5e741489c\",\n                Roles = new[]\n                {\n                    \"GROUP_OWNER\",\n                    \"GROUP_DATA_ACCESS_ADMIN\",\n                    \"GROUP_SEARCH_INDEX_EDITOR\",\n                    \"GROUP_DATA_ACCESS_READ_ONLY\",\n                    \"GROUP_DATA_ACCESS_READ_WRITE\",\n                },\n            },\n        },\n    });\n\n    var roleMapping = Mongodbatlas.GetFederatedSettingsOrgRoleMapping.Invoke(new()\n    {\n        FederationSettingsId = orgGroupRoleMappingImport.Id,\n        OrgId = \"627a9683e7f7f7ff7fe306f14\",\n        RoleMappingId = \"627a9673e7f7f7ff7fe306f14\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\torgGroupRoleMappingImport, err := mongodbatlas.NewFederatedSettingsOrgRoleMapping(ctx, \"org_group_role_mapping_import\", \u0026mongodbatlas.FederatedSettingsOrgRoleMappingArgs{\n\t\t\tFederationSettingsId: pulumi.Any(federatedSettings.Id),\n\t\t\tOrgId:                pulumi.String(\"627a9683e7f7f7ff7fe306f14\"),\n\t\t\tExternalGroupName:    pulumi.String(\"myGrouptest\"),\n\t\t\tRoleAssignments: mongodbatlas.FederatedSettingsOrgRoleMappingRoleAssignmentArray{\n\t\t\t\t\u0026mongodbatlas.FederatedSettingsOrgRoleMappingRoleAssignmentArgs{\n\t\t\t\t\tOrgId: pulumi.String(\"627a9683e7f7f7ff7fe306f14\"),\n\t\t\t\t\tRoles: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"ORG_MEMBER\"),\n\t\t\t\t\t\tpulumi.String(\"ORG_GROUP_CREATOR\"),\n\t\t\t\t\t\tpulumi.String(\"ORG_BILLING_ADMIN\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.FederatedSettingsOrgRoleMappingRoleAssignmentArgs{\n\t\t\t\t\tGroupId: pulumi.String(\"628aa20db7f7f7f98b81b8\"),\n\t\t\t\t\tRoles: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_OWNER\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_ADMIN\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_SEARCH_INDEX_EDITOR\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_READ_ONLY\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.FederatedSettingsOrgRoleMappingRoleAssignmentArgs{\n\t\t\t\t\tGroupId: pulumi.String(\"62b477f7f7f7f5e741489c\"),\n\t\t\t\t\tRoles: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_OWNER\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_ADMIN\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_SEARCH_INDEX_EDITOR\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_READ_ONLY\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_READ_WRITE\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupFederatedSettingsOrgRoleMappingOutput(ctx, mongodbatlas.GetFederatedSettingsOrgRoleMappingOutputArgs{\n\t\t\tFederationSettingsId: orgGroupRoleMappingImport.ID(),\n\t\t\tOrgId:                pulumi.String(\"627a9683e7f7f7ff7fe306f14\"),\n\t\t\tRoleMappingId:        pulumi.String(\"627a9673e7f7f7ff7fe306f14\"),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.FederatedSettingsOrgRoleMapping;\nimport com.pulumi.mongodbatlas.FederatedSettingsOrgRoleMappingArgs;\nimport com.pulumi.mongodbatlas.inputs.FederatedSettingsOrgRoleMappingRoleAssignmentArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetFederatedSettingsOrgRoleMappingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var orgGroupRoleMappingImport = new FederatedSettingsOrgRoleMapping(\"orgGroupRoleMappingImport\", FederatedSettingsOrgRoleMappingArgs.builder()\n            .federationSettingsId(federatedSettings.id())\n            .orgId(\"627a9683e7f7f7ff7fe306f14\")\n            .externalGroupName(\"myGrouptest\")\n            .roleAssignments(            \n                FederatedSettingsOrgRoleMappingRoleAssignmentArgs.builder()\n                    .orgId(\"627a9683e7f7f7ff7fe306f14\")\n                    .roles(                    \n                        \"ORG_MEMBER\",\n                        \"ORG_GROUP_CREATOR\",\n                        \"ORG_BILLING_ADMIN\")\n                    .build(),\n                FederatedSettingsOrgRoleMappingRoleAssignmentArgs.builder()\n                    .groupId(\"628aa20db7f7f7f98b81b8\")\n                    .roles(                    \n                        \"GROUP_OWNER\",\n                        \"GROUP_DATA_ACCESS_ADMIN\",\n                        \"GROUP_SEARCH_INDEX_EDITOR\",\n                        \"GROUP_DATA_ACCESS_READ_ONLY\")\n                    .build(),\n                FederatedSettingsOrgRoleMappingRoleAssignmentArgs.builder()\n                    .groupId(\"62b477f7f7f7f5e741489c\")\n                    .roles(                    \n                        \"GROUP_OWNER\",\n                        \"GROUP_DATA_ACCESS_ADMIN\",\n                        \"GROUP_SEARCH_INDEX_EDITOR\",\n                        \"GROUP_DATA_ACCESS_READ_ONLY\",\n                        \"GROUP_DATA_ACCESS_READ_WRITE\")\n                    .build())\n            .build());\n\n        final var roleMapping = MongodbatlasFunctions.getFederatedSettingsOrgRoleMapping(GetFederatedSettingsOrgRoleMappingArgs.builder()\n            .federationSettingsId(orgGroupRoleMappingImport.id())\n            .orgId(\"627a9683e7f7f7ff7fe306f14\")\n            .roleMappingId(\"627a9673e7f7f7ff7fe306f14\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  orgGroupRoleMappingImport:\n    type: mongodbatlas:FederatedSettingsOrgRoleMapping\n    name: org_group_role_mapping_import\n    properties:\n      federationSettingsId: ${federatedSettings.id}\n      orgId: 627a9683e7f7f7ff7fe306f14\n      externalGroupName: myGrouptest\n      roleAssignments:\n        - orgId: 627a9683e7f7f7ff7fe306f14\n          roles:\n            - ORG_MEMBER\n            - ORG_GROUP_CREATOR\n            - ORG_BILLING_ADMIN\n        - groupId: 628aa20db7f7f7f98b81b8\n          roles:\n            - GROUP_OWNER\n            - GROUP_DATA_ACCESS_ADMIN\n            - GROUP_SEARCH_INDEX_EDITOR\n            - GROUP_DATA_ACCESS_READ_ONLY\n        - groupId: 62b477f7f7f7f5e741489c\n          roles:\n            - GROUP_OWNER\n            - GROUP_DATA_ACCESS_ADMIN\n            - GROUP_SEARCH_INDEX_EDITOR\n            - GROUP_DATA_ACCESS_READ_ONLY\n            - GROUP_DATA_ACCESS_READ_WRITE\nvariables:\n  roleMapping:\n    fn::invoke:\n      Function: mongodbatlas:getFederatedSettingsOrgRoleMapping\n      Arguments:\n        federationSettingsId: ${orgGroupRoleMappingImport.id}\n        orgId: 627a9683e7f7f7ff7fe306f14\n        roleMappingId: 627a9673e7f7f7ff7fe306f14\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getFederatedSettingsOrgRoleMapping.\n",
                "properties": {
                    "federationSettingsId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                    },
                    "roleMappingId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "federationSettingsId",
                    "orgId",
                    "roleMappingId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getFederatedSettingsOrgRoleMapping.\n",
                "properties": {
                    "externalGroupName": {
                        "description": "Unique human-readable label that identifies the identity provider group to which this role mapping applies.\n",
                        "type": "string"
                    },
                    "federationSettingsId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "Unique 24-hexadecimal digit string that identifies this role mapping.\n",
                        "type": "string"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "roleAssignments": {
                        "description": "Atlas roles and the unique identifiers of the groups and organizations associated with each role.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getFederatedSettingsOrgRoleMappingRoleAssignment:getFederatedSettingsOrgRoleMappingRoleAssignment"
                        },
                        "type": "array"
                    },
                    "roleMappingId": {
                        "type": "string"
                    }
                },
                "required": [
                    "externalGroupName",
                    "federationSettingsId",
                    "id",
                    "orgId",
                    "roleAssignments",
                    "roleMappingId"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getFederatedSettingsOrgRoleMappings:getFederatedSettingsOrgRoleMappings": {
            "description": "## # Data Source: mongodbatlas.getFederatedSettingsOrgRoleMappings\n\n`mongodbatlas.getFederatedSettingsOrgRoleMappings` provides an Federated Settings Org Role Mapping datasource. Atlas Cloud Federated Settings Org Role Mapping provides federated settings outputs for the configured Org Role Mapping.\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nresources:\n  orgGroupRoleMappingImport:\n    type: mongodbatlas:FederatedSettingsOrgRoleMapping\n    name: org_group_role_mapping_import\n    properties:\n      federationSettingsId:\n      orgId: 627a9683e7f7f7ff7fe306f14\n      groupId: 628aa20d7f7f7f7f7098b81b8\n      externalGroupName: myGrouptest\n      organizationRoles:\n        - ORG_OWNER\n        - ORG_MEMBER\n        - ORG_BILLING_ADMIN\n        - ORG_GROUP_CREATOR\n        - ORG_READ_ONLY\n      groupRoles:\n        - GROUP_OWNER\n        - GROUP_CLUSTER_MANAGER\n        - GROUP_DATA_ACCESS_ADMIN\n        - GROUP_DATA_ACCESS_READ_WRITE\n        - GROUP_SEARCH_INDEX_EDITOR\n        - GROUP_DATA_ACCESS_READ_ONLY\n        - GROUP_READ_ONLY\nvariables:\n  roleMappings:\n    fn::invoke:\n      Function: mongodbatlas:getFederatedSettingsOrgRoleMappings\n      Arguments:\n        federationSettingsId: ${orgGroupRoleMappingImport.id}\n        orgId: 627a9683e7f7f7ff7fe306f14\n        pageNum: 1\n        itemsPerPage: 5\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getFederatedSettingsOrgRoleMappings.\n",
                "properties": {
                    "federationSettingsId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the federated authentication configuration.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer",
                        "description": "Number of items to return per page, up to a maximum of 500. Defaults to `100`.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the organization that contains your projects.\n"
                    },
                    "pageNum": {
                        "type": "integer",
                        "description": "The page to return. Defaults to `1`.\n"
                    }
                },
                "type": "object",
                "required": [
                    "federationSettingsId",
                    "orgId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getFederatedSettingsOrgRoleMappings.\n",
                "properties": {
                    "federationSettingsId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "results": {
                        "description": "Includes cloudProviderSnapshot object for each item detailed in the results array section.\n* `totalCount` - Count of the total number of items in the result set. It may be greater than the number of objects in the results array if the entire result set is paginated.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getFederatedSettingsOrgRoleMappingsResult:getFederatedSettingsOrgRoleMappingsResult"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "federationSettingsId",
                    "orgId",
                    "results",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getGlobalClusterConfig:getGlobalClusterConfig": {
            "description": "## # Data Source: mongodbatlas.GlobalClusterConfig\n\n`mongodbatlas.GlobalClusterConfig` describes all managed namespaces and custom zone mappings associated with the specified Global Cluster.\n\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.AdvancedCluster(\"test\", {\n    projectId: \"\u003cYOUR-PROJECT-ID\u003e\",\n    name: \"\u003cCLUSTER-NAME\u003e\",\n    clusterType: \"GEOSHARDED\",\n    backupEnabled: true,\n    replicationSpecs: [\n        {\n            zoneName: \"Zone 1\",\n            regionConfigs: [{\n                electableSpecs: {\n                    instanceSize: \"M30\",\n                    nodeCount: 3,\n                },\n                providerName: \"AWS\",\n                priority: 7,\n                regionName: \"EU_CENTRAL_1\",\n            }],\n        },\n        {\n            zoneName: \"Zone 1\",\n            regionConfigs: [{\n                electableSpecs: {\n                    instanceSize: \"M30\",\n                    nodeCount: 3,\n                },\n                providerName: \"AWS\",\n                priority: 7,\n                regionName: \"EU_CENTRAL_1\",\n            }],\n        },\n        {\n            zoneName: \"Zone 2\",\n            regionConfigs: [{\n                electableSpecs: {\n                    instanceSize: \"M30\",\n                    nodeCount: 3,\n                },\n                providerName: \"AWS\",\n                priority: 7,\n                regionName: \"US_EAST_2\",\n            }],\n        },\n        {\n            zoneName: \"Zone 2\",\n            regionConfigs: [{\n                electableSpecs: {\n                    instanceSize: \"M30\",\n                    nodeCount: 3,\n                },\n                providerName: \"AWS\",\n                priority: 7,\n                regionName: \"US_EAST_2\",\n            }],\n        },\n    ],\n});\nconst configGlobalClusterConfig = new mongodbatlas.GlobalClusterConfig(\"config\", {\n    projectId: test.projectId,\n    clusterName: test.name,\n    managedNamespaces: [{\n        db: \"mydata\",\n        collection: \"publishers\",\n        customShardKey: \"city\",\n    }],\n    customZoneMappings: [{\n        location: \"CA\",\n        zone: \"Zone 1\",\n    }],\n});\nconst config = mongodbatlas.getGlobalClusterConfigOutput({\n    projectId: configGlobalClusterConfig.projectId,\n    clusterName: configGlobalClusterConfig.clusterName,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.AdvancedCluster(\"test\",\n    project_id=\"\u003cYOUR-PROJECT-ID\u003e\",\n    name=\"\u003cCLUSTER-NAME\u003e\",\n    cluster_type=\"GEOSHARDED\",\n    backup_enabled=True,\n    replication_specs=[\n        {\n            \"zone_name\": \"Zone 1\",\n            \"region_configs\": [{\n                \"electable_specs\": {\n                    \"instance_size\": \"M30\",\n                    \"node_count\": 3,\n                },\n                \"provider_name\": \"AWS\",\n                \"priority\": 7,\n                \"region_name\": \"EU_CENTRAL_1\",\n            }],\n        },\n        {\n            \"zone_name\": \"Zone 1\",\n            \"region_configs\": [{\n                \"electable_specs\": {\n                    \"instance_size\": \"M30\",\n                    \"node_count\": 3,\n                },\n                \"provider_name\": \"AWS\",\n                \"priority\": 7,\n                \"region_name\": \"EU_CENTRAL_1\",\n            }],\n        },\n        {\n            \"zone_name\": \"Zone 2\",\n            \"region_configs\": [{\n                \"electable_specs\": {\n                    \"instance_size\": \"M30\",\n                    \"node_count\": 3,\n                },\n                \"provider_name\": \"AWS\",\n                \"priority\": 7,\n                \"region_name\": \"US_EAST_2\",\n            }],\n        },\n        {\n            \"zone_name\": \"Zone 2\",\n            \"region_configs\": [{\n                \"electable_specs\": {\n                    \"instance_size\": \"M30\",\n                    \"node_count\": 3,\n                },\n                \"provider_name\": \"AWS\",\n                \"priority\": 7,\n                \"region_name\": \"US_EAST_2\",\n            }],\n        },\n    ])\nconfig_global_cluster_config = mongodbatlas.GlobalClusterConfig(\"config\",\n    project_id=test.project_id,\n    cluster_name=test.name,\n    managed_namespaces=[{\n        \"db\": \"mydata\",\n        \"collection\": \"publishers\",\n        \"custom_shard_key\": \"city\",\n    }],\n    custom_zone_mappings=[{\n        \"location\": \"CA\",\n        \"zone\": \"Zone 1\",\n    }])\nconfig = mongodbatlas.get_global_cluster_config_output(project_id=config_global_cluster_config.project_id,\n    cluster_name=config_global_cluster_config.cluster_name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.AdvancedCluster(\"test\", new()\n    {\n        ProjectId = \"\u003cYOUR-PROJECT-ID\u003e\",\n        Name = \"\u003cCLUSTER-NAME\u003e\",\n        ClusterType = \"GEOSHARDED\",\n        BackupEnabled = true,\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                ZoneName = \"Zone 1\",\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M30\",\n                            NodeCount = 3,\n                        },\n                        ProviderName = \"AWS\",\n                        Priority = 7,\n                        RegionName = \"EU_CENTRAL_1\",\n                    },\n                },\n            },\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                ZoneName = \"Zone 1\",\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M30\",\n                            NodeCount = 3,\n                        },\n                        ProviderName = \"AWS\",\n                        Priority = 7,\n                        RegionName = \"EU_CENTRAL_1\",\n                    },\n                },\n            },\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                ZoneName = \"Zone 2\",\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M30\",\n                            NodeCount = 3,\n                        },\n                        ProviderName = \"AWS\",\n                        Priority = 7,\n                        RegionName = \"US_EAST_2\",\n                    },\n                },\n            },\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                ZoneName = \"Zone 2\",\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M30\",\n                            NodeCount = 3,\n                        },\n                        ProviderName = \"AWS\",\n                        Priority = 7,\n                        RegionName = \"US_EAST_2\",\n                    },\n                },\n            },\n        },\n    });\n\n    var configGlobalClusterConfig = new Mongodbatlas.GlobalClusterConfig(\"config\", new()\n    {\n        ProjectId = test.ProjectId,\n        ClusterName = test.Name,\n        ManagedNamespaces = new[]\n        {\n            new Mongodbatlas.Inputs.GlobalClusterConfigManagedNamespaceArgs\n            {\n                Db = \"mydata\",\n                Collection = \"publishers\",\n                CustomShardKey = \"city\",\n            },\n        },\n        CustomZoneMappings = new[]\n        {\n            new Mongodbatlas.Inputs.GlobalClusterConfigCustomZoneMappingArgs\n            {\n                Location = \"CA\",\n                Zone = \"Zone 1\",\n            },\n        },\n    });\n\n    var config = Mongodbatlas.GetGlobalClusterConfig.Invoke(new()\n    {\n        ProjectId = configGlobalClusterConfig.ProjectId,\n        ClusterName = configGlobalClusterConfig.ClusterName,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := mongodbatlas.NewAdvancedCluster(ctx, \"test\", \u0026mongodbatlas.AdvancedClusterArgs{\n\t\t\tProjectId:     pulumi.String(\"\u003cYOUR-PROJECT-ID\u003e\"),\n\t\t\tName:          pulumi.String(\"\u003cCLUSTER-NAME\u003e\"),\n\t\t\tClusterType:   pulumi.String(\"GEOSHARDED\"),\n\t\t\tBackupEnabled: pulumi.Bool(true),\n\t\t\tReplicationSpecs: mongodbatlas.AdvancedClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tZoneName: pulumi.String(\"Zone 1\"),\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M30\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(3),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tPriority:     pulumi.Int(7),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"EU_CENTRAL_1\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tZoneName: pulumi.String(\"Zone 1\"),\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M30\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(3),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tPriority:     pulumi.Int(7),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"EU_CENTRAL_1\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tZoneName: pulumi.String(\"Zone 2\"),\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M30\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(3),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tPriority:     pulumi.Int(7),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"US_EAST_2\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tZoneName: pulumi.String(\"Zone 2\"),\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M30\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(3),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tPriority:     pulumi.Int(7),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"US_EAST_2\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tconfigGlobalClusterConfig, err := mongodbatlas.NewGlobalClusterConfig(ctx, \"config\", \u0026mongodbatlas.GlobalClusterConfigArgs{\n\t\t\tProjectId:   test.ProjectId,\n\t\t\tClusterName: test.Name,\n\t\t\tManagedNamespaces: mongodbatlas.GlobalClusterConfigManagedNamespaceArray{\n\t\t\t\t\u0026mongodbatlas.GlobalClusterConfigManagedNamespaceArgs{\n\t\t\t\t\tDb:             pulumi.String(\"mydata\"),\n\t\t\t\t\tCollection:     pulumi.String(\"publishers\"),\n\t\t\t\t\tCustomShardKey: pulumi.String(\"city\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tCustomZoneMappings: mongodbatlas.GlobalClusterConfigCustomZoneMappingArray{\n\t\t\t\t\u0026mongodbatlas.GlobalClusterConfigCustomZoneMappingArgs{\n\t\t\t\t\tLocation: pulumi.String(\"CA\"),\n\t\t\t\t\tZone:     pulumi.String(\"Zone 1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupGlobalClusterConfigOutput(ctx, mongodbatlas.GetGlobalClusterConfigOutputArgs{\n\t\t\tProjectId:   configGlobalClusterConfig.ProjectId,\n\t\t\tClusterName: configGlobalClusterConfig.ClusterName,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.AdvancedCluster;\nimport com.pulumi.mongodbatlas.AdvancedClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.AdvancedClusterReplicationSpecArgs;\nimport com.pulumi.mongodbatlas.GlobalClusterConfig;\nimport com.pulumi.mongodbatlas.GlobalClusterConfigArgs;\nimport com.pulumi.mongodbatlas.inputs.GlobalClusterConfigManagedNamespaceArgs;\nimport com.pulumi.mongodbatlas.inputs.GlobalClusterConfigCustomZoneMappingArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetGlobalClusterConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new AdvancedCluster(\"test\", AdvancedClusterArgs.builder()\n            .projectId(\"\u003cYOUR-PROJECT-ID\u003e\")\n            .name(\"\u003cCLUSTER-NAME\u003e\")\n            .clusterType(\"GEOSHARDED\")\n            .backupEnabled(true)\n            .replicationSpecs(            \n                AdvancedClusterReplicationSpecArgs.builder()\n                    .zoneName(\"Zone 1\")\n                    .regionConfigs(AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                        .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                            .instanceSize(\"M30\")\n                            .nodeCount(3)\n                            .build())\n                        .providerName(\"AWS\")\n                        .priority(7)\n                        .regionName(\"EU_CENTRAL_1\")\n                        .build())\n                    .build(),\n                AdvancedClusterReplicationSpecArgs.builder()\n                    .zoneName(\"Zone 1\")\n                    .regionConfigs(AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                        .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                            .instanceSize(\"M30\")\n                            .nodeCount(3)\n                            .build())\n                        .providerName(\"AWS\")\n                        .priority(7)\n                        .regionName(\"EU_CENTRAL_1\")\n                        .build())\n                    .build(),\n                AdvancedClusterReplicationSpecArgs.builder()\n                    .zoneName(\"Zone 2\")\n                    .regionConfigs(AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                        .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                            .instanceSize(\"M30\")\n                            .nodeCount(3)\n                            .build())\n                        .providerName(\"AWS\")\n                        .priority(7)\n                        .regionName(\"US_EAST_2\")\n                        .build())\n                    .build(),\n                AdvancedClusterReplicationSpecArgs.builder()\n                    .zoneName(\"Zone 2\")\n                    .regionConfigs(AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                        .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                            .instanceSize(\"M30\")\n                            .nodeCount(3)\n                            .build())\n                        .providerName(\"AWS\")\n                        .priority(7)\n                        .regionName(\"US_EAST_2\")\n                        .build())\n                    .build())\n            .build());\n\n        var configGlobalClusterConfig = new GlobalClusterConfig(\"configGlobalClusterConfig\", GlobalClusterConfigArgs.builder()\n            .projectId(test.projectId())\n            .clusterName(test.name())\n            .managedNamespaces(GlobalClusterConfigManagedNamespaceArgs.builder()\n                .db(\"mydata\")\n                .collection(\"publishers\")\n                .customShardKey(\"city\")\n                .build())\n            .customZoneMappings(GlobalClusterConfigCustomZoneMappingArgs.builder()\n                .location(\"CA\")\n                .zone(\"Zone 1\")\n                .build())\n            .build());\n\n        final var config = MongodbatlasFunctions.getGlobalClusterConfig(GetGlobalClusterConfigArgs.builder()\n            .projectId(configGlobalClusterConfig.projectId())\n            .clusterName(configGlobalClusterConfig.clusterName())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:AdvancedCluster\n    properties:\n      projectId: \u003cYOUR-PROJECT-ID\u003e\n      name: \u003cCLUSTER-NAME\u003e\n      clusterType: GEOSHARDED\n      backupEnabled: true\n      replicationSpecs:\n        - zoneName: Zone 1\n          regionConfigs:\n            - electableSpecs:\n                instanceSize: M30\n                nodeCount: 3\n              providerName: AWS\n              priority: 7\n              regionName: EU_CENTRAL_1\n        - zoneName: Zone 1\n          regionConfigs:\n            - electableSpecs:\n                instanceSize: M30\n                nodeCount: 3\n              providerName: AWS\n              priority: 7\n              regionName: EU_CENTRAL_1\n        - zoneName: Zone 2\n          regionConfigs:\n            - electableSpecs:\n                instanceSize: M30\n                nodeCount: 3\n              providerName: AWS\n              priority: 7\n              regionName: US_EAST_2\n        - zoneName: Zone 2\n          regionConfigs:\n            - electableSpecs:\n                instanceSize: M30\n                nodeCount: 3\n              providerName: AWS\n              priority: 7\n              regionName: US_EAST_2\n  configGlobalClusterConfig:\n    type: mongodbatlas:GlobalClusterConfig\n    name: config\n    properties:\n      projectId: ${test.projectId}\n      clusterName: ${test.name}\n      managedNamespaces:\n        - db: mydata\n          collection: publishers\n          customShardKey: city\n      customZoneMappings:\n        - location: CA\n          zone: Zone 1\nvariables:\n  config:\n    fn::invoke:\n      Function: mongodbatlas:getGlobalClusterConfig\n      Arguments:\n        projectId: ${configGlobalClusterConfig.projectId}\n        clusterName: ${configGlobalClusterConfig.clusterName}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getGlobalClusterConfig.\n",
                "properties": {
                    "clusterName": {
                        "type": "string"
                    },
                    "managedNamespaces": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getGlobalClusterConfigManagedNamespace:getGlobalClusterConfigManagedNamespace"
                        },
                        "description": "Add a managed namespaces to a Global Cluster. For more information about managed namespaces, see [Global Clusters](https://docs.atlas.mongodb.com/reference/api/global-clusters/). See Managed Namespace below for more details.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the database user.\n* `cluster_name - (Required) The name of the Global Cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getGlobalClusterConfig.\n",
                "properties": {
                    "clusterName": {
                        "type": "string"
                    },
                    "customZoneMapping": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of all custom zone mappings defined for the Global Cluster. Atlas automatically maps each location code to the closest geographical zone. Custom zone mappings allow administrators to override these automatic mappings. If your Global Cluster does not have any custom zone mappings, this document is empty.\n",
                        "type": "object"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "managedNamespaces": {
                        "description": "Add a managed namespaces to a Global Cluster. For more information about managed namespaces, see [Global Clusters](https://docs.atlas.mongodb.com/reference/api/global-clusters/). See Managed Namespace below for more details.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getGlobalClusterConfigManagedNamespace:getGlobalClusterConfigManagedNamespace"
                        },
                        "type": "array"
                    },
                    "projectId": {
                        "type": "string"
                    }
                },
                "required": [
                    "clusterName",
                    "customZoneMapping",
                    "managedNamespaces",
                    "projectId",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getLdapConfiguration:getLdapConfiguration": {
            "description": "## # Data Source: mongodbatlas.LdapConfiguration\n\n`mongodbatlas.LdapConfiguration` describes a LDAP Configuration.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find **group_id** in the official documentation.\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testProject = new mongodbatlas.Project(\"test\", {\n    name: \"NAME OF THE PROJECT\",\n    orgId: \"ORG ID\",\n});\nconst testLdapConfiguration = new mongodbatlas.LdapConfiguration(\"test\", {\n    projectId: testProject.id,\n    authenticationEnabled: true,\n    hostname: \"HOSTNAME\",\n    port: 636,\n    bindUsername: \"USERNAME\",\n    bindPassword: \"PASSWORD\",\n});\nconst test = mongodbatlas.getLdapConfigurationOutput({\n    projectId: testLdapConfiguration.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_project = mongodbatlas.Project(\"test\",\n    name=\"NAME OF THE PROJECT\",\n    org_id=\"ORG ID\")\ntest_ldap_configuration = mongodbatlas.LdapConfiguration(\"test\",\n    project_id=test_project.id,\n    authentication_enabled=True,\n    hostname=\"HOSTNAME\",\n    port=636,\n    bind_username=\"USERNAME\",\n    bind_password=\"PASSWORD\")\ntest = mongodbatlas.get_ldap_configuration_output(project_id=test_ldap_configuration.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testProject = new Mongodbatlas.Project(\"test\", new()\n    {\n        Name = \"NAME OF THE PROJECT\",\n        OrgId = \"ORG ID\",\n    });\n\n    var testLdapConfiguration = new Mongodbatlas.LdapConfiguration(\"test\", new()\n    {\n        ProjectId = testProject.Id,\n        AuthenticationEnabled = true,\n        Hostname = \"HOSTNAME\",\n        Port = 636,\n        BindUsername = \"USERNAME\",\n        BindPassword = \"PASSWORD\",\n    });\n\n    var test = Mongodbatlas.GetLdapConfiguration.Invoke(new()\n    {\n        ProjectId = testLdapConfiguration.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestProject, err := mongodbatlas.NewProject(ctx, \"test\", \u0026mongodbatlas.ProjectArgs{\n\t\t\tName:  pulumi.String(\"NAME OF THE PROJECT\"),\n\t\t\tOrgId: pulumi.String(\"ORG ID\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestLdapConfiguration, err := mongodbatlas.NewLdapConfiguration(ctx, \"test\", \u0026mongodbatlas.LdapConfigurationArgs{\n\t\t\tProjectId:             testProject.ID(),\n\t\t\tAuthenticationEnabled: pulumi.Bool(true),\n\t\t\tHostname:              pulumi.String(\"HOSTNAME\"),\n\t\t\tPort:                  pulumi.Int(636),\n\t\t\tBindUsername:          pulumi.String(\"USERNAME\"),\n\t\t\tBindPassword:          pulumi.String(\"PASSWORD\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupLdapConfigurationOutput(ctx, mongodbatlas.GetLdapConfigurationOutputArgs{\n\t\t\tProjectId: testLdapConfiguration.ID(),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Project;\nimport com.pulumi.mongodbatlas.ProjectArgs;\nimport com.pulumi.mongodbatlas.LdapConfiguration;\nimport com.pulumi.mongodbatlas.LdapConfigurationArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetLdapConfigurationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testProject = new Project(\"testProject\", ProjectArgs.builder()\n            .name(\"NAME OF THE PROJECT\")\n            .orgId(\"ORG ID\")\n            .build());\n\n        var testLdapConfiguration = new LdapConfiguration(\"testLdapConfiguration\", LdapConfigurationArgs.builder()\n            .projectId(testProject.id())\n            .authenticationEnabled(true)\n            .hostname(\"HOSTNAME\")\n            .port(636)\n            .bindUsername(\"USERNAME\")\n            .bindPassword(\"PASSWORD\")\n            .build());\n\n        final var test = MongodbatlasFunctions.getLdapConfiguration(GetLdapConfigurationArgs.builder()\n            .projectId(testLdapConfiguration.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testProject:\n    type: mongodbatlas:Project\n    name: test\n    properties:\n      name: NAME OF THE PROJECT\n      orgId: ORG ID\n  testLdapConfiguration:\n    type: mongodbatlas:LdapConfiguration\n    name: test\n    properties:\n      projectId: ${testProject.id}\n      authenticationEnabled: true\n      hostname: HOSTNAME\n      port: 636\n      bindUsername: USERNAME\n      bindPassword: PASSWORD\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getLdapConfiguration\n      Arguments:\n        projectId: ${testLdapConfiguration.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getLdapConfiguration.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "Identifier for the Atlas project associated with the LDAP over TLS/SSL configuration.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getLdapConfiguration.\n",
                "properties": {
                    "authenticationEnabled": {
                        "description": "Specifies whether user authentication with LDAP is enabled.\n",
                        "type": "boolean"
                    },
                    "authorizationEnabled": {
                        "description": "Specifies whether user authorization with LDAP is enabled.\n",
                        "type": "boolean"
                    },
                    "authzQueryTemplate": {
                        "description": "An LDAP query template that Atlas executes to obtain the LDAP groups to which the authenticated user belongs.\n",
                        "type": "string"
                    },
                    "bindPassword": {
                        "description": "The password used to authenticate the `bind_username`.\n",
                        "type": "string"
                    },
                    "bindUsername": {
                        "description": "The user DN that Atlas uses to connect to the LDAP server.\n",
                        "type": "string"
                    },
                    "caCertificate": {
                        "description": "CA certificate used to verify the identify of the LDAP server.\n",
                        "type": "string"
                    },
                    "hostname": {
                        "description": "(Required) The hostname or IP address of the LDAP server.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "port": {
                        "description": "The port to which the LDAP server listens for client connections.\n",
                        "type": "integer"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "userToDnMappings": {
                        "description": "Maps an LDAP username for authentication to an LDAP Distinguished Name (DN).\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getLdapConfigurationUserToDnMapping:getLdapConfigurationUserToDnMapping"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "authenticationEnabled",
                    "authorizationEnabled",
                    "authzQueryTemplate",
                    "bindPassword",
                    "bindUsername",
                    "caCertificate",
                    "hostname",
                    "port",
                    "projectId",
                    "userToDnMappings",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getLdapVerify:getLdapVerify": {
            "description": "## # Data Source: mongodbatlas.LdapVerify\n\n`mongodbatlas.LdapVerify` describes a LDAP Verify.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find **group_id** in the official documentation.\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testProject = new mongodbatlas.Project(\"test\", {\n    name: \"NAME OF THE PROJECT\",\n    orgId: \"ORG ID\",\n});\nconst testAdvancedCluster = new mongodbatlas.AdvancedCluster(\"test\", {\n    projectId: testProject.id,\n    name: \"ClusterName\",\n    clusterType: \"REPLICASET\",\n    backupEnabled: true,\n    replicationSpecs: [{\n        regionConfigs: [{\n            priority: 7,\n            providerName: \"AWS\",\n            regionName: \"US_EAST_1\",\n            electableSpecs: {\n                instanceSize: \"M10\",\n                nodeCount: 3,\n            },\n        }],\n    }],\n});\nconst testLdapVerify = new mongodbatlas.LdapVerify(\"test\", {\n    projectId: testProject.id,\n    hostname: \"HOSTNAME\",\n    port: 636,\n    bindUsername: \"USERNAME\",\n    bindPassword: \"PASSWORD\",\n}, {\n    dependsOn: [testAdvancedCluster],\n});\nconst test = mongodbatlas.getLdapVerifyOutput({\n    projectId: testLdapVerify.projectId,\n    requestId: testLdapVerify.requestId,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_project = mongodbatlas.Project(\"test\",\n    name=\"NAME OF THE PROJECT\",\n    org_id=\"ORG ID\")\ntest_advanced_cluster = mongodbatlas.AdvancedCluster(\"test\",\n    project_id=test_project.id,\n    name=\"ClusterName\",\n    cluster_type=\"REPLICASET\",\n    backup_enabled=True,\n    replication_specs=[{\n        \"region_configs\": [{\n            \"priority\": 7,\n            \"provider_name\": \"AWS\",\n            \"region_name\": \"US_EAST_1\",\n            \"electable_specs\": {\n                \"instance_size\": \"M10\",\n                \"node_count\": 3,\n            },\n        }],\n    }])\ntest_ldap_verify = mongodbatlas.LdapVerify(\"test\",\n    project_id=test_project.id,\n    hostname=\"HOSTNAME\",\n    port=636,\n    bind_username=\"USERNAME\",\n    bind_password=\"PASSWORD\",\n    opts = pulumi.ResourceOptions(depends_on=[test_advanced_cluster]))\ntest = mongodbatlas.get_ldap_verify_output(project_id=test_ldap_verify.project_id,\n    request_id=test_ldap_verify.request_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testProject = new Mongodbatlas.Project(\"test\", new()\n    {\n        Name = \"NAME OF THE PROJECT\",\n        OrgId = \"ORG ID\",\n    });\n\n    var testAdvancedCluster = new Mongodbatlas.AdvancedCluster(\"test\", new()\n    {\n        ProjectId = testProject.Id,\n        Name = \"ClusterName\",\n        ClusterType = \"REPLICASET\",\n        BackupEnabled = true,\n        ReplicationSpecs = new[]\n        {\n            new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecArgs\n            {\n                RegionConfigs = new[]\n                {\n                    new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigArgs\n                    {\n                        Priority = 7,\n                        ProviderName = \"AWS\",\n                        RegionName = \"US_EAST_1\",\n                        ElectableSpecs = new Mongodbatlas.Inputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs\n                        {\n                            InstanceSize = \"M10\",\n                            NodeCount = 3,\n                        },\n                    },\n                },\n            },\n        },\n    });\n\n    var testLdapVerify = new Mongodbatlas.LdapVerify(\"test\", new()\n    {\n        ProjectId = testProject.Id,\n        Hostname = \"HOSTNAME\",\n        Port = 636,\n        BindUsername = \"USERNAME\",\n        BindPassword = \"PASSWORD\",\n    }, new CustomResourceOptions\n    {\n        DependsOn =\n        {\n            testAdvancedCluster,\n        },\n    });\n\n    var test = Mongodbatlas.GetLdapVerify.Invoke(new()\n    {\n        ProjectId = testLdapVerify.ProjectId,\n        RequestId = testLdapVerify.RequestId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestProject, err := mongodbatlas.NewProject(ctx, \"test\", \u0026mongodbatlas.ProjectArgs{\n\t\t\tName:  pulumi.String(\"NAME OF THE PROJECT\"),\n\t\t\tOrgId: pulumi.String(\"ORG ID\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestAdvancedCluster, err := mongodbatlas.NewAdvancedCluster(ctx, \"test\", \u0026mongodbatlas.AdvancedClusterArgs{\n\t\t\tProjectId:     testProject.ID(),\n\t\t\tName:          pulumi.String(\"ClusterName\"),\n\t\t\tClusterType:   pulumi.String(\"REPLICASET\"),\n\t\t\tBackupEnabled: pulumi.Bool(true),\n\t\t\tReplicationSpecs: mongodbatlas.AdvancedClusterReplicationSpecArray{\n\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecArgs{\n\t\t\t\t\tRegionConfigs: mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArray{\n\t\t\t\t\t\t\u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigArgs{\n\t\t\t\t\t\t\tPriority:     pulumi.Int(7),\n\t\t\t\t\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\t\t\t\t\tRegionName:   pulumi.String(\"US_EAST_1\"),\n\t\t\t\t\t\t\tElectableSpecs: \u0026mongodbatlas.AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs{\n\t\t\t\t\t\t\t\tInstanceSize: pulumi.String(\"M10\"),\n\t\t\t\t\t\t\t\tNodeCount:    pulumi.Int(3),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestLdapVerify, err := mongodbatlas.NewLdapVerify(ctx, \"test\", \u0026mongodbatlas.LdapVerifyArgs{\n\t\t\tProjectId:    testProject.ID(),\n\t\t\tHostname:     pulumi.String(\"HOSTNAME\"),\n\t\t\tPort:         pulumi.Int(636),\n\t\t\tBindUsername: pulumi.String(\"USERNAME\"),\n\t\t\tBindPassword: pulumi.String(\"PASSWORD\"),\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\ttestAdvancedCluster,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupLdapVerifyOutput(ctx, mongodbatlas.GetLdapVerifyOutputArgs{\n\t\t\tProjectId: testLdapVerify.ProjectId,\n\t\t\tRequestId: testLdapVerify.RequestId,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Project;\nimport com.pulumi.mongodbatlas.ProjectArgs;\nimport com.pulumi.mongodbatlas.AdvancedCluster;\nimport com.pulumi.mongodbatlas.AdvancedClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.AdvancedClusterReplicationSpecArgs;\nimport com.pulumi.mongodbatlas.LdapVerify;\nimport com.pulumi.mongodbatlas.LdapVerifyArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetLdapVerifyArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testProject = new Project(\"testProject\", ProjectArgs.builder()\n            .name(\"NAME OF THE PROJECT\")\n            .orgId(\"ORG ID\")\n            .build());\n\n        var testAdvancedCluster = new AdvancedCluster(\"testAdvancedCluster\", AdvancedClusterArgs.builder()\n            .projectId(testProject.id())\n            .name(\"ClusterName\")\n            .clusterType(\"REPLICASET\")\n            .backupEnabled(true)\n            .replicationSpecs(AdvancedClusterReplicationSpecArgs.builder()\n                .regionConfigs(AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                    .priority(7)\n                    .providerName(\"AWS\")\n                    .regionName(\"US_EAST_1\")\n                    .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                        .instanceSize(\"M10\")\n                        .nodeCount(3)\n                        .build())\n                    .build())\n                .build())\n            .build());\n\n        var testLdapVerify = new LdapVerify(\"testLdapVerify\", LdapVerifyArgs.builder()\n            .projectId(testProject.id())\n            .hostname(\"HOSTNAME\")\n            .port(636)\n            .bindUsername(\"USERNAME\")\n            .bindPassword(\"PASSWORD\")\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(testAdvancedCluster)\n                .build());\n\n        final var test = MongodbatlasFunctions.getLdapVerify(GetLdapVerifyArgs.builder()\n            .projectId(testLdapVerify.projectId())\n            .requestId(testLdapVerify.requestId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testProject:\n    type: mongodbatlas:Project\n    name: test\n    properties:\n      name: NAME OF THE PROJECT\n      orgId: ORG ID\n  testAdvancedCluster:\n    type: mongodbatlas:AdvancedCluster\n    name: test\n    properties:\n      projectId: ${testProject.id}\n      name: ClusterName\n      clusterType: REPLICASET\n      backupEnabled: true # enable cloud provider snapshots\n      replicationSpecs:\n        - regionConfigs:\n            - priority: 7\n              providerName: AWS\n              regionName: US_EAST_1\n              electableSpecs:\n                instanceSize: M10\n                nodeCount: 3\n  testLdapVerify:\n    type: mongodbatlas:LdapVerify\n    name: test\n    properties:\n      projectId: ${testProject.id}\n      hostname: HOSTNAME\n      port: 636\n      bindUsername: USERNAME\n      bindPassword: PASSWORD\n    options:\n      dependson:\n        - ${testAdvancedCluster}\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getLdapVerify\n      Arguments:\n        projectId: ${testLdapVerify.projectId}\n        requestId: ${testLdapVerify.requestId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getLdapVerify.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "Unique identifier for the Atlas project associated with the verification request.\n"
                    },
                    "requestId": {
                        "type": "string",
                        "description": "Unique identifier of a request to verify an LDAP configuration.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId",
                    "requestId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getLdapVerify.\n",
                "properties": {
                    "bindUsername": {
                        "description": "The user DN that Atlas uses to connect to the LDAP server.\n",
                        "type": "string"
                    },
                    "hostname": {
                        "description": "(Required) The hostname or IP address of the LDAP server.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "links": {
                        "description": "One or more links to sub-resources. The relations in the URLs are explained in the Web Linking Specification.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getLdapVerifyLink:getLdapVerifyLink"
                        },
                        "type": "array"
                    },
                    "port": {
                        "description": "LDAP ConfigurationThe port to which the LDAP server listens for client connections.\n",
                        "type": "integer"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "requestId": {
                        "description": "The unique identifier for the request to verify the LDAP over TLS/SSL configuration.\n",
                        "type": "string"
                    },
                    "status": {
                        "description": "The current status of the LDAP over TLS/SSL configuration.\n",
                        "type": "string"
                    },
                    "validations": {
                        "description": "Array of validation messages related to the verification of the provided LDAP over TLS/SSL configuration details.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getLdapVerifyValidation:getLdapVerifyValidation"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "bindUsername",
                    "hostname",
                    "links",
                    "port",
                    "projectId",
                    "requestId",
                    "status",
                    "validations",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getMaintenanceWindow:getMaintenanceWindow": {
            "description": "## # Data Source: mongodbatlas.MaintenanceWindow\n\n`mongodbatlas.MaintenanceWindow` provides a Maintenance Window entry datasource. Gets information regarding the configured maintenance window for a MongoDB Atlas project.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n## Examples Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testMaintenanceWindow = new mongodbatlas.MaintenanceWindow(\"test\", {\n    projectId: \"\u003cyour-project-id\u003e\",\n    dayOfWeek: 3,\n    hourOfDay: 4,\n    autoDeferOnceEnabled: true,\n});\nconst test = mongodbatlas.getMaintenanceWindowOutput({\n    projectId: testMaintenanceWindow.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_maintenance_window = mongodbatlas.MaintenanceWindow(\"test\",\n    project_id=\"\u003cyour-project-id\u003e\",\n    day_of_week=3,\n    hour_of_day=4,\n    auto_defer_once_enabled=True)\ntest = mongodbatlas.get_maintenance_window_output(project_id=test_maintenance_window.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testMaintenanceWindow = new Mongodbatlas.MaintenanceWindow(\"test\", new()\n    {\n        ProjectId = \"\u003cyour-project-id\u003e\",\n        DayOfWeek = 3,\n        HourOfDay = 4,\n        AutoDeferOnceEnabled = true,\n    });\n\n    var test = Mongodbatlas.GetMaintenanceWindow.Invoke(new()\n    {\n        ProjectId = testMaintenanceWindow.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestMaintenanceWindow, err := mongodbatlas.NewMaintenanceWindow(ctx, \"test\", \u0026mongodbatlas.MaintenanceWindowArgs{\n\t\t\tProjectId:            pulumi.String(\"\u003cyour-project-id\u003e\"),\n\t\t\tDayOfWeek:            pulumi.Int(3),\n\t\t\tHourOfDay:            pulumi.Int(4),\n\t\t\tAutoDeferOnceEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupMaintenanceWindowOutput(ctx, mongodbatlas.GetMaintenanceWindowOutputArgs{\n\t\t\tProjectId: testMaintenanceWindow.ID(),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MaintenanceWindow;\nimport com.pulumi.mongodbatlas.MaintenanceWindowArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetMaintenanceWindowArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testMaintenanceWindow = new MaintenanceWindow(\"testMaintenanceWindow\", MaintenanceWindowArgs.builder()\n            .projectId(\"\u003cyour-project-id\u003e\")\n            .dayOfWeek(3)\n            .hourOfDay(4)\n            .autoDeferOnceEnabled(true)\n            .build());\n\n        final var test = MongodbatlasFunctions.getMaintenanceWindow(GetMaintenanceWindowArgs.builder()\n            .projectId(testMaintenanceWindow.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testMaintenanceWindow:\n    type: mongodbatlas:MaintenanceWindow\n    name: test\n    properties:\n      projectId: \u003cyour-project-id\u003e\n      dayOfWeek: 3\n      hourOfDay: 4\n      autoDeferOnceEnabled: true\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getMaintenanceWindow\n      Arguments:\n        projectId: ${testMaintenanceWindow.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testMaintenanceWindow = new mongodbatlas.MaintenanceWindow(\"test\", {\n    projectId: \"\u003cyour-project-id\u003e\",\n    startAsap: true,\n});\nconst test = mongodbatlas.getMaintenanceWindowOutput({\n    projectId: testMaintenanceWindow.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_maintenance_window = mongodbatlas.MaintenanceWindow(\"test\",\n    project_id=\"\u003cyour-project-id\u003e\",\n    start_asap=True)\ntest = mongodbatlas.get_maintenance_window_output(project_id=test_maintenance_window.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testMaintenanceWindow = new Mongodbatlas.MaintenanceWindow(\"test\", new()\n    {\n        ProjectId = \"\u003cyour-project-id\u003e\",\n        StartAsap = true,\n    });\n\n    var test = Mongodbatlas.GetMaintenanceWindow.Invoke(new()\n    {\n        ProjectId = testMaintenanceWindow.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestMaintenanceWindow, err := mongodbatlas.NewMaintenanceWindow(ctx, \"test\", \u0026mongodbatlas.MaintenanceWindowArgs{\n\t\t\tProjectId: pulumi.String(\"\u003cyour-project-id\u003e\"),\n\t\t\tStartAsap: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupMaintenanceWindowOutput(ctx, mongodbatlas.GetMaintenanceWindowOutputArgs{\n\t\t\tProjectId: testMaintenanceWindow.ID(),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MaintenanceWindow;\nimport com.pulumi.mongodbatlas.MaintenanceWindowArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetMaintenanceWindowArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testMaintenanceWindow = new MaintenanceWindow(\"testMaintenanceWindow\", MaintenanceWindowArgs.builder()\n            .projectId(\"\u003cyour-project-id\u003e\")\n            .startAsap(true)\n            .build());\n\n        final var test = MongodbatlasFunctions.getMaintenanceWindow(GetMaintenanceWindowArgs.builder()\n            .projectId(testMaintenanceWindow.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testMaintenanceWindow:\n    type: mongodbatlas:MaintenanceWindow\n    name: test\n    properties:\n      projectId: \u003cyour-project-id\u003e\n      startAsap: true\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getMaintenanceWindow\n      Arguments:\n        projectId: ${testMaintenanceWindow.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getMaintenanceWindow.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier of the project for the Maintenance Window.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getMaintenanceWindow.\n",
                "properties": {
                    "autoDeferOnceEnabled": {
                        "description": "Flag that indicates whether you want to defer all maintenance windows one week they would be triggered.\nFor more information see: [MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/reference/api/maintenance-windows/)\n",
                        "type": "boolean"
                    },
                    "dayOfWeek": {
                        "description": "Day of the week when you would like the maintenance window to start as a 1-based integer: Su=1, M=2, T=3, W=4, T=5, F=6, Sa=7.\n",
                        "type": "integer"
                    },
                    "hourOfDay": {
                        "description": "Hour of the day when you would like the maintenance window to start. This parameter uses the 24-hour clock, where midnight is 0, noon is 12  (Time zone is UTC).\n",
                        "type": "integer"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "numberOfDeferrals": {
                        "description": "Number of times the current maintenance event for this project has been deferred, there can be a maximum of 2 deferrals.\n",
                        "type": "integer"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "startAsap": {
                        "description": "Flag indicating whether project maintenance has been directed to start immediately. If you request that maintenance begin immediately, this field returns true from the time the request was made until the time the maintenance event completes.\n",
                        "type": "boolean"
                    }
                },
                "required": [
                    "autoDeferOnceEnabled",
                    "dayOfWeek",
                    "hourOfDay",
                    "numberOfDeferrals",
                    "projectId",
                    "startAsap",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getNetworkContainer:getNetworkContainer": {
            "description": "## # Data Source: mongodbatlas.NetworkContainer\n\n`mongodbatlas.NetworkContainer` describes a Network Peering Container. The resource requires your Project ID and container ID.\n\n\u003e **IMPORTANT:** This resource creates one Network Peering container into which Atlas can deploy Network Peering connections. An Atlas project can have a maximum of one container for each cloud provider. You must have either the Project Owner or Organization Owner role to successfully call this endpoint.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find **group_id** in the official documentation.\n\n\n## Example Usage\n\n### Basic Example.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testNetworkContainer = new mongodbatlas.NetworkContainer(\"test\", {\n    projectId: \"\u003cYOUR-PROJECT-ID\u003e\",\n    atlasCidrBlock: \"10.8.0.0/21\",\n    providerName: \"AWS\",\n    regionName: \"US_EAST_1\",\n});\nconst test = mongodbatlas.getNetworkContainerOutput({\n    projectId: testNetworkContainer.projectId,\n    containerId: testNetworkContainer.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_network_container = mongodbatlas.NetworkContainer(\"test\",\n    project_id=\"\u003cYOUR-PROJECT-ID\u003e\",\n    atlas_cidr_block=\"10.8.0.0/21\",\n    provider_name=\"AWS\",\n    region_name=\"US_EAST_1\")\ntest = mongodbatlas.get_network_container_output(project_id=test_network_container.project_id,\n    container_id=test_network_container.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testNetworkContainer = new Mongodbatlas.NetworkContainer(\"test\", new()\n    {\n        ProjectId = \"\u003cYOUR-PROJECT-ID\u003e\",\n        AtlasCidrBlock = \"10.8.0.0/21\",\n        ProviderName = \"AWS\",\n        RegionName = \"US_EAST_1\",\n    });\n\n    var test = Mongodbatlas.GetNetworkContainer.Invoke(new()\n    {\n        ProjectId = testNetworkContainer.ProjectId,\n        ContainerId = testNetworkContainer.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestNetworkContainer, err := mongodbatlas.NewNetworkContainer(ctx, \"test\", \u0026mongodbatlas.NetworkContainerArgs{\n\t\t\tProjectId:      pulumi.String(\"\u003cYOUR-PROJECT-ID\u003e\"),\n\t\t\tAtlasCidrBlock: pulumi.String(\"10.8.0.0/21\"),\n\t\t\tProviderName:   pulumi.String(\"AWS\"),\n\t\t\tRegionName:     pulumi.String(\"US_EAST_1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupNetworkContainerOutput(ctx, mongodbatlas.GetNetworkContainerOutputArgs{\n\t\t\tProjectId:   testNetworkContainer.ProjectId,\n\t\t\tContainerId: testNetworkContainer.ID(),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.NetworkContainer;\nimport com.pulumi.mongodbatlas.NetworkContainerArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetNetworkContainerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testNetworkContainer = new NetworkContainer(\"testNetworkContainer\", NetworkContainerArgs.builder()\n            .projectId(\"\u003cYOUR-PROJECT-ID\u003e\")\n            .atlasCidrBlock(\"10.8.0.0/21\")\n            .providerName(\"AWS\")\n            .regionName(\"US_EAST_1\")\n            .build());\n\n        final var test = MongodbatlasFunctions.getNetworkContainer(GetNetworkContainerArgs.builder()\n            .projectId(testNetworkContainer.projectId())\n            .containerId(testNetworkContainer.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testNetworkContainer:\n    type: mongodbatlas:NetworkContainer\n    name: test\n    properties:\n      projectId: \u003cYOUR-PROJECT-ID\u003e\n      atlasCidrBlock: 10.8.0.0/21\n      providerName: AWS\n      regionName: US_EAST_1\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getNetworkContainer\n      Arguments:\n        projectId: ${testNetworkContainer.projectId}\n        containerId: ${testNetworkContainer.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNetworkContainer.\n",
                "properties": {
                    "containerId": {
                        "type": "string",
                        "description": "The Network Peering Container ID.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the database user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "containerId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNetworkContainer.\n",
                "properties": {
                    "atlasCidrBlock": {
                        "description": "CIDR block that Atlas uses for your clusters. Atlas uses the specified CIDR block for all other Network Peering connections created in the project. The Atlas CIDR block must be at least a /24 and at most a /21 in one of the following [private networks](https://tools.ietf.org/html/rfc1918.html#section-3).\n",
                        "type": "string"
                    },
                    "azureSubscriptionId": {
                        "description": "Unique identifer of the Azure subscription in which the VNet resides.\n",
                        "type": "string"
                    },
                    "containerId": {
                        "type": "string"
                    },
                    "gcpProjectId": {
                        "description": "Unique identifier of the GCP project in which the Network Peering connection resides.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "networkName": {
                        "description": "Name of the Network Peering connection in the Atlas project.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "providerName": {
                        "description": "Cloud provider for this Network Peering connection. If omitted, Atlas sets this parameter to AWS.\n",
                        "type": "string"
                    },
                    "provisioned": {
                        "description": "Indicates whether the project has Network Peering connections deployed in the container.\n",
                        "type": "boolean"
                    },
                    "region": {
                        "description": "The Atlas Azure region name for where this container will exist.\n",
                        "type": "string"
                    },
                    "regionName": {
                        "description": "The Atlas AWS region name for where this container will exist.\n",
                        "type": "string"
                    },
                    "regions": {
                        "description": "Atlas GCP regions where the container resides.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "vnetName": {
                        "description": "The name of the Azure VNet. This value is null until you provision an Azure VNet in the container.\n",
                        "type": "string"
                    },
                    "vpcId": {
                        "description": "Unique identifier of the projectâs VPC.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "atlasCidrBlock",
                    "azureSubscriptionId",
                    "containerId",
                    "gcpProjectId",
                    "networkName",
                    "projectId",
                    "providerName",
                    "provisioned",
                    "region",
                    "regionName",
                    "regions",
                    "vnetName",
                    "vpcId",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getNetworkContainers:getNetworkContainers": {
            "description": "## # Data Source: mongodbatlas.getNetworkContainers\n\n`mongodbatlas.getNetworkContainers` describes all Network Peering Containers. The data source requires your Project ID.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find **group_id** in the official documentation.\n\n\n## Example Usage\n\n### Basic Example.\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testNetworkContainer = new mongodbatlas.NetworkContainer(\"test\", {\n    projectId: \"\u003cYOUR-PROJECT-ID\u003e\",\n    atlasCidrBlock: \"10.8.0.0/21\",\n    providerName: \"AWS\",\n    regionName: \"US_EAST_1\",\n});\nconst test = pulumi.all([testNetworkContainer.projectId, testNetworkContainer.providerName]).apply(([projectId, providerName]) =\u003e mongodbatlas.getNetworkContainersOutput({\n    projectId: projectId,\n    providerName: providerName,\n}));\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_network_container = mongodbatlas.NetworkContainer(\"test\",\n    project_id=\"\u003cYOUR-PROJECT-ID\u003e\",\n    atlas_cidr_block=\"10.8.0.0/21\",\n    provider_name=\"AWS\",\n    region_name=\"US_EAST_1\")\ntest = pulumi.Output.all(\n    project_id=test_network_container.project_id,\n    provider_name=test_network_container.provider_name\n).apply(lambda resolved_outputs: mongodbatlas.get_network_containers_output(project_id=resolved_outputs['project_id'],\n    provider_name=resolved_outputs['provider_name']))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testNetworkContainer = new Mongodbatlas.NetworkContainer(\"test\", new()\n    {\n        ProjectId = \"\u003cYOUR-PROJECT-ID\u003e\",\n        AtlasCidrBlock = \"10.8.0.0/21\",\n        ProviderName = \"AWS\",\n        RegionName = \"US_EAST_1\",\n    });\n\n    var test = Mongodbatlas.GetNetworkContainers.Invoke(new()\n    {\n        ProjectId = testNetworkContainer.ProjectId,\n        ProviderName = testNetworkContainer.ProviderName,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestNetworkContainer, err := mongodbatlas.NewNetworkContainer(ctx, \"test\", \u0026mongodbatlas.NetworkContainerArgs{\n\t\t\tProjectId:      pulumi.String(\"\u003cYOUR-PROJECT-ID\u003e\"),\n\t\t\tAtlasCidrBlock: pulumi.String(\"10.8.0.0/21\"),\n\t\t\tProviderName:   pulumi.String(\"AWS\"),\n\t\t\tRegionName:     pulumi.String(\"US_EAST_1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = pulumi.All(testNetworkContainer.ProjectId, testNetworkContainer.ProviderName).ApplyT(func(_args []interface{}) (mongodbatlas.GetNetworkContainersResult, error) {\n\t\t\tprojectId := _args[0].(string)\n\t\t\tproviderName := _args[1].(*string)\n\t\t\treturn mongodbatlas.GetNetworkContainersResult(interface{}(mongodbatlas.LookupNetworkContainersOutput(ctx, mongodbatlas.GetNetworkContainersOutputArgs{\n\t\t\t\tProjectId:    projectId,\n\t\t\t\tProviderName: providerName,\n\t\t\t}, nil))), nil\n\t\t}).(mongodbatlas.GetNetworkContainersResultOutput)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.NetworkContainer;\nimport com.pulumi.mongodbatlas.NetworkContainerArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetNetworkContainersArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testNetworkContainer = new NetworkContainer(\"testNetworkContainer\", NetworkContainerArgs.builder()\n            .projectId(\"\u003cYOUR-PROJECT-ID\u003e\")\n            .atlasCidrBlock(\"10.8.0.0/21\")\n            .providerName(\"AWS\")\n            .regionName(\"US_EAST_1\")\n            .build());\n\n        final var test = MongodbatlasFunctions.getNetworkContainers(GetNetworkContainersArgs.builder()\n            .projectId(testNetworkContainer.projectId())\n            .providerName(testNetworkContainer.providerName())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testNetworkContainer:\n    type: mongodbatlas:NetworkContainer\n    name: test\n    properties:\n      projectId: \u003cYOUR-PROJECT-ID\u003e\n      atlasCidrBlock: 10.8.0.0/21\n      providerName: AWS\n      regionName: US_EAST_1\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getNetworkContainers\n      Arguments:\n        projectId: ${testNetworkContainer.projectId}\n        providerName: ${testNetworkContainer.providerName}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNetworkContainers.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the database user.\n"
                    },
                    "providerName": {
                        "type": "string",
                        "description": "Cloud provider for this Network peering container. Accepted values are AWS, GCP, and Azure.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId",
                    "providerName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNetworkContainers.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "providerName": {
                        "description": "Cloud provider for this Network Peering connection. If omitted, Atlas sets this parameter to AWS.\n",
                        "type": "string"
                    },
                    "results": {
                        "description": "A list where each represents a Network Peering Container.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getNetworkContainersResult:getNetworkContainersResult"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "projectId",
                    "providerName",
                    "results",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getNetworkPeering:getNetworkPeering": {
            "description": "## # Data Source: mongodbatlas.NetworkPeering\n\n`mongodbatlas.NetworkPeering` describes a Network Peering Connection.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find **group_id** in the official documentation.\n\n## Example Usage\n\n### Basic Example (AWS).\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testNetworkPeering = new mongodbatlas.NetworkPeering(\"test\", {\n    accepterRegionName: \"us-east-1\",\n    projectId: \"\u003cYOUR-PROJEC-ID\u003e\",\n    containerId: \"507f1f77bcf86cd799439011\",\n    providerName: \"AWS\",\n    routeTableCidrBlock: \"192.168.0.0/24\",\n    vpcId: \"vpc-abc123abc123\",\n    awsAccountId: \"abc123abc123\",\n});\nconst test = mongodbatlas.getNetworkPeeringOutput({\n    projectId: testNetworkPeering.projectId,\n    peeringId: testNetworkPeering.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_network_peering = mongodbatlas.NetworkPeering(\"test\",\n    accepter_region_name=\"us-east-1\",\n    project_id=\"\u003cYOUR-PROJEC-ID\u003e\",\n    container_id=\"507f1f77bcf86cd799439011\",\n    provider_name=\"AWS\",\n    route_table_cidr_block=\"192.168.0.0/24\",\n    vpc_id=\"vpc-abc123abc123\",\n    aws_account_id=\"abc123abc123\")\ntest = mongodbatlas.get_network_peering_output(project_id=test_network_peering.project_id,\n    peering_id=test_network_peering.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testNetworkPeering = new Mongodbatlas.NetworkPeering(\"test\", new()\n    {\n        AccepterRegionName = \"us-east-1\",\n        ProjectId = \"\u003cYOUR-PROJEC-ID\u003e\",\n        ContainerId = \"507f1f77bcf86cd799439011\",\n        ProviderName = \"AWS\",\n        RouteTableCidrBlock = \"192.168.0.0/24\",\n        VpcId = \"vpc-abc123abc123\",\n        AwsAccountId = \"abc123abc123\",\n    });\n\n    var test = Mongodbatlas.GetNetworkPeering.Invoke(new()\n    {\n        ProjectId = testNetworkPeering.ProjectId,\n        PeeringId = testNetworkPeering.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestNetworkPeering, err := mongodbatlas.NewNetworkPeering(ctx, \"test\", \u0026mongodbatlas.NetworkPeeringArgs{\n\t\t\tAccepterRegionName:  pulumi.String(\"us-east-1\"),\n\t\t\tProjectId:           pulumi.String(\"\u003cYOUR-PROJEC-ID\u003e\"),\n\t\t\tContainerId:         pulumi.String(\"507f1f77bcf86cd799439011\"),\n\t\t\tProviderName:        pulumi.String(\"AWS\"),\n\t\t\tRouteTableCidrBlock: pulumi.String(\"192.168.0.0/24\"),\n\t\t\tVpcId:               pulumi.String(\"vpc-abc123abc123\"),\n\t\t\tAwsAccountId:        pulumi.String(\"abc123abc123\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupNetworkPeeringOutput(ctx, mongodbatlas.GetNetworkPeeringOutputArgs{\n\t\t\tProjectId: testNetworkPeering.ProjectId,\n\t\t\tPeeringId: testNetworkPeering.ID(),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.NetworkPeering;\nimport com.pulumi.mongodbatlas.NetworkPeeringArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetNetworkPeeringArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testNetworkPeering = new NetworkPeering(\"testNetworkPeering\", NetworkPeeringArgs.builder()\n            .accepterRegionName(\"us-east-1\")\n            .projectId(\"\u003cYOUR-PROJEC-ID\u003e\")\n            .containerId(\"507f1f77bcf86cd799439011\")\n            .providerName(\"AWS\")\n            .routeTableCidrBlock(\"192.168.0.0/24\")\n            .vpcId(\"vpc-abc123abc123\")\n            .awsAccountId(\"abc123abc123\")\n            .build());\n\n        final var test = MongodbatlasFunctions.getNetworkPeering(GetNetworkPeeringArgs.builder()\n            .projectId(testNetworkPeering.projectId())\n            .peeringId(testNetworkPeering.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testNetworkPeering:\n    type: mongodbatlas:NetworkPeering\n    name: test\n    properties:\n      accepterRegionName: us-east-1\n      projectId: \u003cYOUR-PROJEC-ID\u003e\n      containerId: 507f1f77bcf86cd799439011\n      providerName: AWS\n      routeTableCidrBlock: 192.168.0.0/24\n      vpcId: vpc-abc123abc123\n      awsAccountId: abc123abc123\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getNetworkPeering\n      Arguments:\n        projectId: ${testNetworkPeering.projectId}\n        peeringId: ${testNetworkPeering.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNetworkPeering.\n",
                "properties": {
                    "peeringId": {
                        "type": "string",
                        "description": "Atlas assigned unique ID for the peering connection.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the database user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "peeringId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNetworkPeering.\n",
                "properties": {
                    "accepterRegionName": {
                        "description": "Specifies the region where the peer VPC resides. For complete lists of supported regions, see [Amazon Web Services](https://docs.atlas.mongodb.com/reference/amazon-aws/).\n",
                        "type": "string"
                    },
                    "atlasCidrBlock": {
                        "type": "string"
                    },
                    "atlasId": {
                        "type": "string"
                    },
                    "awsAccountId": {
                        "description": "Account ID of the owner of the peer VPC.\n",
                        "type": "string"
                    },
                    "azureDirectoryId": {
                        "description": "Unique identifier for an Azure AD directory.\n",
                        "type": "string"
                    },
                    "azureSubscriptionId": {
                        "description": "Unique identifer of the Azure subscription in which the VNet resides.\n",
                        "type": "string"
                    },
                    "connectionId": {
                        "description": "Unique identifier for the peering connection.\n",
                        "type": "string"
                    },
                    "containerId": {
                        "type": "string"
                    },
                    "errorMessage": {
                        "description": "When `\"status\" : \"FAILED\"`, Atlas provides a description of the error.\n",
                        "type": "string"
                    },
                    "errorState": {
                        "description": "Description of the Atlas error when `status` is `Failed`, Otherwise, Atlas returns `null`.\n",
                        "type": "string"
                    },
                    "errorStateName": {
                        "description": "Error state, if any. The VPC peering connection error state value can be one of the following: `REJECTED`, `EXPIRED`, `INVALID_ARGUMENT`.\n",
                        "type": "string"
                    },
                    "gcpProjectId": {
                        "description": "GCP project ID of the owner of the network peer.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "networkName": {
                        "description": "Name of the network peer to which Atlas connects.\n",
                        "type": "string"
                    },
                    "peeringId": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "providerName": {
                        "description": "Cloud provider for this VPC peering connection. If omitted, Atlas sets this parameter to AWS. (Possible Values `AWS`, `AZURE`, `GCP`).\n",
                        "type": "string"
                    },
                    "resourceGroupName": {
                        "description": "Name of your Azure resource group.\n",
                        "type": "string"
                    },
                    "routeTableCidrBlock": {
                        "description": "Peer VPC CIDR block or subnet.\n",
                        "type": "string"
                    },
                    "status": {
                        "description": "Status of the Atlas network peering connection: `ADDING_PEER`, `AVAILABLE`, `FAILED`, `DELETING`, `WAITING_FOR_USER`.\n",
                        "type": "string"
                    },
                    "statusName": {
                        "description": "The VPC peering connection status value can be one of the following: `INITIATING`, `PENDING_ACCEPTANCE`, `FAILED`, `FINALIZING`, `AVAILABLE`, `TERMINATING`.\n",
                        "type": "string"
                    },
                    "vnetName": {
                        "description": "Name of your Azure VNet.\n",
                        "type": "string"
                    },
                    "vpcId": {
                        "description": "Unique identifier of the peer VPC.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "accepterRegionName",
                    "atlasCidrBlock",
                    "atlasId",
                    "awsAccountId",
                    "azureDirectoryId",
                    "azureSubscriptionId",
                    "connectionId",
                    "containerId",
                    "errorMessage",
                    "errorState",
                    "errorStateName",
                    "gcpProjectId",
                    "networkName",
                    "peeringId",
                    "projectId",
                    "providerName",
                    "resourceGroupName",
                    "routeTableCidrBlock",
                    "status",
                    "statusName",
                    "vnetName",
                    "vpcId",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getNetworkPeerings:getNetworkPeerings": {
            "description": "## # Data Source: mongodbatlas.getNetworkPeerings\n\n`mongodbatlas.getNetworkPeerings` describes all Network Peering Connections.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find **group_id** in the official documentation.\n\n\n## Example Usage\n\n### Basic Example (AWS).\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testNetworkPeering = new mongodbatlas.NetworkPeering(\"test\", {\n    accepterRegionName: \"us-east-1\",\n    projectId: \"\u003cYOUR-PROJEC-ID\u003e\",\n    containerId: \"507f1f77bcf86cd799439011\",\n    providerName: \"AWS\",\n    routeTableCidrBlock: \"192.168.0.0/24\",\n    vpcId: \"vpc-abc123abc123\",\n    awsAccountId: \"abc123abc123\",\n});\nconst test = mongodbatlas.getNetworkPeeringsOutput({\n    projectId: testNetworkPeering.projectId,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_network_peering = mongodbatlas.NetworkPeering(\"test\",\n    accepter_region_name=\"us-east-1\",\n    project_id=\"\u003cYOUR-PROJEC-ID\u003e\",\n    container_id=\"507f1f77bcf86cd799439011\",\n    provider_name=\"AWS\",\n    route_table_cidr_block=\"192.168.0.0/24\",\n    vpc_id=\"vpc-abc123abc123\",\n    aws_account_id=\"abc123abc123\")\ntest = mongodbatlas.get_network_peerings_output(project_id=test_network_peering.project_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testNetworkPeering = new Mongodbatlas.NetworkPeering(\"test\", new()\n    {\n        AccepterRegionName = \"us-east-1\",\n        ProjectId = \"\u003cYOUR-PROJEC-ID\u003e\",\n        ContainerId = \"507f1f77bcf86cd799439011\",\n        ProviderName = \"AWS\",\n        RouteTableCidrBlock = \"192.168.0.0/24\",\n        VpcId = \"vpc-abc123abc123\",\n        AwsAccountId = \"abc123abc123\",\n    });\n\n    var test = Mongodbatlas.GetNetworkPeerings.Invoke(new()\n    {\n        ProjectId = testNetworkPeering.ProjectId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestNetworkPeering, err := mongodbatlas.NewNetworkPeering(ctx, \"test\", \u0026mongodbatlas.NetworkPeeringArgs{\n\t\t\tAccepterRegionName:  pulumi.String(\"us-east-1\"),\n\t\t\tProjectId:           pulumi.String(\"\u003cYOUR-PROJEC-ID\u003e\"),\n\t\t\tContainerId:         pulumi.String(\"507f1f77bcf86cd799439011\"),\n\t\t\tProviderName:        pulumi.String(\"AWS\"),\n\t\t\tRouteTableCidrBlock: pulumi.String(\"192.168.0.0/24\"),\n\t\t\tVpcId:               pulumi.String(\"vpc-abc123abc123\"),\n\t\t\tAwsAccountId:        pulumi.String(\"abc123abc123\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupNetworkPeeringsOutput(ctx, mongodbatlas.GetNetworkPeeringsOutputArgs{\n\t\t\tProjectId: testNetworkPeering.ProjectId,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.NetworkPeering;\nimport com.pulumi.mongodbatlas.NetworkPeeringArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetNetworkPeeringsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testNetworkPeering = new NetworkPeering(\"testNetworkPeering\", NetworkPeeringArgs.builder()\n            .accepterRegionName(\"us-east-1\")\n            .projectId(\"\u003cYOUR-PROJEC-ID\u003e\")\n            .containerId(\"507f1f77bcf86cd799439011\")\n            .providerName(\"AWS\")\n            .routeTableCidrBlock(\"192.168.0.0/24\")\n            .vpcId(\"vpc-abc123abc123\")\n            .awsAccountId(\"abc123abc123\")\n            .build());\n\n        final var test = MongodbatlasFunctions.getNetworkPeerings(GetNetworkPeeringsArgs.builder()\n            .projectId(testNetworkPeering.projectId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testNetworkPeering:\n    type: mongodbatlas:NetworkPeering\n    name: test\n    properties:\n      accepterRegionName: us-east-1\n      projectId: \u003cYOUR-PROJEC-ID\u003e\n      containerId: 507f1f77bcf86cd799439011\n      providerName: AWS\n      routeTableCidrBlock: 192.168.0.0/24\n      vpcId: vpc-abc123abc123\n      awsAccountId: abc123abc123\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getNetworkPeerings\n      Arguments:\n        projectId: ${testNetworkPeering.projectId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNetworkPeerings.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to create the database user.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNetworkPeerings.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "description": "A list where each represents a Network Peering Connection.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getNetworkPeeringsResult:getNetworkPeeringsResult"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "projectId",
                    "results",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getOnlineArchive:getOnlineArchive": {
            "description": "## # Data Source: mongodbatlas.OnlineArchive\n\n`mongodbatlas.OnlineArchive` describes an Online Archive\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n\n## Example Usage\n\n```terraform \n\ndata \"mongodbatlas_online_archive\" \"test\" {\n    project_id   = var.project_id\n    cluster_name = var.cluster_name\n    archive_id     = \"5ebad3c1fe9c0ab8d37d61e1\"\n}\n```\n\n## Attributes reference\n\n* `db_name`          -  Name of the database that contains the collection.\n* `coll_name`        -  Name of the collection.\n* `collection_type`  -  Type of MongoDB collection that you want to return. This value can be \"TIMESERIES\" or \"STANDARD\". Default is \"STANDARD\".\n* `criteria` - Criteria to use for archiving data. See criteria.\n* `data_expiration_rule` - Rule for specifying when data should be deleted from the archive. See data expiration rule.\n* `data_process_region` - Settings to configure the region where you wish to store your archived data. See data process region.\n* `schedule` - Regular frequency and duration when archiving process occurs. See schedule.\n* `partition_fields` - Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Queries that donât contain the specified fields require a full collection scan of all archived documents, which takes longer and increases your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived. See partition fields.\n* `paused` - State of the online archive. This is required for pausing an active online archive or resuming a paused online archive. If the collection has another active online archive, the resume request fails.\n* `state`    - Status of the online archive. Valid values are: Pending, Archiving, Idle, Pausing, Paused, Orphaned and Deleted\n\n### Criteria\n* `type`          - Type of criteria (DATE, CUSTOM)\n* `date_field`   - Indexed database parameter that stores the date that determines when data moves to the online archive. MongoDB Cloud archives the data when the current date exceeds the date in this database parameter plus the number of days specified through the expireAfterDays parameter. Set this parameter when `type` is `DATE`.\n* `date_format`   - Syntax used to write the date after which data moves to the online archive. Date can be expressed as ISO 8601 or Epoch timestamps. The Epoch timestamp can be expressed as nanoseconds, milliseconds, or seconds. Set this parameter when `type` is `DATE`. You must set `type` to `DATE` if `collectionType` is `TIMESERIES`. Valid values:  ISODATE (default), EPOCH_SECONDS, EPOCH_MILLIS, EPOCH_NANOSECONDS.\n* `expire_after_days` - Number of days after the value in the criteria.dateField when MongoDB Cloud archives data in the specified cluster. Set this parameter when `type` is `DATE`.\n* `query` - JSON query to use to select documents for archiving. Atlas uses the specified query with the db.collection.find(query) command. The empty document {} to return all documents is not supported. Set this parameter when `type` is `CUSTOM`.\n\n### Data Expiration Rule\n* `expire_after_days` - Number of days used in the date criteria for nominating documents for deletion. Value must be between 7 and 9215.\n\n### Data Process Region\n* `cloud_provider` - Human-readable label that identifies the Cloud service provider where you wish to store your archived data.\n* `region` - Human-readable label that identifies the geographic location of the region where you wish to store your archived data. For allowed values, see [MongoDB Atlas API documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Online-Archive/operation/createOnlineArchive)\n\n\n### Schedule\n\n* `type`          - Type of schedule. Valid values: `DEFAULT`, `DAILY`, `MONTHLY`, `WEEKLY`.\n* `start_hour`    - Hour of the day when the when the scheduled window to run one online archive starts.  \n* `end_hour`      - Hour of the day when the scheduled window to run one online archive ends.\n* `start_minute`   - Minute of the hour when the scheduled window to run one online archive starts.\n* `end_minute`     - Minute of the hour when the scheduled window to run one online archive ends.\n* `day_of_month`   - Day of the month when the scheduled archive starts. Set this parameter when `type` is `MONTHLY`.\n* `day_of_week`     - Day of the week when the scheduled archive starts. The week starts with Monday (1) and ends with Sunday (7).Set this parameter when `type` is `WEEKLY`.\n\n### Partition\n* `field_name` - Human-readable label that identifies the parameter that MongoDB Cloud uses to partition data. To specify a nested parameter, use the dot notation.\n* `order` - Sequence in which MongoDB Cloud slices the collection data to create partitions. The resource expresses this sequence starting with zero. The value of the `criteria.dateField` parameter defaults as the first item in the partition sequence.\n* `field_type` - Data type of the parameter that that MongoDB Cloud uses to partition data. Partition parameters of type UUID must be of binary subtype 4. MongoDB Cloud skips partition parameters of type UUID with subtype 3. Valid values: `date`, `int`, `long`, `objectId`, `string`, `uuid`.\n\nSee [MongoDB Atlas API](https://docs.atlas.mongodb.com/reference/api/online-archive-get-one/) Documentation for more information.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getOnlineArchive.\n",
                "properties": {
                    "archiveId": {
                        "type": "string",
                        "description": "ID of the online archive.\n"
                    },
                    "clusterName": {
                        "type": "string",
                        "description": "Name of the cluster that contains the collection.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "archiveId",
                    "clusterName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getOnlineArchive.\n",
                "properties": {
                    "archiveId": {
                        "type": "string"
                    },
                    "clusterName": {
                        "type": "string"
                    },
                    "collName": {
                        "type": "string"
                    },
                    "collectionType": {
                        "type": "string"
                    },
                    "criterias": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getOnlineArchiveCriteria:getOnlineArchiveCriteria"
                        },
                        "type": "array"
                    },
                    "dataExpirationRules": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getOnlineArchiveDataExpirationRule:getOnlineArchiveDataExpirationRule"
                        },
                        "type": "array"
                    },
                    "dataProcessRegions": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getOnlineArchiveDataProcessRegion:getOnlineArchiveDataProcessRegion"
                        },
                        "type": "array"
                    },
                    "dbName": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "partitionFields": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getOnlineArchivePartitionField:getOnlineArchivePartitionField"
                        },
                        "type": "array"
                    },
                    "paused": {
                        "type": "boolean"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "schedules": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getOnlineArchiveSchedule:getOnlineArchiveSchedule"
                        },
                        "type": "array"
                    },
                    "state": {
                        "type": "string"
                    }
                },
                "required": [
                    "archiveId",
                    "clusterName",
                    "collName",
                    "collectionType",
                    "criterias",
                    "dataExpirationRules",
                    "dataProcessRegions",
                    "dbName",
                    "partitionFields",
                    "paused",
                    "projectId",
                    "schedules",
                    "state",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getOnlineArchives:getOnlineArchives": {
            "description": "## # Data Source: mongodbatlas.OnlineArchive\n\n`mongodbatlas.OnlineArchive` Describes the list of all the online archives for a cluster\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n\n## Example Usage\n\n```terraform \ndata \"mongodbatlas_online_archives\" \"test\" {\n    project_id   = var.project_id\n    cluster_name = var.cluster_name\n}\n```\n\n## Attributes reference\n\n* `db_name` - Name of the database that contains the collection.\n* `coll_name` -  Name of the collection.\n* `collection_type` - Type of MongoDB collection that you want to return. This value can be \"TIMESERIES\" or \"STANDARD\". Default is \"STANDARD\". \n* `criteria` - Criteria to use for archiving data. See criteria.\n* `data_expiration_rule` - Rule for specifying when data should be deleted from the archive. See data expiration rule.\n* `data_process_region` - Settings to configure the region where you wish to store your archived data. See data process region.\n* `schedule` - Regular frequency and duration when archiving process occurs. See schedule.\n* `partition_fields` - Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Queries that donât contain the specified fields require a full collection scan of all archived documents, which takes longer and increases your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived. See partition fields.\n* `paused` - State of the online archive. This is required for pausing an active online archive or resuming a paused online archive. If the collection has another active online archive, the resume request fails.\n* `state` - Status of the online archive. Valid values are: Pending, Archiving, Idle, Pausing, Paused, Orphaned and Deleted\n\n### Criteria\n* `type` - Type of criteria (DATE, CUSTOM)\n* `date_field` - Indexed database parameter that stores the date that determines when data moves to the online archive. MongoDB Cloud archives the data when the current date exceeds the date in this database parameter plus the number of days specified through the expireAfterDays parameter. Set this parameter when `type` is `DATE`.\n* `date_format` - Syntax used to write the date after which data moves to the online archive. Date can be expressed as ISO 8601 or Epoch timestamps. The Epoch timestamp can be expressed as nanoseconds, milliseconds, or seconds. Set this parameter when `type` is `DATE`. You must set `type` to `DATE` if `collectionType` is `TIMESERIES`. Valid values:  ISODATE (default), EPOCH_SECONDS, EPOCH_MILLIS, EPOCH_NANOSECONDS.\n* `expire_after_days` - Number of days after the value in the criteria.dateField when MongoDB Cloud archives data in the specified cluster. Set this parameter when `type` is `DATE`.\n* `query` - JSON query to use to select documents for archiving. Atlas uses the specified query with the db.collection.find(query) command. The empty document {} to return all documents is not supported. Set this parameter when `type` is `CUSTOM`.\n\n### Data Expiration Rule\n* `expire_after_days` - Number of days used in the date criteria for nominating documents for deletion. Value must be between 7 and 9215.\n\n### Data Process Region\n* `cloud_provider` - Human-readable label that identifies the Cloud service provider where you wish to store your archived data.\n* `region` - Human-readable label that identifies the geographic location of the region where you wish to store your archived data. For allowed values, see [MongoDB Atlas API documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Online-Archive/operation/createOnlineArchive)\n\n### Schedule\n\n* `type` - Type of schedule (`DAILY`, `MONTHLY`, `WEEKLY`).\n* `start_hour` - Hour of the day when the when the scheduled window to run one online archive starts.  \n* `end_hour` - Hour of the day when the scheduled window to run one online archive ends.\n* `start_minute` - Minute of the hour when the scheduled window to run one online archive starts.\n* `end_minute` - Minute of the hour when the scheduled window to run one online archive ends.\n* `day_of_month` - Day of the month when the scheduled archive starts.\n* `day_of_week` - Day of the week when the scheduled archive starts. The week starts with Monday (1) and ends with Sunday (7).\n\n### Partition\n* `field_name` - Human-readable label that identifies the parameter that MongoDB Cloud uses to partition data. To specify a nested parameter, use the dot notation.\n* `order` - Sequence in which MongoDB Cloud slices the collection data to create partitions. The resource expresses this sequence starting with zero. The value of the `criteria.dateField` parameter defaults as the first item in the partition sequence.\n* `field_type` - Data type of the parameter that that MongoDB Cloud uses to partition data. Partition parameters of type UUID must be of binary subtype 4. MongoDB Cloud skips partition parameters of type UUID with subtype 3. Valid values: `date`, `int`, `long`, `objectId`, `string`, `uuid`.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getOnlineArchives.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "Name of the cluster that contains the collection.\n\n# Attributes Reference\n\nIn addition to all arguments above, the following attributes are exported:\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getOnlineArchives.\n",
                "properties": {
                    "clusterName": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getOnlineArchivesResult:getOnlineArchivesResult"
                        },
                        "type": "array"
                    },
                    "totalCount": {
                        "type": "integer"
                    }
                },
                "required": [
                    "clusterName",
                    "projectId",
                    "results",
                    "totalCount",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getOrgInvitation:getOrgInvitation": {
            "description": "## # Data Source: mongodbatlas.OrgInvitation\n\n`mongodbatlas.OrgInvitation` describes an invitation for a user to join an Atlas organization.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getOrgInvitation.\n",
                "properties": {
                    "invitationId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the invitation in Atlas.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the organization to which you invited the user.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Email address of the invited user. This is the address to which Atlas sends the invite. If the user accepts the invitation, they log in to Atlas with this username.\n"
                    }
                },
                "type": "object",
                "required": [
                    "invitationId",
                    "orgId",
                    "username"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getOrgInvitation.\n",
                "properties": {
                    "createdAt": {
                        "description": "Timestamp in ISO 8601 date and time format in UTC when Atlas sent the invitation.\n",
                        "type": "string"
                    },
                    "expiresAt": {
                        "description": "Timestamp in ISO 8601 date and time format in UTC when the invitation expires. Users have 30 days to accept an invitation.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "invitationId": {
                        "type": "string"
                    },
                    "inviterUsername": {
                        "description": "Atlas user who invited `username` to the organization.\n",
                        "type": "string"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "roles": {
                        "description": "Atlas roles to assign to the invited user. If the user accepts the invitation, Atlas assigns these roles to them. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles a user can have.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "teamsIds": {
                        "description": "An array of unique 24-hexadecimal digit strings that identify the teams that the user was invited to join.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "username": {
                        "type": "string"
                    }
                },
                "required": [
                    "createdAt",
                    "expiresAt",
                    "invitationId",
                    "inviterUsername",
                    "orgId",
                    "roles",
                    "teamsIds",
                    "username",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getOrganization:getOrganization": {
            "description": "## # Data Source: mongodbatlas.Organization\n\n`mongodbatlas.Organization` describes all MongoDB Atlas Organizations. This represents organizations that have been created.\n\n## Example Usage\n\n### Using project_id attribute to query\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = mongodbatlas.getOrganization({\n    orgId: \"\u003corg_id\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.get_organization(org_id=\"\u003corg_id\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Mongodbatlas.GetOrganization.Invoke(new()\n    {\n        OrgId = \"\u003corg_id\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.LookupOrganization(ctx, \u0026mongodbatlas.LookupOrganizationArgs{\n\t\t\tOrgId: \"\u003corg_id\u003e\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetOrganizationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getOrganization(GetOrganizationArgs.builder()\n            .orgId(\"\u003corg_id\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getOrganization\n      Arguments:\n        orgId: \u003corg_id\u003e\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getOrganization.\n",
                "properties": {
                    "orgId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the organization.\n"
                    }
                },
                "type": "object",
                "required": [
                    "orgId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getOrganization.\n",
                "properties": {
                    "apiAccessListRequired": {
                        "description": "(Optional) Flag that indicates whether to require API operations to originate from an IP Address added to the API access list for the specified organization.\n",
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "isDeleted": {
                        "description": "Flag that indicates whether this organization has been deleted.\n",
                        "type": "boolean"
                    },
                    "links": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getOrganizationLink:getOrganizationLink"
                        },
                        "type": "array"
                    },
                    "multiFactorAuthRequired": {
                        "description": "(Optional) Flag that indicates whether to require users to set up Multi-Factor Authentication (MFA) before accessing the specified organization. To learn more, see: https://www.mongodb.com/docs/atlas/security-multi-factor-authentication/.\n",
                        "type": "boolean"
                    },
                    "name": {
                        "description": "Human-readable label that identifies the organization.\n",
                        "type": "string"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "restrictEmployeeAccess": {
                        "description": "(Optional) Flag that indicates whether to block MongoDB Support from accessing Atlas infrastructure for any deployment in the specified organization without explicit permission. Once this setting is turned on, you can grant MongoDB Support a 24-hour bypass access to the Atlas deployment to resolve support issues. To learn more, see: https://www.mongodb.com/docs/atlas/security-restrict-support-access/.\n",
                        "type": "boolean"
                    }
                },
                "required": [
                    "apiAccessListRequired",
                    "isDeleted",
                    "links",
                    "multiFactorAuthRequired",
                    "name",
                    "orgId",
                    "restrictEmployeeAccess",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getOrganizations:getOrganizations": {
            "description": "## # Data Source: mongodbatlas.getOrganizations\n\n`mongodbatlas.getOrganizations` describes all MongoDB Atlas Organizations. This represents organizations that have been created.\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = mongodbatlas.getOrganizations({\n    pageNum: 1,\n    itemsPerPage: 5,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.get_organizations(page_num=1,\n    items_per_page=5)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Mongodbatlas.GetOrganizations.Invoke(new()\n    {\n        PageNum = 1,\n        ItemsPerPage = 5,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.LookupOrganizations(ctx, \u0026mongodbatlas.LookupOrganizationsArgs{\n\t\t\tPageNum:      pulumi.IntRef(1),\n\t\t\tItemsPerPage: pulumi.IntRef(5),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetOrganizationsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getOrganizations(GetOrganizationsArgs.builder()\n            .pageNum(1)\n            .itemsPerPage(5)\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getOrganizations\n      Arguments:\n        pageNum: 1\n        itemsPerPage: 5\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getOrganizations.\n",
                "properties": {
                    "itemsPerPage": {
                        "type": "integer",
                        "description": "Number of items to return per page, up to a maximum of 500. Defaults to `100`.\n"
                    },
                    "name": {
                        "type": "string"
                    },
                    "pageNum": {
                        "type": "integer",
                        "description": "The page to return. Defaults to `1`.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getOrganizations.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "name": {
                        "type": "string"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "results": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getOrganizationsResult:getOrganizationsResult"
                        },
                        "type": "array"
                    },
                    "totalCount": {
                        "type": "integer"
                    }
                },
                "required": [
                    "results",
                    "totalCount",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getPrivateEndpointRegionalMode:getPrivateEndpointRegionalMode": {
            "description": "## # Data Source: private_endpoint_regional_mode\n\n`private_endpoint_regional_mode` describes a Private Endpoint Regional Mode. This represents a Private Endpoint Regional Mode Connection that wants to retrieve settings of an Atlas project.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPrivateEndpointRegionalMode.\n",
                "properties": {
                    "enabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether the regionalized private endpoitn setting is enabled for the project.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique identifier for the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPrivateEndpointRegionalMode.\n",
                "properties": {
                    "enabled": {
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    }
                },
                "required": [
                    "projectId",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getPrivateLinkEndpoint:getPrivateLinkEndpoint": {
            "description": "## # Data Source: mongodbatlas.PrivateLinkEndpoint\n\n`mongodbatlas.PrivateLinkEndpoint` describes a Private Endpoint. This represents a Private Endpoint Connection to retrieve details regarding a private endpoint by id in an Atlas project\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testPrivateLinkEndpoint = new mongodbatlas.PrivateLinkEndpoint(\"test\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    providerName: \"AWS\",\n    region: \"US_EAST_1\",\n});\nconst test = mongodbatlas.getPrivateLinkEndpointOutput({\n    projectId: testPrivateLinkEndpoint.projectId,\n    privateLinkId: testPrivateLinkEndpoint.privateLinkId,\n    providerName: \"AWS\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_private_link_endpoint = mongodbatlas.PrivateLinkEndpoint(\"test\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    provider_name=\"AWS\",\n    region=\"US_EAST_1\")\ntest = mongodbatlas.get_private_link_endpoint_output(project_id=test_private_link_endpoint.project_id,\n    private_link_id=test_private_link_endpoint.private_link_id,\n    provider_name=\"AWS\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testPrivateLinkEndpoint = new Mongodbatlas.PrivateLinkEndpoint(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        ProviderName = \"AWS\",\n        Region = \"US_EAST_1\",\n    });\n\n    var test = Mongodbatlas.GetPrivateLinkEndpoint.Invoke(new()\n    {\n        ProjectId = testPrivateLinkEndpoint.ProjectId,\n        PrivateLinkId = testPrivateLinkEndpoint.PrivateLinkId,\n        ProviderName = \"AWS\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestPrivateLinkEndpoint, err := mongodbatlas.NewPrivateLinkEndpoint(ctx, \"test\", \u0026mongodbatlas.PrivateLinkEndpointArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\tRegion:       pulumi.String(\"US_EAST_1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupPrivateLinkEndpointOutput(ctx, mongodbatlas.GetPrivateLinkEndpointOutputArgs{\n\t\t\tProjectId:     testPrivateLinkEndpoint.ProjectId,\n\t\t\tPrivateLinkId: testPrivateLinkEndpoint.PrivateLinkId,\n\t\t\tProviderName:  pulumi.String(\"AWS\"),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.PrivateLinkEndpoint;\nimport com.pulumi.mongodbatlas.PrivateLinkEndpointArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetPrivateLinkEndpointArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testPrivateLinkEndpoint = new PrivateLinkEndpoint(\"testPrivateLinkEndpoint\", PrivateLinkEndpointArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .providerName(\"AWS\")\n            .region(\"US_EAST_1\")\n            .build());\n\n        final var test = MongodbatlasFunctions.getPrivateLinkEndpoint(GetPrivateLinkEndpointArgs.builder()\n            .projectId(testPrivateLinkEndpoint.projectId())\n            .privateLinkId(testPrivateLinkEndpoint.privateLinkId())\n            .providerName(\"AWS\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testPrivateLinkEndpoint:\n    type: mongodbatlas:PrivateLinkEndpoint\n    name: test\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      providerName: AWS\n      region: US_EAST_1\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getPrivateLinkEndpoint\n      Arguments:\n        projectId: ${testPrivateLinkEndpoint.projectId}\n        privateLinkId: ${testPrivateLinkEndpoint.privateLinkId}\n        providerName: AWS\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Available complete examples\n- Setup private connection to a MongoDB Atlas Cluster with AWS VPC\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPrivateLinkEndpoint.\n",
                "properties": {
                    "privateLinkId": {
                        "type": "string",
                        "description": "Unique identifier of the private endpoint service that you want to retrieve.\n",
                        "willReplaceOnChanges": true
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique identifier for the project.\n",
                        "willReplaceOnChanges": true
                    },
                    "providerName": {
                        "type": "string",
                        "description": "Cloud provider for which you want to retrieve a private endpoint service. Atlas accepts `AWS`, `AZURE` or `GCP`.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "privateLinkId",
                    "projectId",
                    "providerName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPrivateLinkEndpoint.\n",
                "properties": {
                    "endpointGroupNames": {
                        "description": "GCP network endpoint groups corresponding to the Private Service Connect endpoint service.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "endpointServiceName": {
                        "description": "Name of the PrivateLink endpoint service in AWS. Returns null while the endpoint service is being created.\n",
                        "type": "string"
                    },
                    "errorMessage": {
                        "description": "Error message pertaining to the AWS PrivateLink connection. Returns null if there are no errors.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "interfaceEndpoints": {
                        "description": "Unique identifiers of the interface endpoints in your VPC that you added to the AWS PrivateLink connection.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "privateEndpoints": {
                        "description": "All private endpoints that you have added to this Azure Private Link Service.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "privateLinkId": {
                        "type": "string"
                    },
                    "privateLinkServiceName": {
                        "description": "Name of the Azure Private Link Service that Atlas manages.\n",
                        "type": "string"
                    },
                    "privateLinkServiceResourceId": {
                        "description": "Resource ID of the Azure Private Link Service that Atlas manages.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "providerName": {
                        "type": "string"
                    },
                    "regionName": {
                        "description": "GCP region for the Private Service Connect endpoint service.\n",
                        "type": "string"
                    },
                    "serviceAttachmentNames": {
                        "description": "Unique alphanumeric and special character strings that identify the service attachments associated with the GCP Private Service Connect endpoint service.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "status": {
                        "description": "Status of the AWS PrivateLink connection.\nReturns one of the following values:\n* `AVAILABLE` \tAtlas created the load balancer and the Private Link Service.\n* `INITIATING` \tAtlas is creating the network load balancer and VPC endpoint service.\n* `WAITING_FOR_USER` The Atlas network load balancer and VPC endpoint service are created and ready to receive connection requests. When you receive this status, create an interface endpoint to continue configuring the AWS PrivateLink connection.\n* `FAILED` \tA system failure has occurred.\n* `DELETING` \tThe Private Link service is being deleted.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "endpointGroupNames",
                    "endpointServiceName",
                    "errorMessage",
                    "interfaceEndpoints",
                    "privateEndpoints",
                    "privateLinkId",
                    "privateLinkServiceName",
                    "privateLinkServiceResourceId",
                    "projectId",
                    "providerName",
                    "regionName",
                    "serviceAttachmentNames",
                    "status",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getPrivateLinkEndpointService:getPrivateLinkEndpointService": {
            "description": "## # Data Source: mongodbatlas.PrivateLinkEndpointService\n\n`mongodbatlas.PrivateLinkEndpointService` describes a Private Endpoint Link. This represents a Private Endpoint Link Connection that wants to retrieve details in an Atlas project.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n## Example with AWS\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.PrivateLinkEndpoint;\nimport com.pulumi.mongodbatlas.PrivateLinkEndpointArgs;\nimport com.pulumi.aws.vpcEndpoint;\nimport com.pulumi.aws.VpcEndpointArgs;\nimport com.pulumi.mongodbatlas.PrivateLinkEndpointService;\nimport com.pulumi.mongodbatlas.PrivateLinkEndpointServiceArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetPrivateLinkEndpointServiceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testPrivateLinkEndpoint = new PrivateLinkEndpoint(\"testPrivateLinkEndpoint\", PrivateLinkEndpointArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .providerName(\"AWS\")\n            .region(\"US_EAST_1\")\n            .build());\n\n        var ptfeService = new VpcEndpoint(\"ptfeService\", VpcEndpointArgs.builder()\n            .vpcId(\"vpc-7fc0a543\")\n            .serviceName(testPrivateLinkEndpoint.endpointServiceName())\n            .vpcEndpointType(\"Interface\")\n            .subnetIds(\"subnet-de0406d2\")\n            .securityGroupIds(\"sg-3f238186\")\n            .build());\n\n        var testPrivateLinkEndpointService = new PrivateLinkEndpointService(\"testPrivateLinkEndpointService\", PrivateLinkEndpointServiceArgs.builder()\n            .projectId(testPrivateLinkEndpoint.projectId())\n            .privateLinkId(testPrivateLinkEndpoint.privateLinkId())\n            .endpointServiceId(ptfeService.id())\n            .providerName(\"AWS\")\n            .build());\n\n        final var test = MongodbatlasFunctions.getPrivateLinkEndpointService(GetPrivateLinkEndpointServiceArgs.builder()\n            .projectId(testPrivateLinkEndpointService.projectId())\n            .privateLinkId(testPrivateLinkEndpointService.privateLinkId())\n            .interfaceEndpointId(testPrivateLinkEndpointService.interfaceEndpointId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testPrivateLinkEndpoint:\n    type: mongodbatlas:PrivateLinkEndpoint\n    name: test\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      providerName: AWS\n      region: US_EAST_1\n  ptfeService:\n    type: aws:vpcEndpoint\n    name: ptfe_service\n    properties:\n      vpcId: vpc-7fc0a543\n      serviceName: ${testPrivateLinkEndpoint.endpointServiceName}\n      vpcEndpointType: Interface\n      subnetIds:\n        - subnet-de0406d2\n      securityGroupIds:\n        - sg-3f238186\n  testPrivateLinkEndpointService:\n    type: mongodbatlas:PrivateLinkEndpointService\n    name: test\n    properties:\n      projectId: ${testPrivateLinkEndpoint.projectId}\n      privateLinkId: ${testPrivateLinkEndpoint.privateLinkId}\n      endpointServiceId: ${ptfeService.id}\n      providerName: AWS\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getPrivateLinkEndpointService\n      Arguments:\n        projectId: ${testPrivateLinkEndpointService.projectId}\n        privateLinkId: ${testPrivateLinkEndpointService.privateLinkId}\n        interfaceEndpointId: ${testPrivateLinkEndpointService.interfaceEndpointId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Example with Azure\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.PrivateLinkEndpoint;\nimport com.pulumi.mongodbatlas.PrivateLinkEndpointArgs;\nimport com.pulumi.azurerm.privateEndpoint;\nimport com.pulumi.azurerm.PrivateEndpointArgs;\nimport com.pulumi.mongodbatlas.PrivateLinkEndpointService;\nimport com.pulumi.mongodbatlas.PrivateLinkEndpointServiceArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetPrivateLinkEndpointServiceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testPrivateLinkEndpoint = new PrivateLinkEndpoint(\"testPrivateLinkEndpoint\", PrivateLinkEndpointArgs.builder()\n            .projectId(projectId)\n            .providerName(\"AZURE\")\n            .region(\"eastus2\")\n            .build());\n\n        var testPrivateEndpoint = new PrivateEndpoint(\"testPrivateEndpoint\", PrivateEndpointArgs.builder()\n            .name(\"endpoint-test\")\n            .location(testAzurermResourceGroup.location())\n            .resourceGroupName(resourceGroupName)\n            .subnetId(testAzurermSubnet.id())\n            .privateServiceConnection(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference))\n            .build());\n\n        var testPrivateLinkEndpointService = new PrivateLinkEndpointService(\"testPrivateLinkEndpointService\", PrivateLinkEndpointServiceArgs.builder()\n            .projectId(testPrivateLinkEndpoint.projectId())\n            .privateLinkId(testPrivateLinkEndpoint.privateLinkId())\n            .endpointServiceId(testPrivateEndpoint.id())\n            .privateEndpointIpAddress(testPrivateEndpoint.privateServiceConnection()[0].privateIpAddress())\n            .providerName(\"AZURE\")\n            .build());\n\n        final var test = MongodbatlasFunctions.getPrivateLinkEndpointService(GetPrivateLinkEndpointServiceArgs.builder()\n            .projectId(testPrivateLinkEndpointService.projectId())\n            .privateLinkId(testPrivateLinkEndpointService.privateLinkId())\n            .interfaceEndpointId(testPrivateLinkEndpointService.interfaceEndpointId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testPrivateLinkEndpoint:\n    type: mongodbatlas:PrivateLinkEndpoint\n    name: test\n    properties:\n      projectId: ${projectId}\n      providerName: AZURE\n      region: eastus2\n  testPrivateEndpoint:\n    type: azurerm:privateEndpoint\n    name: test\n    properties:\n      name: endpoint-test\n      location: ${testAzurermResourceGroup.location}\n      resourceGroupName: ${resourceGroupName}\n      subnetId: ${testAzurermSubnet.id}\n      privateServiceConnection:\n        - name: ${testPrivateLinkEndpoint.privateLinkServiceName}\n          privateConnectionResourceId: ${testPrivateLinkEndpoint.privateLinkServiceResourceId}\n          isManualConnection: true\n          requestMessage: Azure Private Link test\n  testPrivateLinkEndpointService:\n    type: mongodbatlas:PrivateLinkEndpointService\n    name: test\n    properties:\n      projectId: ${testPrivateLinkEndpoint.projectId}\n      privateLinkId: ${testPrivateLinkEndpoint.privateLinkId}\n      endpointServiceId: ${testPrivateEndpoint.id}\n      privateEndpointIpAddress: ${testPrivateEndpoint.privateServiceConnection[0].privateIpAddress}\n      providerName: AZURE\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getPrivateLinkEndpointService\n      Arguments:\n        projectId: ${testPrivateLinkEndpointService.projectId}\n        privateLinkId: ${testPrivateLinkEndpointService.privateLinkId}\n        interfaceEndpointId: ${testPrivateLinkEndpointService.interfaceEndpointId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Available complete examples\n- Setup private connection to a MongoDB Atlas Cluster with AWS VPC\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPrivateLinkEndpointService.\n",
                "properties": {
                    "endpointServiceId": {
                        "type": "string",
                        "description": "Unique identifier of the `AWS` or `AZURE` or `GCP` resource.\n",
                        "willReplaceOnChanges": true
                    },
                    "privateLinkId": {
                        "type": "string",
                        "description": "Unique identifier of the private endpoint service for which you want to retrieve a private endpoint.\n",
                        "willReplaceOnChanges": true
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique identifier for the project.\n",
                        "willReplaceOnChanges": true
                    },
                    "providerName": {
                        "type": "string",
                        "description": "Cloud provider for which you want to create a private endpoint. Atlas accepts `AWS` or `AZURE` or `GCP`.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "endpointServiceId",
                    "privateLinkId",
                    "projectId",
                    "providerName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPrivateLinkEndpointService.\n",
                "properties": {
                    "awsConnectionStatus": {
                        "description": "Status of the interface endpoint for AWS.\nReturns one of the following values:\n* `NONE` - Atlas created the network load balancer and VPC endpoint service, but AWS hasnât yet created the VPC endpoint.\n* `PENDING_ACCEPTANCE` - AWS has received the connection request from your VPC endpoint to the Atlas VPC endpoint service.\n* `PENDING` - AWS is establishing the connection between your VPC endpoint and the Atlas VPC endpoint service.\n* `AVAILABLE` - Atlas VPC resources are connected to the VPC endpoint in your VPC. You can connect to Atlas clusters in this region using AWS PrivateLink.\n* `REJECTED` - AWS failed to establish a connection between Atlas VPC resources to the VPC endpoint in your VPC.\n* `DELETING` - Atlas is removing the interface endpoint from the private endpoint connection.\n",
                        "type": "string"
                    },
                    "azureStatus": {
                        "description": "Status of the interface endpoint for AZURE.\nReturns one of the following values:\n* `INITIATING` - Atlas has not yet accepted the connection to your private endpoint.\n* `AVAILABLE` - Atlas approved the connection to your private endpoint.\n* `FAILED` - Atlas failed to accept the connection your private endpoint.\n* `DELETING` - Atlas is removing the connection to your private endpoint from the Private Link service.\n",
                        "type": "string"
                    },
                    "deleteRequested": {
                        "description": "Indicates if Atlas received a request to remove the interface endpoint from the private endpoint connection.\n",
                        "type": "boolean"
                    },
                    "endpointServiceId": {
                        "type": "string"
                    },
                    "endpoints": {
                        "description": "Collection of individual private endpoints that comprise your network endpoint group.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getPrivateLinkEndpointServiceEndpoint:getPrivateLinkEndpointServiceEndpoint"
                        },
                        "type": "array"
                    },
                    "errorMessage": {
                        "description": "Error message pertaining to the interface endpoint. Returns null if there are no errors.\n",
                        "type": "string"
                    },
                    "gcpStatus": {
                        "description": "Status of the interface endpoint for GCP.\nReturns one of the following values:\n* `INITIATING` - Atlas has not yet accepted the connection to your private endpoint.\n* `AVAILABLE` - Atlas approved the connection to your private endpoint.\n* `FAILED` - Atlas failed to accept the connection your private endpoint.\n* `DELETING` - Atlas is removing the connection to your private endpoint from the Private Link service.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "interfaceEndpointId": {
                        "description": "Unique identifier of the interface endpoint.\n",
                        "type": "string"
                    },
                    "privateEndpointConnectionName": {
                        "description": "Name of the connection for this private endpoint that Atlas generates.\n",
                        "type": "string"
                    },
                    "privateEndpointIpAddress": {
                        "description": "Private IP address of the private endpoint network interface.\n",
                        "type": "string"
                    },
                    "privateEndpointResourceId": {
                        "description": "Unique identifier of the private endpoint.\n",
                        "type": "string"
                    },
                    "privateLinkId": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "providerName": {
                        "type": "string"
                    }
                },
                "required": [
                    "awsConnectionStatus",
                    "azureStatus",
                    "deleteRequested",
                    "endpointServiceId",
                    "endpoints",
                    "errorMessage",
                    "gcpStatus",
                    "interfaceEndpointId",
                    "privateEndpointConnectionName",
                    "privateEndpointIpAddress",
                    "privateEndpointResourceId",
                    "privateLinkId",
                    "projectId",
                    "providerName",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getPrivatelinkEndpointServiceDataFederationOnlineArchive:getPrivatelinkEndpointServiceDataFederationOnlineArchive": {
            "description": "## # Data Source: mongodbatlas.PrivatelinkEndpointServiceDataFederationOnlineArchive\n\n`mongodbatlas.PrivatelinkEndpointServiceDataFederationOnlineArchive` describes a Private Endpoint Service resource for Data Federation and Online Archive.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst atlas_project = new mongodbatlas.Project(\"atlas-project\", {\n    orgId: atlasOrgId,\n    name: atlasProjectName,\n});\nconst test = new mongodbatlas.PrivatelinkEndpointServiceDataFederationOnlineArchive(\"test\", {\n    projectId: atlas_project.id,\n    endpointId: \"vpce-046cf43c79424d4c9\",\n    providerName: \"AWS\",\n    comment: \"Test\",\n    region: \"US_EAST_1\",\n    customerEndpointDnsName: \"vpce-046cf43c79424d4c9-nmls2y9k.vpce-svc-0824460b72e1a420e.us-east-1.vpce.amazonaws.com\",\n});\nconst testDataSource = mongodbatlas.getPrivatelinkEndpointServiceDataFederationOnlineArchiveOutput({\n    projectId: atlas_project.id,\n    endpointId: test.endpointId,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\natlas_project = mongodbatlas.Project(\"atlas-project\",\n    org_id=atlas_org_id,\n    name=atlas_project_name)\ntest = mongodbatlas.PrivatelinkEndpointServiceDataFederationOnlineArchive(\"test\",\n    project_id=atlas_project.id,\n    endpoint_id=\"vpce-046cf43c79424d4c9\",\n    provider_name=\"AWS\",\n    comment=\"Test\",\n    region=\"US_EAST_1\",\n    customer_endpoint_dns_name=\"vpce-046cf43c79424d4c9-nmls2y9k.vpce-svc-0824460b72e1a420e.us-east-1.vpce.amazonaws.com\")\ntest_data_source = mongodbatlas.get_privatelink_endpoint_service_data_federation_online_archive_output(project_id=atlas_project.id,\n    endpoint_id=test.endpoint_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var atlas_project = new Mongodbatlas.Project(\"atlas-project\", new()\n    {\n        OrgId = atlasOrgId,\n        Name = atlasProjectName,\n    });\n\n    var test = new Mongodbatlas.PrivatelinkEndpointServiceDataFederationOnlineArchive(\"test\", new()\n    {\n        ProjectId = atlas_project.Id,\n        EndpointId = \"vpce-046cf43c79424d4c9\",\n        ProviderName = \"AWS\",\n        Comment = \"Test\",\n        Region = \"US_EAST_1\",\n        CustomerEndpointDnsName = \"vpce-046cf43c79424d4c9-nmls2y9k.vpce-svc-0824460b72e1a420e.us-east-1.vpce.amazonaws.com\",\n    });\n\n    var testDataSource = Mongodbatlas.GetPrivatelinkEndpointServiceDataFederationOnlineArchive.Invoke(new()\n    {\n        ProjectId = atlas_project.Id,\n        EndpointId = test.EndpointId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewProject(ctx, \"atlas-project\", \u0026mongodbatlas.ProjectArgs{\n\t\t\tOrgId: pulumi.Any(atlasOrgId),\n\t\t\tName:  pulumi.Any(atlasProjectName),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttest, err := mongodbatlas.NewPrivatelinkEndpointServiceDataFederationOnlineArchive(ctx, \"test\", \u0026mongodbatlas.PrivatelinkEndpointServiceDataFederationOnlineArchiveArgs{\n\t\t\tProjectId:               atlas_project.ID(),\n\t\t\tEndpointId:              pulumi.String(\"vpce-046cf43c79424d4c9\"),\n\t\t\tProviderName:            pulumi.String(\"AWS\"),\n\t\t\tComment:                 pulumi.String(\"Test\"),\n\t\t\tRegion:                  pulumi.String(\"US_EAST_1\"),\n\t\t\tCustomerEndpointDnsName: pulumi.String(\"vpce-046cf43c79424d4c9-nmls2y9k.vpce-svc-0824460b72e1a420e.us-east-1.vpce.amazonaws.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupPrivatelinkEndpointServiceDataFederationOnlineArchiveOutput(ctx, mongodbatlas.GetPrivatelinkEndpointServiceDataFederationOnlineArchiveOutputArgs{\n\t\t\tProjectId:  atlas_project.ID(),\n\t\t\tEndpointId: test.EndpointId,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Project;\nimport com.pulumi.mongodbatlas.ProjectArgs;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceDataFederationOnlineArchive;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceDataFederationOnlineArchiveArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetPrivatelinkEndpointServiceDataFederationOnlineArchiveArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var atlas_project = new Project(\"atlas-project\", ProjectArgs.builder()\n            .orgId(atlasOrgId)\n            .name(atlasProjectName)\n            .build());\n\n        var test = new PrivatelinkEndpointServiceDataFederationOnlineArchive(\"test\", PrivatelinkEndpointServiceDataFederationOnlineArchiveArgs.builder()\n            .projectId(atlas_project.id())\n            .endpointId(\"vpce-046cf43c79424d4c9\")\n            .providerName(\"AWS\")\n            .comment(\"Test\")\n            .region(\"US_EAST_1\")\n            .customerEndpointDnsName(\"vpce-046cf43c79424d4c9-nmls2y9k.vpce-svc-0824460b72e1a420e.us-east-1.vpce.amazonaws.com\")\n            .build());\n\n        final var testDataSource = MongodbatlasFunctions.getPrivatelinkEndpointServiceDataFederationOnlineArchive(GetPrivatelinkEndpointServiceDataFederationOnlineArchiveArgs.builder()\n            .projectId(atlas_project.id())\n            .endpointId(test.endpointId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  atlas-project:\n    type: mongodbatlas:Project\n    properties:\n      orgId: ${atlasOrgId}\n      name: ${atlasProjectName}\n  test:\n    type: mongodbatlas:PrivatelinkEndpointServiceDataFederationOnlineArchive\n    properties:\n      projectId: ${[\"atlas-project\"].id}\n      endpointId: vpce-046cf43c79424d4c9\n      providerName: AWS\n      comment: Test\n      region: US_EAST_1\n      customerEndpointDnsName: vpce-046cf43c79424d4c9-nmls2y9k.vpce-svc-0824460b72e1a420e.us-east-1.vpce.amazonaws.com\nvariables:\n  testDataSource:\n    fn::invoke:\n      Function: mongodbatlas:getPrivatelinkEndpointServiceDataFederationOnlineArchive\n      Arguments:\n        projectId: ${[\"atlas-project\"].id}\n        endpointId: ${test.endpointId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPrivatelinkEndpointServiceDataFederationOnlineArchive.\n",
                "properties": {
                    "endpointId": {
                        "type": "string",
                        "description": "Unique 22-character alphanumeric string that identifies the private endpoint. See [Atlas Data Lake supports Amazon Web Services private endpoints using the AWS PrivateLink feature](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation/operation/createDataFederationPrivateEndpoint:~:text=Atlas%20Data%20Lake%20supports%20Amazon%20Web%20Services%20private%20endpoints%20using%20the%20AWS%20PrivateLink%20feature).\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies your project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "endpointId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPrivatelinkEndpointServiceDataFederationOnlineArchive.\n",
                "properties": {
                    "comment": {
                        "description": "Human-readable string to associate with this private endpoint.\n",
                        "type": "string"
                    },
                    "customerEndpointDnsName": {
                        "description": "(Optional) Human-readable label to identify VPC endpoint DNS name.\n",
                        "type": "string"
                    },
                    "endpointId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "providerName": {
                        "description": "Human-readable label that identifies the cloud service provider.\n",
                        "type": "string"
                    },
                    "region": {
                        "description": "Human-readable label to identify the region of VPC endpoint.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).\n",
                        "type": "string"
                    },
                    "type": {
                        "description": "Human-readable label that identifies the resource type associated with this private endpoint.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "comment",
                    "customerEndpointDnsName",
                    "endpointId",
                    "projectId",
                    "providerName",
                    "region",
                    "type",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getPrivatelinkEndpointServiceDataFederationOnlineArchives:getPrivatelinkEndpointServiceDataFederationOnlineArchives": {
            "description": "## # Data Source: mongodbatlas.getPrivatelinkEndpointServiceDataFederationOnlineArchives\n\n`mongodbatlas.getPrivatelinkEndpointServiceDataFederationOnlineArchives` describes Private Endpoint Service resources for Data Federation and Online Archive.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst atlas_project = new mongodbatlas.Project(\"atlas-project\", {\n    orgId: atlasOrgId,\n    name: atlasProjectName,\n});\nconst test = new mongodbatlas.PrivatelinkEndpointServiceDataFederationOnlineArchive(\"test\", {\n    projectId: atlas_project.id,\n    endpointId: \"vpce-046cf43c79424d4c9\",\n    providerName: \"AWS\",\n    comment: \"Test\",\n    region: \"US_EAST_1\",\n    customerEndpointDnsName: \"vpce-046cf43c79424d4c9-nmls2y9k.vpce-svc-0824460b72e1a420e.us-east-1.vpce.amazonaws.com\",\n});\nconst testDataSource = mongodbatlas.getPrivatelinkEndpointServiceDataFederationOnlineArchivesOutput({\n    projectId: atlas_project.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\natlas_project = mongodbatlas.Project(\"atlas-project\",\n    org_id=atlas_org_id,\n    name=atlas_project_name)\ntest = mongodbatlas.PrivatelinkEndpointServiceDataFederationOnlineArchive(\"test\",\n    project_id=atlas_project.id,\n    endpoint_id=\"vpce-046cf43c79424d4c9\",\n    provider_name=\"AWS\",\n    comment=\"Test\",\n    region=\"US_EAST_1\",\n    customer_endpoint_dns_name=\"vpce-046cf43c79424d4c9-nmls2y9k.vpce-svc-0824460b72e1a420e.us-east-1.vpce.amazonaws.com\")\ntest_data_source = mongodbatlas.get_privatelink_endpoint_service_data_federation_online_archives_output(project_id=atlas_project.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var atlas_project = new Mongodbatlas.Project(\"atlas-project\", new()\n    {\n        OrgId = atlasOrgId,\n        Name = atlasProjectName,\n    });\n\n    var test = new Mongodbatlas.PrivatelinkEndpointServiceDataFederationOnlineArchive(\"test\", new()\n    {\n        ProjectId = atlas_project.Id,\n        EndpointId = \"vpce-046cf43c79424d4c9\",\n        ProviderName = \"AWS\",\n        Comment = \"Test\",\n        Region = \"US_EAST_1\",\n        CustomerEndpointDnsName = \"vpce-046cf43c79424d4c9-nmls2y9k.vpce-svc-0824460b72e1a420e.us-east-1.vpce.amazonaws.com\",\n    });\n\n    var testDataSource = Mongodbatlas.GetPrivatelinkEndpointServiceDataFederationOnlineArchives.Invoke(new()\n    {\n        ProjectId = atlas_project.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewProject(ctx, \"atlas-project\", \u0026mongodbatlas.ProjectArgs{\n\t\t\tOrgId: pulumi.Any(atlasOrgId),\n\t\t\tName:  pulumi.Any(atlasProjectName),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewPrivatelinkEndpointServiceDataFederationOnlineArchive(ctx, \"test\", \u0026mongodbatlas.PrivatelinkEndpointServiceDataFederationOnlineArchiveArgs{\n\t\t\tProjectId:               atlas_project.ID(),\n\t\t\tEndpointId:              pulumi.String(\"vpce-046cf43c79424d4c9\"),\n\t\t\tProviderName:            pulumi.String(\"AWS\"),\n\t\t\tComment:                 pulumi.String(\"Test\"),\n\t\t\tRegion:                  pulumi.String(\"US_EAST_1\"),\n\t\t\tCustomerEndpointDnsName: pulumi.String(\"vpce-046cf43c79424d4c9-nmls2y9k.vpce-svc-0824460b72e1a420e.us-east-1.vpce.amazonaws.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupPrivatelinkEndpointServiceDataFederationOnlineArchivesOutput(ctx, mongodbatlas.GetPrivatelinkEndpointServiceDataFederationOnlineArchivesOutputArgs{\n\t\t\tProjectId: atlas_project.ID(),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Project;\nimport com.pulumi.mongodbatlas.ProjectArgs;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceDataFederationOnlineArchive;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceDataFederationOnlineArchiveArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetPrivatelinkEndpointServiceDataFederationOnlineArchivesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var atlas_project = new Project(\"atlas-project\", ProjectArgs.builder()\n            .orgId(atlasOrgId)\n            .name(atlasProjectName)\n            .build());\n\n        var test = new PrivatelinkEndpointServiceDataFederationOnlineArchive(\"test\", PrivatelinkEndpointServiceDataFederationOnlineArchiveArgs.builder()\n            .projectId(atlas_project.id())\n            .endpointId(\"vpce-046cf43c79424d4c9\")\n            .providerName(\"AWS\")\n            .comment(\"Test\")\n            .region(\"US_EAST_1\")\n            .customerEndpointDnsName(\"vpce-046cf43c79424d4c9-nmls2y9k.vpce-svc-0824460b72e1a420e.us-east-1.vpce.amazonaws.com\")\n            .build());\n\n        final var testDataSource = MongodbatlasFunctions.getPrivatelinkEndpointServiceDataFederationOnlineArchives(GetPrivatelinkEndpointServiceDataFederationOnlineArchivesArgs.builder()\n            .projectId(atlas_project.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  atlas-project:\n    type: mongodbatlas:Project\n    properties:\n      orgId: ${atlasOrgId}\n      name: ${atlasProjectName}\n  test:\n    type: mongodbatlas:PrivatelinkEndpointServiceDataFederationOnlineArchive\n    properties:\n      projectId: ${[\"atlas-project\"].id}\n      endpointId: vpce-046cf43c79424d4c9\n      providerName: AWS\n      comment: Test\n      region: US_EAST_1\n      customerEndpointDnsName: vpce-046cf43c79424d4c9-nmls2y9k.vpce-svc-0824460b72e1a420e.us-east-1.vpce.amazonaws.com\nvariables:\n  testDataSource:\n    fn::invoke:\n      Function: mongodbatlas:getPrivatelinkEndpointServiceDataFederationOnlineArchives\n      Arguments:\n        projectId: ${[\"atlas-project\"].id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPrivatelinkEndpointServiceDataFederationOnlineArchives.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies your project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPrivatelinkEndpointServiceDataFederationOnlineArchives.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "description": "A list where each represents a Private Endpoint Service\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getPrivatelinkEndpointServiceDataFederationOnlineArchivesResult:getPrivatelinkEndpointServiceDataFederationOnlineArchivesResult"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "projectId",
                    "results",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getPrivatelinkEndpointServiceServerless:getPrivatelinkEndpointServiceServerless": {
            "description": "## # Data Source: privatelink_endpoint_service_serverless\n\n`privatelink_endpoint_service_serverless` provides a Serverless PrivateLink Endpoint Service resource.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n## Example with AWS\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testServerlessInstance = new mongodbatlas.ServerlessInstance(\"test\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    name: \"test-db\",\n    providerSettingsBackingProviderName: \"AWS\",\n    providerSettingsProviderName: \"SERVERLESS\",\n    providerSettingsRegionName: \"US_EAST_1\",\n    continuousBackupEnabled: true,\n});\nconst testPrivatelinkEndpointServerless = new mongodbatlas.PrivatelinkEndpointServerless(\"test\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: testServerlessInstance.name,\n    providerName: \"AWS\",\n});\nconst test = mongodbatlas.getPrivatelinkEndpointServiceServerlessOutput({\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: testServerlessInstance.name,\n    endpointId: testPrivatelinkEndpointServerless.endpointId,\n});\nconst testPrivatelinkEndpointServiceServerless = new mongodbatlas.PrivatelinkEndpointServiceServerless(\"test\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: \"test-db\",\n    endpointId: testPrivatelinkEndpointServerless.endpointId,\n    providerName: \"AWS\",\n    comment: \"New serverless endpoint\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_serverless_instance = mongodbatlas.ServerlessInstance(\"test\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    name=\"test-db\",\n    provider_settings_backing_provider_name=\"AWS\",\n    provider_settings_provider_name=\"SERVERLESS\",\n    provider_settings_region_name=\"US_EAST_1\",\n    continuous_backup_enabled=True)\ntest_privatelink_endpoint_serverless = mongodbatlas.PrivatelinkEndpointServerless(\"test\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=test_serverless_instance.name,\n    provider_name=\"AWS\")\ntest = mongodbatlas.get_privatelink_endpoint_service_serverless_output(project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=test_serverless_instance.name,\n    endpoint_id=test_privatelink_endpoint_serverless.endpoint_id)\ntest_privatelink_endpoint_service_serverless = mongodbatlas.PrivatelinkEndpointServiceServerless(\"test\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=\"test-db\",\n    endpoint_id=test_privatelink_endpoint_serverless.endpoint_id,\n    provider_name=\"AWS\",\n    comment=\"New serverless endpoint\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testServerlessInstance = new Mongodbatlas.ServerlessInstance(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        Name = \"test-db\",\n        ProviderSettingsBackingProviderName = \"AWS\",\n        ProviderSettingsProviderName = \"SERVERLESS\",\n        ProviderSettingsRegionName = \"US_EAST_1\",\n        ContinuousBackupEnabled = true,\n    });\n\n    var testPrivatelinkEndpointServerless = new Mongodbatlas.PrivatelinkEndpointServerless(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = testServerlessInstance.Name,\n        ProviderName = \"AWS\",\n    });\n\n    var test = Mongodbatlas.GetPrivatelinkEndpointServiceServerless.Invoke(new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = testServerlessInstance.Name,\n        EndpointId = testPrivatelinkEndpointServerless.EndpointId,\n    });\n\n    var testPrivatelinkEndpointServiceServerless = new Mongodbatlas.PrivatelinkEndpointServiceServerless(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = \"test-db\",\n        EndpointId = testPrivatelinkEndpointServerless.EndpointId,\n        ProviderName = \"AWS\",\n        Comment = \"New serverless endpoint\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestServerlessInstance, err := mongodbatlas.NewServerlessInstance(ctx, \"test\", \u0026mongodbatlas.ServerlessInstanceArgs{\n\t\t\tProjectId:                           pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tName:                                pulumi.String(\"test-db\"),\n\t\t\tProviderSettingsBackingProviderName: pulumi.String(\"AWS\"),\n\t\t\tProviderSettingsProviderName:        pulumi.String(\"SERVERLESS\"),\n\t\t\tProviderSettingsRegionName:          pulumi.String(\"US_EAST_1\"),\n\t\t\tContinuousBackupEnabled:             pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestPrivatelinkEndpointServerless, err := mongodbatlas.NewPrivatelinkEndpointServerless(ctx, \"test\", \u0026mongodbatlas.PrivatelinkEndpointServerlessArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tInstanceName: testServerlessInstance.Name,\n\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupPrivatelinkEndpointServiceServerlessOutput(ctx, mongodbatlas.GetPrivatelinkEndpointServiceServerlessOutputArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tInstanceName: testServerlessInstance.Name,\n\t\t\tEndpointId:   testPrivatelinkEndpointServerless.EndpointId,\n\t\t}, nil)\n\t\t_, err = mongodbatlas.NewPrivatelinkEndpointServiceServerless(ctx, \"test\", \u0026mongodbatlas.PrivatelinkEndpointServiceServerlessArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tInstanceName: pulumi.String(\"test-db\"),\n\t\t\tEndpointId:   testPrivatelinkEndpointServerless.EndpointId,\n\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\tComment:      pulumi.String(\"New serverless endpoint\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ServerlessInstance;\nimport com.pulumi.mongodbatlas.ServerlessInstanceArgs;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServerless;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServerlessArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetPrivatelinkEndpointServiceServerlessArgs;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceServerless;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceServerlessArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testServerlessInstance = new ServerlessInstance(\"testServerlessInstance\", ServerlessInstanceArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .name(\"test-db\")\n            .providerSettingsBackingProviderName(\"AWS\")\n            .providerSettingsProviderName(\"SERVERLESS\")\n            .providerSettingsRegionName(\"US_EAST_1\")\n            .continuousBackupEnabled(true)\n            .build());\n\n        var testPrivatelinkEndpointServerless = new PrivatelinkEndpointServerless(\"testPrivatelinkEndpointServerless\", PrivatelinkEndpointServerlessArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(testServerlessInstance.name())\n            .providerName(\"AWS\")\n            .build());\n\n        final var test = MongodbatlasFunctions.getPrivatelinkEndpointServiceServerless(GetPrivatelinkEndpointServiceServerlessArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(testServerlessInstance.name())\n            .endpointId(testPrivatelinkEndpointServerless.endpointId())\n            .build());\n\n        var testPrivatelinkEndpointServiceServerless = new PrivatelinkEndpointServiceServerless(\"testPrivatelinkEndpointServiceServerless\", PrivatelinkEndpointServiceServerlessArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(\"test-db\")\n            .endpointId(testPrivatelinkEndpointServerless.endpointId())\n            .providerName(\"AWS\")\n            .comment(\"New serverless endpoint\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testPrivatelinkEndpointServerless:\n    type: mongodbatlas:PrivatelinkEndpointServerless\n    name: test\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      instanceName: ${testServerlessInstance.name}\n      providerName: AWS\n  testPrivatelinkEndpointServiceServerless:\n    type: mongodbatlas:PrivatelinkEndpointServiceServerless\n    name: test\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      instanceName: test-db\n      endpointId: ${testPrivatelinkEndpointServerless.endpointId}\n      providerName: AWS\n      comment: New serverless endpoint\n  testServerlessInstance:\n    type: mongodbatlas:ServerlessInstance\n    name: test\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      name: test-db\n      providerSettingsBackingProviderName: AWS\n      providerSettingsProviderName: SERVERLESS\n      providerSettingsRegionName: US_EAST_1\n      continuousBackupEnabled: true\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getPrivatelinkEndpointServiceServerless\n      Arguments:\n        projectId: \u003cPROJECT_ID\u003e\n        instanceName: ${testServerlessInstance.name}\n        endpointId: ${testPrivatelinkEndpointServerless.endpointId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Example with AZURE\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testServerlessInstance = new mongodbatlas.ServerlessInstance(\"test\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    name: \"test-db\",\n    providerSettingsBackingProviderName: \"AZURE\",\n    providerSettingsProviderName: \"SERVERLESS\",\n    providerSettingsRegionName: \"US_EAST\",\n    continuousBackupEnabled: true,\n});\nconst testPrivatelinkEndpointServerless = new mongodbatlas.PrivatelinkEndpointServerless(\"test\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: testServerlessInstance.name,\n    providerName: \"AZURE\",\n});\nconst test = mongodbatlas.getPrivatelinkEndpointServiceServerlessOutput({\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: testServerlessInstance.name,\n    endpointId: testPrivatelinkEndpointServerless.endpointId,\n});\nconst testPrivatelinkEndpointServiceServerless = new mongodbatlas.PrivatelinkEndpointServiceServerless(\"test\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: \"test-db\",\n    endpointId: testPrivatelinkEndpointServerless.endpointId,\n    providerName: \"AZURE\",\n    comment: \"New serverless endpoint\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_serverless_instance = mongodbatlas.ServerlessInstance(\"test\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    name=\"test-db\",\n    provider_settings_backing_provider_name=\"AZURE\",\n    provider_settings_provider_name=\"SERVERLESS\",\n    provider_settings_region_name=\"US_EAST\",\n    continuous_backup_enabled=True)\ntest_privatelink_endpoint_serverless = mongodbatlas.PrivatelinkEndpointServerless(\"test\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=test_serverless_instance.name,\n    provider_name=\"AZURE\")\ntest = mongodbatlas.get_privatelink_endpoint_service_serverless_output(project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=test_serverless_instance.name,\n    endpoint_id=test_privatelink_endpoint_serverless.endpoint_id)\ntest_privatelink_endpoint_service_serverless = mongodbatlas.PrivatelinkEndpointServiceServerless(\"test\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=\"test-db\",\n    endpoint_id=test_privatelink_endpoint_serverless.endpoint_id,\n    provider_name=\"AZURE\",\n    comment=\"New serverless endpoint\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testServerlessInstance = new Mongodbatlas.ServerlessInstance(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        Name = \"test-db\",\n        ProviderSettingsBackingProviderName = \"AZURE\",\n        ProviderSettingsProviderName = \"SERVERLESS\",\n        ProviderSettingsRegionName = \"US_EAST\",\n        ContinuousBackupEnabled = true,\n    });\n\n    var testPrivatelinkEndpointServerless = new Mongodbatlas.PrivatelinkEndpointServerless(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = testServerlessInstance.Name,\n        ProviderName = \"AZURE\",\n    });\n\n    var test = Mongodbatlas.GetPrivatelinkEndpointServiceServerless.Invoke(new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = testServerlessInstance.Name,\n        EndpointId = testPrivatelinkEndpointServerless.EndpointId,\n    });\n\n    var testPrivatelinkEndpointServiceServerless = new Mongodbatlas.PrivatelinkEndpointServiceServerless(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = \"test-db\",\n        EndpointId = testPrivatelinkEndpointServerless.EndpointId,\n        ProviderName = \"AZURE\",\n        Comment = \"New serverless endpoint\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestServerlessInstance, err := mongodbatlas.NewServerlessInstance(ctx, \"test\", \u0026mongodbatlas.ServerlessInstanceArgs{\n\t\t\tProjectId:                           pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tName:                                pulumi.String(\"test-db\"),\n\t\t\tProviderSettingsBackingProviderName: pulumi.String(\"AZURE\"),\n\t\t\tProviderSettingsProviderName:        pulumi.String(\"SERVERLESS\"),\n\t\t\tProviderSettingsRegionName:          pulumi.String(\"US_EAST\"),\n\t\t\tContinuousBackupEnabled:             pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestPrivatelinkEndpointServerless, err := mongodbatlas.NewPrivatelinkEndpointServerless(ctx, \"test\", \u0026mongodbatlas.PrivatelinkEndpointServerlessArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tInstanceName: testServerlessInstance.Name,\n\t\t\tProviderName: pulumi.String(\"AZURE\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupPrivatelinkEndpointServiceServerlessOutput(ctx, mongodbatlas.GetPrivatelinkEndpointServiceServerlessOutputArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tInstanceName: testServerlessInstance.Name,\n\t\t\tEndpointId:   testPrivatelinkEndpointServerless.EndpointId,\n\t\t}, nil)\n\t\t_, err = mongodbatlas.NewPrivatelinkEndpointServiceServerless(ctx, \"test\", \u0026mongodbatlas.PrivatelinkEndpointServiceServerlessArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tInstanceName: pulumi.String(\"test-db\"),\n\t\t\tEndpointId:   testPrivatelinkEndpointServerless.EndpointId,\n\t\t\tProviderName: pulumi.String(\"AZURE\"),\n\t\t\tComment:      pulumi.String(\"New serverless endpoint\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ServerlessInstance;\nimport com.pulumi.mongodbatlas.ServerlessInstanceArgs;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServerless;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServerlessArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetPrivatelinkEndpointServiceServerlessArgs;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceServerless;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceServerlessArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testServerlessInstance = new ServerlessInstance(\"testServerlessInstance\", ServerlessInstanceArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .name(\"test-db\")\n            .providerSettingsBackingProviderName(\"AZURE\")\n            .providerSettingsProviderName(\"SERVERLESS\")\n            .providerSettingsRegionName(\"US_EAST\")\n            .continuousBackupEnabled(true)\n            .build());\n\n        var testPrivatelinkEndpointServerless = new PrivatelinkEndpointServerless(\"testPrivatelinkEndpointServerless\", PrivatelinkEndpointServerlessArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(testServerlessInstance.name())\n            .providerName(\"AZURE\")\n            .build());\n\n        final var test = MongodbatlasFunctions.getPrivatelinkEndpointServiceServerless(GetPrivatelinkEndpointServiceServerlessArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(testServerlessInstance.name())\n            .endpointId(testPrivatelinkEndpointServerless.endpointId())\n            .build());\n\n        var testPrivatelinkEndpointServiceServerless = new PrivatelinkEndpointServiceServerless(\"testPrivatelinkEndpointServiceServerless\", PrivatelinkEndpointServiceServerlessArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(\"test-db\")\n            .endpointId(testPrivatelinkEndpointServerless.endpointId())\n            .providerName(\"AZURE\")\n            .comment(\"New serverless endpoint\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testPrivatelinkEndpointServerless:\n    type: mongodbatlas:PrivatelinkEndpointServerless\n    name: test\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      instanceName: ${testServerlessInstance.name}\n      providerName: AZURE\n  testPrivatelinkEndpointServiceServerless:\n    type: mongodbatlas:PrivatelinkEndpointServiceServerless\n    name: test\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      instanceName: test-db\n      endpointId: ${testPrivatelinkEndpointServerless.endpointId}\n      providerName: AZURE\n      comment: New serverless endpoint\n  testServerlessInstance:\n    type: mongodbatlas:ServerlessInstance\n    name: test\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      name: test-db\n      providerSettingsBackingProviderName: AZURE\n      providerSettingsProviderName: SERVERLESS\n      providerSettingsRegionName: US_EAST\n      continuousBackupEnabled: true\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getPrivatelinkEndpointServiceServerless\n      Arguments:\n        projectId: \u003cPROJECT_ID\u003e\n        instanceName: ${testServerlessInstance.name}\n        endpointId: ${testPrivatelinkEndpointServerless.endpointId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Available complete examples\n- Setup private connection to a MongoDB Atlas Serverless Instance with AWS VPC\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPrivatelinkEndpointServiceServerless.\n",
                "properties": {
                    "endpointId": {
                        "type": "string",
                        "description": "Unique 22-character alphanumeric string that identifies the private endpoint. Atlas supports AWS private endpoints using the [AWS PrivateLink](https://aws.amazon.com/privatelink/) feature.\n",
                        "willReplaceOnChanges": true
                    },
                    "instanceName": {
                        "type": "string",
                        "description": "Human-readable label that identifies the serverless instance\n",
                        "willReplaceOnChanges": true
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-digit hexadecimal string that identifies the project.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "endpointId",
                    "instanceName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPrivatelinkEndpointServiceServerless.\n",
                "properties": {
                    "cloudProviderEndpointId": {
                        "type": "string"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "endpointId": {
                        "type": "string"
                    },
                    "endpointServiceName": {
                        "description": "Unique string that identifies the PrivateLink endpoint service. MongoDB Cloud returns null while it creates the endpoint service.\n",
                        "type": "string"
                    },
                    "errorMessage": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "instanceName": {
                        "type": "string"
                    },
                    "privateEndpointIpAddress": {
                        "description": "IPv4 address of the private endpoint in your Azure VNet that someone added to this private endpoint service.\n",
                        "type": "string"
                    },
                    "privateLinkServiceResourceId": {
                        "description": "Root-relative path that identifies the Azure Private Link Service that MongoDB Cloud manages.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "status": {
                        "description": "Human-readable label that indicates the current operating status of the private endpoint. Values include: RESERVATION_REQUESTED, RESERVED, INITIATING, AVAILABLE, FAILED, DELETING.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "cloudProviderEndpointId",
                    "comment",
                    "endpointId",
                    "endpointServiceName",
                    "errorMessage",
                    "instanceName",
                    "privateEndpointIpAddress",
                    "privateLinkServiceResourceId",
                    "projectId",
                    "status",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getPrivatelinkEndpointsServiceServerless:getPrivatelinkEndpointsServiceServerless": {
            "description": "## # Data Source: privatelink_endpoints_service_serverless\n\n`privatelink_endpoints_service_serverless` describes the list of all Serverless PrivateLink Endpoint Service resource.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n## Example with AWS\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testServerlessInstance = new mongodbatlas.ServerlessInstance(\"test\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    name: \"test-db\",\n    providerSettingsBackingProviderName: \"AWS\",\n    providerSettingsProviderName: \"SERVERLESS\",\n    providerSettingsRegionName: \"US_EAST_1\",\n    continuousBackupEnabled: true,\n});\nconst test = mongodbatlas.getPrivatelinkEndpointsServiceServerlessOutput({\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: testServerlessInstance.name,\n});\nconst testPrivatelinkEndpointServerless = new mongodbatlas.PrivatelinkEndpointServerless(\"test\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: testServerlessInstance.name,\n    providerName: \"AWS\",\n});\nconst testPrivatelinkEndpointServiceServerless = new mongodbatlas.PrivatelinkEndpointServiceServerless(\"test\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: \"test-db\",\n    endpointId: testPrivatelinkEndpointServerless.endpointId,\n    providerName: \"AWS\",\n    comment: \"New serverless endpoint\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_serverless_instance = mongodbatlas.ServerlessInstance(\"test\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    name=\"test-db\",\n    provider_settings_backing_provider_name=\"AWS\",\n    provider_settings_provider_name=\"SERVERLESS\",\n    provider_settings_region_name=\"US_EAST_1\",\n    continuous_backup_enabled=True)\ntest = mongodbatlas.get_privatelink_endpoints_service_serverless_output(project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=test_serverless_instance.name)\ntest_privatelink_endpoint_serverless = mongodbatlas.PrivatelinkEndpointServerless(\"test\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=test_serverless_instance.name,\n    provider_name=\"AWS\")\ntest_privatelink_endpoint_service_serverless = mongodbatlas.PrivatelinkEndpointServiceServerless(\"test\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=\"test-db\",\n    endpoint_id=test_privatelink_endpoint_serverless.endpoint_id,\n    provider_name=\"AWS\",\n    comment=\"New serverless endpoint\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testServerlessInstance = new Mongodbatlas.ServerlessInstance(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        Name = \"test-db\",\n        ProviderSettingsBackingProviderName = \"AWS\",\n        ProviderSettingsProviderName = \"SERVERLESS\",\n        ProviderSettingsRegionName = \"US_EAST_1\",\n        ContinuousBackupEnabled = true,\n    });\n\n    var test = Mongodbatlas.GetPrivatelinkEndpointsServiceServerless.Invoke(new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = testServerlessInstance.Name,\n    });\n\n    var testPrivatelinkEndpointServerless = new Mongodbatlas.PrivatelinkEndpointServerless(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = testServerlessInstance.Name,\n        ProviderName = \"AWS\",\n    });\n\n    var testPrivatelinkEndpointServiceServerless = new Mongodbatlas.PrivatelinkEndpointServiceServerless(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = \"test-db\",\n        EndpointId = testPrivatelinkEndpointServerless.EndpointId,\n        ProviderName = \"AWS\",\n        Comment = \"New serverless endpoint\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestServerlessInstance, err := mongodbatlas.NewServerlessInstance(ctx, \"test\", \u0026mongodbatlas.ServerlessInstanceArgs{\n\t\t\tProjectId:                           pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tName:                                pulumi.String(\"test-db\"),\n\t\t\tProviderSettingsBackingProviderName: pulumi.String(\"AWS\"),\n\t\t\tProviderSettingsProviderName:        pulumi.String(\"SERVERLESS\"),\n\t\t\tProviderSettingsRegionName:          pulumi.String(\"US_EAST_1\"),\n\t\t\tContinuousBackupEnabled:             pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupPrivatelinkEndpointsServiceServerlessOutput(ctx, mongodbatlas.GetPrivatelinkEndpointsServiceServerlessOutputArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tInstanceName: testServerlessInstance.Name,\n\t\t}, nil)\n\t\ttestPrivatelinkEndpointServerless, err := mongodbatlas.NewPrivatelinkEndpointServerless(ctx, \"test\", \u0026mongodbatlas.PrivatelinkEndpointServerlessArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tInstanceName: testServerlessInstance.Name,\n\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewPrivatelinkEndpointServiceServerless(ctx, \"test\", \u0026mongodbatlas.PrivatelinkEndpointServiceServerlessArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tInstanceName: pulumi.String(\"test-db\"),\n\t\t\tEndpointId:   testPrivatelinkEndpointServerless.EndpointId,\n\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t\tComment:      pulumi.String(\"New serverless endpoint\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ServerlessInstance;\nimport com.pulumi.mongodbatlas.ServerlessInstanceArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetPrivatelinkEndpointsServiceServerlessArgs;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServerless;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServerlessArgs;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceServerless;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceServerlessArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testServerlessInstance = new ServerlessInstance(\"testServerlessInstance\", ServerlessInstanceArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .name(\"test-db\")\n            .providerSettingsBackingProviderName(\"AWS\")\n            .providerSettingsProviderName(\"SERVERLESS\")\n            .providerSettingsRegionName(\"US_EAST_1\")\n            .continuousBackupEnabled(true)\n            .build());\n\n        final var test = MongodbatlasFunctions.getPrivatelinkEndpointsServiceServerless(GetPrivatelinkEndpointsServiceServerlessArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(testServerlessInstance.name())\n            .build());\n\n        var testPrivatelinkEndpointServerless = new PrivatelinkEndpointServerless(\"testPrivatelinkEndpointServerless\", PrivatelinkEndpointServerlessArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(testServerlessInstance.name())\n            .providerName(\"AWS\")\n            .build());\n\n        var testPrivatelinkEndpointServiceServerless = new PrivatelinkEndpointServiceServerless(\"testPrivatelinkEndpointServiceServerless\", PrivatelinkEndpointServiceServerlessArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(\"test-db\")\n            .endpointId(testPrivatelinkEndpointServerless.endpointId())\n            .providerName(\"AWS\")\n            .comment(\"New serverless endpoint\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testPrivatelinkEndpointServerless:\n    type: mongodbatlas:PrivatelinkEndpointServerless\n    name: test\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      instanceName: ${testServerlessInstance.name}\n      providerName: AWS\n  testPrivatelinkEndpointServiceServerless:\n    type: mongodbatlas:PrivatelinkEndpointServiceServerless\n    name: test\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      instanceName: test-db\n      endpointId: ${testPrivatelinkEndpointServerless.endpointId}\n      providerName: AWS\n      comment: New serverless endpoint\n  testServerlessInstance:\n    type: mongodbatlas:ServerlessInstance\n    name: test\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      name: test-db\n      providerSettingsBackingProviderName: AWS\n      providerSettingsProviderName: SERVERLESS\n      providerSettingsRegionName: US_EAST_1\n      continuousBackupEnabled: true\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getPrivatelinkEndpointsServiceServerless\n      Arguments:\n        projectId: \u003cPROJECT_ID\u003e\n        instanceName: ${testServerlessInstance.name}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Example with AZURE\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testServerlessInstance = new mongodbatlas.ServerlessInstance(\"test\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    name: \"test-db\",\n    providerSettingsBackingProviderName: \"AZURE\",\n    providerSettingsProviderName: \"SERVERLESS\",\n    providerSettingsRegionName: \"US_EAST\",\n    continuousBackupEnabled: true,\n});\nconst test = mongodbatlas.getPrivatelinkEndpointsServiceServerlessOutput({\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: testServerlessInstance.name,\n});\nconst testPrivatelinkEndpointServerless = new mongodbatlas.PrivatelinkEndpointServerless(\"test\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: testServerlessInstance.name,\n    providerName: \"AZURE\",\n});\nconst testPrivatelinkEndpointServiceServerless = new mongodbatlas.PrivatelinkEndpointServiceServerless(\"test\", {\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: \"test-db\",\n    endpointId: testPrivatelinkEndpointServerless.endpointId,\n    providerName: \"AZURE\",\n    comment: \"New serverless endpoint\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_serverless_instance = mongodbatlas.ServerlessInstance(\"test\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    name=\"test-db\",\n    provider_settings_backing_provider_name=\"AZURE\",\n    provider_settings_provider_name=\"SERVERLESS\",\n    provider_settings_region_name=\"US_EAST\",\n    continuous_backup_enabled=True)\ntest = mongodbatlas.get_privatelink_endpoints_service_serverless_output(project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=test_serverless_instance.name)\ntest_privatelink_endpoint_serverless = mongodbatlas.PrivatelinkEndpointServerless(\"test\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=test_serverless_instance.name,\n    provider_name=\"AZURE\")\ntest_privatelink_endpoint_service_serverless = mongodbatlas.PrivatelinkEndpointServiceServerless(\"test\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=\"test-db\",\n    endpoint_id=test_privatelink_endpoint_serverless.endpoint_id,\n    provider_name=\"AZURE\",\n    comment=\"New serverless endpoint\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testServerlessInstance = new Mongodbatlas.ServerlessInstance(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        Name = \"test-db\",\n        ProviderSettingsBackingProviderName = \"AZURE\",\n        ProviderSettingsProviderName = \"SERVERLESS\",\n        ProviderSettingsRegionName = \"US_EAST\",\n        ContinuousBackupEnabled = true,\n    });\n\n    var test = Mongodbatlas.GetPrivatelinkEndpointsServiceServerless.Invoke(new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = testServerlessInstance.Name,\n    });\n\n    var testPrivatelinkEndpointServerless = new Mongodbatlas.PrivatelinkEndpointServerless(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = testServerlessInstance.Name,\n        ProviderName = \"AZURE\",\n    });\n\n    var testPrivatelinkEndpointServiceServerless = new Mongodbatlas.PrivatelinkEndpointServiceServerless(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = \"test-db\",\n        EndpointId = testPrivatelinkEndpointServerless.EndpointId,\n        ProviderName = \"AZURE\",\n        Comment = \"New serverless endpoint\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestServerlessInstance, err := mongodbatlas.NewServerlessInstance(ctx, \"test\", \u0026mongodbatlas.ServerlessInstanceArgs{\n\t\t\tProjectId:                           pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tName:                                pulumi.String(\"test-db\"),\n\t\t\tProviderSettingsBackingProviderName: pulumi.String(\"AZURE\"),\n\t\t\tProviderSettingsProviderName:        pulumi.String(\"SERVERLESS\"),\n\t\t\tProviderSettingsRegionName:          pulumi.String(\"US_EAST\"),\n\t\t\tContinuousBackupEnabled:             pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupPrivatelinkEndpointsServiceServerlessOutput(ctx, mongodbatlas.GetPrivatelinkEndpointsServiceServerlessOutputArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tInstanceName: testServerlessInstance.Name,\n\t\t}, nil)\n\t\ttestPrivatelinkEndpointServerless, err := mongodbatlas.NewPrivatelinkEndpointServerless(ctx, \"test\", \u0026mongodbatlas.PrivatelinkEndpointServerlessArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tInstanceName: testServerlessInstance.Name,\n\t\t\tProviderName: pulumi.String(\"AZURE\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewPrivatelinkEndpointServiceServerless(ctx, \"test\", \u0026mongodbatlas.PrivatelinkEndpointServiceServerlessArgs{\n\t\t\tProjectId:    pulumi.String(\"\u003cPROJECT_ID\u003e\"),\n\t\t\tInstanceName: pulumi.String(\"test-db\"),\n\t\t\tEndpointId:   testPrivatelinkEndpointServerless.EndpointId,\n\t\t\tProviderName: pulumi.String(\"AZURE\"),\n\t\t\tComment:      pulumi.String(\"New serverless endpoint\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ServerlessInstance;\nimport com.pulumi.mongodbatlas.ServerlessInstanceArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetPrivatelinkEndpointsServiceServerlessArgs;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServerless;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServerlessArgs;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceServerless;\nimport com.pulumi.mongodbatlas.PrivatelinkEndpointServiceServerlessArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testServerlessInstance = new ServerlessInstance(\"testServerlessInstance\", ServerlessInstanceArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .name(\"test-db\")\n            .providerSettingsBackingProviderName(\"AZURE\")\n            .providerSettingsProviderName(\"SERVERLESS\")\n            .providerSettingsRegionName(\"US_EAST\")\n            .continuousBackupEnabled(true)\n            .build());\n\n        final var test = MongodbatlasFunctions.getPrivatelinkEndpointsServiceServerless(GetPrivatelinkEndpointsServiceServerlessArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(testServerlessInstance.name())\n            .build());\n\n        var testPrivatelinkEndpointServerless = new PrivatelinkEndpointServerless(\"testPrivatelinkEndpointServerless\", PrivatelinkEndpointServerlessArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(testServerlessInstance.name())\n            .providerName(\"AZURE\")\n            .build());\n\n        var testPrivatelinkEndpointServiceServerless = new PrivatelinkEndpointServiceServerless(\"testPrivatelinkEndpointServiceServerless\", PrivatelinkEndpointServiceServerlessArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(\"test-db\")\n            .endpointId(testPrivatelinkEndpointServerless.endpointId())\n            .providerName(\"AZURE\")\n            .comment(\"New serverless endpoint\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testPrivatelinkEndpointServerless:\n    type: mongodbatlas:PrivatelinkEndpointServerless\n    name: test\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      instanceName: ${testServerlessInstance.name}\n      providerName: AZURE\n  testPrivatelinkEndpointServiceServerless:\n    type: mongodbatlas:PrivatelinkEndpointServiceServerless\n    name: test\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      instanceName: test-db\n      endpointId: ${testPrivatelinkEndpointServerless.endpointId}\n      providerName: AZURE\n      comment: New serverless endpoint\n  testServerlessInstance:\n    type: mongodbatlas:ServerlessInstance\n    name: test\n    properties:\n      projectId: \u003cPROJECT_ID\u003e\n      name: test-db\n      providerSettingsBackingProviderName: AZURE\n      providerSettingsProviderName: SERVERLESS\n      providerSettingsRegionName: US_EAST\n      continuousBackupEnabled: true\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getPrivatelinkEndpointsServiceServerless\n      Arguments:\n        projectId: \u003cPROJECT_ID\u003e\n        instanceName: ${testServerlessInstance.name}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPrivatelinkEndpointsServiceServerless.\n",
                "properties": {
                    "instanceName": {
                        "type": "string",
                        "description": "Human-readable label that identifies the serverless instance\n",
                        "willReplaceOnChanges": true
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-digit hexadecimal string that identifies the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "instanceName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPrivatelinkEndpointsServiceServerless.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "instanceName": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "description": "Each element in the `result` array is one private serverless endpoint.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getPrivatelinkEndpointsServiceServerlessResult:getPrivatelinkEndpointsServiceServerlessResult"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "instanceName",
                    "projectId",
                    "results",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getProject:getProject": {
            "description": "## # Data Source: mongodbatlas.Project\n\n`mongodbatlas.Project` describes a MongoDB Atlas Project. This represents a project that has been created.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n## Example Usage\n\n### Using project_id attribute to query\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = mongodbatlas.getRolesOrgId({});\nconst testProject = new mongodbatlas.Project(\"test\", {\n    name: \"project-name\",\n    orgId: test.then(test =\u003e test.orgId),\n    teams: [\n        {\n            teamId: \"5e0fa8c99ccf641c722fe645\",\n            roleNames: [\"GROUP_OWNER\"],\n        },\n        {\n            teamId: \"5e1dd7b4f2a30ba80a70cd4rw\",\n            roleNames: [\n                \"GROUP_READ_ONLY\",\n                \"GROUP_DATA_ACCESS_READ_WRITE\",\n            ],\n        },\n    ],\n    limits: [{\n        name: \"atlas.project.deployment.clusters\",\n        value: 26,\n    }],\n});\nconst testGetProject = mongodbatlas.getProjectOutput({\n    projectId: testProject.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.get_roles_org_id()\ntest_project = mongodbatlas.Project(\"test\",\n    name=\"project-name\",\n    org_id=test.org_id,\n    teams=[\n        {\n            \"team_id\": \"5e0fa8c99ccf641c722fe645\",\n            \"role_names\": [\"GROUP_OWNER\"],\n        },\n        {\n            \"team_id\": \"5e1dd7b4f2a30ba80a70cd4rw\",\n            \"role_names\": [\n                \"GROUP_READ_ONLY\",\n                \"GROUP_DATA_ACCESS_READ_WRITE\",\n            ],\n        },\n    ],\n    limits=[{\n        \"name\": \"atlas.project.deployment.clusters\",\n        \"value\": 26,\n    }])\ntest_get_project = mongodbatlas.get_project_output(project_id=test_project.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Mongodbatlas.GetRolesOrgId.Invoke();\n\n    var testProject = new Mongodbatlas.Project(\"test\", new()\n    {\n        Name = \"project-name\",\n        OrgId = test.Apply(getRolesOrgIdResult =\u003e getRolesOrgIdResult.OrgId),\n        Teams = new[]\n        {\n            new Mongodbatlas.Inputs.ProjectTeamArgs\n            {\n                TeamId = \"5e0fa8c99ccf641c722fe645\",\n                RoleNames = new[]\n                {\n                    \"GROUP_OWNER\",\n                },\n            },\n            new Mongodbatlas.Inputs.ProjectTeamArgs\n            {\n                TeamId = \"5e1dd7b4f2a30ba80a70cd4rw\",\n                RoleNames = new[]\n                {\n                    \"GROUP_READ_ONLY\",\n                    \"GROUP_DATA_ACCESS_READ_WRITE\",\n                },\n            },\n        },\n        Limits = new[]\n        {\n            new Mongodbatlas.Inputs.ProjectLimitArgs\n            {\n                Name = \"atlas.project.deployment.clusters\",\n                Value = 26,\n            },\n        },\n    });\n\n    var testGetProject = Mongodbatlas.GetProject.Invoke(new()\n    {\n        ProjectId = testProject.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := mongodbatlas.GetRolesOrgId(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestProject, err := mongodbatlas.NewProject(ctx, \"test\", \u0026mongodbatlas.ProjectArgs{\n\t\t\tName:  pulumi.String(\"project-name\"),\n\t\t\tOrgId: pulumi.String(test.OrgId),\n\t\t\tTeams: mongodbatlas.ProjectTeamArray{\n\t\t\t\t\u0026mongodbatlas.ProjectTeamArgs{\n\t\t\t\t\tTeamId: pulumi.String(\"5e0fa8c99ccf641c722fe645\"),\n\t\t\t\t\tRoleNames: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_OWNER\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.ProjectTeamArgs{\n\t\t\t\t\tTeamId: pulumi.String(\"5e1dd7b4f2a30ba80a70cd4rw\"),\n\t\t\t\t\tRoleNames: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_READ_ONLY\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_READ_WRITE\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tLimits: mongodbatlas.ProjectLimitArray{\n\t\t\t\t\u0026mongodbatlas.ProjectLimitArgs{\n\t\t\t\t\tName:  pulumi.String(\"atlas.project.deployment.clusters\"),\n\t\t\t\t\tValue: pulumi.Int(26),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupProjectOutput(ctx, mongodbatlas.GetProjectOutputArgs{\n\t\t\tProjectId: testProject.ID(),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.Project;\nimport com.pulumi.mongodbatlas.ProjectArgs;\nimport com.pulumi.mongodbatlas.inputs.ProjectTeamArgs;\nimport com.pulumi.mongodbatlas.inputs.ProjectLimitArgs;\nimport com.pulumi.mongodbatlas.inputs.GetProjectArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getRolesOrgId();\n\n        var testProject = new Project(\"testProject\", ProjectArgs.builder()\n            .name(\"project-name\")\n            .orgId(test.applyValue(getRolesOrgIdResult -\u003e getRolesOrgIdResult.orgId()))\n            .teams(            \n                ProjectTeamArgs.builder()\n                    .teamId(\"5e0fa8c99ccf641c722fe645\")\n                    .roleNames(\"GROUP_OWNER\")\n                    .build(),\n                ProjectTeamArgs.builder()\n                    .teamId(\"5e1dd7b4f2a30ba80a70cd4rw\")\n                    .roleNames(                    \n                        \"GROUP_READ_ONLY\",\n                        \"GROUP_DATA_ACCESS_READ_WRITE\")\n                    .build())\n            .limits(ProjectLimitArgs.builder()\n                .name(\"atlas.project.deployment.clusters\")\n                .value(26)\n                .build())\n            .build());\n\n        final var testGetProject = MongodbatlasFunctions.getProject(GetProjectArgs.builder()\n            .projectId(testProject.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testProject:\n    type: mongodbatlas:Project\n    name: test\n    properties:\n      name: project-name\n      orgId: ${test.orgId}\n      teams:\n        - teamId: 5e0fa8c99ccf641c722fe645\n          roleNames:\n            - GROUP_OWNER\n        - teamId: 5e1dd7b4f2a30ba80a70cd4rw\n          roleNames:\n            - GROUP_READ_ONLY\n            - GROUP_DATA_ACCESS_READ_WRITE\n      limits:\n        - name: atlas.project.deployment.clusters\n          value: 26\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getRolesOrgId\n      Arguments: {}\n  testGetProject:\n    fn::invoke:\n      Function: mongodbatlas:getProject\n      Arguments:\n        projectId: ${testProject.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Using name attribute to query\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testProject = new mongodbatlas.Project(\"test\", {\n    name: \"project-name\",\n    orgId: \"\u003cORG_ID\u003e\",\n    teams: [\n        {\n            teamId: \"5e0fa8c99ccf641c722fe645\",\n            roleNames: [\"GROUP_OWNER\"],\n        },\n        {\n            teamId: \"5e1dd7b4f2a30ba80a70cd4rw\",\n            roleNames: [\n                \"GROUP_READ_ONLY\",\n                \"GROUP_DATA_ACCESS_READ_WRITE\",\n            ],\n        },\n    ],\n    limits: [{\n        name: \"atlas.project.deployment.clusters\",\n        value: 26,\n    }],\n});\nconst test = mongodbatlas.getProjectOutput({\n    name: testProject.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_project = mongodbatlas.Project(\"test\",\n    name=\"project-name\",\n    org_id=\"\u003cORG_ID\u003e\",\n    teams=[\n        {\n            \"team_id\": \"5e0fa8c99ccf641c722fe645\",\n            \"role_names\": [\"GROUP_OWNER\"],\n        },\n        {\n            \"team_id\": \"5e1dd7b4f2a30ba80a70cd4rw\",\n            \"role_names\": [\n                \"GROUP_READ_ONLY\",\n                \"GROUP_DATA_ACCESS_READ_WRITE\",\n            ],\n        },\n    ],\n    limits=[{\n        \"name\": \"atlas.project.deployment.clusters\",\n        \"value\": 26,\n    }])\ntest = mongodbatlas.get_project_output(name=test_project.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testProject = new Mongodbatlas.Project(\"test\", new()\n    {\n        Name = \"project-name\",\n        OrgId = \"\u003cORG_ID\u003e\",\n        Teams = new[]\n        {\n            new Mongodbatlas.Inputs.ProjectTeamArgs\n            {\n                TeamId = \"5e0fa8c99ccf641c722fe645\",\n                RoleNames = new[]\n                {\n                    \"GROUP_OWNER\",\n                },\n            },\n            new Mongodbatlas.Inputs.ProjectTeamArgs\n            {\n                TeamId = \"5e1dd7b4f2a30ba80a70cd4rw\",\n                RoleNames = new[]\n                {\n                    \"GROUP_READ_ONLY\",\n                    \"GROUP_DATA_ACCESS_READ_WRITE\",\n                },\n            },\n        },\n        Limits = new[]\n        {\n            new Mongodbatlas.Inputs.ProjectLimitArgs\n            {\n                Name = \"atlas.project.deployment.clusters\",\n                Value = 26,\n            },\n        },\n    });\n\n    var test = Mongodbatlas.GetProject.Invoke(new()\n    {\n        Name = testProject.Name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestProject, err := mongodbatlas.NewProject(ctx, \"test\", \u0026mongodbatlas.ProjectArgs{\n\t\t\tName:  pulumi.String(\"project-name\"),\n\t\t\tOrgId: pulumi.String(\"\u003cORG_ID\u003e\"),\n\t\t\tTeams: mongodbatlas.ProjectTeamArray{\n\t\t\t\t\u0026mongodbatlas.ProjectTeamArgs{\n\t\t\t\t\tTeamId: pulumi.String(\"5e0fa8c99ccf641c722fe645\"),\n\t\t\t\t\tRoleNames: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_OWNER\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.ProjectTeamArgs{\n\t\t\t\t\tTeamId: pulumi.String(\"5e1dd7b4f2a30ba80a70cd4rw\"),\n\t\t\t\t\tRoleNames: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_READ_ONLY\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_READ_WRITE\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tLimits: mongodbatlas.ProjectLimitArray{\n\t\t\t\t\u0026mongodbatlas.ProjectLimitArgs{\n\t\t\t\t\tName:  pulumi.String(\"atlas.project.deployment.clusters\"),\n\t\t\t\t\tValue: pulumi.Int(26),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupProjectOutput(ctx, mongodbatlas.GetProjectOutputArgs{\n\t\t\tName: testProject.Name,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Project;\nimport com.pulumi.mongodbatlas.ProjectArgs;\nimport com.pulumi.mongodbatlas.inputs.ProjectTeamArgs;\nimport com.pulumi.mongodbatlas.inputs.ProjectLimitArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetProjectArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testProject = new Project(\"testProject\", ProjectArgs.builder()\n            .name(\"project-name\")\n            .orgId(\"\u003cORG_ID\u003e\")\n            .teams(            \n                ProjectTeamArgs.builder()\n                    .teamId(\"5e0fa8c99ccf641c722fe645\")\n                    .roleNames(\"GROUP_OWNER\")\n                    .build(),\n                ProjectTeamArgs.builder()\n                    .teamId(\"5e1dd7b4f2a30ba80a70cd4rw\")\n                    .roleNames(                    \n                        \"GROUP_READ_ONLY\",\n                        \"GROUP_DATA_ACCESS_READ_WRITE\")\n                    .build())\n            .limits(ProjectLimitArgs.builder()\n                .name(\"atlas.project.deployment.clusters\")\n                .value(26)\n                .build())\n            .build());\n\n        final var test = MongodbatlasFunctions.getProject(GetProjectArgs.builder()\n            .name(testProject.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testProject:\n    type: mongodbatlas:Project\n    name: test\n    properties:\n      name: project-name\n      orgId: \u003cORG_ID\u003e\n      teams:\n        - teamId: 5e0fa8c99ccf641c722fe645\n          roleNames:\n            - GROUP_OWNER\n        - teamId: 5e1dd7b4f2a30ba80a70cd4rw\n          roleNames:\n            - GROUP_READ_ONLY\n            - GROUP_DATA_ACCESS_READ_WRITE\n      limits:\n        - name: atlas.project.deployment.clusters\n          value: 26\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getProject\n      Arguments:\n        name: ${testProject.name}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProject.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The unique ID for the project.\n\n\u003e **IMPORTANT:** Either `project_id` or `name` must be configurated.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getProject.\n",
                "properties": {
                    "clusterCount": {
                        "description": "The number of Atlas clusters deployed in the project.\n",
                        "type": "integer"
                    },
                    "created": {
                        "description": "The ISO-8601-formatted timestamp of when Atlas created the project.\n",
                        "type": "string"
                    },
                    "id": {
                        "type": "string"
                    },
                    "ipAddresses": {
                        "$ref": "#/types/mongodbatlas:index/getProjectIpAddresses:getProjectIpAddresses",
                        "description": "IP addresses in a project categorized by services. See IP Addresses.\n"
                    },
                    "isCollectDatabaseSpecificsStatisticsEnabled": {
                        "description": "Flag that indicates whether to enable statistics in [cluster metrics](https://www.mongodb.com/docs/atlas/monitor-cluster-metrics/) collection for the project.\n",
                        "type": "boolean"
                    },
                    "isDataExplorerEnabled": {
                        "description": "Flag that indicates whether to enable Data Explorer for the project. If enabled, you can query your database with an easy to use interface.\n",
                        "type": "boolean"
                    },
                    "isExtendedStorageSizesEnabled": {
                        "description": "Flag that indicates whether to enable extended storage sizes for the specified project.\n",
                        "type": "boolean"
                    },
                    "isPerformanceAdvisorEnabled": {
                        "description": "Flag that indicates whether to enable Performance Advisor and Profiler for the project. If enabled, you can analyze database logs to recommend performance improvements.\n",
                        "type": "boolean"
                    },
                    "isRealtimePerformancePanelEnabled": {
                        "description": "Flag that indicates whether to enable Real Time Performance Panel for the project. If enabled, you can see real time metrics from your MongoDB database.\n",
                        "type": "boolean"
                    },
                    "isSchemaAdvisorEnabled": {
                        "description": "Flag that indicates whether to enable Schema Advisor for the project. If enabled, you receive customized recommendations to optimize your data model and enhance performance. Disable this setting to disable schema suggestions in the [Performance Advisor](https://www.mongodb.com/docs/atlas/performance-advisor/#std-label-performance-advisor) and the [Data Explorer](https://www.mongodb.com/docs/atlas/atlas-ui/#std-label-atlas-ui).\n",
                        "type": "boolean"
                    },
                    "limits": {
                        "description": "The limits for the specified project. See Limits.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getProjectLimit:getProjectLimit"
                        },
                        "type": "array"
                    },
                    "name": {
                        "description": "Human-readable label that identifies this project limit.\n",
                        "type": "string"
                    },
                    "orgId": {
                        "description": "The ID of the organization you want to create the project within.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "regionUsageRestrictions": {
                        "description": "If GOV_REGIONS_ONLY the project can be used for government regions only, otherwise defaults to standard regions. For more information see [MongoDB Atlas for Government](https://www.mongodb.com/docs/atlas/government/api/#creating-a-project).\n",
                        "type": "string"
                    },
                    "tags": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Map that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the project. To learn more, see [Resource Tags](https://www.mongodb.com/docs/atlas/tags/)\n",
                        "type": "object"
                    },
                    "teams": {
                        "description": "Returns all teams to which the authenticated user has access in the project. See Teams.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getProjectTeam:getProjectTeam"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "clusterCount",
                    "created",
                    "id",
                    "ipAddresses",
                    "isCollectDatabaseSpecificsStatisticsEnabled",
                    "isDataExplorerEnabled",
                    "isExtendedStorageSizesEnabled",
                    "isPerformanceAdvisorEnabled",
                    "isRealtimePerformancePanelEnabled",
                    "isSchemaAdvisorEnabled",
                    "limits",
                    "orgId",
                    "regionUsageRestrictions",
                    "tags",
                    "teams"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getProjectApiKey:getProjectApiKey": {
            "description": "## Example Usage\n\n### Using project_id and api_key_id attribute to query\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testProjectApiKey = new mongodbatlas.ProjectApiKey(\"test\", {\n    description: \"Description of your API key\",\n    projectAssignments: [{\n        projectId: \"64259ee860c43338194b0f8e\",\n        roleNames: [\"GROUP_READ_ONLY\"],\n    }],\n});\nconst test = mongodbatlas.getProjectApiKey({\n    projectId: \"64259ee860c43338194b0f8e\",\n    apiKeyId: testMongodbatlasApiKey.apiKeyId,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_project_api_key = mongodbatlas.ProjectApiKey(\"test\",\n    description=\"Description of your API key\",\n    project_assignments=[{\n        \"project_id\": \"64259ee860c43338194b0f8e\",\n        \"role_names\": [\"GROUP_READ_ONLY\"],\n    }])\ntest = mongodbatlas.get_project_api_key(project_id=\"64259ee860c43338194b0f8e\",\n    api_key_id=test_mongodbatlas_api_key[\"apiKeyId\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testProjectApiKey = new Mongodbatlas.ProjectApiKey(\"test\", new()\n    {\n        Description = \"Description of your API key\",\n        ProjectAssignments = new[]\n        {\n            new Mongodbatlas.Inputs.ProjectApiKeyProjectAssignmentArgs\n            {\n                ProjectId = \"64259ee860c43338194b0f8e\",\n                RoleNames = new[]\n                {\n                    \"GROUP_READ_ONLY\",\n                },\n            },\n        },\n    });\n\n    var test = Mongodbatlas.GetProjectApiKey.Invoke(new()\n    {\n        ProjectId = \"64259ee860c43338194b0f8e\",\n        ApiKeyId = testMongodbatlasApiKey.ApiKeyId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewProjectApiKey(ctx, \"test\", \u0026mongodbatlas.ProjectApiKeyArgs{\n\t\t\tDescription: pulumi.String(\"Description of your API key\"),\n\t\t\tProjectAssignments: mongodbatlas.ProjectApiKeyProjectAssignmentArray{\n\t\t\t\t\u0026mongodbatlas.ProjectApiKeyProjectAssignmentArgs{\n\t\t\t\t\tProjectId: pulumi.String(\"64259ee860c43338194b0f8e\"),\n\t\t\t\t\tRoleNames: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_READ_ONLY\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.LookupProjectApiKey(ctx, \u0026mongodbatlas.LookupProjectApiKeyArgs{\n\t\t\tProjectId: \"64259ee860c43338194b0f8e\",\n\t\t\tApiKeyId:  testMongodbatlasApiKey.ApiKeyId,\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ProjectApiKey;\nimport com.pulumi.mongodbatlas.ProjectApiKeyArgs;\nimport com.pulumi.mongodbatlas.inputs.ProjectApiKeyProjectAssignmentArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetProjectApiKeyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testProjectApiKey = new ProjectApiKey(\"testProjectApiKey\", ProjectApiKeyArgs.builder()\n            .description(\"Description of your API key\")\n            .projectAssignments(ProjectApiKeyProjectAssignmentArgs.builder()\n                .projectId(\"64259ee860c43338194b0f8e\")\n                .roleNames(\"GROUP_READ_ONLY\")\n                .build())\n            .build());\n\n        final var test = MongodbatlasFunctions.getProjectApiKey(GetProjectApiKeyArgs.builder()\n            .projectId(\"64259ee860c43338194b0f8e\")\n            .apiKeyId(testMongodbatlasApiKey.apiKeyId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testProjectApiKey:\n    type: mongodbatlas:ProjectApiKey\n    name: test\n    properties:\n      description: Description of your API key\n      projectAssignments:\n        - projectId: 64259ee860c43338194b0f8e\n          roleNames:\n            - GROUP_READ_ONLY\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getProjectApiKey\n      Arguments:\n        projectId: 64259ee860c43338194b0f8e\n        apiKeyId: ${testMongodbatlasApiKey.apiKeyId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectApiKey.\n",
                "properties": {
                    "apiKeyId": {
                        "type": "string",
                        "description": "Unique identifier for this Project API key.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "apiKeyId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectApiKey.\n",
                "properties": {
                    "apiKeyId": {
                        "type": "string"
                    },
                    "description": {
                        "description": "Description of this Project API key.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "privateKey": {
                        "description": "Private key for this Organization API key.\n",
                        "type": "string"
                    },
                    "projectAssignments": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getProjectApiKeyProjectAssignment:getProjectApiKeyProjectAssignment"
                        },
                        "type": "array"
                    },
                    "projectId": {
                        "description": "Project ID to assign to Access Key\n",
                        "type": "string"
                    },
                    "publicKey": {
                        "description": "Public key for this Organization API key.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "apiKeyId",
                    "description",
                    "privateKey",
                    "projectAssignments",
                    "projectId",
                    "publicKey",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getProjectApiKeys:getProjectApiKeys": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = mongodbatlas.getProjectApiKeys({\n    pageNum: 1,\n    itemsPerPage: 5,\n    projectId: \"32b6e34b3d91647abb20e7b8\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.get_project_api_keys(page_num=1,\n    items_per_page=5,\n    project_id=\"32b6e34b3d91647abb20e7b8\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Mongodbatlas.GetProjectApiKeys.Invoke(new()\n    {\n        PageNum = 1,\n        ItemsPerPage = 5,\n        ProjectId = \"32b6e34b3d91647abb20e7b8\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.LookupProjectApiKeys(ctx, \u0026mongodbatlas.LookupProjectApiKeysArgs{\n\t\t\tPageNum:      pulumi.IntRef(1),\n\t\t\tItemsPerPage: pulumi.IntRef(5),\n\t\t\tProjectId:    \"32b6e34b3d91647abb20e7b8\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetProjectApiKeysArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getProjectApiKeys(GetProjectApiKeysArgs.builder()\n            .pageNum(1)\n            .itemsPerPage(5)\n            .projectId(\"32b6e34b3d91647abb20e7b8\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getProjectApiKeys\n      Arguments:\n        pageNum: 1\n        itemsPerPage: 5\n        projectId: 32b6e34b3d91647abb20e7b8\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectApiKeys.\n",
                "properties": {
                    "itemsPerPage": {
                        "type": "integer",
                        "description": "Number of items to return per page, up to a maximum of 500. Defaults to `100`.\n"
                    },
                    "pageNum": {
                        "type": "integer",
                        "description": "The page to return. Defaults to `1`.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectApiKeys.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "projectId": {
                        "description": "Project ID to assign to Access Key\n",
                        "type": "string"
                    },
                    "results": {
                        "description": "A list where each element represents a API Key assigned to the project.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getProjectApiKeysResult:getProjectApiKeysResult"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "projectId",
                    "results",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getProjectInvitation:getProjectInvitation": {
            "description": "## # Data Source: mongodbatlas.ProjectInvitation\n\n`mongodbatlas.ProjectInvitation` describes an invitation to a user to join an Atlas project.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find GROUP-ID in the official documentation.\n\n## Example Usage\n\n### S\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testProjectInvitation = new mongodbatlas.ProjectInvitation(\"test\", {\n    username: \"test-acc-username\",\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    roles: [\"GROUP_DATA_ACCESS_READ_WRITE\"],\n});\nconst test = mongodbatlas.getProjectInvitationOutput({\n    projectId: testProjectInvitation.projectId,\n    username: testProjectInvitation.username,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_project_invitation = mongodbatlas.ProjectInvitation(\"test\",\n    username=\"test-acc-username\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    roles=[\"GROUP_DATA_ACCESS_READ_WRITE\"])\ntest = mongodbatlas.get_project_invitation_output(project_id=test_project_invitation.project_id,\n    username=test_project_invitation.username)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testProjectInvitation = new Mongodbatlas.ProjectInvitation(\"test\", new()\n    {\n        Username = \"test-acc-username\",\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        Roles = new[]\n        {\n            \"GROUP_DATA_ACCESS_READ_WRITE\",\n        },\n    });\n\n    var test = Mongodbatlas.GetProjectInvitation.Invoke(new()\n    {\n        ProjectId = testProjectInvitation.ProjectId,\n        Username = testProjectInvitation.Username,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestProjectInvitation, err := mongodbatlas.NewProjectInvitation(ctx, \"test\", \u0026mongodbatlas.ProjectInvitationArgs{\n\t\t\tUsername:  pulumi.String(\"test-acc-username\"),\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tRoles: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_READ_WRITE\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupProjectInvitationOutput(ctx, mongodbatlas.GetProjectInvitationOutputArgs{\n\t\t\tProjectId: testProjectInvitation.ProjectId,\n\t\t\tUsername:  testProjectInvitation.Username,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ProjectInvitation;\nimport com.pulumi.mongodbatlas.ProjectInvitationArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetProjectInvitationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testProjectInvitation = new ProjectInvitation(\"testProjectInvitation\", ProjectInvitationArgs.builder()\n            .username(\"test-acc-username\")\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .roles(\"GROUP_DATA_ACCESS_READ_WRITE\")\n            .build());\n\n        final var test = MongodbatlasFunctions.getProjectInvitation(GetProjectInvitationArgs.builder()\n            .projectId(testProjectInvitation.projectId())\n            .username(testProjectInvitation.username())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testProjectInvitation:\n    type: mongodbatlas:ProjectInvitation\n    name: test\n    properties:\n      username: test-acc-username\n      projectId: \u003cPROJECT-ID\u003e\n      roles:\n        - GROUP_DATA_ACCESS_READ_WRITE\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getProjectInvitation\n      Arguments:\n        projectId: ${testProjectInvitation.projectId}\n        username: ${testProjectInvitation.username}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectInvitation.\n",
                "properties": {
                    "invitationId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the invitation in Atlas.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the project to which you invited the user.\n"
                    },
                    "username": {
                        "type": "string",
                        "description": "Email address of the invited user. This is the address to which Atlas sends the invite. If the user accepts the invitation, they log in to Atlas with this username.\n"
                    }
                },
                "type": "object",
                "required": [
                    "invitationId",
                    "projectId",
                    "username"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectInvitation.\n",
                "properties": {
                    "createdAt": {
                        "description": "Timestamp in ISO 8601 date and time format in UTC when Atlas sent the invitation.\n",
                        "type": "string"
                    },
                    "expiresAt": {
                        "description": "Timestamp in ISO 8601 date and time format in UTC when the invitation expires. Users have 30 days to accept an invitation.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "invitationId": {
                        "type": "string"
                    },
                    "inviterUsername": {
                        "description": "Atlas user who invited `username` to the project.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "roles": {
                        "description": "Atlas roles to assign to the invited user. If the user accepts the invitation, Atlas assigns these roles to them. Refer to the [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) for information on valid roles.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "username": {
                        "type": "string"
                    }
                },
                "required": [
                    "createdAt",
                    "expiresAt",
                    "invitationId",
                    "inviterUsername",
                    "projectId",
                    "roles",
                    "username",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getProjectIpAccessList:getProjectIpAccessList": {
            "description": "## # Data Source: mongodbatlas.ProjectIpAccessList\n\n`mongodbatlas.ProjectIpAccessList` describes an IP Access List entry resource. The access list grants access from IPs, CIDRs or AWS Security Groups (if VPC Peering is enabled) to clusters within the Project.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n\u003e **IMPORTANT:**\nWhen you remove an entry from the access list, existing connections from the removed address(es) may remain open for a variable amount of time. How much time passes before Atlas closes the connection depends on several factors, including how the connection was established, the particular behavior of the application or driver using the address, and the connection protocol (e.g., TCP or UDP). This is particularly important to consider when changing an existing IP address or CIDR block as they cannot be updated via the Provider (comments can however), hence a change will force the destruction and recreation of entries.   \n\n\n## Example Usage\n\n### Using CIDR Block\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testProjectIpAccessList = new mongodbatlas.ProjectIpAccessList(\"test\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    cidrBlock: \"1.2.3.4/32\",\n    comment: \"cidr block for tf acc testing\",\n});\nconst test = mongodbatlas.getProjectIpAccessListOutput({\n    projectId: testProjectIpAccessList.projectId,\n    cidrBlock: testProjectIpAccessList.cidrBlock,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_project_ip_access_list = mongodbatlas.ProjectIpAccessList(\"test\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    cidr_block=\"1.2.3.4/32\",\n    comment=\"cidr block for tf acc testing\")\ntest = mongodbatlas.get_project_ip_access_list_output(project_id=test_project_ip_access_list.project_id,\n    cidr_block=test_project_ip_access_list.cidr_block)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testProjectIpAccessList = new Mongodbatlas.ProjectIpAccessList(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        CidrBlock = \"1.2.3.4/32\",\n        Comment = \"cidr block for tf acc testing\",\n    });\n\n    var test = Mongodbatlas.GetProjectIpAccessList.Invoke(new()\n    {\n        ProjectId = testProjectIpAccessList.ProjectId,\n        CidrBlock = testProjectIpAccessList.CidrBlock,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestProjectIpAccessList, err := mongodbatlas.NewProjectIpAccessList(ctx, \"test\", \u0026mongodbatlas.ProjectIpAccessListArgs{\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tCidrBlock: pulumi.String(\"1.2.3.4/32\"),\n\t\t\tComment:   pulumi.String(\"cidr block for tf acc testing\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupProjectIpAccessListOutput(ctx, mongodbatlas.GetProjectIpAccessListOutputArgs{\n\t\t\tProjectId: testProjectIpAccessList.ProjectId,\n\t\t\tCidrBlock: testProjectIpAccessList.CidrBlock,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ProjectIpAccessList;\nimport com.pulumi.mongodbatlas.ProjectIpAccessListArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetProjectIpAccessListArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testProjectIpAccessList = new ProjectIpAccessList(\"testProjectIpAccessList\", ProjectIpAccessListArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .cidrBlock(\"1.2.3.4/32\")\n            .comment(\"cidr block for tf acc testing\")\n            .build());\n\n        final var test = MongodbatlasFunctions.getProjectIpAccessList(GetProjectIpAccessListArgs.builder()\n            .projectId(testProjectIpAccessList.projectId())\n            .cidrBlock(testProjectIpAccessList.cidrBlock())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testProjectIpAccessList:\n    type: mongodbatlas:ProjectIpAccessList\n    name: test\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      cidrBlock: 1.2.3.4/32\n      comment: cidr block for tf acc testing\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getProjectIpAccessList\n      Arguments:\n        projectId: ${testProjectIpAccessList.projectId}\n        cidrBlock: ${testProjectIpAccessList.cidrBlock}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Using IP Address\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testProjectIpAccessList = new mongodbatlas.ProjectIpAccessList(\"test\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    ipAddress: \"2.3.4.5\",\n    comment: \"ip address for tf acc testing\",\n});\nconst test = mongodbatlas.getProjectIpAccessListOutput({\n    projectId: testProjectIpAccessList.projectId,\n    ipAddress: testProjectIpAccessList.ipAddress,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_project_ip_access_list = mongodbatlas.ProjectIpAccessList(\"test\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    ip_address=\"2.3.4.5\",\n    comment=\"ip address for tf acc testing\")\ntest = mongodbatlas.get_project_ip_access_list_output(project_id=test_project_ip_access_list.project_id,\n    ip_address=test_project_ip_access_list.ip_address)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testProjectIpAccessList = new Mongodbatlas.ProjectIpAccessList(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        IpAddress = \"2.3.4.5\",\n        Comment = \"ip address for tf acc testing\",\n    });\n\n    var test = Mongodbatlas.GetProjectIpAccessList.Invoke(new()\n    {\n        ProjectId = testProjectIpAccessList.ProjectId,\n        IpAddress = testProjectIpAccessList.IpAddress,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestProjectIpAccessList, err := mongodbatlas.NewProjectIpAccessList(ctx, \"test\", \u0026mongodbatlas.ProjectIpAccessListArgs{\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tIpAddress: pulumi.String(\"2.3.4.5\"),\n\t\t\tComment:   pulumi.String(\"ip address for tf acc testing\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupProjectIpAccessListOutput(ctx, mongodbatlas.GetProjectIpAccessListOutputArgs{\n\t\t\tProjectId: testProjectIpAccessList.ProjectId,\n\t\t\tIpAddress: testProjectIpAccessList.IpAddress,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ProjectIpAccessList;\nimport com.pulumi.mongodbatlas.ProjectIpAccessListArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetProjectIpAccessListArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testProjectIpAccessList = new ProjectIpAccessList(\"testProjectIpAccessList\", ProjectIpAccessListArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .ipAddress(\"2.3.4.5\")\n            .comment(\"ip address for tf acc testing\")\n            .build());\n\n        final var test = MongodbatlasFunctions.getProjectIpAccessList(GetProjectIpAccessListArgs.builder()\n            .projectId(testProjectIpAccessList.projectId())\n            .ipAddress(testProjectIpAccessList.ipAddress())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testProjectIpAccessList:\n    type: mongodbatlas:ProjectIpAccessList\n    name: test\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      ipAddress: 2.3.4.5\n      comment: ip address for tf acc testing\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getProjectIpAccessList\n      Arguments:\n        projectId: ${testProjectIpAccessList.projectId}\n        ipAddress: ${testProjectIpAccessList.ipAddress}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Using an AWS Security Group\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testNetworkContainer = new mongodbatlas.NetworkContainer(\"test\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    atlasCidrBlock: \"192.168.208.0/21\",\n    providerName: \"AWS\",\n    regionName: \"US_EAST_1\",\n});\nconst testNetworkPeering = new mongodbatlas.NetworkPeering(\"test\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    containerId: testNetworkContainer.containerId,\n    accepterRegionName: \"us-east-1\",\n    providerName: \"AWS\",\n    routeTableCidrBlock: \"172.31.0.0/16\",\n    vpcId: \"vpc-0d93d6f69f1578bd8\",\n    awsAccountId: \"232589400519\",\n});\nconst testProjectIpAccessList = new mongodbatlas.ProjectIpAccessList(\"test\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    awsSecurityGroup: \"sg-0026348ec11780bd1\",\n    comment: \"TestAcc for awsSecurityGroup\",\n}, {\n    dependsOn: [testNetworkPeering],\n});\nconst test = mongodbatlas.getProjectIpAccessListOutput({\n    projectId: testProjectIpAccessList.projectId,\n    awsSecurityGroup: testProjectIpAccessList.awsSecurityGroup,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_network_container = mongodbatlas.NetworkContainer(\"test\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    atlas_cidr_block=\"192.168.208.0/21\",\n    provider_name=\"AWS\",\n    region_name=\"US_EAST_1\")\ntest_network_peering = mongodbatlas.NetworkPeering(\"test\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    container_id=test_network_container.container_id,\n    accepter_region_name=\"us-east-1\",\n    provider_name=\"AWS\",\n    route_table_cidr_block=\"172.31.0.0/16\",\n    vpc_id=\"vpc-0d93d6f69f1578bd8\",\n    aws_account_id=\"232589400519\")\ntest_project_ip_access_list = mongodbatlas.ProjectIpAccessList(\"test\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    aws_security_group=\"sg-0026348ec11780bd1\",\n    comment=\"TestAcc for awsSecurityGroup\",\n    opts = pulumi.ResourceOptions(depends_on=[test_network_peering]))\ntest = mongodbatlas.get_project_ip_access_list_output(project_id=test_project_ip_access_list.project_id,\n    aws_security_group=test_project_ip_access_list.aws_security_group)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testNetworkContainer = new Mongodbatlas.NetworkContainer(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        AtlasCidrBlock = \"192.168.208.0/21\",\n        ProviderName = \"AWS\",\n        RegionName = \"US_EAST_1\",\n    });\n\n    var testNetworkPeering = new Mongodbatlas.NetworkPeering(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        ContainerId = testNetworkContainer.ContainerId,\n        AccepterRegionName = \"us-east-1\",\n        ProviderName = \"AWS\",\n        RouteTableCidrBlock = \"172.31.0.0/16\",\n        VpcId = \"vpc-0d93d6f69f1578bd8\",\n        AwsAccountId = \"232589400519\",\n    });\n\n    var testProjectIpAccessList = new Mongodbatlas.ProjectIpAccessList(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        AwsSecurityGroup = \"sg-0026348ec11780bd1\",\n        Comment = \"TestAcc for awsSecurityGroup\",\n    }, new CustomResourceOptions\n    {\n        DependsOn =\n        {\n            testNetworkPeering,\n        },\n    });\n\n    var test = Mongodbatlas.GetProjectIpAccessList.Invoke(new()\n    {\n        ProjectId = testProjectIpAccessList.ProjectId,\n        AwsSecurityGroup = testProjectIpAccessList.AwsSecurityGroup,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestNetworkContainer, err := mongodbatlas.NewNetworkContainer(ctx, \"test\", \u0026mongodbatlas.NetworkContainerArgs{\n\t\t\tProjectId:      pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tAtlasCidrBlock: pulumi.String(\"192.168.208.0/21\"),\n\t\t\tProviderName:   pulumi.String(\"AWS\"),\n\t\t\tRegionName:     pulumi.String(\"US_EAST_1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestNetworkPeering, err := mongodbatlas.NewNetworkPeering(ctx, \"test\", \u0026mongodbatlas.NetworkPeeringArgs{\n\t\t\tProjectId:           pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tContainerId:         testNetworkContainer.ContainerId,\n\t\t\tAccepterRegionName:  pulumi.String(\"us-east-1\"),\n\t\t\tProviderName:        pulumi.String(\"AWS\"),\n\t\t\tRouteTableCidrBlock: pulumi.String(\"172.31.0.0/16\"),\n\t\t\tVpcId:               pulumi.String(\"vpc-0d93d6f69f1578bd8\"),\n\t\t\tAwsAccountId:        pulumi.String(\"232589400519\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestProjectIpAccessList, err := mongodbatlas.NewProjectIpAccessList(ctx, \"test\", \u0026mongodbatlas.ProjectIpAccessListArgs{\n\t\t\tProjectId:        pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tAwsSecurityGroup: pulumi.String(\"sg-0026348ec11780bd1\"),\n\t\t\tComment:          pulumi.String(\"TestAcc for awsSecurityGroup\"),\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\ttestNetworkPeering,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupProjectIpAccessListOutput(ctx, mongodbatlas.GetProjectIpAccessListOutputArgs{\n\t\t\tProjectId:        testProjectIpAccessList.ProjectId,\n\t\t\tAwsSecurityGroup: testProjectIpAccessList.AwsSecurityGroup,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.NetworkContainer;\nimport com.pulumi.mongodbatlas.NetworkContainerArgs;\nimport com.pulumi.mongodbatlas.NetworkPeering;\nimport com.pulumi.mongodbatlas.NetworkPeeringArgs;\nimport com.pulumi.mongodbatlas.ProjectIpAccessList;\nimport com.pulumi.mongodbatlas.ProjectIpAccessListArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetProjectIpAccessListArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testNetworkContainer = new NetworkContainer(\"testNetworkContainer\", NetworkContainerArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .atlasCidrBlock(\"192.168.208.0/21\")\n            .providerName(\"AWS\")\n            .regionName(\"US_EAST_1\")\n            .build());\n\n        var testNetworkPeering = new NetworkPeering(\"testNetworkPeering\", NetworkPeeringArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .containerId(testNetworkContainer.containerId())\n            .accepterRegionName(\"us-east-1\")\n            .providerName(\"AWS\")\n            .routeTableCidrBlock(\"172.31.0.0/16\")\n            .vpcId(\"vpc-0d93d6f69f1578bd8\")\n            .awsAccountId(\"232589400519\")\n            .build());\n\n        var testProjectIpAccessList = new ProjectIpAccessList(\"testProjectIpAccessList\", ProjectIpAccessListArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .awsSecurityGroup(\"sg-0026348ec11780bd1\")\n            .comment(\"TestAcc for awsSecurityGroup\")\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(testNetworkPeering)\n                .build());\n\n        final var test = MongodbatlasFunctions.getProjectIpAccessList(GetProjectIpAccessListArgs.builder()\n            .projectId(testProjectIpAccessList.projectId())\n            .awsSecurityGroup(testProjectIpAccessList.awsSecurityGroup())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testNetworkContainer:\n    type: mongodbatlas:NetworkContainer\n    name: test\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      atlasCidrBlock: 192.168.208.0/21\n      providerName: AWS\n      regionName: US_EAST_1\n  testNetworkPeering:\n    type: mongodbatlas:NetworkPeering\n    name: test\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      containerId: ${testNetworkContainer.containerId}\n      accepterRegionName: us-east-1\n      providerName: AWS\n      routeTableCidrBlock: 172.31.0.0/16\n      vpcId: vpc-0d93d6f69f1578bd8\n      awsAccountId: '232589400519'\n  testProjectIpAccessList:\n    type: mongodbatlas:ProjectIpAccessList\n    name: test\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      awsSecurityGroup: sg-0026348ec11780bd1\n      comment: TestAcc for awsSecurityGroup\n    options:\n      dependson:\n        - ${testNetworkPeering}\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getProjectIpAccessList\n      Arguments:\n        projectId: ${testProjectIpAccessList.projectId}\n        awsSecurityGroup: ${testProjectIpAccessList.awsSecurityGroup}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\u003e **IMPORTANT:** In order to use AWS Security Group(s) VPC Peering must be enabled like in the above example.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProjectIpAccessList.\n",
                "properties": {
                    "awsSecurityGroup": {
                        "type": "string",
                        "description": "Unique identifier of the AWS security group to add to the access list.\n"
                    },
                    "cidrBlock": {
                        "type": "string",
                        "description": "Range of IP addresses in CIDR notation to be added to the access list.\n"
                    },
                    "ipAddress": {
                        "type": "string",
                        "description": "Single IP address to be added to the access list.\n\n\u003e **NOTE:** One of the following attributes must set:  `aws_security_group`, `cidr_block`  or `ip_address`.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique identifier for the project to which you want to add one or more access list entries.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getProjectIpAccessList.\n",
                "properties": {
                    "awsSecurityGroup": {
                        "type": "string"
                    },
                    "cidrBlock": {
                        "type": "string"
                    },
                    "comment": {
                        "description": "Comment to add to the access list entry.\n",
                        "type": "string"
                    },
                    "id": {
                        "type": "string"
                    },
                    "ipAddress": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    }
                },
                "required": [
                    "awsSecurityGroup",
                    "cidrBlock",
                    "comment",
                    "id",
                    "ipAddress",
                    "projectId"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getProjects:getProjects": {
            "description": "## # Data Source: mongodbatlas.getProjects\n\n`mongodbatlas.getProjects` describes all Projects. This represents projects that have been created.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = mongodbatlas.getRolesOrgId({});\nconst testProject = new mongodbatlas.Project(\"test\", {\n    name: \"project-name\",\n    orgId: test.then(test =\u003e test.orgId),\n    teams: [\n        {\n            teamId: \"5e0fa8c99ccf641c722fe645\",\n            roleNames: [\"GROUP_OWNER\"],\n        },\n        {\n            teamId: \"5e1dd7b4f2a30ba80a70cd4rw\",\n            roleNames: [\n                \"GROUP_READ_ONLY\",\n                \"GROUP_DATA_ACCESS_READ_WRITE\",\n            ],\n        },\n    ],\n    limits: [{\n        name: \"atlas.project.deployment.clusters\",\n        value: 26,\n    }],\n});\nconst testGetProjects = mongodbatlas.getProjects({\n    pageNum: 1,\n    itemsPerPage: 5,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.get_roles_org_id()\ntest_project = mongodbatlas.Project(\"test\",\n    name=\"project-name\",\n    org_id=test.org_id,\n    teams=[\n        {\n            \"team_id\": \"5e0fa8c99ccf641c722fe645\",\n            \"role_names\": [\"GROUP_OWNER\"],\n        },\n        {\n            \"team_id\": \"5e1dd7b4f2a30ba80a70cd4rw\",\n            \"role_names\": [\n                \"GROUP_READ_ONLY\",\n                \"GROUP_DATA_ACCESS_READ_WRITE\",\n            ],\n        },\n    ],\n    limits=[{\n        \"name\": \"atlas.project.deployment.clusters\",\n        \"value\": 26,\n    }])\ntest_get_projects = mongodbatlas.get_projects(page_num=1,\n    items_per_page=5)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Mongodbatlas.GetRolesOrgId.Invoke();\n\n    var testProject = new Mongodbatlas.Project(\"test\", new()\n    {\n        Name = \"project-name\",\n        OrgId = test.Apply(getRolesOrgIdResult =\u003e getRolesOrgIdResult.OrgId),\n        Teams = new[]\n        {\n            new Mongodbatlas.Inputs.ProjectTeamArgs\n            {\n                TeamId = \"5e0fa8c99ccf641c722fe645\",\n                RoleNames = new[]\n                {\n                    \"GROUP_OWNER\",\n                },\n            },\n            new Mongodbatlas.Inputs.ProjectTeamArgs\n            {\n                TeamId = \"5e1dd7b4f2a30ba80a70cd4rw\",\n                RoleNames = new[]\n                {\n                    \"GROUP_READ_ONLY\",\n                    \"GROUP_DATA_ACCESS_READ_WRITE\",\n                },\n            },\n        },\n        Limits = new[]\n        {\n            new Mongodbatlas.Inputs.ProjectLimitArgs\n            {\n                Name = \"atlas.project.deployment.clusters\",\n                Value = 26,\n            },\n        },\n    });\n\n    var testGetProjects = Mongodbatlas.GetProjects.Invoke(new()\n    {\n        PageNum = 1,\n        ItemsPerPage = 5,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := mongodbatlas.GetRolesOrgId(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewProject(ctx, \"test\", \u0026mongodbatlas.ProjectArgs{\n\t\t\tName:  pulumi.String(\"project-name\"),\n\t\t\tOrgId: pulumi.String(test.OrgId),\n\t\t\tTeams: mongodbatlas.ProjectTeamArray{\n\t\t\t\t\u0026mongodbatlas.ProjectTeamArgs{\n\t\t\t\t\tTeamId: pulumi.String(\"5e0fa8c99ccf641c722fe645\"),\n\t\t\t\t\tRoleNames: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_OWNER\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026mongodbatlas.ProjectTeamArgs{\n\t\t\t\t\tTeamId: pulumi.String(\"5e1dd7b4f2a30ba80a70cd4rw\"),\n\t\t\t\t\tRoleNames: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"GROUP_READ_ONLY\"),\n\t\t\t\t\t\tpulumi.String(\"GROUP_DATA_ACCESS_READ_WRITE\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tLimits: mongodbatlas.ProjectLimitArray{\n\t\t\t\t\u0026mongodbatlas.ProjectLimitArgs{\n\t\t\t\t\tName:  pulumi.String(\"atlas.project.deployment.clusters\"),\n\t\t\t\t\tValue: pulumi.Int(26),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.LookupProjects(ctx, \u0026mongodbatlas.LookupProjectsArgs{\n\t\t\tPageNum:      pulumi.IntRef(1),\n\t\t\tItemsPerPage: pulumi.IntRef(5),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.Project;\nimport com.pulumi.mongodbatlas.ProjectArgs;\nimport com.pulumi.mongodbatlas.inputs.ProjectTeamArgs;\nimport com.pulumi.mongodbatlas.inputs.ProjectLimitArgs;\nimport com.pulumi.mongodbatlas.inputs.GetProjectsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getRolesOrgId();\n\n        var testProject = new Project(\"testProject\", ProjectArgs.builder()\n            .name(\"project-name\")\n            .orgId(test.applyValue(getRolesOrgIdResult -\u003e getRolesOrgIdResult.orgId()))\n            .teams(            \n                ProjectTeamArgs.builder()\n                    .teamId(\"5e0fa8c99ccf641c722fe645\")\n                    .roleNames(\"GROUP_OWNER\")\n                    .build(),\n                ProjectTeamArgs.builder()\n                    .teamId(\"5e1dd7b4f2a30ba80a70cd4rw\")\n                    .roleNames(                    \n                        \"GROUP_READ_ONLY\",\n                        \"GROUP_DATA_ACCESS_READ_WRITE\")\n                    .build())\n            .limits(ProjectLimitArgs.builder()\n                .name(\"atlas.project.deployment.clusters\")\n                .value(26)\n                .build())\n            .build());\n\n        final var testGetProjects = MongodbatlasFunctions.getProjects(GetProjectsArgs.builder()\n            .pageNum(1)\n            .itemsPerPage(5)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testProject:\n    type: mongodbatlas:Project\n    name: test\n    properties:\n      name: project-name\n      orgId: ${test.orgId}\n      teams:\n        - teamId: 5e0fa8c99ccf641c722fe645\n          roleNames:\n            - GROUP_OWNER\n        - teamId: 5e1dd7b4f2a30ba80a70cd4rw\n          roleNames:\n            - GROUP_READ_ONLY\n            - GROUP_DATA_ACCESS_READ_WRITE\n      limits:\n        - name: atlas.project.deployment.clusters\n          value: 26\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getRolesOrgId\n      Arguments: {}\n  testGetProjects:\n    fn::invoke:\n      Function: mongodbatlas:getProjects\n      Arguments:\n        pageNum: 1\n        itemsPerPage: 5\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getProjects.\n",
                "properties": {
                    "itemsPerPage": {
                        "type": "integer",
                        "description": "Number of items to return per page, up to a maximum of 500. Defaults to `100`.\n"
                    },
                    "pageNum": {
                        "type": "integer",
                        "description": "The page to return. Defaults to `1`.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getProjects.\n",
                "properties": {
                    "id": {
                        "deprecationMessage": "Please use each project's id attribute instead",
                        "type": "string"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "results": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getProjectsResult:getProjectsResult"
                        },
                        "type": "array"
                    },
                    "totalCount": {
                        "type": "integer"
                    }
                },
                "required": [
                    "id",
                    "results",
                    "totalCount"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getPushBasedLogExport:getPushBasedLogExport": {
            "description": "## # Data Source: mongodbatlas.PushBasedLogExport\n\n`mongodbatlas.PushBasedLogExport` describes the configured project level settings for the push-based log export feature.\n\n## Example Usage\n\n### S\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nexport = async () =\u003e {\n    const project_tf = new mongodbatlas.Project(\"project-tf\", {\n        name: atlasProjectName,\n        orgId: atlasOrgId,\n    });\n    // Set up cloud provider access in Atlas using the created IAM role\n    const setupOnly = new mongodbatlas.CloudProviderAccessSetup(\"setup_only\", {\n        projectId: project_tf.id,\n        providerName: \"AWS\",\n    });\n    const authRole = new mongodbatlas.CloudProviderAccessAuthorization(\"auth_role\", {\n        projectId: project_tf.id,\n        roleId: setupOnly.roleId,\n        aws: {\n            iamAssumedRoleArn: testRole.arn,\n        },\n    });\n    // Set up push-based log export with authorized IAM role\n    const testPushBasedLogExport = new mongodbatlas.PushBasedLogExport(\"test\", {\n        projectId: project_tf.id,\n        bucketName: logBucket.bucket,\n        iamRoleId: authRole.roleId,\n        prefixPath: \"push-based-log-test\",\n    });\n    const test = mongodbatlas.getPushBasedLogExportOutput({\n        projectId: testPushBasedLogExport.projectId,\n    });\n    return {\n        test: test.apply(test =\u003e test.prefixPath),\n    };\n}\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nproject_tf = mongodbatlas.Project(\"project-tf\",\n    name=atlas_project_name,\n    org_id=atlas_org_id)\n# Set up cloud provider access in Atlas using the created IAM role\nsetup_only = mongodbatlas.CloudProviderAccessSetup(\"setup_only\",\n    project_id=project_tf.id,\n    provider_name=\"AWS\")\nauth_role = mongodbatlas.CloudProviderAccessAuthorization(\"auth_role\",\n    project_id=project_tf.id,\n    role_id=setup_only.role_id,\n    aws={\n        \"iam_assumed_role_arn\": test_role[\"arn\"],\n    })\n# Set up push-based log export with authorized IAM role\ntest_push_based_log_export = mongodbatlas.PushBasedLogExport(\"test\",\n    project_id=project_tf.id,\n    bucket_name=log_bucket[\"bucket\"],\n    iam_role_id=auth_role.role_id,\n    prefix_path=\"push-based-log-test\")\ntest = mongodbatlas.get_push_based_log_export_output(project_id=test_push_based_log_export.project_id)\npulumi.export(\"test\", test.prefix_path)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var project_tf = new Mongodbatlas.Project(\"project-tf\", new()\n    {\n        Name = atlasProjectName,\n        OrgId = atlasOrgId,\n    });\n\n    // Set up cloud provider access in Atlas using the created IAM role\n    var setupOnly = new Mongodbatlas.CloudProviderAccessSetup(\"setup_only\", new()\n    {\n        ProjectId = project_tf.Id,\n        ProviderName = \"AWS\",\n    });\n\n    var authRole = new Mongodbatlas.CloudProviderAccessAuthorization(\"auth_role\", new()\n    {\n        ProjectId = project_tf.Id,\n        RoleId = setupOnly.RoleId,\n        Aws = new Mongodbatlas.Inputs.CloudProviderAccessAuthorizationAwsArgs\n        {\n            IamAssumedRoleArn = testRole.Arn,\n        },\n    });\n\n    // Set up push-based log export with authorized IAM role\n    var testPushBasedLogExport = new Mongodbatlas.PushBasedLogExport(\"test\", new()\n    {\n        ProjectId = project_tf.Id,\n        BucketName = logBucket.Bucket,\n        IamRoleId = authRole.RoleId,\n        PrefixPath = \"push-based-log-test\",\n    });\n\n    var test = Mongodbatlas.GetPushBasedLogExport.Invoke(new()\n    {\n        ProjectId = testPushBasedLogExport.ProjectId,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"test\"] = test.Apply(getPushBasedLogExportResult =\u003e getPushBasedLogExportResult.PrefixPath),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.NewProject(ctx, \"project-tf\", \u0026mongodbatlas.ProjectArgs{\n\t\t\tName:  pulumi.Any(atlasProjectName),\n\t\t\tOrgId: pulumi.Any(atlasOrgId),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Set up cloud provider access in Atlas using the created IAM role\n\t\tsetupOnly, err := mongodbatlas.NewCloudProviderAccessSetup(ctx, \"setup_only\", \u0026mongodbatlas.CloudProviderAccessSetupArgs{\n\t\t\tProjectId:    project_tf.ID(),\n\t\t\tProviderName: pulumi.String(\"AWS\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tauthRole, err := mongodbatlas.NewCloudProviderAccessAuthorization(ctx, \"auth_role\", \u0026mongodbatlas.CloudProviderAccessAuthorizationArgs{\n\t\t\tProjectId: project_tf.ID(),\n\t\t\tRoleId:    setupOnly.RoleId,\n\t\t\tAws: \u0026mongodbatlas.CloudProviderAccessAuthorizationAwsArgs{\n\t\t\t\tIamAssumedRoleArn: pulumi.Any(testRole.Arn),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Set up push-based log export with authorized IAM role\n\t\ttestPushBasedLogExport, err := mongodbatlas.NewPushBasedLogExport(ctx, \"test\", \u0026mongodbatlas.PushBasedLogExportArgs{\n\t\t\tProjectId:  project_tf.ID(),\n\t\t\tBucketName: pulumi.Any(logBucket.Bucket),\n\t\t\tIamRoleId:  authRole.RoleId,\n\t\t\tPrefixPath: pulumi.String(\"push-based-log-test\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttest := mongodbatlas.LookupPushBasedLogExportOutput(ctx, mongodbatlas.GetPushBasedLogExportOutputArgs{\n\t\t\tProjectId: testPushBasedLogExport.ProjectId,\n\t\t}, nil)\n\t\tctx.Export(\"test\", test.ApplyT(func(test mongodbatlas.GetPushBasedLogExportResult) (*string, error) {\n\t\t\treturn \u0026test.PrefixPath, nil\n\t\t}).(pulumi.StringPtrOutput))\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Project;\nimport com.pulumi.mongodbatlas.ProjectArgs;\nimport com.pulumi.mongodbatlas.CloudProviderAccessSetup;\nimport com.pulumi.mongodbatlas.CloudProviderAccessSetupArgs;\nimport com.pulumi.mongodbatlas.CloudProviderAccessAuthorization;\nimport com.pulumi.mongodbatlas.CloudProviderAccessAuthorizationArgs;\nimport com.pulumi.mongodbatlas.inputs.CloudProviderAccessAuthorizationAwsArgs;\nimport com.pulumi.mongodbatlas.PushBasedLogExport;\nimport com.pulumi.mongodbatlas.PushBasedLogExportArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetPushBasedLogExportArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var project_tf = new Project(\"project-tf\", ProjectArgs.builder()\n            .name(atlasProjectName)\n            .orgId(atlasOrgId)\n            .build());\n\n        // Set up cloud provider access in Atlas using the created IAM role\n        var setupOnly = new CloudProviderAccessSetup(\"setupOnly\", CloudProviderAccessSetupArgs.builder()\n            .projectId(project_tf.id())\n            .providerName(\"AWS\")\n            .build());\n\n        var authRole = new CloudProviderAccessAuthorization(\"authRole\", CloudProviderAccessAuthorizationArgs.builder()\n            .projectId(project_tf.id())\n            .roleId(setupOnly.roleId())\n            .aws(CloudProviderAccessAuthorizationAwsArgs.builder()\n                .iamAssumedRoleArn(testRole.arn())\n                .build())\n            .build());\n\n        // Set up push-based log export with authorized IAM role\n        var testPushBasedLogExport = new PushBasedLogExport(\"testPushBasedLogExport\", PushBasedLogExportArgs.builder()\n            .projectId(project_tf.id())\n            .bucketName(logBucket.bucket())\n            .iamRoleId(authRole.roleId())\n            .prefixPath(\"push-based-log-test\")\n            .build());\n\n        final var test = MongodbatlasFunctions.getPushBasedLogExport(GetPushBasedLogExportArgs.builder()\n            .projectId(testPushBasedLogExport.projectId())\n            .build());\n\n        ctx.export(\"test\", test.applyValue(getPushBasedLogExportResult -\u003e getPushBasedLogExportResult).applyValue(test -\u003e test.applyValue(getPushBasedLogExportResult -\u003e getPushBasedLogExportResult.prefixPath())));\n    }\n}\n```\n```yaml\nresources:\n  project-tf:\n    type: mongodbatlas:Project\n    properties:\n      name: ${atlasProjectName}\n      orgId: ${atlasOrgId}\n  # Set up cloud provider access in Atlas using the created IAM role\n  setupOnly:\n    type: mongodbatlas:CloudProviderAccessSetup\n    name: setup_only\n    properties:\n      projectId: ${[\"project-tf\"].id}\n      providerName: AWS\n  authRole:\n    type: mongodbatlas:CloudProviderAccessAuthorization\n    name: auth_role\n    properties:\n      projectId: ${[\"project-tf\"].id}\n      roleId: ${setupOnly.roleId}\n      aws:\n        iamAssumedRoleArn: ${testRole.arn}\n  # Set up push-based log export with authorized IAM role\n  testPushBasedLogExport:\n    type: mongodbatlas:PushBasedLogExport\n    name: test\n    properties:\n      projectId: ${[\"project-tf\"].id}\n      bucketName: ${logBucket.bucket}\n      iamRoleId: ${authRole.roleId}\n      prefixPath: push-based-log-test\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getPushBasedLogExport\n      Arguments:\n        projectId: ${testPushBasedLogExport.projectId}\noutputs:\n  test: ${test.prefixPath}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPushBasedLogExport.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies your project. Use the /groups endpoint to retrieve all projects to which the authenticated user has access.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPushBasedLogExport.\n",
                "properties": {
                    "bucketName": {
                        "type": "string"
                    },
                    "createDate": {
                        "type": "string"
                    },
                    "iamRoleId": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "prefixPath": {
                        "type": "string"
                    },
                    "projectId": {
                        "description": "Unique 24-hexadecimal digit string that identifies your project. Use the /groups endpoint to retrieve all projects to which the authenticated user has access.\n",
                        "type": "string"
                    },
                    "state": {
                        "type": "string"
                    }
                },
                "required": [
                    "bucketName",
                    "createDate",
                    "iamRoleId",
                    "prefixPath",
                    "projectId",
                    "state",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getRolesOrgId:getRolesOrgId": {
            "description": "## # Data Source: mongodbatlas.getRolesOrgId\n\n`mongodbatlas.getRolesOrgId` describes a MongoDB Atlas Roles Org ID. This represents a Roles Org ID.\n\n## Example Usage\n\n### Using data source to query\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = mongodbatlas.getRolesOrgId({});\nexport const orgId = test.then(test =\u003e test.orgId);\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.get_roles_org_id()\npulumi.export(\"orgId\", test.org_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Mongodbatlas.GetRolesOrgId.Invoke();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"orgId\"] = test.Apply(getRolesOrgIdResult =\u003e getRolesOrgIdResult.OrgId),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := mongodbatlas.GetRolesOrgId(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"orgId\", test.OrgId)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getRolesOrgId();\n\n        ctx.export(\"orgId\", test.applyValue(getRolesOrgIdResult -\u003e getRolesOrgIdResult.orgId()));\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getRolesOrgId\n      Arguments: {}\noutputs:\n  orgId: ${test.orgId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getRolesOrgId.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "orgId": {
                        "description": "The ID of the organization you want to retrieve associated to an API Key.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "orgId",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getSearchDeployment:getSearchDeployment": {
            "description": "## # Data Source: mongodbatlas.SearchDeployment\n\n`mongodbatlas.SearchDeployment` describes a search node deployment.\n\n## Example Usage\n\n### S\n\u003c!--Start PulumiCodeChooser --\u003e\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Project;\nimport com.pulumi.mongodbatlas.ProjectArgs;\nimport com.pulumi.mongodbatlas.AdvancedCluster;\nimport com.pulumi.mongodbatlas.AdvancedClusterArgs;\nimport com.pulumi.mongodbatlas.inputs.AdvancedClusterReplicationSpecArgs;\nimport com.pulumi.mongodbatlas.SearchDeployment;\nimport com.pulumi.mongodbatlas.SearchDeploymentArgs;\nimport com.pulumi.mongodbatlas.inputs.SearchDeploymentSpecArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetSearchDeploymentArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleProject = new Project(\"exampleProject\", ProjectArgs.builder()\n            .name(\"project-name\")\n            .orgId(orgId)\n            .build());\n\n        var exampleAdvancedCluster = new AdvancedCluster(\"exampleAdvancedCluster\", AdvancedClusterArgs.builder()\n            .projectId(exampleProject.id())\n            .name(\"ClusterExample\")\n            .clusterType(\"REPLICASET\")\n            .replicationSpecs(AdvancedClusterReplicationSpecArgs.builder()\n                .regionConfigs(AdvancedClusterReplicationSpecRegionConfigArgs.builder()\n                    .electableSpecs(AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs.builder()\n                        .instanceSize(\"M10\")\n                        .nodeCount(3)\n                        .build())\n                    .providerName(\"AWS\")\n                    .priority(7)\n                    .regionName(\"US_EAST_1\")\n                    .build())\n                .build())\n            .build());\n\n        var exampleSearchDeployment = new SearchDeployment(\"exampleSearchDeployment\", SearchDeploymentArgs.builder()\n            .projectId(exampleProject.id())\n            .clusterName(exampleAdvancedCluster.name())\n            .specs(SearchDeploymentSpecArgs.builder()\n                .instance_size(\"S20_HIGHCPU_NVME\")\n                .node_count(2)\n                .build())\n            .build());\n\n        final var example = MongodbatlasFunctions.getSearchDeployment(GetSearchDeploymentArgs.builder()\n            .projectId(exampleSearchDeployment.projectId())\n            .clusterName(exampleSearchDeployment.clusterName())\n            .build());\n\n        ctx.export(\"mongodbatlasSearchDeploymentId\", example.applyValue(getSearchDeploymentResult -\u003e getSearchDeploymentResult).applyValue(example -\u003e example.applyValue(getSearchDeploymentResult -\u003e getSearchDeploymentResult.id())));\n    }\n}\n```\n```yaml\nresources:\n  exampleProject:\n    type: mongodbatlas:Project\n    name: example\n    properties:\n      name: project-name\n      orgId: ${orgId}\n  exampleAdvancedCluster:\n    type: mongodbatlas:AdvancedCluster\n    name: example\n    properties:\n      projectId: ${exampleProject.id}\n      name: ClusterExample\n      clusterType: REPLICASET\n      replicationSpecs:\n        - regionConfigs:\n            - electableSpecs:\n                instanceSize: M10\n                nodeCount: 3\n              providerName: AWS\n              priority: 7\n              regionName: US_EAST_1\n  exampleSearchDeployment:\n    type: mongodbatlas:SearchDeployment\n    name: example\n    properties:\n      projectId: ${exampleProject.id}\n      clusterName: ${exampleAdvancedCluster.name}\n      specs:\n        - instance_size: S20_HIGHCPU_NVME\n          node_count: 2\nvariables:\n  example:\n    fn::invoke:\n      Function: mongodbatlas:getSearchDeployment\n      Arguments:\n        projectId: ${exampleSearchDeployment.projectId}\n        clusterName: ${exampleSearchDeployment.clusterName}\noutputs:\n  mongodbatlasSearchDeploymentId: ${example.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getSearchDeployment.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "Label that identifies the cluster to return the search nodes for.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies your project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSearchDeployment.\n",
                "properties": {
                    "clusterName": {
                        "description": "Label that identifies the cluster to return the search nodes for.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "Unique 24-hexadecimal digit string that identifies the search deployment.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "description": "Unique 24-hexadecimal digit string that identifies your project.\n",
                        "type": "string"
                    },
                    "specs": {
                        "description": "List of settings that configure the search nodes for your cluster. This list is currently limited to defining a single element.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getSearchDeploymentSpec:getSearchDeploymentSpec"
                        },
                        "type": "array"
                    },
                    "stateName": {
                        "description": "Human-readable label that indicates the current operating condition of this search deployment.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "clusterName",
                    "id",
                    "projectId",
                    "specs",
                    "stateName"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getSearchIndex:getSearchIndex": {
            "description": "## # Data Source: mongodbatlas.SearchIndex\n\n`mongodbatlas.SearchIndex` describes a single search indexes. This represents a single search index that have been created.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = mongodbatlas.getSearchIndex({\n    indexId: \"\u003cINDEX_ID\",\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    clusterName: \"\u003cCLUSTER_NAME\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.get_search_index(index_id=\"\u003cINDEX_ID\",\n    project_id=\"\u003cPROJECT_ID\u003e\",\n    cluster_name=\"\u003cCLUSTER_NAME\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Mongodbatlas.GetSearchIndex.Invoke(new()\n    {\n        IndexId = \"\u003cINDEX_ID\",\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        ClusterName = \"\u003cCLUSTER_NAME\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.LookupSearchIndex(ctx, \u0026mongodbatlas.LookupSearchIndexArgs{\n\t\t\tIndexId:     \"\u003cINDEX_ID\",\n\t\t\tProjectId:   \"\u003cPROJECT_ID\u003e\",\n\t\t\tClusterName: \"\u003cCLUSTER_NAME\u003e\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetSearchIndexArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getSearchIndex(GetSearchIndexArgs.builder()\n            .indexId(\"\u003cINDEX_ID\")\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .clusterName(\"\u003cCLUSTER_NAME\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getSearchIndex\n      Arguments:\n        indexId: \u003cINDEX_ID\n        projectId: \u003cPROJECT_ID\u003e\n        clusterName: \u003cCLUSTER_NAME\u003e\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getSearchIndex.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "The name of the cluster containing the collection with one or more Atlas Search indexes.\n"
                    },
                    "indexId": {
                        "type": "string",
                        "description": "The unique identifier of the Atlas Search index. Use the `mongodbatlas.getSearchIndexes`datasource to find the IDs of all Atlas Search indexes.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique identifier for the [project](https://docs.atlas.mongodb.com/organizations-projects/#std-label-projects) that contains the specified cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "indexId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSearchIndex.\n",
                "properties": {
                    "analyzer": {
                        "description": "[Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.\n",
                        "type": "string"
                    },
                    "analyzers": {
                        "description": "[Custom analyzers](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-custom-analyzers) to use in this index (this is an array of objects).\n",
                        "type": "string"
                    },
                    "clusterName": {
                        "type": "string"
                    },
                    "collectionName": {
                        "description": "Name of the collection the index is on.\n",
                        "type": "string"
                    },
                    "database": {
                        "description": "Name of the database the collection is in.\n",
                        "type": "string"
                    },
                    "fields": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "indexId": {
                        "type": "string"
                    },
                    "mappingsDynamic": {
                        "description": "Flag indicating whether the index uses dynamic or static mappings.\n",
                        "type": "boolean"
                    },
                    "mappingsFields": {
                        "description": "Object containing one or more field specifications.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "Name of the index.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "searchAnalyzer": {
                        "description": "[Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when searching the index.\n",
                        "type": "string"
                    },
                    "status": {
                        "description": "Current status of the index.\n",
                        "type": "string"
                    },
                    "storedSource": {
                        "description": "String that can be \"true\" (store all fields), \"false\" (default, don't store any field), or a JSON string that contains the list of fields to store (include) or not store (exclude) on Atlas Search. To learn more, see [Stored Source Fields](https://www.mongodb.com/docs/atlas/atlas-search/stored-source-definition/).\n",
                        "type": "string"
                    },
                    "synonyms": {
                        "description": "Synonyms mapping definition to use in this index.\n* `synonyms.#.name` - Name of the [synonym mapping definition](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-ref).\n* `synonyms.#.source_collection` - Name of the source MongoDB collection for the synonyms.\n* `synonyms.#.analyzer` - Name of the [analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use with this synonym mapping.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getSearchIndexSynonym:getSearchIndexSynonym"
                        },
                        "type": "array"
                    },
                    "type": {
                        "type": "string"
                    }
                },
                "required": [
                    "analyzer",
                    "analyzers",
                    "clusterName",
                    "collectionName",
                    "database",
                    "fields",
                    "indexId",
                    "mappingsDynamic",
                    "mappingsFields",
                    "name",
                    "projectId",
                    "searchAnalyzer",
                    "status",
                    "storedSource",
                    "synonyms",
                    "type",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getSearchIndexes:getSearchIndexes": {
            "description": "## # Data Source: mongodbatlas.getSearchIndexes\n\n`mongodbatlas.getSearchIndexes` describes all search indexes. This represents search indexes that have been created.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetSearchIndexesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getSearchIndexes(GetSearchIndexesArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .clusterName(\"\u003cCLUSTER_NAME\u003e\")\n            .databaseName(\"\u003cDATABASE_NAME\u003e\")\n            .collectionName(\"\u003cCOLLECTION_NAME\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getSearchIndexes\n      Arguments:\n        projectId: \u003cPROJECT_ID\u003e\n        clusterName: \u003cCLUSTER_NAME\u003e\n        databaseName: \u003cDATABASE_NAME\u003e\n        collectionName: \u003cCOLLECTION_NAME\u003e\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getSearchIndexes.\n",
                "properties": {
                    "clusterName": {
                        "type": "string",
                        "description": "Name of the cluster containing the collection with one or more Atlas Search indexes.\n"
                    },
                    "collectionName": {
                        "type": "string",
                        "description": "Name of the collection with one or more Atlas Search indexes.\n"
                    },
                    "database": {
                        "type": "string",
                        "description": "(Required) Name of the database the collection is in.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique identifier for the [project](https://docs.atlas.mongodb.com/organizations-projects/#std-label-projects) that contains the specified cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "collectionName",
                    "database",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSearchIndexes.\n",
                "properties": {
                    "clusterName": {
                        "type": "string"
                    },
                    "collectionName": {
                        "description": "(Required) Name of the collection the index is on.\n",
                        "type": "string"
                    },
                    "database": {
                        "description": "(Required) Name of the database the collection is in.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "description": "A list where each represents a search index.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getSearchIndexesResult:getSearchIndexesResult"
                        },
                        "type": "array"
                    },
                    "totalCount": {
                        "description": "Represents the total of the search indexes\n",
                        "type": "integer"
                    }
                },
                "required": [
                    "clusterName",
                    "collectionName",
                    "database",
                    "projectId",
                    "results",
                    "totalCount",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getServerlessInstance:getServerlessInstance": {
            "description": "## # Data Source: mongodbatlas.ServerlessInstance\n\n`mongodbatlas.ServerlessInstance` describes a single serverless instance. This represents a single serverless instance that have been created.\n\u003e **NOTE:**  Serverless instances do not support some Atlas features at this time.\nFor a full list of unsupported features, see [Serverless Instance Limitations](https://docs.atlas.mongodb.com/reference/serverless-instance-limitations/).\n \n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n## Example Usage\n\n### Basic\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testTwo = mongodbatlas.getServerlessInstance({\n    name: \"\u003cSERVERLESS_INSTANCE_NAME\u003e\",\n    projectId: \"\u003cPROJECT_ID \u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_two = mongodbatlas.get_serverless_instance(name=\"\u003cSERVERLESS_INSTANCE_NAME\u003e\",\n    project_id=\"\u003cPROJECT_ID \u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testTwo = Mongodbatlas.GetServerlessInstance.Invoke(new()\n    {\n        Name = \"\u003cSERVERLESS_INSTANCE_NAME\u003e\",\n        ProjectId = \"\u003cPROJECT_ID \u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.LookupServerlessInstance(ctx, \u0026mongodbatlas.LookupServerlessInstanceArgs{\n\t\t\tName:      \"\u003cSERVERLESS_INSTANCE_NAME\u003e\",\n\t\t\tProjectId: \"\u003cPROJECT_ID \u003e\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetServerlessInstanceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var testTwo = MongodbatlasFunctions.getServerlessInstance(GetServerlessInstanceArgs.builder()\n            .name(\"\u003cSERVERLESS_INSTANCE_NAME\u003e\")\n            .projectId(\"\u003cPROJECT_ID \u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  testTwo:\n    fn::invoke:\n      Function: mongodbatlas:getServerlessInstance\n      Arguments:\n        name: \u003cSERVERLESS_INSTANCE_NAME\u003e\n        projectId: \u003cPROJECT_ID \u003e\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n**NOTE:**  `mongodbatlas.ServerlessInstance` and `mongodbatlas.PrivatelinkEndpointServiceServerless` resources have a circular dependency in some respects.\\\nThat is, the `serverless_instance` must exist before the `privatelink_endpoint_service` can be created,\\\nand the `privatelink_endpoint_service` must exist before the `serverless_instance` gets its respective `connection_strings_private_endpoint_srv` values.\n\nBecause of this, the `serverless_instance` data source has particular value as a source of the `connection_strings_private_endpoint_srv`.\\\nWhen using the data_source in-tandem with the afforementioned resources, we can create and retrieve the `connection_strings_private_endpoint_srv` in a single `pulumi up`.\n\nFollow this example to setup private connection to a serverless instance using aws vpc and get the connection strings in a single `pulumi up`\n",
            "inputs": {
                "description": "A collection of arguments for invoking getServerlessInstance.\n",
                "properties": {
                    "autoIndexing": {
                        "type": "boolean",
                        "description": "Flag that indicates whether the serverless instance uses [Serverless Auto Indexing](https://www.mongodb.com/docs/atlas/performance-advisor/auto-index-serverless/).\n"
                    },
                    "continuousBackupEnabled": {
                        "type": "boolean",
                        "description": "Flag that indicates whether the serverless instance uses Serverless Continuous Backup.\n"
                    },
                    "links": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getServerlessInstanceLink:getServerlessInstanceLink"
                        }
                    },
                    "name": {
                        "type": "string",
                        "description": "Human-readable label that identifies your serverless instance.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies the project that contains your serverless instance.\n"
                    },
                    "stateName": {
                        "type": "string",
                        "description": "Stage of deployment of this serverless instance when the resource made its request.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getServerlessInstance.\n",
                "properties": {
                    "autoIndexing": {
                        "description": "Flag that indicates whether the serverless instance uses [Serverless Auto Indexing](https://www.mongodb.com/docs/atlas/performance-advisor/auto-index-serverless/).\n",
                        "type": "boolean"
                    },
                    "connectionStringsPrivateEndpointSrvs": {
                        "description": "List of Serverless Private Endpoint Connections\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "connectionStringsStandardSrv": {
                        "description": "Public `mongodb+srv://` connection string that you can use to connect to this serverless instance.\n",
                        "type": "string"
                    },
                    "continuousBackupEnabled": {
                        "description": "Flag that indicates whether the serverless instance uses Serverless Continuous Backup.\n",
                        "type": "boolean"
                    },
                    "createDate": {
                        "type": "string"
                    },
                    "id": {
                        "description": "Unique 24-hexadecimal digit string that identifies the serverless instance.\n",
                        "type": "string"
                    },
                    "links": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getServerlessInstanceLink:getServerlessInstanceLink"
                        },
                        "type": "array"
                    },
                    "mongoDbVersion": {
                        "description": "Version of MongoDB that the serverless instance runs, in `\u003cmajor version\u003e`.`\u003cminor version\u003e` format.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "providerSettingsBackingProviderName": {
                        "description": "Cloud service provider on which MongoDB Cloud provisioned the serverless instance.\n",
                        "type": "string"
                    },
                    "providerSettingsProviderName": {
                        "description": "Cloud service provider that applies to the provisioned the serverless instance.\n",
                        "type": "string"
                    },
                    "providerSettingsRegionName": {
                        "description": "Human-readable label that identifies the physical location of your MongoDB serverless instance. The region you choose can affect network latency for clients accessing your databases.\n",
                        "type": "string"
                    },
                    "stateName": {
                        "description": "Stage of deployment of this serverless instance when the resource made its request.\n",
                        "type": "string"
                    },
                    "tags": {
                        "description": "Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getServerlessInstanceTag:getServerlessInstanceTag"
                        },
                        "type": "array"
                    },
                    "terminationProtectionEnabled": {
                        "description": "Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.\n",
                        "type": "boolean"
                    }
                },
                "required": [
                    "autoIndexing",
                    "connectionStringsPrivateEndpointSrvs",
                    "connectionStringsStandardSrv",
                    "continuousBackupEnabled",
                    "createDate",
                    "id",
                    "links",
                    "mongoDbVersion",
                    "name",
                    "projectId",
                    "providerSettingsBackingProviderName",
                    "providerSettingsProviderName",
                    "providerSettingsRegionName",
                    "stateName",
                    "tags",
                    "terminationProtectionEnabled"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getServerlessInstances:getServerlessInstances": {
            "description": "## # Data Source: mongodbatlas.getServerlessInstances\n\n`mongodbatlas.getServerlessInstances` describes all serverless instances. This represents serverless instances that have been created for the specified group id.\n\n\u003e **NOTE:**  Serverless instances do not support some Atlas features at this time.\nFor a full list of unsupported features, see [Serverless Instance Limitations](https://docs.atlas.mongodb.com/reference/serverless-instance-limitations/).\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst dataServerless = mongodbatlas.getServerlessInstances({\n    projectId: \"\u003cPROJECT_ID\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ndata_serverless = mongodbatlas.get_serverless_instances(project_id=\"\u003cPROJECT_ID\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var dataServerless = Mongodbatlas.GetServerlessInstances.Invoke(new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.LookupServerlessInstances(ctx, \u0026mongodbatlas.LookupServerlessInstancesArgs{\n\t\t\tProjectId: \"\u003cPROJECT_ID\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetServerlessInstancesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var dataServerless = MongodbatlasFunctions.getServerlessInstances(GetServerlessInstancesArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  dataServerless:\n    fn::invoke:\n      Function: mongodbatlas:getServerlessInstances\n      Arguments:\n        projectId: \u003cPROJECT_ID\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getServerlessInstances.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "Unique identifier for the [project](https://docs.atlas.mongodb.com/organizations-projects/#std-label-projects) that contains the specified cluster.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getServerlessInstances.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "description": "A list where each result represents a Serverless Instance. To learn more, see Serverless Instance.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getServerlessInstancesResult:getServerlessInstancesResult"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "projectId",
                    "results",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getSharedTierRestoreJob:getSharedTierRestoreJob": {
            "inputs": {
                "description": "A collection of arguments for invoking getSharedTierRestoreJob.\n",
                "properties": {
                    "clusterName": {
                        "type": "string"
                    },
                    "jobId": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "jobId",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSharedTierRestoreJob.\n",
                "properties": {
                    "clusterName": {
                        "type": "string"
                    },
                    "deliveryType": {
                        "type": "string"
                    },
                    "expirationDate": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "jobId": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "restoreFinishedDate": {
                        "type": "string"
                    },
                    "restoreScheduledDate": {
                        "type": "string"
                    },
                    "snapshotFinishedDate": {
                        "type": "string"
                    },
                    "snapshotId": {
                        "type": "string"
                    },
                    "snapshotUrl": {
                        "type": "string"
                    },
                    "status": {
                        "type": "string"
                    },
                    "targetDeploymentItemName": {
                        "type": "string"
                    },
                    "targetProjectId": {
                        "type": "string"
                    }
                },
                "required": [
                    "clusterName",
                    "deliveryType",
                    "expirationDate",
                    "jobId",
                    "projectId",
                    "restoreFinishedDate",
                    "restoreScheduledDate",
                    "snapshotFinishedDate",
                    "snapshotId",
                    "snapshotUrl",
                    "status",
                    "targetDeploymentItemName",
                    "targetProjectId",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getSharedTierRestoreJobs:getSharedTierRestoreJobs": {
            "inputs": {
                "description": "A collection of arguments for invoking getSharedTierRestoreJobs.\n",
                "properties": {
                    "clusterName": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSharedTierRestoreJobs.\n",
                "properties": {
                    "clusterName": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getSharedTierRestoreJobsResult:getSharedTierRestoreJobsResult"
                        },
                        "type": "array"
                    },
                    "totalCount": {
                        "type": "integer"
                    }
                },
                "required": [
                    "clusterName",
                    "projectId",
                    "results",
                    "totalCount",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getSharedTierSnapshot:getSharedTierSnapshot": {
            "inputs": {
                "description": "A collection of arguments for invoking getSharedTierSnapshot.\n",
                "properties": {
                    "clusterName": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "snapshotId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId",
                    "snapshotId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSharedTierSnapshot.\n",
                "properties": {
                    "clusterName": {
                        "type": "string"
                    },
                    "expiration": {
                        "type": "string"
                    },
                    "finishTime": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "mongoDbVersion": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "scheduledTime": {
                        "type": "string"
                    },
                    "snapshotId": {
                        "type": "string"
                    },
                    "startTime": {
                        "type": "string"
                    },
                    "status": {
                        "type": "string"
                    }
                },
                "required": [
                    "clusterName",
                    "expiration",
                    "finishTime",
                    "mongoDbVersion",
                    "projectId",
                    "scheduledTime",
                    "snapshotId",
                    "startTime",
                    "status",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getSharedTierSnapshots:getSharedTierSnapshots": {
            "inputs": {
                "description": "A collection of arguments for invoking getSharedTierSnapshots.\n",
                "properties": {
                    "clusterName": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "clusterName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getSharedTierSnapshots.\n",
                "properties": {
                    "clusterName": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "results": {
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getSharedTierSnapshotsResult:getSharedTierSnapshotsResult"
                        },
                        "type": "array"
                    },
                    "totalCount": {
                        "type": "integer"
                    }
                },
                "required": [
                    "clusterName",
                    "projectId",
                    "results",
                    "totalCount",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getStreamConnection:getStreamConnection": {
            "description": "## # Data Source: mongodbatlas.StreamConnection\n\n`mongodbatlas.StreamConnection` describes a stream connection.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst example = mongodbatlas.getStreamConnection({\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: \"\u003cINSTANCE_NAME\u003e\",\n    connectionName: \"\u003cCONNECTION_NAME\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nexample = mongodbatlas.get_stream_connection(project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=\"\u003cINSTANCE_NAME\u003e\",\n    connection_name=\"\u003cCONNECTION_NAME\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Mongodbatlas.GetStreamConnection.Invoke(new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = \"\u003cINSTANCE_NAME\u003e\",\n        ConnectionName = \"\u003cCONNECTION_NAME\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.LookupStreamConnection(ctx, \u0026mongodbatlas.LookupStreamConnectionArgs{\n\t\t\tProjectId:      \"\u003cPROJECT_ID\u003e\",\n\t\t\tInstanceName:   \"\u003cINSTANCE_NAME\u003e\",\n\t\t\tConnectionName: \"\u003cCONNECTION_NAME\u003e\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetStreamConnectionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = MongodbatlasFunctions.getStreamConnection(GetStreamConnectionArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(\"\u003cINSTANCE_NAME\u003e\")\n            .connectionName(\"\u003cCONNECTION_NAME\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: mongodbatlas:getStreamConnection\n      Arguments:\n        projectId: \u003cPROJECT_ID\u003e\n        instanceName: \u003cINSTANCE_NAME\u003e\n        connectionName: \u003cCONNECTION_NAME\u003e\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getStreamConnection.\n",
                "properties": {
                    "connectionName": {
                        "type": "string",
                        "description": "Human-readable label that identifies the stream connection. In the case of the Sample type, this is the name of the sample source.\n"
                    },
                    "instanceName": {
                        "type": "string",
                        "description": "Human-readable label that identifies the stream instance.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies your project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "connectionName",
                    "instanceName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getStreamConnection.\n",
                "properties": {
                    "authentication": {
                        "$ref": "#/types/mongodbatlas:index/getStreamConnectionAuthentication:getStreamConnectionAuthentication",
                        "description": "User credentials required to connect to a Kafka cluster. Includes the authentication type, as well as the parameters for that authentication mode. See authentication.\n"
                    },
                    "bootstrapServers": {
                        "description": "Comma separated list of server addresses.\n",
                        "type": "string"
                    },
                    "clusterName": {
                        "description": "Name of the cluster configured for this connection.\n",
                        "type": "string"
                    },
                    "config": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of Kafka key-value pairs for optional configuration. This is a flat object, and keys can have '.' characters.\n",
                        "type": "object"
                    },
                    "connectionName": {
                        "type": "string"
                    },
                    "dbRoleToExecute": {
                        "$ref": "#/types/mongodbatlas:index/getStreamConnectionDbRoleToExecute:getStreamConnectionDbRoleToExecute",
                        "description": "The name of a Built in or Custom DB Role to connect to an Atlas Cluster. See DBRoleToExecute.\n"
                    },
                    "id": {
                        "type": "string"
                    },
                    "instanceName": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "security": {
                        "$ref": "#/types/mongodbatlas:index/getStreamConnectionSecurity:getStreamConnectionSecurity",
                        "description": "Properties for the secure transport connection to Kafka. For SSL, this can include the trusted certificate to use. See security.\n"
                    },
                    "type": {
                        "description": "Type of the DB role. Can be either BUILT_IN or CUSTOM.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "authentication",
                    "bootstrapServers",
                    "clusterName",
                    "config",
                    "connectionName",
                    "dbRoleToExecute",
                    "id",
                    "instanceName",
                    "projectId",
                    "security",
                    "type"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getStreamConnections:getStreamConnections": {
            "description": "## # Data Source: mongodbatlas.getStreamConnections\n\n`mongodbatlas.getStreamConnections` describes all connections of a stream instance for the specified project.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = mongodbatlas.getStreamConnections({\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: \"\u003cINSTANCE_NAME\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.get_stream_connections(project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=\"\u003cINSTANCE_NAME\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Mongodbatlas.GetStreamConnections.Invoke(new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = \"\u003cINSTANCE_NAME\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.LookupStreamConnections(ctx, \u0026mongodbatlas.LookupStreamConnectionsArgs{\n\t\t\tProjectId:    \"\u003cPROJECT_ID\u003e\",\n\t\t\tInstanceName: \"\u003cINSTANCE_NAME\u003e\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetStreamConnectionsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getStreamConnections(GetStreamConnectionsArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(\"\u003cINSTANCE_NAME\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getStreamConnections\n      Arguments:\n        projectId: \u003cPROJECT_ID\u003e\n        instanceName: \u003cINSTANCE_NAME\u003e\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getStreamConnections.\n",
                "properties": {
                    "instanceName": {
                        "type": "string",
                        "description": "Human-readable label that identifies the stream instance.\n"
                    },
                    "itemsPerPage": {
                        "type": "integer",
                        "description": "Number of items that the response returns per page, up to a maximum of `500`. Defaults to `100`.\n"
                    },
                    "pageNum": {
                        "type": "integer",
                        "description": "Number of the page that displays the current set of the total objects that the response returns. Defaults to `1`.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies your project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "instanceName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getStreamConnections.\n",
                "properties": {
                    "id": {
                        "type": "string"
                    },
                    "instanceName": {
                        "description": "Human-readable label that identifies the stream instance.\n",
                        "type": "string"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "projectId": {
                        "description": "Unique 24-hexadecimal digit string that identifies your project.\n",
                        "type": "string"
                    },
                    "results": {
                        "description": "A list where each element contains a stream connection.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getStreamConnectionsResult:getStreamConnectionsResult"
                        },
                        "type": "array"
                    },
                    "totalCount": {
                        "description": "Count of the total number of items in the result set. The count might be greater than the number of objects in the results array if the entire result set is paginated.\n",
                        "type": "integer"
                    }
                },
                "required": [
                    "id",
                    "instanceName",
                    "projectId",
                    "results",
                    "totalCount"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getStreamInstance:getStreamInstance": {
            "description": "## # Data Source: mongodbatlas.StreamInstance\n\n`mongodbatlas.StreamInstance` describes a stream instance.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst example = mongodbatlas.getStreamInstance({\n    projectId: \"\u003cPROJECT_ID\u003e\",\n    instanceName: \"\u003cINSTANCE_NAME\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\nexample = mongodbatlas.get_stream_instance(project_id=\"\u003cPROJECT_ID\u003e\",\n    instance_name=\"\u003cINSTANCE_NAME\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = Mongodbatlas.GetStreamInstance.Invoke(new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n        InstanceName = \"\u003cINSTANCE_NAME\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.LookupStreamInstance(ctx, \u0026mongodbatlas.LookupStreamInstanceArgs{\n\t\t\tProjectId:    \"\u003cPROJECT_ID\u003e\",\n\t\t\tInstanceName: \"\u003cINSTANCE_NAME\u003e\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetStreamInstanceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var example = MongodbatlasFunctions.getStreamInstance(GetStreamInstanceArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .instanceName(\"\u003cINSTANCE_NAME\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  example:\n    fn::invoke:\n      Function: mongodbatlas:getStreamInstance\n      Arguments:\n        projectId: \u003cPROJECT_ID\u003e\n        instanceName: \u003cINSTANCE_NAME\u003e\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getStreamInstance.\n",
                "properties": {
                    "instanceName": {
                        "type": "string",
                        "description": "Human-readable label that identifies the stream instance.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies your project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "instanceName",
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getStreamInstance.\n",
                "properties": {
                    "dataProcessRegion": {
                        "$ref": "#/types/mongodbatlas:index/getStreamInstanceDataProcessRegion:getStreamInstanceDataProcessRegion",
                        "description": "Defines the cloud service provider and region where MongoDB Cloud performs stream processing. See data process region.\n"
                    },
                    "hostnames": {
                        "description": "List that contains the hostnames assigned to the stream instance.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "id": {
                        "type": "string"
                    },
                    "instanceName": {
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "streamConfig": {
                        "$ref": "#/types/mongodbatlas:index/getStreamInstanceStreamConfig:getStreamInstanceStreamConfig",
                        "description": "Defines the configuration options for an Atlas Stream Processing Instance. See stream config\n"
                    }
                },
                "required": [
                    "dataProcessRegion",
                    "hostnames",
                    "id",
                    "instanceName",
                    "projectId",
                    "streamConfig"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getStreamInstances:getStreamInstances": {
            "description": "## # Data Source: mongodbatlas.getStreamInstances\n\n`mongodbatlas.getStreamInstances` describes the stream instances defined in a project.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = mongodbatlas.getStreamInstances({\n    projectId: \"\u003cPROJECT_ID\u003e\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.get_stream_instances(project_id=\"\u003cPROJECT_ID\u003e\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Mongodbatlas.GetStreamInstances.Invoke(new()\n    {\n        ProjectId = \"\u003cPROJECT_ID\u003e\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := mongodbatlas.LookupStreamInstances(ctx, \u0026mongodbatlas.LookupStreamInstancesArgs{\n\t\t\tProjectId: \"\u003cPROJECT_ID\u003e\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetStreamInstancesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = MongodbatlasFunctions.getStreamInstances(GetStreamInstancesArgs.builder()\n            .projectId(\"\u003cPROJECT_ID\u003e\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getStreamInstances\n      Arguments:\n        projectId: \u003cPROJECT_ID\u003e\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getStreamInstances.\n",
                "properties": {
                    "itemsPerPage": {
                        "type": "integer",
                        "description": "Number of items that the response returns per page, up to a maximum of `500`. Defaults to `100`.\n"
                    },
                    "pageNum": {
                        "type": "integer",
                        "description": "Number of the page that displays the current set of the total objects that the response returns. Defaults to `1`.\n"
                    },
                    "projectId": {
                        "type": "string",
                        "description": "Unique 24-hexadecimal digit string that identifies your project.\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getStreamInstances.\n",
                "properties": {
                    "id": {
                        "type": "string"
                    },
                    "itemsPerPage": {
                        "type": "integer"
                    },
                    "pageNum": {
                        "type": "integer"
                    },
                    "projectId": {
                        "description": "Unique 24-hexadecimal digit string that identifies your project.\n",
                        "type": "string"
                    },
                    "results": {
                        "description": "A list where each element contains a Stream Instance.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getStreamInstancesResult:getStreamInstancesResult"
                        },
                        "type": "array"
                    },
                    "totalCount": {
                        "description": "Count of the total number of items in the result set. The count might be greater than the number of objects in the results array if the entire result set is paginated.\n",
                        "type": "integer"
                    }
                },
                "required": [
                    "id",
                    "projectId",
                    "results",
                    "totalCount"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getTeam:getTeam": {
            "description": "## # Data Source: mongodbatlas.Team\n\n`mongodbatlas.Team` describes a Team. The resource requires your Organization ID, Project ID and Team ID.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `group_id` in the official documentation.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testTeam = new mongodbatlas.Team(\"test\", {\n    orgId: \"\u003cORGANIZATION-ID\u003e\",\n    name: \"myNewTeam\",\n    usernames: [\n        \"user1\",\n        \"user2\",\n        \"user3\",\n    ],\n});\nconst test = mongodbatlas.getTeamOutput({\n    orgId: testTeam.orgId,\n    teamId: testTeam.teamId,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_team = mongodbatlas.Team(\"test\",\n    org_id=\"\u003cORGANIZATION-ID\u003e\",\n    name=\"myNewTeam\",\n    usernames=[\n        \"user1\",\n        \"user2\",\n        \"user3\",\n    ])\ntest = mongodbatlas.get_team_output(org_id=test_team.org_id,\n    team_id=test_team.team_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testTeam = new Mongodbatlas.Team(\"test\", new()\n    {\n        OrgId = \"\u003cORGANIZATION-ID\u003e\",\n        Name = \"myNewTeam\",\n        Usernames = new[]\n        {\n            \"user1\",\n            \"user2\",\n            \"user3\",\n        },\n    });\n\n    var test = Mongodbatlas.GetTeam.Invoke(new()\n    {\n        OrgId = testTeam.OrgId,\n        TeamId = testTeam.TeamId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestTeam, err := mongodbatlas.NewTeam(ctx, \"test\", \u0026mongodbatlas.TeamArgs{\n\t\t\tOrgId: pulumi.String(\"\u003cORGANIZATION-ID\u003e\"),\n\t\t\tName:  pulumi.String(\"myNewTeam\"),\n\t\t\tUsernames: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"user1\"),\n\t\t\t\tpulumi.String(\"user2\"),\n\t\t\t\tpulumi.String(\"user3\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupTeamOutput(ctx, mongodbatlas.GetTeamOutputArgs{\n\t\t\tOrgId:  testTeam.OrgId,\n\t\t\tTeamId: testTeam.TeamId,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Team;\nimport com.pulumi.mongodbatlas.TeamArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetTeamArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testTeam = new Team(\"testTeam\", TeamArgs.builder()\n            .orgId(\"\u003cORGANIZATION-ID\u003e\")\n            .name(\"myNewTeam\")\n            .usernames(            \n                \"user1\",\n                \"user2\",\n                \"user3\")\n            .build());\n\n        final var test = MongodbatlasFunctions.getTeam(GetTeamArgs.builder()\n            .orgId(testTeam.orgId())\n            .teamId(testTeam.teamId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testTeam:\n    type: mongodbatlas:Team\n    name: test\n    properties:\n      orgId: \u003cORGANIZATION-ID\u003e\n      name: myNewTeam\n      usernames:\n        - user1\n        - user2\n        - user3\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getTeam\n      Arguments:\n        orgId: ${testTeam.orgId}\n        teamId: ${testTeam.teamId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst test = new mongodbatlas.Team(\"test\", {\n    orgId: \"\u003cORGANIZATION-ID\u003e\",\n    name: \"myNewTeam\",\n    usernames: [\n        \"user1\",\n        \"user2\",\n        \"user3\",\n    ],\n});\nconst test2 = mongodbatlas.getTeamOutput({\n    orgId: test.orgId,\n    name: test.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest = mongodbatlas.Team(\"test\",\n    org_id=\"\u003cORGANIZATION-ID\u003e\",\n    name=\"myNewTeam\",\n    usernames=[\n        \"user1\",\n        \"user2\",\n        \"user3\",\n    ])\ntest2 = mongodbatlas.get_team_output(org_id=test.org_id,\n    name=test.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Mongodbatlas.Team(\"test\", new()\n    {\n        OrgId = \"\u003cORGANIZATION-ID\u003e\",\n        Name = \"myNewTeam\",\n        Usernames = new[]\n        {\n            \"user1\",\n            \"user2\",\n            \"user3\",\n        },\n    });\n\n    var test2 = Mongodbatlas.GetTeam.Invoke(new()\n    {\n        OrgId = test.OrgId,\n        Name = test.Name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := mongodbatlas.NewTeam(ctx, \"test\", \u0026mongodbatlas.TeamArgs{\n\t\t\tOrgId: pulumi.String(\"\u003cORGANIZATION-ID\u003e\"),\n\t\t\tName:  pulumi.String(\"myNewTeam\"),\n\t\t\tUsernames: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"user1\"),\n\t\t\t\tpulumi.String(\"user2\"),\n\t\t\t\tpulumi.String(\"user3\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupTeamOutput(ctx, mongodbatlas.GetTeamOutputArgs{\n\t\t\tOrgId: test.OrgId,\n\t\t\tName:  test.Name,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.Team;\nimport com.pulumi.mongodbatlas.TeamArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetTeamArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new Team(\"test\", TeamArgs.builder()\n            .orgId(\"\u003cORGANIZATION-ID\u003e\")\n            .name(\"myNewTeam\")\n            .usernames(            \n                \"user1\",\n                \"user2\",\n                \"user3\")\n            .build());\n\n        final var test2 = MongodbatlasFunctions.getTeam(GetTeamArgs.builder()\n            .orgId(test.orgId())\n            .name(test.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: mongodbatlas:Team\n    properties:\n      orgId: \u003cORGANIZATION-ID\u003e\n      name: myNewTeam\n      usernames:\n        - user1\n        - user2\n        - user3\nvariables:\n  test2:\n    fn::invoke:\n      Function: mongodbatlas:getTeam\n      Arguments:\n        orgId: ${test.orgId}\n        name: ${test.name}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getTeam.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The team name.\n\n\u003e **IMPORTANT:** Either `team_id` or `name` must be configured.\n"
                    },
                    "orgId": {
                        "type": "string",
                        "description": "The unique identifier for the organization you want to associate the team with.\n"
                    },
                    "teamId": {
                        "type": "string",
                        "description": "The unique identifier for the team.\n"
                    }
                },
                "type": "object",
                "required": [
                    "orgId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getTeam.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "The name of the team you want to create.\n",
                        "type": "string"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "teamId": {
                        "description": "The unique identifier for the team.\n",
                        "type": "string"
                    },
                    "usernames": {
                        "description": "The users who are part of the organization.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "name",
                    "orgId",
                    "teamId",
                    "usernames",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getTeams:getTeams": {
            "description": "**WARNING:** This datasource is deprecated, use `mongodbatlas.Team`\n\nThis data source is deprecated. Please transition to using `mongodbatlas.Team` which defines the same underlying implementation, aligning the name of the data source with the implementation which fetches a single team.\n\nIn the future this data source will define a new implementation capable of fetching all teams in one organization.\n",
            "inputs": {
                "description": "A collection of arguments for invoking getTeams.\n",
                "properties": {
                    "name": {
                        "type": "string"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "teamId": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "orgId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getTeams.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "orgId": {
                        "type": "string"
                    },
                    "teamId": {
                        "type": "string"
                    },
                    "usernames": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "name",
                    "orgId",
                    "teamId",
                    "usernames",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getThirdPartyIntegration:getThirdPartyIntegration": {
            "description": "## # Data Source: mongodbatlas.ThirdPartyIntegration\n\n`mongodbatlas.ThirdPartyIntegration` describes a Third-Party Integration Settings for the given type.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testDatadog = new mongodbatlas.ThirdPartyIntegration(\"test_datadog\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    type: \"DATADOG\",\n    apiKey: \"\u003cAPI-KEY\u003e\",\n    region: \"\u003cREGION\u003e\",\n});\nconst test = mongodbatlas.getThirdPartyIntegrationOutput({\n    projectId: testDatadog.projectId,\n    type: \"DATADOG\",\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_datadog = mongodbatlas.ThirdPartyIntegration(\"test_datadog\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    type=\"DATADOG\",\n    api_key=\"\u003cAPI-KEY\u003e\",\n    region=\"\u003cREGION\u003e\")\ntest = mongodbatlas.get_third_party_integration_output(project_id=test_datadog.project_id,\n    type=\"DATADOG\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testDatadog = new Mongodbatlas.ThirdPartyIntegration(\"test_datadog\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        Type = \"DATADOG\",\n        ApiKey = \"\u003cAPI-KEY\u003e\",\n        Region = \"\u003cREGION\u003e\",\n    });\n\n    var test = Mongodbatlas.GetThirdPartyIntegration.Invoke(new()\n    {\n        ProjectId = testDatadog.ProjectId,\n        Type = \"DATADOG\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestDatadog, err := mongodbatlas.NewThirdPartyIntegration(ctx, \"test_datadog\", \u0026mongodbatlas.ThirdPartyIntegrationArgs{\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tType:      pulumi.String(\"DATADOG\"),\n\t\t\tApiKey:    pulumi.String(\"\u003cAPI-KEY\u003e\"),\n\t\t\tRegion:    pulumi.String(\"\u003cREGION\u003e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupThirdPartyIntegrationOutput(ctx, mongodbatlas.GetThirdPartyIntegrationOutputArgs{\n\t\t\tProjectId: testDatadog.ProjectId,\n\t\t\tType:      pulumi.String(\"DATADOG\"),\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ThirdPartyIntegration;\nimport com.pulumi.mongodbatlas.ThirdPartyIntegrationArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetThirdPartyIntegrationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testDatadog = new ThirdPartyIntegration(\"testDatadog\", ThirdPartyIntegrationArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .type(\"DATADOG\")\n            .apiKey(\"\u003cAPI-KEY\u003e\")\n            .region(\"\u003cREGION\u003e\")\n            .build());\n\n        final var test = MongodbatlasFunctions.getThirdPartyIntegration(GetThirdPartyIntegrationArgs.builder()\n            .projectId(testDatadog.projectId())\n            .type(\"DATADOG\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testDatadog:\n    type: mongodbatlas:ThirdPartyIntegration\n    name: test_datadog\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      type: DATADOG\n      apiKey: \u003cAPI-KEY\u003e\n      region: \u003cREGION\u003e\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getThirdPartyIntegration\n      Arguments:\n        projectId: ${testDatadog.projectId}\n        type: DATADOG\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getThirdPartyIntegration.\n",
                "properties": {
                    "enabled": {
                        "type": "boolean",
                        "description": "Whether your cluster has Prometheus enabled.\n"
                    },
                    "microsoftTeamsWebhookUrl": {
                        "type": "string",
                        "description": "Your Microsoft Teams incoming webhook URL.\n* `PROMETHEUS`\n",
                        "secret": true
                    },
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to get all Third-Party service integrations\n"
                    },
                    "serviceDiscovery": {
                        "type": "string",
                        "description": "Indicates which service discovery method is used, either file or http.\n",
                        "secret": true
                    },
                    "type": {
                        "type": "string",
                        "description": "Third-Party service integration type\n* PAGER_DUTY\n* DATADOG\n* OPS_GENIE\n* VICTOR_OPS\n* WEBHOOK\n* MICROSOFT_TEAMS\n* PROMETHEUS\n"
                    },
                    "userName": {
                        "type": "string",
                        "description": "Your Prometheus username.\n",
                        "secret": true
                    }
                },
                "type": "object",
                "required": [
                    "projectId",
                    "type"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getThirdPartyIntegration.\n",
                "properties": {
                    "accountId": {
                        "type": "string"
                    },
                    "apiKey": {
                        "description": "Your API Key.\n",
                        "secret": true,
                        "type": "string"
                    },
                    "channelName": {
                        "type": "string"
                    },
                    "enabled": {
                        "description": "Whether your cluster has Prometheus enabled.\n",
                        "type": "boolean"
                    },
                    "id": {
                        "description": "Unique identifier of the integration.\n",
                        "type": "string"
                    },
                    "microsoftTeamsWebhookUrl": {
                        "description": "Your Microsoft Teams incoming webhook URL.\n* `PROMETHEUS`\n",
                        "secret": true,
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "region": {
                        "description": "Two-letter code that indicates which API URL to use. See the `region` response field of [MongoDB API Third-Party Service Integration documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Third-Party-Integrations/operation/getThirdPartyIntegration) for more details. Opsgenie will use US by default.\n* `VICTOR_OPS`\n",
                        "type": "string"
                    },
                    "routingKey": {
                        "description": "An optional field for your Routing Key.\n* `WEBHOOK`\n",
                        "secret": true,
                        "type": "string"
                    },
                    "secret": {
                        "description": "An optional field for your webhook secret.\n* `MICROSOFT_TEAMS`\n",
                        "secret": true,
                        "type": "string"
                    },
                    "serviceDiscovery": {
                        "description": "Indicates which service discovery method is used, either file or http.\n",
                        "secret": true,
                        "type": "string"
                    },
                    "serviceKey": {
                        "description": "Your Service Key.\n* `DATADOG`\n",
                        "secret": true,
                        "type": "string"
                    },
                    "teamName": {
                        "type": "string"
                    },
                    "type": {
                        "type": "string"
                    },
                    "url": {
                        "description": "Your webhook URL.\n",
                        "type": "string"
                    },
                    "userName": {
                        "description": "Your Prometheus username.\n",
                        "secret": true,
                        "type": "string"
                    }
                },
                "required": [
                    "accountId",
                    "apiKey",
                    "channelName",
                    "id",
                    "projectId",
                    "region",
                    "routingKey",
                    "secret",
                    "serviceKey",
                    "teamName",
                    "type",
                    "url"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getThirdPartyIntegrations:getThirdPartyIntegrations": {
            "description": "## # Data Source: mongodbatlas.getThirdPartyIntegrations\n\n`mongodbatlas.getThirdPartyIntegrations` describes all Third-Party Integration Settings. This represents two Third-Party services `PAGER_DUTY` and `DATADOG`\napplied across the project. \n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find `groupId` in the official documentation.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testPagerDuty = new mongodbatlas.ThirdPartyIntegration(\"test_pager_duty\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    type: \"PAGER_DUTY\",\n    serviceKey: \"\u003cPAGER-DUTY-SERVICE-KEY\u003e\",\n});\nconst testDatadog = new mongodbatlas.ThirdPartyIntegration(\"test_datadog\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    type: \"DATADOG\",\n    apiKey: \"\u003cAPI-KEY\u003e\",\n    region: \"\u003cREGION\u003e\",\n});\nconst test = mongodbatlas.getThirdPartyIntegrationsOutput({\n    projectId: testPagerDuty.projectId,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_pager_duty = mongodbatlas.ThirdPartyIntegration(\"test_pager_duty\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    type=\"PAGER_DUTY\",\n    service_key=\"\u003cPAGER-DUTY-SERVICE-KEY\u003e\")\ntest_datadog = mongodbatlas.ThirdPartyIntegration(\"test_datadog\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    type=\"DATADOG\",\n    api_key=\"\u003cAPI-KEY\u003e\",\n    region=\"\u003cREGION\u003e\")\ntest = mongodbatlas.get_third_party_integrations_output(project_id=test_pager_duty.project_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testPagerDuty = new Mongodbatlas.ThirdPartyIntegration(\"test_pager_duty\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        Type = \"PAGER_DUTY\",\n        ServiceKey = \"\u003cPAGER-DUTY-SERVICE-KEY\u003e\",\n    });\n\n    var testDatadog = new Mongodbatlas.ThirdPartyIntegration(\"test_datadog\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        Type = \"DATADOG\",\n        ApiKey = \"\u003cAPI-KEY\u003e\",\n        Region = \"\u003cREGION\u003e\",\n    });\n\n    var test = Mongodbatlas.GetThirdPartyIntegrations.Invoke(new()\n    {\n        ProjectId = testPagerDuty.ProjectId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestPagerDuty, err := mongodbatlas.NewThirdPartyIntegration(ctx, \"test_pager_duty\", \u0026mongodbatlas.ThirdPartyIntegrationArgs{\n\t\t\tProjectId:  pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tType:       pulumi.String(\"PAGER_DUTY\"),\n\t\t\tServiceKey: pulumi.String(\"\u003cPAGER-DUTY-SERVICE-KEY\u003e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = mongodbatlas.NewThirdPartyIntegration(ctx, \"test_datadog\", \u0026mongodbatlas.ThirdPartyIntegrationArgs{\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tType:      pulumi.String(\"DATADOG\"),\n\t\t\tApiKey:    pulumi.String(\"\u003cAPI-KEY\u003e\"),\n\t\t\tRegion:    pulumi.String(\"\u003cREGION\u003e\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupThirdPartyIntegrationsOutput(ctx, mongodbatlas.GetThirdPartyIntegrationsOutputArgs{\n\t\t\tProjectId: testPagerDuty.ProjectId,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.ThirdPartyIntegration;\nimport com.pulumi.mongodbatlas.ThirdPartyIntegrationArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetThirdPartyIntegrationsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testPagerDuty = new ThirdPartyIntegration(\"testPagerDuty\", ThirdPartyIntegrationArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .type(\"PAGER_DUTY\")\n            .serviceKey(\"\u003cPAGER-DUTY-SERVICE-KEY\u003e\")\n            .build());\n\n        var testDatadog = new ThirdPartyIntegration(\"testDatadog\", ThirdPartyIntegrationArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .type(\"DATADOG\")\n            .apiKey(\"\u003cAPI-KEY\u003e\")\n            .region(\"\u003cREGION\u003e\")\n            .build());\n\n        final var test = MongodbatlasFunctions.getThirdPartyIntegrations(GetThirdPartyIntegrationsArgs.builder()\n            .projectId(testPagerDuty.projectId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testPagerDuty:\n    type: mongodbatlas:ThirdPartyIntegration\n    name: test_pager_duty\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      type: PAGER_DUTY\n      serviceKey: \u003cPAGER-DUTY-SERVICE-KEY\u003e\n  testDatadog:\n    type: mongodbatlas:ThirdPartyIntegration\n    name: test_datadog\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      type: DATADOG\n      apiKey: \u003cAPI-KEY\u003e\n      region: \u003cREGION\u003e\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getThirdPartyIntegrations\n      Arguments:\n        projectId: ${testPagerDuty.projectId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getThirdPartyIntegrations.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "The unique ID for the project to get all Third-Party service integrations\n"
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getThirdPartyIntegrations.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "description": "ID of the Atlas project the Third-Party Service Integration belongs to.\n",
                        "type": "string"
                    },
                    "results": {
                        "description": "A list where each represents a Third-Party service integration.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getThirdPartyIntegrationsResult:getThirdPartyIntegrationsResult"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "projectId",
                    "results",
                    "id"
                ],
                "type": "object"
            }
        },
        "mongodbatlas:index/getX509AuthenticationDatabaseUser:getX509AuthenticationDatabaseUser": {
            "description": "## # Data Source: mongodbatlas.X509AuthenticationDatabaseUser\n\n`mongodbatlas.X509AuthenticationDatabaseUser` describes a X509 Authentication Database User. This represents a X509 Authentication Database User.\n\n\u003e **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.\n\n## Example Usage\n\n### S\n\n### Example Usage: Generate an Atlas-managed X.509 certificate for a MongoDB user\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nresources:\n  user:\n    type: mongodbatlas:DatabaseUser\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      username: myUsername\n      x509Type: MANAGED\n      databaseName: $external\n      roles:\n        - roleName: atlasAdmin\n          databaseName: admin\n      labels:\n        - key: My Key\n          value: My Value\n  testX509AuthenticationDatabaseUser:\n    type: mongodbatlas:X509AuthenticationDatabaseUser\n    name: test\n    properties:\n      projectId: ${user.projectId}\n      username: ${user.username}\n      monthsUntilExpiration: 2\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getX509AuthenticationDatabaseUser\n      Arguments:\n        projectId: ${testX509AuthenticationDatabaseUser.projectId}\n        username: ${testX509AuthenticationDatabaseUser.username}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Example Usage: Save a customer-managed X.509 configuration for an Atlas project\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as mongodbatlas from \"@pulumi/mongodbatlas\";\n\nconst testX509AuthenticationDatabaseUser = new mongodbatlas.X509AuthenticationDatabaseUser(\"test\", {\n    projectId: \"\u003cPROJECT-ID\u003e\",\n    customerX509Cas: `-----BEGIN CERTIFICATE-----\nMIICmTCCAgICCQDZnHzklxsT9TANBgkqhkiG9w0BAQsFADCBkDELMAkGA1UEBhMC\nVVMxDjAMBgNVBAgMBVRleGFzMQ8wDQYDVQQHDAZBdXN0aW4xETAPBgNVBAoMCHRl\nc3QuY29tMQ0wCwYDVQQLDARUZXN0MREwDwYDVQQDDAh0ZXN0LmNvbTErMCkGCSqG\nSIb3DQEJARYcbWVsaXNzYS5wbHVua2V0dEBtb25nb2RiLmNvbTAeFw0yMDAyMDQy\nMDQ2MDFaFw0yMTAyMDMyMDQ2MDFaMIGQMQswCQYDVQQGEwJVUzEOMAwGA1UECAwF\nVGV4YXMxDzANBgNVBAcMBkF1c3RpbjERMA8GA1UECgwIdGVzdC5jb20xDTALBgNV\nBAsMBFRlc3QxETAPBgNVBAMMCHRlc3QuY29tMSswKQYJKoZIhvcNAQkBFhxtZWxp\nc3NhLnBsdW5rZXR0QG1vbmdvZGIuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB\niQKBgQCf1LRqr1zftzdYx2Aj9G76tb0noMPtj6faGLlPji1+m6Rn7RWD9L0ntWAr\ncURxvypa9jZ9MXFzDtLevvd3tHEmfrUT3ukNDX6+Jtc4kWm+Dh2A70Pd+deKZ2/O\nFh8audEKAESGXnTbeJCeQa1XKlIkjqQHBNwES5h1b9vJtFoLJwIDAQABMA0GCSqG\nSIb3DQEBCwUAA4GBADMUncjEPV/MiZUcVNGmktP6BPmEqMXQWUDpdGW2+Tg2JtUA\n7MMILtepBkFzLO+GlpZxeAlXO0wxiNgEmCRONgh4+t2w3e7a8GFijYQ99FHrAC5A\niul59bdl18gVqXia1Yeq/iK7Ohfy/Jwd7Hsm530elwkM/ZEkYDjBlZSXYdyz\n-----END CERTIFICATE-----\"\n`,\n});\nconst test = mongodbatlas.getX509AuthenticationDatabaseUserOutput({\n    projectId: testX509AuthenticationDatabaseUser.projectId,\n});\n```\n```python\nimport pulumi\nimport pulumi_mongodbatlas as mongodbatlas\n\ntest_x509_authentication_database_user = mongodbatlas.X509AuthenticationDatabaseUser(\"test\",\n    project_id=\"\u003cPROJECT-ID\u003e\",\n    customer_x509_cas=\"\"\"-----BEGIN CERTIFICATE-----\nMIICmTCCAgICCQDZnHzklxsT9TANBgkqhkiG9w0BAQsFADCBkDELMAkGA1UEBhMC\nVVMxDjAMBgNVBAgMBVRleGFzMQ8wDQYDVQQHDAZBdXN0aW4xETAPBgNVBAoMCHRl\nc3QuY29tMQ0wCwYDVQQLDARUZXN0MREwDwYDVQQDDAh0ZXN0LmNvbTErMCkGCSqG\nSIb3DQEJARYcbWVsaXNzYS5wbHVua2V0dEBtb25nb2RiLmNvbTAeFw0yMDAyMDQy\nMDQ2MDFaFw0yMTAyMDMyMDQ2MDFaMIGQMQswCQYDVQQGEwJVUzEOMAwGA1UECAwF\nVGV4YXMxDzANBgNVBAcMBkF1c3RpbjERMA8GA1UECgwIdGVzdC5jb20xDTALBgNV\nBAsMBFRlc3QxETAPBgNVBAMMCHRlc3QuY29tMSswKQYJKoZIhvcNAQkBFhxtZWxp\nc3NhLnBsdW5rZXR0QG1vbmdvZGIuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB\niQKBgQCf1LRqr1zftzdYx2Aj9G76tb0noMPtj6faGLlPji1+m6Rn7RWD9L0ntWAr\ncURxvypa9jZ9MXFzDtLevvd3tHEmfrUT3ukNDX6+Jtc4kWm+Dh2A70Pd+deKZ2/O\nFh8audEKAESGXnTbeJCeQa1XKlIkjqQHBNwES5h1b9vJtFoLJwIDAQABMA0GCSqG\nSIb3DQEBCwUAA4GBADMUncjEPV/MiZUcVNGmktP6BPmEqMXQWUDpdGW2+Tg2JtUA\n7MMILtepBkFzLO+GlpZxeAlXO0wxiNgEmCRONgh4+t2w3e7a8GFijYQ99FHrAC5A\niul59bdl18gVqXia1Yeq/iK7Ohfy/Jwd7Hsm530elwkM/ZEkYDjBlZSXYdyz\n-----END CERTIFICATE-----\"\n\"\"\")\ntest = mongodbatlas.get_x509_authentication_database_user_output(project_id=test_x509_authentication_database_user.project_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Mongodbatlas = Pulumi.Mongodbatlas;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testX509AuthenticationDatabaseUser = new Mongodbatlas.X509AuthenticationDatabaseUser(\"test\", new()\n    {\n        ProjectId = \"\u003cPROJECT-ID\u003e\",\n        CustomerX509Cas = @\"-----BEGIN CERTIFICATE-----\nMIICmTCCAgICCQDZnHzklxsT9TANBgkqhkiG9w0BAQsFADCBkDELMAkGA1UEBhMC\nVVMxDjAMBgNVBAgMBVRleGFzMQ8wDQYDVQQHDAZBdXN0aW4xETAPBgNVBAoMCHRl\nc3QuY29tMQ0wCwYDVQQLDARUZXN0MREwDwYDVQQDDAh0ZXN0LmNvbTErMCkGCSqG\nSIb3DQEJARYcbWVsaXNzYS5wbHVua2V0dEBtb25nb2RiLmNvbTAeFw0yMDAyMDQy\nMDQ2MDFaFw0yMTAyMDMyMDQ2MDFaMIGQMQswCQYDVQQGEwJVUzEOMAwGA1UECAwF\nVGV4YXMxDzANBgNVBAcMBkF1c3RpbjERMA8GA1UECgwIdGVzdC5jb20xDTALBgNV\nBAsMBFRlc3QxETAPBgNVBAMMCHRlc3QuY29tMSswKQYJKoZIhvcNAQkBFhxtZWxp\nc3NhLnBsdW5rZXR0QG1vbmdvZGIuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB\niQKBgQCf1LRqr1zftzdYx2Aj9G76tb0noMPtj6faGLlPji1+m6Rn7RWD9L0ntWAr\ncURxvypa9jZ9MXFzDtLevvd3tHEmfrUT3ukNDX6+Jtc4kWm+Dh2A70Pd+deKZ2/O\nFh8audEKAESGXnTbeJCeQa1XKlIkjqQHBNwES5h1b9vJtFoLJwIDAQABMA0GCSqG\nSIb3DQEBCwUAA4GBADMUncjEPV/MiZUcVNGmktP6BPmEqMXQWUDpdGW2+Tg2JtUA\n7MMILtepBkFzLO+GlpZxeAlXO0wxiNgEmCRONgh4+t2w3e7a8GFijYQ99FHrAC5A\niul59bdl18gVqXia1Yeq/iK7Ohfy/Jwd7Hsm530elwkM/ZEkYDjBlZSXYdyz\n-----END CERTIFICATE-----\"\"\n\",\n    });\n\n    var test = Mongodbatlas.GetX509AuthenticationDatabaseUser.Invoke(new()\n    {\n        ProjectId = testX509AuthenticationDatabaseUser.ProjectId,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-mongodbatlas/sdk/v3/go/mongodbatlas\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestX509AuthenticationDatabaseUser, err := mongodbatlas.NewX509AuthenticationDatabaseUser(ctx, \"test\", \u0026mongodbatlas.X509AuthenticationDatabaseUserArgs{\n\t\t\tProjectId: pulumi.String(\"\u003cPROJECT-ID\u003e\"),\n\t\t\tCustomerX509Cas: pulumi.String(`-----BEGIN CERTIFICATE-----\nMIICmTCCAgICCQDZnHzklxsT9TANBgkqhkiG9w0BAQsFADCBkDELMAkGA1UEBhMC\nVVMxDjAMBgNVBAgMBVRleGFzMQ8wDQYDVQQHDAZBdXN0aW4xETAPBgNVBAoMCHRl\nc3QuY29tMQ0wCwYDVQQLDARUZXN0MREwDwYDVQQDDAh0ZXN0LmNvbTErMCkGCSqG\nSIb3DQEJARYcbWVsaXNzYS5wbHVua2V0dEBtb25nb2RiLmNvbTAeFw0yMDAyMDQy\nMDQ2MDFaFw0yMTAyMDMyMDQ2MDFaMIGQMQswCQYDVQQGEwJVUzEOMAwGA1UECAwF\nVGV4YXMxDzANBgNVBAcMBkF1c3RpbjERMA8GA1UECgwIdGVzdC5jb20xDTALBgNV\nBAsMBFRlc3QxETAPBgNVBAMMCHRlc3QuY29tMSswKQYJKoZIhvcNAQkBFhxtZWxp\nc3NhLnBsdW5rZXR0QG1vbmdvZGIuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB\niQKBgQCf1LRqr1zftzdYx2Aj9G76tb0noMPtj6faGLlPji1+m6Rn7RWD9L0ntWAr\ncURxvypa9jZ9MXFzDtLevvd3tHEmfrUT3ukNDX6+Jtc4kWm+Dh2A70Pd+deKZ2/O\nFh8audEKAESGXnTbeJCeQa1XKlIkjqQHBNwES5h1b9vJtFoLJwIDAQABMA0GCSqG\nSIb3DQEBCwUAA4GBADMUncjEPV/MiZUcVNGmktP6BPmEqMXQWUDpdGW2+Tg2JtUA\n7MMILtepBkFzLO+GlpZxeAlXO0wxiNgEmCRONgh4+t2w3e7a8GFijYQ99FHrAC5A\niul59bdl18gVqXia1Yeq/iK7Ohfy/Jwd7Hsm530elwkM/ZEkYDjBlZSXYdyz\n-----END CERTIFICATE-----\"\n`),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_ = mongodbatlas.LookupX509AuthenticationDatabaseUserOutput(ctx, mongodbatlas.GetX509AuthenticationDatabaseUserOutputArgs{\n\t\t\tProjectId: testX509AuthenticationDatabaseUser.ProjectId,\n\t\t}, nil)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.mongodbatlas.X509AuthenticationDatabaseUser;\nimport com.pulumi.mongodbatlas.X509AuthenticationDatabaseUserArgs;\nimport com.pulumi.mongodbatlas.MongodbatlasFunctions;\nimport com.pulumi.mongodbatlas.inputs.GetX509AuthenticationDatabaseUserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testX509AuthenticationDatabaseUser = new X509AuthenticationDatabaseUser(\"testX509AuthenticationDatabaseUser\", X509AuthenticationDatabaseUserArgs.builder()\n            .projectId(\"\u003cPROJECT-ID\u003e\")\n            .customerX509Cas(\"\"\"\n-----BEGIN CERTIFICATE-----\nMIICmTCCAgICCQDZnHzklxsT9TANBgkqhkiG9w0BAQsFADCBkDELMAkGA1UEBhMC\nVVMxDjAMBgNVBAgMBVRleGFzMQ8wDQYDVQQHDAZBdXN0aW4xETAPBgNVBAoMCHRl\nc3QuY29tMQ0wCwYDVQQLDARUZXN0MREwDwYDVQQDDAh0ZXN0LmNvbTErMCkGCSqG\nSIb3DQEJARYcbWVsaXNzYS5wbHVua2V0dEBtb25nb2RiLmNvbTAeFw0yMDAyMDQy\nMDQ2MDFaFw0yMTAyMDMyMDQ2MDFaMIGQMQswCQYDVQQGEwJVUzEOMAwGA1UECAwF\nVGV4YXMxDzANBgNVBAcMBkF1c3RpbjERMA8GA1UECgwIdGVzdC5jb20xDTALBgNV\nBAsMBFRlc3QxETAPBgNVBAMMCHRlc3QuY29tMSswKQYJKoZIhvcNAQkBFhxtZWxp\nc3NhLnBsdW5rZXR0QG1vbmdvZGIuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB\niQKBgQCf1LRqr1zftzdYx2Aj9G76tb0noMPtj6faGLlPji1+m6Rn7RWD9L0ntWAr\ncURxvypa9jZ9MXFzDtLevvd3tHEmfrUT3ukNDX6+Jtc4kWm+Dh2A70Pd+deKZ2/O\nFh8audEKAESGXnTbeJCeQa1XKlIkjqQHBNwES5h1b9vJtFoLJwIDAQABMA0GCSqG\nSIb3DQEBCwUAA4GBADMUncjEPV/MiZUcVNGmktP6BPmEqMXQWUDpdGW2+Tg2JtUA\n7MMILtepBkFzLO+GlpZxeAlXO0wxiNgEmCRONgh4+t2w3e7a8GFijYQ99FHrAC5A\niul59bdl18gVqXia1Yeq/iK7Ohfy/Jwd7Hsm530elwkM/ZEkYDjBlZSXYdyz\n-----END CERTIFICATE-----\"\n            \"\"\")\n            .build());\n\n        final var test = MongodbatlasFunctions.getX509AuthenticationDatabaseUser(GetX509AuthenticationDatabaseUserArgs.builder()\n            .projectId(testX509AuthenticationDatabaseUser.projectId())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testX509AuthenticationDatabaseUser:\n    type: mongodbatlas:X509AuthenticationDatabaseUser\n    name: test\n    properties:\n      projectId: \u003cPROJECT-ID\u003e\n      customerX509Cas: |\n        -----BEGIN CERTIFICATE-----\n        MIICmTCCAgICCQDZnHzklxsT9TANBgkqhkiG9w0BAQsFADCBkDELMAkGA1UEBhMC\n        VVMxDjAMBgNVBAgMBVRleGFzMQ8wDQYDVQQHDAZBdXN0aW4xETAPBgNVBAoMCHRl\n        c3QuY29tMQ0wCwYDVQQLDARUZXN0MREwDwYDVQQDDAh0ZXN0LmNvbTErMCkGCSqG\n        SIb3DQEJARYcbWVsaXNzYS5wbHVua2V0dEBtb25nb2RiLmNvbTAeFw0yMDAyMDQy\n        MDQ2MDFaFw0yMTAyMDMyMDQ2MDFaMIGQMQswCQYDVQQGEwJVUzEOMAwGA1UECAwF\n        VGV4YXMxDzANBgNVBAcMBkF1c3RpbjERMA8GA1UECgwIdGVzdC5jb20xDTALBgNV\n        BAsMBFRlc3QxETAPBgNVBAMMCHRlc3QuY29tMSswKQYJKoZIhvcNAQkBFhxtZWxp\n        c3NhLnBsdW5rZXR0QG1vbmdvZGIuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCB\n        iQKBgQCf1LRqr1zftzdYx2Aj9G76tb0noMPtj6faGLlPji1+m6Rn7RWD9L0ntWAr\n        cURxvypa9jZ9MXFzDtLevvd3tHEmfrUT3ukNDX6+Jtc4kWm+Dh2A70Pd+deKZ2/O\n        Fh8audEKAESGXnTbeJCeQa1XKlIkjqQHBNwES5h1b9vJtFoLJwIDAQABMA0GCSqG\n        SIb3DQEBCwUAA4GBADMUncjEPV/MiZUcVNGmktP6BPmEqMXQWUDpdGW2+Tg2JtUA\n        7MMILtepBkFzLO+GlpZxeAlXO0wxiNgEmCRONgh4+t2w3e7a8GFijYQ99FHrAC5A\n        iul59bdl18gVqXia1Yeq/iK7Ohfy/Jwd7Hsm530elwkM/ZEkYDjBlZSXYdyz\n        -----END CERTIFICATE-----\"\nvariables:\n  test:\n    fn::invoke:\n      Function: mongodbatlas:getX509AuthenticationDatabaseUser\n      Arguments:\n        projectId: ${testX509AuthenticationDatabaseUser.projectId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getX509AuthenticationDatabaseUser.\n",
                "properties": {
                    "projectId": {
                        "type": "string",
                        "description": "Identifier for the Atlas project associated with the X.509 configuration.\n",
                        "willReplaceOnChanges": true
                    },
                    "username": {
                        "type": "string",
                        "description": "Username of the database user to create a certificate for.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "projectId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getX509AuthenticationDatabaseUser.\n",
                "properties": {
                    "certificates": {
                        "description": "Array of objects where each details one unexpired database user certificate.\n",
                        "items": {
                            "$ref": "#/types/mongodbatlas:index/getX509AuthenticationDatabaseUserCertificate:getX509AuthenticationDatabaseUserCertificate"
                        },
                        "type": "array"
                    },
                    "customerX509Cas": {
                        "secret": true,
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.\n",
                        "type": "string"
                    },
                    "projectId": {
                        "type": "string"
                    },
                    "username": {
                        "type": "string"
                    }
                },
                "required": [
                    "certificates",
                    "customerX509Cas",
                    "projectId",
                    "id"
                ],
                "type": "object"
            }
        }
    }
}