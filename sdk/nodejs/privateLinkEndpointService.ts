// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * `mongodbatlas.PrivateLinkEndpointService` provides a Private Endpoint Interface Link resource. This represents a Private Endpoint Interface Link, which adds one [Interface Endpoint](https://www.mongodb.com/docs/atlas/security-private-endpoint/#private-endpoint-concepts) to a private endpoint connection in an Atlas project.
 *
 * > **IMPORTANT:** This resource links your cloud provider's Private Endpoint to the MongoDB Atlas Private Endpoint Service. It does not create the service itself (this is done by `mongodbatlas.PrivateLinkEndpoint`). You first create the service in Atlas with `mongodbatlas.PrivateLinkEndpoint`, then the endpoint is created in your cloud provider, and you link them together with the `mongodbatlas.PrivateLinkEndpointService` resource.
 *
 * The private link Terraform module makes use of this resource and simplifies its use.
 *
 * > **NOTE:** You must have Organization Owner or Project Owner role. Create and delete operations wait for all clusters on the project to IDLE to ensure the latest connection strings can be retrieved (default timeout: 2hrs).
 *
 * > **IMPORTANT:** For GCP, MongoDB encourages customers to use the port-mapped architecture by setting `portMappingEnabled = true` on the `mongodbatlas.PrivateLinkEndpoint` resource. This architecture uses a single set of resources to support up to 150 nodes. The legacy architecture requires dedicated resources for each Atlas node, which can lead to IP address exhaustion. For migration guidance, see the GCP Private Service Connect to Port-Mapped Architecture.
 *
 * ## Example with AWS
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * import * as mongodbatlas from "@pulumi/mongodbatlas";
 *
 * const _this = new mongodbatlas.PrivateLinkEndpoint("this", {
 *     projectId: "<PROJECT_ID>",
 *     providerName: "AWS",
 *     region: "US_EAST_1",
 * });
 * const ptfeService = new aws.index.VpcEndpoint("ptfe_service", {
 *     vpcId: "vpc-7fc0a543",
 *     serviceName: _this.endpointServiceName,
 *     vpcEndpointType: "Interface",
 *     subnetIds: ["subnet-de0406d2"],
 *     securityGroupIds: ["sg-3f238186"],
 * });
 * const thisPrivateLinkEndpointService = new mongodbatlas.PrivateLinkEndpointService("this", {
 *     projectId: _this.projectId,
 *     privateLinkId: _this.privateLinkId,
 *     endpointServiceId: ptfeService.id,
 *     providerName: "AWS",
 * });
 * ```
 *
 * ## Example with Azure
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as azurerm from "@pulumi/azurerm";
 * import * as mongodbatlas from "@pulumi/mongodbatlas";
 *
 * const _this = new mongodbatlas.PrivateLinkEndpoint("this", {
 *     projectId: projectId,
 *     providerName: "AZURE",
 *     region: "eastus2",
 * });
 * const thisPrivateEndpoint = new azurerm.index.PrivateEndpoint("this", {
 *     name: "endpoint-this",
 *     location: thisAzurermResourceGroup.location,
 *     resourceGroupName: resourceGroupName,
 *     subnetId: thisAzurermSubnet.id,
 *     privateServiceConnection: [{
 *         name: _this.privateLinkServiceName,
 *         privateConnectionResourceId: _this.privateLinkServiceResourceId,
 *         isManualConnection: true,
 *         requestMessage: "Azure Private Link this",
 *     }],
 * });
 * const thisPrivateLinkEndpointService = new mongodbatlas.PrivateLinkEndpointService("this", {
 *     projectId: _this.projectId,
 *     privateLinkId: _this.privateLinkId,
 *     endpointServiceId: thisPrivateEndpoint.id,
 *     privateEndpointIpAddress: thisPrivateEndpoint.privateServiceConnection[0].privateIpAddress,
 *     providerName: "AZURE",
 * });
 * ```
 *
 * ## Example with GCP (Legacy Architecture)
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as google from "@pulumi/google";
 * import * as mongodbatlas from "@pulumi/mongodbatlas";
 *
 * const _this = new mongodbatlas.PrivateLinkEndpoint("this", {
 *     projectId: projectId,
 *     providerName: "GCP",
 *     region: gcpRegion,
 * });
 * // Create a Google Network
 * const _default = new google.index.ComputeNetwork("default", {
 *     project: gcpProjectId,
 *     name: "my-network",
 *     autoCreateSubnetworks: false,
 * });
 * // Create a Google Sub Network
 * const defaultComputeSubnetwork = new google.index.ComputeSubnetwork("default", {
 *     project: _default.project,
 *     name: "my-subnet",
 *     ipCidrRange: "10.0.0.0/16",
 *     region: gcpRegion,
 *     network: _default.id,
 * });
 * // Create Google 50 Addresses (required for GCP legacy private endpoint architecture)
 * const defaultComputeAddress: google.index.ComputeAddress[] = [];
 * for (const range = {value: 0}; range.value < 50; range.value++) {
 *     defaultComputeAddress.push(new google.index.ComputeAddress(`default-${range.value}`, {
 *         project: defaultComputeSubnetwork.project,
 *         name: `tf-this${range.value}`,
 *         subnetwork: defaultComputeSubnetwork.id,
 *         addressType: "INTERNAL",
 *         address: `10.0.42.${range.value}`,
 *         region: gcpRegion,
 *     }, {
 *     dependsOn: [_this],
 * }));
 * }
 * // Create 50 Forwarding rules (required for GCP legacy private endpoint architecture)
 * const defaultComputeForwardingRule: google.index.ComputeForwardingRule[] = [];
 * for (const range = {value: 0}; range.value < 50; range.value++) {
 *     defaultComputeForwardingRule.push(new google.index.ComputeForwardingRule(`default-${range.value}`, {
 *         target: _this.serviceAttachmentNames[range.value],
 *         project: defaultComputeAddress[range.value].project,
 *         region: defaultComputeAddress[range.value].region,
 *         name: defaultComputeAddress[range.value].name,
 *         ipAddress: defaultComputeAddress[range.value].id,
 *         network: _default.id,
 *         loadBalancingScheme: "",
 *     }));
 * }
 * const thisPrivateLinkEndpointService = new mongodbatlas.PrivateLinkEndpointService("this", {
 *     endpoints: defaultComputeAddress.map((v, k) => ({key: k, value: v})).map(entry => ({
 *         ipAddress: entry.value.address,
 *         endpointName: defaultComputeForwardingRule[entry.key].name,
 *     })),
 *     projectId: _this.projectId,
 *     privateLinkId: _this.privateLinkId,
 *     providerName: "GCP",
 *     endpointServiceId: _default.name,
 *     gcpProjectId: gcpProjectId,
 * }, {
 *     dependsOn: [defaultComputeForwardingRule],
 * });
 * ```
 *
 * ## Example with GCP (Port-Mapped Architecture)
 *
 * The port-mapped architecture uses port mapping to reduce resource provisioning. In the GCP legacy private endpoint architecture, service attachments were mapped 1:1 with Atlas nodes (one service attachment per node). In the port-mapped architecture, regardless of cloud provider, one service attachment can be mapped to up to 150 nodes via ports designated per node, enabling direct targeting of specific nodes using only one customer IP address. Enable it by setting `portMappingEnabled = true` on the `mongodbatlas.PrivateLinkEndpoint` resource.
 *
 * **Important:** For the port-mapped architecture, use `endpointServiceId` (the forwarding rule name) and `privateEndpointIpAddress` (the IP address). The `endpoints` list is no longer used for the port-mapped architecture.
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as google from "@pulumi/google";
 * import * as mongodbatlas from "@pulumi/mongodbatlas";
 *
 * const _this = new mongodbatlas.PrivateLinkEndpoint("this", {
 *     projectId: projectId,
 *     providerName: "GCP",
 *     region: gcpRegion,
 *     portMappingEnabled: true,
 * });
 * // Create a Google Network
 * const _default = new google.index.ComputeNetwork("default", {
 *     project: gcpProjectId,
 *     name: "my-network",
 *     autoCreateSubnetworks: false,
 * });
 * // Create a Google Sub Network
 * const defaultComputeSubnetwork = new google.index.ComputeSubnetwork("default", {
 *     project: _default.project,
 *     name: "my-subnet",
 *     ipCidrRange: "10.0.0.0/16",
 *     region: gcpRegion,
 *     network: _default.id,
 * });
 * // Create Google Address (1 address for port-mapped architecture)
 * const defaultComputeAddress = new google.index.ComputeAddress("default", {
 *     project: defaultComputeSubnetwork.project,
 *     name: "tf-this-psc-endpoint",
 *     subnetwork: defaultComputeSubnetwork.id,
 *     addressType: "INTERNAL",
 *     address: "10.0.42.1",
 *     region: defaultComputeSubnetwork.region,
 * }, {
 *     dependsOn: [_this],
 * });
 * // Create Forwarding Rule (1 rule for port-mapped architecture)
 * const defaultComputeForwardingRule = new google.index.ComputeForwardingRule("default", {
 *     target: _this.serviceAttachmentNames[0],
 *     project: defaultComputeAddress.project,
 *     region: defaultComputeAddress.region,
 *     name: defaultComputeAddress.name,
 *     ipAddress: defaultComputeAddress.id,
 *     network: _default.id,
 *     loadBalancingScheme: "",
 * });
 * const thisPrivateLinkEndpointService = new mongodbatlas.PrivateLinkEndpointService("this", {
 *     projectId: _this.projectId,
 *     privateLinkId: _this.privateLinkId,
 *     providerName: "GCP",
 *     endpointServiceId: defaultComputeForwardingRule.name,
 *     privateEndpointIpAddress: defaultComputeAddress.address,
 *     gcpProjectId: gcpProjectId,
 * }, {
 *     dependsOn: [defaultComputeForwardingRule],
 * });
 * ```
 *
 * ### Further Examples
 * - AWS PrivateLink Endpoint and Service
 * - Azure Private Link Endpoint and Service
 * - GCP Private Service Connect Endpoint and Service (Port-Mapped Architecture)
 *
 * ## Import
 *
 * Private Endpoint Link Connection can be imported using project ID, private link ID, endpoint service ID, and provider name, in the format `{project_id}--{private_link_id}--{endpoint_service_id}--{provider_name}`, e.g.
 *
 * ```sh
 * $ pulumi import mongodbatlas:index/privateLinkEndpointService:PrivateLinkEndpointService this 1112222b3bf99403840e8934--3242342343112--vpce-4242342343--AWS
 * ```
 *
 * For more information, see:
 * - [MongoDB API Private Endpoint Link Connection](https://www.mongodb.com/docs/api/doc/atlas-admin-api-v2/operation/operation-creategroupprivateendpointendpointserviceendpoint) for detailed arguments and attributes.
 * - [Set Up a Private Endpoint](https://www.mongodb.com/docs/atlas/security-private-endpoint/) for general guidance on private endpoints in MongoDB Atlas.
 */
export class PrivateLinkEndpointService extends pulumi.CustomResource {
    /**
     * Get an existing PrivateLinkEndpointService resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: PrivateLinkEndpointServiceState, opts?: pulumi.CustomResourceOptions): PrivateLinkEndpointService {
        return new PrivateLinkEndpointService(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'mongodbatlas:index/privateLinkEndpointService:PrivateLinkEndpointService';

    /**
     * Returns true if the given object is an instance of PrivateLinkEndpointService.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is PrivateLinkEndpointService {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === PrivateLinkEndpointService.__pulumiType;
    }

    /**
     * Status of the interface endpoint for AWS.
     * Returns one of the following values:
     * * `NONE` - Atlas created the network load balancer and VPC endpoint service, but AWS hasn't yet created the VPC endpoint.
     * * `PENDING_ACCEPTANCE` - AWS has received the connection request from your VPC endpoint to the Atlas VPC endpoint service.
     * * `PENDING` - AWS is establishing the connection between your VPC endpoint and the Atlas VPC endpoint service.
     * * `AVAILABLE` - Atlas VPC resources are connected to the VPC endpoint in your VPC. You can connect to Atlas clusters in this region using AWS PrivateLink.
     * * `REJECTED` - AWS failed to establish a connection between Atlas VPC resources to the VPC endpoint in your VPC.
     * * `DELETING` - Atlas is removing the interface endpoint from the private endpoint connection.
     */
    declare public /*out*/ readonly awsConnectionStatus: pulumi.Output<string>;
    /**
     * Status of the interface endpoint for AZURE.
     * Returns one of the following values:
     * * `INITIATING` - Atlas has not yet accepted the connection to your private endpoint.
     * * `AVAILABLE` - Atlas approved the connection to your private endpoint.
     * * `FAILED` - Atlas failed to accept the connection your private endpoint.
     * * `DELETING` - Atlas is removing the connection to your private endpoint from the Private Link service.
     */
    declare public /*out*/ readonly azureStatus: pulumi.Output<string>;
    /**
     * Indicates whether to delete the resource being created if a timeout is reached when waiting for completion. When set to `true` and timeout occurs, it triggers the deletion and returns immediately without waiting for deletion to complete. When set to `false`, the timeout will not trigger resource deletion. If you suspect a transient error when the value is `true`, wait before retrying to allow resource deletion to finish. Default is `true`.
     */
    declare public readonly deleteOnCreateTimeout: pulumi.Output<boolean | undefined>;
    /**
     * Indicates if Atlas received a request to remove the interface endpoint from the private endpoint connection.
     */
    declare public /*out*/ readonly deleteRequested: pulumi.Output<boolean>;
    declare public /*out*/ readonly endpointGroupName: pulumi.Output<string>;
    /**
     * Unique identifier of the interface endpoint you created in your VPC. For `AWS` and `AZURE`, this is the interface endpoint identifier. For `GCP` port-mapped architecture, this is the forwarding rule name. For `GCP` legacy private endpoint architecture, this is the endpoint group name.
     */
    declare public readonly endpointServiceId: pulumi.Output<string>;
    /**
     * Collection of individual private endpoints that comprise your endpoint group. Only for GCP legacy private endpoint architecture. **Note:** For the port-mapped architecture, this field is no longer used - use `endpointServiceId` and `privateEndpointIpAddress` instead.
     */
    declare public readonly endpoints: pulumi.Output<outputs.PrivateLinkEndpointServiceEndpoint[]>;
    /**
     * Error message pertaining to the interface endpoint. Returns null if there are no errors.
     */
    declare public /*out*/ readonly errorMessage: pulumi.Output<string>;
    /**
     * Status of the individual endpoint. Only populated for port-mapped architecture. Returns one of the following values: `INITIATING`, `AVAILABLE`, `FAILED`, `DELETING`.
     */
    declare public /*out*/ readonly gcpEndpointStatus: pulumi.Output<string>;
    /**
     * Unique identifier of the GCP project in which you created your endpoints. **Required for `GCP`** (both legacy and port-mapped architectures). Only for `GCP`.
     */
    declare public readonly gcpProjectId: pulumi.Output<string | undefined>;
    /**
     * Status of the interface endpoint.
     * Returns one of the following values:
     * * `INITIATING` - Atlas has not yet accepted the connection to your private endpoint.
     * * `AVAILABLE` - Atlas approved the connection to your private endpoint.
     * * `FAILED` - Atlas failed to accept the connection your private endpoint.
     * * `DELETING` - Atlas is removing the connection to your private endpoint from the Private Link service.
     */
    declare public /*out*/ readonly gcpStatus: pulumi.Output<string>;
    /**
     * Unique identifier of the interface endpoint.
     */
    declare public /*out*/ readonly interfaceEndpointId: pulumi.Output<string>;
    /**
     * Flag that indicates whether the underlying `privatelinkEndpoint` resource uses GCP port-mapping. This is a read-only attribute that reflects the architecture type. When `true`, the endpoint service uses the port-mapped architecture. When `false`, it uses the GCP legacy private endpoint architecture. Only applicable for GCP provider.
     */
    declare public /*out*/ readonly portMappingEnabled: pulumi.Output<boolean>;
    /**
     * Name of the connection for this private endpoint that Atlas generates.
     */
    declare public /*out*/ readonly privateEndpointConnectionName: pulumi.Output<string>;
    /**
     * Private IP address of the private endpoint network interface. **Required for `AZURE and GCP Port-Mapped`.** For port-mapped architecture, this is required and is the IP address of the forwarding rule. For GCP legacy private endpoint architecture, this is not used.
     */
    declare public readonly privateEndpointIpAddress: pulumi.Output<string>;
    /**
     * Unique identifier of the private endpoint.
     */
    declare public /*out*/ readonly privateEndpointResourceId: pulumi.Output<string>;
    /**
     * Unique identifier of the `AWS`, `AZURE` or `GCP` PrivateLink connection which is created by `mongodbatlas.PrivateLinkEndpoint` resource.
     */
    declare public readonly privateLinkId: pulumi.Output<string>;
    /**
     * Unique identifier for the project, also known as `groupId` in the official documentation.
     */
    declare public readonly projectId: pulumi.Output<string>;
    /**
     * Cloud provider for which you want to create a private endpoint. Atlas accepts `AWS`, `AZURE` or `GCP`.
     */
    declare public readonly providerName: pulumi.Output<string>;

    /**
     * Create a PrivateLinkEndpointService resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: PrivateLinkEndpointServiceArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: PrivateLinkEndpointServiceArgs | PrivateLinkEndpointServiceState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as PrivateLinkEndpointServiceState | undefined;
            resourceInputs["awsConnectionStatus"] = state?.awsConnectionStatus;
            resourceInputs["azureStatus"] = state?.azureStatus;
            resourceInputs["deleteOnCreateTimeout"] = state?.deleteOnCreateTimeout;
            resourceInputs["deleteRequested"] = state?.deleteRequested;
            resourceInputs["endpointGroupName"] = state?.endpointGroupName;
            resourceInputs["endpointServiceId"] = state?.endpointServiceId;
            resourceInputs["endpoints"] = state?.endpoints;
            resourceInputs["errorMessage"] = state?.errorMessage;
            resourceInputs["gcpEndpointStatus"] = state?.gcpEndpointStatus;
            resourceInputs["gcpProjectId"] = state?.gcpProjectId;
            resourceInputs["gcpStatus"] = state?.gcpStatus;
            resourceInputs["interfaceEndpointId"] = state?.interfaceEndpointId;
            resourceInputs["portMappingEnabled"] = state?.portMappingEnabled;
            resourceInputs["privateEndpointConnectionName"] = state?.privateEndpointConnectionName;
            resourceInputs["privateEndpointIpAddress"] = state?.privateEndpointIpAddress;
            resourceInputs["privateEndpointResourceId"] = state?.privateEndpointResourceId;
            resourceInputs["privateLinkId"] = state?.privateLinkId;
            resourceInputs["projectId"] = state?.projectId;
            resourceInputs["providerName"] = state?.providerName;
        } else {
            const args = argsOrState as PrivateLinkEndpointServiceArgs | undefined;
            if (args?.endpointServiceId === undefined && !opts.urn) {
                throw new Error("Missing required property 'endpointServiceId'");
            }
            if (args?.privateLinkId === undefined && !opts.urn) {
                throw new Error("Missing required property 'privateLinkId'");
            }
            if (args?.projectId === undefined && !opts.urn) {
                throw new Error("Missing required property 'projectId'");
            }
            if (args?.providerName === undefined && !opts.urn) {
                throw new Error("Missing required property 'providerName'");
            }
            resourceInputs["deleteOnCreateTimeout"] = args?.deleteOnCreateTimeout;
            resourceInputs["endpointServiceId"] = args?.endpointServiceId;
            resourceInputs["endpoints"] = args?.endpoints;
            resourceInputs["gcpProjectId"] = args?.gcpProjectId;
            resourceInputs["privateEndpointIpAddress"] = args?.privateEndpointIpAddress;
            resourceInputs["privateLinkId"] = args?.privateLinkId;
            resourceInputs["projectId"] = args?.projectId;
            resourceInputs["providerName"] = args?.providerName;
            resourceInputs["awsConnectionStatus"] = undefined /*out*/;
            resourceInputs["azureStatus"] = undefined /*out*/;
            resourceInputs["deleteRequested"] = undefined /*out*/;
            resourceInputs["endpointGroupName"] = undefined /*out*/;
            resourceInputs["errorMessage"] = undefined /*out*/;
            resourceInputs["gcpEndpointStatus"] = undefined /*out*/;
            resourceInputs["gcpStatus"] = undefined /*out*/;
            resourceInputs["interfaceEndpointId"] = undefined /*out*/;
            resourceInputs["portMappingEnabled"] = undefined /*out*/;
            resourceInputs["privateEndpointConnectionName"] = undefined /*out*/;
            resourceInputs["privateEndpointResourceId"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(PrivateLinkEndpointService.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering PrivateLinkEndpointService resources.
 */
export interface PrivateLinkEndpointServiceState {
    /**
     * Status of the interface endpoint for AWS.
     * Returns one of the following values:
     * * `NONE` - Atlas created the network load balancer and VPC endpoint service, but AWS hasn't yet created the VPC endpoint.
     * * `PENDING_ACCEPTANCE` - AWS has received the connection request from your VPC endpoint to the Atlas VPC endpoint service.
     * * `PENDING` - AWS is establishing the connection between your VPC endpoint and the Atlas VPC endpoint service.
     * * `AVAILABLE` - Atlas VPC resources are connected to the VPC endpoint in your VPC. You can connect to Atlas clusters in this region using AWS PrivateLink.
     * * `REJECTED` - AWS failed to establish a connection between Atlas VPC resources to the VPC endpoint in your VPC.
     * * `DELETING` - Atlas is removing the interface endpoint from the private endpoint connection.
     */
    awsConnectionStatus?: pulumi.Input<string>;
    /**
     * Status of the interface endpoint for AZURE.
     * Returns one of the following values:
     * * `INITIATING` - Atlas has not yet accepted the connection to your private endpoint.
     * * `AVAILABLE` - Atlas approved the connection to your private endpoint.
     * * `FAILED` - Atlas failed to accept the connection your private endpoint.
     * * `DELETING` - Atlas is removing the connection to your private endpoint from the Private Link service.
     */
    azureStatus?: pulumi.Input<string>;
    /**
     * Indicates whether to delete the resource being created if a timeout is reached when waiting for completion. When set to `true` and timeout occurs, it triggers the deletion and returns immediately without waiting for deletion to complete. When set to `false`, the timeout will not trigger resource deletion. If you suspect a transient error when the value is `true`, wait before retrying to allow resource deletion to finish. Default is `true`.
     */
    deleteOnCreateTimeout?: pulumi.Input<boolean>;
    /**
     * Indicates if Atlas received a request to remove the interface endpoint from the private endpoint connection.
     */
    deleteRequested?: pulumi.Input<boolean>;
    endpointGroupName?: pulumi.Input<string>;
    /**
     * Unique identifier of the interface endpoint you created in your VPC. For `AWS` and `AZURE`, this is the interface endpoint identifier. For `GCP` port-mapped architecture, this is the forwarding rule name. For `GCP` legacy private endpoint architecture, this is the endpoint group name.
     */
    endpointServiceId?: pulumi.Input<string>;
    /**
     * Collection of individual private endpoints that comprise your endpoint group. Only for GCP legacy private endpoint architecture. **Note:** For the port-mapped architecture, this field is no longer used - use `endpointServiceId` and `privateEndpointIpAddress` instead.
     */
    endpoints?: pulumi.Input<pulumi.Input<inputs.PrivateLinkEndpointServiceEndpoint>[]>;
    /**
     * Error message pertaining to the interface endpoint. Returns null if there are no errors.
     */
    errorMessage?: pulumi.Input<string>;
    /**
     * Status of the individual endpoint. Only populated for port-mapped architecture. Returns one of the following values: `INITIATING`, `AVAILABLE`, `FAILED`, `DELETING`.
     */
    gcpEndpointStatus?: pulumi.Input<string>;
    /**
     * Unique identifier of the GCP project in which you created your endpoints. **Required for `GCP`** (both legacy and port-mapped architectures). Only for `GCP`.
     */
    gcpProjectId?: pulumi.Input<string>;
    /**
     * Status of the interface endpoint.
     * Returns one of the following values:
     * * `INITIATING` - Atlas has not yet accepted the connection to your private endpoint.
     * * `AVAILABLE` - Atlas approved the connection to your private endpoint.
     * * `FAILED` - Atlas failed to accept the connection your private endpoint.
     * * `DELETING` - Atlas is removing the connection to your private endpoint from the Private Link service.
     */
    gcpStatus?: pulumi.Input<string>;
    /**
     * Unique identifier of the interface endpoint.
     */
    interfaceEndpointId?: pulumi.Input<string>;
    /**
     * Flag that indicates whether the underlying `privatelinkEndpoint` resource uses GCP port-mapping. This is a read-only attribute that reflects the architecture type. When `true`, the endpoint service uses the port-mapped architecture. When `false`, it uses the GCP legacy private endpoint architecture. Only applicable for GCP provider.
     */
    portMappingEnabled?: pulumi.Input<boolean>;
    /**
     * Name of the connection for this private endpoint that Atlas generates.
     */
    privateEndpointConnectionName?: pulumi.Input<string>;
    /**
     * Private IP address of the private endpoint network interface. **Required for `AZURE and GCP Port-Mapped`.** For port-mapped architecture, this is required and is the IP address of the forwarding rule. For GCP legacy private endpoint architecture, this is not used.
     */
    privateEndpointIpAddress?: pulumi.Input<string>;
    /**
     * Unique identifier of the private endpoint.
     */
    privateEndpointResourceId?: pulumi.Input<string>;
    /**
     * Unique identifier of the `AWS`, `AZURE` or `GCP` PrivateLink connection which is created by `mongodbatlas.PrivateLinkEndpoint` resource.
     */
    privateLinkId?: pulumi.Input<string>;
    /**
     * Unique identifier for the project, also known as `groupId` in the official documentation.
     */
    projectId?: pulumi.Input<string>;
    /**
     * Cloud provider for which you want to create a private endpoint. Atlas accepts `AWS`, `AZURE` or `GCP`.
     */
    providerName?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a PrivateLinkEndpointService resource.
 */
export interface PrivateLinkEndpointServiceArgs {
    /**
     * Indicates whether to delete the resource being created if a timeout is reached when waiting for completion. When set to `true` and timeout occurs, it triggers the deletion and returns immediately without waiting for deletion to complete. When set to `false`, the timeout will not trigger resource deletion. If you suspect a transient error when the value is `true`, wait before retrying to allow resource deletion to finish. Default is `true`.
     */
    deleteOnCreateTimeout?: pulumi.Input<boolean>;
    /**
     * Unique identifier of the interface endpoint you created in your VPC. For `AWS` and `AZURE`, this is the interface endpoint identifier. For `GCP` port-mapped architecture, this is the forwarding rule name. For `GCP` legacy private endpoint architecture, this is the endpoint group name.
     */
    endpointServiceId: pulumi.Input<string>;
    /**
     * Collection of individual private endpoints that comprise your endpoint group. Only for GCP legacy private endpoint architecture. **Note:** For the port-mapped architecture, this field is no longer used - use `endpointServiceId` and `privateEndpointIpAddress` instead.
     */
    endpoints?: pulumi.Input<pulumi.Input<inputs.PrivateLinkEndpointServiceEndpoint>[]>;
    /**
     * Unique identifier of the GCP project in which you created your endpoints. **Required for `GCP`** (both legacy and port-mapped architectures). Only for `GCP`.
     */
    gcpProjectId?: pulumi.Input<string>;
    /**
     * Private IP address of the private endpoint network interface. **Required for `AZURE and GCP Port-Mapped`.** For port-mapped architecture, this is required and is the IP address of the forwarding rule. For GCP legacy private endpoint architecture, this is not used.
     */
    privateEndpointIpAddress?: pulumi.Input<string>;
    /**
     * Unique identifier of the `AWS`, `AZURE` or `GCP` PrivateLink connection which is created by `mongodbatlas.PrivateLinkEndpoint` resource.
     */
    privateLinkId: pulumi.Input<string>;
    /**
     * Unique identifier for the project, also known as `groupId` in the official documentation.
     */
    projectId: pulumi.Input<string>;
    /**
     * Cloud provider for which you want to create a private endpoint. Atlas accepts `AWS`, `AZURE` or `GCP`.
     */
    providerName: pulumi.Input<string>;
}
