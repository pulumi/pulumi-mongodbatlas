// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * `mongodbatlas.getServiceAccountAccessListEntries` returns all Access List entries for the specified Service Account.
 *
 * > **IMPORTANT:** When you remove an entry from the access list, existing connections from the removed address(es) may remain open for a variable amount of time. How much time passes before Atlas closes the connection depends on several factors, including how the connection was established, the particular behavior of the application or driver using the address, and the connection protocol (e.g., TCP or UDP). This is particularly important to consider when changing an existing IP address or CIDR block as they cannot be updated via the Provider, hence a change will force the destruction and recreation of entries.
 *
 * > **IMPORTANT WARNING:** Managing Service Accounts with Terraform **exposes sensitive organizational secrets** in Terraform's state. We suggest following Terraform's best practices.
 *
 * ## Example Usage
 *
 * ### S
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as mongodbatlas from "@pulumi/mongodbatlas";
 *
 * const thisServiceAccount = new mongodbatlas.ServiceAccount("this", {
 *     orgId: orgId,
 *     name: "example-service-account",
 *     description: "Example Service Account",
 *     roles: ["ORG_READ_ONLY"],
 *     secretExpiresAfterHours: 2160,
 * });
 * // Add IP Access List Entry to Service Account using CIDR Block
 * const cidr = new mongodbatlas.ServiceAccountAccessListEntry("cidr", {
 *     orgId: orgId,
 *     clientId: thisServiceAccount.clientId,
 *     cidrBlock: "1.2.3.4/32",
 * });
 * // Add IP Access List Entry to Service Account using IP Address
 * const ip = new mongodbatlas.ServiceAccountAccessListEntry("ip", {
 *     orgId: orgId,
 *     clientId: thisServiceAccount.clientId,
 *     ipAddress: "2.3.4.5",
 * });
 * // Data source to read a single Access List entry for the Service Account
 * const _this = mongodbatlas.getServiceAccountAccessListEntryOutput({
 *     orgId: cidr.orgId,
 *     clientId: cidr.clientId,
 *     cidrBlock: cidr.cidrBlock,
 * });
 * export const accessListEntryCidrBlock = _this.apply(_this => _this.cidrBlock);
 * // Data source to read all Access List entries for the Service Account
 * const thisGetServiceAccountAccessListEntries = mongodbatlas.getServiceAccountAccessListEntriesOutput({
 *     orgId: thisServiceAccount.orgId,
 *     clientId: thisServiceAccount.clientId,
 * });
 * export const allAccessListEntries = thisGetServiceAccountAccessListEntries.apply(thisGetServiceAccountAccessListEntries => thisGetServiceAccountAccessListEntries.results);
 * ```
 */
export function getServiceAccountAccessListEntries(args: GetServiceAccountAccessListEntriesArgs, opts?: pulumi.InvokeOptions): Promise<GetServiceAccountAccessListEntriesResult> {
    opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts || {});
    return pulumi.runtime.invoke("mongodbatlas:index/getServiceAccountAccessListEntries:getServiceAccountAccessListEntries", {
        "clientId": args.clientId,
        "orgId": args.orgId,
    }, opts);
}

/**
 * A collection of arguments for invoking getServiceAccountAccessListEntries.
 */
export interface GetServiceAccountAccessListEntriesArgs {
    /**
     * The Client ID of the Service Account.
     */
    clientId: string;
    /**
     * Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
     */
    orgId: string;
}

/**
 * A collection of values returned by getServiceAccountAccessListEntries.
 */
export interface GetServiceAccountAccessListEntriesResult {
    /**
     * The Client ID of the Service Account.
     */
    readonly clientId: string;
    /**
     * The provider-assigned unique ID for this managed resource.
     */
    readonly id: string;
    /**
     * Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
     */
    readonly orgId: string;
    /**
     * List of documents that MongoDB Cloud returns for this request.
     */
    readonly results: outputs.GetServiceAccountAccessListEntriesResult[];
}
/**
 * `mongodbatlas.getServiceAccountAccessListEntries` returns all Access List entries for the specified Service Account.
 *
 * > **IMPORTANT:** When you remove an entry from the access list, existing connections from the removed address(es) may remain open for a variable amount of time. How much time passes before Atlas closes the connection depends on several factors, including how the connection was established, the particular behavior of the application or driver using the address, and the connection protocol (e.g., TCP or UDP). This is particularly important to consider when changing an existing IP address or CIDR block as they cannot be updated via the Provider, hence a change will force the destruction and recreation of entries.
 *
 * > **IMPORTANT WARNING:** Managing Service Accounts with Terraform **exposes sensitive organizational secrets** in Terraform's state. We suggest following Terraform's best practices.
 *
 * ## Example Usage
 *
 * ### S
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as mongodbatlas from "@pulumi/mongodbatlas";
 *
 * const thisServiceAccount = new mongodbatlas.ServiceAccount("this", {
 *     orgId: orgId,
 *     name: "example-service-account",
 *     description: "Example Service Account",
 *     roles: ["ORG_READ_ONLY"],
 *     secretExpiresAfterHours: 2160,
 * });
 * // Add IP Access List Entry to Service Account using CIDR Block
 * const cidr = new mongodbatlas.ServiceAccountAccessListEntry("cidr", {
 *     orgId: orgId,
 *     clientId: thisServiceAccount.clientId,
 *     cidrBlock: "1.2.3.4/32",
 * });
 * // Add IP Access List Entry to Service Account using IP Address
 * const ip = new mongodbatlas.ServiceAccountAccessListEntry("ip", {
 *     orgId: orgId,
 *     clientId: thisServiceAccount.clientId,
 *     ipAddress: "2.3.4.5",
 * });
 * // Data source to read a single Access List entry for the Service Account
 * const _this = mongodbatlas.getServiceAccountAccessListEntryOutput({
 *     orgId: cidr.orgId,
 *     clientId: cidr.clientId,
 *     cidrBlock: cidr.cidrBlock,
 * });
 * export const accessListEntryCidrBlock = _this.apply(_this => _this.cidrBlock);
 * // Data source to read all Access List entries for the Service Account
 * const thisGetServiceAccountAccessListEntries = mongodbatlas.getServiceAccountAccessListEntriesOutput({
 *     orgId: thisServiceAccount.orgId,
 *     clientId: thisServiceAccount.clientId,
 * });
 * export const allAccessListEntries = thisGetServiceAccountAccessListEntries.apply(thisGetServiceAccountAccessListEntries => thisGetServiceAccountAccessListEntries.results);
 * ```
 */
export function getServiceAccountAccessListEntriesOutput(args: GetServiceAccountAccessListEntriesOutputArgs, opts?: pulumi.InvokeOutputOptions): pulumi.Output<GetServiceAccountAccessListEntriesResult> {
    opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts || {});
    return pulumi.runtime.invokeOutput("mongodbatlas:index/getServiceAccountAccessListEntries:getServiceAccountAccessListEntries", {
        "clientId": args.clientId,
        "orgId": args.orgId,
    }, opts);
}

/**
 * A collection of arguments for invoking getServiceAccountAccessListEntries.
 */
export interface GetServiceAccountAccessListEntriesOutputArgs {
    /**
     * The Client ID of the Service Account.
     */
    clientId: pulumi.Input<string>;
    /**
     * Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
     */
    orgId: pulumi.Input<string>;
}
