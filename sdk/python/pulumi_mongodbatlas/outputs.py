# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'AdvancedClusterAdvancedConfiguration',
    'AdvancedClusterBiConnector',
    'AdvancedClusterConnectionString',
    'AdvancedClusterConnectionStringPrivateEndpoint',
    'AdvancedClusterConnectionStringPrivateEndpointEndpoint',
    'AdvancedClusterLabel',
    'AdvancedClusterReplicationSpec',
    'AdvancedClusterReplicationSpecRegionConfig',
    'AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs',
    'AdvancedClusterReplicationSpecRegionConfigAutoScaling',
    'AdvancedClusterReplicationSpecRegionConfigElectableSpecs',
    'AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs',
    'AlertConfigurationMatcher',
    'AlertConfigurationMetricThresholdConfig',
    'AlertConfigurationNotification',
    'AlertConfigurationThresholdConfig',
    'CloudBackupScheduleExport',
    'CloudBackupSchedulePolicyItemDaily',
    'CloudBackupSchedulePolicyItemHourly',
    'CloudBackupSchedulePolicyItemMonthly',
    'CloudBackupSchedulePolicyItemWeekly',
    'CloudBackupSnapshotExportJobComponent',
    'CloudBackupSnapshotExportJobCustomData',
    'CloudBackupSnapshotMember',
    'CloudBackupSnapshotRestoreJobDeliveryTypeConfig',
    'CloudProviderAccessAuthorizationAws',
    'CloudProviderAccessAuthorizationFeatureUsage',
    'CloudProviderAccessFeatureUsage',
    'CloudProviderAccessSetupAwsConfig',
    'CloudProviderSnapshotBackupPolicyPolicy',
    'CloudProviderSnapshotBackupPolicyPolicyPolicyItem',
    'CloudProviderSnapshotRestoreJobDeliveryTypeConfig',
    'ClusterAdvancedConfiguration',
    'ClusterBiConnectorConfig',
    'ClusterConnectionString',
    'ClusterConnectionStringPrivateEndpoint',
    'ClusterConnectionStringPrivateEndpointEndpoint',
    'ClusterLabel',
    'ClusterReplicationSpec',
    'ClusterReplicationSpecRegionsConfig',
    'ClusterSnapshotBackupPolicy',
    'ClusterSnapshotBackupPolicyPolicy',
    'ClusterSnapshotBackupPolicyPolicyPolicyItem',
    'CustomDbRoleAction',
    'CustomDbRoleActionResource',
    'CustomDbRoleInheritedRole',
    'DataLakeAws',
    'DataLakeDataProcessRegion',
    'DataLakeStorageDatabase',
    'DataLakeStorageDatabaseCollection',
    'DataLakeStorageDatabaseCollectionDataSource',
    'DataLakeStorageDatabaseView',
    'DataLakeStorageStore',
    'DatabaseUserLabel',
    'DatabaseUserRole',
    'DatabaseUserScope',
    'EncryptionAtRestAwsKmsConfig',
    'EncryptionAtRestAzureKeyVaultConfig',
    'EncryptionAtRestGoogleCloudKmsConfig',
    'EventTriggerEventProcessors',
    'EventTriggerEventProcessorsAwsEventbridge',
    'FederatedSettingsOrgRoleMappingRoleAssignment',
    'GlobalClusterConfigCustomZoneMapping',
    'GlobalClusterConfigManagedNamespace',
    'LdapConfigurationUserToDnMapping',
    'LdapVerifyLink',
    'LdapVerifyValidation',
    'OnlineArchiveCriteria',
    'OnlineArchivePartitionField',
    'PrivateLinkEndpointServiceEndpoint',
    'ProjectApiKey',
    'ProjectTeam',
    'SearchIndexSynonym',
    'ServerlessInstanceLink',
    'X509AuthenticationDatabaseUserCertificate',
    'Get509AuthenticationDatabaseUserCertificateResult',
    'GetAdvancedClusterAdvancedConfigurationResult',
    'GetAdvancedClusterBiConnectorResult',
    'GetAdvancedClusterConnectionStringResult',
    'GetAdvancedClusterConnectionStringPrivateEndpointResult',
    'GetAdvancedClusterConnectionStringPrivateEndpointEndpointResult',
    'GetAdvancedClusterLabelResult',
    'GetAdvancedClusterReplicationSpecResult',
    'GetAdvancedClusterReplicationSpecRegionConfigResult',
    'GetAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsResult',
    'GetAdvancedClusterReplicationSpecRegionConfigAutoScalingResult',
    'GetAdvancedClusterReplicationSpecRegionConfigElectableSpecsResult',
    'GetAdvancedClusterReplicationSpecRegionConfigReadOnlySpecsResult',
    'GetAdvancedClustersResultResult',
    'GetAdvancedClustersResultAdvancedConfigurationResult',
    'GetAdvancedClustersResultBiConnectorResult',
    'GetAdvancedClustersResultConnectionStringResult',
    'GetAdvancedClustersResultConnectionStringPrivateEndpointResult',
    'GetAdvancedClustersResultConnectionStringPrivateEndpointEndpointResult',
    'GetAdvancedClustersResultLabelResult',
    'GetAdvancedClustersResultReplicationSpecResult',
    'GetAdvancedClustersResultReplicationSpecRegionConfigResult',
    'GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecsResult',
    'GetAdvancedClustersResultReplicationSpecRegionConfigAutoScalingResult',
    'GetAdvancedClustersResultReplicationSpecRegionConfigElectableSpecsResult',
    'GetAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecsResult',
    'GetAlertConfigurationMatcherResult',
    'GetAlertConfigurationMetricThresholdConfigResult',
    'GetAlertConfigurationNotificationResult',
    'GetAlertConfigurationThresholdConfigResult',
    'GetCloudBackupScheduleExportResult',
    'GetCloudBackupSchedulePolicyItemDailyResult',
    'GetCloudBackupSchedulePolicyItemHourlyResult',
    'GetCloudBackupSchedulePolicyItemMonthlyResult',
    'GetCloudBackupSchedulePolicyItemWeeklyResult',
    'GetCloudBackupSnapshotExportBucketsResultResult',
    'GetCloudBackupSnapshotExportJobComponentResult',
    'GetCloudBackupSnapshotExportJobCustomDataResult',
    'GetCloudBackupSnapshotExportJobsResultResult',
    'GetCloudBackupSnapshotExportJobsResultComponentResult',
    'GetCloudBackupSnapshotExportJobsResultCustomDataResult',
    'GetCloudBackupSnapshotMemberResult',
    'GetCloudBackupSnapshotRestoreJobsResultResult',
    'GetCloudBackupSnapshotsResultResult',
    'GetCloudBackupSnapshotsResultMemberResult',
    'GetCloudProviderAccessAwsIamRoleResult',
    'GetCloudProviderAccessAwsIamRoleFeatureUsageResult',
    'GetCloudProviderAccessSetupAwsConfigResult',
    'GetCloudProviderSnapshotBackupPolicyPolicyResult',
    'GetCloudProviderSnapshotBackupPolicyPolicyPolicyItemResult',
    'GetCloudProviderSnapshotRestoreJobsResultResult',
    'GetCloudProviderSnapshotsResultResult',
    'GetClusterAdvancedConfigurationResult',
    'GetClusterBiConnectorConfigResult',
    'GetClusterConnectionStringResult',
    'GetClusterConnectionStringPrivateEndpointResult',
    'GetClusterConnectionStringPrivateEndpointEndpointResult',
    'GetClusterLabelResult',
    'GetClusterReplicationSpecResult',
    'GetClusterReplicationSpecRegionsConfigResult',
    'GetClusterSnapshotBackupPolicyResult',
    'GetClusterSnapshotBackupPolicyPolicyResult',
    'GetClusterSnapshotBackupPolicyPolicyPolicyItemResult',
    'GetClustersResultResult',
    'GetClustersResultAdvancedConfigurationResult',
    'GetClustersResultBiConnectorConfigResult',
    'GetClustersResultConnectionStringResult',
    'GetClustersResultConnectionStringPrivateEndpointResult',
    'GetClustersResultConnectionStringPrivateEndpointEndpointResult',
    'GetClustersResultLabelResult',
    'GetClustersResultReplicationSpecResult',
    'GetClustersResultReplicationSpecRegionsConfigResult',
    'GetClustersResultSnapshotBackupPolicyResult',
    'GetClustersResultSnapshotBackupPolicyPolicyResult',
    'GetClustersResultSnapshotBackupPolicyPolicyPolicyItemResult',
    'GetCustomDbRoleActionResult',
    'GetCustomDbRoleActionResourceResult',
    'GetCustomDbRoleInheritedRoleResult',
    'GetCustomDbRolesResultResult',
    'GetCustomDbRolesResultActionResult',
    'GetCustomDbRolesResultActionResourceResult',
    'GetCustomDbRolesResultInheritedRoleResult',
    'GetDataLakeAwResult',
    'GetDataLakeDataProcessRegionResult',
    'GetDataLakeStorageDatabaseResult',
    'GetDataLakeStorageDatabaseCollectionResult',
    'GetDataLakeStorageDatabaseCollectionDataSourceResult',
    'GetDataLakeStorageDatabaseViewResult',
    'GetDataLakeStorageStoreResult',
    'GetDataLakesResultResult',
    'GetDataLakesResultAwResult',
    'GetDataLakesResultDataProcessRegionResult',
    'GetDataLakesResultStorageDatabaseResult',
    'GetDataLakesResultStorageDatabaseCollectionResult',
    'GetDataLakesResultStorageDatabaseCollectionDataSourceResult',
    'GetDataLakesResultStorageDatabaseViewResult',
    'GetDataLakesResultStorageStoreResult',
    'GetDatabaseUserLabelResult',
    'GetDatabaseUserRoleResult',
    'GetDatabaseUserScopeResult',
    'GetDatabaseUsersResultResult',
    'GetDatabaseUsersResultLabelResult',
    'GetDatabaseUsersResultRoleResult',
    'GetDatabaseUsersResultScopeResult',
    'GetEventTriggerEventProcessorResult',
    'GetEventTriggerEventProcessorAwsEventbridgeResult',
    'GetEventTriggersResultResult',
    'GetEventTriggersResultEventProcessorResult',
    'GetEventTriggersResultEventProcessorAwsEventbridgeResult',
    'GetFederatedSettingsIdentityProviderAssociatedOrgResult',
    'GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingResult',
    'GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignmentResult',
    'GetFederatedSettingsIdentityProviderAssociatedOrgUserConflictResult',
    'GetFederatedSettingsIdentityProviderPemFileInfoResult',
    'GetFederatedSettingsIdentityProviderPemFileInfoCertificateResult',
    'GetFederatedSettingsIdentityProvidersResultResult',
    'GetFederatedSettingsIdentityProvidersResultAssociatedOrgResult',
    'GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingResult',
    'GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignmentResult',
    'GetFederatedSettingsIdentityProvidersResultAssociatedOrgUserConflictResult',
    'GetFederatedSettingsIdentityProvidersResultPemFileInfoResult',
    'GetFederatedSettingsIdentityProvidersResultPemFileInfoCertificateResult',
    'GetFederatedSettingsOrgConfigRoleMappingResult',
    'GetFederatedSettingsOrgConfigRoleMappingRoleAssignmentResult',
    'GetFederatedSettingsOrgConfigUserConflictResult',
    'GetFederatedSettingsOrgConfigsResultResult',
    'GetFederatedSettingsOrgConfigsResultRoleMappingResult',
    'GetFederatedSettingsOrgConfigsResultRoleMappingRoleAssignmentResult',
    'GetFederatedSettingsOrgConfigsResultUserConflictResult',
    'GetFederatedSettingsOrgRoleMappingRoleAssignmentResult',
    'GetFederatedSettingsOrgRoleMappingsResultResult',
    'GetFederatedSettingsOrgRoleMappingsResultRoleAssignmentResult',
    'GetGlobalClusterConfigManagedNamespaceResult',
    'GetLdapConfigurationUserToDnMappingResult',
    'GetLdapVerifyLinkResult',
    'GetLdapVerifyValidationResult',
    'GetNetworkContainersResultResult',
    'GetNetworkPeeringsResultResult',
    'GetOnlineArchiveCriteriaResult',
    'GetOnlineArchivePartitionFieldResult',
    'GetOnlineArchivesResultResult',
    'GetOnlineArchivesResultCriteriaResult',
    'GetOnlineArchivesResultPartitionFieldResult',
    'GetPrivateLinkEndpointServiceEndpointResult',
    'GetPrivatelinkEndpointsServiceAdlLinkResult',
    'GetPrivatelinkEndpointsServiceAdlResultResult',
    'GetProjectApiKeyResult',
    'GetProjectTeamResult',
    'GetProjectsResultResult',
    'GetProjectsResultApiKeyResult',
    'GetProjectsResultTeamResult',
    'GetSearchIndexSynonymResult',
    'GetSearchIndexesResultResult',
    'GetSearchIndexesResultSynonymResult',
    'GetServerlessInstanceLinkResult',
    'GetServerlessInstancesResultResult',
    'GetServerlessInstancesResultLinkResult',
    'GetThirdPartyIntegrationsResultResult',
]

@pulumi.output_type
class AdvancedClusterAdvancedConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultReadConcern":
            suggest = "default_read_concern"
        elif key == "defaultWriteConcern":
            suggest = "default_write_concern"
        elif key == "failIndexKeyTooLong":
            suggest = "fail_index_key_too_long"
        elif key == "javascriptEnabled":
            suggest = "javascript_enabled"
        elif key == "minimumEnabledTlsProtocol":
            suggest = "minimum_enabled_tls_protocol"
        elif key == "noTableScan":
            suggest = "no_table_scan"
        elif key == "oplogSizeMb":
            suggest = "oplog_size_mb"
        elif key == "sampleRefreshIntervalBiConnector":
            suggest = "sample_refresh_interval_bi_connector"
        elif key == "sampleSizeBiConnector":
            suggest = "sample_size_bi_connector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterAdvancedConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterAdvancedConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterAdvancedConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_read_concern: Optional[str] = None,
                 default_write_concern: Optional[str] = None,
                 fail_index_key_too_long: Optional[bool] = None,
                 javascript_enabled: Optional[bool] = None,
                 minimum_enabled_tls_protocol: Optional[str] = None,
                 no_table_scan: Optional[bool] = None,
                 oplog_size_mb: Optional[int] = None,
                 sample_refresh_interval_bi_connector: Optional[int] = None,
                 sample_size_bi_connector: Optional[int] = None):
        """
        :param str default_read_concern: [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        :param str default_write_concern: [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        :param bool fail_index_key_too_long: When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        :param bool javascript_enabled: When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        :param str minimum_enabled_tls_protocol: Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        :param bool no_table_scan: When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        :param int oplog_size_mb: The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        :param int sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param int sample_size_bi_connector: Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        if default_read_concern is not None:
            pulumi.set(__self__, "default_read_concern", default_read_concern)
        if default_write_concern is not None:
            pulumi.set(__self__, "default_write_concern", default_write_concern)
        if fail_index_key_too_long is not None:
            pulumi.set(__self__, "fail_index_key_too_long", fail_index_key_too_long)
        if javascript_enabled is not None:
            pulumi.set(__self__, "javascript_enabled", javascript_enabled)
        if minimum_enabled_tls_protocol is not None:
            pulumi.set(__self__, "minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        if no_table_scan is not None:
            pulumi.set(__self__, "no_table_scan", no_table_scan)
        if oplog_size_mb is not None:
            pulumi.set(__self__, "oplog_size_mb", oplog_size_mb)
        if sample_refresh_interval_bi_connector is not None:
            pulumi.set(__self__, "sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        if sample_size_bi_connector is not None:
            pulumi.set(__self__, "sample_size_bi_connector", sample_size_bi_connector)

    @property
    @pulumi.getter(name="defaultReadConcern")
    def default_read_concern(self) -> Optional[str]:
        """
        [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        """
        return pulumi.get(self, "default_read_concern")

    @property
    @pulumi.getter(name="defaultWriteConcern")
    def default_write_concern(self) -> Optional[str]:
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        return pulumi.get(self, "default_write_concern")

    @property
    @pulumi.getter(name="failIndexKeyTooLong")
    def fail_index_key_too_long(self) -> Optional[bool]:
        """
        When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        """
        return pulumi.get(self, "fail_index_key_too_long")

    @property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> Optional[bool]:
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        return pulumi.get(self, "javascript_enabled")

    @property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> Optional[str]:
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> Optional[bool]:
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        return pulumi.get(self, "no_table_scan")

    @property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> Optional[int]:
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        return pulumi.get(self, "oplog_size_mb")

    @property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> Optional[int]:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> Optional[int]:
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_size_bi_connector")


@pulumi.output_type
class AdvancedClusterBiConnector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readPreference":
            suggest = "read_preference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterBiConnector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterBiConnector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterBiConnector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 read_preference: Optional[str] = None):
        """
        :param bool enabled: Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
               *
               - Set to `true` to enable BI Connector for Atlas.
               - Set to `false` to disable BI Connector for Atlas.
        :param str read_preference: Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if read_preference is not None:
            pulumi.set(__self__, "read_preference", read_preference)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
        *
        - Set to `true` to enable BI Connector for Atlas.
        - Set to `false` to disable BI Connector for Atlas.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> Optional[str]:
        """
        Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        return pulumi.get(self, "read_preference")


@pulumi.output_type
class AdvancedClusterConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsPrivateLink":
            suggest = "aws_private_link"
        elif key == "awsPrivateLinkSrv":
            suggest = "aws_private_link_srv"
        elif key == "privateEndpoints":
            suggest = "private_endpoints"
        elif key == "privateSrv":
            suggest = "private_srv"
        elif key == "standardSrv":
            suggest = "standard_srv"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_private_link: Optional[Mapping[str, Any]] = None,
                 aws_private_link_srv: Optional[Mapping[str, Any]] = None,
                 private: Optional[str] = None,
                 private_endpoints: Optional[Sequence['outputs.AdvancedClusterConnectionStringPrivateEndpoint']] = None,
                 private_srv: Optional[str] = None,
                 standard: Optional[str] = None,
                 standard_srv: Optional[str] = None):
        if aws_private_link is not None:
            pulumi.set(__self__, "aws_private_link", aws_private_link)
        if aws_private_link_srv is not None:
            pulumi.set(__self__, "aws_private_link_srv", aws_private_link_srv)
        if private is not None:
            pulumi.set(__self__, "private", private)
        if private_endpoints is not None:
            pulumi.set(__self__, "private_endpoints", private_endpoints)
        if private_srv is not None:
            pulumi.set(__self__, "private_srv", private_srv)
        if standard is not None:
            pulumi.set(__self__, "standard", standard)
        if standard_srv is not None:
            pulumi.set(__self__, "standard_srv", standard_srv)

    @property
    @pulumi.getter(name="awsPrivateLink")
    def aws_private_link(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "aws_private_link")

    @property
    @pulumi.getter(name="awsPrivateLinkSrv")
    def aws_private_link_srv(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "aws_private_link_srv")

    @property
    @pulumi.getter
    def private(self) -> Optional[str]:
        return pulumi.get(self, "private")

    @property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Optional[Sequence['outputs.AdvancedClusterConnectionStringPrivateEndpoint']]:
        return pulumi.get(self, "private_endpoints")

    @property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> Optional[str]:
        return pulumi.get(self, "private_srv")

    @property
    @pulumi.getter
    def standard(self) -> Optional[str]:
        return pulumi.get(self, "standard")

    @property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> Optional[str]:
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class AdvancedClusterConnectionStringPrivateEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionString":
            suggest = "connection_string"
        elif key == "srvConnectionString":
            suggest = "srv_connection_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterConnectionStringPrivateEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterConnectionStringPrivateEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterConnectionStringPrivateEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_string: Optional[str] = None,
                 endpoints: Optional[Sequence['outputs.AdvancedClusterConnectionStringPrivateEndpointEndpoint']] = None,
                 srv_connection_string: Optional[str] = None,
                 type: Optional[str] = None):
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if srv_connection_string is not None:
            pulumi.set(__self__, "srv_connection_string", srv_connection_string)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[str]:
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence['outputs.AdvancedClusterConnectionStringPrivateEndpointEndpoint']]:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> Optional[str]:
        return pulumi.get(self, "srv_connection_string")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class AdvancedClusterConnectionStringPrivateEndpointEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointId":
            suggest = "endpoint_id"
        elif key == "providerName":
            suggest = "provider_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterConnectionStringPrivateEndpointEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterConnectionStringPrivateEndpointEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterConnectionStringPrivateEndpointEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_id: Optional[str] = None,
                 provider_name: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str provider_name: Cloud service provider on which the servers are provisioned.
               The possible values are:
        """
        if endpoint_id is not None:
            pulumi.set(__self__, "endpoint_id", endpoint_id)
        if provider_name is not None:
            pulumi.set(__self__, "provider_name", provider_name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[str]:
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> Optional[str]:
        """
        Cloud service provider on which the servers are provisioned.
        The possible values are:
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class AdvancedClusterLabel(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AdvancedClusterReplicationSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionConfigs":
            suggest = "region_configs"
        elif key == "containerId":
            suggest = "container_id"
        elif key == "numShards":
            suggest = "num_shards"
        elif key == "zoneName":
            suggest = "zone_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterReplicationSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterReplicationSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterReplicationSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region_configs: Sequence['outputs.AdvancedClusterReplicationSpecRegionConfig'],
                 container_id: Optional[Mapping[str, str]] = None,
                 num_shards: Optional[int] = None,
                 zone_name: Optional[str] = None):
        """
        :param Sequence['AdvancedClusterReplicationSpecRegionConfigArgs'] region_configs: Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below
        :param Mapping[str, str] container_id: A key-value map of the Network Peering Container ID(s) for the configuration specified in `region_configs`. The Container ID is the id of the container either created programmatically by the user before any clusters existed in a project or when the first cluster in the region (AWS/Azure) or project (GCP) was created.  The syntax is `"providerName:regionName" = "containerId"`. Example `AWS:US_EAST_1" = "61e0797dde08fb498ca11a71`.
        :param int num_shards: Provide this value if you set a `cluster_type` of SHARDED or GEOSHARDED. Omit this value if you selected a `cluster_type` of REPLICASET. This API resource accepts 1 through 50, inclusive. This parameter defaults to 1. If you specify a `num_shards` value of 1 and a `cluster_type` of SHARDED, Atlas deploys a single-shard [sharded cluster](https://docs.atlas.mongodb.com/reference/glossary/#std-term-sharded-cluster). Don't create a sharded cluster with a single shard for production environments. Single-shard sharded clusters don't provide the same benefits as multi-shard configurations.
        :param str zone_name: Name for the zone in a Global Cluster.
        """
        pulumi.set(__self__, "region_configs", region_configs)
        if container_id is not None:
            pulumi.set(__self__, "container_id", container_id)
        if num_shards is not None:
            pulumi.set(__self__, "num_shards", num_shards)
        if zone_name is not None:
            pulumi.set(__self__, "zone_name", zone_name)

    @property
    @pulumi.getter(name="regionConfigs")
    def region_configs(self) -> Sequence['outputs.AdvancedClusterReplicationSpecRegionConfig']:
        """
        Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below
        """
        return pulumi.get(self, "region_configs")

    @property
    @pulumi.getter(name="containerId")
    def container_id(self) -> Optional[Mapping[str, str]]:
        """
        A key-value map of the Network Peering Container ID(s) for the configuration specified in `region_configs`. The Container ID is the id of the container either created programmatically by the user before any clusters existed in a project or when the first cluster in the region (AWS/Azure) or project (GCP) was created.  The syntax is `"providerName:regionName" = "containerId"`. Example `AWS:US_EAST_1" = "61e0797dde08fb498ca11a71`.
        """
        return pulumi.get(self, "container_id")

    @property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> Optional[int]:
        """
        Provide this value if you set a `cluster_type` of SHARDED or GEOSHARDED. Omit this value if you selected a `cluster_type` of REPLICASET. This API resource accepts 1 through 50, inclusive. This parameter defaults to 1. If you specify a `num_shards` value of 1 and a `cluster_type` of SHARDED, Atlas deploys a single-shard [sharded cluster](https://docs.atlas.mongodb.com/reference/glossary/#std-term-sharded-cluster). Don't create a sharded cluster with a single shard for production environments. Single-shard sharded clusters don't provide the same benefits as multi-shard configurations.
        """
        return pulumi.get(self, "num_shards")

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> Optional[str]:
        """
        Name for the zone in a Global Cluster.
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class AdvancedClusterReplicationSpecRegionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "providerName":
            suggest = "provider_name"
        elif key == "regionName":
            suggest = "region_name"
        elif key == "analyticsSpecs":
            suggest = "analytics_specs"
        elif key == "autoScaling":
            suggest = "auto_scaling"
        elif key == "backingProviderName":
            suggest = "backing_provider_name"
        elif key == "electableSpecs":
            suggest = "electable_specs"
        elif key == "readOnlySpecs":
            suggest = "read_only_specs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterReplicationSpecRegionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterReplicationSpecRegionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterReplicationSpecRegionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 priority: int,
                 provider_name: str,
                 region_name: str,
                 analytics_specs: Optional['outputs.AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs'] = None,
                 auto_scaling: Optional['outputs.AdvancedClusterReplicationSpecRegionConfigAutoScaling'] = None,
                 backing_provider_name: Optional[str] = None,
                 electable_specs: Optional['outputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecs'] = None,
                 read_only_specs: Optional['outputs.AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs'] = None):
        """
        :param int priority: Election priority of the region. For regions with only read-only nodes, set this value to 0.
               * If you have multiple `region_configs` objects (your cluster is multi-region or multi-cloud), they must have priorities in descending order. The highest priority is 7.
               * If your region has set `region_configs.#.electable_specs.0.node_count` to 1 or higher, it must have a priority of exactly one (1) less than another region in the `replication_specs.#.region_configs.#` array. The highest-priority region must have a priority of 7. The lowest possible priority is 1.
        :param str provider_name: Cloud service provider on which the servers are provisioned.
               The possible values are:
        :param str region_name: Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        :param 'AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgs' analytics_specs: Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. Analytics nodes handle analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only and can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary). If you don't specify this parameter, no analytics nodes deploy to this region. See below
        :param 'AdvancedClusterReplicationSpecRegionConfigAutoScalingArgs' auto_scaling: Configuration for the Collection of settings that configures auto-scaling information for the cluster. The values for the `auto_scaling` parameter must be the same for every item in the `replication_specs` array. See below
        :param str backing_provider_name: Cloud service provider on which you provision the host for a multi-tenant cluster. Use this only when a `provider_name` is `TENANT` and `instance_size` of a specs is `M2` or `M5`.
        :param 'AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs' electable_specs: Hardware specifications for electable nodes in the region. Electable nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you do not specify this option, no electable nodes are deployed to the region. See below
        :param 'AdvancedClusterReplicationSpecRegionConfigReadOnlySpecsArgs' read_only_specs: Hardware specifications for read-only nodes in the region. Read-only nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you don't specify this parameter, no read-only nodes are deployed to the region. See below
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "region_name", region_name)
        if analytics_specs is not None:
            pulumi.set(__self__, "analytics_specs", analytics_specs)
        if auto_scaling is not None:
            pulumi.set(__self__, "auto_scaling", auto_scaling)
        if backing_provider_name is not None:
            pulumi.set(__self__, "backing_provider_name", backing_provider_name)
        if electable_specs is not None:
            pulumi.set(__self__, "electable_specs", electable_specs)
        if read_only_specs is not None:
            pulumi.set(__self__, "read_only_specs", read_only_specs)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Election priority of the region. For regions with only read-only nodes, set this value to 0.
        * If you have multiple `region_configs` objects (your cluster is multi-region or multi-cloud), they must have priorities in descending order. The highest priority is 7.
        * If your region has set `region_configs.#.electable_specs.0.node_count` to 1 or higher, it must have a priority of exactly one (1) less than another region in the `replication_specs.#.region_configs.#` array. The highest-priority region must have a priority of 7. The lowest possible priority is 1.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Cloud service provider on which the servers are provisioned.
        The possible values are:
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter(name="analyticsSpecs")
    def analytics_specs(self) -> Optional['outputs.AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs']:
        """
        Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. Analytics nodes handle analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only and can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary). If you don't specify this parameter, no analytics nodes deploy to this region. See below
        """
        return pulumi.get(self, "analytics_specs")

    @property
    @pulumi.getter(name="autoScaling")
    def auto_scaling(self) -> Optional['outputs.AdvancedClusterReplicationSpecRegionConfigAutoScaling']:
        """
        Configuration for the Collection of settings that configures auto-scaling information for the cluster. The values for the `auto_scaling` parameter must be the same for every item in the `replication_specs` array. See below
        """
        return pulumi.get(self, "auto_scaling")

    @property
    @pulumi.getter(name="backingProviderName")
    def backing_provider_name(self) -> Optional[str]:
        """
        Cloud service provider on which you provision the host for a multi-tenant cluster. Use this only when a `provider_name` is `TENANT` and `instance_size` of a specs is `M2` or `M5`.
        """
        return pulumi.get(self, "backing_provider_name")

    @property
    @pulumi.getter(name="electableSpecs")
    def electable_specs(self) -> Optional['outputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecs']:
        """
        Hardware specifications for electable nodes in the region. Electable nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you do not specify this option, no electable nodes are deployed to the region. See below
        """
        return pulumi.get(self, "electable_specs")

    @property
    @pulumi.getter(name="readOnlySpecs")
    def read_only_specs(self) -> Optional['outputs.AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs']:
        """
        Hardware specifications for read-only nodes in the region. Read-only nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you don't specify this parameter, no read-only nodes are deployed to the region. See below
        """
        return pulumi.get(self, "read_only_specs")


@pulumi.output_type
class AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceSize":
            suggest = "instance_size"
        elif key == "diskIops":
            suggest = "disk_iops"
        elif key == "ebsVolumeType":
            suggest = "ebs_volume_type"
        elif key == "nodeCount":
            suggest = "node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_size: str,
                 disk_iops: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 node_count: Optional[int] = None):
        """
        :param str instance_size: Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size.
        :param int disk_iops: Target throughput (IOPS) desired for AWS storage attached to your cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster.
        :param str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        :param int node_count: Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary), but can enable local reads.
        """
        pulumi.set(__self__, "instance_size", instance_size)
        if disk_iops is not None:
            pulumi.set(__self__, "disk_iops", disk_iops)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size.
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[int]:
        """
        Target throughput (IOPS) desired for AWS storage attached to your cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        """
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary), but can enable local reads.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class AdvancedClusterReplicationSpecRegionConfigAutoScaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeEnabled":
            suggest = "compute_enabled"
        elif key == "computeMaxInstanceSize":
            suggest = "compute_max_instance_size"
        elif key == "computeMinInstanceSize":
            suggest = "compute_min_instance_size"
        elif key == "computeScaleDownEnabled":
            suggest = "compute_scale_down_enabled"
        elif key == "diskGbEnabled":
            suggest = "disk_gb_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterReplicationSpecRegionConfigAutoScaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterReplicationSpecRegionConfigAutoScaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterReplicationSpecRegionConfigAutoScaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_enabled: Optional[bool] = None,
                 compute_max_instance_size: Optional[str] = None,
                 compute_min_instance_size: Optional[str] = None,
                 compute_scale_down_enabled: Optional[bool] = None,
                 disk_gb_enabled: Optional[bool] = None):
        """
        :param bool compute_enabled: Flag that indicates whether instance size auto-scaling is enabled. This parameter defaults to false.
        :param str compute_max_instance_size: Maximum instance size to which your cluster can automatically scale (such as M40). Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_enabled` is true.
        :param str compute_min_instance_size: Minimum instance size to which your cluster can automatically scale (such as M10). Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_scale_down_enabled` is true.
        :param bool compute_scale_down_enabled: Flag that indicates whether the instance size may scale down. Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_enabled` : true. If you enable this option, specify a value for `replication_specs.#.region_configs.#.auto_scaling.0.compute_min_instance_size`.
        :param bool disk_gb_enabled: Flag that indicates whether this cluster enables disk auto-scaling. This parameter defaults to true.
        """
        if compute_enabled is not None:
            pulumi.set(__self__, "compute_enabled", compute_enabled)
        if compute_max_instance_size is not None:
            pulumi.set(__self__, "compute_max_instance_size", compute_max_instance_size)
        if compute_min_instance_size is not None:
            pulumi.set(__self__, "compute_min_instance_size", compute_min_instance_size)
        if compute_scale_down_enabled is not None:
            pulumi.set(__self__, "compute_scale_down_enabled", compute_scale_down_enabled)
        if disk_gb_enabled is not None:
            pulumi.set(__self__, "disk_gb_enabled", disk_gb_enabled)

    @property
    @pulumi.getter(name="computeEnabled")
    def compute_enabled(self) -> Optional[bool]:
        """
        Flag that indicates whether instance size auto-scaling is enabled. This parameter defaults to false.
        """
        return pulumi.get(self, "compute_enabled")

    @property
    @pulumi.getter(name="computeMaxInstanceSize")
    def compute_max_instance_size(self) -> Optional[str]:
        """
        Maximum instance size to which your cluster can automatically scale (such as M40). Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_enabled` is true.
        """
        return pulumi.get(self, "compute_max_instance_size")

    @property
    @pulumi.getter(name="computeMinInstanceSize")
    def compute_min_instance_size(self) -> Optional[str]:
        """
        Minimum instance size to which your cluster can automatically scale (such as M10). Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_scale_down_enabled` is true.
        """
        return pulumi.get(self, "compute_min_instance_size")

    @property
    @pulumi.getter(name="computeScaleDownEnabled")
    def compute_scale_down_enabled(self) -> Optional[bool]:
        """
        Flag that indicates whether the instance size may scale down. Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_enabled` : true. If you enable this option, specify a value for `replication_specs.#.region_configs.#.auto_scaling.0.compute_min_instance_size`.
        """
        return pulumi.get(self, "compute_scale_down_enabled")

    @property
    @pulumi.getter(name="diskGbEnabled")
    def disk_gb_enabled(self) -> Optional[bool]:
        """
        Flag that indicates whether this cluster enables disk auto-scaling. This parameter defaults to true.
        """
        return pulumi.get(self, "disk_gb_enabled")


@pulumi.output_type
class AdvancedClusterReplicationSpecRegionConfigElectableSpecs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceSize":
            suggest = "instance_size"
        elif key == "diskIops":
            suggest = "disk_iops"
        elif key == "ebsVolumeType":
            suggest = "ebs_volume_type"
        elif key == "nodeCount":
            suggest = "node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterReplicationSpecRegionConfigElectableSpecs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterReplicationSpecRegionConfigElectableSpecs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterReplicationSpecRegionConfigElectableSpecs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_size: str,
                 disk_iops: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 node_count: Optional[int] = None):
        """
        :param str instance_size: Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size.
        :param int disk_iops: Target throughput (IOPS) desired for AWS storage attached to your cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster.
        :param str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        :param int node_count: Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary), but can enable local reads.
        """
        pulumi.set(__self__, "instance_size", instance_size)
        if disk_iops is not None:
            pulumi.set(__self__, "disk_iops", disk_iops)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size.
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[int]:
        """
        Target throughput (IOPS) desired for AWS storage attached to your cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        """
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary), but can enable local reads.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceSize":
            suggest = "instance_size"
        elif key == "diskIops":
            suggest = "disk_iops"
        elif key == "ebsVolumeType":
            suggest = "ebs_volume_type"
        elif key == "nodeCount":
            suggest = "node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_size: str,
                 disk_iops: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 node_count: Optional[int] = None):
        """
        :param str instance_size: Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size.
        :param int disk_iops: Target throughput (IOPS) desired for AWS storage attached to your cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster.
        :param str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        :param int node_count: Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary), but can enable local reads.
        """
        pulumi.set(__self__, "instance_size", instance_size)
        if disk_iops is not None:
            pulumi.set(__self__, "disk_iops", disk_iops)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size.
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[int]:
        """
        Target throughput (IOPS) desired for AWS storage attached to your cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        """
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary), but can enable local reads.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class AlertConfigurationMatcher(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertConfigurationMatcher. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertConfigurationMatcher.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertConfigurationMatcher.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: Optional[str] = None,
                 operator: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str field_name: Name of the field in the target object to match on.
        :param str operator: Operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
               - `GREATER_THAN`
               - `LESS_THAN`
        :param str value: Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
               - `PRIMARY`
               - `SECONDARY`
               - `STANDALONE`
               - `CONFIG`
               - `MONGOS`
        """
        if field_name is not None:
            pulumi.set(__self__, "field_name", field_name)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> Optional[str]:
        """
        Name of the field in the target object to match on.
        """
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        - `GREATER_THAN`
        - `LESS_THAN`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
        - `PRIMARY`
        - `SECONDARY`
        - `STANDALONE`
        - `CONFIG`
        - `MONGOS`
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AlertConfigurationMetricThresholdConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertConfigurationMetricThresholdConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertConfigurationMetricThresholdConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertConfigurationMetricThresholdConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: Optional[str] = None,
                 mode: Optional[str] = None,
                 operator: Optional[str] = None,
                 threshold: Optional[float] = None,
                 units: Optional[str] = None):
        """
        :param str metric_name: Name of the metric to check. The full list of current options is available [here](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types)
        :param str mode: This must be set to AVERAGE. Atlas computes the current metric value as an average.
        :param str operator: Operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
               - `GREATER_THAN`
               - `LESS_THAN`
        :param float threshold: Threshold value outside of which an alert will be triggered.
        :param str units: The units for the threshold value. Depends on the type of metric.
               Accepted values are:
               - `RAW`
               - `BITS`
               - `BYTES`
               - `KILOBITS`
               - `KILOBYTES`
               - `MEGABITS`
               - `MEGABYTES`
               - `GIGABITS`
               - `GIGABYTES`
               - `TERABYTES`
               - `PETABYTES`
               - `MILLISECONDS`
               - `SECONDS`
               - `MINUTES`
               - `HOURS`
               - `DAYS`
        """
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if units is not None:
            pulumi.set(__self__, "units", units)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[str]:
        """
        Name of the metric to check. The full list of current options is available [here](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types)
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        This must be set to AVERAGE. Atlas computes the current metric value as an average.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        - `GREATER_THAN`
        - `LESS_THAN`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        """
        Threshold value outside of which an alert will be triggered.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def units(self) -> Optional[str]:
        """
        The units for the threshold value. Depends on the type of metric.
        Accepted values are:
        - `RAW`
        - `BITS`
        - `BYTES`
        - `KILOBITS`
        - `KILOBYTES`
        - `MEGABITS`
        - `MEGABYTES`
        - `GIGABITS`
        - `GIGABYTES`
        - `TERABYTES`
        - `PETABYTES`
        - `MILLISECONDS`
        - `SECONDS`
        - `MINUTES`
        - `HOURS`
        - `DAYS`
        """
        return pulumi.get(self, "units")


@pulumi.output_type
class AlertConfigurationNotification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "channelName":
            suggest = "channel_name"
        elif key == "datadogApiKey":
            suggest = "datadog_api_key"
        elif key == "datadogRegion":
            suggest = "datadog_region"
        elif key == "delayMin":
            suggest = "delay_min"
        elif key == "emailAddress":
            suggest = "email_address"
        elif key == "emailEnabled":
            suggest = "email_enabled"
        elif key == "flowName":
            suggest = "flow_name"
        elif key == "flowdockApiToken":
            suggest = "flowdock_api_token"
        elif key == "intervalMin":
            suggest = "interval_min"
        elif key == "mobileNumber":
            suggest = "mobile_number"
        elif key == "opsGenieApiKey":
            suggest = "ops_genie_api_key"
        elif key == "opsGenieRegion":
            suggest = "ops_genie_region"
        elif key == "orgName":
            suggest = "org_name"
        elif key == "serviceKey":
            suggest = "service_key"
        elif key == "smsEnabled":
            suggest = "sms_enabled"
        elif key == "teamId":
            suggest = "team_id"
        elif key == "teamName":
            suggest = "team_name"
        elif key == "typeName":
            suggest = "type_name"
        elif key == "victorOpsApiKey":
            suggest = "victor_ops_api_key"
        elif key == "victorOpsRoutingKey":
            suggest = "victor_ops_routing_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertConfigurationNotification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertConfigurationNotification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertConfigurationNotification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: Optional[str] = None,
                 channel_name: Optional[str] = None,
                 datadog_api_key: Optional[str] = None,
                 datadog_region: Optional[str] = None,
                 delay_min: Optional[int] = None,
                 email_address: Optional[str] = None,
                 email_enabled: Optional[bool] = None,
                 flow_name: Optional[str] = None,
                 flowdock_api_token: Optional[str] = None,
                 interval_min: Optional[int] = None,
                 mobile_number: Optional[str] = None,
                 ops_genie_api_key: Optional[str] = None,
                 ops_genie_region: Optional[str] = None,
                 org_name: Optional[str] = None,
                 roles: Optional[Sequence[str]] = None,
                 service_key: Optional[str] = None,
                 sms_enabled: Optional[bool] = None,
                 team_id: Optional[str] = None,
                 team_name: Optional[str] = None,
                 type_name: Optional[str] = None,
                 username: Optional[str] = None,
                 victor_ops_api_key: Optional[str] = None,
                 victor_ops_routing_key: Optional[str] = None):
        """
        :param str api_token: Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param str channel_name: Slack channel name. Required for the SLACK notifications type.
        :param str datadog_api_key: Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        :param str datadog_region: Region that indicates which API URL to use. Accepted regions are: `US`, `EU`. The default Datadog region is US.
        :param int delay_min: Number of minutes to wait after an alert condition is detected before sending out the first notification.
        :param str email_address: Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        :param bool email_enabled: Flag indicating email notifications should be sent. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        :param str flow_name: Flowdock flow name in lower-case letters. Required for the `FLOWDOCK` notifications type
        :param str flowdock_api_token: The Flowdock personal API token. Required for the `FLOWDOCK` notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param int interval_min: Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5. **NOTE** `PAGER_DUTY`, `VICTOR_OPS`, and `OPS_GENIE` notifications do not return this value. The notification interval must be configured and managed within each external service.
        :param str mobile_number: Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        :param str ops_genie_api_key: Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param str ops_genie_region: Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        :param str org_name: Flowdock organization name in lower-case letters. This is the name that appears after www.flowdock.com/app/ in the URL string. Required for the FLOWDOCK notifications type.
        :param Sequence[str] roles: Optional. One or more roles that receive the configured alert. If you include this field, Atlas sends alerts only to users assigned the roles you specify in the array. If you omit this field, Atlas sends alerts to users assigned any role. This parameter is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
               Accepted values are:
        :param str service_key: PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param bool sms_enabled: Flag indicating if text message notifications should be sent to this user's mobile phone. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        :param str team_id: Unique identifier of a team.
        :param str team_name: Label for the team that receives this notification.
        :param str type_name: Type of alert notification.
               Accepted values are:
               - `DATADOG`
               - `EMAIL`
               - `FLOWDOCK`
        :param str username: Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        :param str victor_ops_api_key: VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param str victor_ops_routing_key: VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        if api_token is not None:
            pulumi.set(__self__, "api_token", api_token)
        if channel_name is not None:
            pulumi.set(__self__, "channel_name", channel_name)
        if datadog_api_key is not None:
            pulumi.set(__self__, "datadog_api_key", datadog_api_key)
        if datadog_region is not None:
            pulumi.set(__self__, "datadog_region", datadog_region)
        if delay_min is not None:
            pulumi.set(__self__, "delay_min", delay_min)
        if email_address is not None:
            pulumi.set(__self__, "email_address", email_address)
        if email_enabled is not None:
            pulumi.set(__self__, "email_enabled", email_enabled)
        if flow_name is not None:
            pulumi.set(__self__, "flow_name", flow_name)
        if flowdock_api_token is not None:
            pulumi.set(__self__, "flowdock_api_token", flowdock_api_token)
        if interval_min is not None:
            pulumi.set(__self__, "interval_min", interval_min)
        if mobile_number is not None:
            pulumi.set(__self__, "mobile_number", mobile_number)
        if ops_genie_api_key is not None:
            pulumi.set(__self__, "ops_genie_api_key", ops_genie_api_key)
        if ops_genie_region is not None:
            pulumi.set(__self__, "ops_genie_region", ops_genie_region)
        if org_name is not None:
            pulumi.set(__self__, "org_name", org_name)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)
        if service_key is not None:
            pulumi.set(__self__, "service_key", service_key)
        if sms_enabled is not None:
            pulumi.set(__self__, "sms_enabled", sms_enabled)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)
        if team_name is not None:
            pulumi.set(__self__, "team_name", team_name)
        if type_name is not None:
            pulumi.set(__self__, "type_name", type_name)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if victor_ops_api_key is not None:
            pulumi.set(__self__, "victor_ops_api_key", victor_ops_api_key)
        if victor_ops_routing_key is not None:
            pulumi.set(__self__, "victor_ops_routing_key", victor_ops_routing_key)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional[str]:
        """
        Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> Optional[str]:
        """
        Slack channel name. Required for the SLACK notifications type.
        """
        return pulumi.get(self, "channel_name")

    @property
    @pulumi.getter(name="datadogApiKey")
    def datadog_api_key(self) -> Optional[str]:
        """
        Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        """
        return pulumi.get(self, "datadog_api_key")

    @property
    @pulumi.getter(name="datadogRegion")
    def datadog_region(self) -> Optional[str]:
        """
        Region that indicates which API URL to use. Accepted regions are: `US`, `EU`. The default Datadog region is US.
        """
        return pulumi.get(self, "datadog_region")

    @property
    @pulumi.getter(name="delayMin")
    def delay_min(self) -> Optional[int]:
        """
        Number of minutes to wait after an alert condition is detected before sending out the first notification.
        """
        return pulumi.get(self, "delay_min")

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> Optional[str]:
        """
        Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter(name="emailEnabled")
    def email_enabled(self) -> Optional[bool]:
        """
        Flag indicating email notifications should be sent. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        """
        return pulumi.get(self, "email_enabled")

    @property
    @pulumi.getter(name="flowName")
    def flow_name(self) -> Optional[str]:
        """
        Flowdock flow name in lower-case letters. Required for the `FLOWDOCK` notifications type
        """
        return pulumi.get(self, "flow_name")

    @property
    @pulumi.getter(name="flowdockApiToken")
    def flowdock_api_token(self) -> Optional[str]:
        """
        The Flowdock personal API token. Required for the `FLOWDOCK` notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "flowdock_api_token")

    @property
    @pulumi.getter(name="intervalMin")
    def interval_min(self) -> Optional[int]:
        """
        Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5. **NOTE** `PAGER_DUTY`, `VICTOR_OPS`, and `OPS_GENIE` notifications do not return this value. The notification interval must be configured and managed within each external service.
        """
        return pulumi.get(self, "interval_min")

    @property
    @pulumi.getter(name="mobileNumber")
    def mobile_number(self) -> Optional[str]:
        """
        Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        """
        return pulumi.get(self, "mobile_number")

    @property
    @pulumi.getter(name="opsGenieApiKey")
    def ops_genie_api_key(self) -> Optional[str]:
        """
        Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "ops_genie_api_key")

    @property
    @pulumi.getter(name="opsGenieRegion")
    def ops_genie_region(self) -> Optional[str]:
        """
        Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        """
        return pulumi.get(self, "ops_genie_region")

    @property
    @pulumi.getter(name="orgName")
    def org_name(self) -> Optional[str]:
        """
        Flowdock organization name in lower-case letters. This is the name that appears after www.flowdock.com/app/ in the URL string. Required for the FLOWDOCK notifications type.
        """
        return pulumi.get(self, "org_name")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        """
        Optional. One or more roles that receive the configured alert. If you include this field, Atlas sends alerts only to users assigned the roles you specify in the array. If you omit this field, Atlas sends alerts to users assigned any role. This parameter is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        Accepted values are:
        """
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter(name="serviceKey")
    def service_key(self) -> Optional[str]:
        """
        PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "service_key")

    @property
    @pulumi.getter(name="smsEnabled")
    def sms_enabled(self) -> Optional[bool]:
        """
        Flag indicating if text message notifications should be sent to this user's mobile phone. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        """
        return pulumi.get(self, "sms_enabled")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[str]:
        """
        Unique identifier of a team.
        """
        return pulumi.get(self, "team_id")

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> Optional[str]:
        """
        Label for the team that receives this notification.
        """
        return pulumi.get(self, "team_name")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> Optional[str]:
        """
        Type of alert notification.
        Accepted values are:
        - `DATADOG`
        - `EMAIL`
        - `FLOWDOCK`
        """
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="victorOpsApiKey")
    def victor_ops_api_key(self) -> Optional[str]:
        """
        VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "victor_ops_api_key")

    @property
    @pulumi.getter(name="victorOpsRoutingKey")
    def victor_ops_routing_key(self) -> Optional[str]:
        """
        VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "victor_ops_routing_key")


@pulumi.output_type
class AlertConfigurationThresholdConfig(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 threshold: Optional[float] = None,
                 units: Optional[str] = None):
        """
        :param str operator: Operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
               - `GREATER_THAN`
               - `LESS_THAN`
        :param float threshold: Threshold value outside of which an alert will be triggered.
        :param str units: The units for the threshold value. Depends on the type of metric.
               Accepted values are:
               - `RAW`
               - `BITS`
               - `BYTES`
               - `KILOBITS`
               - `KILOBYTES`
               - `MEGABITS`
               - `MEGABYTES`
               - `GIGABITS`
               - `GIGABYTES`
               - `TERABYTES`
               - `PETABYTES`
               - `MILLISECONDS`
               - `SECONDS`
               - `MINUTES`
               - `HOURS`
               - `DAYS`
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if units is not None:
            pulumi.set(__self__, "units", units)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        - `GREATER_THAN`
        - `LESS_THAN`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        """
        Threshold value outside of which an alert will be triggered.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def units(self) -> Optional[str]:
        """
        The units for the threshold value. Depends on the type of metric.
        Accepted values are:
        - `RAW`
        - `BITS`
        - `BYTES`
        - `KILOBITS`
        - `KILOBYTES`
        - `MEGABITS`
        - `MEGABYTES`
        - `GIGABITS`
        - `GIGABYTES`
        - `TERABYTES`
        - `PETABYTES`
        - `MILLISECONDS`
        - `SECONDS`
        - `MINUTES`
        - `HOURS`
        - `DAYS`
        """
        return pulumi.get(self, "units")


@pulumi.output_type
class CloudBackupScheduleExport(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportBucketId":
            suggest = "export_bucket_id"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupScheduleExport. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupScheduleExport.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupScheduleExport.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_bucket_id: Optional[str] = None,
                 frequency_type: Optional[str] = None):
        """
        :param str export_bucket_id: Unique identifier of the CloudBackupSnapshotExportBucket export_bucket_id value.
        :param str frequency_type: Frequency associated with the export snapshot item.
        """
        if export_bucket_id is not None:
            pulumi.set(__self__, "export_bucket_id", export_bucket_id)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)

    @property
    @pulumi.getter(name="exportBucketId")
    def export_bucket_id(self) -> Optional[str]:
        """
        Unique identifier of the CloudBackupSnapshotExportBucket export_bucket_id value.
        """
        return pulumi.get(self, "export_bucket_id")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        """
        Frequency associated with the export snapshot item.
        """
        return pulumi.get(self, "frequency_type")


@pulumi.output_type
class CloudBackupSchedulePolicyItemDaily(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSchedulePolicyItemDaily. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSchedulePolicyItemDaily.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSchedulePolicyItemDaily.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 retention_unit: str,
                 retention_value: int,
                 frequency_type: Optional[str] = None):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type`.
        :param str retention_unit: Scope of the backup policy item: days, weeks, or months.
        :param int retention_value: Value to associate with `retention_unit`.
        :param str frequency_type: Frequency associated with the export snapshot item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type`.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: days, weeks, or months.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`.
        """
        return pulumi.get(self, "retention_value")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        """
        Frequency associated with the export snapshot item.
        """
        return pulumi.get(self, "frequency_type")


@pulumi.output_type
class CloudBackupSchedulePolicyItemHourly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSchedulePolicyItemHourly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSchedulePolicyItemHourly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSchedulePolicyItemHourly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 retention_unit: str,
                 retention_value: int,
                 frequency_type: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type`.
        :param str retention_unit: Scope of the backup policy item: days, weeks, or months.
        :param int retention_value: Value to associate with `retention_unit`.
        :param str frequency_type: Frequency associated with the export snapshot item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type`.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: days, weeks, or months.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`.
        """
        return pulumi.get(self, "retention_value")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        """
        Frequency associated with the export snapshot item.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class CloudBackupSchedulePolicyItemMonthly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSchedulePolicyItemMonthly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSchedulePolicyItemMonthly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSchedulePolicyItemMonthly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 retention_unit: str,
                 retention_value: int,
                 frequency_type: Optional[str] = None):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type`.
        :param str retention_unit: Scope of the backup policy item: days, weeks, or months.
        :param int retention_value: Value to associate with `retention_unit`.
        :param str frequency_type: Frequency associated with the export snapshot item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type`.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: days, weeks, or months.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`.
        """
        return pulumi.get(self, "retention_value")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        """
        Frequency associated with the export snapshot item.
        """
        return pulumi.get(self, "frequency_type")


@pulumi.output_type
class CloudBackupSchedulePolicyItemWeekly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSchedulePolicyItemWeekly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSchedulePolicyItemWeekly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSchedulePolicyItemWeekly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 retention_unit: str,
                 retention_value: int,
                 frequency_type: Optional[str] = None):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type`.
        :param str retention_unit: Scope of the backup policy item: days, weeks, or months.
        :param int retention_value: Value to associate with `retention_unit`.
        :param str frequency_type: Frequency associated with the export snapshot item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type`.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: days, weeks, or months.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`.
        """
        return pulumi.get(self, "retention_value")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        """
        Frequency associated with the export snapshot item.
        """
        return pulumi.get(self, "frequency_type")


@pulumi.output_type
class CloudBackupSnapshotExportJobComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportId":
            suggest = "export_id"
        elif key == "replicaSetName":
            suggest = "replica_set_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSnapshotExportJobComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSnapshotExportJobComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSnapshotExportJobComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_id: Optional[str] = None,
                 replica_set_name: Optional[str] = None):
        """
        :param str export_id: _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        :param str replica_set_name: _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
        if export_id is not None:
            pulumi.set(__self__, "export_id", export_id)
        if replica_set_name is not None:
            pulumi.set(__self__, "replica_set_name", replica_set_name)

    @property
    @pulumi.getter(name="exportId")
    def export_id(self) -> Optional[str]:
        """
        _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        """
        return pulumi.get(self, "export_id")

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> Optional[str]:
        """
        _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
        return pulumi.get(self, "replica_set_name")


@pulumi.output_type
class CloudBackupSnapshotExportJobCustomData(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Required if you want to include custom data using `custom_data` in the metadata file uploaded to the bucket. Key to include in the metadata file that Atlas uploads to the bucket when the export job finishes.
        :param str value: Required if you specify `key`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Required if you want to include custom data using `custom_data` in the metadata file uploaded to the bucket. Key to include in the metadata file that Atlas uploads to the bucket when the export job finishes.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Required if you specify `key`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CloudBackupSnapshotMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudProvider":
            suggest = "cloud_provider"
        elif key == "replicaSetName":
            suggest = "replica_set_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSnapshotMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSnapshotMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSnapshotMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_provider: Optional[str] = None,
                 replica_set_name: Optional[str] = None):
        """
        :param str cloud_provider: Cloud provider that stores this snapshot.
        :param str replica_set_name: Label given to a shard or config server from which Atlas took this snapshot.
        """
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if replica_set_name is not None:
            pulumi.set(__self__, "replica_set_name", replica_set_name)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[str]:
        """
        Cloud provider that stores this snapshot.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> Optional[str]:
        """
        Label given to a shard or config server from which Atlas took this snapshot.
        """
        return pulumi.get(self, "replica_set_name")


@pulumi.output_type
class CloudBackupSnapshotRestoreJobDeliveryTypeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oplogInc":
            suggest = "oplog_inc"
        elif key == "oplogTs":
            suggest = "oplog_ts"
        elif key == "pointInTime":
            suggest = "point_in_time"
        elif key == "pointInTimeUtcSeconds":
            suggest = "point_in_time_utc_seconds"
        elif key == "targetClusterName":
            suggest = "target_cluster_name"
        elif key == "targetProjectId":
            suggest = "target_project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSnapshotRestoreJobDeliveryTypeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSnapshotRestoreJobDeliveryTypeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSnapshotRestoreJobDeliveryTypeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automated: Optional[bool] = None,
                 download: Optional[bool] = None,
                 oplog_inc: Optional[int] = None,
                 oplog_ts: Optional[int] = None,
                 point_in_time: Optional[bool] = None,
                 point_in_time_utc_seconds: Optional[int] = None,
                 target_cluster_name: Optional[str] = None,
                 target_project_id: Optional[str] = None):
        """
        :param str target_cluster_name: Name of the target Atlas cluster to which the restore job restores the snapshot. Only required if deliveryType is automated.
        """
        if automated is not None:
            pulumi.set(__self__, "automated", automated)
        if download is not None:
            pulumi.set(__self__, "download", download)
        if oplog_inc is not None:
            pulumi.set(__self__, "oplog_inc", oplog_inc)
        if oplog_ts is not None:
            pulumi.set(__self__, "oplog_ts", oplog_ts)
        if point_in_time is not None:
            pulumi.set(__self__, "point_in_time", point_in_time)
        if point_in_time_utc_seconds is not None:
            pulumi.set(__self__, "point_in_time_utc_seconds", point_in_time_utc_seconds)
        if target_cluster_name is not None:
            pulumi.set(__self__, "target_cluster_name", target_cluster_name)
        if target_project_id is not None:
            pulumi.set(__self__, "target_project_id", target_project_id)

    @property
    @pulumi.getter
    def automated(self) -> Optional[bool]:
        return pulumi.get(self, "automated")

    @property
    @pulumi.getter
    def download(self) -> Optional[bool]:
        return pulumi.get(self, "download")

    @property
    @pulumi.getter(name="oplogInc")
    def oplog_inc(self) -> Optional[int]:
        return pulumi.get(self, "oplog_inc")

    @property
    @pulumi.getter(name="oplogTs")
    def oplog_ts(self) -> Optional[int]:
        return pulumi.get(self, "oplog_ts")

    @property
    @pulumi.getter(name="pointInTime")
    def point_in_time(self) -> Optional[bool]:
        return pulumi.get(self, "point_in_time")

    @property
    @pulumi.getter(name="pointInTimeUtcSeconds")
    def point_in_time_utc_seconds(self) -> Optional[int]:
        return pulumi.get(self, "point_in_time_utc_seconds")

    @property
    @pulumi.getter(name="targetClusterName")
    def target_cluster_name(self) -> Optional[str]:
        """
        Name of the target Atlas cluster to which the restore job restores the snapshot. Only required if deliveryType is automated.
        """
        return pulumi.get(self, "target_cluster_name")

    @property
    @pulumi.getter(name="targetProjectId")
    def target_project_id(self) -> Optional[str]:
        return pulumi.get(self, "target_project_id")


@pulumi.output_type
class CloudProviderAccessAuthorizationAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iamAssumedRoleArn":
            suggest = "iam_assumed_role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudProviderAccessAuthorizationAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudProviderAccessAuthorizationAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudProviderAccessAuthorizationAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iam_assumed_role_arn: str):
        pulumi.set(__self__, "iam_assumed_role_arn", iam_assumed_role_arn)

    @property
    @pulumi.getter(name="iamAssumedRoleArn")
    def iam_assumed_role_arn(self) -> str:
        return pulumi.get(self, "iam_assumed_role_arn")


@pulumi.output_type
class CloudProviderAccessAuthorizationFeatureUsage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "featureId":
            suggest = "feature_id"
        elif key == "featureType":
            suggest = "feature_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudProviderAccessAuthorizationFeatureUsage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudProviderAccessAuthorizationFeatureUsage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudProviderAccessAuthorizationFeatureUsage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 feature_id: Optional[Mapping[str, Any]] = None,
                 feature_type: Optional[str] = None):
        if feature_id is not None:
            pulumi.set(__self__, "feature_id", feature_id)
        if feature_type is not None:
            pulumi.set(__self__, "feature_type", feature_type)

    @property
    @pulumi.getter(name="featureId")
    def feature_id(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "feature_id")

    @property
    @pulumi.getter(name="featureType")
    def feature_type(self) -> Optional[str]:
        return pulumi.get(self, "feature_type")


@pulumi.output_type
class CloudProviderAccessFeatureUsage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "featureId":
            suggest = "feature_id"
        elif key == "featureType":
            suggest = "feature_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudProviderAccessFeatureUsage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudProviderAccessFeatureUsage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudProviderAccessFeatureUsage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 feature_id: Optional[Mapping[str, Any]] = None,
                 feature_type: Optional[str] = None):
        if feature_id is not None:
            pulumi.set(__self__, "feature_id", feature_id)
        if feature_type is not None:
            pulumi.set(__self__, "feature_type", feature_type)

    @property
    @pulumi.getter(name="featureId")
    def feature_id(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "feature_id")

    @property
    @pulumi.getter(name="featureType")
    def feature_type(self) -> Optional[str]:
        return pulumi.get(self, "feature_type")


@pulumi.output_type
class CloudProviderAccessSetupAwsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "atlasAssumedRoleExternalId":
            suggest = "atlas_assumed_role_external_id"
        elif key == "atlasAwsAccountArn":
            suggest = "atlas_aws_account_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudProviderAccessSetupAwsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudProviderAccessSetupAwsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudProviderAccessSetupAwsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 atlas_assumed_role_external_id: Optional[str] = None,
                 atlas_aws_account_arn: Optional[str] = None):
        if atlas_assumed_role_external_id is not None:
            pulumi.set(__self__, "atlas_assumed_role_external_id", atlas_assumed_role_external_id)
        if atlas_aws_account_arn is not None:
            pulumi.set(__self__, "atlas_aws_account_arn", atlas_aws_account_arn)

    @property
    @pulumi.getter(name="atlasAssumedRoleExternalId")
    def atlas_assumed_role_external_id(self) -> Optional[str]:
        return pulumi.get(self, "atlas_assumed_role_external_id")

    @property
    @pulumi.getter(name="atlasAwsAccountArn")
    def atlas_aws_account_arn(self) -> Optional[str]:
        return pulumi.get(self, "atlas_aws_account_arn")


@pulumi.output_type
class CloudProviderSnapshotBackupPolicyPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyItems":
            suggest = "policy_items"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudProviderSnapshotBackupPolicyPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudProviderSnapshotBackupPolicyPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudProviderSnapshotBackupPolicyPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy_items: Sequence['outputs.CloudProviderSnapshotBackupPolicyPolicyPolicyItem']):
        pulumi.set(__self__, "policy_items", policy_items)

    @property
    @pulumi.getter(name="policyItems")
    def policy_items(self) -> Sequence['outputs.CloudProviderSnapshotBackupPolicyPolicyPolicyItem']:
        return pulumi.get(self, "policy_items")


@pulumi.output_type
class CloudProviderSnapshotBackupPolicyPolicyPolicyItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "frequencyType":
            suggest = "frequency_type"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudProviderSnapshotBackupPolicyPolicyPolicyItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudProviderSnapshotBackupPolicyPolicyPolicyItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudProviderSnapshotBackupPolicyPolicyPolicyItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 retention_unit: str,
                 retention_value: int):
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class CloudProviderSnapshotRestoreJobDeliveryTypeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oplogInc":
            suggest = "oplog_inc"
        elif key == "oplogTs":
            suggest = "oplog_ts"
        elif key == "pointInTime":
            suggest = "point_in_time"
        elif key == "pointInTimeUtcSeconds":
            suggest = "point_in_time_utc_seconds"
        elif key == "targetClusterName":
            suggest = "target_cluster_name"
        elif key == "targetProjectId":
            suggest = "target_project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudProviderSnapshotRestoreJobDeliveryTypeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudProviderSnapshotRestoreJobDeliveryTypeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudProviderSnapshotRestoreJobDeliveryTypeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automated: Optional[bool] = None,
                 download: Optional[bool] = None,
                 oplog_inc: Optional[int] = None,
                 oplog_ts: Optional[int] = None,
                 point_in_time: Optional[bool] = None,
                 point_in_time_utc_seconds: Optional[int] = None,
                 target_cluster_name: Optional[str] = None,
                 target_project_id: Optional[str] = None):
        """
        :param str target_cluster_name: Name of the target Atlas cluster to which the restore job restores the snapshot. Only required if deliveryType is automated.
        """
        if automated is not None:
            pulumi.set(__self__, "automated", automated)
        if download is not None:
            pulumi.set(__self__, "download", download)
        if oplog_inc is not None:
            pulumi.set(__self__, "oplog_inc", oplog_inc)
        if oplog_ts is not None:
            pulumi.set(__self__, "oplog_ts", oplog_ts)
        if point_in_time is not None:
            pulumi.set(__self__, "point_in_time", point_in_time)
        if point_in_time_utc_seconds is not None:
            pulumi.set(__self__, "point_in_time_utc_seconds", point_in_time_utc_seconds)
        if target_cluster_name is not None:
            pulumi.set(__self__, "target_cluster_name", target_cluster_name)
        if target_project_id is not None:
            pulumi.set(__self__, "target_project_id", target_project_id)

    @property
    @pulumi.getter
    def automated(self) -> Optional[bool]:
        return pulumi.get(self, "automated")

    @property
    @pulumi.getter
    def download(self) -> Optional[bool]:
        return pulumi.get(self, "download")

    @property
    @pulumi.getter(name="oplogInc")
    def oplog_inc(self) -> Optional[int]:
        return pulumi.get(self, "oplog_inc")

    @property
    @pulumi.getter(name="oplogTs")
    def oplog_ts(self) -> Optional[int]:
        return pulumi.get(self, "oplog_ts")

    @property
    @pulumi.getter(name="pointInTime")
    def point_in_time(self) -> Optional[bool]:
        return pulumi.get(self, "point_in_time")

    @property
    @pulumi.getter(name="pointInTimeUtcSeconds")
    def point_in_time_utc_seconds(self) -> Optional[int]:
        return pulumi.get(self, "point_in_time_utc_seconds")

    @property
    @pulumi.getter(name="targetClusterName")
    def target_cluster_name(self) -> Optional[str]:
        """
        Name of the target Atlas cluster to which the restore job restores the snapshot. Only required if deliveryType is automated.
        """
        return pulumi.get(self, "target_cluster_name")

    @property
    @pulumi.getter(name="targetProjectId")
    def target_project_id(self) -> Optional[str]:
        return pulumi.get(self, "target_project_id")


@pulumi.output_type
class ClusterAdvancedConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultReadConcern":
            suggest = "default_read_concern"
        elif key == "defaultWriteConcern":
            suggest = "default_write_concern"
        elif key == "failIndexKeyTooLong":
            suggest = "fail_index_key_too_long"
        elif key == "javascriptEnabled":
            suggest = "javascript_enabled"
        elif key == "minimumEnabledTlsProtocol":
            suggest = "minimum_enabled_tls_protocol"
        elif key == "noTableScan":
            suggest = "no_table_scan"
        elif key == "oplogSizeMb":
            suggest = "oplog_size_mb"
        elif key == "sampleRefreshIntervalBiConnector":
            suggest = "sample_refresh_interval_bi_connector"
        elif key == "sampleSizeBiConnector":
            suggest = "sample_size_bi_connector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAdvancedConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAdvancedConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAdvancedConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_read_concern: Optional[str] = None,
                 default_write_concern: Optional[str] = None,
                 fail_index_key_too_long: Optional[bool] = None,
                 javascript_enabled: Optional[bool] = None,
                 minimum_enabled_tls_protocol: Optional[str] = None,
                 no_table_scan: Optional[bool] = None,
                 oplog_size_mb: Optional[int] = None,
                 sample_refresh_interval_bi_connector: Optional[int] = None,
                 sample_size_bi_connector: Optional[int] = None):
        """
        :param str default_read_concern: [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        :param str default_write_concern: [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        :param bool fail_index_key_too_long: When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        :param bool javascript_enabled: When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        :param str minimum_enabled_tls_protocol: Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        :param bool no_table_scan: When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        :param int oplog_size_mb: The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        :param int sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param int sample_size_bi_connector: Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        if default_read_concern is not None:
            pulumi.set(__self__, "default_read_concern", default_read_concern)
        if default_write_concern is not None:
            pulumi.set(__self__, "default_write_concern", default_write_concern)
        if fail_index_key_too_long is not None:
            pulumi.set(__self__, "fail_index_key_too_long", fail_index_key_too_long)
        if javascript_enabled is not None:
            pulumi.set(__self__, "javascript_enabled", javascript_enabled)
        if minimum_enabled_tls_protocol is not None:
            pulumi.set(__self__, "minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        if no_table_scan is not None:
            pulumi.set(__self__, "no_table_scan", no_table_scan)
        if oplog_size_mb is not None:
            pulumi.set(__self__, "oplog_size_mb", oplog_size_mb)
        if sample_refresh_interval_bi_connector is not None:
            pulumi.set(__self__, "sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        if sample_size_bi_connector is not None:
            pulumi.set(__self__, "sample_size_bi_connector", sample_size_bi_connector)

    @property
    @pulumi.getter(name="defaultReadConcern")
    def default_read_concern(self) -> Optional[str]:
        """
        [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        """
        return pulumi.get(self, "default_read_concern")

    @property
    @pulumi.getter(name="defaultWriteConcern")
    def default_write_concern(self) -> Optional[str]:
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        return pulumi.get(self, "default_write_concern")

    @property
    @pulumi.getter(name="failIndexKeyTooLong")
    def fail_index_key_too_long(self) -> Optional[bool]:
        """
        When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        """
        return pulumi.get(self, "fail_index_key_too_long")

    @property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> Optional[bool]:
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        return pulumi.get(self, "javascript_enabled")

    @property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> Optional[str]:
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> Optional[bool]:
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        return pulumi.get(self, "no_table_scan")

    @property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> Optional[int]:
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        return pulumi.get(self, "oplog_size_mb")

    @property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> Optional[int]:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> Optional[int]:
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_size_bi_connector")


@pulumi.output_type
class ClusterBiConnectorConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readPreference":
            suggest = "read_preference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterBiConnectorConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterBiConnectorConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterBiConnectorConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 read_preference: Optional[str] = None):
        """
        :param bool enabled: Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
               *
               - Set to `true` to enable BI Connector for Atlas.
               - Set to `false` to disable BI Connector for Atlas.
        :param str read_preference: Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if read_preference is not None:
            pulumi.set(__self__, "read_preference", read_preference)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
        *
        - Set to `true` to enable BI Connector for Atlas.
        - Set to `false` to disable BI Connector for Atlas.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> Optional[str]:
        """
        Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        return pulumi.get(self, "read_preference")


@pulumi.output_type
class ClusterConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsPrivateLink":
            suggest = "aws_private_link"
        elif key == "awsPrivateLinkSrv":
            suggest = "aws_private_link_srv"
        elif key == "privateEndpoints":
            suggest = "private_endpoints"
        elif key == "privateSrv":
            suggest = "private_srv"
        elif key == "standardSrv":
            suggest = "standard_srv"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_private_link: Optional[Mapping[str, Any]] = None,
                 aws_private_link_srv: Optional[Mapping[str, Any]] = None,
                 private: Optional[str] = None,
                 private_endpoints: Optional[Sequence['outputs.ClusterConnectionStringPrivateEndpoint']] = None,
                 private_srv: Optional[str] = None,
                 standard: Optional[str] = None,
                 standard_srv: Optional[str] = None):
        if aws_private_link is not None:
            pulumi.set(__self__, "aws_private_link", aws_private_link)
        if aws_private_link_srv is not None:
            pulumi.set(__self__, "aws_private_link_srv", aws_private_link_srv)
        if private is not None:
            pulumi.set(__self__, "private", private)
        if private_endpoints is not None:
            pulumi.set(__self__, "private_endpoints", private_endpoints)
        if private_srv is not None:
            pulumi.set(__self__, "private_srv", private_srv)
        if standard is not None:
            pulumi.set(__self__, "standard", standard)
        if standard_srv is not None:
            pulumi.set(__self__, "standard_srv", standard_srv)

    @property
    @pulumi.getter(name="awsPrivateLink")
    def aws_private_link(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "aws_private_link")

    @property
    @pulumi.getter(name="awsPrivateLinkSrv")
    def aws_private_link_srv(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "aws_private_link_srv")

    @property
    @pulumi.getter
    def private(self) -> Optional[str]:
        return pulumi.get(self, "private")

    @property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Optional[Sequence['outputs.ClusterConnectionStringPrivateEndpoint']]:
        return pulumi.get(self, "private_endpoints")

    @property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> Optional[str]:
        return pulumi.get(self, "private_srv")

    @property
    @pulumi.getter
    def standard(self) -> Optional[str]:
        return pulumi.get(self, "standard")

    @property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> Optional[str]:
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class ClusterConnectionStringPrivateEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionString":
            suggest = "connection_string"
        elif key == "srvConnectionString":
            suggest = "srv_connection_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterConnectionStringPrivateEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterConnectionStringPrivateEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterConnectionStringPrivateEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_string: Optional[str] = None,
                 endpoints: Optional[Sequence['outputs.ClusterConnectionStringPrivateEndpointEndpoint']] = None,
                 srv_connection_string: Optional[str] = None,
                 type: Optional[str] = None):
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if srv_connection_string is not None:
            pulumi.set(__self__, "srv_connection_string", srv_connection_string)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[str]:
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence['outputs.ClusterConnectionStringPrivateEndpointEndpoint']]:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> Optional[str]:
        return pulumi.get(self, "srv_connection_string")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class ClusterConnectionStringPrivateEndpointEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointId":
            suggest = "endpoint_id"
        elif key == "providerName":
            suggest = "provider_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterConnectionStringPrivateEndpointEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterConnectionStringPrivateEndpointEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterConnectionStringPrivateEndpointEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_id: Optional[str] = None,
                 provider_name: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str provider_name: Cloud service provider on which the servers are provisioned.
        """
        if endpoint_id is not None:
            pulumi.set(__self__, "endpoint_id", endpoint_id)
        if provider_name is not None:
            pulumi.set(__self__, "provider_name", provider_name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[str]:
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> Optional[str]:
        """
        Cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class ClusterLabel(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterReplicationSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numShards":
            suggest = "num_shards"
        elif key == "regionsConfigs":
            suggest = "regions_configs"
        elif key == "zoneName":
            suggest = "zone_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterReplicationSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterReplicationSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterReplicationSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_shards: int,
                 id: Optional[str] = None,
                 regions_configs: Optional[Sequence['outputs.ClusterReplicationSpecRegionsConfig']] = None,
                 zone_name: Optional[str] = None):
        """
        :param int num_shards: Number of shards to deploy in the specified zone, minimum 1.
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster.
        :param Sequence['ClusterReplicationSpecRegionsConfigArgs'] regions_configs: Physical location of the region. Each regionsConfig document describes the regions priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        :param str zone_name: Name for the zone in a Global Cluster.
        """
        pulumi.set(__self__, "num_shards", num_shards)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if regions_configs is not None:
            pulumi.set(__self__, "regions_configs", regions_configs)
        if zone_name is not None:
            pulumi.set(__self__, "zone_name", zone_name)

    @property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> int:
        """
        Number of shards to deploy in the specified zone, minimum 1.
        """
        return pulumi.get(self, "num_shards")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifer of the replication document for a zone in a Global Cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="regionsConfigs")
    def regions_configs(self) -> Optional[Sequence['outputs.ClusterReplicationSpecRegionsConfig']]:
        """
        Physical location of the region. Each regionsConfig document describes the regions priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        """
        return pulumi.get(self, "regions_configs")

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> Optional[str]:
        """
        Name for the zone in a Global Cluster.
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class ClusterReplicationSpecRegionsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionName":
            suggest = "region_name"
        elif key == "analyticsNodes":
            suggest = "analytics_nodes"
        elif key == "electableNodes":
            suggest = "electable_nodes"
        elif key == "readOnlyNodes":
            suggest = "read_only_nodes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterReplicationSpecRegionsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterReplicationSpecRegionsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterReplicationSpecRegionsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region_name: str,
                 analytics_nodes: Optional[int] = None,
                 electable_nodes: Optional[int] = None,
                 priority: Optional[int] = None,
                 read_only_nodes: Optional[int] = None):
        """
        :param str region_name: Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        :param int analytics_nodes: The number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary. If you do not specify this option, no analytics nodes are deployed to the region.
        :param int electable_nodes: Number of electable nodes for Atlas to deploy to the region. Electable nodes can become the primary and can facilitate local reads.
               * The total number of electableNodes across all replication spec regions  must total 3, 5, or 7.
               * Specify 0 if you do not want any electable nodes in the region.
               * You cannot create electable nodes in a region if `priority` is 0.
        :param int priority: Election priority of the region. For regions with only read-only nodes, set this value to 0.
               * For regions where `electable_nodes` is at least 1, each region must have a priority of exactly one (1) less than the previous region. The first region must have a priority of 7. The lowest possible priority is 1.
               * The priority 7 region identifies the Preferred Region of the cluster. Atlas places the primary node in the Preferred Region. Priorities 1 through 7 are exclusive - no more than one region per cluster can be assigned a given priority.
               * Example: If you have three regions, their priorities would be 7, 6, and 5 respectively. If you added two more regions for supporting electable nodes, the priorities of those regions would be 4 and 3 respectively.
        :param int read_only_nodes: Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        """
        pulumi.set(__self__, "region_name", region_name)
        if analytics_nodes is not None:
            pulumi.set(__self__, "analytics_nodes", analytics_nodes)
        if electable_nodes is not None:
            pulumi.set(__self__, "electable_nodes", electable_nodes)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if read_only_nodes is not None:
            pulumi.set(__self__, "read_only_nodes", read_only_nodes)

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter(name="analyticsNodes")
    def analytics_nodes(self) -> Optional[int]:
        """
        The number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary. If you do not specify this option, no analytics nodes are deployed to the region.
        """
        return pulumi.get(self, "analytics_nodes")

    @property
    @pulumi.getter(name="electableNodes")
    def electable_nodes(self) -> Optional[int]:
        """
        Number of electable nodes for Atlas to deploy to the region. Electable nodes can become the primary and can facilitate local reads.
        * The total number of electableNodes across all replication spec regions  must total 3, 5, or 7.
        * Specify 0 if you do not want any electable nodes in the region.
        * You cannot create electable nodes in a region if `priority` is 0.
        """
        return pulumi.get(self, "electable_nodes")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Election priority of the region. For regions with only read-only nodes, set this value to 0.
        * For regions where `electable_nodes` is at least 1, each region must have a priority of exactly one (1) less than the previous region. The first region must have a priority of 7. The lowest possible priority is 1.
        * The priority 7 region identifies the Preferred Region of the cluster. Atlas places the primary node in the Preferred Region. Priorities 1 through 7 are exclusive - no more than one region per cluster can be assigned a given priority.
        * Example: If you have three regions, their priorities would be 7, 6, and 5 respectively. If you added two more regions for supporting electable nodes, the priorities of those regions would be 4 and 3 respectively.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="readOnlyNodes")
    def read_only_nodes(self) -> Optional[int]:
        """
        Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        """
        return pulumi.get(self, "read_only_nodes")


@pulumi.output_type
class ClusterSnapshotBackupPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterId":
            suggest = "cluster_id"
        elif key == "clusterName":
            suggest = "cluster_name"
        elif key == "nextSnapshot":
            suggest = "next_snapshot"
        elif key == "referenceHourOfDay":
            suggest = "reference_hour_of_day"
        elif key == "referenceMinuteOfHour":
            suggest = "reference_minute_of_hour"
        elif key == "restoreWindowDays":
            suggest = "restore_window_days"
        elif key == "updateSnapshots":
            suggest = "update_snapshots"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSnapshotBackupPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSnapshotBackupPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSnapshotBackupPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_id: Optional[str] = None,
                 cluster_name: Optional[str] = None,
                 next_snapshot: Optional[str] = None,
                 policies: Optional[Sequence['outputs.ClusterSnapshotBackupPolicyPolicy']] = None,
                 reference_hour_of_day: Optional[int] = None,
                 reference_minute_of_hour: Optional[int] = None,
                 restore_window_days: Optional[int] = None,
                 update_snapshots: Optional[bool] = None):
        """
        :param str cluster_id: The cluster ID.
        """
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if next_snapshot is not None:
            pulumi.set(__self__, "next_snapshot", next_snapshot)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if reference_hour_of_day is not None:
            pulumi.set(__self__, "reference_hour_of_day", reference_hour_of_day)
        if reference_minute_of_hour is not None:
            pulumi.set(__self__, "reference_minute_of_hour", reference_minute_of_hour)
        if restore_window_days is not None:
            pulumi.set(__self__, "restore_window_days", restore_window_days)
        if update_snapshots is not None:
            pulumi.set(__self__, "update_snapshots", update_snapshots)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[str]:
        """
        The cluster ID.
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="nextSnapshot")
    def next_snapshot(self) -> Optional[str]:
        return pulumi.get(self, "next_snapshot")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence['outputs.ClusterSnapshotBackupPolicyPolicy']]:
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="referenceHourOfDay")
    def reference_hour_of_day(self) -> Optional[int]:
        return pulumi.get(self, "reference_hour_of_day")

    @property
    @pulumi.getter(name="referenceMinuteOfHour")
    def reference_minute_of_hour(self) -> Optional[int]:
        return pulumi.get(self, "reference_minute_of_hour")

    @property
    @pulumi.getter(name="restoreWindowDays")
    def restore_window_days(self) -> Optional[int]:
        return pulumi.get(self, "restore_window_days")

    @property
    @pulumi.getter(name="updateSnapshots")
    def update_snapshots(self) -> Optional[bool]:
        return pulumi.get(self, "update_snapshots")


@pulumi.output_type
class ClusterSnapshotBackupPolicyPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyItems":
            suggest = "policy_items"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSnapshotBackupPolicyPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSnapshotBackupPolicyPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSnapshotBackupPolicyPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy_items: Optional[Sequence['outputs.ClusterSnapshotBackupPolicyPolicyPolicyItem']] = None):
        if policy_items is not None:
            pulumi.set(__self__, "policy_items", policy_items)

    @property
    @pulumi.getter(name="policyItems")
    def policy_items(self) -> Optional[Sequence['outputs.ClusterSnapshotBackupPolicyPolicyPolicyItem']]:
        return pulumi.get(self, "policy_items")


@pulumi.output_type
class ClusterSnapshotBackupPolicyPolicyPolicyItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "frequencyType":
            suggest = "frequency_type"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSnapshotBackupPolicyPolicyPolicyItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSnapshotBackupPolicyPolicyPolicyItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSnapshotBackupPolicyPolicyPolicyItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: Optional[int] = None,
                 frequency_type: Optional[str] = None,
                 retention_unit: Optional[str] = None,
                 retention_value: Optional[int] = None):
        if frequency_interval is not None:
            pulumi.set(__self__, "frequency_interval", frequency_interval)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if retention_unit is not None:
            pulumi.set(__self__, "retention_unit", retention_unit)
        if retention_value is not None:
            pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> Optional[int]:
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> Optional[str]:
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> Optional[int]:
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class CustomDbRoleAction(dict):
    def __init__(__self__, *,
                 action: str,
                 resources: Sequence['outputs.CustomDbRoleActionResource']):
        """
        :param str action: Name of the privilege action. For a complete list of actions available in the Atlas API, see [Custom Role Actions](https://docs.atlas.mongodb.com/reference/api/custom-role-actions)
               > **Note**: The privilege actions available to the Custom Roles API resource represent a subset of the privilege actions available in the Atlas Custom Roles UI.
        :param Sequence['CustomDbRoleActionResourceArgs'] resources: Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Name of the privilege action. For a complete list of actions available in the Atlas API, see [Custom Role Actions](https://docs.atlas.mongodb.com/reference/api/custom-role-actions)
        > **Note**: The privilege actions available to the Custom Roles API resource represent a subset of the privilege actions available in the Atlas Custom Roles UI.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.CustomDbRoleActionResource']:
        """
        Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class CustomDbRoleActionResource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collectionName":
            suggest = "collection_name"
        elif key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomDbRoleActionResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomDbRoleActionResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomDbRoleActionResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster: Optional[bool] = None,
                 collection_name: Optional[str] = None,
                 database_name: Optional[str] = None):
        """
        :param str database_name: Database on which the inherited role is granted.
        """
        if cluster is not None:
            pulumi.set(__self__, "cluster", cluster)
        if collection_name is not None:
            pulumi.set(__self__, "collection_name", collection_name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)

    @property
    @pulumi.getter
    def cluster(self) -> Optional[bool]:
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[str]:
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        Database on which the inherited role is granted.
        """
        return pulumi.get(self, "database_name")


@pulumi.output_type
class CustomDbRoleInheritedRole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "roleName":
            suggest = "role_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomDbRoleInheritedRole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomDbRoleInheritedRole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomDbRoleInheritedRole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 role_name: str):
        """
        :param str database_name: Database on which the inherited role is granted.
        :param str role_name: Name of the inherited role. This can either be another custom role or a built-in role.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Database on which the inherited role is granted.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        """
        Name of the inherited role. This can either be another custom role or a built-in role.
        """
        return pulumi.get(self, "role_name")


@pulumi.output_type
class DataLakeAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleId":
            suggest = "role_id"
        elif key == "testS3Bucket":
            suggest = "test_s3_bucket"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "iamAssumedRoleArn":
            suggest = "iam_assumed_role_arn"
        elif key == "iamUserArn":
            suggest = "iam_user_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakeAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakeAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakeAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_id: str,
                 test_s3_bucket: str,
                 external_id: Optional[str] = None,
                 iam_assumed_role_arn: Optional[str] = None,
                 iam_user_arn: Optional[str] = None):
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "test_s3_bucket", test_s3_bucket)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if iam_assumed_role_arn is not None:
            pulumi.set(__self__, "iam_assumed_role_arn", iam_assumed_role_arn)
        if iam_user_arn is not None:
            pulumi.set(__self__, "iam_user_arn", iam_user_arn)

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> str:
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="testS3Bucket")
    def test_s3_bucket(self) -> str:
        return pulumi.get(self, "test_s3_bucket")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="iamAssumedRoleArn")
    def iam_assumed_role_arn(self) -> Optional[str]:
        return pulumi.get(self, "iam_assumed_role_arn")

    @property
    @pulumi.getter(name="iamUserArn")
    def iam_user_arn(self) -> Optional[str]:
        return pulumi.get(self, "iam_user_arn")


@pulumi.output_type
class DataLakeDataProcessRegion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudProvider":
            suggest = "cloud_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakeDataProcessRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakeDataProcessRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakeDataProcessRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_provider: str,
                 region: str):
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class DataLakeStorageDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxWildcardCollections":
            suggest = "max_wildcard_collections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakeStorageDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakeStorageDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakeStorageDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collections: Optional[Sequence['outputs.DataLakeStorageDatabaseCollection']] = None,
                 max_wildcard_collections: Optional[int] = None,
                 name: Optional[str] = None,
                 views: Optional[Sequence['outputs.DataLakeStorageDatabaseView']] = None):
        """
        :param str name: Name of the Atlas Data Lake.
        """
        if collections is not None:
            pulumi.set(__self__, "collections", collections)
        if max_wildcard_collections is not None:
            pulumi.set(__self__, "max_wildcard_collections", max_wildcard_collections)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if views is not None:
            pulumi.set(__self__, "views", views)

    @property
    @pulumi.getter
    def collections(self) -> Optional[Sequence['outputs.DataLakeStorageDatabaseCollection']]:
        return pulumi.get(self, "collections")

    @property
    @pulumi.getter(name="maxWildcardCollections")
    def max_wildcard_collections(self) -> Optional[int]:
        return pulumi.get(self, "max_wildcard_collections")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Atlas Data Lake.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def views(self) -> Optional[Sequence['outputs.DataLakeStorageDatabaseView']]:
        return pulumi.get(self, "views")


@pulumi.output_type
class DataLakeStorageDatabaseCollection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSources":
            suggest = "data_sources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakeStorageDatabaseCollection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakeStorageDatabaseCollection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakeStorageDatabaseCollection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_sources: Optional[Sequence['outputs.DataLakeStorageDatabaseCollectionDataSource']] = None,
                 name: Optional[str] = None):
        """
        :param str name: Name of the Atlas Data Lake.
        """
        if data_sources is not None:
            pulumi.set(__self__, "data_sources", data_sources)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Optional[Sequence['outputs.DataLakeStorageDatabaseCollectionDataSource']]:
        return pulumi.get(self, "data_sources")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Atlas Data Lake.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DataLakeStorageDatabaseCollectionDataSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultFormat":
            suggest = "default_format"
        elif key == "storeName":
            suggest = "store_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakeStorageDatabaseCollectionDataSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakeStorageDatabaseCollectionDataSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakeStorageDatabaseCollectionDataSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_format: Optional[str] = None,
                 path: Optional[str] = None,
                 store_name: Optional[str] = None):
        if default_format is not None:
            pulumi.set(__self__, "default_format", default_format)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if store_name is not None:
            pulumi.set(__self__, "store_name", store_name)

    @property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> Optional[str]:
        return pulumi.get(self, "default_format")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="storeName")
    def store_name(self) -> Optional[str]:
        return pulumi.get(self, "store_name")


@pulumi.output_type
class DataLakeStorageDatabaseView(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 pipeline: Optional[str] = None,
                 source: Optional[str] = None):
        """
        :param str name: Name of the Atlas Data Lake.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if pipeline is not None:
            pulumi.set(__self__, "pipeline", pipeline)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Atlas Data Lake.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def pipeline(self) -> Optional[str]:
        return pulumi.get(self, "pipeline")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")


@pulumi.output_type
class DataLakeStorageStore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalStorageClasses":
            suggest = "additional_storage_classes"
        elif key == "includeTags":
            suggest = "include_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakeStorageStore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakeStorageStore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakeStorageStore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_storage_classes: Optional[Sequence[str]] = None,
                 bucket: Optional[str] = None,
                 delimiter: Optional[str] = None,
                 include_tags: Optional[bool] = None,
                 name: Optional[str] = None,
                 prefix: Optional[str] = None,
                 provider: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str name: Name of the Atlas Data Lake.
        """
        if additional_storage_classes is not None:
            pulumi.set(__self__, "additional_storage_classes", additional_storage_classes)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if include_tags is not None:
            pulumi.set(__self__, "include_tags", include_tags)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="additionalStorageClasses")
    def additional_storage_classes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "additional_storage_classes")

    @property
    @pulumi.getter
    def bucket(self) -> Optional[str]:
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[str]:
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="includeTags")
    def include_tags(self) -> Optional[bool]:
        return pulumi.get(self, "include_tags")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Atlas Data Lake.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class DatabaseUserLabel(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DatabaseUserRole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collectionName":
            suggest = "collection_name"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "roleName":
            suggest = "role_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseUserRole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseUserRole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseUserRole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collection_name: Optional[str] = None,
                 database_name: Optional[str] = None,
                 role_name: Optional[str] = None):
        """
        :param str collection_name: Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        :param str database_name: Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.
        :param str role_name: Name of the role to grant. See [Create a Database User](https://docs.atlas.mongodb.com/reference/api/database-users-create-a-user/) `roles.roleName` for valid values and restrictions.
        """
        if collection_name is not None:
            pulumi.set(__self__, "collection_name", collection_name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if role_name is not None:
            pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[str]:
        """
        Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        """
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> Optional[str]:
        """
        Name of the role to grant. See [Create a Database User](https://docs.atlas.mongodb.com/reference/api/database-users-create-a-user/) `roles.roleName` for valid values and restrictions.
        """
        return pulumi.get(self, "role_name")


@pulumi.output_type
class DatabaseUserScope(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: Name of the cluster or Atlas Data Lake that the user has access to.
        :param str type: Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the cluster or Atlas Data Lake that the user has access to.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class EncryptionAtRestAwsKmsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKeyId":
            suggest = "access_key_id"
        elif key == "customerMasterKeyId":
            suggest = "customer_master_key_id"
        elif key == "roleId":
            suggest = "role_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionAtRestAwsKmsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionAtRestAwsKmsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionAtRestAwsKmsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key_id: Optional[str] = None,
                 customer_master_key_id: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 region: Optional[str] = None,
                 role_id: Optional[str] = None,
                 secret_access_key: Optional[str] = None):
        """
        :param str customer_master_key_id: The AWS customer master key used to encrypt and decrypt the MongoDB master keys.
        :param bool enabled: Specifies whether Encryption at Rest is enabled for an Atlas project. To disable Encryption at Rest, pass only this parameter with a value of false. When you disable Encryption at Rest, Atlas also removes the configuration details.
        :param str region: The AWS region in which the AWS customer master key exists: CA_CENTRAL_1, US_EAST_1, US_EAST_2, US_WEST_1, US_WEST_2, SA_EAST_1
        :param str role_id: ID of an AWS IAM role authorized to manage an AWS customer master key. To find the ID for an existing IAM role check the `role_id` attribute of the `CloudProviderAccess` resource.
        """
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if customer_master_key_id is not None:
            pulumi.set(__self__, "customer_master_key_id", customer_master_key_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_id is not None:
            pulumi.set(__self__, "role_id", role_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[str]:
        return pulumi.get(self, "access_key_id")

    @property
    @pulumi.getter(name="customerMasterKeyId")
    def customer_master_key_id(self) -> Optional[str]:
        """
        The AWS customer master key used to encrypt and decrypt the MongoDB master keys.
        """
        return pulumi.get(self, "customer_master_key_id")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Specifies whether Encryption at Rest is enabled for an Atlas project. To disable Encryption at Rest, pass only this parameter with a value of false. When you disable Encryption at Rest, Atlas also removes the configuration details.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The AWS region in which the AWS customer master key exists: CA_CENTRAL_1, US_EAST_1, US_EAST_2, US_WEST_1, US_WEST_2, SA_EAST_1
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[str]:
        """
        ID of an AWS IAM role authorized to manage an AWS customer master key. To find the ID for an existing IAM role check the `role_id` attribute of the `CloudProviderAccess` resource.
        """
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[str]:
        return pulumi.get(self, "secret_access_key")


@pulumi.output_type
class EncryptionAtRestAzureKeyVaultConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureEnvironment":
            suggest = "azure_environment"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "keyIdentifier":
            suggest = "key_identifier"
        elif key == "keyVaultName":
            suggest = "key_vault_name"
        elif key == "resourceGroupName":
            suggest = "resource_group_name"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionAtRestAzureKeyVaultConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionAtRestAzureKeyVaultConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionAtRestAzureKeyVaultConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 azure_environment: Optional[str] = None,
                 client_id: Optional[str] = None,
                 key_identifier: Optional[str] = None,
                 key_vault_name: Optional[str] = None,
                 resource_group_name: Optional[str] = None,
                 secret: Optional[str] = None,
                 subscription_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param bool enabled: Specifies whether Encryption at Rest is enabled for an Atlas project. To disable Encryption at Rest, pass only this parameter with a value of false. When you disable Encryption at Rest, Atlas also removes the configuration details.
        :param str azure_environment: The Azure environment where the Azure account credentials reside. Valid values are the following: AZURE, AZURE_CHINA, AZURE_GERMANY
        :param str client_id: The client ID, also known as the application ID, for an Azure application associated with the Azure AD tenant.
        :param str key_identifier: The unique identifier of a key in an Azure Key Vault.
        :param str key_vault_name: The name of an Azure Key Vault containing your key.
        :param str resource_group_name: The name of the Azure Resource group that contains an Azure Key Vault.
        :param str secret: The secret associated with the Azure Key Vault specified by azureKeyVault.tenantID.
        :param str subscription_id: The unique identifier associated with an Azure subscription.
        :param str tenant_id: The unique identifier for an Azure AD tenant within an Azure subscription.
        """
        pulumi.set(__self__, "enabled", enabled)
        if azure_environment is not None:
            pulumi.set(__self__, "azure_environment", azure_environment)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if key_identifier is not None:
            pulumi.set(__self__, "key_identifier", key_identifier)
        if key_vault_name is not None:
            pulumi.set(__self__, "key_vault_name", key_vault_name)
        if resource_group_name is not None:
            pulumi.set(__self__, "resource_group_name", resource_group_name)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Specifies whether Encryption at Rest is enabled for an Atlas project. To disable Encryption at Rest, pass only this parameter with a value of false. When you disable Encryption at Rest, Atlas also removes the configuration details.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="azureEnvironment")
    def azure_environment(self) -> Optional[str]:
        """
        The Azure environment where the Azure account credentials reside. Valid values are the following: AZURE, AZURE_CHINA, AZURE_GERMANY
        """
        return pulumi.get(self, "azure_environment")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The client ID, also known as the application ID, for an Azure application associated with the Azure AD tenant.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="keyIdentifier")
    def key_identifier(self) -> Optional[str]:
        """
        The unique identifier of a key in an Azure Key Vault.
        """
        return pulumi.get(self, "key_identifier")

    @property
    @pulumi.getter(name="keyVaultName")
    def key_vault_name(self) -> Optional[str]:
        """
        The name of an Azure Key Vault containing your key.
        """
        return pulumi.get(self, "key_vault_name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[str]:
        """
        The name of the Azure Resource group that contains an Azure Key Vault.
        """
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        The secret associated with the Azure Key Vault specified by azureKeyVault.tenantID.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[str]:
        """
        The unique identifier associated with an Azure subscription.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The unique identifier for an Azure AD tenant within an Azure subscription.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class EncryptionAtRestGoogleCloudKmsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVersionResourceId":
            suggest = "key_version_resource_id"
        elif key == "serviceAccountKey":
            suggest = "service_account_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionAtRestGoogleCloudKmsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionAtRestGoogleCloudKmsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionAtRestGoogleCloudKmsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 key_version_resource_id: Optional[str] = None,
                 service_account_key: Optional[str] = None):
        """
        :param bool enabled: Specifies whether Encryption at Rest is enabled for an Atlas project. To disable Encryption at Rest, pass only this parameter with a value of false. When you disable Encryption at Rest, Atlas also removes the configuration details.
        :param str key_version_resource_id: The Key Version Resource ID from your GCP account.
        :param str service_account_key: String-formatted JSON object containing GCP KMS credentials from your GCP account.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if key_version_resource_id is not None:
            pulumi.set(__self__, "key_version_resource_id", key_version_resource_id)
        if service_account_key is not None:
            pulumi.set(__self__, "service_account_key", service_account_key)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Specifies whether Encryption at Rest is enabled for an Atlas project. To disable Encryption at Rest, pass only this parameter with a value of false. When you disable Encryption at Rest, Atlas also removes the configuration details.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="keyVersionResourceId")
    def key_version_resource_id(self) -> Optional[str]:
        """
        The Key Version Resource ID from your GCP account.
        """
        return pulumi.get(self, "key_version_resource_id")

    @property
    @pulumi.getter(name="serviceAccountKey")
    def service_account_key(self) -> Optional[str]:
        """
        String-formatted JSON object containing GCP KMS credentials from your GCP account.
        """
        return pulumi.get(self, "service_account_key")


@pulumi.output_type
class EventTriggerEventProcessors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsEventbridge":
            suggest = "aws_eventbridge"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventTriggerEventProcessors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventTriggerEventProcessors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventTriggerEventProcessors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_eventbridge: Optional['outputs.EventTriggerEventProcessorsAwsEventbridge'] = None):
        if aws_eventbridge is not None:
            pulumi.set(__self__, "aws_eventbridge", aws_eventbridge)

    @property
    @pulumi.getter(name="awsEventbridge")
    def aws_eventbridge(self) -> Optional['outputs.EventTriggerEventProcessorsAwsEventbridge']:
        return pulumi.get(self, "aws_eventbridge")


@pulumi.output_type
class EventTriggerEventProcessorsAwsEventbridge(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configAccountId":
            suggest = "config_account_id"
        elif key == "configRegion":
            suggest = "config_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventTriggerEventProcessorsAwsEventbridge. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventTriggerEventProcessorsAwsEventbridge.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventTriggerEventProcessorsAwsEventbridge.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_account_id: Optional[str] = None,
                 config_region: Optional[str] = None):
        if config_account_id is not None:
            pulumi.set(__self__, "config_account_id", config_account_id)
        if config_region is not None:
            pulumi.set(__self__, "config_region", config_region)

    @property
    @pulumi.getter(name="configAccountId")
    def config_account_id(self) -> Optional[str]:
        return pulumi.get(self, "config_account_id")

    @property
    @pulumi.getter(name="configRegion")
    def config_region(self) -> Optional[str]:
        return pulumi.get(self, "config_region")


@pulumi.output_type
class FederatedSettingsOrgRoleMappingRoleAssignment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupId":
            suggest = "group_id"
        elif key == "orgId":
            suggest = "org_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedSettingsOrgRoleMappingRoleAssignment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedSettingsOrgRoleMappingRoleAssignment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedSettingsOrgRoleMappingRoleAssignment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_id: Optional[str] = None,
                 org_id: Optional[str] = None,
                 roles: Optional[Sequence[str]] = None):
        """
        :param str group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param Sequence[str] roles: Specifies the Roles that are attached to the Role Mapping.
        """
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[str]:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        """
        Specifies the Roles that are attached to the Role Mapping.
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class GlobalClusterConfigCustomZoneMapping(dict):
    def __init__(__self__, *,
                 location: Optional[str] = None,
                 zone: Optional[str] = None):
        """
        :param str location: The ISO location code to which you want to map a zone in your Global Cluster. You can find a list of all supported location codes [here](https://cloud.mongodb.com/static/atlas/country_iso_codes.txt).
        :param str zone: The name of the zone in your Global Cluster that you want to map to location.
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        The ISO location code to which you want to map a zone in your Global Cluster. You can find a list of all supported location codes [here](https://cloud.mongodb.com/static/atlas/country_iso_codes.txt).
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        """
        The name of the zone in your Global Cluster that you want to map to location.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GlobalClusterConfigManagedNamespace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customShardKey":
            suggest = "custom_shard_key"
        elif key == "isCustomShardKeyHashed":
            suggest = "is_custom_shard_key_hashed"
        elif key == "isShardKeyUnique":
            suggest = "is_shard_key_unique"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalClusterConfigManagedNamespace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalClusterConfigManagedNamespace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalClusterConfigManagedNamespace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collection: str,
                 custom_shard_key: str,
                 db: str,
                 is_custom_shard_key_hashed: Optional[bool] = None,
                 is_shard_key_unique: Optional[bool] = None):
        """
        :param str collection: The name of the collection associated with the managed namespace.
        :param str custom_shard_key: The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        :param str db: The name of the database containing the collection.
        :param bool is_custom_shard_key_hashed: Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.
        :param bool is_shard_key_unique: Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).
        """
        pulumi.set(__self__, "collection", collection)
        pulumi.set(__self__, "custom_shard_key", custom_shard_key)
        pulumi.set(__self__, "db", db)
        if is_custom_shard_key_hashed is not None:
            pulumi.set(__self__, "is_custom_shard_key_hashed", is_custom_shard_key_hashed)
        if is_shard_key_unique is not None:
            pulumi.set(__self__, "is_shard_key_unique", is_shard_key_unique)

    @property
    @pulumi.getter
    def collection(self) -> str:
        """
        The name of the collection associated with the managed namespace.
        """
        return pulumi.get(self, "collection")

    @property
    @pulumi.getter(name="customShardKey")
    def custom_shard_key(self) -> str:
        """
        The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        """
        return pulumi.get(self, "custom_shard_key")

    @property
    @pulumi.getter
    def db(self) -> str:
        """
        The name of the database containing the collection.
        """
        return pulumi.get(self, "db")

    @property
    @pulumi.getter(name="isCustomShardKeyHashed")
    def is_custom_shard_key_hashed(self) -> Optional[bool]:
        """
        Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.
        """
        return pulumi.get(self, "is_custom_shard_key_hashed")

    @property
    @pulumi.getter(name="isShardKeyUnique")
    def is_shard_key_unique(self) -> Optional[bool]:
        """
        Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).
        """
        return pulumi.get(self, "is_shard_key_unique")


@pulumi.output_type
class LdapConfigurationUserToDnMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ldapQuery":
            suggest = "ldap_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LdapConfigurationUserToDnMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LdapConfigurationUserToDnMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LdapConfigurationUserToDnMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ldap_query: Optional[str] = None,
                 match: Optional[str] = None,
                 substitution: Optional[str] = None):
        if ldap_query is not None:
            pulumi.set(__self__, "ldap_query", ldap_query)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if substitution is not None:
            pulumi.set(__self__, "substitution", substitution)

    @property
    @pulumi.getter(name="ldapQuery")
    def ldap_query(self) -> Optional[str]:
        return pulumi.get(self, "ldap_query")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def substitution(self) -> Optional[str]:
        return pulumi.get(self, "substitution")


@pulumi.output_type
class LdapVerifyLink(dict):
    def __init__(__self__, *,
                 href: Optional[str] = None,
                 rel: Optional[str] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[str]:
        return pulumi.get(self, "href")

    @property
    @pulumi.getter
    def rel(self) -> Optional[str]:
        return pulumi.get(self, "rel")


@pulumi.output_type
class LdapVerifyValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "validationType":
            suggest = "validation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LdapVerifyValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LdapVerifyValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LdapVerifyValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status: Optional[str] = None,
                 validation_type: Optional[str] = None):
        """
        :param str status: The current status of the LDAP over TLS/SSL configuration. One of the following values: `PENDING`, `SUCCESS`, and `FAILED`.
        """
        if status is not None:
            pulumi.set(__self__, "status", status)
        if validation_type is not None:
            pulumi.set(__self__, "validation_type", validation_type)

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The current status of the LDAP over TLS/SSL configuration. One of the following values: `PENDING`, `SUCCESS`, and `FAILED`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="validationType")
    def validation_type(self) -> Optional[str]:
        return pulumi.get(self, "validation_type")


@pulumi.output_type
class OnlineArchiveCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateField":
            suggest = "date_field"
        elif key == "dateFormat":
            suggest = "date_format"
        elif key == "expireAfterDays":
            suggest = "expire_after_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineArchiveCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineArchiveCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineArchiveCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 date_field: Optional[str] = None,
                 date_format: Optional[str] = None,
                 expire_after_days: Optional[int] = None,
                 query: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if date_field is not None:
            pulumi.set(__self__, "date_field", date_field)
        if date_format is not None:
            pulumi.set(__self__, "date_format", date_format)
        if expire_after_days is not None:
            pulumi.set(__self__, "expire_after_days", expire_after_days)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="dateField")
    def date_field(self) -> Optional[str]:
        return pulumi.get(self, "date_field")

    @property
    @pulumi.getter(name="dateFormat")
    def date_format(self) -> Optional[str]:
        return pulumi.get(self, "date_format")

    @property
    @pulumi.getter(name="expireAfterDays")
    def expire_after_days(self) -> Optional[int]:
        return pulumi.get(self, "expire_after_days")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        return pulumi.get(self, "query")


@pulumi.output_type
class OnlineArchivePartitionField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "fieldType":
            suggest = "field_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineArchivePartitionField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineArchivePartitionField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineArchivePartitionField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: str,
                 order: int,
                 field_type: Optional[str] = None):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "order", order)
        if field_type is not None:
            pulumi.set(__self__, "field_type", field_type)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def order(self) -> int:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> Optional[str]:
        return pulumi.get(self, "field_type")


@pulumi.output_type
class PrivateLinkEndpointServiceEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointName":
            suggest = "endpoint_name"
        elif key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceAttachmentName":
            suggest = "service_attachment_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkEndpointServiceEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkEndpointServiceEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkEndpointServiceEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_name: Optional[str] = None,
                 ip_address: Optional[str] = None,
                 service_attachment_name: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str endpoint_name: Forwarding rule that corresponds to the endpoint you created in GCP.
        :param str ip_address: Private IP address of the endpoint you created in GCP.
        :param str service_attachment_name: Unique alphanumeric and special character strings that identify the service attachment associated with the endpoint.
        :param str status: Status of the endpoint. Atlas returns one of the [values shown above](https://docs.atlas.mongodb.com/reference/api/private-endpoints-endpoint-create-one/#std-label-ref-status-field).
        """
        if endpoint_name is not None:
            pulumi.set(__self__, "endpoint_name", endpoint_name)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if service_attachment_name is not None:
            pulumi.set(__self__, "service_attachment_name", service_attachment_name)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="endpointName")
    def endpoint_name(self) -> Optional[str]:
        """
        Forwarding rule that corresponds to the endpoint you created in GCP.
        """
        return pulumi.get(self, "endpoint_name")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        Private IP address of the endpoint you created in GCP.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="serviceAttachmentName")
    def service_attachment_name(self) -> Optional[str]:
        """
        Unique alphanumeric and special character strings that identify the service attachment associated with the endpoint.
        """
        return pulumi.get(self, "service_attachment_name")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of the endpoint. Atlas returns one of the [values shown above](https://docs.atlas.mongodb.com/reference/api/private-endpoints-endpoint-create-one/#std-label-ref-status-field).
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ProjectApiKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKeyId":
            suggest = "api_key_id"
        elif key == "roleNames":
            suggest = "role_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectApiKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectApiKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectApiKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key_id: str,
                 role_names: Sequence[str]):
        """
        :param str api_key_id: The unique identifier of the Programmatic API key you want to associate with the Project.  The Programmatic API key and Project must share the same parent organization.  Note: this is not the `publicKey` of the Programmatic API key but the `id` of the key. See [Programmatic API Keys](https://docs.atlas.mongodb.com/reference/api/apiKeys/) for more.
        :param Sequence[str] role_names: List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project.  You must specify an array even if you are only associating a single role with the Programmatic API key.
               The following are valid roles:
               * `GROUP_OWNER`
               * `GROUP_READ_ONLY`
               * `GROUP_DATA_ACCESS_ADMIN`
               * `GROUP_DATA_ACCESS_READ_WRITE`
               * `GROUP_DATA_ACCESS_READ_ONLY`
        """
        pulumi.set(__self__, "api_key_id", api_key_id)
        pulumi.set(__self__, "role_names", role_names)

    @property
    @pulumi.getter(name="apiKeyId")
    def api_key_id(self) -> str:
        """
        The unique identifier of the Programmatic API key you want to associate with the Project.  The Programmatic API key and Project must share the same parent organization.  Note: this is not the `publicKey` of the Programmatic API key but the `id` of the key. See [Programmatic API Keys](https://docs.atlas.mongodb.com/reference/api/apiKeys/) for more.
        """
        return pulumi.get(self, "api_key_id")

    @property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[str]:
        """
        List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project.  You must specify an array even if you are only associating a single role with the Programmatic API key.
        The following are valid roles:
        * `GROUP_OWNER`
        * `GROUP_READ_ONLY`
        * `GROUP_DATA_ACCESS_ADMIN`
        * `GROUP_DATA_ACCESS_READ_WRITE`
        * `GROUP_DATA_ACCESS_READ_ONLY`
        """
        return pulumi.get(self, "role_names")


@pulumi.output_type
class ProjectTeam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleNames":
            suggest = "role_names"
        elif key == "teamId":
            suggest = "team_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectTeam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectTeam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectTeam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_names: Sequence[str],
                 team_id: str):
        """
        :param Sequence[str] role_names: List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project.  You must specify an array even if you are only associating a single role with the Programmatic API key.
               The following are valid roles:
               * `GROUP_OWNER`
               * `GROUP_READ_ONLY`
               * `GROUP_DATA_ACCESS_ADMIN`
               * `GROUP_DATA_ACCESS_READ_WRITE`
               * `GROUP_DATA_ACCESS_READ_ONLY`
        :param str team_id: The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
        """
        pulumi.set(__self__, "role_names", role_names)
        pulumi.set(__self__, "team_id", team_id)

    @property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[str]:
        """
        List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project.  You must specify an array even if you are only associating a single role with the Programmatic API key.
        The following are valid roles:
        * `GROUP_OWNER`
        * `GROUP_READ_ONLY`
        * `GROUP_DATA_ACCESS_ADMIN`
        * `GROUP_DATA_ACCESS_READ_WRITE`
        * `GROUP_DATA_ACCESS_READ_ONLY`
        """
        return pulumi.get(self, "role_names")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> str:
        """
        The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
        """
        return pulumi.get(self, "team_id")


@pulumi.output_type
class SearchIndexSynonym(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceCollection":
            suggest = "source_collection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SearchIndexSynonym. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SearchIndexSynonym.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SearchIndexSynonym.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 analyzer: str,
                 name: str,
                 source_collection: str):
        """
        :param str analyzer: Name of the [analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use with this synonym mapping. Atlas Search doesn't support these [custom analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-custom-analyzers) tokenizers and token filters in [analyzers used in synonym mappings](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#options):
               * [nGram](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-ngram-tokenizer-ref) Tokenizer
               * [edgeGram](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-edgegram-tokenizer-ref) Tokenizers
               * [daitchMokotoffSoundex](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-daitchmokotoffsoundex-tf-ref) token filter
               * [nGram](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-ngram-tf-ref) token filter
               * [edgeGram](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-edgegram-tf-ref) token filter
               * [shingle](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-shingle-tf-ref) token filter
        :param str name: Name of the [synonym mapping definition](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-ref). Name must be unique in this index definition and it can't be an empty string.
        :param str source_collection: Name of the source MongoDB collection for the synonyms. Documents in this collection must be in the format described in the [Synonyms Source Collection Documents](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-coll-spec).
        """
        pulumi.set(__self__, "analyzer", analyzer)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source_collection", source_collection)

    @property
    @pulumi.getter
    def analyzer(self) -> str:
        """
        Name of the [analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use with this synonym mapping. Atlas Search doesn't support these [custom analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-custom-analyzers) tokenizers and token filters in [analyzers used in synonym mappings](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#options):
        * [nGram](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-ngram-tokenizer-ref) Tokenizer
        * [edgeGram](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-edgegram-tokenizer-ref) Tokenizers
        * [daitchMokotoffSoundex](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-daitchmokotoffsoundex-tf-ref) token filter
        * [nGram](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-ngram-tf-ref) token filter
        * [edgeGram](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-edgegram-tf-ref) token filter
        * [shingle](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-shingle-tf-ref) token filter
        """
        return pulumi.get(self, "analyzer")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the [synonym mapping definition](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-ref). Name must be unique in this index definition and it can't be an empty string.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sourceCollection")
    def source_collection(self) -> str:
        """
        Name of the source MongoDB collection for the synonyms. Documents in this collection must be in the format described in the [Synonyms Source Collection Documents](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-coll-spec).
        """
        return pulumi.get(self, "source_collection")


@pulumi.output_type
class ServerlessInstanceLink(dict):
    def __init__(__self__, *,
                 href: Optional[str] = None,
                 rel: Optional[str] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[str]:
        return pulumi.get(self, "href")

    @property
    @pulumi.getter
    def rel(self) -> Optional[str]:
        return pulumi.get(self, "rel")


@pulumi.output_type
class X509AuthenticationDatabaseUserCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "notAfter":
            suggest = "not_after"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in X509AuthenticationDatabaseUserCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        X509AuthenticationDatabaseUserCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        X509AuthenticationDatabaseUserCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 group_id: Optional[str] = None,
                 not_after: Optional[str] = None,
                 subject: Optional[str] = None):
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if not_after is not None:
            pulumi.set(__self__, "not_after", not_after)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> Optional[str]:
        return pulumi.get(self, "not_after")

    @property
    @pulumi.getter
    def subject(self) -> Optional[str]:
        return pulumi.get(self, "subject")


@pulumi.output_type
class Get509AuthenticationDatabaseUserCertificateResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 group_id: str,
                 id: int,
                 not_after: str,
                 subject: str):
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "not_after", not_after)
        pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> str:
        return pulumi.get(self, "not_after")

    @property
    @pulumi.getter
    def subject(self) -> str:
        return pulumi.get(self, "subject")


@pulumi.output_type
class GetAdvancedClusterAdvancedConfigurationResult(dict):
    def __init__(__self__, *,
                 default_read_concern: str,
                 default_write_concern: str,
                 fail_index_key_too_long: bool,
                 javascript_enabled: bool,
                 minimum_enabled_tls_protocol: str,
                 no_table_scan: bool,
                 oplog_size_mb: int,
                 sample_refresh_interval_bi_connector: int,
                 sample_size_bi_connector: int):
        """
        :param str default_read_concern: [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        :param str default_write_concern: [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        :param bool fail_index_key_too_long: When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        :param bool javascript_enabled: When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        :param str minimum_enabled_tls_protocol: Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        :param bool no_table_scan: When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        :param int oplog_size_mb: The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        :param int sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param int sample_size_bi_connector: Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        pulumi.set(__self__, "default_read_concern", default_read_concern)
        pulumi.set(__self__, "default_write_concern", default_write_concern)
        pulumi.set(__self__, "fail_index_key_too_long", fail_index_key_too_long)
        pulumi.set(__self__, "javascript_enabled", javascript_enabled)
        pulumi.set(__self__, "minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        pulumi.set(__self__, "no_table_scan", no_table_scan)
        pulumi.set(__self__, "oplog_size_mb", oplog_size_mb)
        pulumi.set(__self__, "sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        pulumi.set(__self__, "sample_size_bi_connector", sample_size_bi_connector)

    @property
    @pulumi.getter(name="defaultReadConcern")
    def default_read_concern(self) -> str:
        """
        [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        """
        return pulumi.get(self, "default_read_concern")

    @property
    @pulumi.getter(name="defaultWriteConcern")
    def default_write_concern(self) -> str:
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        return pulumi.get(self, "default_write_concern")

    @property
    @pulumi.getter(name="failIndexKeyTooLong")
    def fail_index_key_too_long(self) -> bool:
        """
        When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        """
        return pulumi.get(self, "fail_index_key_too_long")

    @property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> bool:
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        return pulumi.get(self, "javascript_enabled")

    @property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> str:
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> bool:
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        return pulumi.get(self, "no_table_scan")

    @property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> int:
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        return pulumi.get(self, "oplog_size_mb")

    @property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> int:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> int:
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_size_bi_connector")


@pulumi.output_type
class GetAdvancedClusterBiConnectorResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 read_preference: str):
        """
        :param bool enabled: Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
        :param str read_preference: Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "read_preference", read_preference)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> str:
        """
        Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        return pulumi.get(self, "read_preference")


@pulumi.output_type
class GetAdvancedClusterConnectionStringResult(dict):
    def __init__(__self__, *,
                 aws_private_link: Mapping[str, Any],
                 aws_private_link_srv: Mapping[str, Any],
                 private: str,
                 private_endpoints: Sequence['outputs.GetAdvancedClusterConnectionStringPrivateEndpointResult'],
                 private_srv: str,
                 standard: str,
                 standard_srv: str):
        pulumi.set(__self__, "aws_private_link", aws_private_link)
        pulumi.set(__self__, "aws_private_link_srv", aws_private_link_srv)
        pulumi.set(__self__, "private", private)
        pulumi.set(__self__, "private_endpoints", private_endpoints)
        pulumi.set(__self__, "private_srv", private_srv)
        pulumi.set(__self__, "standard", standard)
        pulumi.set(__self__, "standard_srv", standard_srv)

    @property
    @pulumi.getter(name="awsPrivateLink")
    def aws_private_link(self) -> Mapping[str, Any]:
        return pulumi.get(self, "aws_private_link")

    @property
    @pulumi.getter(name="awsPrivateLinkSrv")
    def aws_private_link_srv(self) -> Mapping[str, Any]:
        return pulumi.get(self, "aws_private_link_srv")

    @property
    @pulumi.getter
    def private(self) -> str:
        return pulumi.get(self, "private")

    @property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Sequence['outputs.GetAdvancedClusterConnectionStringPrivateEndpointResult']:
        return pulumi.get(self, "private_endpoints")

    @property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> str:
        return pulumi.get(self, "private_srv")

    @property
    @pulumi.getter
    def standard(self) -> str:
        return pulumi.get(self, "standard")

    @property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> str:
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class GetAdvancedClusterConnectionStringPrivateEndpointResult(dict):
    def __init__(__self__, *,
                 connection_string: str,
                 endpoints: Sequence['outputs.GetAdvancedClusterConnectionStringPrivateEndpointEndpointResult'],
                 srv_connection_string: str,
                 type: str):
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "srv_connection_string", srv_connection_string)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> str:
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def endpoints(self) -> Sequence['outputs.GetAdvancedClusterConnectionStringPrivateEndpointEndpointResult']:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> str:
        return pulumi.get(self, "srv_connection_string")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAdvancedClusterConnectionStringPrivateEndpointEndpointResult(dict):
    def __init__(__self__, *,
                 endpoint_id: str,
                 provider_name: str,
                 region: str):
        """
        :param str provider_name: Cloud service provider on which the servers are provisioned.
        """
        pulumi.set(__self__, "endpoint_id", endpoint_id)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> str:
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetAdvancedClusterLabelResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecResult(dict):
    def __init__(__self__, *,
                 container_id: Mapping[str, str],
                 id: str,
                 num_shards: int,
                 region_configs: Sequence['outputs.GetAdvancedClusterReplicationSpecRegionConfigResult'],
                 zone_name: str):
        """
        :param Mapping[str, str] container_id: A key-value map of the Network Peering Container ID(s) for the configuration specified in `region_configs`. The Container ID is the id of the container either created programmatically by the user before any clusters existed in a project or when the first cluster in the region (AWS/Azure) or project (GCP) was created.  The syntax is `"providerName:regionName" = "containerId"`. Example `AWS:US_EAST_1" = "61e0797dde08fb498ca11a71`.
        :param int num_shards: Provide this value if you set a `cluster_type` of SHARDED or GEOSHARDED.
        :param Sequence['GetAdvancedClusterReplicationSpecRegionConfigArgs'] region_configs: Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below
        :param str zone_name: Name for the zone in a Global Cluster.
        """
        pulumi.set(__self__, "container_id", container_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "num_shards", num_shards)
        pulumi.set(__self__, "region_configs", region_configs)
        pulumi.set(__self__, "zone_name", zone_name)

    @property
    @pulumi.getter(name="containerId")
    def container_id(self) -> Mapping[str, str]:
        """
        A key-value map of the Network Peering Container ID(s) for the configuration specified in `region_configs`. The Container ID is the id of the container either created programmatically by the user before any clusters existed in a project or when the first cluster in the region (AWS/Azure) or project (GCP) was created.  The syntax is `"providerName:regionName" = "containerId"`. Example `AWS:US_EAST_1" = "61e0797dde08fb498ca11a71`.
        """
        return pulumi.get(self, "container_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> int:
        """
        Provide this value if you set a `cluster_type` of SHARDED or GEOSHARDED.
        """
        return pulumi.get(self, "num_shards")

    @property
    @pulumi.getter(name="regionConfigs")
    def region_configs(self) -> Sequence['outputs.GetAdvancedClusterReplicationSpecRegionConfigResult']:
        """
        Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below
        """
        return pulumi.get(self, "region_configs")

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> str:
        """
        Name for the zone in a Global Cluster.
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecRegionConfigResult(dict):
    def __init__(__self__, *,
                 auto_scalings: Sequence['outputs.GetAdvancedClusterReplicationSpecRegionConfigAutoScalingResult'],
                 backing_provider_name: str,
                 priority: int,
                 provider_name: str,
                 region_name: str,
                 analytics_specs: Optional['outputs.GetAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsResult'] = None,
                 electable_specs: Optional['outputs.GetAdvancedClusterReplicationSpecRegionConfigElectableSpecsResult'] = None,
                 read_only_specs: Optional['outputs.GetAdvancedClusterReplicationSpecRegionConfigReadOnlySpecsResult'] = None):
        """
        :param Sequence['GetAdvancedClusterReplicationSpecRegionConfigAutoScalingArgs'] auto_scalings: Configuration for the Collection of settings that configures auto-scaling information for the cluster. See below
        :param str backing_provider_name: Cloud service provider on which you provision the host for a multi-tenant cluster.
        :param int priority: Election priority of the region.
        :param str provider_name: Cloud service provider on which the servers are provisioned.
        :param str region_name: Physical location of your MongoDB cluster.
        :param 'GetAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgs' analytics_specs: Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. See below
        :param 'GetAdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs' electable_specs: Hardware specifications for electable nodes in the region.
        :param 'GetAdvancedClusterReplicationSpecRegionConfigReadOnlySpecsArgs' read_only_specs: Hardware specifications for read-only nodes in the region. See below
        """
        pulumi.set(__self__, "auto_scalings", auto_scalings)
        pulumi.set(__self__, "backing_provider_name", backing_provider_name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "region_name", region_name)
        if analytics_specs is not None:
            pulumi.set(__self__, "analytics_specs", analytics_specs)
        if electable_specs is not None:
            pulumi.set(__self__, "electable_specs", electable_specs)
        if read_only_specs is not None:
            pulumi.set(__self__, "read_only_specs", read_only_specs)

    @property
    @pulumi.getter(name="autoScalings")
    def auto_scalings(self) -> Sequence['outputs.GetAdvancedClusterReplicationSpecRegionConfigAutoScalingResult']:
        """
        Configuration for the Collection of settings that configures auto-scaling information for the cluster. See below
        """
        return pulumi.get(self, "auto_scalings")

    @property
    @pulumi.getter(name="backingProviderName")
    def backing_provider_name(self) -> str:
        """
        Cloud service provider on which you provision the host for a multi-tenant cluster.
        """
        return pulumi.get(self, "backing_provider_name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Election priority of the region.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        Physical location of your MongoDB cluster.
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter(name="analyticsSpecs")
    def analytics_specs(self) -> Optional['outputs.GetAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsResult']:
        """
        Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. See below
        """
        return pulumi.get(self, "analytics_specs")

    @property
    @pulumi.getter(name="electableSpecs")
    def electable_specs(self) -> Optional['outputs.GetAdvancedClusterReplicationSpecRegionConfigElectableSpecsResult']:
        """
        Hardware specifications for electable nodes in the region.
        """
        return pulumi.get(self, "electable_specs")

    @property
    @pulumi.getter(name="readOnlySpecs")
    def read_only_specs(self) -> Optional['outputs.GetAdvancedClusterReplicationSpecRegionConfigReadOnlySpecsResult']:
        """
        Hardware specifications for read-only nodes in the region. See below
        """
        return pulumi.get(self, "read_only_specs")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsResult(dict):
    def __init__(__self__, *,
                 instance_size: str,
                 disk_iops: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 node_count: Optional[int] = None):
        """
        :param str instance_size: Hardware specification for the instance sizes in this region.
        :param int disk_iops: Target throughput (IOPS) desired for AWS storage attached to your cluster.
        :param str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. 
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param int node_count: Number of read-only nodes for Atlas to deploy to the region.
        """
        pulumi.set(__self__, "instance_size", instance_size)
        if disk_iops is not None:
            pulumi.set(__self__, "disk_iops", disk_iops)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[int]:
        """
        Target throughput (IOPS) desired for AWS storage attached to your cluster.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. 
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of read-only nodes for Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecRegionConfigAutoScalingResult(dict):
    def __init__(__self__, *,
                 compute_enabled: bool,
                 compute_max_instance_size: str,
                 compute_min_instance_size: str,
                 compute_scale_down_enabled: bool,
                 disk_gb_enabled: bool):
        """
        :param bool compute_enabled: Flag that indicates whether instance size auto-scaling is enabled.
        :param str compute_max_instance_size: Maximum instance size to which your cluster can automatically scale (such as M40).
        :param str compute_min_instance_size: Minimum instance size to which your cluster can automatically scale (such as M10).
        :param bool compute_scale_down_enabled: Flag that indicates whether the instance size may scale down.
        :param bool disk_gb_enabled: Flag that indicates whether this cluster enables disk auto-scaling.
        """
        pulumi.set(__self__, "compute_enabled", compute_enabled)
        pulumi.set(__self__, "compute_max_instance_size", compute_max_instance_size)
        pulumi.set(__self__, "compute_min_instance_size", compute_min_instance_size)
        pulumi.set(__self__, "compute_scale_down_enabled", compute_scale_down_enabled)
        pulumi.set(__self__, "disk_gb_enabled", disk_gb_enabled)

    @property
    @pulumi.getter(name="computeEnabled")
    def compute_enabled(self) -> bool:
        """
        Flag that indicates whether instance size auto-scaling is enabled.
        """
        return pulumi.get(self, "compute_enabled")

    @property
    @pulumi.getter(name="computeMaxInstanceSize")
    def compute_max_instance_size(self) -> str:
        """
        Maximum instance size to which your cluster can automatically scale (such as M40).
        """
        return pulumi.get(self, "compute_max_instance_size")

    @property
    @pulumi.getter(name="computeMinInstanceSize")
    def compute_min_instance_size(self) -> str:
        """
        Minimum instance size to which your cluster can automatically scale (such as M10).
        """
        return pulumi.get(self, "compute_min_instance_size")

    @property
    @pulumi.getter(name="computeScaleDownEnabled")
    def compute_scale_down_enabled(self) -> bool:
        """
        Flag that indicates whether the instance size may scale down.
        """
        return pulumi.get(self, "compute_scale_down_enabled")

    @property
    @pulumi.getter(name="diskGbEnabled")
    def disk_gb_enabled(self) -> bool:
        """
        Flag that indicates whether this cluster enables disk auto-scaling.
        """
        return pulumi.get(self, "disk_gb_enabled")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecRegionConfigElectableSpecsResult(dict):
    def __init__(__self__, *,
                 instance_size: str,
                 disk_iops: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 node_count: Optional[int] = None):
        """
        :param str instance_size: Hardware specification for the instance sizes in this region.
        :param int disk_iops: Target throughput (IOPS) desired for AWS storage attached to your cluster.
        :param str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. 
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param int node_count: Number of read-only nodes for Atlas to deploy to the region.
        """
        pulumi.set(__self__, "instance_size", instance_size)
        if disk_iops is not None:
            pulumi.set(__self__, "disk_iops", disk_iops)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[int]:
        """
        Target throughput (IOPS) desired for AWS storage attached to your cluster.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. 
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of read-only nodes for Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecRegionConfigReadOnlySpecsResult(dict):
    def __init__(__self__, *,
                 instance_size: str,
                 disk_iops: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 node_count: Optional[int] = None):
        """
        :param str instance_size: Hardware specification for the instance sizes in this region.
        :param int disk_iops: Target throughput (IOPS) desired for AWS storage attached to your cluster.
        :param str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. 
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param int node_count: Number of read-only nodes for Atlas to deploy to the region.
        """
        pulumi.set(__self__, "instance_size", instance_size)
        if disk_iops is not None:
            pulumi.set(__self__, "disk_iops", disk_iops)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[int]:
        """
        Target throughput (IOPS) desired for AWS storage attached to your cluster.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. 
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of read-only nodes for Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAdvancedClustersResultResult(dict):
    def __init__(__self__, *,
                 advanced_configurations: Sequence['outputs.GetAdvancedClustersResultAdvancedConfigurationResult'],
                 backup_enabled: bool,
                 bi_connectors: Sequence['outputs.GetAdvancedClustersResultBiConnectorResult'],
                 cluster_type: str,
                 connection_strings: Sequence['outputs.GetAdvancedClustersResultConnectionStringResult'],
                 create_date: str,
                 disk_size_gb: float,
                 encryption_at_rest_provider: str,
                 labels: Sequence['outputs.GetAdvancedClustersResultLabelResult'],
                 mongo_db_major_version: str,
                 mongo_db_version: str,
                 name: str,
                 paused: bool,
                 pit_enabled: bool,
                 replication_specs: Sequence['outputs.GetAdvancedClustersResultReplicationSpecResult'],
                 root_cert_type: str,
                 state_name: str,
                 version_release_system: str):
        """
        :param Sequence['GetAdvancedClustersResultAdvancedConfigurationArgs'] advanced_configurations: Get the advanced configuration options. See Advanced Configuration below for more details.
        :param Sequence['GetAdvancedClustersResultBiConnectorArgs'] bi_connectors: Configuration settings applied to BI Connector for Atlas on this cluster. See below.
        :param str cluster_type: Type of the cluster that you want to create.
        :param Sequence['GetAdvancedClustersResultConnectionStringArgs'] connection_strings: Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.
        :param float disk_size_gb: Capacity, in gigabytes, of the host's root volume.
        :param str encryption_at_rest_provider: Possible values are AWS, GCP, AZURE or NONE.
        :param Sequence['GetAdvancedClustersResultLabelArgs'] labels: Configuration for the collection of key-value pairs that tag and categorize the cluster. See below.
        :param str mongo_db_major_version: Version of the cluster to deploy.
        :param str mongo_db_version: Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.
        :param bool paused: Flag that indicates whether the cluster is paused or not.
        :param bool pit_enabled: Flag that indicates if the cluster uses Continuous Cloud Backup.
        :param Sequence['GetAdvancedClustersResultReplicationSpecArgs'] replication_specs: Configuration for cluster regions and the hardware provisioned in them. See below
        :param str root_cert_type: Certificate Authority that MongoDB Atlas clusters use.
        :param str state_name: Current state of the cluster. The possible states are:
        :param str version_release_system: Release cadence that Atlas uses for this cluster.
        """
        pulumi.set(__self__, "advanced_configurations", advanced_configurations)
        pulumi.set(__self__, "backup_enabled", backup_enabled)
        pulumi.set(__self__, "bi_connectors", bi_connectors)
        pulumi.set(__self__, "cluster_type", cluster_type)
        pulumi.set(__self__, "connection_strings", connection_strings)
        pulumi.set(__self__, "create_date", create_date)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "encryption_at_rest_provider", encryption_at_rest_provider)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "mongo_db_major_version", mongo_db_major_version)
        pulumi.set(__self__, "mongo_db_version", mongo_db_version)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "paused", paused)
        pulumi.set(__self__, "pit_enabled", pit_enabled)
        pulumi.set(__self__, "replication_specs", replication_specs)
        pulumi.set(__self__, "root_cert_type", root_cert_type)
        pulumi.set(__self__, "state_name", state_name)
        pulumi.set(__self__, "version_release_system", version_release_system)

    @property
    @pulumi.getter(name="advancedConfigurations")
    def advanced_configurations(self) -> Sequence['outputs.GetAdvancedClustersResultAdvancedConfigurationResult']:
        """
        Get the advanced configuration options. See Advanced Configuration below for more details.
        """
        return pulumi.get(self, "advanced_configurations")

    @property
    @pulumi.getter(name="backupEnabled")
    def backup_enabled(self) -> bool:
        return pulumi.get(self, "backup_enabled")

    @property
    @pulumi.getter(name="biConnectors")
    def bi_connectors(self) -> Sequence['outputs.GetAdvancedClustersResultBiConnectorResult']:
        """
        Configuration settings applied to BI Connector for Atlas on this cluster. See below.
        """
        return pulumi.get(self, "bi_connectors")

    @property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> str:
        """
        Type of the cluster that you want to create.
        """
        return pulumi.get(self, "cluster_type")

    @property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Sequence['outputs.GetAdvancedClustersResultConnectionStringResult']:
        """
        Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.
        """
        return pulumi.get(self, "connection_strings")

    @property
    @pulumi.getter(name="createDate")
    def create_date(self) -> str:
        return pulumi.get(self, "create_date")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> float:
        """
        Capacity, in gigabytes, of the host's root volume.
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter(name="encryptionAtRestProvider")
    def encryption_at_rest_provider(self) -> str:
        """
        Possible values are AWS, GCP, AZURE or NONE.
        """
        return pulumi.get(self, "encryption_at_rest_provider")

    @property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetAdvancedClustersResultLabelResult']:
        """
        Configuration for the collection of key-value pairs that tag and categorize the cluster. See below.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="mongoDbMajorVersion")
    def mongo_db_major_version(self) -> str:
        """
        Version of the cluster to deploy.
        """
        return pulumi.get(self, "mongo_db_major_version")

    @property
    @pulumi.getter(name="mongoDbVersion")
    def mongo_db_version(self) -> str:
        """
        Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.
        """
        return pulumi.get(self, "mongo_db_version")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def paused(self) -> bool:
        """
        Flag that indicates whether the cluster is paused or not.
        """
        return pulumi.get(self, "paused")

    @property
    @pulumi.getter(name="pitEnabled")
    def pit_enabled(self) -> bool:
        """
        Flag that indicates if the cluster uses Continuous Cloud Backup.
        """
        return pulumi.get(self, "pit_enabled")

    @property
    @pulumi.getter(name="replicationSpecs")
    def replication_specs(self) -> Sequence['outputs.GetAdvancedClustersResultReplicationSpecResult']:
        """
        Configuration for cluster regions and the hardware provisioned in them. See below
        """
        return pulumi.get(self, "replication_specs")

    @property
    @pulumi.getter(name="rootCertType")
    def root_cert_type(self) -> str:
        """
        Certificate Authority that MongoDB Atlas clusters use.
        """
        return pulumi.get(self, "root_cert_type")

    @property
    @pulumi.getter(name="stateName")
    def state_name(self) -> str:
        """
        Current state of the cluster. The possible states are:
        """
        return pulumi.get(self, "state_name")

    @property
    @pulumi.getter(name="versionReleaseSystem")
    def version_release_system(self) -> str:
        """
        Release cadence that Atlas uses for this cluster.
        """
        return pulumi.get(self, "version_release_system")


@pulumi.output_type
class GetAdvancedClustersResultAdvancedConfigurationResult(dict):
    def __init__(__self__, *,
                 default_read_concern: str,
                 default_write_concern: str,
                 fail_index_key_too_long: bool,
                 javascript_enabled: bool,
                 minimum_enabled_tls_protocol: str,
                 no_table_scan: bool,
                 oplog_size_mb: int,
                 sample_refresh_interval_bi_connector: int,
                 sample_size_bi_connector: int):
        """
        :param str default_read_concern: [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        :param str default_write_concern: [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        :param bool fail_index_key_too_long: When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        :param bool javascript_enabled: When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        :param str minimum_enabled_tls_protocol: Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        :param bool no_table_scan: When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        :param int oplog_size_mb: The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        :param int sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param int sample_size_bi_connector: Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        pulumi.set(__self__, "default_read_concern", default_read_concern)
        pulumi.set(__self__, "default_write_concern", default_write_concern)
        pulumi.set(__self__, "fail_index_key_too_long", fail_index_key_too_long)
        pulumi.set(__self__, "javascript_enabled", javascript_enabled)
        pulumi.set(__self__, "minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        pulumi.set(__self__, "no_table_scan", no_table_scan)
        pulumi.set(__self__, "oplog_size_mb", oplog_size_mb)
        pulumi.set(__self__, "sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        pulumi.set(__self__, "sample_size_bi_connector", sample_size_bi_connector)

    @property
    @pulumi.getter(name="defaultReadConcern")
    def default_read_concern(self) -> str:
        """
        [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        """
        return pulumi.get(self, "default_read_concern")

    @property
    @pulumi.getter(name="defaultWriteConcern")
    def default_write_concern(self) -> str:
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        return pulumi.get(self, "default_write_concern")

    @property
    @pulumi.getter(name="failIndexKeyTooLong")
    def fail_index_key_too_long(self) -> bool:
        """
        When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        """
        return pulumi.get(self, "fail_index_key_too_long")

    @property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> bool:
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        return pulumi.get(self, "javascript_enabled")

    @property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> str:
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> bool:
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        return pulumi.get(self, "no_table_scan")

    @property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> int:
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        return pulumi.get(self, "oplog_size_mb")

    @property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> int:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> int:
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_size_bi_connector")


@pulumi.output_type
class GetAdvancedClustersResultBiConnectorResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 read_preference: str):
        """
        :param bool enabled: Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
        :param str read_preference: Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "read_preference", read_preference)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> str:
        """
        Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        return pulumi.get(self, "read_preference")


@pulumi.output_type
class GetAdvancedClustersResultConnectionStringResult(dict):
    def __init__(__self__, *,
                 aws_private_link: Mapping[str, Any],
                 aws_private_link_srv: Mapping[str, Any],
                 private: str,
                 private_endpoints: Sequence['outputs.GetAdvancedClustersResultConnectionStringPrivateEndpointResult'],
                 private_srv: str,
                 standard: str,
                 standard_srv: str):
        pulumi.set(__self__, "aws_private_link", aws_private_link)
        pulumi.set(__self__, "aws_private_link_srv", aws_private_link_srv)
        pulumi.set(__self__, "private", private)
        pulumi.set(__self__, "private_endpoints", private_endpoints)
        pulumi.set(__self__, "private_srv", private_srv)
        pulumi.set(__self__, "standard", standard)
        pulumi.set(__self__, "standard_srv", standard_srv)

    @property
    @pulumi.getter(name="awsPrivateLink")
    def aws_private_link(self) -> Mapping[str, Any]:
        return pulumi.get(self, "aws_private_link")

    @property
    @pulumi.getter(name="awsPrivateLinkSrv")
    def aws_private_link_srv(self) -> Mapping[str, Any]:
        return pulumi.get(self, "aws_private_link_srv")

    @property
    @pulumi.getter
    def private(self) -> str:
        return pulumi.get(self, "private")

    @property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Sequence['outputs.GetAdvancedClustersResultConnectionStringPrivateEndpointResult']:
        return pulumi.get(self, "private_endpoints")

    @property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> str:
        return pulumi.get(self, "private_srv")

    @property
    @pulumi.getter
    def standard(self) -> str:
        return pulumi.get(self, "standard")

    @property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> str:
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class GetAdvancedClustersResultConnectionStringPrivateEndpointResult(dict):
    def __init__(__self__, *,
                 connection_string: str,
                 endpoints: Sequence['outputs.GetAdvancedClustersResultConnectionStringPrivateEndpointEndpointResult'],
                 srv_connection_string: str,
                 type: str):
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "srv_connection_string", srv_connection_string)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> str:
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def endpoints(self) -> Sequence['outputs.GetAdvancedClustersResultConnectionStringPrivateEndpointEndpointResult']:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> str:
        return pulumi.get(self, "srv_connection_string")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAdvancedClustersResultConnectionStringPrivateEndpointEndpointResult(dict):
    def __init__(__self__, *,
                 endpoint_id: str,
                 provider_name: str,
                 region: str):
        """
        :param str provider_name: Cloud service provider on which the servers are provisioned.
        """
        pulumi.set(__self__, "endpoint_id", endpoint_id)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> str:
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetAdvancedClustersResultLabelResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecResult(dict):
    def __init__(__self__, *,
                 container_id: Mapping[str, str],
                 id: str,
                 num_shards: int,
                 region_configs: Sequence['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigResult'],
                 zone_name: str):
        """
        :param Mapping[str, str] container_id: A key-value map of the Network Peering Container ID(s) for the configuration specified in `region_configs`. The Container ID is the id of the container either created programmatically by the user before any clusters existed in a project or when the first cluster in the region (AWS/Azure) or project (GCP) was created.  The syntax is `"providerName:regionName" = "containerId"`. Example `AWS:US_EAST_1" = "61e0797dde08fb498ca11a71`.
        :param int num_shards: Provide this value if you set a `cluster_type` of SHARDED or GEOSHARDED.
        :param Sequence['GetAdvancedClustersResultReplicationSpecRegionConfigArgs'] region_configs: Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below
        :param str zone_name: Name for the zone in a Global Cluster.
        """
        pulumi.set(__self__, "container_id", container_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "num_shards", num_shards)
        pulumi.set(__self__, "region_configs", region_configs)
        pulumi.set(__self__, "zone_name", zone_name)

    @property
    @pulumi.getter(name="containerId")
    def container_id(self) -> Mapping[str, str]:
        """
        A key-value map of the Network Peering Container ID(s) for the configuration specified in `region_configs`. The Container ID is the id of the container either created programmatically by the user before any clusters existed in a project or when the first cluster in the region (AWS/Azure) or project (GCP) was created.  The syntax is `"providerName:regionName" = "containerId"`. Example `AWS:US_EAST_1" = "61e0797dde08fb498ca11a71`.
        """
        return pulumi.get(self, "container_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> int:
        """
        Provide this value if you set a `cluster_type` of SHARDED or GEOSHARDED.
        """
        return pulumi.get(self, "num_shards")

    @property
    @pulumi.getter(name="regionConfigs")
    def region_configs(self) -> Sequence['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigResult']:
        """
        Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below
        """
        return pulumi.get(self, "region_configs")

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> str:
        """
        Name for the zone in a Global Cluster.
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecRegionConfigResult(dict):
    def __init__(__self__, *,
                 auto_scalings: Sequence['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigAutoScalingResult'],
                 backing_provider_name: str,
                 priority: int,
                 provider_name: str,
                 region_name: str,
                 analytics_specs: Optional['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecsResult'] = None,
                 electable_specs: Optional['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigElectableSpecsResult'] = None,
                 read_only_specs: Optional['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecsResult'] = None):
        """
        :param Sequence['GetAdvancedClustersResultReplicationSpecRegionConfigAutoScalingArgs'] auto_scalings: Configuration for the Collection of settings that configures auto-scaling information for the cluster. See below
        :param str backing_provider_name: Cloud service provider on which you provision the host for a multi-tenant cluster.
        :param int priority: Election priority of the region.
        :param str provider_name: Cloud service provider on which the servers are provisioned.
        :param str region_name: Physical location of your MongoDB cluster.
        :param 'GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecsArgs' analytics_specs: Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. See below
        :param 'GetAdvancedClustersResultReplicationSpecRegionConfigElectableSpecsArgs' electable_specs: Hardware specifications for electable nodes in the region.
        :param 'GetAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecsArgs' read_only_specs: Hardware specifications for read-only nodes in the region. See below
        """
        pulumi.set(__self__, "auto_scalings", auto_scalings)
        pulumi.set(__self__, "backing_provider_name", backing_provider_name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "region_name", region_name)
        if analytics_specs is not None:
            pulumi.set(__self__, "analytics_specs", analytics_specs)
        if electable_specs is not None:
            pulumi.set(__self__, "electable_specs", electable_specs)
        if read_only_specs is not None:
            pulumi.set(__self__, "read_only_specs", read_only_specs)

    @property
    @pulumi.getter(name="autoScalings")
    def auto_scalings(self) -> Sequence['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigAutoScalingResult']:
        """
        Configuration for the Collection of settings that configures auto-scaling information for the cluster. See below
        """
        return pulumi.get(self, "auto_scalings")

    @property
    @pulumi.getter(name="backingProviderName")
    def backing_provider_name(self) -> str:
        """
        Cloud service provider on which you provision the host for a multi-tenant cluster.
        """
        return pulumi.get(self, "backing_provider_name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Election priority of the region.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        Physical location of your MongoDB cluster.
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter(name="analyticsSpecs")
    def analytics_specs(self) -> Optional['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecsResult']:
        """
        Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. See below
        """
        return pulumi.get(self, "analytics_specs")

    @property
    @pulumi.getter(name="electableSpecs")
    def electable_specs(self) -> Optional['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigElectableSpecsResult']:
        """
        Hardware specifications for electable nodes in the region.
        """
        return pulumi.get(self, "electable_specs")

    @property
    @pulumi.getter(name="readOnlySpecs")
    def read_only_specs(self) -> Optional['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecsResult']:
        """
        Hardware specifications for read-only nodes in the region. See below
        """
        return pulumi.get(self, "read_only_specs")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecsResult(dict):
    def __init__(__self__, *,
                 instance_size: str,
                 disk_iops: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 node_count: Optional[int] = None):
        """
        :param str instance_size: Hardware specification for the instance sizes in this region.
        :param int disk_iops: Target throughput (IOPS) desired for AWS storage attached to your cluster.
        :param str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster.
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param int node_count: Number of read-only nodes for Atlas to deploy to the region.
        """
        pulumi.set(__self__, "instance_size", instance_size)
        if disk_iops is not None:
            pulumi.set(__self__, "disk_iops", disk_iops)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[int]:
        """
        Target throughput (IOPS) desired for AWS storage attached to your cluster.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster.
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of read-only nodes for Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecRegionConfigAutoScalingResult(dict):
    def __init__(__self__, *,
                 compute_enabled: bool,
                 compute_max_instance_size: str,
                 compute_min_instance_size: str,
                 compute_scale_down_enabled: bool,
                 disk_gb_enabled: bool):
        """
        :param bool compute_enabled: Flag that indicates whether instance size auto-scaling is enabled.
        :param str compute_max_instance_size: Maximum instance size to which your cluster can automatically scale (such as M40).
        :param str compute_min_instance_size: Minimum instance size to which your cluster can automatically scale (such as M10).
        :param bool compute_scale_down_enabled: Flag that indicates whether the instance size may scale down.
        :param bool disk_gb_enabled: Flag that indicates whether this cluster enables disk auto-scaling.
        """
        pulumi.set(__self__, "compute_enabled", compute_enabled)
        pulumi.set(__self__, "compute_max_instance_size", compute_max_instance_size)
        pulumi.set(__self__, "compute_min_instance_size", compute_min_instance_size)
        pulumi.set(__self__, "compute_scale_down_enabled", compute_scale_down_enabled)
        pulumi.set(__self__, "disk_gb_enabled", disk_gb_enabled)

    @property
    @pulumi.getter(name="computeEnabled")
    def compute_enabled(self) -> bool:
        """
        Flag that indicates whether instance size auto-scaling is enabled.
        """
        return pulumi.get(self, "compute_enabled")

    @property
    @pulumi.getter(name="computeMaxInstanceSize")
    def compute_max_instance_size(self) -> str:
        """
        Maximum instance size to which your cluster can automatically scale (such as M40).
        """
        return pulumi.get(self, "compute_max_instance_size")

    @property
    @pulumi.getter(name="computeMinInstanceSize")
    def compute_min_instance_size(self) -> str:
        """
        Minimum instance size to which your cluster can automatically scale (such as M10).
        """
        return pulumi.get(self, "compute_min_instance_size")

    @property
    @pulumi.getter(name="computeScaleDownEnabled")
    def compute_scale_down_enabled(self) -> bool:
        """
        Flag that indicates whether the instance size may scale down.
        """
        return pulumi.get(self, "compute_scale_down_enabled")

    @property
    @pulumi.getter(name="diskGbEnabled")
    def disk_gb_enabled(self) -> bool:
        """
        Flag that indicates whether this cluster enables disk auto-scaling.
        """
        return pulumi.get(self, "disk_gb_enabled")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecRegionConfigElectableSpecsResult(dict):
    def __init__(__self__, *,
                 instance_size: str,
                 disk_iops: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 node_count: Optional[int] = None):
        """
        :param str instance_size: Hardware specification for the instance sizes in this region.
        :param int disk_iops: Target throughput (IOPS) desired for AWS storage attached to your cluster.
        :param str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster.
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param int node_count: Number of read-only nodes for Atlas to deploy to the region.
        """
        pulumi.set(__self__, "instance_size", instance_size)
        if disk_iops is not None:
            pulumi.set(__self__, "disk_iops", disk_iops)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[int]:
        """
        Target throughput (IOPS) desired for AWS storage attached to your cluster.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster.
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of read-only nodes for Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecsResult(dict):
    def __init__(__self__, *,
                 instance_size: str,
                 disk_iops: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 node_count: Optional[int] = None):
        """
        :param str instance_size: Hardware specification for the instance sizes in this region.
        :param int disk_iops: Target throughput (IOPS) desired for AWS storage attached to your cluster.
        :param str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster.
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param int node_count: Number of read-only nodes for Atlas to deploy to the region.
        """
        pulumi.set(__self__, "instance_size", instance_size)
        if disk_iops is not None:
            pulumi.set(__self__, "disk_iops", disk_iops)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[int]:
        """
        Target throughput (IOPS) desired for AWS storage attached to your cluster.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster.
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of read-only nodes for Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAlertConfigurationMatcherResult(dict):
    def __init__(__self__, *,
                 field_name: str,
                 operator: str,
                 value: str):
        """
        :param str field_name: Name of the field in the target object to match on.
        :param str operator: Operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
               - `GREATER_THAN`
               - `LESS_THAN`
        :param str value: Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
               - `PRIMARY`
               - `SECONDARY`
               - `STANDALONE`
               - `CONFIG`
               - `MONGOS`
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        """
        Name of the field in the target object to match on.
        """
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        - `GREATER_THAN`
        - `LESS_THAN`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
        - `PRIMARY`
        - `SECONDARY`
        - `STANDALONE`
        - `CONFIG`
        - `MONGOS`
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAlertConfigurationMetricThresholdConfigResult(dict):
    def __init__(__self__, *,
                 metric_name: str,
                 mode: str,
                 operator: str,
                 threshold: float,
                 units: str):
        """
        :param str metric_name: Name of the metric to check. The full list of current options is available [here](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types)
        :param str mode: This must be set to AVERAGE. Atlas computes the current metric value as an average.
        :param str operator: Operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
               - `GREATER_THAN`
               - `LESS_THAN`
        :param float threshold: Threshold value outside of which an alert will be triggered.
        :param str units: The units for the threshold value. Depends on the type of metric.
               Accepted values are:
               - `RAW`
               - `BITS`
               - `BYTES`
               - `KILOBITS`
               - `KILOBYTES`
               - `MEGABITS`
               - `MEGABYTES`
               - `GIGABITS`
               - `GIGABYTES`
               - `TERABYTES`
               - `PETABYTES`
               - `MILLISECONDS`
               - `SECONDS`
               - `MINUTES`
               - `HOURS`
               - `DAYS`
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "units", units)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        Name of the metric to check. The full list of current options is available [here](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types)
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        This must be set to AVERAGE. Atlas computes the current metric value as an average.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        - `GREATER_THAN`
        - `LESS_THAN`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        Threshold value outside of which an alert will be triggered.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def units(self) -> str:
        """
        The units for the threshold value. Depends on the type of metric.
        Accepted values are:
        - `RAW`
        - `BITS`
        - `BYTES`
        - `KILOBITS`
        - `KILOBYTES`
        - `MEGABITS`
        - `MEGABYTES`
        - `GIGABITS`
        - `GIGABYTES`
        - `TERABYTES`
        - `PETABYTES`
        - `MILLISECONDS`
        - `SECONDS`
        - `MINUTES`
        - `HOURS`
        - `DAYS`
        """
        return pulumi.get(self, "units")


@pulumi.output_type
class GetAlertConfigurationNotificationResult(dict):
    def __init__(__self__, *,
                 api_token: str,
                 channel_name: str,
                 datadog_api_key: str,
                 datadog_region: str,
                 delay_min: int,
                 email_address: str,
                 email_enabled: bool,
                 flow_name: str,
                 flowdock_api_token: str,
                 interval_min: int,
                 mobile_number: str,
                 ops_genie_api_key: str,
                 ops_genie_region: str,
                 org_name: str,
                 service_key: str,
                 sms_enabled: bool,
                 team_id: str,
                 team_name: str,
                 type_name: str,
                 username: str,
                 victor_ops_api_key: str,
                 victor_ops_routing_key: str,
                 roles: Optional[Sequence[str]] = None):
        """
        :param str api_token: Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param str channel_name: Slack channel name. Required for the SLACK notifications type.
        :param str datadog_api_key: Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        :param str datadog_region: Region that indicates which API URL to use. Accepted regions are: `US`, `EU`. The default Datadog region is US.
        :param int delay_min: Number of minutes to wait after an alert condition is detected before sending out the first notification.
        :param str email_address: Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        :param bool email_enabled: Flag indicating email notifications should be sent. Atlas returns this value if `type_name` is set  to `ORG`, `GROUP`, or `USER`.
        :param str flow_name: Flowdock flow name in lower-case letters. Required for the `FLOWDOCK` notifications type
        :param str flowdock_api_token: The Flowdock personal API token. Required for the `FLOWDOCK` notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param int interval_min: Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5.
        :param str mobile_number: Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        :param str ops_genie_api_key: Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param str ops_genie_region: Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        :param str org_name: Flowdock organization name in lower-case letters. This is the name that appears after www.flowdock.com/app/ in the URL string. Required for the FLOWDOCK notifications type.
        :param str service_key: PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param bool sms_enabled: Flag indicating text notifications should be sent. Atlas returns this value if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        :param str team_id: Unique identifier of a team.
        :param str team_name: Label for the team that receives this notification.
        :param str type_name: Type of alert notification.
               Accepted values are:
               - `DATADOG`
               - `EMAIL`
               - `FLOWDOCK`
               - `GROUP` (Project)
               - `OPS_GENIE`
               - `ORG`
               - `PAGER_DUTY`
               - `SLACK`
               - `SMS`
               - `TEAM`
               - `USER`
               - `VICTOR_OPS`
               - `WEBHOOK`
        :param str username: Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        :param str victor_ops_api_key: VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param str victor_ops_routing_key: VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param Sequence[str] roles: Atlas role in current Project or Organization. Atlas returns this value if you set `type_name` to `ORG` or `GROUP`.
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "channel_name", channel_name)
        pulumi.set(__self__, "datadog_api_key", datadog_api_key)
        pulumi.set(__self__, "datadog_region", datadog_region)
        pulumi.set(__self__, "delay_min", delay_min)
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "email_enabled", email_enabled)
        pulumi.set(__self__, "flow_name", flow_name)
        pulumi.set(__self__, "flowdock_api_token", flowdock_api_token)
        pulumi.set(__self__, "interval_min", interval_min)
        pulumi.set(__self__, "mobile_number", mobile_number)
        pulumi.set(__self__, "ops_genie_api_key", ops_genie_api_key)
        pulumi.set(__self__, "ops_genie_region", ops_genie_region)
        pulumi.set(__self__, "org_name", org_name)
        pulumi.set(__self__, "service_key", service_key)
        pulumi.set(__self__, "sms_enabled", sms_enabled)
        pulumi.set(__self__, "team_id", team_id)
        pulumi.set(__self__, "team_name", team_name)
        pulumi.set(__self__, "type_name", type_name)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "victor_ops_api_key", victor_ops_api_key)
        pulumi.set(__self__, "victor_ops_routing_key", victor_ops_routing_key)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> str:
        """
        Slack channel name. Required for the SLACK notifications type.
        """
        return pulumi.get(self, "channel_name")

    @property
    @pulumi.getter(name="datadogApiKey")
    def datadog_api_key(self) -> str:
        """
        Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        """
        return pulumi.get(self, "datadog_api_key")

    @property
    @pulumi.getter(name="datadogRegion")
    def datadog_region(self) -> str:
        """
        Region that indicates which API URL to use. Accepted regions are: `US`, `EU`. The default Datadog region is US.
        """
        return pulumi.get(self, "datadog_region")

    @property
    @pulumi.getter(name="delayMin")
    def delay_min(self) -> int:
        """
        Number of minutes to wait after an alert condition is detected before sending out the first notification.
        """
        return pulumi.get(self, "delay_min")

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> str:
        """
        Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter(name="emailEnabled")
    def email_enabled(self) -> bool:
        """
        Flag indicating email notifications should be sent. Atlas returns this value if `type_name` is set  to `ORG`, `GROUP`, or `USER`.
        """
        return pulumi.get(self, "email_enabled")

    @property
    @pulumi.getter(name="flowName")
    def flow_name(self) -> str:
        """
        Flowdock flow name in lower-case letters. Required for the `FLOWDOCK` notifications type
        """
        return pulumi.get(self, "flow_name")

    @property
    @pulumi.getter(name="flowdockApiToken")
    def flowdock_api_token(self) -> str:
        """
        The Flowdock personal API token. Required for the `FLOWDOCK` notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "flowdock_api_token")

    @property
    @pulumi.getter(name="intervalMin")
    def interval_min(self) -> int:
        """
        Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5.
        """
        return pulumi.get(self, "interval_min")

    @property
    @pulumi.getter(name="mobileNumber")
    def mobile_number(self) -> str:
        """
        Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        """
        return pulumi.get(self, "mobile_number")

    @property
    @pulumi.getter(name="opsGenieApiKey")
    def ops_genie_api_key(self) -> str:
        """
        Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "ops_genie_api_key")

    @property
    @pulumi.getter(name="opsGenieRegion")
    def ops_genie_region(self) -> str:
        """
        Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        """
        return pulumi.get(self, "ops_genie_region")

    @property
    @pulumi.getter(name="orgName")
    def org_name(self) -> str:
        """
        Flowdock organization name in lower-case letters. This is the name that appears after www.flowdock.com/app/ in the URL string. Required for the FLOWDOCK notifications type.
        """
        return pulumi.get(self, "org_name")

    @property
    @pulumi.getter(name="serviceKey")
    def service_key(self) -> str:
        """
        PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "service_key")

    @property
    @pulumi.getter(name="smsEnabled")
    def sms_enabled(self) -> bool:
        """
        Flag indicating text notifications should be sent. Atlas returns this value if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        """
        return pulumi.get(self, "sms_enabled")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> str:
        """
        Unique identifier of a team.
        """
        return pulumi.get(self, "team_id")

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> str:
        """
        Label for the team that receives this notification.
        """
        return pulumi.get(self, "team_name")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        """
        Type of alert notification.
        Accepted values are:
        - `DATADOG`
        - `EMAIL`
        - `FLOWDOCK`
        - `GROUP` (Project)
        - `OPS_GENIE`
        - `ORG`
        - `PAGER_DUTY`
        - `SLACK`
        - `SMS`
        - `TEAM`
        - `USER`
        - `VICTOR_OPS`
        - `WEBHOOK`
        """
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="victorOpsApiKey")
    def victor_ops_api_key(self) -> str:
        """
        VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "victor_ops_api_key")

    @property
    @pulumi.getter(name="victorOpsRoutingKey")
    def victor_ops_routing_key(self) -> str:
        """
        VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "victor_ops_routing_key")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        """
        Atlas role in current Project or Organization. Atlas returns this value if you set `type_name` to `ORG` or `GROUP`.
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class GetAlertConfigurationThresholdConfigResult(dict):
    def __init__(__self__, *,
                 operator: str,
                 threshold: float,
                 units: str):
        """
        :param str operator: Operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
               - `GREATER_THAN`
               - `LESS_THAN`
        :param float threshold: Threshold value outside of which an alert will be triggered.
        :param str units: The units for the threshold value. Depends on the type of metric.
               Accepted values are:
               - `RAW`
               - `BITS`
               - `BYTES`
               - `KILOBITS`
               - `KILOBYTES`
               - `MEGABITS`
               - `MEGABYTES`
               - `GIGABITS`
               - `GIGABYTES`
               - `TERABYTES`
               - `PETABYTES`
               - `MILLISECONDS`
               - `SECONDS`
               - `MINUTES`
               - `HOURS`
               - `DAYS`
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "units", units)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        - `GREATER_THAN`
        - `LESS_THAN`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        Threshold value outside of which an alert will be triggered.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def units(self) -> str:
        """
        The units for the threshold value. Depends on the type of metric.
        Accepted values are:
        - `RAW`
        - `BITS`
        - `BYTES`
        - `KILOBITS`
        - `KILOBYTES`
        - `MEGABITS`
        - `MEGABYTES`
        - `GIGABITS`
        - `GIGABYTES`
        - `TERABYTES`
        - `PETABYTES`
        - `MILLISECONDS`
        - `SECONDS`
        - `MINUTES`
        - `HOURS`
        - `DAYS`
        """
        return pulumi.get(self, "units")


@pulumi.output_type
class GetCloudBackupScheduleExportResult(dict):
    def __init__(__self__, *,
                 export_bucket_id: str,
                 frequency_type: str):
        """
        :param str export_bucket_id: Unique identifier of the CloudBackupSnapshotExportBucket export_bucket_id value.
        :param str frequency_type: Frequency associated with the backup policy item.
        """
        pulumi.set(__self__, "export_bucket_id", export_bucket_id)
        pulumi.set(__self__, "frequency_type", frequency_type)

    @property
    @pulumi.getter(name="exportBucketId")
    def export_bucket_id(self) -> str:
        """
        Unique identifier of the CloudBackupSnapshotExportBucket export_bucket_id value.
        """
        return pulumi.get(self, "export_bucket_id")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        """
        Frequency associated with the backup policy item.
        """
        return pulumi.get(self, "frequency_type")


@pulumi.output_type
class GetCloudBackupSchedulePolicyItemDailyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type`.
        :param str frequency_type: Frequency associated with the backup policy item.
        :param str id: Unique identifier of the backup policy item.
        :param str retention_unit: Scope of the backup policy item: days, weeks, or months.
        :param int retention_value: Value to associate with `retention_unit`.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type`.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        """
        Frequency associated with the backup policy item.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: days, weeks, or months.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetCloudBackupSchedulePolicyItemHourlyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type`.
        :param str frequency_type: Frequency associated with the backup policy item.
        :param str id: Unique identifier of the backup policy item.
        :param str retention_unit: Scope of the backup policy item: days, weeks, or months.
        :param int retention_value: Value to associate with `retention_unit`.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type`.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        """
        Frequency associated with the backup policy item.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: days, weeks, or months.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetCloudBackupSchedulePolicyItemMonthlyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type`.
        :param str frequency_type: Frequency associated with the backup policy item.
        :param str id: Unique identifier of the backup policy item.
        :param str retention_unit: Scope of the backup policy item: days, weeks, or months.
        :param int retention_value: Value to associate with `retention_unit`.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type`.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        """
        Frequency associated with the backup policy item.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: days, weeks, or months.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetCloudBackupSchedulePolicyItemWeeklyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type`.
        :param str frequency_type: Frequency associated with the backup policy item.
        :param str id: Unique identifier of the backup policy item.
        :param str retention_unit: Scope of the backup policy item: days, weeks, or months.
        :param int retention_value: Value to associate with `retention_unit`.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type`.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        """
        Frequency associated with the backup policy item.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: days, weeks, or months.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetCloudBackupSnapshotExportBucketsResultResult(dict):
    def __init__(__self__, *,
                 bucket_name: str,
                 cloud_provider: str,
                 export_bucket_id: str,
                 iam_role_id: str):
        """
        :param str bucket_name: Name of the bucket that the provided role ID is authorized to access. You must also specify the `iam_role_id`.
        :param str cloud_provider: Name of the provider of the cloud service where Atlas can access the S3 bucket. Atlas only supports `AWS`.
        :param str export_bucket_id: Unique identifier of the snapshot bucket id.
        :param str iam_role_id: Unique identifier of the role that Atlas can use to access the bucket. You must also specify the `bucket_name`.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "export_bucket_id", export_bucket_id)
        pulumi.set(__self__, "iam_role_id", iam_role_id)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> str:
        """
        Name of the bucket that the provided role ID is authorized to access. You must also specify the `iam_role_id`.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        Name of the provider of the cloud service where Atlas can access the S3 bucket. Atlas only supports `AWS`.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="exportBucketId")
    def export_bucket_id(self) -> str:
        """
        Unique identifier of the snapshot bucket id.
        """
        return pulumi.get(self, "export_bucket_id")

    @property
    @pulumi.getter(name="iamRoleId")
    def iam_role_id(self) -> str:
        """
        Unique identifier of the role that Atlas can use to access the bucket. You must also specify the `bucket_name`.
        """
        return pulumi.get(self, "iam_role_id")


@pulumi.output_type
class GetCloudBackupSnapshotExportJobComponentResult(dict):
    def __init__(__self__, *,
                 export_id: str,
                 replica_set_name: str):
        """
        :param str export_id: _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        :param str replica_set_name: _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
        pulumi.set(__self__, "export_id", export_id)
        pulumi.set(__self__, "replica_set_name", replica_set_name)

    @property
    @pulumi.getter(name="exportId")
    def export_id(self) -> str:
        """
        _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        """
        return pulumi.get(self, "export_id")

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> str:
        """
        _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
        return pulumi.get(self, "replica_set_name")


@pulumi.output_type
class GetCloudBackupSnapshotExportJobCustomDataResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Custom data specified as key in the key and value pair.
        :param str value: Value for the key specified using `key`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Custom data specified as key in the key and value pair.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value for the key specified using `key`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCloudBackupSnapshotExportJobsResultResult(dict):
    def __init__(__self__, *,
                 components: Sequence['outputs.GetCloudBackupSnapshotExportJobsResultComponentResult'],
                 created_at: str,
                 custom_datas: Sequence['outputs.GetCloudBackupSnapshotExportJobsResultCustomDataResult'],
                 err_msg: str,
                 export_bucket_id: str,
                 export_job_id: str,
                 export_status_exported_collections: int,
                 export_status_total_collections: int,
                 finished_at: str,
                 prefix: str,
                 snapshot_id: str,
                 state: str):
        """
        :param Sequence['GetCloudBackupSnapshotExportJobsResultComponentArgs'] components: _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        :param str created_at: Timestamp in ISO 8601 date and time format in UTC when the export job was created.
        :param Sequence['GetCloudBackupSnapshotExportJobsResultCustomDataArgs'] custom_datas: Custom data to include in the metadata file named `.complete` that Atlas uploads to the bucket when the export job finishes. Custom data can be specified as key and value pairs.
        :param str err_msg: Error message, only if the export job failed.
        :param str export_bucket_id: Unique identifier of the AWS bucket to export the Cloud Backup snapshot to.
        :param str export_job_id: Unique identifier of the export job.
               * `prefix ` - Full path on the cloud provider bucket to the folder where the snapshot is exported. The path is in the following format:`/exported_snapshots/{ORG-NAME}/{PROJECT-NAME}/{CLUSTER-NAME}/{SNAPSHOT-INITIATION-DATE}/{TIMESTAMP}`
        :param str finished_at: Timestamp in ISO 8601 date and time format in UTC when the export job completes.
        :param str snapshot_id: Unique identifier of the Cloud Backup snapshot to export.
        :param str state: Status of the export job. Value can be one of the following:
        """
        pulumi.set(__self__, "components", components)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "custom_datas", custom_datas)
        pulumi.set(__self__, "err_msg", err_msg)
        pulumi.set(__self__, "export_bucket_id", export_bucket_id)
        pulumi.set(__self__, "export_job_id", export_job_id)
        pulumi.set(__self__, "export_status_exported_collections", export_status_exported_collections)
        pulumi.set(__self__, "export_status_total_collections", export_status_total_collections)
        pulumi.set(__self__, "finished_at", finished_at)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def components(self) -> Sequence['outputs.GetCloudBackupSnapshotExportJobsResultComponentResult']:
        """
        _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        """
        return pulumi.get(self, "components")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Timestamp in ISO 8601 date and time format in UTC when the export job was created.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="customDatas")
    def custom_datas(self) -> Sequence['outputs.GetCloudBackupSnapshotExportJobsResultCustomDataResult']:
        """
        Custom data to include in the metadata file named `.complete` that Atlas uploads to the bucket when the export job finishes. Custom data can be specified as key and value pairs.
        """
        return pulumi.get(self, "custom_datas")

    @property
    @pulumi.getter(name="errMsg")
    def err_msg(self) -> str:
        """
        Error message, only if the export job failed.
        """
        return pulumi.get(self, "err_msg")

    @property
    @pulumi.getter(name="exportBucketId")
    def export_bucket_id(self) -> str:
        """
        Unique identifier of the AWS bucket to export the Cloud Backup snapshot to.
        """
        return pulumi.get(self, "export_bucket_id")

    @property
    @pulumi.getter(name="exportJobId")
    def export_job_id(self) -> str:
        """
        Unique identifier of the export job.
        * `prefix ` - Full path on the cloud provider bucket to the folder where the snapshot is exported. The path is in the following format:`/exported_snapshots/{ORG-NAME}/{PROJECT-NAME}/{CLUSTER-NAME}/{SNAPSHOT-INITIATION-DATE}/{TIMESTAMP}`
        """
        return pulumi.get(self, "export_job_id")

    @property
    @pulumi.getter(name="exportStatusExportedCollections")
    def export_status_exported_collections(self) -> int:
        return pulumi.get(self, "export_status_exported_collections")

    @property
    @pulumi.getter(name="exportStatusTotalCollections")
    def export_status_total_collections(self) -> int:
        return pulumi.get(self, "export_status_total_collections")

    @property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> str:
        """
        Timestamp in ISO 8601 date and time format in UTC when the export job completes.
        """
        return pulumi.get(self, "finished_at")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> str:
        """
        Unique identifier of the Cloud Backup snapshot to export.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Status of the export job. Value can be one of the following:
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetCloudBackupSnapshotExportJobsResultComponentResult(dict):
    def __init__(__self__, *,
                 export_id: str,
                 replica_set_name: str):
        """
        :param str export_id: _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        :param str replica_set_name: _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
        pulumi.set(__self__, "export_id", export_id)
        pulumi.set(__self__, "replica_set_name", replica_set_name)

    @property
    @pulumi.getter(name="exportId")
    def export_id(self) -> str:
        """
        _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        """
        return pulumi.get(self, "export_id")

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> str:
        """
        _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
        return pulumi.get(self, "replica_set_name")


@pulumi.output_type
class GetCloudBackupSnapshotExportJobsResultCustomDataResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Custom data specified as key in the key and value pair.
        :param str value: Value for the key specified using `key`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Custom data specified as key in the key and value pair.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value for the key specified using `key`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCloudBackupSnapshotMemberResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 id: str,
                 replica_set_name: str):
        """
        :param str cloud_provider: Cloud provider that stores this snapshot.
        :param str id: Unique identifier for the sharded cluster snapshot.
        :param str replica_set_name: Label given to a shard or config server from which Atlas took this snapshot.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "replica_set_name", replica_set_name)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        Cloud provider that stores this snapshot.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier for the sharded cluster snapshot.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> str:
        """
        Label given to a shard or config server from which Atlas took this snapshot.
        """
        return pulumi.get(self, "replica_set_name")


@pulumi.output_type
class GetCloudBackupSnapshotRestoreJobsResultResult(dict):
    def __init__(__self__, *,
                 cancelled: bool,
                 created_at: str,
                 delivery_type: str,
                 delivery_urls: Sequence[str],
                 expired: bool,
                 expires_at: str,
                 finished_at: str,
                 id: str,
                 oplog_inc: int,
                 oplog_ts: int,
                 point_in_time_utc_seconds: int,
                 snapshot_id: str,
                 target_cluster_name: str,
                 target_project_id: str,
                 timestamp: str):
        """
        :param bool cancelled: Indicates whether the restore job was canceled.
        :param str created_at: UTC ISO 8601 formatted point in time when Atlas created the restore job.
        :param str delivery_type: Type of restore job to create. Possible values are: automated and download.
        :param Sequence[str] delivery_urls: One or more URLs for the compressed snapshot files for manual download. Only visible if deliveryType is download.
        :param bool expired: Indicates whether the restore job expired.
        :param str expires_at: UTC ISO 8601 formatted point in time when the restore job expires.
        :param str finished_at: UTC ISO 8601 formatted point in time when the restore job completed.
        :param str id: The unique identifier of the restore job.
        :param str snapshot_id: Unique identifier of the source snapshot ID of the restore job.
        :param str target_cluster_name: Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.
        :param str timestamp: Timestamp in ISO 8601 date and time format in UTC when the snapshot associated to snapshotId was taken.
        """
        pulumi.set(__self__, "cancelled", cancelled)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "delivery_type", delivery_type)
        pulumi.set(__self__, "delivery_urls", delivery_urls)
        pulumi.set(__self__, "expired", expired)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "finished_at", finished_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "oplog_inc", oplog_inc)
        pulumi.set(__self__, "oplog_ts", oplog_ts)
        pulumi.set(__self__, "point_in_time_utc_seconds", point_in_time_utc_seconds)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "target_cluster_name", target_cluster_name)
        pulumi.set(__self__, "target_project_id", target_project_id)
        pulumi.set(__self__, "timestamp", timestamp)

    @property
    @pulumi.getter
    def cancelled(self) -> bool:
        """
        Indicates whether the restore job was canceled.
        """
        return pulumi.get(self, "cancelled")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        UTC ISO 8601 formatted point in time when Atlas created the restore job.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="deliveryType")
    def delivery_type(self) -> str:
        """
        Type of restore job to create. Possible values are: automated and download.
        """
        return pulumi.get(self, "delivery_type")

    @property
    @pulumi.getter(name="deliveryUrls")
    def delivery_urls(self) -> Sequence[str]:
        """
        One or more URLs for the compressed snapshot files for manual download. Only visible if deliveryType is download.
        """
        return pulumi.get(self, "delivery_urls")

    @property
    @pulumi.getter
    def expired(self) -> bool:
        """
        Indicates whether the restore job expired.
        """
        return pulumi.get(self, "expired")

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> str:
        """
        UTC ISO 8601 formatted point in time when the restore job expires.
        """
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> str:
        """
        UTC ISO 8601 formatted point in time when the restore job completed.
        """
        return pulumi.get(self, "finished_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique identifier of the restore job.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="oplogInc")
    def oplog_inc(self) -> int:
        return pulumi.get(self, "oplog_inc")

    @property
    @pulumi.getter(name="oplogTs")
    def oplog_ts(self) -> int:
        return pulumi.get(self, "oplog_ts")

    @property
    @pulumi.getter(name="pointInTimeUtcSeconds")
    def point_in_time_utc_seconds(self) -> int:
        return pulumi.get(self, "point_in_time_utc_seconds")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> str:
        """
        Unique identifier of the source snapshot ID of the restore job.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter(name="targetClusterName")
    def target_cluster_name(self) -> str:
        """
        Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.
        """
        return pulumi.get(self, "target_cluster_name")

    @property
    @pulumi.getter(name="targetProjectId")
    def target_project_id(self) -> str:
        return pulumi.get(self, "target_project_id")

    @property
    @pulumi.getter
    def timestamp(self) -> str:
        """
        Timestamp in ISO 8601 date and time format in UTC when the snapshot associated to snapshotId was taken.
        """
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class GetCloudBackupSnapshotsResultResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 created_at: str,
                 description: str,
                 expires_at: str,
                 id: str,
                 master_key_uuid: str,
                 members: Sequence['outputs.GetCloudBackupSnapshotsResultMemberResult'],
                 mongod_version: str,
                 replica_set_name: str,
                 snapshot_ids: Sequence[str],
                 snapshot_type: str,
                 status: str,
                 storage_size_bytes: int,
                 type: str):
        """
        :param str cloud_provider: Cloud provider that stores this snapshot.
        :param str created_at: UTC ISO 8601 formatted point in time when Atlas took the snapshot.
        :param str description: UDescription of the snapshot. Only present for on-demand snapshots.
        :param str expires_at: UTC ISO 8601 formatted point in time when Atlas will delete the snapshot.
        :param str id: Unique identifier for the sharded cluster snapshot.
        :param str master_key_uuid: Unique ID of the AWS KMS Customer Master Key used to encrypt the snapshot. Only visible for clusters using Encryption at Rest via Customer KMS.
        :param Sequence['GetCloudBackupSnapshotsResultMemberArgs'] members: Block of List of snapshots and the cloud provider where the snapshots are stored. See below
        :param str mongod_version: Version of the MongoDB server.
        :param str replica_set_name: Label given to a shard or config server from which Atlas took this snapshot.
        :param Sequence[str] snapshot_ids: Unique identifiers of the snapshots created for the shards and config server for a sharded cluster.
        :param str snapshot_type: Specified the type of snapshot. Valid values are onDemand and scheduled.
        :param str status: Current status of the snapshot. One of the following values: queued, inProgress, completed, failed.
        :param int storage_size_bytes: Specifies the size of the snapshot in bytes.
        :param str type: Specifies the type of cluster: replicaSet or shardedCluster.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "master_key_uuid", master_key_uuid)
        pulumi.set(__self__, "members", members)
        pulumi.set(__self__, "mongod_version", mongod_version)
        pulumi.set(__self__, "replica_set_name", replica_set_name)
        pulumi.set(__self__, "snapshot_ids", snapshot_ids)
        pulumi.set(__self__, "snapshot_type", snapshot_type)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "storage_size_bytes", storage_size_bytes)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        Cloud provider that stores this snapshot.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        UTC ISO 8601 formatted point in time when Atlas took the snapshot.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        UDescription of the snapshot. Only present for on-demand snapshots.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> str:
        """
        UTC ISO 8601 formatted point in time when Atlas will delete the snapshot.
        """
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier for the sharded cluster snapshot.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="masterKeyUuid")
    def master_key_uuid(self) -> str:
        """
        Unique ID of the AWS KMS Customer Master Key used to encrypt the snapshot. Only visible for clusters using Encryption at Rest via Customer KMS.
        """
        return pulumi.get(self, "master_key_uuid")

    @property
    @pulumi.getter
    def members(self) -> Sequence['outputs.GetCloudBackupSnapshotsResultMemberResult']:
        """
        Block of List of snapshots and the cloud provider where the snapshots are stored. See below
        """
        return pulumi.get(self, "members")

    @property
    @pulumi.getter(name="mongodVersion")
    def mongod_version(self) -> str:
        """
        Version of the MongoDB server.
        """
        return pulumi.get(self, "mongod_version")

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> str:
        """
        Label given to a shard or config server from which Atlas took this snapshot.
        """
        return pulumi.get(self, "replica_set_name")

    @property
    @pulumi.getter(name="snapshotIds")
    def snapshot_ids(self) -> Sequence[str]:
        """
        Unique identifiers of the snapshots created for the shards and config server for a sharded cluster.
        """
        return pulumi.get(self, "snapshot_ids")

    @property
    @pulumi.getter(name="snapshotType")
    def snapshot_type(self) -> str:
        """
        Specified the type of snapshot. Valid values are onDemand and scheduled.
        """
        return pulumi.get(self, "snapshot_type")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Current status of the snapshot. One of the following values: queued, inProgress, completed, failed.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="storageSizeBytes")
    def storage_size_bytes(self) -> int:
        """
        Specifies the size of the snapshot in bytes.
        """
        return pulumi.get(self, "storage_size_bytes")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of cluster: replicaSet or shardedCluster.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetCloudBackupSnapshotsResultMemberResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 id: str,
                 replica_set_name: str):
        """
        :param str cloud_provider: Cloud provider that stores this snapshot.
        :param str id: Unique identifier for the sharded cluster snapshot.
        :param str replica_set_name: Label given to a shard or config server from which Atlas took this snapshot.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "replica_set_name", replica_set_name)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        Cloud provider that stores this snapshot.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier for the sharded cluster snapshot.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> str:
        """
        Label given to a shard or config server from which Atlas took this snapshot.
        """
        return pulumi.get(self, "replica_set_name")


@pulumi.output_type
class GetCloudProviderAccessAwsIamRoleResult(dict):
    def __init__(__self__, *,
                 atlas_assumed_role_external_id: str,
                 atlas_aws_account_arn: str,
                 authorized_date: str,
                 created_date: str,
                 feature_usages: Sequence['outputs.GetCloudProviderAccessAwsIamRoleFeatureUsageResult'],
                 iam_assumed_role_arn: str,
                 provider_name: str,
                 role_id: str):
        """
        :param str atlas_assumed_role_external_id: Unique external ID Atlas uses when assuming the IAM role in your AWS account.
        :param str atlas_aws_account_arn: ARN associated with the Atlas AWS account used to assume IAM roles in your AWS account.
        :param str authorized_date: Date on which this role was authorized.
        :param str created_date: Date on which this role was created.
        :param Sequence['GetCloudProviderAccessAwsIamRoleFeatureUsageArgs'] feature_usages: Atlas features this AWS IAM role is linked to.
        :param str iam_assumed_role_arn: ARN of the IAM Role that Atlas assumes when accessing resources in your AWS account.
        :param str provider_name: Name of the cloud provider. Currently limited to AWS.
        :param str role_id: Unique ID of this role.
        """
        pulumi.set(__self__, "atlas_assumed_role_external_id", atlas_assumed_role_external_id)
        pulumi.set(__self__, "atlas_aws_account_arn", atlas_aws_account_arn)
        pulumi.set(__self__, "authorized_date", authorized_date)
        pulumi.set(__self__, "created_date", created_date)
        pulumi.set(__self__, "feature_usages", feature_usages)
        pulumi.set(__self__, "iam_assumed_role_arn", iam_assumed_role_arn)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "role_id", role_id)

    @property
    @pulumi.getter(name="atlasAssumedRoleExternalId")
    def atlas_assumed_role_external_id(self) -> str:
        """
        Unique external ID Atlas uses when assuming the IAM role in your AWS account.
        """
        return pulumi.get(self, "atlas_assumed_role_external_id")

    @property
    @pulumi.getter(name="atlasAwsAccountArn")
    def atlas_aws_account_arn(self) -> str:
        """
        ARN associated with the Atlas AWS account used to assume IAM roles in your AWS account.
        """
        return pulumi.get(self, "atlas_aws_account_arn")

    @property
    @pulumi.getter(name="authorizedDate")
    def authorized_date(self) -> str:
        """
        Date on which this role was authorized.
        """
        return pulumi.get(self, "authorized_date")

    @property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> str:
        """
        Date on which this role was created.
        """
        return pulumi.get(self, "created_date")

    @property
    @pulumi.getter(name="featureUsages")
    def feature_usages(self) -> Sequence['outputs.GetCloudProviderAccessAwsIamRoleFeatureUsageResult']:
        """
        Atlas features this AWS IAM role is linked to.
        """
        return pulumi.get(self, "feature_usages")

    @property
    @pulumi.getter(name="iamAssumedRoleArn")
    def iam_assumed_role_arn(self) -> str:
        """
        ARN of the IAM Role that Atlas assumes when accessing resources in your AWS account.
        """
        return pulumi.get(self, "iam_assumed_role_arn")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Name of the cloud provider. Currently limited to AWS.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> str:
        """
        Unique ID of this role.
        """
        return pulumi.get(self, "role_id")


@pulumi.output_type
class GetCloudProviderAccessAwsIamRoleFeatureUsageResult(dict):
    def __init__(__self__, *,
                 feature_id: Mapping[str, Any],
                 feature_type: str):
        pulumi.set(__self__, "feature_id", feature_id)
        pulumi.set(__self__, "feature_type", feature_type)

    @property
    @pulumi.getter(name="featureId")
    def feature_id(self) -> Mapping[str, Any]:
        return pulumi.get(self, "feature_id")

    @property
    @pulumi.getter(name="featureType")
    def feature_type(self) -> str:
        return pulumi.get(self, "feature_type")


@pulumi.output_type
class GetCloudProviderAccessSetupAwsConfigResult(dict):
    def __init__(__self__, *,
                 atlas_assumed_role_external_id: str,
                 atlas_aws_account_arn: str):
        """
        :param str atlas_assumed_role_external_id: Unique external ID Atlas uses when assuming the IAM role in your AWS account.
        :param str atlas_aws_account_arn: ARN associated with the Atlas AWS account used to assume IAM roles in your AWS account.
        """
        pulumi.set(__self__, "atlas_assumed_role_external_id", atlas_assumed_role_external_id)
        pulumi.set(__self__, "atlas_aws_account_arn", atlas_aws_account_arn)

    @property
    @pulumi.getter(name="atlasAssumedRoleExternalId")
    def atlas_assumed_role_external_id(self) -> str:
        """
        Unique external ID Atlas uses when assuming the IAM role in your AWS account.
        """
        return pulumi.get(self, "atlas_assumed_role_external_id")

    @property
    @pulumi.getter(name="atlasAwsAccountArn")
    def atlas_aws_account_arn(self) -> str:
        """
        ARN associated with the Atlas AWS account used to assume IAM roles in your AWS account.
        """
        return pulumi.get(self, "atlas_aws_account_arn")


@pulumi.output_type
class GetCloudProviderSnapshotBackupPolicyPolicyResult(dict):
    def __init__(__self__, *,
                 id: str,
                 policy_items: Sequence['outputs.GetCloudProviderSnapshotBackupPolicyPolicyPolicyItemResult']):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "policy_items", policy_items)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="policyItems")
    def policy_items(self) -> Sequence['outputs.GetCloudProviderSnapshotBackupPolicyPolicyPolicyItemResult']:
        return pulumi.get(self, "policy_items")


@pulumi.output_type
class GetCloudProviderSnapshotBackupPolicyPolicyPolicyItemResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetCloudProviderSnapshotRestoreJobsResultResult(dict):
    def __init__(__self__, *,
                 cancelled: bool,
                 created_at: str,
                 delivery_type: str,
                 delivery_urls: Sequence[str],
                 expired: bool,
                 expires_at: str,
                 finished_at: str,
                 id: str,
                 oplog_inc: int,
                 oplog_ts: int,
                 point_in_time_utc_seconds: int,
                 snapshot_id: str,
                 target_cluster_name: str,
                 target_project_id: str,
                 timestamp: str):
        """
        :param bool cancelled: Indicates whether the restore job was canceled.
        :param str created_at: UTC ISO 8601 formatted point in time when Atlas created the restore job.
        :param str delivery_type: Type of restore job to create. Possible values are: automated and download.
        :param Sequence[str] delivery_urls: One or more URLs for the compressed snapshot files for manual download. Only visible if deliveryType is download.
        :param bool expired: Indicates whether the restore job expired.
        :param str expires_at: UTC ISO 8601 formatted point in time when the restore job expires.
        :param str finished_at: UTC ISO 8601 formatted point in time when the restore job completed.
        :param str id: The unique identifier of the restore job.
        :param str snapshot_id: Unique identifier of the source snapshot ID of the restore job.
        :param str target_cluster_name: Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.
        :param str timestamp: Timestamp in ISO 8601 date and time format in UTC when the snapshot associated to snapshotId was taken.
        """
        pulumi.set(__self__, "cancelled", cancelled)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "delivery_type", delivery_type)
        pulumi.set(__self__, "delivery_urls", delivery_urls)
        pulumi.set(__self__, "expired", expired)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "finished_at", finished_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "oplog_inc", oplog_inc)
        pulumi.set(__self__, "oplog_ts", oplog_ts)
        pulumi.set(__self__, "point_in_time_utc_seconds", point_in_time_utc_seconds)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "target_cluster_name", target_cluster_name)
        pulumi.set(__self__, "target_project_id", target_project_id)
        pulumi.set(__self__, "timestamp", timestamp)

    @property
    @pulumi.getter
    def cancelled(self) -> bool:
        """
        Indicates whether the restore job was canceled.
        """
        return pulumi.get(self, "cancelled")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        UTC ISO 8601 formatted point in time when Atlas created the restore job.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="deliveryType")
    def delivery_type(self) -> str:
        """
        Type of restore job to create. Possible values are: automated and download.
        """
        return pulumi.get(self, "delivery_type")

    @property
    @pulumi.getter(name="deliveryUrls")
    def delivery_urls(self) -> Sequence[str]:
        """
        One or more URLs for the compressed snapshot files for manual download. Only visible if deliveryType is download.
        """
        return pulumi.get(self, "delivery_urls")

    @property
    @pulumi.getter
    def expired(self) -> bool:
        """
        Indicates whether the restore job expired.
        """
        return pulumi.get(self, "expired")

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> str:
        """
        UTC ISO 8601 formatted point in time when the restore job expires.
        """
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> str:
        """
        UTC ISO 8601 formatted point in time when the restore job completed.
        """
        return pulumi.get(self, "finished_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique identifier of the restore job.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="oplogInc")
    def oplog_inc(self) -> int:
        return pulumi.get(self, "oplog_inc")

    @property
    @pulumi.getter(name="oplogTs")
    def oplog_ts(self) -> int:
        return pulumi.get(self, "oplog_ts")

    @property
    @pulumi.getter(name="pointInTimeUtcSeconds")
    def point_in_time_utc_seconds(self) -> int:
        return pulumi.get(self, "point_in_time_utc_seconds")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> str:
        """
        Unique identifier of the source snapshot ID of the restore job.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter(name="targetClusterName")
    def target_cluster_name(self) -> str:
        """
        Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.
        """
        return pulumi.get(self, "target_cluster_name")

    @property
    @pulumi.getter(name="targetProjectId")
    def target_project_id(self) -> str:
        return pulumi.get(self, "target_project_id")

    @property
    @pulumi.getter
    def timestamp(self) -> str:
        """
        Timestamp in ISO 8601 date and time format in UTC when the snapshot associated to snapshotId was taken.
        """
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class GetCloudProviderSnapshotsResultResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 description: str,
                 expires_at: str,
                 id: str,
                 master_key_uuid: str,
                 mongod_version: str,
                 snapshot_type: str,
                 status: str,
                 storage_size_bytes: int,
                 type: str):
        """
        :param str created_at: UTC ISO 8601 formatted point in time when Atlas took the snapshot.
        :param str description: UDescription of the snapshot. Only present for on-demand snapshots.
        :param str expires_at: UTC ISO 8601 formatted point in time when Atlas will delete the snapshot.
        :param str id: Unique identifier of the snapshot.
        :param str master_key_uuid: Unique ID of the AWS KMS Customer Master Key used to encrypt the snapshot. Only visible for clusters using Encryption at Rest via Customer KMS.
        :param str mongod_version: Version of the MongoDB server.
        :param str snapshot_type: Specified the type of snapshot. Valid values are onDemand and scheduled.
        :param str status: Current status of the snapshot. One of the following values: queued, inProgress, completed, failed.
        :param int storage_size_bytes: Specifies the size of the snapshot in bytes.
        :param str type: Specifies the type of cluster: replicaSet or shardedCluster.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "master_key_uuid", master_key_uuid)
        pulumi.set(__self__, "mongod_version", mongod_version)
        pulumi.set(__self__, "snapshot_type", snapshot_type)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "storage_size_bytes", storage_size_bytes)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        UTC ISO 8601 formatted point in time when Atlas took the snapshot.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        UDescription of the snapshot. Only present for on-demand snapshots.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> str:
        """
        UTC ISO 8601 formatted point in time when Atlas will delete the snapshot.
        """
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of the snapshot.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="masterKeyUuid")
    def master_key_uuid(self) -> str:
        """
        Unique ID of the AWS KMS Customer Master Key used to encrypt the snapshot. Only visible for clusters using Encryption at Rest via Customer KMS.
        """
        return pulumi.get(self, "master_key_uuid")

    @property
    @pulumi.getter(name="mongodVersion")
    def mongod_version(self) -> str:
        """
        Version of the MongoDB server.
        """
        return pulumi.get(self, "mongod_version")

    @property
    @pulumi.getter(name="snapshotType")
    def snapshot_type(self) -> str:
        """
        Specified the type of snapshot. Valid values are onDemand and scheduled.
        """
        return pulumi.get(self, "snapshot_type")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Current status of the snapshot. One of the following values: queued, inProgress, completed, failed.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="storageSizeBytes")
    def storage_size_bytes(self) -> int:
        """
        Specifies the size of the snapshot in bytes.
        """
        return pulumi.get(self, "storage_size_bytes")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of cluster: replicaSet or shardedCluster.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetClusterAdvancedConfigurationResult(dict):
    def __init__(__self__, *,
                 default_read_concern: str,
                 default_write_concern: str,
                 fail_index_key_too_long: bool,
                 javascript_enabled: bool,
                 minimum_enabled_tls_protocol: str,
                 no_table_scan: bool,
                 oplog_size_mb: int,
                 sample_refresh_interval_bi_connector: int,
                 sample_size_bi_connector: int):
        """
        :param str default_read_concern: [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        :param str default_write_concern: [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        :param bool fail_index_key_too_long: When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        :param bool javascript_enabled: When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        :param str minimum_enabled_tls_protocol: Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        :param bool no_table_scan: When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        :param int oplog_size_mb: The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        :param int sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param int sample_size_bi_connector: Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        pulumi.set(__self__, "default_read_concern", default_read_concern)
        pulumi.set(__self__, "default_write_concern", default_write_concern)
        pulumi.set(__self__, "fail_index_key_too_long", fail_index_key_too_long)
        pulumi.set(__self__, "javascript_enabled", javascript_enabled)
        pulumi.set(__self__, "minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        pulumi.set(__self__, "no_table_scan", no_table_scan)
        pulumi.set(__self__, "oplog_size_mb", oplog_size_mb)
        pulumi.set(__self__, "sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        pulumi.set(__self__, "sample_size_bi_connector", sample_size_bi_connector)

    @property
    @pulumi.getter(name="defaultReadConcern")
    def default_read_concern(self) -> str:
        """
        [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        """
        return pulumi.get(self, "default_read_concern")

    @property
    @pulumi.getter(name="defaultWriteConcern")
    def default_write_concern(self) -> str:
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        return pulumi.get(self, "default_write_concern")

    @property
    @pulumi.getter(name="failIndexKeyTooLong")
    def fail_index_key_too_long(self) -> bool:
        """
        When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        """
        return pulumi.get(self, "fail_index_key_too_long")

    @property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> bool:
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        return pulumi.get(self, "javascript_enabled")

    @property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> str:
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> bool:
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        return pulumi.get(self, "no_table_scan")

    @property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> int:
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        return pulumi.get(self, "oplog_size_mb")

    @property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> int:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> int:
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_size_bi_connector")


@pulumi.output_type
class GetClusterBiConnectorConfigResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 read_preference: str):
        """
        :param bool enabled: Indicates whether or not BI Connector for Atlas is enabled on the cluster.
        :param str read_preference: Indicates the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "read_preference", read_preference)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Indicates whether or not BI Connector for Atlas is enabled on the cluster.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> str:
        """
        Indicates the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        return pulumi.get(self, "read_preference")


@pulumi.output_type
class GetClusterConnectionStringResult(dict):
    def __init__(__self__, *,
                 aws_private_link: Mapping[str, Any],
                 aws_private_link_srv: Mapping[str, Any],
                 private: str,
                 private_endpoints: Sequence['outputs.GetClusterConnectionStringPrivateEndpointResult'],
                 private_srv: str,
                 standard: str,
                 standard_srv: str):
        pulumi.set(__self__, "aws_private_link", aws_private_link)
        pulumi.set(__self__, "aws_private_link_srv", aws_private_link_srv)
        pulumi.set(__self__, "private", private)
        pulumi.set(__self__, "private_endpoints", private_endpoints)
        pulumi.set(__self__, "private_srv", private_srv)
        pulumi.set(__self__, "standard", standard)
        pulumi.set(__self__, "standard_srv", standard_srv)

    @property
    @pulumi.getter(name="awsPrivateLink")
    def aws_private_link(self) -> Mapping[str, Any]:
        return pulumi.get(self, "aws_private_link")

    @property
    @pulumi.getter(name="awsPrivateLinkSrv")
    def aws_private_link_srv(self) -> Mapping[str, Any]:
        return pulumi.get(self, "aws_private_link_srv")

    @property
    @pulumi.getter
    def private(self) -> str:
        return pulumi.get(self, "private")

    @property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Sequence['outputs.GetClusterConnectionStringPrivateEndpointResult']:
        return pulumi.get(self, "private_endpoints")

    @property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> str:
        return pulumi.get(self, "private_srv")

    @property
    @pulumi.getter
    def standard(self) -> str:
        return pulumi.get(self, "standard")

    @property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> str:
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class GetClusterConnectionStringPrivateEndpointResult(dict):
    def __init__(__self__, *,
                 connection_string: str,
                 endpoints: Sequence['outputs.GetClusterConnectionStringPrivateEndpointEndpointResult'],
                 srv_connection_string: str,
                 type: str):
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "srv_connection_string", srv_connection_string)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> str:
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def endpoints(self) -> Sequence['outputs.GetClusterConnectionStringPrivateEndpointEndpointResult']:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> str:
        return pulumi.get(self, "srv_connection_string")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetClusterConnectionStringPrivateEndpointEndpointResult(dict):
    def __init__(__self__, *,
                 endpoint_id: str,
                 provider_name: str,
                 region: str):
        """
        :param str provider_name: Indicates the cloud service provider on which the servers are provisioned.
        """
        pulumi.set(__self__, "endpoint_id", endpoint_id)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> str:
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Indicates the cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetClusterLabelResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that was set.
        :param str value: The value that represents the key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that was set.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that represents the key.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterReplicationSpecResult(dict):
    def __init__(__self__, *,
                 id: str,
                 num_shards: int,
                 regions_configs: Sequence['outputs.GetClusterReplicationSpecRegionsConfigResult'],
                 zone_name: str):
        """
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster.
        :param int num_shards: Number of shards to deploy in the specified zone.
        :param Sequence['GetClusterReplicationSpecRegionsConfigArgs'] regions_configs: Describes the physical location of the region. Each regionsConfig document describes the regions priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        :param str zone_name: Indicates the n ame for the zone in a Global Cluster.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "num_shards", num_shards)
        pulumi.set(__self__, "regions_configs", regions_configs)
        pulumi.set(__self__, "zone_name", zone_name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifer of the replication document for a zone in a Global Cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> int:
        """
        Number of shards to deploy in the specified zone.
        """
        return pulumi.get(self, "num_shards")

    @property
    @pulumi.getter(name="regionsConfigs")
    def regions_configs(self) -> Sequence['outputs.GetClusterReplicationSpecRegionsConfigResult']:
        """
        Describes the physical location of the region. Each regionsConfig document describes the regions priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        """
        return pulumi.get(self, "regions_configs")

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> str:
        """
        Indicates the n ame for the zone in a Global Cluster.
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class GetClusterReplicationSpecRegionsConfigResult(dict):
    def __init__(__self__, *,
                 analytics_nodes: int,
                 electable_nodes: int,
                 priority: int,
                 read_only_nodes: int,
                 region_name: str):
        """
        :param int analytics_nodes: Indicates the number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary.
        :param int electable_nodes: Number of electable nodes for Atlas to deploy to the region.
        :param int priority: Election priority of the region. For regions with only read-only nodes, set this value to 0.
        :param int read_only_nodes: Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        :param str region_name: Name for the region specified.
        """
        pulumi.set(__self__, "analytics_nodes", analytics_nodes)
        pulumi.set(__self__, "electable_nodes", electable_nodes)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "read_only_nodes", read_only_nodes)
        pulumi.set(__self__, "region_name", region_name)

    @property
    @pulumi.getter(name="analyticsNodes")
    def analytics_nodes(self) -> int:
        """
        Indicates the number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary.
        """
        return pulumi.get(self, "analytics_nodes")

    @property
    @pulumi.getter(name="electableNodes")
    def electable_nodes(self) -> int:
        """
        Number of electable nodes for Atlas to deploy to the region.
        """
        return pulumi.get(self, "electable_nodes")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Election priority of the region. For regions with only read-only nodes, set this value to 0.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="readOnlyNodes")
    def read_only_nodes(self) -> int:
        """
        Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        """
        return pulumi.get(self, "read_only_nodes")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        Name for the region specified.
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class GetClusterSnapshotBackupPolicyResult(dict):
    def __init__(__self__, *,
                 cluster_id: str,
                 cluster_name: str,
                 next_snapshot: str,
                 policies: Sequence['outputs.GetClusterSnapshotBackupPolicyPolicyResult'],
                 reference_hour_of_day: int,
                 reference_minute_of_hour: int,
                 restore_window_days: int,
                 update_snapshots: bool):
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "next_snapshot", next_snapshot)
        pulumi.set(__self__, "policies", policies)
        pulumi.set(__self__, "reference_hour_of_day", reference_hour_of_day)
        pulumi.set(__self__, "reference_minute_of_hour", reference_minute_of_hour)
        pulumi.set(__self__, "restore_window_days", restore_window_days)
        pulumi.set(__self__, "update_snapshots", update_snapshots)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="nextSnapshot")
    def next_snapshot(self) -> str:
        return pulumi.get(self, "next_snapshot")

    @property
    @pulumi.getter
    def policies(self) -> Sequence['outputs.GetClusterSnapshotBackupPolicyPolicyResult']:
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="referenceHourOfDay")
    def reference_hour_of_day(self) -> int:
        return pulumi.get(self, "reference_hour_of_day")

    @property
    @pulumi.getter(name="referenceMinuteOfHour")
    def reference_minute_of_hour(self) -> int:
        return pulumi.get(self, "reference_minute_of_hour")

    @property
    @pulumi.getter(name="restoreWindowDays")
    def restore_window_days(self) -> int:
        return pulumi.get(self, "restore_window_days")

    @property
    @pulumi.getter(name="updateSnapshots")
    def update_snapshots(self) -> bool:
        return pulumi.get(self, "update_snapshots")


@pulumi.output_type
class GetClusterSnapshotBackupPolicyPolicyResult(dict):
    def __init__(__self__, *,
                 policy_items: Sequence['outputs.GetClusterSnapshotBackupPolicyPolicyPolicyItemResult']):
        pulumi.set(__self__, "policy_items", policy_items)

    @property
    @pulumi.getter(name="policyItems")
    def policy_items(self) -> Sequence['outputs.GetClusterSnapshotBackupPolicyPolicyPolicyItemResult']:
        return pulumi.get(self, "policy_items")


@pulumi.output_type
class GetClusterSnapshotBackupPolicyPolicyPolicyItemResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 retention_unit: str,
                 retention_value: int):
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetClustersResultResult(dict):
    def __init__(__self__, *,
                 advanced_configurations: Sequence['outputs.GetClustersResultAdvancedConfigurationResult'],
                 auto_scaling_compute_enabled: bool,
                 auto_scaling_compute_scale_down_enabled: bool,
                 auto_scaling_disk_gb_enabled: bool,
                 backing_provider_name: str,
                 backup_enabled: bool,
                 bi_connector: Mapping[str, str],
                 bi_connector_configs: Sequence['outputs.GetClustersResultBiConnectorConfigResult'],
                 cluster_type: str,
                 connection_strings: Sequence['outputs.GetClustersResultConnectionStringResult'],
                 container_id: str,
                 disk_size_gb: float,
                 encryption_at_rest_provider: str,
                 labels: Sequence['outputs.GetClustersResultLabelResult'],
                 mongo_db_major_version: str,
                 mongo_db_version: str,
                 mongo_uri: str,
                 mongo_uri_updated: str,
                 mongo_uri_with_options: str,
                 name: str,
                 num_shards: int,
                 paused: bool,
                 pit_enabled: bool,
                 provider_auto_scaling_compute_max_instance_size: str,
                 provider_auto_scaling_compute_min_instance_size: str,
                 provider_backup_enabled: bool,
                 provider_disk_iops: int,
                 provider_disk_type_name: str,
                 provider_encrypt_ebs_volume: bool,
                 provider_instance_size_name: str,
                 provider_name: str,
                 provider_region_name: str,
                 provider_volume_type: str,
                 replication_factor: int,
                 replication_specs: Sequence['outputs.GetClustersResultReplicationSpecResult'],
                 snapshot_backup_policies: Sequence['outputs.GetClustersResultSnapshotBackupPolicyResult'],
                 srv_address: str,
                 state_name: str,
                 version_release_system: str):
        """
        :param Sequence['GetClustersResultAdvancedConfigurationArgs'] advanced_configurations: Get the advanced configuration options. See Advanced Configuration below for more details.
        :param bool auto_scaling_compute_enabled: Specifies whether cluster tier auto-scaling is enabled. The default is false.
        :param bool auto_scaling_compute_scale_down_enabled: * `auto_scaling_compute_scale_down_enabled` - Specifies whether cluster tier auto-down-scaling is enabled.
        :param bool auto_scaling_disk_gb_enabled: Indicates whether disk auto-scaling is enabled.
        :param str backing_provider_name: Indicates Cloud service provider on which the server for a multi-tenant cluster is provisioned.
        :param bool backup_enabled: Legacy Option, Indicates whether Atlas continuous backups are enabled for the cluster.
        :param Mapping[str, str] bi_connector: Indicates BI Connector for Atlas configuration on this cluster. BI Connector for Atlas is only available for M10+ clusters. See BI Connector below for more details. **DEPRECATED** Use `bi_connector_config` instead.
        :param Sequence['GetClustersResultBiConnectorConfigArgs'] bi_connector_configs: Indicates BI Connector for Atlas configuration on this cluster. BI Connector for Atlas is only available for M10+ clusters. See BI Connector below for more details.
        :param str cluster_type: Indicates the type of the cluster that you want to modify. You cannot convert a sharded cluster deployment to a replica set deployment.
        :param Sequence['GetClustersResultConnectionStringArgs'] connection_strings: Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.
               - `connection_strings.standard` -   Public mongodb:// connection string for this cluster.
               - `connection_strings.standard_srv` - Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you dont need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesnt, use connectionStrings.standard.
               - `connection_strings.aws_private_link` -  [Private-endpoint-aware](https://docs.atlas.mongodb.com/security-private-endpoint/#private-endpoint-connection-strings) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a AWS PrivateLink connection to this cluster. **DEPRECATED** Use `connection_strings.private_endpoint[n].connection_string` instead.
               - `connection_strings.aws_private_link_srv` - [Private-endpoint-aware](https://docs.atlas.mongodb.com/security-private-endpoint/#private-endpoint-connection-strings) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a AWS PrivateLink connection to this cluster. Use this URI format if your driver supports it. If it doesnt, use connectionStrings.awsPrivateLink. **DEPRECATED** `connection_strings.private_endpoint[n].srv_connection_string` instead.
               - `connection_strings.private` -   [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
               - `connection_strings.private_srv` -  [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
               - `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
               - `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint.
               - `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
               - `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`
               - `connection_strings.private_endoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.
               - `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
               - `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.
        :param str container_id: The Network Peering Container ID.
        :param float disk_size_gb: Indicates the size in gigabytes of the servers root volume (AWS/GCP Only).
        :param str encryption_at_rest_provider: Indicates whether Encryption at Rest is enabled or disabled.
        :param str mongo_db_major_version: Indicates the version of the cluster to deploy.
        :param str mongo_db_version: Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.
        :param str mongo_uri: Base connection string for the cluster. Atlas only displays this field after the cluster is operational, not while it builds the cluster.
        :param str mongo_uri_updated: Lists when the connection string was last updated. The connection string changes, for example, if you change a replica set to a sharded cluster.
        :param str mongo_uri_with_options: Describes connection string for connecting to the Atlas cluster. Includes the replicaSet, ssl, and authSource query parameters in the connection string with values appropriate for the cluster.
        :param str name: The name of the current plugin
        :param int num_shards: Number of shards to deploy in the specified zone.
        :param bool paused: Flag that indicates whether the cluster is paused or not.
        :param bool pit_enabled: Flag that indicates if the cluster uses Continuous Cloud Backup.
        :param str provider_auto_scaling_compute_max_instance_size: Maximum instance size to which your cluster can automatically scale.
        :param str provider_auto_scaling_compute_min_instance_size: Minimum instance size to which your cluster can automatically scale.
        :param bool provider_backup_enabled: Flag indicating if the cluster uses Cloud Backup Snapshots for backups. **DEPRECATED** Use `cloud_backup` instead.
        :param int provider_disk_iops: Indicates the maximum input/output operations per second (IOPS) the system can perform. The possible values depend on the selected providerSettings.instanceSizeName and diskSizeGB.
        :param str provider_disk_type_name: Describes Azure disk type of the servers root volume (Azure Only).
        :param bool provider_encrypt_ebs_volume: **(DEPRECATED)** Indicates whether the Amazon EBS encryption is enabled. This feature encrypts the servers root volume for both data at rest within the volume and data moving between the volume and the instance. By default this attribute is always enabled, per deprecation process showing the real value at `provider_encrypt_ebs_volume_flag` computed attribute.
        :param str provider_instance_size_name: Atlas provides different instance sizes, each with a default storage capacity and RAM size.
        :param str provider_name: Indicates the cloud service provider on which the servers are provisioned.
        :param str provider_region_name: Indicates Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases. Requires the Atlas Region name, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        :param str provider_volume_type: Indicates the type of the volume. The possible values are: `STANDARD` and `PROVISIONED`.
        :param int replication_factor: (Deprecated) Number of replica set members. Each member keeps a copy of your databases, providing high availability and data redundancy. The possible values are 3, 5, or 7. The default value is 3.
        :param Sequence['GetClustersResultReplicationSpecArgs'] replication_specs: Configuration for cluster regions.  See Replication Spec below for more details.
        :param Sequence['GetClustersResultSnapshotBackupPolicyArgs'] snapshot_backup_policies: current snapshot schedule and retention settings for the cluster.
        :param str srv_address: Connection string for connecting to the Atlas cluster. The +srv modifier forces the connection to use TLS/SSL. See the mongoURI for additional options.
        :param str state_name: Indicates the current state of the cluster. The possible states are:
               - IDLE
               - CREATING
               - UPDATING
               - DELETING
               - DELETED
               - REPAIRING
        :param str version_release_system: Release cadence that Atlas uses for this cluster.
        """
        pulumi.set(__self__, "advanced_configurations", advanced_configurations)
        pulumi.set(__self__, "auto_scaling_compute_enabled", auto_scaling_compute_enabled)
        pulumi.set(__self__, "auto_scaling_compute_scale_down_enabled", auto_scaling_compute_scale_down_enabled)
        pulumi.set(__self__, "auto_scaling_disk_gb_enabled", auto_scaling_disk_gb_enabled)
        pulumi.set(__self__, "backing_provider_name", backing_provider_name)
        pulumi.set(__self__, "backup_enabled", backup_enabled)
        pulumi.set(__self__, "bi_connector", bi_connector)
        pulumi.set(__self__, "bi_connector_configs", bi_connector_configs)
        pulumi.set(__self__, "cluster_type", cluster_type)
        pulumi.set(__self__, "connection_strings", connection_strings)
        pulumi.set(__self__, "container_id", container_id)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "encryption_at_rest_provider", encryption_at_rest_provider)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "mongo_db_major_version", mongo_db_major_version)
        pulumi.set(__self__, "mongo_db_version", mongo_db_version)
        pulumi.set(__self__, "mongo_uri", mongo_uri)
        pulumi.set(__self__, "mongo_uri_updated", mongo_uri_updated)
        pulumi.set(__self__, "mongo_uri_with_options", mongo_uri_with_options)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "num_shards", num_shards)
        pulumi.set(__self__, "paused", paused)
        pulumi.set(__self__, "pit_enabled", pit_enabled)
        pulumi.set(__self__, "provider_auto_scaling_compute_max_instance_size", provider_auto_scaling_compute_max_instance_size)
        pulumi.set(__self__, "provider_auto_scaling_compute_min_instance_size", provider_auto_scaling_compute_min_instance_size)
        pulumi.set(__self__, "provider_backup_enabled", provider_backup_enabled)
        pulumi.set(__self__, "provider_disk_iops", provider_disk_iops)
        pulumi.set(__self__, "provider_disk_type_name", provider_disk_type_name)
        pulumi.set(__self__, "provider_encrypt_ebs_volume", provider_encrypt_ebs_volume)
        pulumi.set(__self__, "provider_instance_size_name", provider_instance_size_name)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "provider_region_name", provider_region_name)
        pulumi.set(__self__, "provider_volume_type", provider_volume_type)
        pulumi.set(__self__, "replication_factor", replication_factor)
        pulumi.set(__self__, "replication_specs", replication_specs)
        pulumi.set(__self__, "snapshot_backup_policies", snapshot_backup_policies)
        pulumi.set(__self__, "srv_address", srv_address)
        pulumi.set(__self__, "state_name", state_name)
        pulumi.set(__self__, "version_release_system", version_release_system)

    @property
    @pulumi.getter(name="advancedConfigurations")
    def advanced_configurations(self) -> Sequence['outputs.GetClustersResultAdvancedConfigurationResult']:
        """
        Get the advanced configuration options. See Advanced Configuration below for more details.
        """
        return pulumi.get(self, "advanced_configurations")

    @property
    @pulumi.getter(name="autoScalingComputeEnabled")
    def auto_scaling_compute_enabled(self) -> bool:
        """
        Specifies whether cluster tier auto-scaling is enabled. The default is false.
        """
        return pulumi.get(self, "auto_scaling_compute_enabled")

    @property
    @pulumi.getter(name="autoScalingComputeScaleDownEnabled")
    def auto_scaling_compute_scale_down_enabled(self) -> bool:
        """
        * `auto_scaling_compute_scale_down_enabled` - Specifies whether cluster tier auto-down-scaling is enabled.
        """
        return pulumi.get(self, "auto_scaling_compute_scale_down_enabled")

    @property
    @pulumi.getter(name="autoScalingDiskGbEnabled")
    def auto_scaling_disk_gb_enabled(self) -> bool:
        """
        Indicates whether disk auto-scaling is enabled.
        """
        return pulumi.get(self, "auto_scaling_disk_gb_enabled")

    @property
    @pulumi.getter(name="backingProviderName")
    def backing_provider_name(self) -> str:
        """
        Indicates Cloud service provider on which the server for a multi-tenant cluster is provisioned.
        """
        return pulumi.get(self, "backing_provider_name")

    @property
    @pulumi.getter(name="backupEnabled")
    def backup_enabled(self) -> bool:
        """
        Legacy Option, Indicates whether Atlas continuous backups are enabled for the cluster.
        """
        return pulumi.get(self, "backup_enabled")

    @property
    @pulumi.getter(name="biConnector")
    def bi_connector(self) -> Mapping[str, str]:
        """
        Indicates BI Connector for Atlas configuration on this cluster. BI Connector for Atlas is only available for M10+ clusters. See BI Connector below for more details. **DEPRECATED** Use `bi_connector_config` instead.
        """
        return pulumi.get(self, "bi_connector")

    @property
    @pulumi.getter(name="biConnectorConfigs")
    def bi_connector_configs(self) -> Sequence['outputs.GetClustersResultBiConnectorConfigResult']:
        """
        Indicates BI Connector for Atlas configuration on this cluster. BI Connector for Atlas is only available for M10+ clusters. See BI Connector below for more details.
        """
        return pulumi.get(self, "bi_connector_configs")

    @property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> str:
        """
        Indicates the type of the cluster that you want to modify. You cannot convert a sharded cluster deployment to a replica set deployment.
        """
        return pulumi.get(self, "cluster_type")

    @property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Sequence['outputs.GetClustersResultConnectionStringResult']:
        """
        Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.
        - `connection_strings.standard` -   Public mongodb:// connection string for this cluster.
        - `connection_strings.standard_srv` - Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you dont need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesnt, use connectionStrings.standard.
        - `connection_strings.aws_private_link` -  [Private-endpoint-aware](https://docs.atlas.mongodb.com/security-private-endpoint/#private-endpoint-connection-strings) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a AWS PrivateLink connection to this cluster. **DEPRECATED** Use `connection_strings.private_endpoint[n].connection_string` instead.
        - `connection_strings.aws_private_link_srv` - [Private-endpoint-aware](https://docs.atlas.mongodb.com/security-private-endpoint/#private-endpoint-connection-strings) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a AWS PrivateLink connection to this cluster. Use this URI format if your driver supports it. If it doesnt, use connectionStrings.awsPrivateLink. **DEPRECATED** `connection_strings.private_endpoint[n].srv_connection_string` instead.
        - `connection_strings.private` -   [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        - `connection_strings.private_srv` -  [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        - `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
        - `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint.
        - `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
        - `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`
        - `connection_strings.private_endoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.
        - `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
        - `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.
        """
        return pulumi.get(self, "connection_strings")

    @property
    @pulumi.getter(name="containerId")
    def container_id(self) -> str:
        """
        The Network Peering Container ID.
        """
        return pulumi.get(self, "container_id")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> float:
        """
        Indicates the size in gigabytes of the servers root volume (AWS/GCP Only).
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter(name="encryptionAtRestProvider")
    def encryption_at_rest_provider(self) -> str:
        """
        Indicates whether Encryption at Rest is enabled or disabled.
        """
        return pulumi.get(self, "encryption_at_rest_provider")

    @property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetClustersResultLabelResult']:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="mongoDbMajorVersion")
    def mongo_db_major_version(self) -> str:
        """
        Indicates the version of the cluster to deploy.
        """
        return pulumi.get(self, "mongo_db_major_version")

    @property
    @pulumi.getter(name="mongoDbVersion")
    def mongo_db_version(self) -> str:
        """
        Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.
        """
        return pulumi.get(self, "mongo_db_version")

    @property
    @pulumi.getter(name="mongoUri")
    def mongo_uri(self) -> str:
        """
        Base connection string for the cluster. Atlas only displays this field after the cluster is operational, not while it builds the cluster.
        """
        return pulumi.get(self, "mongo_uri")

    @property
    @pulumi.getter(name="mongoUriUpdated")
    def mongo_uri_updated(self) -> str:
        """
        Lists when the connection string was last updated. The connection string changes, for example, if you change a replica set to a sharded cluster.
        """
        return pulumi.get(self, "mongo_uri_updated")

    @property
    @pulumi.getter(name="mongoUriWithOptions")
    def mongo_uri_with_options(self) -> str:
        """
        Describes connection string for connecting to the Atlas cluster. Includes the replicaSet, ssl, and authSource query parameters in the connection string with values appropriate for the cluster.
        """
        return pulumi.get(self, "mongo_uri_with_options")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the current plugin
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> int:
        """
        Number of shards to deploy in the specified zone.
        """
        return pulumi.get(self, "num_shards")

    @property
    @pulumi.getter
    def paused(self) -> bool:
        """
        Flag that indicates whether the cluster is paused or not.
        """
        return pulumi.get(self, "paused")

    @property
    @pulumi.getter(name="pitEnabled")
    def pit_enabled(self) -> bool:
        """
        Flag that indicates if the cluster uses Continuous Cloud Backup.
        """
        return pulumi.get(self, "pit_enabled")

    @property
    @pulumi.getter(name="providerAutoScalingComputeMaxInstanceSize")
    def provider_auto_scaling_compute_max_instance_size(self) -> str:
        """
        Maximum instance size to which your cluster can automatically scale.
        """
        return pulumi.get(self, "provider_auto_scaling_compute_max_instance_size")

    @property
    @pulumi.getter(name="providerAutoScalingComputeMinInstanceSize")
    def provider_auto_scaling_compute_min_instance_size(self) -> str:
        """
        Minimum instance size to which your cluster can automatically scale.
        """
        return pulumi.get(self, "provider_auto_scaling_compute_min_instance_size")

    @property
    @pulumi.getter(name="providerBackupEnabled")
    def provider_backup_enabled(self) -> bool:
        """
        Flag indicating if the cluster uses Cloud Backup Snapshots for backups. **DEPRECATED** Use `cloud_backup` instead.
        """
        return pulumi.get(self, "provider_backup_enabled")

    @property
    @pulumi.getter(name="providerDiskIops")
    def provider_disk_iops(self) -> int:
        """
        Indicates the maximum input/output operations per second (IOPS) the system can perform. The possible values depend on the selected providerSettings.instanceSizeName and diskSizeGB.
        """
        return pulumi.get(self, "provider_disk_iops")

    @property
    @pulumi.getter(name="providerDiskTypeName")
    def provider_disk_type_name(self) -> str:
        """
        Describes Azure disk type of the servers root volume (Azure Only).
        """
        return pulumi.get(self, "provider_disk_type_name")

    @property
    @pulumi.getter(name="providerEncryptEbsVolume")
    def provider_encrypt_ebs_volume(self) -> bool:
        """
        **(DEPRECATED)** Indicates whether the Amazon EBS encryption is enabled. This feature encrypts the servers root volume for both data at rest within the volume and data moving between the volume and the instance. By default this attribute is always enabled, per deprecation process showing the real value at `provider_encrypt_ebs_volume_flag` computed attribute.
        """
        return pulumi.get(self, "provider_encrypt_ebs_volume")

    @property
    @pulumi.getter(name="providerInstanceSizeName")
    def provider_instance_size_name(self) -> str:
        """
        Atlas provides different instance sizes, each with a default storage capacity and RAM size.
        """
        return pulumi.get(self, "provider_instance_size_name")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Indicates the cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter(name="providerRegionName")
    def provider_region_name(self) -> str:
        """
        Indicates Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases. Requires the Atlas Region name, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        """
        return pulumi.get(self, "provider_region_name")

    @property
    @pulumi.getter(name="providerVolumeType")
    def provider_volume_type(self) -> str:
        """
        Indicates the type of the volume. The possible values are: `STANDARD` and `PROVISIONED`.
        """
        return pulumi.get(self, "provider_volume_type")

    @property
    @pulumi.getter(name="replicationFactor")
    def replication_factor(self) -> int:
        """
        (Deprecated) Number of replica set members. Each member keeps a copy of your databases, providing high availability and data redundancy. The possible values are 3, 5, or 7. The default value is 3.
        """
        return pulumi.get(self, "replication_factor")

    @property
    @pulumi.getter(name="replicationSpecs")
    def replication_specs(self) -> Sequence['outputs.GetClustersResultReplicationSpecResult']:
        """
        Configuration for cluster regions.  See Replication Spec below for more details.
        """
        return pulumi.get(self, "replication_specs")

    @property
    @pulumi.getter(name="snapshotBackupPolicies")
    def snapshot_backup_policies(self) -> Sequence['outputs.GetClustersResultSnapshotBackupPolicyResult']:
        """
        current snapshot schedule and retention settings for the cluster.
        """
        return pulumi.get(self, "snapshot_backup_policies")

    @property
    @pulumi.getter(name="srvAddress")
    def srv_address(self) -> str:
        """
        Connection string for connecting to the Atlas cluster. The +srv modifier forces the connection to use TLS/SSL. See the mongoURI for additional options.
        """
        return pulumi.get(self, "srv_address")

    @property
    @pulumi.getter(name="stateName")
    def state_name(self) -> str:
        """
        Indicates the current state of the cluster. The possible states are:
        - IDLE
        - CREATING
        - UPDATING
        - DELETING
        - DELETED
        - REPAIRING
        """
        return pulumi.get(self, "state_name")

    @property
    @pulumi.getter(name="versionReleaseSystem")
    def version_release_system(self) -> str:
        """
        Release cadence that Atlas uses for this cluster.
        """
        return pulumi.get(self, "version_release_system")


@pulumi.output_type
class GetClustersResultAdvancedConfigurationResult(dict):
    def __init__(__self__, *,
                 default_read_concern: str,
                 default_write_concern: str,
                 fail_index_key_too_long: bool,
                 javascript_enabled: bool,
                 minimum_enabled_tls_protocol: str,
                 no_table_scan: bool,
                 oplog_size_mb: int,
                 sample_refresh_interval_bi_connector: int,
                 sample_size_bi_connector: int):
        """
        :param str default_read_concern: [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        :param str default_write_concern: [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        :param bool fail_index_key_too_long: When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        :param bool javascript_enabled: When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        :param str minimum_enabled_tls_protocol: Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        :param bool no_table_scan: When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        :param int oplog_size_mb: The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        :param int sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param int sample_size_bi_connector: Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        pulumi.set(__self__, "default_read_concern", default_read_concern)
        pulumi.set(__self__, "default_write_concern", default_write_concern)
        pulumi.set(__self__, "fail_index_key_too_long", fail_index_key_too_long)
        pulumi.set(__self__, "javascript_enabled", javascript_enabled)
        pulumi.set(__self__, "minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        pulumi.set(__self__, "no_table_scan", no_table_scan)
        pulumi.set(__self__, "oplog_size_mb", oplog_size_mb)
        pulumi.set(__self__, "sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        pulumi.set(__self__, "sample_size_bi_connector", sample_size_bi_connector)

    @property
    @pulumi.getter(name="defaultReadConcern")
    def default_read_concern(self) -> str:
        """
        [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        """
        return pulumi.get(self, "default_read_concern")

    @property
    @pulumi.getter(name="defaultWriteConcern")
    def default_write_concern(self) -> str:
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        return pulumi.get(self, "default_write_concern")

    @property
    @pulumi.getter(name="failIndexKeyTooLong")
    def fail_index_key_too_long(self) -> bool:
        """
        When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        """
        return pulumi.get(self, "fail_index_key_too_long")

    @property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> bool:
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        return pulumi.get(self, "javascript_enabled")

    @property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> str:
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> bool:
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        return pulumi.get(self, "no_table_scan")

    @property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> int:
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        return pulumi.get(self, "oplog_size_mb")

    @property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> int:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> int:
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_size_bi_connector")


@pulumi.output_type
class GetClustersResultBiConnectorConfigResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 read_preference: str):
        """
        :param bool enabled: Indicates whether or not BI Connector for Atlas is enabled on the cluster.
        :param str read_preference: Indicates the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "read_preference", read_preference)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Indicates whether or not BI Connector for Atlas is enabled on the cluster.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> str:
        """
        Indicates the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        return pulumi.get(self, "read_preference")


@pulumi.output_type
class GetClustersResultConnectionStringResult(dict):
    def __init__(__self__, *,
                 aws_private_link: Mapping[str, Any],
                 aws_private_link_srv: Mapping[str, Any],
                 private: str,
                 private_endpoints: Sequence['outputs.GetClustersResultConnectionStringPrivateEndpointResult'],
                 private_srv: str,
                 standard: str,
                 standard_srv: str):
        pulumi.set(__self__, "aws_private_link", aws_private_link)
        pulumi.set(__self__, "aws_private_link_srv", aws_private_link_srv)
        pulumi.set(__self__, "private", private)
        pulumi.set(__self__, "private_endpoints", private_endpoints)
        pulumi.set(__self__, "private_srv", private_srv)
        pulumi.set(__self__, "standard", standard)
        pulumi.set(__self__, "standard_srv", standard_srv)

    @property
    @pulumi.getter(name="awsPrivateLink")
    def aws_private_link(self) -> Mapping[str, Any]:
        return pulumi.get(self, "aws_private_link")

    @property
    @pulumi.getter(name="awsPrivateLinkSrv")
    def aws_private_link_srv(self) -> Mapping[str, Any]:
        return pulumi.get(self, "aws_private_link_srv")

    @property
    @pulumi.getter
    def private(self) -> str:
        return pulumi.get(self, "private")

    @property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Sequence['outputs.GetClustersResultConnectionStringPrivateEndpointResult']:
        return pulumi.get(self, "private_endpoints")

    @property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> str:
        return pulumi.get(self, "private_srv")

    @property
    @pulumi.getter
    def standard(self) -> str:
        return pulumi.get(self, "standard")

    @property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> str:
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class GetClustersResultConnectionStringPrivateEndpointResult(dict):
    def __init__(__self__, *,
                 connection_string: str,
                 endpoints: Sequence['outputs.GetClustersResultConnectionStringPrivateEndpointEndpointResult'],
                 srv_connection_string: str,
                 type: str):
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "srv_connection_string", srv_connection_string)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> str:
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def endpoints(self) -> Sequence['outputs.GetClustersResultConnectionStringPrivateEndpointEndpointResult']:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> str:
        return pulumi.get(self, "srv_connection_string")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetClustersResultConnectionStringPrivateEndpointEndpointResult(dict):
    def __init__(__self__, *,
                 endpoint_id: str,
                 provider_name: str,
                 region: str):
        """
        :param str provider_name: Indicates the cloud service provider on which the servers are provisioned.
        """
        pulumi.set(__self__, "endpoint_id", endpoint_id)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> str:
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Indicates the cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetClustersResultLabelResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that was set.
        :param str value: The value that represents the key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that was set.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that represents the key.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClustersResultReplicationSpecResult(dict):
    def __init__(__self__, *,
                 id: str,
                 num_shards: int,
                 regions_configs: Sequence['outputs.GetClustersResultReplicationSpecRegionsConfigResult'],
                 zone_name: str):
        """
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster.
        :param int num_shards: Number of shards to deploy in the specified zone.
        :param Sequence['GetClustersResultReplicationSpecRegionsConfigArgs'] regions_configs: Describes the physical location of the region. Each regionsConfig document describes the regions priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        :param str zone_name: Indicates the n ame for the zone in a Global Cluster.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "num_shards", num_shards)
        pulumi.set(__self__, "regions_configs", regions_configs)
        pulumi.set(__self__, "zone_name", zone_name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifer of the replication document for a zone in a Global Cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> int:
        """
        Number of shards to deploy in the specified zone.
        """
        return pulumi.get(self, "num_shards")

    @property
    @pulumi.getter(name="regionsConfigs")
    def regions_configs(self) -> Sequence['outputs.GetClustersResultReplicationSpecRegionsConfigResult']:
        """
        Describes the physical location of the region. Each regionsConfig document describes the regions priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        """
        return pulumi.get(self, "regions_configs")

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> str:
        """
        Indicates the n ame for the zone in a Global Cluster.
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class GetClustersResultReplicationSpecRegionsConfigResult(dict):
    def __init__(__self__, *,
                 analytics_nodes: int,
                 electable_nodes: int,
                 priority: int,
                 read_only_nodes: int,
                 region_name: str):
        """
        :param int analytics_nodes: Indicates the number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary.
        :param int electable_nodes: Number of electable nodes for Atlas to deploy to the region.
        :param int priority: Election priority of the region. For regions with only read-only nodes, set this value to 0.
        :param int read_only_nodes: Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        :param str region_name: Name for the region specified.
        """
        pulumi.set(__self__, "analytics_nodes", analytics_nodes)
        pulumi.set(__self__, "electable_nodes", electable_nodes)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "read_only_nodes", read_only_nodes)
        pulumi.set(__self__, "region_name", region_name)

    @property
    @pulumi.getter(name="analyticsNodes")
    def analytics_nodes(self) -> int:
        """
        Indicates the number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary.
        """
        return pulumi.get(self, "analytics_nodes")

    @property
    @pulumi.getter(name="electableNodes")
    def electable_nodes(self) -> int:
        """
        Number of electable nodes for Atlas to deploy to the region.
        """
        return pulumi.get(self, "electable_nodes")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Election priority of the region. For regions with only read-only nodes, set this value to 0.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="readOnlyNodes")
    def read_only_nodes(self) -> int:
        """
        Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        """
        return pulumi.get(self, "read_only_nodes")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        Name for the region specified.
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class GetClustersResultSnapshotBackupPolicyResult(dict):
    def __init__(__self__, *,
                 cluster_id: str,
                 cluster_name: str,
                 next_snapshot: str,
                 policies: Sequence['outputs.GetClustersResultSnapshotBackupPolicyPolicyResult'],
                 reference_hour_of_day: int,
                 reference_minute_of_hour: int,
                 restore_window_days: int,
                 update_snapshots: bool):
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "next_snapshot", next_snapshot)
        pulumi.set(__self__, "policies", policies)
        pulumi.set(__self__, "reference_hour_of_day", reference_hour_of_day)
        pulumi.set(__self__, "reference_minute_of_hour", reference_minute_of_hour)
        pulumi.set(__self__, "restore_window_days", restore_window_days)
        pulumi.set(__self__, "update_snapshots", update_snapshots)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="nextSnapshot")
    def next_snapshot(self) -> str:
        return pulumi.get(self, "next_snapshot")

    @property
    @pulumi.getter
    def policies(self) -> Sequence['outputs.GetClustersResultSnapshotBackupPolicyPolicyResult']:
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="referenceHourOfDay")
    def reference_hour_of_day(self) -> int:
        return pulumi.get(self, "reference_hour_of_day")

    @property
    @pulumi.getter(name="referenceMinuteOfHour")
    def reference_minute_of_hour(self) -> int:
        return pulumi.get(self, "reference_minute_of_hour")

    @property
    @pulumi.getter(name="restoreWindowDays")
    def restore_window_days(self) -> int:
        return pulumi.get(self, "restore_window_days")

    @property
    @pulumi.getter(name="updateSnapshots")
    def update_snapshots(self) -> bool:
        return pulumi.get(self, "update_snapshots")


@pulumi.output_type
class GetClustersResultSnapshotBackupPolicyPolicyResult(dict):
    def __init__(__self__, *,
                 policy_items: Sequence['outputs.GetClustersResultSnapshotBackupPolicyPolicyPolicyItemResult']):
        pulumi.set(__self__, "policy_items", policy_items)

    @property
    @pulumi.getter(name="policyItems")
    def policy_items(self) -> Sequence['outputs.GetClustersResultSnapshotBackupPolicyPolicyPolicyItemResult']:
        return pulumi.get(self, "policy_items")


@pulumi.output_type
class GetClustersResultSnapshotBackupPolicyPolicyPolicyItemResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 retention_unit: str,
                 retention_value: int):
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetCustomDbRoleActionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 resources: Sequence['outputs.GetCustomDbRoleActionResourceResult']):
        """
        :param str action: (Required) Name of the privilege action. For a complete list of actions available in the Atlas API, see Custom Role Actions.
        :param Sequence['GetCustomDbRoleActionResourceArgs'] resources: (Required) Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        (Required) Name of the privilege action. For a complete list of actions available in the Atlas API, see Custom Role Actions.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetCustomDbRoleActionResourceResult']:
        """
        (Required) Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetCustomDbRoleActionResourceResult(dict):
    def __init__(__self__, *,
                 cluster: bool,
                 collection_name: str,
                 database_name: str):
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "database_name", database_name)

    @property
    @pulumi.getter
    def cluster(self) -> bool:
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> str:
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        return pulumi.get(self, "database_name")


@pulumi.output_type
class GetCustomDbRoleInheritedRoleResult(dict):
    def __init__(__self__, *,
                 database_name: str,
                 role_name: str):
        """
        :param str role_name: Name of the custom role.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        """
        Name of the custom role.
        """
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetCustomDbRolesResultResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetCustomDbRolesResultActionResult'],
                 inherited_roles: Sequence['outputs.GetCustomDbRolesResultInheritedRoleResult'],
                 role_name: str):
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "inherited_roles", inherited_roles)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetCustomDbRolesResultActionResult']:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="inheritedRoles")
    def inherited_roles(self) -> Sequence['outputs.GetCustomDbRolesResultInheritedRoleResult']:
        return pulumi.get(self, "inherited_roles")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetCustomDbRolesResultActionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 resources: Sequence['outputs.GetCustomDbRolesResultActionResourceResult']):
        """
        :param str action: (Required) Name of the privilege action. For a complete list of actions available in the Atlas API, see Custom Role Actions.
        :param Sequence['GetCustomDbRolesResultActionResourceArgs'] resources: (Required) Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        (Required) Name of the privilege action. For a complete list of actions available in the Atlas API, see Custom Role Actions.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetCustomDbRolesResultActionResourceResult']:
        """
        (Required) Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetCustomDbRolesResultActionResourceResult(dict):
    def __init__(__self__, *,
                 cluster: bool,
                 collection_name: str,
                 database_name: str):
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "database_name", database_name)

    @property
    @pulumi.getter
    def cluster(self) -> bool:
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> str:
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        return pulumi.get(self, "database_name")


@pulumi.output_type
class GetCustomDbRolesResultInheritedRoleResult(dict):
    def __init__(__self__, *,
                 database_name: str,
                 role_name: str):
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetDataLakeAwResult(dict):
    def __init__(__self__, *,
                 external_id: str,
                 iam_assumed_role_arn: str,
                 iam_user_arn: str,
                 role_id: str,
                 test_s3_bucket: str):
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "iam_assumed_role_arn", iam_assumed_role_arn)
        pulumi.set(__self__, "iam_user_arn", iam_user_arn)
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "test_s3_bucket", test_s3_bucket)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> str:
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="iamAssumedRoleArn")
    def iam_assumed_role_arn(self) -> str:
        return pulumi.get(self, "iam_assumed_role_arn")

    @property
    @pulumi.getter(name="iamUserArn")
    def iam_user_arn(self) -> str:
        return pulumi.get(self, "iam_user_arn")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> str:
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="testS3Bucket")
    def test_s3_bucket(self) -> str:
        return pulumi.get(self, "test_s3_bucket")


@pulumi.output_type
class GetDataLakeDataProcessRegionResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 region: str):
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetDataLakeStorageDatabaseResult(dict):
    def __init__(__self__, *,
                 collections: Sequence['outputs.GetDataLakeStorageDatabaseCollectionResult'],
                 max_wildcard_collections: int,
                 name: str,
                 views: Sequence['outputs.GetDataLakeStorageDatabaseViewResult']):
        """
        :param str name: Name of the data lake.
        """
        pulumi.set(__self__, "collections", collections)
        pulumi.set(__self__, "max_wildcard_collections", max_wildcard_collections)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "views", views)

    @property
    @pulumi.getter
    def collections(self) -> Sequence['outputs.GetDataLakeStorageDatabaseCollectionResult']:
        return pulumi.get(self, "collections")

    @property
    @pulumi.getter(name="maxWildcardCollections")
    def max_wildcard_collections(self) -> int:
        return pulumi.get(self, "max_wildcard_collections")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the data lake.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def views(self) -> Sequence['outputs.GetDataLakeStorageDatabaseViewResult']:
        return pulumi.get(self, "views")


@pulumi.output_type
class GetDataLakeStorageDatabaseCollectionResult(dict):
    def __init__(__self__, *,
                 data_sources: Sequence['outputs.GetDataLakeStorageDatabaseCollectionDataSourceResult'],
                 name: str):
        """
        :param str name: Name of the data lake.
        """
        pulumi.set(__self__, "data_sources", data_sources)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Sequence['outputs.GetDataLakeStorageDatabaseCollectionDataSourceResult']:
        return pulumi.get(self, "data_sources")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the data lake.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDataLakeStorageDatabaseCollectionDataSourceResult(dict):
    def __init__(__self__, *,
                 default_format: str,
                 path: str,
                 store_name: str):
        pulumi.set(__self__, "default_format", default_format)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "store_name", store_name)

    @property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> str:
        return pulumi.get(self, "default_format")

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="storeName")
    def store_name(self) -> str:
        return pulumi.get(self, "store_name")


@pulumi.output_type
class GetDataLakeStorageDatabaseViewResult(dict):
    def __init__(__self__, *,
                 name: str,
                 pipeline: str,
                 source: str):
        """
        :param str name: Name of the data lake.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pipeline", pipeline)
        pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the data lake.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def pipeline(self) -> str:
        return pulumi.get(self, "pipeline")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")


@pulumi.output_type
class GetDataLakeStorageStoreResult(dict):
    def __init__(__self__, *,
                 additional_storage_classes: Sequence[str],
                 bucket: str,
                 delimiter: str,
                 include_tags: bool,
                 name: str,
                 prefix: str,
                 provider: str,
                 region: str):
        """
        :param str name: Name of the data lake.
        """
        pulumi.set(__self__, "additional_storage_classes", additional_storage_classes)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "delimiter", delimiter)
        pulumi.set(__self__, "include_tags", include_tags)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="additionalStorageClasses")
    def additional_storage_classes(self) -> Sequence[str]:
        return pulumi.get(self, "additional_storage_classes")

    @property
    @pulumi.getter
    def bucket(self) -> str:
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def delimiter(self) -> str:
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="includeTags")
    def include_tags(self) -> bool:
        return pulumi.get(self, "include_tags")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the data lake.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def provider(self) -> str:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetDataLakesResultResult(dict):
    def __init__(__self__, *,
                 aws: Sequence['outputs.GetDataLakesResultAwResult'],
                 data_process_regions: Sequence['outputs.GetDataLakesResultDataProcessRegionResult'],
                 hostnames: Sequence[str],
                 name: str,
                 project_id: str,
                 state: str,
                 storage_databases: Sequence['outputs.GetDataLakesResultStorageDatabaseResult'],
                 storage_stores: Sequence['outputs.GetDataLakesResultStorageStoreResult']):
        """
        :param Sequence['GetDataLakesResultDataProcessRegionArgs'] data_process_regions: The cloud provider region to which Atlas Data Lake routes client connections for data processing.
               * `data_process_region.0.cloud_provider` - Name of the cloud service provider.
               * `data_process_region.0.region` -Name of the region to which Data Lake routes client connections for data processing.
        :param Sequence[str] hostnames: The list of hostnames assigned to the Atlas Data Lake. Each string in the array is a hostname assigned to the Atlas Data Lake.
        :param str project_id: The unique ID for the project to get all data lakes.
        :param str state: Current state of the Atlas Data Lake:
        :param Sequence['GetDataLakesResultStorageDatabaseArgs'] storage_databases: Configuration details for mapping each data store to queryable databases and collections.
               * `storage_databases.#.name` - Name of the database to which Data Lake maps the data contained in the data store.
               * `storage_databases.#.collections` -     Array of objects where each object represents a collection and data sources that map to a [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#mongodb-datalakeconf-datalakeconf.stores) data store.
               * `storage_databases.#.collections.#.name` - Name of the collection.
               * `storage_databases.#.collections.#.data_sources` -     Array of objects where each object represents a stores data store to map with the collection.
               * `storage_databases.#.collections.#.data_sources.#.store_name` -     Name of a data store to map to the `<collection>`.
               * `storage_databases.#.collections.#.data_sources.#.default_format` - Default format that Data Lake assumes if it encounters a file without an extension while searching the storeName.
               * `storage_databases.#.collections.#.data_sources.#.path` - Controls how Atlas Data Lake searches for and parses files in the storeName before mapping them to the `<collection>`.
               * `storage_databases.#.views` -     Array of objects where each object represents an [aggregation pipeline](https://docs.mongodb.com/manual/core/aggregation-pipeline/#id1) on a collection.
               * `storage_databases.#.views.#.name` - Name of the view.
               * `storage_databases.#.views.#.source` -  Name of the source collection for the view.
               * `storage_databases.#.views.#.pipeline`- Aggregation pipeline stage(s) to apply to the source collection.
        :param Sequence['GetDataLakesResultStorageStoreArgs'] storage_stores: Each object in the array represents a data store. Data Lake uses the storage.databases configuration details to map data in each data store to queryable databases and collections.
               * `storage_stores.#.name` - Name of the data store.
               * `storage_stores.#.provider` - Defines where the data is stored.
               * `storage_stores.#.region` - Name of the AWS region in which the S3 bucket is hosted.
               * `storage_stores.#.bucket` - Name of the AWS S3 bucket.
               * `storage_stores.#.prefix` - Prefix Data Lake applies when searching for files in the S3 bucket .
               * `storage_stores.#.delimiter` - The delimiter that separates `storage_databases.#.collections.#.data_sources.#.path` segments in the data store.
               * `storage_stores.#.include_tags` - Determines whether or not to use S3 tags on the files in the given path as additional partition attributes.
        """
        pulumi.set(__self__, "aws", aws)
        pulumi.set(__self__, "data_process_regions", data_process_regions)
        pulumi.set(__self__, "hostnames", hostnames)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "storage_databases", storage_databases)
        pulumi.set(__self__, "storage_stores", storage_stores)

    @property
    @pulumi.getter
    def aws(self) -> Sequence['outputs.GetDataLakesResultAwResult']:
        return pulumi.get(self, "aws")

    @property
    @pulumi.getter(name="dataProcessRegions")
    def data_process_regions(self) -> Sequence['outputs.GetDataLakesResultDataProcessRegionResult']:
        """
        The cloud provider region to which Atlas Data Lake routes client connections for data processing.
        * `data_process_region.0.cloud_provider` - Name of the cloud service provider.
        * `data_process_region.0.region` -Name of the region to which Data Lake routes client connections for data processing.
        """
        return pulumi.get(self, "data_process_regions")

    @property
    @pulumi.getter
    def hostnames(self) -> Sequence[str]:
        """
        The list of hostnames assigned to the Atlas Data Lake. Each string in the array is a hostname assigned to the Atlas Data Lake.
        """
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project to get all data lakes.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Current state of the Atlas Data Lake:
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="storageDatabases")
    def storage_databases(self) -> Sequence['outputs.GetDataLakesResultStorageDatabaseResult']:
        """
        Configuration details for mapping each data store to queryable databases and collections.
        * `storage_databases.#.name` - Name of the database to which Data Lake maps the data contained in the data store.
        * `storage_databases.#.collections` -     Array of objects where each object represents a collection and data sources that map to a [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#mongodb-datalakeconf-datalakeconf.stores) data store.
        * `storage_databases.#.collections.#.name` - Name of the collection.
        * `storage_databases.#.collections.#.data_sources` -     Array of objects where each object represents a stores data store to map with the collection.
        * `storage_databases.#.collections.#.data_sources.#.store_name` -     Name of a data store to map to the `<collection>`.
        * `storage_databases.#.collections.#.data_sources.#.default_format` - Default format that Data Lake assumes if it encounters a file without an extension while searching the storeName.
        * `storage_databases.#.collections.#.data_sources.#.path` - Controls how Atlas Data Lake searches for and parses files in the storeName before mapping them to the `<collection>`.
        * `storage_databases.#.views` -     Array of objects where each object represents an [aggregation pipeline](https://docs.mongodb.com/manual/core/aggregation-pipeline/#id1) on a collection.
        * `storage_databases.#.views.#.name` - Name of the view.
        * `storage_databases.#.views.#.source` -  Name of the source collection for the view.
        * `storage_databases.#.views.#.pipeline`- Aggregation pipeline stage(s) to apply to the source collection.
        """
        return pulumi.get(self, "storage_databases")

    @property
    @pulumi.getter(name="storageStores")
    def storage_stores(self) -> Sequence['outputs.GetDataLakesResultStorageStoreResult']:
        """
        Each object in the array represents a data store. Data Lake uses the storage.databases configuration details to map data in each data store to queryable databases and collections.
        * `storage_stores.#.name` - Name of the data store.
        * `storage_stores.#.provider` - Defines where the data is stored.
        * `storage_stores.#.region` - Name of the AWS region in which the S3 bucket is hosted.
        * `storage_stores.#.bucket` - Name of the AWS S3 bucket.
        * `storage_stores.#.prefix` - Prefix Data Lake applies when searching for files in the S3 bucket .
        * `storage_stores.#.delimiter` - The delimiter that separates `storage_databases.#.collections.#.data_sources.#.path` segments in the data store.
        * `storage_stores.#.include_tags` - Determines whether or not to use S3 tags on the files in the given path as additional partition attributes.
        """
        return pulumi.get(self, "storage_stores")


@pulumi.output_type
class GetDataLakesResultAwResult(dict):
    def __init__(__self__, *,
                 external_id: str,
                 iam_assumed_role_arn: str,
                 iam_user_arn: str,
                 role_id: str,
                 test_s3_bucket: str):
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "iam_assumed_role_arn", iam_assumed_role_arn)
        pulumi.set(__self__, "iam_user_arn", iam_user_arn)
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "test_s3_bucket", test_s3_bucket)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> str:
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="iamAssumedRoleArn")
    def iam_assumed_role_arn(self) -> str:
        return pulumi.get(self, "iam_assumed_role_arn")

    @property
    @pulumi.getter(name="iamUserArn")
    def iam_user_arn(self) -> str:
        return pulumi.get(self, "iam_user_arn")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> str:
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="testS3Bucket")
    def test_s3_bucket(self) -> str:
        return pulumi.get(self, "test_s3_bucket")


@pulumi.output_type
class GetDataLakesResultDataProcessRegionResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 region: str):
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetDataLakesResultStorageDatabaseResult(dict):
    def __init__(__self__, *,
                 collections: Sequence['outputs.GetDataLakesResultStorageDatabaseCollectionResult'],
                 max_wildcard_collections: int,
                 name: str,
                 views: Sequence['outputs.GetDataLakesResultStorageDatabaseViewResult']):
        pulumi.set(__self__, "collections", collections)
        pulumi.set(__self__, "max_wildcard_collections", max_wildcard_collections)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "views", views)

    @property
    @pulumi.getter
    def collections(self) -> Sequence['outputs.GetDataLakesResultStorageDatabaseCollectionResult']:
        return pulumi.get(self, "collections")

    @property
    @pulumi.getter(name="maxWildcardCollections")
    def max_wildcard_collections(self) -> int:
        return pulumi.get(self, "max_wildcard_collections")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def views(self) -> Sequence['outputs.GetDataLakesResultStorageDatabaseViewResult']:
        return pulumi.get(self, "views")


@pulumi.output_type
class GetDataLakesResultStorageDatabaseCollectionResult(dict):
    def __init__(__self__, *,
                 data_sources: Sequence['outputs.GetDataLakesResultStorageDatabaseCollectionDataSourceResult'],
                 name: str):
        pulumi.set(__self__, "data_sources", data_sources)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Sequence['outputs.GetDataLakesResultStorageDatabaseCollectionDataSourceResult']:
        return pulumi.get(self, "data_sources")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDataLakesResultStorageDatabaseCollectionDataSourceResult(dict):
    def __init__(__self__, *,
                 default_format: str,
                 path: str,
                 store_name: str):
        pulumi.set(__self__, "default_format", default_format)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "store_name", store_name)

    @property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> str:
        return pulumi.get(self, "default_format")

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="storeName")
    def store_name(self) -> str:
        return pulumi.get(self, "store_name")


@pulumi.output_type
class GetDataLakesResultStorageDatabaseViewResult(dict):
    def __init__(__self__, *,
                 name: str,
                 pipeline: str,
                 source: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pipeline", pipeline)
        pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def pipeline(self) -> str:
        return pulumi.get(self, "pipeline")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")


@pulumi.output_type
class GetDataLakesResultStorageStoreResult(dict):
    def __init__(__self__, *,
                 additional_storage_classes: Sequence[str],
                 bucket: str,
                 delimiter: str,
                 include_tags: bool,
                 name: str,
                 prefix: str,
                 provider: str,
                 region: str):
        pulumi.set(__self__, "additional_storage_classes", additional_storage_classes)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "delimiter", delimiter)
        pulumi.set(__self__, "include_tags", include_tags)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="additionalStorageClasses")
    def additional_storage_classes(self) -> Sequence[str]:
        return pulumi.get(self, "additional_storage_classes")

    @property
    @pulumi.getter
    def bucket(self) -> str:
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def delimiter(self) -> str:
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="includeTags")
    def include_tags(self) -> bool:
        return pulumi.get(self, "include_tags")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def provider(self) -> str:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetDatabaseUserLabelResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDatabaseUserRoleResult(dict):
    def __init__(__self__, *,
                 collection_name: str,
                 database_name: str,
                 role_name: str):
        """
        :param str collection_name: Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        :param str database_name: Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.
        """
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> str:
        """
        Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        """
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetDatabaseUserScopeResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str):
        """
        :param str name: Name of the role to grant.
        :param str type: Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the role to grant.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDatabaseUsersResultResult(dict):
    def __init__(__self__, *,
                 auth_database_name: str,
                 aws_iam_type: str,
                 labels: Sequence['outputs.GetDatabaseUsersResultLabelResult'],
                 ldap_auth_type: str,
                 project_id: str,
                 roles: Sequence['outputs.GetDatabaseUsersResultRoleResult'],
                 scopes: Sequence['outputs.GetDatabaseUsersResultScopeResult'],
                 username: str,
                 x509_type: str):
        """
        :param str auth_database_name: (Required) Database against which Atlas authenticates the user. A user must provide both a username and authentication database to log into MongoDB.
               Possible values include:
               * `admin` if `x509_type` and `aws_iam_type` and `ldap_auth_type` are omitted or NONE.
               * `$external` if:
               * `x509_type` is MANAGED or CUSTOMER, or
               * `aws_iam_type` is USER or ROLE.
        :param str aws_iam_type: The new database user authenticates with AWS IAM credentials. Default is `NONE`, `USER` means user has AWS IAM user credentials, `ROLE` - means user has credentials associated with an AWS IAM role.
        :param str ldap_auth_type: Method by which the provided username is authenticated. Default is `NONE`. Other valid values are: `USER`, `GROUP`.
        :param str project_id: The unique ID for the project to get all database users.
        :param Sequence['GetDatabaseUsersResultRoleArgs'] roles: List of users roles and the databases / collections on which the roles apply. A role allows the user to perform particular actions on the specified database. A role on the admin database can include privileges that apply to the other databases as well. See Roles below for more details.
        :param Sequence['GetDatabaseUsersResultScopeArgs'] scopes: Array of clusters and Atlas Data Lakes that this user has access to.
        :param str username: Username for authenticating to MongoDB.
        :param str x509_type: X.509 method by which the provided username is authenticated.
        """
        pulumi.set(__self__, "auth_database_name", auth_database_name)
        pulumi.set(__self__, "aws_iam_type", aws_iam_type)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "ldap_auth_type", ldap_auth_type)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "x509_type", x509_type)

    @property
    @pulumi.getter(name="authDatabaseName")
    def auth_database_name(self) -> str:
        """
        (Required) Database against which Atlas authenticates the user. A user must provide both a username and authentication database to log into MongoDB.
        Possible values include:
        * `admin` if `x509_type` and `aws_iam_type` and `ldap_auth_type` are omitted or NONE.
        * `$external` if:
        * `x509_type` is MANAGED or CUSTOMER, or
        * `aws_iam_type` is USER or ROLE.
        """
        return pulumi.get(self, "auth_database_name")

    @property
    @pulumi.getter(name="awsIamType")
    def aws_iam_type(self) -> str:
        """
        The new database user authenticates with AWS IAM credentials. Default is `NONE`, `USER` means user has AWS IAM user credentials, `ROLE` - means user has credentials associated with an AWS IAM role.
        """
        return pulumi.get(self, "aws_iam_type")

    @property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetDatabaseUsersResultLabelResult']:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="ldapAuthType")
    def ldap_auth_type(self) -> str:
        """
        Method by which the provided username is authenticated. Default is `NONE`. Other valid values are: `USER`, `GROUP`.
        """
        return pulumi.get(self, "ldap_auth_type")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project to get all database users.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def roles(self) -> Sequence['outputs.GetDatabaseUsersResultRoleResult']:
        """
        List of users roles and the databases / collections on which the roles apply. A role allows the user to perform particular actions on the specified database. A role on the admin database can include privileges that apply to the other databases as well. See Roles below for more details.
        """
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence['outputs.GetDatabaseUsersResultScopeResult']:
        """
        Array of clusters and Atlas Data Lakes that this user has access to.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username for authenticating to MongoDB.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="x509Type")
    def x509_type(self) -> str:
        """
        X.509 method by which the provided username is authenticated.
        """
        return pulumi.get(self, "x509_type")


@pulumi.output_type
class GetDatabaseUsersResultLabelResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDatabaseUsersResultRoleResult(dict):
    def __init__(__self__, *,
                 collection_name: str,
                 database_name: str,
                 role_name: str):
        """
        :param str collection_name: Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        :param str database_name: Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.
        """
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> str:
        """
        Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        """
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetDatabaseUsersResultScopeResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str):
        """
        :param str name: Name of the role to grant.
        :param str type: Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the role to grant.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetEventTriggerEventProcessorResult(dict):
    def __init__(__self__, *,
                 aws_eventbridges: Sequence['outputs.GetEventTriggerEventProcessorAwsEventbridgeResult']):
        pulumi.set(__self__, "aws_eventbridges", aws_eventbridges)

    @property
    @pulumi.getter(name="awsEventbridges")
    def aws_eventbridges(self) -> Sequence['outputs.GetEventTriggerEventProcessorAwsEventbridgeResult']:
        return pulumi.get(self, "aws_eventbridges")


@pulumi.output_type
class GetEventTriggerEventProcessorAwsEventbridgeResult(dict):
    def __init__(__self__, *,
                 config_account_id: str,
                 config_region: str):
        pulumi.set(__self__, "config_account_id", config_account_id)
        pulumi.set(__self__, "config_region", config_region)

    @property
    @pulumi.getter(name="configAccountId")
    def config_account_id(self) -> str:
        return pulumi.get(self, "config_account_id")

    @property
    @pulumi.getter(name="configRegion")
    def config_region(self) -> str:
        return pulumi.get(self, "config_region")


@pulumi.output_type
class GetEventTriggersResultResult(dict):
    def __init__(__self__, *,
                 config_collection: str,
                 config_database: str,
                 config_full_document: bool,
                 config_full_document_before: bool,
                 config_match: str,
                 config_operation_type: str,
                 config_operation_types: Sequence[str],
                 config_project: str,
                 config_providers: Sequence[str],
                 config_schedule: str,
                 config_schedule_type: str,
                 config_service_id: str,
                 disabled: bool,
                 event_processors: Sequence['outputs.GetEventTriggersResultEventProcessorResult'],
                 function_id: str,
                 function_name: str,
                 name: str,
                 trigger_id: str,
                 type: str,
                 unordered: bool):
        """
        :param str config_collection: The name of the MongoDB collection that the trigger watches for change events.
        :param str config_database: The name of the MongoDB database that contains the watched collection.
        :param bool config_full_document: If true, indicates that `UPDATE` change events should include the most current [majority-committed](https://docs.mongodb.com/manual/reference/read-concern-majority/) version of the modified document in the fullDocument field.
        :param str config_match: A [$match](https://docs.mongodb.com/manual/reference/operator/aggregation/match/) expression document that MongoDB Realm includes in the underlying change stream pipeline for the trigger.
        :param str config_operation_type: The [authentication operation type](https://docs.mongodb.com/realm/triggers/authentication-triggers/#std-label-authentication-event-operation-types) to listen for.
        :param Sequence[str] config_operation_types: The [database event operation types](https://docs.mongodb.com/realm/triggers/database-triggers/#std-label-database-events) to listen for.
        :param str config_project: A [$project](https://docs.mongodb.com/manual/reference/operator/aggregation/project/) expression document that Realm uses to filter the fields that appear in change event objects.
        :param Sequence[str] config_providers: A list of one or more [authentication provider](https://docs.mongodb.com/realm/authentication/providers/) id values. The trigger will only listen for authentication events produced by these providers.
        :param str config_schedule: A [cron expression](https://docs.mongodb.com/realm/triggers/cron-expressions/) that defines the trigger schedule.
        :param str config_service_id: The ID of the MongoDB Service associated with the trigger.
        :param bool disabled: Status of a trigger.
        :param Sequence['GetEventTriggersResultEventProcessorArgs'] event_processors: An object where each field name is an event processor ID and each value is an object that configures its corresponding event processor.
               * `event_processors.0.aws_eventbridge.config_account_id` - AWS Account ID.
               * `event_processors.0.aws_eventbridge.config_region` - Region of AWS Account.
        :param str function_id: The ID of the function associated with the trigger.
        :param str function_name: The name of the function associated with the trigger.
        :param str name: The name of the trigger.
        :param str type: The type of the trigger. Possible Values: `DATABASE`, `AUTHENTICATION`
        :param bool unordered: Sort order for `DATABASE` type.
        """
        pulumi.set(__self__, "config_collection", config_collection)
        pulumi.set(__self__, "config_database", config_database)
        pulumi.set(__self__, "config_full_document", config_full_document)
        pulumi.set(__self__, "config_full_document_before", config_full_document_before)
        pulumi.set(__self__, "config_match", config_match)
        pulumi.set(__self__, "config_operation_type", config_operation_type)
        pulumi.set(__self__, "config_operation_types", config_operation_types)
        pulumi.set(__self__, "config_project", config_project)
        pulumi.set(__self__, "config_providers", config_providers)
        pulumi.set(__self__, "config_schedule", config_schedule)
        pulumi.set(__self__, "config_schedule_type", config_schedule_type)
        pulumi.set(__self__, "config_service_id", config_service_id)
        pulumi.set(__self__, "disabled", disabled)
        pulumi.set(__self__, "event_processors", event_processors)
        pulumi.set(__self__, "function_id", function_id)
        pulumi.set(__self__, "function_name", function_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "trigger_id", trigger_id)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "unordered", unordered)

    @property
    @pulumi.getter(name="configCollection")
    def config_collection(self) -> str:
        """
        The name of the MongoDB collection that the trigger watches for change events.
        """
        return pulumi.get(self, "config_collection")

    @property
    @pulumi.getter(name="configDatabase")
    def config_database(self) -> str:
        """
        The name of the MongoDB database that contains the watched collection.
        """
        return pulumi.get(self, "config_database")

    @property
    @pulumi.getter(name="configFullDocument")
    def config_full_document(self) -> bool:
        """
        If true, indicates that `UPDATE` change events should include the most current [majority-committed](https://docs.mongodb.com/manual/reference/read-concern-majority/) version of the modified document in the fullDocument field.
        """
        return pulumi.get(self, "config_full_document")

    @property
    @pulumi.getter(name="configFullDocumentBefore")
    def config_full_document_before(self) -> bool:
        return pulumi.get(self, "config_full_document_before")

    @property
    @pulumi.getter(name="configMatch")
    def config_match(self) -> str:
        """
        A [$match](https://docs.mongodb.com/manual/reference/operator/aggregation/match/) expression document that MongoDB Realm includes in the underlying change stream pipeline for the trigger.
        """
        return pulumi.get(self, "config_match")

    @property
    @pulumi.getter(name="configOperationType")
    def config_operation_type(self) -> str:
        """
        The [authentication operation type](https://docs.mongodb.com/realm/triggers/authentication-triggers/#std-label-authentication-event-operation-types) to listen for.
        """
        return pulumi.get(self, "config_operation_type")

    @property
    @pulumi.getter(name="configOperationTypes")
    def config_operation_types(self) -> Sequence[str]:
        """
        The [database event operation types](https://docs.mongodb.com/realm/triggers/database-triggers/#std-label-database-events) to listen for.
        """
        return pulumi.get(self, "config_operation_types")

    @property
    @pulumi.getter(name="configProject")
    def config_project(self) -> str:
        """
        A [$project](https://docs.mongodb.com/manual/reference/operator/aggregation/project/) expression document that Realm uses to filter the fields that appear in change event objects.
        """
        return pulumi.get(self, "config_project")

    @property
    @pulumi.getter(name="configProviders")
    def config_providers(self) -> Sequence[str]:
        """
        A list of one or more [authentication provider](https://docs.mongodb.com/realm/authentication/providers/) id values. The trigger will only listen for authentication events produced by these providers.
        """
        return pulumi.get(self, "config_providers")

    @property
    @pulumi.getter(name="configSchedule")
    def config_schedule(self) -> str:
        """
        A [cron expression](https://docs.mongodb.com/realm/triggers/cron-expressions/) that defines the trigger schedule.
        """
        return pulumi.get(self, "config_schedule")

    @property
    @pulumi.getter(name="configScheduleType")
    def config_schedule_type(self) -> str:
        return pulumi.get(self, "config_schedule_type")

    @property
    @pulumi.getter(name="configServiceId")
    def config_service_id(self) -> str:
        """
        The ID of the MongoDB Service associated with the trigger.
        """
        return pulumi.get(self, "config_service_id")

    @property
    @pulumi.getter
    def disabled(self) -> bool:
        """
        Status of a trigger.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="eventProcessors")
    def event_processors(self) -> Sequence['outputs.GetEventTriggersResultEventProcessorResult']:
        """
        An object where each field name is an event processor ID and each value is an object that configures its corresponding event processor.
        * `event_processors.0.aws_eventbridge.config_account_id` - AWS Account ID.
        * `event_processors.0.aws_eventbridge.config_region` - Region of AWS Account.
        """
        return pulumi.get(self, "event_processors")

    @property
    @pulumi.getter(name="functionId")
    def function_id(self) -> str:
        """
        The ID of the function associated with the trigger.
        """
        return pulumi.get(self, "function_id")

    @property
    @pulumi.getter(name="functionName")
    def function_name(self) -> str:
        """
        The name of the function associated with the trigger.
        """
        return pulumi.get(self, "function_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the trigger.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="triggerId")
    def trigger_id(self) -> str:
        return pulumi.get(self, "trigger_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the trigger. Possible Values: `DATABASE`, `AUTHENTICATION`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unordered(self) -> bool:
        """
        Sort order for `DATABASE` type.
        """
        return pulumi.get(self, "unordered")


@pulumi.output_type
class GetEventTriggersResultEventProcessorResult(dict):
    def __init__(__self__, *,
                 aws_eventbridges: Sequence['outputs.GetEventTriggersResultEventProcessorAwsEventbridgeResult']):
        pulumi.set(__self__, "aws_eventbridges", aws_eventbridges)

    @property
    @pulumi.getter(name="awsEventbridges")
    def aws_eventbridges(self) -> Sequence['outputs.GetEventTriggersResultEventProcessorAwsEventbridgeResult']:
        return pulumi.get(self, "aws_eventbridges")


@pulumi.output_type
class GetEventTriggersResultEventProcessorAwsEventbridgeResult(dict):
    def __init__(__self__, *,
                 config_account_id: str,
                 config_region: str):
        pulumi.set(__self__, "config_account_id", config_account_id)
        pulumi.set(__self__, "config_region", config_region)

    @property
    @pulumi.getter(name="configAccountId")
    def config_account_id(self) -> str:
        return pulumi.get(self, "config_account_id")

    @property
    @pulumi.getter(name="configRegion")
    def config_region(self) -> str:
        return pulumi.get(self, "config_region")


@pulumi.output_type
class GetFederatedSettingsIdentityProviderAssociatedOrgResult(dict):
    def __init__(__self__, *,
                 domain_allow_lists: Sequence[str],
                 domain_restriction_enabled: bool,
                 identity_provider_id: str,
                 org_id: str,
                 post_auth_role_grants: Sequence[str],
                 role_mappings: Sequence['outputs.GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingResult'],
                 user_conflicts: Sequence['outputs.GetFederatedSettingsIdentityProviderAssociatedOrgUserConflictResult']):
        """
        :param Sequence[str] domain_allow_lists: List that contains the approved domains from which organization users can log in.
        :param bool domain_restriction_enabled: Flag that indicates whether domain restriction is enabled for the connected organization.
        :param str identity_provider_id: Unique 20-hexadecimal digit string that identifies the IdP.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param Sequence[str] post_auth_role_grants: List that contains the default roles granted to users who authenticate through the IdP in a connected organization. If you provide a postAuthRoleGrants field in the request, the array that you provide replaces the current postAuthRoleGrants.
        """
        pulumi.set(__self__, "domain_allow_lists", domain_allow_lists)
        pulumi.set(__self__, "domain_restriction_enabled", domain_restriction_enabled)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "post_auth_role_grants", post_auth_role_grants)
        pulumi.set(__self__, "role_mappings", role_mappings)
        pulumi.set(__self__, "user_conflicts", user_conflicts)

    @property
    @pulumi.getter(name="domainAllowLists")
    def domain_allow_lists(self) -> Sequence[str]:
        """
        List that contains the approved domains from which organization users can log in.
        """
        return pulumi.get(self, "domain_allow_lists")

    @property
    @pulumi.getter(name="domainRestrictionEnabled")
    def domain_restriction_enabled(self) -> bool:
        """
        Flag that indicates whether domain restriction is enabled for the connected organization.
        """
        return pulumi.get(self, "domain_restriction_enabled")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        Unique 20-hexadecimal digit string that identifies the IdP.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter(name="postAuthRoleGrants")
    def post_auth_role_grants(self) -> Sequence[str]:
        """
        List that contains the default roles granted to users who authenticate through the IdP in a connected organization. If you provide a postAuthRoleGrants field in the request, the array that you provide replaces the current postAuthRoleGrants.
        """
        return pulumi.get(self, "post_auth_role_grants")

    @property
    @pulumi.getter(name="roleMappings")
    def role_mappings(self) -> Sequence['outputs.GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingResult']:
        return pulumi.get(self, "role_mappings")

    @property
    @pulumi.getter(name="userConflicts")
    def user_conflicts(self) -> Sequence['outputs.GetFederatedSettingsIdentityProviderAssociatedOrgUserConflictResult']:
        return pulumi.get(self, "user_conflicts")


@pulumi.output_type
class GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingResult(dict):
    def __init__(__self__, *,
                 external_group_name: str,
                 id: str,
                 role_assignments: Sequence['outputs.GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignmentResult']):
        """
        :param str external_group_name: Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        :param str id: Unique 24-hexadecimal digit string that identifies this role mapping.
        :param Sequence['GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignmentArgs'] role_assignments: Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        pulumi.set(__self__, "external_group_name", external_group_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "role_assignments", role_assignments)

    @property
    @pulumi.getter(name="externalGroupName")
    def external_group_name(self) -> str:
        """
        Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        """
        return pulumi.get(self, "external_group_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies this role mapping.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="roleAssignments")
    def role_assignments(self) -> Sequence['outputs.GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignmentResult']:
        """
        Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        return pulumi.get(self, "role_assignments")


@pulumi.output_type
class GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 group_id: str,
                 org_id: str,
                 role: str):
        """
        :param str group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param str role: Specifies the Role that is attached to the Role Mapping.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Specifies the Role that is attached to the Role Mapping.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetFederatedSettingsIdentityProviderAssociatedOrgUserConflictResult(dict):
    def __init__(__self__, *,
                 email_address: str,
                 federation_settings_id: str,
                 first_name: str,
                 last_name: str,
                 user_id: str):
        """
        :param str email_address: Email address of the the user that conflicts with selected domains.
        :param str federation_settings_id: Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        :param str first_name: First name of the the user that conflicts with selected domains.
        :param str last_name: Last name of the the user that conflicts with selected domains.
        :param str user_id: Name of the Atlas user that conflicts with selected domains.
        """
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "federation_settings_id", federation_settings_id)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> str:
        """
        Email address of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter(name="federationSettingsId")
    def federation_settings_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        """
        return pulumi.get(self, "federation_settings_id")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> str:
        """
        First name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> str:
        """
        Last name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        """
        Name of the Atlas user that conflicts with selected domains.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetFederatedSettingsIdentityProviderPemFileInfoResult(dict):
    def __init__(__self__, *,
                 certificates: Sequence['outputs.GetFederatedSettingsIdentityProviderPemFileInfoCertificateResult'],
                 file_name: str):
        """
        :param str file_name: Filename of certificate
        """
        pulumi.set(__self__, "certificates", certificates)
        pulumi.set(__self__, "file_name", file_name)

    @property
    @pulumi.getter
    def certificates(self) -> Sequence['outputs.GetFederatedSettingsIdentityProviderPemFileInfoCertificateResult']:
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> str:
        """
        Filename of certificate
        """
        return pulumi.get(self, "file_name")


@pulumi.output_type
class GetFederatedSettingsIdentityProviderPemFileInfoCertificateResult(dict):
    def __init__(__self__, *,
                 not_after: str,
                 not_before: str):
        """
        :param str not_after: Expiration  Date.
        :param str not_before: Start Date.
        """
        pulumi.set(__self__, "not_after", not_after)
        pulumi.set(__self__, "not_before", not_before)

    @property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> str:
        """
        Expiration  Date.
        """
        return pulumi.get(self, "not_after")

    @property
    @pulumi.getter(name="notBefore")
    def not_before(self) -> str:
        """
        Start Date.
        """
        return pulumi.get(self, "not_before")


@pulumi.output_type
class GetFederatedSettingsIdentityProvidersResultResult(dict):
    def __init__(__self__, *,
                 acs_url: str,
                 associated_domains: Sequence[str],
                 associated_orgs: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgResult'],
                 audience_uri: str,
                 display_name: str,
                 issuer_uri: str,
                 okta_idp_id: str,
                 pem_file_infos: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultPemFileInfoResult'],
                 request_binding: str,
                 response_signature_algorithm: str,
                 sso_debug_enabled: bool,
                 sso_url: str,
                 status: str):
        """
        :param str acs_url: Assertion consumer service URL to which the IdP sends the SAML response.
        :param Sequence[str] associated_domains: List that contains the configured domains from which users can log in for this IdP.
        :param Sequence['GetFederatedSettingsIdentityProvidersResultAssociatedOrgArgs'] associated_orgs: List that contains the configured domains from which users can log in for this IdP.
        :param str audience_uri: Identifier for the intended audience of the SAML Assertion.
        :param str display_name: Human-readable label that identifies the IdP.
        :param str issuer_uri: Identifier for the issuer of the SAML Assertion.
        :param str request_binding: SAML Authentication Request Protocol binding used to send the AuthNRequest. Atlas supports the following binding values:
               - HTTP POST
               - HTTP REDIRECT
        :param str response_signature_algorithm: Algorithm used to encrypt the IdP signature. Atlas supports the following signature algorithm values:
               - SHA-1
               - SHA-256
        :param bool sso_debug_enabled: Flag that indicates whether the IdP has enabled Bypass SAML Mode. Enabling this mode generates a URL that allows you bypass SAML and login to your organizations at any point. You can authenticate with this special URL only when Bypass Mode is enabled. Set this parameter to true during testing. This keeps you from getting locked out of MongoDB.
        :param str sso_url: URL of the receiver of the SAML AuthNRequest.
        :param str status: Label that indicates whether the identity provider is active. The IdP is Inactive until you map at least one domain to the IdP.
        """
        pulumi.set(__self__, "acs_url", acs_url)
        pulumi.set(__self__, "associated_domains", associated_domains)
        pulumi.set(__self__, "associated_orgs", associated_orgs)
        pulumi.set(__self__, "audience_uri", audience_uri)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "issuer_uri", issuer_uri)
        pulumi.set(__self__, "okta_idp_id", okta_idp_id)
        pulumi.set(__self__, "pem_file_infos", pem_file_infos)
        pulumi.set(__self__, "request_binding", request_binding)
        pulumi.set(__self__, "response_signature_algorithm", response_signature_algorithm)
        pulumi.set(__self__, "sso_debug_enabled", sso_debug_enabled)
        pulumi.set(__self__, "sso_url", sso_url)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="acsUrl")
    def acs_url(self) -> str:
        """
        Assertion consumer service URL to which the IdP sends the SAML response.
        """
        return pulumi.get(self, "acs_url")

    @property
    @pulumi.getter(name="associatedDomains")
    def associated_domains(self) -> Sequence[str]:
        """
        List that contains the configured domains from which users can log in for this IdP.
        """
        return pulumi.get(self, "associated_domains")

    @property
    @pulumi.getter(name="associatedOrgs")
    def associated_orgs(self) -> Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgResult']:
        """
        List that contains the configured domains from which users can log in for this IdP.
        """
        return pulumi.get(self, "associated_orgs")

    @property
    @pulumi.getter(name="audienceUri")
    def audience_uri(self) -> str:
        """
        Identifier for the intended audience of the SAML Assertion.
        """
        return pulumi.get(self, "audience_uri")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        Human-readable label that identifies the IdP.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="issuerUri")
    def issuer_uri(self) -> str:
        """
        Identifier for the issuer of the SAML Assertion.
        """
        return pulumi.get(self, "issuer_uri")

    @property
    @pulumi.getter(name="oktaIdpId")
    def okta_idp_id(self) -> str:
        return pulumi.get(self, "okta_idp_id")

    @property
    @pulumi.getter(name="pemFileInfos")
    def pem_file_infos(self) -> Sequence['outputs.GetFederatedSettingsIdentityProvidersResultPemFileInfoResult']:
        return pulumi.get(self, "pem_file_infos")

    @property
    @pulumi.getter(name="requestBinding")
    def request_binding(self) -> str:
        """
        SAML Authentication Request Protocol binding used to send the AuthNRequest. Atlas supports the following binding values:
        - HTTP POST
        - HTTP REDIRECT
        """
        return pulumi.get(self, "request_binding")

    @property
    @pulumi.getter(name="responseSignatureAlgorithm")
    def response_signature_algorithm(self) -> str:
        """
        Algorithm used to encrypt the IdP signature. Atlas supports the following signature algorithm values:
        - SHA-1
        - SHA-256
        """
        return pulumi.get(self, "response_signature_algorithm")

    @property
    @pulumi.getter(name="ssoDebugEnabled")
    def sso_debug_enabled(self) -> bool:
        """
        Flag that indicates whether the IdP has enabled Bypass SAML Mode. Enabling this mode generates a URL that allows you bypass SAML and login to your organizations at any point. You can authenticate with this special URL only when Bypass Mode is enabled. Set this parameter to true during testing. This keeps you from getting locked out of MongoDB.
        """
        return pulumi.get(self, "sso_debug_enabled")

    @property
    @pulumi.getter(name="ssoUrl")
    def sso_url(self) -> str:
        """
        URL of the receiver of the SAML AuthNRequest.
        """
        return pulumi.get(self, "sso_url")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Label that indicates whether the identity provider is active. The IdP is Inactive until you map at least one domain to the IdP.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetFederatedSettingsIdentityProvidersResultAssociatedOrgResult(dict):
    def __init__(__self__, *,
                 domain_allow_lists: Sequence[str],
                 domain_restriction_enabled: bool,
                 identity_provider_id: str,
                 org_id: str,
                 post_auth_role_grants: Sequence[str],
                 role_mappings: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingResult'],
                 user_conflicts: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgUserConflictResult']):
        """
        :param Sequence[str] domain_allow_lists: List that contains the approved domains from which organization users can log in.
        :param bool domain_restriction_enabled: Flag that indicates whether domain restriction is enabled for the connected organization.
        :param str identity_provider_id: Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param Sequence[str] post_auth_role_grants: List that contains the default roles granted to users who authenticate through the IdP in a connected organization. If you provide a postAuthRoleGrants field in the request, the array that you provide replaces the current postAuthRoleGrants.
        """
        pulumi.set(__self__, "domain_allow_lists", domain_allow_lists)
        pulumi.set(__self__, "domain_restriction_enabled", domain_restriction_enabled)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "post_auth_role_grants", post_auth_role_grants)
        pulumi.set(__self__, "role_mappings", role_mappings)
        pulumi.set(__self__, "user_conflicts", user_conflicts)

    @property
    @pulumi.getter(name="domainAllowLists")
    def domain_allow_lists(self) -> Sequence[str]:
        """
        List that contains the approved domains from which organization users can log in.
        """
        return pulumi.get(self, "domain_allow_lists")

    @property
    @pulumi.getter(name="domainRestrictionEnabled")
    def domain_restriction_enabled(self) -> bool:
        """
        Flag that indicates whether domain restriction is enabled for the connected organization.
        """
        return pulumi.get(self, "domain_restriction_enabled")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter(name="postAuthRoleGrants")
    def post_auth_role_grants(self) -> Sequence[str]:
        """
        List that contains the default roles granted to users who authenticate through the IdP in a connected organization. If you provide a postAuthRoleGrants field in the request, the array that you provide replaces the current postAuthRoleGrants.
        """
        return pulumi.get(self, "post_auth_role_grants")

    @property
    @pulumi.getter(name="roleMappings")
    def role_mappings(self) -> Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingResult']:
        return pulumi.get(self, "role_mappings")

    @property
    @pulumi.getter(name="userConflicts")
    def user_conflicts(self) -> Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgUserConflictResult']:
        return pulumi.get(self, "user_conflicts")


@pulumi.output_type
class GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingResult(dict):
    def __init__(__self__, *,
                 external_group_name: str,
                 id: str,
                 role_assignments: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignmentResult']):
        """
        :param str external_group_name: Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        :param str id: Unique 24-hexadecimal digit string that identifies this role mapping.
        :param Sequence['GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignmentArgs'] role_assignments: Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        pulumi.set(__self__, "external_group_name", external_group_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "role_assignments", role_assignments)

    @property
    @pulumi.getter(name="externalGroupName")
    def external_group_name(self) -> str:
        """
        Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        """
        return pulumi.get(self, "external_group_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies this role mapping.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="roleAssignments")
    def role_assignments(self) -> Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignmentResult']:
        """
        Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        return pulumi.get(self, "role_assignments")


@pulumi.output_type
class GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 group_id: str,
                 org_id: str,
                 role: str):
        """
        :param str group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param str role: Specifies the Role that is attached to the Role Mapping.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Specifies the Role that is attached to the Role Mapping.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetFederatedSettingsIdentityProvidersResultAssociatedOrgUserConflictResult(dict):
    def __init__(__self__, *,
                 email_address: str,
                 federation_settings_id: str,
                 first_name: str,
                 last_name: str,
                 user_id: str):
        """
        :param str email_address: Email address of the the user that conflicts with selected domains.
        :param str federation_settings_id: Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        :param str first_name: First name of the the user that conflicts with selected domains.
        :param str last_name: Last name of the the user that conflicts with selected domains.
        :param str user_id: Name of the Atlas user that conflicts with selected domains.
        """
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "federation_settings_id", federation_settings_id)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> str:
        """
        Email address of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter(name="federationSettingsId")
    def federation_settings_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        """
        return pulumi.get(self, "federation_settings_id")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> str:
        """
        First name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> str:
        """
        Last name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        """
        Name of the Atlas user that conflicts with selected domains.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetFederatedSettingsIdentityProvidersResultPemFileInfoResult(dict):
    def __init__(__self__, *,
                 certificates: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultPemFileInfoCertificateResult'],
                 file_name: str):
        """
        :param str file_name: Filename of certificate
        """
        pulumi.set(__self__, "certificates", certificates)
        pulumi.set(__self__, "file_name", file_name)

    @property
    @pulumi.getter
    def certificates(self) -> Sequence['outputs.GetFederatedSettingsIdentityProvidersResultPemFileInfoCertificateResult']:
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> str:
        """
        Filename of certificate
        """
        return pulumi.get(self, "file_name")


@pulumi.output_type
class GetFederatedSettingsIdentityProvidersResultPemFileInfoCertificateResult(dict):
    def __init__(__self__, *,
                 not_after: str,
                 not_before: str):
        """
        :param str not_after: Expiration  Date.
        :param str not_before: Start Date.
        """
        pulumi.set(__self__, "not_after", not_after)
        pulumi.set(__self__, "not_before", not_before)

    @property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> str:
        """
        Expiration  Date.
        """
        return pulumi.get(self, "not_after")

    @property
    @pulumi.getter(name="notBefore")
    def not_before(self) -> str:
        """
        Start Date.
        """
        return pulumi.get(self, "not_before")


@pulumi.output_type
class GetFederatedSettingsOrgConfigRoleMappingResult(dict):
    def __init__(__self__, *,
                 external_group_name: str,
                 id: str,
                 role_assignments: Sequence['outputs.GetFederatedSettingsOrgConfigRoleMappingRoleAssignmentResult']):
        """
        :param str external_group_name: Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        :param str id: Unique 24-hexadecimal digit string that identifies this role mapping.
        :param Sequence['GetFederatedSettingsOrgConfigRoleMappingRoleAssignmentArgs'] role_assignments: Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        pulumi.set(__self__, "external_group_name", external_group_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "role_assignments", role_assignments)

    @property
    @pulumi.getter(name="externalGroupName")
    def external_group_name(self) -> str:
        """
        Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        """
        return pulumi.get(self, "external_group_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies this role mapping.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="roleAssignments")
    def role_assignments(self) -> Sequence['outputs.GetFederatedSettingsOrgConfigRoleMappingRoleAssignmentResult']:
        """
        Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        return pulumi.get(self, "role_assignments")


@pulumi.output_type
class GetFederatedSettingsOrgConfigRoleMappingRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 group_id: str,
                 org_id: str,
                 role: str):
        """
        :param str group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param str role: Specifies the Role that is attached to the Role Mapping.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Specifies the Role that is attached to the Role Mapping.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetFederatedSettingsOrgConfigUserConflictResult(dict):
    def __init__(__self__, *,
                 email_address: str,
                 federation_settings_id: str,
                 first_name: str,
                 last_name: str,
                 user_id: str):
        """
        :param str email_address: Email address of the the user that conflicts with selected domains.
        :param str federation_settings_id: Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        :param str first_name: First name of the the user that conflicts with selected domains.
        :param str last_name: Last name of the the user that conflicts with selected domains.
        :param str user_id: Name of the Atlas user that conflicts with selected domains.
        """
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "federation_settings_id", federation_settings_id)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> str:
        """
        Email address of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter(name="federationSettingsId")
    def federation_settings_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        """
        return pulumi.get(self, "federation_settings_id")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> str:
        """
        First name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> str:
        """
        Last name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        """
        Name of the Atlas user that conflicts with selected domains.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetFederatedSettingsOrgConfigsResultResult(dict):
    def __init__(__self__, *,
                 domain_allow_lists: Sequence[str],
                 domain_restriction_enabled: bool,
                 identity_provider_id: str,
                 org_id: str,
                 post_auth_role_grants: Sequence[str],
                 role_mappings: Sequence['outputs.GetFederatedSettingsOrgConfigsResultRoleMappingResult'],
                 user_conflicts: Sequence['outputs.GetFederatedSettingsOrgConfigsResultUserConflictResult']):
        """
        :param Sequence[str] domain_allow_lists: List that contains the approved domains from which organization users can log in.
        :param bool domain_restriction_enabled: Flag that indicates whether domain restriction is enabled for the connected organization.
        :param str identity_provider_id: Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param Sequence[str] post_auth_role_grants: List that contains the default roles granted to users who authenticate through the IdP in a connected organization. If you provide a postAuthRoleGrants field in the request, the array that you provide replaces the current postAuthRoleGrants.
        """
        pulumi.set(__self__, "domain_allow_lists", domain_allow_lists)
        pulumi.set(__self__, "domain_restriction_enabled", domain_restriction_enabled)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "post_auth_role_grants", post_auth_role_grants)
        pulumi.set(__self__, "role_mappings", role_mappings)
        pulumi.set(__self__, "user_conflicts", user_conflicts)

    @property
    @pulumi.getter(name="domainAllowLists")
    def domain_allow_lists(self) -> Sequence[str]:
        """
        List that contains the approved domains from which organization users can log in.
        """
        return pulumi.get(self, "domain_allow_lists")

    @property
    @pulumi.getter(name="domainRestrictionEnabled")
    def domain_restriction_enabled(self) -> bool:
        """
        Flag that indicates whether domain restriction is enabled for the connected organization.
        """
        return pulumi.get(self, "domain_restriction_enabled")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter(name="postAuthRoleGrants")
    def post_auth_role_grants(self) -> Sequence[str]:
        """
        List that contains the default roles granted to users who authenticate through the IdP in a connected organization. If you provide a postAuthRoleGrants field in the request, the array that you provide replaces the current postAuthRoleGrants.
        """
        return pulumi.get(self, "post_auth_role_grants")

    @property
    @pulumi.getter(name="roleMappings")
    def role_mappings(self) -> Sequence['outputs.GetFederatedSettingsOrgConfigsResultRoleMappingResult']:
        return pulumi.get(self, "role_mappings")

    @property
    @pulumi.getter(name="userConflicts")
    def user_conflicts(self) -> Sequence['outputs.GetFederatedSettingsOrgConfigsResultUserConflictResult']:
        return pulumi.get(self, "user_conflicts")


@pulumi.output_type
class GetFederatedSettingsOrgConfigsResultRoleMappingResult(dict):
    def __init__(__self__, *,
                 external_group_name: str,
                 id: str,
                 role_assignments: Sequence['outputs.GetFederatedSettingsOrgConfigsResultRoleMappingRoleAssignmentResult']):
        """
        :param str external_group_name: Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        :param str id: Unique 24-hexadecimal digit string that identifies this role mapping.
        :param Sequence['GetFederatedSettingsOrgConfigsResultRoleMappingRoleAssignmentArgs'] role_assignments: Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        pulumi.set(__self__, "external_group_name", external_group_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "role_assignments", role_assignments)

    @property
    @pulumi.getter(name="externalGroupName")
    def external_group_name(self) -> str:
        """
        Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        """
        return pulumi.get(self, "external_group_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies this role mapping.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="roleAssignments")
    def role_assignments(self) -> Sequence['outputs.GetFederatedSettingsOrgConfigsResultRoleMappingRoleAssignmentResult']:
        """
        Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        return pulumi.get(self, "role_assignments")


@pulumi.output_type
class GetFederatedSettingsOrgConfigsResultRoleMappingRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 group_id: str,
                 org_id: str,
                 role: str):
        """
        :param str group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param str role: Specifies the Role that is attached to the Role Mapping.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Specifies the Role that is attached to the Role Mapping.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetFederatedSettingsOrgConfigsResultUserConflictResult(dict):
    def __init__(__self__, *,
                 email_address: str,
                 federation_settings_id: str,
                 first_name: str,
                 last_name: str,
                 user_id: str):
        """
        :param str email_address: Email address of the the user that conflicts with selected domains.
        :param str federation_settings_id: Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        :param str first_name: First name of the the user that conflicts with selected domains.
        :param str last_name: Last name of the the user that conflicts with selected domains.
        :param str user_id: Name of the Atlas user that conflicts with selected domains.
        """
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "federation_settings_id", federation_settings_id)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> str:
        """
        Email address of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter(name="federationSettingsId")
    def federation_settings_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        """
        return pulumi.get(self, "federation_settings_id")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> str:
        """
        First name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> str:
        """
        Last name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        """
        Name of the Atlas user that conflicts with selected domains.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetFederatedSettingsOrgRoleMappingRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 group_id: str,
                 org_id: str,
                 role: str):
        """
        :param str group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param str role: Specifies the Role that is attached to the Role Mapping.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Specifies the Role that is attached to the Role Mapping.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetFederatedSettingsOrgRoleMappingsResultResult(dict):
    def __init__(__self__, *,
                 external_group_name: str,
                 id: str,
                 role_assignments: Sequence['outputs.GetFederatedSettingsOrgRoleMappingsResultRoleAssignmentResult']):
        """
        :param str external_group_name: Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        :param str id: Unique 24-hexadecimal digit string that identifies this role mapping.
        :param Sequence['GetFederatedSettingsOrgRoleMappingsResultRoleAssignmentArgs'] role_assignments: Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        pulumi.set(__self__, "external_group_name", external_group_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "role_assignments", role_assignments)

    @property
    @pulumi.getter(name="externalGroupName")
    def external_group_name(self) -> str:
        """
        Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        """
        return pulumi.get(self, "external_group_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies this role mapping.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="roleAssignments")
    def role_assignments(self) -> Sequence['outputs.GetFederatedSettingsOrgRoleMappingsResultRoleAssignmentResult']:
        """
        Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        return pulumi.get(self, "role_assignments")


@pulumi.output_type
class GetFederatedSettingsOrgRoleMappingsResultRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 group_id: str,
                 org_id: str,
                 role: str):
        """
        :param str group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param str role: Specifies the Role that is attached to the Role Mapping.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Specifies the Role that is attached to the Role Mapping.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetGlobalClusterConfigManagedNamespaceResult(dict):
    def __init__(__self__, *,
                 collection: str,
                 custom_shard_key: str,
                 db: str,
                 is_custom_shard_key_hashed: bool,
                 is_shard_key_unique: bool):
        """
        :param str collection: (Required) The name of the collection associated with the managed namespace.
        :param str custom_shard_key: (Required)	The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        :param str db: (Required) The name of the database containing the collection.
        :param bool is_custom_shard_key_hashed: Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.
        :param bool is_shard_key_unique: Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).
        """
        pulumi.set(__self__, "collection", collection)
        pulumi.set(__self__, "custom_shard_key", custom_shard_key)
        pulumi.set(__self__, "db", db)
        pulumi.set(__self__, "is_custom_shard_key_hashed", is_custom_shard_key_hashed)
        pulumi.set(__self__, "is_shard_key_unique", is_shard_key_unique)

    @property
    @pulumi.getter
    def collection(self) -> str:
        """
        (Required) The name of the collection associated with the managed namespace.
        """
        return pulumi.get(self, "collection")

    @property
    @pulumi.getter(name="customShardKey")
    def custom_shard_key(self) -> str:
        """
        (Required)	The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        """
        return pulumi.get(self, "custom_shard_key")

    @property
    @pulumi.getter
    def db(self) -> str:
        """
        (Required) The name of the database containing the collection.
        """
        return pulumi.get(self, "db")

    @property
    @pulumi.getter(name="isCustomShardKeyHashed")
    def is_custom_shard_key_hashed(self) -> bool:
        """
        Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.
        """
        return pulumi.get(self, "is_custom_shard_key_hashed")

    @property
    @pulumi.getter(name="isShardKeyUnique")
    def is_shard_key_unique(self) -> bool:
        """
        Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).
        """
        return pulumi.get(self, "is_shard_key_unique")


@pulumi.output_type
class GetLdapConfigurationUserToDnMappingResult(dict):
    def __init__(__self__, *,
                 ldap_query: str,
                 match: str,
                 substitution: str):
        pulumi.set(__self__, "ldap_query", ldap_query)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "substitution", substitution)

    @property
    @pulumi.getter(name="ldapQuery")
    def ldap_query(self) -> str:
        return pulumi.get(self, "ldap_query")

    @property
    @pulumi.getter
    def match(self) -> str:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def substitution(self) -> str:
        return pulumi.get(self, "substitution")


@pulumi.output_type
class GetLdapVerifyLinkResult(dict):
    def __init__(__self__, *,
                 href: str,
                 rel: str):
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> str:
        return pulumi.get(self, "href")

    @property
    @pulumi.getter
    def rel(self) -> str:
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetLdapVerifyValidationResult(dict):
    def __init__(__self__, *,
                 status: str,
                 validation_type: str):
        """
        :param str status: The current status of the LDAP over TLS/SSL configuration.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "validation_type", validation_type)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The current status of the LDAP over TLS/SSL configuration.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="validationType")
    def validation_type(self) -> str:
        return pulumi.get(self, "validation_type")


@pulumi.output_type
class GetNetworkContainersResultResult(dict):
    def __init__(__self__, *,
                 atlas_cidr_block: str,
                 azure_subscription_id: str,
                 gcp_project_id: str,
                 id: str,
                 network_name: str,
                 provider_name: str,
                 provisioned: bool,
                 region: str,
                 region_name: str,
                 regions: Sequence[str],
                 vnet_name: str,
                 vpc_id: str):
        """
        :param str atlas_cidr_block: CIDR block that Atlas uses for your clusters. Atlas uses the specified CIDR block for all other Network Peering connections created in the project. The Atlas CIDR block must be at least a /24 and at most a /21 in one of the following [private networks](https://tools.ietf.org/html/rfc1918.html#section-3).
        :param str azure_subscription_id: Unique identifer of the Azure subscription in which the VNet resides.
        :param str gcp_project_id: Unique identifier of the GCP project in which the Network Peering connection resides.
        :param str id: The Network Peering Container ID.
        :param str network_name: Name of the Network Peering connection in the Atlas project.
        :param str provider_name: Cloud provider for this Network peering container. Accepted values are AWS, GCP, and Azure.
        :param bool provisioned: Indicates whether the project has Network Peering connections deployed in the container.
        :param str region: The Atlas Azure region name for where this container exists.
        :param str region_name: The Atlas AWS region name for where this container exists.
        :param Sequence[str] regions: Atlas GCP regions where the container resides.
        :param str vnet_name: The name of the Azure VNet. This value is null until you provision an Azure VNet in the container.
        :param str vpc_id: Unique identifier of the projects VPC.
        """
        pulumi.set(__self__, "atlas_cidr_block", atlas_cidr_block)
        pulumi.set(__self__, "azure_subscription_id", azure_subscription_id)
        pulumi.set(__self__, "gcp_project_id", gcp_project_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "network_name", network_name)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "provisioned", provisioned)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "region_name", region_name)
        pulumi.set(__self__, "regions", regions)
        pulumi.set(__self__, "vnet_name", vnet_name)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="atlasCidrBlock")
    def atlas_cidr_block(self) -> str:
        """
        CIDR block that Atlas uses for your clusters. Atlas uses the specified CIDR block for all other Network Peering connections created in the project. The Atlas CIDR block must be at least a /24 and at most a /21 in one of the following [private networks](https://tools.ietf.org/html/rfc1918.html#section-3).
        """
        return pulumi.get(self, "atlas_cidr_block")

    @property
    @pulumi.getter(name="azureSubscriptionId")
    def azure_subscription_id(self) -> str:
        """
        Unique identifer of the Azure subscription in which the VNet resides.
        """
        return pulumi.get(self, "azure_subscription_id")

    @property
    @pulumi.getter(name="gcpProjectId")
    def gcp_project_id(self) -> str:
        """
        Unique identifier of the GCP project in which the Network Peering connection resides.
        """
        return pulumi.get(self, "gcp_project_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The Network Peering Container ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="networkName")
    def network_name(self) -> str:
        """
        Name of the Network Peering connection in the Atlas project.
        """
        return pulumi.get(self, "network_name")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Cloud provider for this Network peering container. Accepted values are AWS, GCP, and Azure.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def provisioned(self) -> bool:
        """
        Indicates whether the project has Network Peering connections deployed in the container.
        """
        return pulumi.get(self, "provisioned")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The Atlas Azure region name for where this container exists.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        The Atlas AWS region name for where this container exists.
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter
    def regions(self) -> Sequence[str]:
        """
        Atlas GCP regions where the container resides.
        """
        return pulumi.get(self, "regions")

    @property
    @pulumi.getter(name="vnetName")
    def vnet_name(self) -> str:
        """
        The name of the Azure VNet. This value is null until you provision an Azure VNet in the container.
        """
        return pulumi.get(self, "vnet_name")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        Unique identifier of the projects VPC.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetNetworkPeeringsResultResult(dict):
    def __init__(__self__, *,
                 accepter_region_name: str,
                 atlas_cidr_block: str,
                 aws_account_id: str,
                 azure_directory_id: str,
                 azure_subscription_id: str,
                 connection_id: str,
                 container_id: str,
                 error_message: str,
                 error_state: str,
                 error_state_name: str,
                 gcp_project_id: str,
                 network_name: str,
                 peering_id: str,
                 provider_name: str,
                 resource_group_name: str,
                 route_table_cidr_block: str,
                 status: str,
                 status_name: str,
                 vnet_name: str,
                 vpc_id: str):
        """
        :param str accepter_region_name: Specifies the region where the peer VPC resides. For complete lists of supported regions, see [Amazon Web Services](https://docs.atlas.mongodb.com/reference/amazon-aws/).
        :param str aws_account_id: Account ID of the owner of the peer VPC.
        :param str azure_directory_id: Unique identifier for an Azure AD directory.
        :param str azure_subscription_id: Unique identifer of the Azure subscription in which the VNet resides.
        :param str connection_id: Unique identifier for the peering connection.
        :param str error_message: When `"status" : "FAILED"`, Atlas provides a description of the error.
        :param str error_state: Description of the Atlas error when `status` is `Failed`, Otherwise, Atlas returns `null`.
        :param str error_state_name: Error state, if any. The VPC peering connection error state value can be one of the following: `REJECTED`, `EXPIRED`, `INVALID_ARGUMENT`.
        :param str gcp_project_id: GCP project ID of the owner of the network peer.
        :param str network_name: Name of the network peer to which Atlas connects.
        :param str peering_id: Atlas assigned unique ID for the peering connection.
        :param str provider_name: Cloud provider for this VPC peering connection. If omitted, Atlas sets this parameter to AWS. (Possible Values `AWS`, `AZURE`, `GCP`).
        :param str resource_group_name: Name of your Azure resource group.
        :param str route_table_cidr_block: Peer VPC CIDR block or subnet.
        :param str status: Status of the Atlas network peering connection: `ADDING_PEER`, `AVAILABLE`, `FAILED`, `DELETING`, `WAITING_FOR_USER`.
        :param str status_name: The VPC peering connection status value can be one of the following: `INITIATING`, `PENDING_ACCEPTANCE`, `FAILED`, `FINALIZING`, `AVAILABLE`, `TERMINATING`.
        :param str vnet_name: Name of your Azure VNet.
        :param str vpc_id: Unique identifier of the peer VPC.
        """
        pulumi.set(__self__, "accepter_region_name", accepter_region_name)
        pulumi.set(__self__, "atlas_cidr_block", atlas_cidr_block)
        pulumi.set(__self__, "aws_account_id", aws_account_id)
        pulumi.set(__self__, "azure_directory_id", azure_directory_id)
        pulumi.set(__self__, "azure_subscription_id", azure_subscription_id)
        pulumi.set(__self__, "connection_id", connection_id)
        pulumi.set(__self__, "container_id", container_id)
        pulumi.set(__self__, "error_message", error_message)
        pulumi.set(__self__, "error_state", error_state)
        pulumi.set(__self__, "error_state_name", error_state_name)
        pulumi.set(__self__, "gcp_project_id", gcp_project_id)
        pulumi.set(__self__, "network_name", network_name)
        pulumi.set(__self__, "peering_id", peering_id)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)
        pulumi.set(__self__, "route_table_cidr_block", route_table_cidr_block)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_name", status_name)
        pulumi.set(__self__, "vnet_name", vnet_name)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="accepterRegionName")
    def accepter_region_name(self) -> str:
        """
        Specifies the region where the peer VPC resides. For complete lists of supported regions, see [Amazon Web Services](https://docs.atlas.mongodb.com/reference/amazon-aws/).
        """
        return pulumi.get(self, "accepter_region_name")

    @property
    @pulumi.getter(name="atlasCidrBlock")
    def atlas_cidr_block(self) -> str:
        return pulumi.get(self, "atlas_cidr_block")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> str:
        """
        Account ID of the owner of the peer VPC.
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="azureDirectoryId")
    def azure_directory_id(self) -> str:
        """
        Unique identifier for an Azure AD directory.
        """
        return pulumi.get(self, "azure_directory_id")

    @property
    @pulumi.getter(name="azureSubscriptionId")
    def azure_subscription_id(self) -> str:
        """
        Unique identifer of the Azure subscription in which the VNet resides.
        """
        return pulumi.get(self, "azure_subscription_id")

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> str:
        """
        Unique identifier for the peering connection.
        """
        return pulumi.get(self, "connection_id")

    @property
    @pulumi.getter(name="containerId")
    def container_id(self) -> str:
        return pulumi.get(self, "container_id")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> str:
        """
        When `"status" : "FAILED"`, Atlas provides a description of the error.
        """
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter(name="errorState")
    def error_state(self) -> str:
        """
        Description of the Atlas error when `status` is `Failed`, Otherwise, Atlas returns `null`.
        """
        return pulumi.get(self, "error_state")

    @property
    @pulumi.getter(name="errorStateName")
    def error_state_name(self) -> str:
        """
        Error state, if any. The VPC peering connection error state value can be one of the following: `REJECTED`, `EXPIRED`, `INVALID_ARGUMENT`.
        """
        return pulumi.get(self, "error_state_name")

    @property
    @pulumi.getter(name="gcpProjectId")
    def gcp_project_id(self) -> str:
        """
        GCP project ID of the owner of the network peer.
        """
        return pulumi.get(self, "gcp_project_id")

    @property
    @pulumi.getter(name="networkName")
    def network_name(self) -> str:
        """
        Name of the network peer to which Atlas connects.
        """
        return pulumi.get(self, "network_name")

    @property
    @pulumi.getter(name="peeringId")
    def peering_id(self) -> str:
        """
        Atlas assigned unique ID for the peering connection.
        """
        return pulumi.get(self, "peering_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Cloud provider for this VPC peering connection. If omitted, Atlas sets this parameter to AWS. (Possible Values `AWS`, `AZURE`, `GCP`).
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> str:
        """
        Name of your Azure resource group.
        """
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter(name="routeTableCidrBlock")
    def route_table_cidr_block(self) -> str:
        """
        Peer VPC CIDR block or subnet.
        """
        return pulumi.get(self, "route_table_cidr_block")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the Atlas network peering connection: `ADDING_PEER`, `AVAILABLE`, `FAILED`, `DELETING`, `WAITING_FOR_USER`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="statusName")
    def status_name(self) -> str:
        """
        The VPC peering connection status value can be one of the following: `INITIATING`, `PENDING_ACCEPTANCE`, `FAILED`, `FINALIZING`, `AVAILABLE`, `TERMINATING`.
        """
        return pulumi.get(self, "status_name")

    @property
    @pulumi.getter(name="vnetName")
    def vnet_name(self) -> str:
        """
        Name of your Azure VNet.
        """
        return pulumi.get(self, "vnet_name")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        Unique identifier of the peer VPC.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetOnlineArchiveCriteriaResult(dict):
    def __init__(__self__, *,
                 date_field: str,
                 date_format: str,
                 expire_after_days: int,
                 query: str,
                 type: str):
        pulumi.set(__self__, "date_field", date_field)
        pulumi.set(__self__, "date_format", date_format)
        pulumi.set(__self__, "expire_after_days", expire_after_days)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="dateField")
    def date_field(self) -> str:
        return pulumi.get(self, "date_field")

    @property
    @pulumi.getter(name="dateFormat")
    def date_format(self) -> str:
        return pulumi.get(self, "date_format")

    @property
    @pulumi.getter(name="expireAfterDays")
    def expire_after_days(self) -> int:
        return pulumi.get(self, "expire_after_days")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetOnlineArchivePartitionFieldResult(dict):
    def __init__(__self__, *,
                 field_name: str,
                 field_type: str,
                 order: int):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "field_type", field_type)
        pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> str:
        return pulumi.get(self, "field_type")

    @property
    @pulumi.getter
    def order(self) -> int:
        return pulumi.get(self, "order")


@pulumi.output_type
class GetOnlineArchivesResultResult(dict):
    def __init__(__self__, *,
                 archive_id: str,
                 cluster_name: str,
                 coll_name: str,
                 criterias: Sequence['outputs.GetOnlineArchivesResultCriteriaResult'],
                 db_name: str,
                 partition_fields: Sequence['outputs.GetOnlineArchivesResultPartitionFieldResult'],
                 paused: bool,
                 project_id: str,
                 state: str):
        """
        :param str cluster_name: Name of the cluster that contains the collection.
        :param str project_id: The unique ID for the project.
        """
        pulumi.set(__self__, "archive_id", archive_id)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "coll_name", coll_name)
        pulumi.set(__self__, "criterias", criterias)
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "partition_fields", partition_fields)
        pulumi.set(__self__, "paused", paused)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="archiveId")
    def archive_id(self) -> str:
        return pulumi.get(self, "archive_id")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        Name of the cluster that contains the collection.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="collName")
    def coll_name(self) -> str:
        return pulumi.get(self, "coll_name")

    @property
    @pulumi.getter
    def criterias(self) -> Sequence['outputs.GetOnlineArchivesResultCriteriaResult']:
        return pulumi.get(self, "criterias")

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> str:
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="partitionFields")
    def partition_fields(self) -> Sequence['outputs.GetOnlineArchivesResultPartitionFieldResult']:
        return pulumi.get(self, "partition_fields")

    @property
    @pulumi.getter
    def paused(self) -> bool:
        return pulumi.get(self, "paused")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")


@pulumi.output_type
class GetOnlineArchivesResultCriteriaResult(dict):
    def __init__(__self__, *,
                 date_field: str,
                 date_format: str,
                 expire_after_days: int,
                 query: str,
                 type: str):
        pulumi.set(__self__, "date_field", date_field)
        pulumi.set(__self__, "date_format", date_format)
        pulumi.set(__self__, "expire_after_days", expire_after_days)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="dateField")
    def date_field(self) -> str:
        return pulumi.get(self, "date_field")

    @property
    @pulumi.getter(name="dateFormat")
    def date_format(self) -> str:
        return pulumi.get(self, "date_format")

    @property
    @pulumi.getter(name="expireAfterDays")
    def expire_after_days(self) -> int:
        return pulumi.get(self, "expire_after_days")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetOnlineArchivesResultPartitionFieldResult(dict):
    def __init__(__self__, *,
                 field_name: str,
                 field_type: str,
                 order: int):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "field_type", field_type)
        pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> str:
        return pulumi.get(self, "field_type")

    @property
    @pulumi.getter
    def order(self) -> int:
        return pulumi.get(self, "order")


@pulumi.output_type
class GetPrivateLinkEndpointServiceEndpointResult(dict):
    def __init__(__self__, *,
                 endpoint_name: str,
                 ip_address: str,
                 service_attachment_name: str,
                 status: str):
        """
        :param str endpoint_name: Forwarding rule that corresponds to the endpoint you created in GCP.
        :param str ip_address: Private IP address of the network endpoint group you created in GCP.
        :param str service_attachment_name: Unique alphanumeric and special character strings that identify the service attachment associated with the endpoint.
        :param str status: Status of the endpoint. Atlas returns one of the [values shown above](https://docs.atlas.mongodb.com/reference/api/private-endpoints-endpoint-create-one/#std-label-ref-status-field).
        """
        pulumi.set(__self__, "endpoint_name", endpoint_name)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "service_attachment_name", service_attachment_name)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="endpointName")
    def endpoint_name(self) -> str:
        """
        Forwarding rule that corresponds to the endpoint you created in GCP.
        """
        return pulumi.get(self, "endpoint_name")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        Private IP address of the network endpoint group you created in GCP.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="serviceAttachmentName")
    def service_attachment_name(self) -> str:
        """
        Unique alphanumeric and special character strings that identify the service attachment associated with the endpoint.
        """
        return pulumi.get(self, "service_attachment_name")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the endpoint. Atlas returns one of the [values shown above](https://docs.atlas.mongodb.com/reference/api/private-endpoints-endpoint-create-one/#std-label-ref-status-field).
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetPrivatelinkEndpointsServiceAdlLinkResult(dict):
    def __init__(__self__, *,
                 href: str,
                 rel: str):
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> str:
        return pulumi.get(self, "href")

    @property
    @pulumi.getter
    def rel(self) -> str:
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetPrivatelinkEndpointsServiceAdlResultResult(dict):
    def __init__(__self__, *,
                 comment: str,
                 endpoint_id: str,
                 provider_name: str,
                 type: str):
        """
        :param str comment: Human-readable string to associate with this private endpoint.
        :param str endpoint_id: Unique 22-character alphanumeric string that identifies the private endpoint. Atlas supports AWS private endpoints using the [|aws| PrivateLink](https://aws.amazon.com/privatelink/) feature.
        :param str provider_name: Human-readable label that identifies the cloud provider for this endpoint.
        :param str type: Human-readable label that identifies the type of resource to associate with this private endpoint.
        """
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "endpoint_id", endpoint_id)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def comment(self) -> str:
        """
        Human-readable string to associate with this private endpoint.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> str:
        """
        Unique 22-character alphanumeric string that identifies the private endpoint. Atlas supports AWS private endpoints using the [|aws| PrivateLink](https://aws.amazon.com/privatelink/) feature.
        """
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Human-readable label that identifies the cloud provider for this endpoint.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Human-readable label that identifies the type of resource to associate with this private endpoint.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetProjectApiKeyResult(dict):
    def __init__(__self__, *,
                 api_key_id: str,
                 role_names: Sequence[str]):
        pulumi.set(__self__, "api_key_id", api_key_id)
        pulumi.set(__self__, "role_names", role_names)

    @property
    @pulumi.getter(name="apiKeyId")
    def api_key_id(self) -> str:
        return pulumi.get(self, "api_key_id")

    @property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[str]:
        return pulumi.get(self, "role_names")


@pulumi.output_type
class GetProjectTeamResult(dict):
    def __init__(__self__, *,
                 role_names: Sequence[str],
                 team_id: str):
        pulumi.set(__self__, "role_names", role_names)
        pulumi.set(__self__, "team_id", team_id)

    @property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[str]:
        return pulumi.get(self, "role_names")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> str:
        return pulumi.get(self, "team_id")


@pulumi.output_type
class GetProjectsResultResult(dict):
    def __init__(__self__, *,
                 api_keys: Sequence['outputs.GetProjectsResultApiKeyResult'],
                 cluster_count: int,
                 created: str,
                 id: str,
                 is_collect_database_specifics_statistics_enabled: bool,
                 is_data_explorer_enabled: bool,
                 is_performance_advisor_enabled: bool,
                 is_realtime_performance_panel_enabled: bool,
                 is_schema_advisor_enabled: bool,
                 name: str,
                 org_id: str,
                 teams: Sequence['outputs.GetProjectsResultTeamResult']):
        """
        :param str id: Autogenerated Unique ID for this data source.
        :param bool is_collect_database_specifics_statistics_enabled: Flag that indicates whether to enable statistics in [cluster metrics](https://www.mongodb.com/docs/atlas/monitor-cluster-metrics/) collection for the project.
        :param bool is_data_explorer_enabled: Flag that indicates whether to enable Data Explorer for the project. If enabled, you can query your database with an easy to use interface.
        :param bool is_performance_advisor_enabled: Flag that indicates whether to enable Performance Advisor and Profiler for the project. If enabled, you can analyze database logs to recommend performance improvements.
        :param bool is_realtime_performance_panel_enabled: Flag that indicates whether to enable Real Time Performance Panel for the project. If enabled, you can see real time metrics from your MongoDB database.
        :param bool is_schema_advisor_enabled: Flag that indicates whether to enable Schema Advisor for the project. If enabled, you receive customized recommendations to optimize your data model and enhance performance. Disable this setting to disable schema suggestions in the [Performance Advisor](https://www.mongodb.com/docs/atlas/performance-advisor/#std-label-performance-advisor) and the [Data Explorer](https://www.mongodb.com/docs/atlas/atlas-ui/#std-label-atlas-ui).
        :param str name: The name of the project you want to create. (Cannot be changed via this Provider after creation.)
        :param str org_id: The ID of the organization you want to create the project within.
               *`cluster_count` - The number of Atlas clusters deployed in the project.
               *`created` - The ISO-8601-formatted timestamp of when Atlas created the project.
               * `teams.#.team_id` - The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
               * `teams.#.role_names` - Each string in the array represents a project role assigned to the team. Every user associated with the team inherits these roles.
               The following are valid roles:
               * `GROUP_OWNER`
               * `GROUP_READ_ONLY`
               * `GROUP_DATA_ACCESS_ADMIN`
               * `GROUP_DATA_ACCESS_READ_WRITE`
               * `GROUP_DATA_ACCESS_READ_ONLY`
               * `GROUP_CLUSTER_MANAGER`
               * `api_keys.#.api_key_id` - The unique identifier of the Organization Programmatic API key assigned to the Project.
               * `api_keys.#.role_names` -  List of roles that the Organization Programmatic API key has been assigned.
               The following are valid roles:
               * `GROUP_OWNER`
               * `GROUP_READ_ONLY`
               * `GROUP_DATA_ACCESS_ADMIN`
               * `GROUP_DATA_ACCESS_READ_WRITE`
               * `GROUP_DATA_ACCESS_READ_ONLY`
               * `GROUP_CLUSTER_MANAGER`
        """
        pulumi.set(__self__, "api_keys", api_keys)
        pulumi.set(__self__, "cluster_count", cluster_count)
        pulumi.set(__self__, "created", created)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_collect_database_specifics_statistics_enabled", is_collect_database_specifics_statistics_enabled)
        pulumi.set(__self__, "is_data_explorer_enabled", is_data_explorer_enabled)
        pulumi.set(__self__, "is_performance_advisor_enabled", is_performance_advisor_enabled)
        pulumi.set(__self__, "is_realtime_performance_panel_enabled", is_realtime_performance_panel_enabled)
        pulumi.set(__self__, "is_schema_advisor_enabled", is_schema_advisor_enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="apiKeys")
    def api_keys(self) -> Sequence['outputs.GetProjectsResultApiKeyResult']:
        return pulumi.get(self, "api_keys")

    @property
    @pulumi.getter(name="clusterCount")
    def cluster_count(self) -> int:
        return pulumi.get(self, "cluster_count")

    @property
    @pulumi.getter
    def created(self) -> str:
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Autogenerated Unique ID for this data source.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isCollectDatabaseSpecificsStatisticsEnabled")
    def is_collect_database_specifics_statistics_enabled(self) -> bool:
        """
        Flag that indicates whether to enable statistics in [cluster metrics](https://www.mongodb.com/docs/atlas/monitor-cluster-metrics/) collection for the project.
        """
        return pulumi.get(self, "is_collect_database_specifics_statistics_enabled")

    @property
    @pulumi.getter(name="isDataExplorerEnabled")
    def is_data_explorer_enabled(self) -> bool:
        """
        Flag that indicates whether to enable Data Explorer for the project. If enabled, you can query your database with an easy to use interface.
        """
        return pulumi.get(self, "is_data_explorer_enabled")

    @property
    @pulumi.getter(name="isPerformanceAdvisorEnabled")
    def is_performance_advisor_enabled(self) -> bool:
        """
        Flag that indicates whether to enable Performance Advisor and Profiler for the project. If enabled, you can analyze database logs to recommend performance improvements.
        """
        return pulumi.get(self, "is_performance_advisor_enabled")

    @property
    @pulumi.getter(name="isRealtimePerformancePanelEnabled")
    def is_realtime_performance_panel_enabled(self) -> bool:
        """
        Flag that indicates whether to enable Real Time Performance Panel for the project. If enabled, you can see real time metrics from your MongoDB database.
        """
        return pulumi.get(self, "is_realtime_performance_panel_enabled")

    @property
    @pulumi.getter(name="isSchemaAdvisorEnabled")
    def is_schema_advisor_enabled(self) -> bool:
        """
        Flag that indicates whether to enable Schema Advisor for the project. If enabled, you receive customized recommendations to optimize your data model and enhance performance. Disable this setting to disable schema suggestions in the [Performance Advisor](https://www.mongodb.com/docs/atlas/performance-advisor/#std-label-performance-advisor) and the [Data Explorer](https://www.mongodb.com/docs/atlas/atlas-ui/#std-label-atlas-ui).
        """
        return pulumi.get(self, "is_schema_advisor_enabled")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the project you want to create. (Cannot be changed via this Provider after creation.)
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        The ID of the organization you want to create the project within.
        *`cluster_count` - The number of Atlas clusters deployed in the project.
        *`created` - The ISO-8601-formatted timestamp of when Atlas created the project.
        * `teams.#.team_id` - The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
        * `teams.#.role_names` - Each string in the array represents a project role assigned to the team. Every user associated with the team inherits these roles.
        The following are valid roles:
        * `GROUP_OWNER`
        * `GROUP_READ_ONLY`
        * `GROUP_DATA_ACCESS_ADMIN`
        * `GROUP_DATA_ACCESS_READ_WRITE`
        * `GROUP_DATA_ACCESS_READ_ONLY`
        * `GROUP_CLUSTER_MANAGER`
        * `api_keys.#.api_key_id` - The unique identifier of the Organization Programmatic API key assigned to the Project.
        * `api_keys.#.role_names` -  List of roles that the Organization Programmatic API key has been assigned.
        The following are valid roles:
        * `GROUP_OWNER`
        * `GROUP_READ_ONLY`
        * `GROUP_DATA_ACCESS_ADMIN`
        * `GROUP_DATA_ACCESS_READ_WRITE`
        * `GROUP_DATA_ACCESS_READ_ONLY`
        * `GROUP_CLUSTER_MANAGER`
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter
    def teams(self) -> Sequence['outputs.GetProjectsResultTeamResult']:
        return pulumi.get(self, "teams")


@pulumi.output_type
class GetProjectsResultApiKeyResult(dict):
    def __init__(__self__, *,
                 api_key_id: str,
                 role_names: Sequence[str]):
        pulumi.set(__self__, "api_key_id", api_key_id)
        pulumi.set(__self__, "role_names", role_names)

    @property
    @pulumi.getter(name="apiKeyId")
    def api_key_id(self) -> str:
        return pulumi.get(self, "api_key_id")

    @property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[str]:
        return pulumi.get(self, "role_names")


@pulumi.output_type
class GetProjectsResultTeamResult(dict):
    def __init__(__self__, *,
                 role_names: Sequence[str],
                 team_id: str):
        pulumi.set(__self__, "role_names", role_names)
        pulumi.set(__self__, "team_id", team_id)

    @property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[str]:
        return pulumi.get(self, "role_names")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> str:
        return pulumi.get(self, "team_id")


@pulumi.output_type
class GetSearchIndexSynonymResult(dict):
    def __init__(__self__, *,
                 analyzer: str,
                 name: str,
                 source_collection: str):
        """
        :param str analyzer: [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.
        :param str name: Name of the index.
        """
        pulumi.set(__self__, "analyzer", analyzer)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source_collection", source_collection)

    @property
    @pulumi.getter
    def analyzer(self) -> str:
        """
        [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.
        """
        return pulumi.get(self, "analyzer")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the index.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sourceCollection")
    def source_collection(self) -> str:
        return pulumi.get(self, "source_collection")


@pulumi.output_type
class GetSearchIndexesResultResult(dict):
    def __init__(__self__, *,
                 analyzer: str,
                 cluster_name: str,
                 collection_name: str,
                 database: str,
                 index_id: str,
                 name: str,
                 project_id: str,
                 status: str,
                 analyzers: Optional[str] = None,
                 mappings_dynamic: Optional[bool] = None,
                 mappings_fields: Optional[str] = None,
                 search_analyzer: Optional[str] = None,
                 synonyms: Optional[Sequence['outputs.GetSearchIndexesResultSynonymResult']] = None):
        """
        :param str analyzer: [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.
        :param str cluster_name: Name of the cluster containing the collection with one or more Atlas Search indexes.
        :param str collection_name: Name of the collection with one or more Atlas Search indexes.
        :param str database: (Required) Name of the database the collection is in.
        :param str name: Name of the index.
        :param str project_id: Unique identifier for the [project](https://docs.atlas.mongodb.com/organizations-projects/#std-label-projects) that contains the specified cluster.
        :param str analyzers: [Custom analyzers](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-custom-analyzers) to use in this index (this is an array of objects).
        :param bool mappings_dynamic: Flag indicating whether the index uses dynamic or static mappings.
        :param str mappings_fields: Object containing one or more field specifications.
        :param str search_analyzer: [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when searching the index.
        :param Sequence['GetSearchIndexesResultSynonymArgs'] synonyms: Synonyms mapping definition to use in this index.
               * `synonyms.#.name` - Name of the [synonym mapping definition](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-ref).
               * `synonyms.#.source_collection` - Name of the source MongoDB collection for the synonyms.
               * `synonyms.#.analyzer` - Name of the [analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use with this synonym mapping.
        """
        pulumi.set(__self__, "analyzer", analyzer)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "index_id", index_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "status", status)
        if analyzers is not None:
            pulumi.set(__self__, "analyzers", analyzers)
        if mappings_dynamic is not None:
            pulumi.set(__self__, "mappings_dynamic", mappings_dynamic)
        if mappings_fields is not None:
            pulumi.set(__self__, "mappings_fields", mappings_fields)
        if search_analyzer is not None:
            pulumi.set(__self__, "search_analyzer", search_analyzer)
        if synonyms is not None:
            pulumi.set(__self__, "synonyms", synonyms)

    @property
    @pulumi.getter
    def analyzer(self) -> str:
        """
        [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.
        """
        return pulumi.get(self, "analyzer")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        Name of the cluster containing the collection with one or more Atlas Search indexes.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> str:
        """
        Name of the collection with one or more Atlas Search indexes.
        """
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        (Required) Name of the database the collection is in.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="indexId")
    def index_id(self) -> str:
        return pulumi.get(self, "index_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the index.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Unique identifier for the [project](https://docs.atlas.mongodb.com/organizations-projects/#std-label-projects) that contains the specified cluster.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def analyzers(self) -> Optional[str]:
        """
        [Custom analyzers](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-custom-analyzers) to use in this index (this is an array of objects).
        """
        return pulumi.get(self, "analyzers")

    @property
    @pulumi.getter(name="mappingsDynamic")
    def mappings_dynamic(self) -> Optional[bool]:
        """
        Flag indicating whether the index uses dynamic or static mappings.
        """
        return pulumi.get(self, "mappings_dynamic")

    @property
    @pulumi.getter(name="mappingsFields")
    def mappings_fields(self) -> Optional[str]:
        """
        Object containing one or more field specifications.
        """
        return pulumi.get(self, "mappings_fields")

    @property
    @pulumi.getter(name="searchAnalyzer")
    def search_analyzer(self) -> Optional[str]:
        """
        [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when searching the index.
        """
        return pulumi.get(self, "search_analyzer")

    @property
    @pulumi.getter
    def synonyms(self) -> Optional[Sequence['outputs.GetSearchIndexesResultSynonymResult']]:
        """
        Synonyms mapping definition to use in this index.
        * `synonyms.#.name` - Name of the [synonym mapping definition](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-ref).
        * `synonyms.#.source_collection` - Name of the source MongoDB collection for the synonyms.
        * `synonyms.#.analyzer` - Name of the [analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use with this synonym mapping.
        """
        return pulumi.get(self, "synonyms")


@pulumi.output_type
class GetSearchIndexesResultSynonymResult(dict):
    def __init__(__self__, *,
                 analyzer: str,
                 name: str,
                 source_collection: str):
        """
        :param str analyzer: [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.
        :param str name: Name of the index.
        """
        pulumi.set(__self__, "analyzer", analyzer)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source_collection", source_collection)

    @property
    @pulumi.getter
    def analyzer(self) -> str:
        """
        [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.
        """
        return pulumi.get(self, "analyzer")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the index.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sourceCollection")
    def source_collection(self) -> str:
        return pulumi.get(self, "source_collection")


@pulumi.output_type
class GetServerlessInstanceLinkResult(dict):
    def __init__(__self__, *,
                 href: str,
                 rel: str):
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> str:
        return pulumi.get(self, "href")

    @property
    @pulumi.getter
    def rel(self) -> str:
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetServerlessInstancesResultResult(dict):
    def __init__(__self__, *,
                 connection_strings_standard_srv: str,
                 create_date: str,
                 id: str,
                 links: Sequence['outputs.GetServerlessInstancesResultLinkResult'],
                 mongo_db_version: str,
                 name: str,
                 project_id: str,
                 provider_settings_backing_provider_name: str,
                 provider_settings_provider_name: str,
                 provider_settings_region_name: str,
                 state_name: str):
        """
        :param str connection_strings_standard_srv: Public `mongodb+srv://` connection string that you can use to connect to this serverless instance.
        :param str id: Unique 24-hexadecimal digit string that identifies the serverless instance.
        :param str mongo_db_version: Version of MongoDB that the serverless instance runs, in `<major version>`.`<minor version>` format.
        :param str name: (Required) Human-readable label that identifies your serverless instance.
        :param str project_id: Unique identifier for the [project](https://docs.atlas.mongodb.com/organizations-projects/#std-label-projects) that contains the specified cluster.
        :param str provider_settings_backing_provider_name: Cloud service provider on which MongoDB Cloud provisioned the serverless instance.
        :param str provider_settings_provider_name: Cloud service provider that applies to the provisioned the serverless instance.
        :param str provider_settings_region_name: Human-readable label that identifies the physical location of your MongoDB serverless instance. The region you choose can affect network latency for clients accessing your databases.
        :param str state_name: Stage of deployment of this serverless instance when the resource made its request.
        """
        pulumi.set(__self__, "connection_strings_standard_srv", connection_strings_standard_srv)
        pulumi.set(__self__, "create_date", create_date)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "links", links)
        pulumi.set(__self__, "mongo_db_version", mongo_db_version)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "provider_settings_backing_provider_name", provider_settings_backing_provider_name)
        pulumi.set(__self__, "provider_settings_provider_name", provider_settings_provider_name)
        pulumi.set(__self__, "provider_settings_region_name", provider_settings_region_name)
        pulumi.set(__self__, "state_name", state_name)

    @property
    @pulumi.getter(name="connectionStringsStandardSrv")
    def connection_strings_standard_srv(self) -> str:
        """
        Public `mongodb+srv://` connection string that you can use to connect to this serverless instance.
        """
        return pulumi.get(self, "connection_strings_standard_srv")

    @property
    @pulumi.getter(name="createDate")
    def create_date(self) -> str:
        return pulumi.get(self, "create_date")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the serverless instance.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def links(self) -> Sequence['outputs.GetServerlessInstancesResultLinkResult']:
        return pulumi.get(self, "links")

    @property
    @pulumi.getter(name="mongoDbVersion")
    def mongo_db_version(self) -> str:
        """
        Version of MongoDB that the serverless instance runs, in `<major version>`.`<minor version>` format.
        """
        return pulumi.get(self, "mongo_db_version")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        (Required) Human-readable label that identifies your serverless instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Unique identifier for the [project](https://docs.atlas.mongodb.com/organizations-projects/#std-label-projects) that contains the specified cluster.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="providerSettingsBackingProviderName")
    def provider_settings_backing_provider_name(self) -> str:
        """
        Cloud service provider on which MongoDB Cloud provisioned the serverless instance.
        """
        return pulumi.get(self, "provider_settings_backing_provider_name")

    @property
    @pulumi.getter(name="providerSettingsProviderName")
    def provider_settings_provider_name(self) -> str:
        """
        Cloud service provider that applies to the provisioned the serverless instance.
        """
        return pulumi.get(self, "provider_settings_provider_name")

    @property
    @pulumi.getter(name="providerSettingsRegionName")
    def provider_settings_region_name(self) -> str:
        """
        Human-readable label that identifies the physical location of your MongoDB serverless instance. The region you choose can affect network latency for clients accessing your databases.
        """
        return pulumi.get(self, "provider_settings_region_name")

    @property
    @pulumi.getter(name="stateName")
    def state_name(self) -> str:
        """
        Stage of deployment of this serverless instance when the resource made its request.
        """
        return pulumi.get(self, "state_name")


@pulumi.output_type
class GetServerlessInstancesResultLinkResult(dict):
    def __init__(__self__, *,
                 href: str,
                 rel: str):
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> str:
        return pulumi.get(self, "href")

    @property
    @pulumi.getter
    def rel(self) -> str:
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetThirdPartyIntegrationsResultResult(dict):
    def __init__(__self__, *,
                 account_id: str,
                 api_key: str,
                 api_token: str,
                 channel_name: str,
                 flow_name: str,
                 license_key: str,
                 org_name: str,
                 project_id: str,
                 read_token: str,
                 region: str,
                 routing_key: str,
                 secret: str,
                 service_key: str,
                 team_name: str,
                 type: str,
                 url: str,
                 write_token: str,
                 enabled: Optional[bool] = None,
                 microsoft_teams_webhook_url: Optional[str] = None,
                 scheme: Optional[str] = None,
                 service_discovery: Optional[str] = None,
                 user_name: Optional[str] = None):
        """
        :param str account_id: Unique identifier of your New Relic account.
        :param str api_key: Your API Key.
        :param str api_token: Your API Token.
        :param str flow_name: Your Flowdock Flow name.
        :param str license_key: Your License Key.
        :param str org_name: Your Flowdock organization name.
               * `WEBHOOK`
        :param str project_id: The unique ID for the project to get all Third-Party service integrations
        :param str read_token: Your Insights Query Key.
               * `OPS_GENIE`
        :param str region: Indicates which API URL to use, either US or EU. Opsgenie will use US by default.
               * `VICTOR_OPS`
        :param str routing_key: An optional field for your Routing Key.
               * `FLOWDOCK`
        :param str secret: An optional field for your webhook secret.
               * `MICROSOFT_TEAMS`
        :param str service_key: Your Service Key.
               * `DATADOG`
        :param str type: (Required) Thirt-Party service integration type.
        :param str url: Your webhook URL.
        :param str write_token: Your Insights Insert Key.
        :param bool enabled: Whether your cluster has Prometheus enabled.
        :param str microsoft_teams_webhook_url: Your Microsoft Teams incoming webhook URL.
               * `PROMETHEUS`
        :param str scheme: Your Prometheus protocol scheme configured for requests.
        :param str service_discovery: Indicates which service discovery method is used, either file or http.
        :param str user_name: Your Prometheus username.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "channel_name", channel_name)
        pulumi.set(__self__, "flow_name", flow_name)
        pulumi.set(__self__, "license_key", license_key)
        pulumi.set(__self__, "org_name", org_name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "read_token", read_token)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "routing_key", routing_key)
        pulumi.set(__self__, "secret", secret)
        pulumi.set(__self__, "service_key", service_key)
        pulumi.set(__self__, "team_name", team_name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "write_token", write_token)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if microsoft_teams_webhook_url is not None:
            pulumi.set(__self__, "microsoft_teams_webhook_url", microsoft_teams_webhook_url)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)
        if service_discovery is not None:
            pulumi.set(__self__, "service_discovery", service_discovery)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        """
        Unique identifier of your New Relic account.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Your API Key.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        Your API Token.
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> str:
        return pulumi.get(self, "channel_name")

    @property
    @pulumi.getter(name="flowName")
    def flow_name(self) -> str:
        """
        Your Flowdock Flow name.
        """
        return pulumi.get(self, "flow_name")

    @property
    @pulumi.getter(name="licenseKey")
    def license_key(self) -> str:
        """
        Your License Key.
        """
        return pulumi.get(self, "license_key")

    @property
    @pulumi.getter(name="orgName")
    def org_name(self) -> str:
        """
        Your Flowdock organization name.
        * `WEBHOOK`
        """
        return pulumi.get(self, "org_name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project to get all Third-Party service integrations
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="readToken")
    def read_token(self) -> str:
        """
        Your Insights Query Key.
        * `OPS_GENIE`
        """
        return pulumi.get(self, "read_token")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Indicates which API URL to use, either US or EU. Opsgenie will use US by default.
        * `VICTOR_OPS`
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="routingKey")
    def routing_key(self) -> str:
        """
        An optional field for your Routing Key.
        * `FLOWDOCK`
        """
        return pulumi.get(self, "routing_key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        An optional field for your webhook secret.
        * `MICROSOFT_TEAMS`
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="serviceKey")
    def service_key(self) -> str:
        """
        Your Service Key.
        * `DATADOG`
        """
        return pulumi.get(self, "service_key")

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> str:
        return pulumi.get(self, "team_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        (Required) Thirt-Party service integration type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Your webhook URL.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="writeToken")
    def write_token(self) -> str:
        """
        Your Insights Insert Key.
        """
        return pulumi.get(self, "write_token")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether your cluster has Prometheus enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="microsoftTeamsWebhookUrl")
    def microsoft_teams_webhook_url(self) -> Optional[str]:
        """
        Your Microsoft Teams incoming webhook URL.
        * `PROMETHEUS`
        """
        return pulumi.get(self, "microsoft_teams_webhook_url")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Your Prometheus protocol scheme configured for requests.
        """
        return pulumi.get(self, "scheme")

    @property
    @pulumi.getter(name="serviceDiscovery")
    def service_discovery(self) -> Optional[str]:
        """
        Indicates which service discovery method is used, either file or http.
        """
        return pulumi.get(self, "service_discovery")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        """
        Your Prometheus username.
        """
        return pulumi.get(self, "user_name")


