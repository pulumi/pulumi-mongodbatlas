# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'AdvancedClusterAdvancedConfiguration',
    'AdvancedClusterBiConnectorConfig',
    'AdvancedClusterConnectionString',
    'AdvancedClusterConnectionStringPrivateEndpoint',
    'AdvancedClusterConnectionStringPrivateEndpointEndpoint',
    'AdvancedClusterLabel',
    'AdvancedClusterReplicationSpec',
    'AdvancedClusterReplicationSpecRegionConfig',
    'AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling',
    'AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs',
    'AdvancedClusterReplicationSpecRegionConfigAutoScaling',
    'AdvancedClusterReplicationSpecRegionConfigElectableSpecs',
    'AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs',
    'AdvancedClusterTag',
    'AlertConfigurationMatcher',
    'AlertConfigurationMetricThresholdConfig',
    'AlertConfigurationNotification',
    'AlertConfigurationThresholdConfig',
    'BackupCompliancePolicyOnDemandPolicyItem',
    'BackupCompliancePolicyPolicyItemDaily',
    'BackupCompliancePolicyPolicyItemHourly',
    'BackupCompliancePolicyPolicyItemMonthly',
    'BackupCompliancePolicyPolicyItemWeekly',
    'CloudBackupScheduleCopySetting',
    'CloudBackupScheduleExport',
    'CloudBackupSchedulePolicyItemDaily',
    'CloudBackupSchedulePolicyItemHourly',
    'CloudBackupSchedulePolicyItemMonthly',
    'CloudBackupSchedulePolicyItemWeekly',
    'CloudBackupSnapshotExportJobComponent',
    'CloudBackupSnapshotExportJobCustomData',
    'CloudBackupSnapshotMember',
    'CloudBackupSnapshotRestoreJobDeliveryTypeConfig',
    'CloudProviderAccessAuthorizationAws',
    'CloudProviderAccessAuthorizationAzure',
    'CloudProviderAccessAuthorizationFeatureUsage',
    'CloudProviderAccessFeatureUsage',
    'CloudProviderAccessSetupAwsConfig',
    'CloudProviderAccessSetupAzureConfig',
    'ClusterAdvancedConfiguration',
    'ClusterBiConnectorConfig',
    'ClusterConnectionString',
    'ClusterConnectionStringPrivateEndpoint',
    'ClusterConnectionStringPrivateEndpointEndpoint',
    'ClusterLabel',
    'ClusterOutageSimulationOutageFilter',
    'ClusterReplicationSpec',
    'ClusterReplicationSpecRegionsConfig',
    'ClusterSnapshotBackupPolicy',
    'ClusterSnapshotBackupPolicyPolicy',
    'ClusterSnapshotBackupPolicyPolicyPolicyItem',
    'ClusterTag',
    'CustomDbRoleAction',
    'CustomDbRoleActionResource',
    'CustomDbRoleInheritedRole',
    'DataLakeAws',
    'DataLakeDataProcessRegion',
    'DataLakePipelineIngestionSchedule',
    'DataLakePipelineSink',
    'DataLakePipelineSinkPartitionField',
    'DataLakePipelineSnapshot',
    'DataLakePipelineSource',
    'DataLakePipelineTransformation',
    'DataLakeStorageDatabase',
    'DataLakeStorageDatabaseCollection',
    'DataLakeStorageDatabaseCollectionDataSource',
    'DataLakeStorageDatabaseView',
    'DataLakeStorageStore',
    'DatabaseUserLabel',
    'DatabaseUserRole',
    'DatabaseUserScope',
    'EncryptionAtRestAwsKmsConfig',
    'EncryptionAtRestAzureKeyVaultConfig',
    'EncryptionAtRestGoogleCloudKmsConfig',
    'EventTriggerEventProcessors',
    'EventTriggerEventProcessorsAwsEventbridge',
    'FederatedDatabaseInstanceCloudProviderConfig',
    'FederatedDatabaseInstanceCloudProviderConfigAws',
    'FederatedDatabaseInstanceDataProcessRegion',
    'FederatedDatabaseInstanceStorageDatabase',
    'FederatedDatabaseInstanceStorageDatabaseCollection',
    'FederatedDatabaseInstanceStorageDatabaseCollectionDataSource',
    'FederatedDatabaseInstanceStorageDatabaseView',
    'FederatedDatabaseInstanceStorageStore',
    'FederatedDatabaseInstanceStorageStoreReadPreference',
    'FederatedDatabaseInstanceStorageStoreReadPreferenceTagSet',
    'FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTag',
    'FederatedSettingsOrgRoleMappingRoleAssignment',
    'GlobalClusterConfigCustomZoneMapping',
    'GlobalClusterConfigManagedNamespace',
    'LdapConfigurationUserToDnMapping',
    'LdapVerifyLink',
    'LdapVerifyValidation',
    'OnlineArchiveCriteria',
    'OnlineArchivePartitionField',
    'OnlineArchiveSchedule',
    'PrivateLinkEndpointServiceEndpoint',
    'ProjectApiKeyProjectAssignment',
    'ProjectIpAccessListTimeouts',
    'ProjectLimit',
    'ProjectTeam',
    'SearchIndexSynonym',
    'ServerlessInstanceLink',
    'ServerlessInstanceTag',
    'X509AuthenticationDatabaseUserCertificate',
    'Get509AuthenticationDatabaseUserCertificateResult',
    'GetAccessListApiKeysResultResult',
    'GetAdvancedClusterAdvancedConfigurationResult',
    'GetAdvancedClusterBiConnectorConfigResult',
    'GetAdvancedClusterConnectionStringResult',
    'GetAdvancedClusterConnectionStringPrivateEndpointResult',
    'GetAdvancedClusterConnectionStringPrivateEndpointEndpointResult',
    'GetAdvancedClusterLabelResult',
    'GetAdvancedClusterReplicationSpecResult',
    'GetAdvancedClusterReplicationSpecRegionConfigResult',
    'GetAdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingResult',
    'GetAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsResult',
    'GetAdvancedClusterReplicationSpecRegionConfigAutoScalingResult',
    'GetAdvancedClusterReplicationSpecRegionConfigElectableSpecsResult',
    'GetAdvancedClusterReplicationSpecRegionConfigReadOnlySpecsResult',
    'GetAdvancedClusterTagResult',
    'GetAdvancedClustersResultResult',
    'GetAdvancedClustersResultAdvancedConfigurationResult',
    'GetAdvancedClustersResultBiConnectorConfigResult',
    'GetAdvancedClustersResultConnectionStringResult',
    'GetAdvancedClustersResultConnectionStringPrivateEndpointResult',
    'GetAdvancedClustersResultConnectionStringPrivateEndpointEndpointResult',
    'GetAdvancedClustersResultLabelResult',
    'GetAdvancedClustersResultReplicationSpecResult',
    'GetAdvancedClustersResultReplicationSpecRegionConfigResult',
    'GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsAutoScalingResult',
    'GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecsResult',
    'GetAdvancedClustersResultReplicationSpecRegionConfigAutoScalingResult',
    'GetAdvancedClustersResultReplicationSpecRegionConfigElectableSpecsResult',
    'GetAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecsResult',
    'GetAdvancedClustersResultTagResult',
    'GetAlertConfigurationMatcherResult',
    'GetAlertConfigurationMetricThresholdConfigResult',
    'GetAlertConfigurationNotificationResult',
    'GetAlertConfigurationOutputResult',
    'GetAlertConfigurationThresholdConfigResult',
    'GetAlertConfigurationsListOptionResult',
    'GetAlertConfigurationsResultResult',
    'GetAlertConfigurationsResultMatcherResult',
    'GetAlertConfigurationsResultMetricThresholdConfigResult',
    'GetAlertConfigurationsResultNotificationResult',
    'GetAlertConfigurationsResultOutputResult',
    'GetAlertConfigurationsResultThresholdConfigResult',
    'GetApiKeysResultResult',
    'GetAtlasUserLinkResult',
    'GetAtlasUserRoleResult',
    'GetAtlasUsersResultResult',
    'GetAtlasUsersResultLinkResult',
    'GetAtlasUsersResultRoleResult',
    'GetBackupCompliancePolicyOnDemandPolicyItemResult',
    'GetBackupCompliancePolicyPolicyItemDailyResult',
    'GetBackupCompliancePolicyPolicyItemHourlyResult',
    'GetBackupCompliancePolicyPolicyItemMonthlyResult',
    'GetBackupCompliancePolicyPolicyItemWeeklyResult',
    'GetCloudBackupScheduleCopySettingResult',
    'GetCloudBackupScheduleExportResult',
    'GetCloudBackupSchedulePolicyItemDailyResult',
    'GetCloudBackupSchedulePolicyItemHourlyResult',
    'GetCloudBackupSchedulePolicyItemMonthlyResult',
    'GetCloudBackupSchedulePolicyItemWeeklyResult',
    'GetCloudBackupSnapshotExportBucketsResultResult',
    'GetCloudBackupSnapshotExportJobComponentResult',
    'GetCloudBackupSnapshotExportJobCustomDataResult',
    'GetCloudBackupSnapshotExportJobsResultResult',
    'GetCloudBackupSnapshotExportJobsResultComponentResult',
    'GetCloudBackupSnapshotExportJobsResultCustomDataResult',
    'GetCloudBackupSnapshotMemberResult',
    'GetCloudBackupSnapshotRestoreJobsResultResult',
    'GetCloudBackupSnapshotsResultResult',
    'GetCloudBackupSnapshotsResultMemberResult',
    'GetCloudProviderAccessAwsIamRoleResult',
    'GetCloudProviderAccessAwsIamRoleFeatureUsageResult',
    'GetCloudProviderAccessSetupAwsConfigResult',
    'GetCloudProviderAccessSetupAzureConfigResult',
    'GetClusterAdvancedConfigurationResult',
    'GetClusterBiConnectorConfigResult',
    'GetClusterConnectionStringResult',
    'GetClusterConnectionStringPrivateEndpointResult',
    'GetClusterConnectionStringPrivateEndpointEndpointResult',
    'GetClusterLabelResult',
    'GetClusterOutageSimulationOutageFilterResult',
    'GetClusterReplicationSpecResult',
    'GetClusterReplicationSpecRegionsConfigResult',
    'GetClusterSnapshotBackupPolicyResult',
    'GetClusterSnapshotBackupPolicyPolicyResult',
    'GetClusterSnapshotBackupPolicyPolicyPolicyItemResult',
    'GetClusterTagResult',
    'GetClustersResultResult',
    'GetClustersResultAdvancedConfigurationResult',
    'GetClustersResultBiConnectorConfigResult',
    'GetClustersResultConnectionStringResult',
    'GetClustersResultConnectionStringPrivateEndpointResult',
    'GetClustersResultConnectionStringPrivateEndpointEndpointResult',
    'GetClustersResultLabelResult',
    'GetClustersResultReplicationSpecResult',
    'GetClustersResultReplicationSpecRegionsConfigResult',
    'GetClustersResultSnapshotBackupPolicyResult',
    'GetClustersResultSnapshotBackupPolicyPolicyResult',
    'GetClustersResultSnapshotBackupPolicyPolicyPolicyItemResult',
    'GetClustersResultTagResult',
    'GetCustomDbRoleActionResult',
    'GetCustomDbRoleActionResourceResult',
    'GetCustomDbRoleInheritedRoleResult',
    'GetCustomDbRolesResultResult',
    'GetCustomDbRolesResultActionResult',
    'GetCustomDbRolesResultActionResourceResult',
    'GetCustomDbRolesResultInheritedRoleResult',
    'GetDataLakeAwResult',
    'GetDataLakeDataProcessRegionResult',
    'GetDataLakePipelineIngestionScheduleResult',
    'GetDataLakePipelineRunStatResult',
    'GetDataLakePipelineRunsResultResult',
    'GetDataLakePipelineRunsResultStatResult',
    'GetDataLakePipelineSinkResult',
    'GetDataLakePipelineSinkPartitionFieldResult',
    'GetDataLakePipelineSnapshotResult',
    'GetDataLakePipelineSourceResult',
    'GetDataLakePipelineTransformationResult',
    'GetDataLakePipelinesResultResult',
    'GetDataLakePipelinesResultSinkResult',
    'GetDataLakePipelinesResultSinkPartitionFieldResult',
    'GetDataLakePipelinesResultSourceResult',
    'GetDataLakePipelinesResultTransformationResult',
    'GetDataLakeStorageDatabaseResult',
    'GetDataLakeStorageDatabaseCollectionResult',
    'GetDataLakeStorageDatabaseCollectionDataSourceResult',
    'GetDataLakeStorageDatabaseViewResult',
    'GetDataLakeStorageStoreResult',
    'GetDataLakesResultResult',
    'GetDataLakesResultAwResult',
    'GetDataLakesResultDataProcessRegionResult',
    'GetDataLakesResultStorageDatabaseResult',
    'GetDataLakesResultStorageDatabaseCollectionResult',
    'GetDataLakesResultStorageDatabaseCollectionDataSourceResult',
    'GetDataLakesResultStorageDatabaseViewResult',
    'GetDataLakesResultStorageStoreResult',
    'GetDatabaseUserLabelResult',
    'GetDatabaseUserRoleResult',
    'GetDatabaseUserScopeResult',
    'GetDatabaseUsersResultResult',
    'GetDatabaseUsersResultLabelResult',
    'GetDatabaseUsersResultRoleResult',
    'GetDatabaseUsersResultScopeResult',
    'GetEventTriggerEventProcessorResult',
    'GetEventTriggerEventProcessorAwsEventbridgeResult',
    'GetEventTriggersResultResult',
    'GetEventTriggersResultEventProcessorResult',
    'GetEventTriggersResultEventProcessorAwsEventbridgeResult',
    'GetFederatedDatabaseInstanceCloudProviderConfigResult',
    'GetFederatedDatabaseInstanceCloudProviderConfigAwsResult',
    'GetFederatedDatabaseInstanceDataProcessRegionResult',
    'GetFederatedDatabaseInstanceStorageDatabaseResult',
    'GetFederatedDatabaseInstanceStorageDatabaseCollectionResult',
    'GetFederatedDatabaseInstanceStorageDatabaseCollectionDataSourceResult',
    'GetFederatedDatabaseInstanceStorageDatabaseViewResult',
    'GetFederatedDatabaseInstanceStorageStoreResult',
    'GetFederatedDatabaseInstanceStorageStoreReadPreferenceResult',
    'GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetResult',
    'GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTagResult',
    'GetFederatedDatabaseInstancesResultResult',
    'GetFederatedDatabaseInstancesResultCloudProviderConfigResult',
    'GetFederatedDatabaseInstancesResultCloudProviderConfigAwsResult',
    'GetFederatedDatabaseInstancesResultDataProcessRegionResult',
    'GetFederatedDatabaseInstancesResultStorageDatabaseResult',
    'GetFederatedDatabaseInstancesResultStorageDatabaseCollectionResult',
    'GetFederatedDatabaseInstancesResultStorageDatabaseCollectionDataSourceResult',
    'GetFederatedDatabaseInstancesResultStorageDatabaseViewResult',
    'GetFederatedDatabaseInstancesResultStorageStoreResult',
    'GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceResult',
    'GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetResult',
    'GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetTagResult',
    'GetFederatedQueryLimitsResultResult',
    'GetFederatedSettingsIdentityProviderAssociatedOrgResult',
    'GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingResult',
    'GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignmentResult',
    'GetFederatedSettingsIdentityProviderAssociatedOrgUserConflictResult',
    'GetFederatedSettingsIdentityProviderPemFileInfoResult',
    'GetFederatedSettingsIdentityProviderPemFileInfoCertificateResult',
    'GetFederatedSettingsIdentityProvidersResultResult',
    'GetFederatedSettingsIdentityProvidersResultAssociatedOrgResult',
    'GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingResult',
    'GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignmentResult',
    'GetFederatedSettingsIdentityProvidersResultAssociatedOrgUserConflictResult',
    'GetFederatedSettingsIdentityProvidersResultPemFileInfoResult',
    'GetFederatedSettingsIdentityProvidersResultPemFileInfoCertificateResult',
    'GetFederatedSettingsOrgConfigRoleMappingResult',
    'GetFederatedSettingsOrgConfigRoleMappingRoleAssignmentResult',
    'GetFederatedSettingsOrgConfigUserConflictResult',
    'GetFederatedSettingsOrgConfigsResultResult',
    'GetFederatedSettingsOrgConfigsResultRoleMappingResult',
    'GetFederatedSettingsOrgConfigsResultRoleMappingRoleAssignmentResult',
    'GetFederatedSettingsOrgConfigsResultUserConflictResult',
    'GetFederatedSettingsOrgRoleMappingRoleAssignmentResult',
    'GetFederatedSettingsOrgRoleMappingsResultResult',
    'GetFederatedSettingsOrgRoleMappingsResultRoleAssignmentResult',
    'GetGlobalClusterConfigManagedNamespaceResult',
    'GetLdapConfigurationUserToDnMappingResult',
    'GetLdapVerifyLinkResult',
    'GetLdapVerifyValidationResult',
    'GetNetworkContainersResultResult',
    'GetNetworkPeeringsResultResult',
    'GetOnlineArchiveCriteriaResult',
    'GetOnlineArchivePartitionFieldResult',
    'GetOnlineArchiveScheduleResult',
    'GetOnlineArchivesResultResult',
    'GetOnlineArchivesResultCriteriaResult',
    'GetOnlineArchivesResultPartitionFieldResult',
    'GetOnlineArchivesResultScheduleResult',
    'GetOrganizationLinkResult',
    'GetOrganizationsResultResult',
    'GetOrganizationsResultLinkResult',
    'GetPrivateLinkEndpointServiceEndpointResult',
    'GetPrivatelinkEndpointServiceDataFederationOnlineArchivesResultResult',
    'GetPrivatelinkEndpointsServiceAdlLinkResult',
    'GetPrivatelinkEndpointsServiceAdlResultResult',
    'GetPrivatelinkEndpointsServiceServerlessResultResult',
    'GetProjectApiKeyProjectAssignmentResult',
    'GetProjectApiKeysResultResult',
    'GetProjectApiKeysResultProjectAssignmentResult',
    'GetProjectLimitResult',
    'GetProjectTeamResult',
    'GetProjectsResultResult',
    'GetProjectsResultLimitResult',
    'GetProjectsResultTeamResult',
    'GetSearchIndexSynonymResult',
    'GetSearchIndexesResultResult',
    'GetSearchIndexesResultSynonymResult',
    'GetServerlessInstanceLinkResult',
    'GetServerlessInstanceTagResult',
    'GetServerlessInstancesResultResult',
    'GetServerlessInstancesResultLinkResult',
    'GetServerlessInstancesResultTagResult',
    'GetSharedTierRestoreJobsResultResult',
    'GetSharedTierSnapshotsResultResult',
    'GetThirdPartyIntegrationsResultResult',
]

@pulumi.output_type
class AdvancedClusterAdvancedConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultReadConcern":
            suggest = "default_read_concern"
        elif key == "defaultWriteConcern":
            suggest = "default_write_concern"
        elif key == "failIndexKeyTooLong":
            suggest = "fail_index_key_too_long"
        elif key == "javascriptEnabled":
            suggest = "javascript_enabled"
        elif key == "minimumEnabledTlsProtocol":
            suggest = "minimum_enabled_tls_protocol"
        elif key == "noTableScan":
            suggest = "no_table_scan"
        elif key == "oplogMinRetentionHours":
            suggest = "oplog_min_retention_hours"
        elif key == "oplogSizeMb":
            suggest = "oplog_size_mb"
        elif key == "sampleRefreshIntervalBiConnector":
            suggest = "sample_refresh_interval_bi_connector"
        elif key == "sampleSizeBiConnector":
            suggest = "sample_size_bi_connector"
        elif key == "transactionLifetimeLimitSeconds":
            suggest = "transaction_lifetime_limit_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterAdvancedConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterAdvancedConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterAdvancedConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_read_concern: Optional[str] = None,
                 default_write_concern: Optional[str] = None,
                 fail_index_key_too_long: Optional[bool] = None,
                 javascript_enabled: Optional[bool] = None,
                 minimum_enabled_tls_protocol: Optional[str] = None,
                 no_table_scan: Optional[bool] = None,
                 oplog_min_retention_hours: Optional[int] = None,
                 oplog_size_mb: Optional[int] = None,
                 sample_refresh_interval_bi_connector: Optional[int] = None,
                 sample_size_bi_connector: Optional[int] = None,
                 transaction_lifetime_limit_seconds: Optional[int] = None):
        """
        :param str default_read_concern: [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        :param str default_write_concern: [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        :param bool fail_index_key_too_long: When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        :param bool javascript_enabled: When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        :param str minimum_enabled_tls_protocol: Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
               
               - TLS1_0
               - TLS1_1
               - TLS1_2
        :param bool no_table_scan: When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        :param int oplog_min_retention_hours: Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
               * **Note**  A minimum oplog retention is required when seeking to change a cluster's class to Local NVMe SSD. To learn more and for latest guidance see [`oplogMinRetentionHours`](https://www.mongodb.com/docs/manual/core/replica-set-oplog/#std-label-replica-set-minimum-oplog-size)
        :param int oplog_size_mb: The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        :param int sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param int sample_size_bi_connector: Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param int transaction_lifetime_limit_seconds: Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        AdvancedClusterAdvancedConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_read_concern=default_read_concern,
            default_write_concern=default_write_concern,
            fail_index_key_too_long=fail_index_key_too_long,
            javascript_enabled=javascript_enabled,
            minimum_enabled_tls_protocol=minimum_enabled_tls_protocol,
            no_table_scan=no_table_scan,
            oplog_min_retention_hours=oplog_min_retention_hours,
            oplog_size_mb=oplog_size_mb,
            sample_refresh_interval_bi_connector=sample_refresh_interval_bi_connector,
            sample_size_bi_connector=sample_size_bi_connector,
            transaction_lifetime_limit_seconds=transaction_lifetime_limit_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_read_concern: Optional[str] = None,
             default_write_concern: Optional[str] = None,
             fail_index_key_too_long: Optional[bool] = None,
             javascript_enabled: Optional[bool] = None,
             minimum_enabled_tls_protocol: Optional[str] = None,
             no_table_scan: Optional[bool] = None,
             oplog_min_retention_hours: Optional[int] = None,
             oplog_size_mb: Optional[int] = None,
             sample_refresh_interval_bi_connector: Optional[int] = None,
             sample_size_bi_connector: Optional[int] = None,
             transaction_lifetime_limit_seconds: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if default_read_concern is not None:
            _setter("default_read_concern", default_read_concern)
        if default_write_concern is not None:
            _setter("default_write_concern", default_write_concern)
        if fail_index_key_too_long is not None:
            _setter("fail_index_key_too_long", fail_index_key_too_long)
        if javascript_enabled is not None:
            _setter("javascript_enabled", javascript_enabled)
        if minimum_enabled_tls_protocol is not None:
            _setter("minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        if no_table_scan is not None:
            _setter("no_table_scan", no_table_scan)
        if oplog_min_retention_hours is not None:
            _setter("oplog_min_retention_hours", oplog_min_retention_hours)
        if oplog_size_mb is not None:
            _setter("oplog_size_mb", oplog_size_mb)
        if sample_refresh_interval_bi_connector is not None:
            _setter("sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        if sample_size_bi_connector is not None:
            _setter("sample_size_bi_connector", sample_size_bi_connector)
        if transaction_lifetime_limit_seconds is not None:
            _setter("transaction_lifetime_limit_seconds", transaction_lifetime_limit_seconds)

    @property
    @pulumi.getter(name="defaultReadConcern")
    def default_read_concern(self) -> Optional[str]:
        """
        [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        """
        return pulumi.get(self, "default_read_concern")

    @property
    @pulumi.getter(name="defaultWriteConcern")
    def default_write_concern(self) -> Optional[str]:
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        return pulumi.get(self, "default_write_concern")

    @property
    @pulumi.getter(name="failIndexKeyTooLong")
    def fail_index_key_too_long(self) -> Optional[bool]:
        """
        When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        """
        return pulumi.get(self, "fail_index_key_too_long")

    @property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> Optional[bool]:
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        return pulumi.get(self, "javascript_enabled")

    @property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> Optional[str]:
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:

        - TLS1_0
        - TLS1_1
        - TLS1_2
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> Optional[bool]:
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        return pulumi.get(self, "no_table_scan")

    @property
    @pulumi.getter(name="oplogMinRetentionHours")
    def oplog_min_retention_hours(self) -> Optional[int]:
        """
        Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        * **Note**  A minimum oplog retention is required when seeking to change a cluster's class to Local NVMe SSD. To learn more and for latest guidance see [`oplogMinRetentionHours`](https://www.mongodb.com/docs/manual/core/replica-set-oplog/#std-label-replica-set-minimum-oplog-size)
        """
        return pulumi.get(self, "oplog_min_retention_hours")

    @property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> Optional[int]:
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        return pulumi.get(self, "oplog_size_mb")

    @property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> Optional[int]:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> Optional[int]:
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_size_bi_connector")

    @property
    @pulumi.getter(name="transactionLifetimeLimitSeconds")
    def transaction_lifetime_limit_seconds(self) -> Optional[int]:
        """
        Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        return pulumi.get(self, "transaction_lifetime_limit_seconds")


@pulumi.output_type
class AdvancedClusterBiConnectorConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readPreference":
            suggest = "read_preference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterBiConnectorConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterBiConnectorConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterBiConnectorConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 read_preference: Optional[str] = None):
        """
        :param bool enabled: Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
               *
               - Set to `true` to enable BI Connector for Atlas.
               - Set to `false` to disable BI Connector for Atlas.
        :param str read_preference: Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
               
               - Set to "primary" to have BI Connector for Atlas read from the primary.
               
               - Set to "secondary" to have BI Connector for Atlas read from a secondary member. Default if there are no analytics nodes in the cluster.
               
               - Set to "analytics" to have BI Connector for Atlas read from an analytics node. Default if the cluster contains analytics nodes.
        """
        AdvancedClusterBiConnectorConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            read_preference=read_preference,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             read_preference: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enabled is not None:
            _setter("enabled", enabled)
        if read_preference is not None:
            _setter("read_preference", read_preference)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
        *
        - Set to `true` to enable BI Connector for Atlas.
        - Set to `false` to disable BI Connector for Atlas.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> Optional[str]:
        """
        Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).

        - Set to "primary" to have BI Connector for Atlas read from the primary.

        - Set to "secondary" to have BI Connector for Atlas read from a secondary member. Default if there are no analytics nodes in the cluster.

        - Set to "analytics" to have BI Connector for Atlas read from an analytics node. Default if the cluster contains analytics nodes.
        """
        return pulumi.get(self, "read_preference")


@pulumi.output_type
class AdvancedClusterConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateEndpoints":
            suggest = "private_endpoints"
        elif key == "privateSrv":
            suggest = "private_srv"
        elif key == "standardSrv":
            suggest = "standard_srv"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private: Optional[str] = None,
                 private_endpoints: Optional[Sequence['outputs.AdvancedClusterConnectionStringPrivateEndpoint']] = None,
                 private_srv: Optional[str] = None,
                 standard: Optional[str] = None,
                 standard_srv: Optional[str] = None):
        AdvancedClusterConnectionString._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private=private,
            private_endpoints=private_endpoints,
            private_srv=private_srv,
            standard=standard,
            standard_srv=standard_srv,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private: Optional[str] = None,
             private_endpoints: Optional[Sequence['outputs.AdvancedClusterConnectionStringPrivateEndpoint']] = None,
             private_srv: Optional[str] = None,
             standard: Optional[str] = None,
             standard_srv: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if private is not None:
            _setter("private", private)
        if private_endpoints is not None:
            _setter("private_endpoints", private_endpoints)
        if private_srv is not None:
            _setter("private_srv", private_srv)
        if standard is not None:
            _setter("standard", standard)
        if standard_srv is not None:
            _setter("standard_srv", standard_srv)

    @property
    @pulumi.getter
    def private(self) -> Optional[str]:
        return pulumi.get(self, "private")

    @property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Optional[Sequence['outputs.AdvancedClusterConnectionStringPrivateEndpoint']]:
        return pulumi.get(self, "private_endpoints")

    @property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> Optional[str]:
        return pulumi.get(self, "private_srv")

    @property
    @pulumi.getter
    def standard(self) -> Optional[str]:
        return pulumi.get(self, "standard")

    @property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> Optional[str]:
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class AdvancedClusterConnectionStringPrivateEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionString":
            suggest = "connection_string"
        elif key == "srvConnectionString":
            suggest = "srv_connection_string"
        elif key == "srvShardOptimizedConnectionString":
            suggest = "srv_shard_optimized_connection_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterConnectionStringPrivateEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterConnectionStringPrivateEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterConnectionStringPrivateEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_string: Optional[str] = None,
                 endpoints: Optional[Sequence['outputs.AdvancedClusterConnectionStringPrivateEndpointEndpoint']] = None,
                 srv_connection_string: Optional[str] = None,
                 srv_shard_optimized_connection_string: Optional[str] = None,
                 type: Optional[str] = None):
        AdvancedClusterConnectionStringPrivateEndpoint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_string=connection_string,
            endpoints=endpoints,
            srv_connection_string=srv_connection_string,
            srv_shard_optimized_connection_string=srv_shard_optimized_connection_string,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_string: Optional[str] = None,
             endpoints: Optional[Sequence['outputs.AdvancedClusterConnectionStringPrivateEndpointEndpoint']] = None,
             srv_connection_string: Optional[str] = None,
             srv_shard_optimized_connection_string: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if connection_string is not None:
            _setter("connection_string", connection_string)
        if endpoints is not None:
            _setter("endpoints", endpoints)
        if srv_connection_string is not None:
            _setter("srv_connection_string", srv_connection_string)
        if srv_shard_optimized_connection_string is not None:
            _setter("srv_shard_optimized_connection_string", srv_shard_optimized_connection_string)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[str]:
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence['outputs.AdvancedClusterConnectionStringPrivateEndpointEndpoint']]:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> Optional[str]:
        return pulumi.get(self, "srv_connection_string")

    @property
    @pulumi.getter(name="srvShardOptimizedConnectionString")
    def srv_shard_optimized_connection_string(self) -> Optional[str]:
        return pulumi.get(self, "srv_shard_optimized_connection_string")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class AdvancedClusterConnectionStringPrivateEndpointEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointId":
            suggest = "endpoint_id"
        elif key == "providerName":
            suggest = "provider_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterConnectionStringPrivateEndpointEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterConnectionStringPrivateEndpointEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterConnectionStringPrivateEndpointEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_id: Optional[str] = None,
                 provider_name: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str provider_name: Cloud service provider on which the servers are provisioned.
               The possible values are:
        """
        AdvancedClusterConnectionStringPrivateEndpointEndpoint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_id=endpoint_id,
            provider_name=provider_name,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_id: Optional[str] = None,
             provider_name: Optional[str] = None,
             region: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if endpoint_id is not None:
            _setter("endpoint_id", endpoint_id)
        if provider_name is not None:
            _setter("provider_name", provider_name)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[str]:
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> Optional[str]:
        """
        Cloud service provider on which the servers are provisioned.
        The possible values are:
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class AdvancedClusterLabel(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
               
               > **NOTE:** MongoDB Atlas doesn't display your labels.
        """
        AdvancedClusterLabel._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value that you want to write.

        > **NOTE:** MongoDB Atlas doesn't display your labels.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AdvancedClusterReplicationSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionConfigs":
            suggest = "region_configs"
        elif key == "containerId":
            suggest = "container_id"
        elif key == "numShards":
            suggest = "num_shards"
        elif key == "zoneName":
            suggest = "zone_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterReplicationSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterReplicationSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterReplicationSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region_configs: Sequence['outputs.AdvancedClusterReplicationSpecRegionConfig'],
                 container_id: Optional[Mapping[str, str]] = None,
                 id: Optional[str] = None,
                 num_shards: Optional[int] = None,
                 zone_name: Optional[str] = None):
        """
        :param Sequence['AdvancedClusterReplicationSpecRegionConfigArgs'] region_configs: Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below
        :param int num_shards: Provide this value if you set a `cluster_type` of SHARDED or GEOSHARDED. Omit this value if you selected a `cluster_type` of REPLICASET. This API resource accepts 1 through 50, inclusive. This parameter defaults to 1. If you specify a `num_shards` value of 1 and a `cluster_type` of SHARDED, Atlas deploys a single-shard [sharded cluster](https://docs.atlas.mongodb.com/reference/glossary/#std-term-sharded-cluster). Don't create a sharded cluster with a single shard for production environments. Single-shard sharded clusters don't provide the same benefits as multi-shard configurations.
        :param str zone_name: Name for the zone in a Global Cluster.
        """
        AdvancedClusterReplicationSpec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            region_configs=region_configs,
            container_id=container_id,
            id=id,
            num_shards=num_shards,
            zone_name=zone_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             region_configs: Sequence['outputs.AdvancedClusterReplicationSpecRegionConfig'],
             container_id: Optional[Mapping[str, str]] = None,
             id: Optional[str] = None,
             num_shards: Optional[int] = None,
             zone_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("region_configs", region_configs)
        if container_id is not None:
            _setter("container_id", container_id)
        if id is not None:
            _setter("id", id)
        if num_shards is not None:
            _setter("num_shards", num_shards)
        if zone_name is not None:
            _setter("zone_name", zone_name)

    @property
    @pulumi.getter(name="regionConfigs")
    def region_configs(self) -> Sequence['outputs.AdvancedClusterReplicationSpecRegionConfig']:
        """
        Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below
        """
        return pulumi.get(self, "region_configs")

    @property
    @pulumi.getter(name="containerId")
    def container_id(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "container_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> Optional[int]:
        """
        Provide this value if you set a `cluster_type` of SHARDED or GEOSHARDED. Omit this value if you selected a `cluster_type` of REPLICASET. This API resource accepts 1 through 50, inclusive. This parameter defaults to 1. If you specify a `num_shards` value of 1 and a `cluster_type` of SHARDED, Atlas deploys a single-shard [sharded cluster](https://docs.atlas.mongodb.com/reference/glossary/#std-term-sharded-cluster). Don't create a sharded cluster with a single shard for production environments. Single-shard sharded clusters don't provide the same benefits as multi-shard configurations.
        """
        return pulumi.get(self, "num_shards")

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> Optional[str]:
        """
        Name for the zone in a Global Cluster.
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class AdvancedClusterReplicationSpecRegionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "providerName":
            suggest = "provider_name"
        elif key == "regionName":
            suggest = "region_name"
        elif key == "analyticsAutoScaling":
            suggest = "analytics_auto_scaling"
        elif key == "analyticsSpecs":
            suggest = "analytics_specs"
        elif key == "autoScaling":
            suggest = "auto_scaling"
        elif key == "backingProviderName":
            suggest = "backing_provider_name"
        elif key == "electableSpecs":
            suggest = "electable_specs"
        elif key == "readOnlySpecs":
            suggest = "read_only_specs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterReplicationSpecRegionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterReplicationSpecRegionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterReplicationSpecRegionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 priority: int,
                 provider_name: str,
                 region_name: str,
                 analytics_auto_scaling: Optional['outputs.AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling'] = None,
                 analytics_specs: Optional['outputs.AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs'] = None,
                 auto_scaling: Optional['outputs.AdvancedClusterReplicationSpecRegionConfigAutoScaling'] = None,
                 backing_provider_name: Optional[str] = None,
                 electable_specs: Optional['outputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecs'] = None,
                 read_only_specs: Optional['outputs.AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs'] = None):
        """
        :param int priority: Election priority of the region. For regions with only read-only nodes, set this value to 0.
               * If you have multiple `region_configs` objects (your cluster is multi-region or multi-cloud), they must have priorities in descending order. The highest priority is 7.
               * If your region has set `region_configs.#.electable_specs.0.node_count` to 1 or higher, it must have a priority of exactly one (1) less than another region in the `replication_specs.#.region_configs.#` array. The highest-priority region must have a priority of 7. The lowest possible priority is 1.
        :param str provider_name: Cloud service provider on which the servers are provisioned.
               The possible values are:
        :param str region_name: Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        :param 'AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingArgs' analytics_auto_scaling: Configuration for the Collection of settings that configures analytics-auto-scaling information for the cluster. The values for the `analytics_auto_scaling` parameter must be the same for every item in the `replication_specs` array. See below
        :param 'AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgs' analytics_specs: Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. Analytics nodes handle analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only and can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary). If you don't specify this parameter, no analytics nodes deploy to this region. See below
        :param 'AdvancedClusterReplicationSpecRegionConfigAutoScalingArgs' auto_scaling: Configuration for the Collection of settings that configures auto-scaling information for the cluster. The values for the `auto_scaling` parameter must be the same for every item in the `replication_specs` array. See below
        :param str backing_provider_name: Cloud service provider on which you provision the host for a multi-tenant cluster. Use this only when a `provider_name` is `TENANT` and `instance_size` of a specs is `M2` or `M5`.
        :param 'AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs' electable_specs: Hardware specifications for electable nodes in the region. Electable nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you do not specify this option, no electable nodes are deployed to the region. See below
        :param 'AdvancedClusterReplicationSpecRegionConfigReadOnlySpecsArgs' read_only_specs: Hardware specifications for read-only nodes in the region. Read-only nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you don't specify this parameter, no read-only nodes are deployed to the region. See below
        """
        AdvancedClusterReplicationSpecRegionConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            priority=priority,
            provider_name=provider_name,
            region_name=region_name,
            analytics_auto_scaling=analytics_auto_scaling,
            analytics_specs=analytics_specs,
            auto_scaling=auto_scaling,
            backing_provider_name=backing_provider_name,
            electable_specs=electable_specs,
            read_only_specs=read_only_specs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             priority: int,
             provider_name: str,
             region_name: str,
             analytics_auto_scaling: Optional['outputs.AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling'] = None,
             analytics_specs: Optional['outputs.AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs'] = None,
             auto_scaling: Optional['outputs.AdvancedClusterReplicationSpecRegionConfigAutoScaling'] = None,
             backing_provider_name: Optional[str] = None,
             electable_specs: Optional['outputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecs'] = None,
             read_only_specs: Optional['outputs.AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("priority", priority)
        _setter("provider_name", provider_name)
        _setter("region_name", region_name)
        if analytics_auto_scaling is not None:
            _setter("analytics_auto_scaling", analytics_auto_scaling)
        if analytics_specs is not None:
            _setter("analytics_specs", analytics_specs)
        if auto_scaling is not None:
            _setter("auto_scaling", auto_scaling)
        if backing_provider_name is not None:
            _setter("backing_provider_name", backing_provider_name)
        if electable_specs is not None:
            _setter("electable_specs", electable_specs)
        if read_only_specs is not None:
            _setter("read_only_specs", read_only_specs)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Election priority of the region. For regions with only read-only nodes, set this value to 0.
        * If you have multiple `region_configs` objects (your cluster is multi-region or multi-cloud), they must have priorities in descending order. The highest priority is 7.
        * If your region has set `region_configs.#.electable_specs.0.node_count` to 1 or higher, it must have a priority of exactly one (1) less than another region in the `replication_specs.#.region_configs.#` array. The highest-priority region must have a priority of 7. The lowest possible priority is 1.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Cloud service provider on which the servers are provisioned.
        The possible values are:
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter(name="analyticsAutoScaling")
    def analytics_auto_scaling(self) -> Optional['outputs.AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling']:
        """
        Configuration for the Collection of settings that configures analytics-auto-scaling information for the cluster. The values for the `analytics_auto_scaling` parameter must be the same for every item in the `replication_specs` array. See below
        """
        return pulumi.get(self, "analytics_auto_scaling")

    @property
    @pulumi.getter(name="analyticsSpecs")
    def analytics_specs(self) -> Optional['outputs.AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs']:
        """
        Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. Analytics nodes handle analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only and can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary). If you don't specify this parameter, no analytics nodes deploy to this region. See below
        """
        return pulumi.get(self, "analytics_specs")

    @property
    @pulumi.getter(name="autoScaling")
    def auto_scaling(self) -> Optional['outputs.AdvancedClusterReplicationSpecRegionConfigAutoScaling']:
        """
        Configuration for the Collection of settings that configures auto-scaling information for the cluster. The values for the `auto_scaling` parameter must be the same for every item in the `replication_specs` array. See below
        """
        return pulumi.get(self, "auto_scaling")

    @property
    @pulumi.getter(name="backingProviderName")
    def backing_provider_name(self) -> Optional[str]:
        """
        Cloud service provider on which you provision the host for a multi-tenant cluster. Use this only when a `provider_name` is `TENANT` and `instance_size` of a specs is `M2` or `M5`.
        """
        return pulumi.get(self, "backing_provider_name")

    @property
    @pulumi.getter(name="electableSpecs")
    def electable_specs(self) -> Optional['outputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecs']:
        """
        Hardware specifications for electable nodes in the region. Electable nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you do not specify this option, no electable nodes are deployed to the region. See below
        """
        return pulumi.get(self, "electable_specs")

    @property
    @pulumi.getter(name="readOnlySpecs")
    def read_only_specs(self) -> Optional['outputs.AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs']:
        """
        Hardware specifications for read-only nodes in the region. Read-only nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you don't specify this parameter, no read-only nodes are deployed to the region. See below
        """
        return pulumi.get(self, "read_only_specs")


@pulumi.output_type
class AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeEnabled":
            suggest = "compute_enabled"
        elif key == "computeMaxInstanceSize":
            suggest = "compute_max_instance_size"
        elif key == "computeMinInstanceSize":
            suggest = "compute_min_instance_size"
        elif key == "computeScaleDownEnabled":
            suggest = "compute_scale_down_enabled"
        elif key == "diskGbEnabled":
            suggest = "disk_gb_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_enabled: Optional[bool] = None,
                 compute_max_instance_size: Optional[str] = None,
                 compute_min_instance_size: Optional[str] = None,
                 compute_scale_down_enabled: Optional[bool] = None,
                 disk_gb_enabled: Optional[bool] = None):
        """
        :param str compute_max_instance_size: Maximum instance size to which your cluster can automatically scale (such as M40). Atlas requires this parameter if `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_enabled` is true.
        :param str compute_min_instance_size: Minimum instance size to which your cluster can automatically scale (such as M10). Atlas requires this parameter if `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_scale_down_enabled` is true.
        :param bool compute_scale_down_enabled: Flag that indicates whether the instance size may scale down. Atlas requires this parameter if `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_enabled` : true. If you enable this option, specify a value for `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_min_instance_size`.
        :param bool disk_gb_enabled: Flag that indicates whether this cluster enables disk auto-scaling. This parameter defaults to true.
        """
        AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compute_enabled=compute_enabled,
            compute_max_instance_size=compute_max_instance_size,
            compute_min_instance_size=compute_min_instance_size,
            compute_scale_down_enabled=compute_scale_down_enabled,
            disk_gb_enabled=disk_gb_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compute_enabled: Optional[bool] = None,
             compute_max_instance_size: Optional[str] = None,
             compute_min_instance_size: Optional[str] = None,
             compute_scale_down_enabled: Optional[bool] = None,
             disk_gb_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if compute_enabled is not None:
            _setter("compute_enabled", compute_enabled)
        if compute_max_instance_size is not None:
            _setter("compute_max_instance_size", compute_max_instance_size)
        if compute_min_instance_size is not None:
            _setter("compute_min_instance_size", compute_min_instance_size)
        if compute_scale_down_enabled is not None:
            _setter("compute_scale_down_enabled", compute_scale_down_enabled)
        if disk_gb_enabled is not None:
            _setter("disk_gb_enabled", disk_gb_enabled)

    @property
    @pulumi.getter(name="computeEnabled")
    def compute_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "compute_enabled")

    @property
    @pulumi.getter(name="computeMaxInstanceSize")
    def compute_max_instance_size(self) -> Optional[str]:
        """
        Maximum instance size to which your cluster can automatically scale (such as M40). Atlas requires this parameter if `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_enabled` is true.
        """
        return pulumi.get(self, "compute_max_instance_size")

    @property
    @pulumi.getter(name="computeMinInstanceSize")
    def compute_min_instance_size(self) -> Optional[str]:
        """
        Minimum instance size to which your cluster can automatically scale (such as M10). Atlas requires this parameter if `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_scale_down_enabled` is true.
        """
        return pulumi.get(self, "compute_min_instance_size")

    @property
    @pulumi.getter(name="computeScaleDownEnabled")
    def compute_scale_down_enabled(self) -> Optional[bool]:
        """
        Flag that indicates whether the instance size may scale down. Atlas requires this parameter if `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_enabled` : true. If you enable this option, specify a value for `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_min_instance_size`.
        """
        return pulumi.get(self, "compute_scale_down_enabled")

    @property
    @pulumi.getter(name="diskGbEnabled")
    def disk_gb_enabled(self) -> Optional[bool]:
        """
        Flag that indicates whether this cluster enables disk auto-scaling. This parameter defaults to true.
        """
        return pulumi.get(self, "disk_gb_enabled")


@pulumi.output_type
class AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceSize":
            suggest = "instance_size"
        elif key == "diskIops":
            suggest = "disk_iops"
        elif key == "ebsVolumeType":
            suggest = "ebs_volume_type"
        elif key == "nodeCount":
            suggest = "node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_size: str,
                 disk_iops: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 node_count: Optional[int] = None):
        """
        :param str instance_size: Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size.
        :param int disk_iops: Target throughput (IOPS) desired for AWS storage attached to your cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster.
        :param str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        :param int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_size=instance_size,
            disk_iops=disk_iops,
            ebs_volume_type=ebs_volume_type,
            node_count=node_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_size: str,
             disk_iops: Optional[int] = None,
             ebs_volume_type: Optional[str] = None,
             node_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("instance_size", instance_size)
        if disk_iops is not None:
            _setter("disk_iops", disk_iops)
        if ebs_volume_type is not None:
            _setter("ebs_volume_type", ebs_volume_type)
        if node_count is not None:
            _setter("node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size.
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[int]:
        """
        Target throughput (IOPS) desired for AWS storage attached to your cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        """
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class AdvancedClusterReplicationSpecRegionConfigAutoScaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeEnabled":
            suggest = "compute_enabled"
        elif key == "computeMaxInstanceSize":
            suggest = "compute_max_instance_size"
        elif key == "computeMinInstanceSize":
            suggest = "compute_min_instance_size"
        elif key == "computeScaleDownEnabled":
            suggest = "compute_scale_down_enabled"
        elif key == "diskGbEnabled":
            suggest = "disk_gb_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterReplicationSpecRegionConfigAutoScaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterReplicationSpecRegionConfigAutoScaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterReplicationSpecRegionConfigAutoScaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_enabled: Optional[bool] = None,
                 compute_max_instance_size: Optional[str] = None,
                 compute_min_instance_size: Optional[str] = None,
                 compute_scale_down_enabled: Optional[bool] = None,
                 disk_gb_enabled: Optional[bool] = None):
        """
        :param str compute_max_instance_size: Maximum instance size to which your cluster can automatically scale (such as M40). Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_enabled` is true.
        :param str compute_min_instance_size: Minimum instance size to which your cluster can automatically scale (such as M10). Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_scale_down_enabled` is true.
        :param bool compute_scale_down_enabled: Flag that indicates whether the instance size may scale down. Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_enabled` : true. If you enable this option, specify a value for `replication_specs.#.region_configs.#.auto_scaling.0.compute_min_instance_size`.
        """
        AdvancedClusterReplicationSpecRegionConfigAutoScaling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compute_enabled=compute_enabled,
            compute_max_instance_size=compute_max_instance_size,
            compute_min_instance_size=compute_min_instance_size,
            compute_scale_down_enabled=compute_scale_down_enabled,
            disk_gb_enabled=disk_gb_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compute_enabled: Optional[bool] = None,
             compute_max_instance_size: Optional[str] = None,
             compute_min_instance_size: Optional[str] = None,
             compute_scale_down_enabled: Optional[bool] = None,
             disk_gb_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if compute_enabled is not None:
            _setter("compute_enabled", compute_enabled)
        if compute_max_instance_size is not None:
            _setter("compute_max_instance_size", compute_max_instance_size)
        if compute_min_instance_size is not None:
            _setter("compute_min_instance_size", compute_min_instance_size)
        if compute_scale_down_enabled is not None:
            _setter("compute_scale_down_enabled", compute_scale_down_enabled)
        if disk_gb_enabled is not None:
            _setter("disk_gb_enabled", disk_gb_enabled)

    @property
    @pulumi.getter(name="computeEnabled")
    def compute_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "compute_enabled")

    @property
    @pulumi.getter(name="computeMaxInstanceSize")
    def compute_max_instance_size(self) -> Optional[str]:
        """
        Maximum instance size to which your cluster can automatically scale (such as M40). Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_enabled` is true.
        """
        return pulumi.get(self, "compute_max_instance_size")

    @property
    @pulumi.getter(name="computeMinInstanceSize")
    def compute_min_instance_size(self) -> Optional[str]:
        """
        Minimum instance size to which your cluster can automatically scale (such as M10). Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_scale_down_enabled` is true.
        """
        return pulumi.get(self, "compute_min_instance_size")

    @property
    @pulumi.getter(name="computeScaleDownEnabled")
    def compute_scale_down_enabled(self) -> Optional[bool]:
        """
        Flag that indicates whether the instance size may scale down. Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_enabled` : true. If you enable this option, specify a value for `replication_specs.#.region_configs.#.auto_scaling.0.compute_min_instance_size`.
        """
        return pulumi.get(self, "compute_scale_down_enabled")

    @property
    @pulumi.getter(name="diskGbEnabled")
    def disk_gb_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "disk_gb_enabled")


@pulumi.output_type
class AdvancedClusterReplicationSpecRegionConfigElectableSpecs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceSize":
            suggest = "instance_size"
        elif key == "diskIops":
            suggest = "disk_iops"
        elif key == "ebsVolumeType":
            suggest = "ebs_volume_type"
        elif key == "nodeCount":
            suggest = "node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterReplicationSpecRegionConfigElectableSpecs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterReplicationSpecRegionConfigElectableSpecs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterReplicationSpecRegionConfigElectableSpecs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_size: str,
                 disk_iops: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 node_count: Optional[int] = None):
        """
        :param str instance_size: Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size.
        :param int disk_iops: Target throughput (IOPS) desired for AWS storage attached to your cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster.
        :param str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        :param int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        AdvancedClusterReplicationSpecRegionConfigElectableSpecs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_size=instance_size,
            disk_iops=disk_iops,
            ebs_volume_type=ebs_volume_type,
            node_count=node_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_size: str,
             disk_iops: Optional[int] = None,
             ebs_volume_type: Optional[str] = None,
             node_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("instance_size", instance_size)
        if disk_iops is not None:
            _setter("disk_iops", disk_iops)
        if ebs_volume_type is not None:
            _setter("ebs_volume_type", ebs_volume_type)
        if node_count is not None:
            _setter("node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size.
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[int]:
        """
        Target throughput (IOPS) desired for AWS storage attached to your cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        """
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceSize":
            suggest = "instance_size"
        elif key == "diskIops":
            suggest = "disk_iops"
        elif key == "ebsVolumeType":
            suggest = "ebs_volume_type"
        elif key == "nodeCount":
            suggest = "node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_size: str,
                 disk_iops: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 node_count: Optional[int] = None):
        """
        :param str instance_size: Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size.
        :param int disk_iops: Target throughput (IOPS) desired for AWS storage attached to your cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster.
        :param str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        :param int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_size=instance_size,
            disk_iops=disk_iops,
            ebs_volume_type=ebs_volume_type,
            node_count=node_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_size: str,
             disk_iops: Optional[int] = None,
             ebs_volume_type: Optional[str] = None,
             node_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("instance_size", instance_size)
        if disk_iops is not None:
            _setter("disk_iops", disk_iops)
        if ebs_volume_type is not None:
            _setter("ebs_volume_type", ebs_volume_type)
        if node_count is not None:
            _setter("node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size.
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[int]:
        """
        Target throughput (IOPS) desired for AWS storage attached to your cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        """
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class AdvancedClusterTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Constant that defines the set of the tag.
        :param str value: Variable that belongs to the set of the tag.
               
               To learn more, see [Resource Tags](https://dochub.mongodb.org/core/add-cluster-tag-atlas).
        """
        AdvancedClusterTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Constant that defines the set of the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Variable that belongs to the set of the tag.

        To learn more, see [Resource Tags](https://dochub.mongodb.org/core/add-cluster-tag-atlas).
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AlertConfigurationMatcher(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertConfigurationMatcher. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertConfigurationMatcher.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertConfigurationMatcher.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: str,
                 operator: str,
                 value: str):
        """
        :param str field_name: Name of the field in the target object to match on.
               
               | Host alerts         | Replica set alerts  |  Sharded cluster alerts |
               |:----------           |:-------------       |:------                 |
               | `TYPE_NAME`         | `REPLICA_SET_NAME`  | `CLUSTER_NAME`          |
               | `HOSTNAME`          | `SHARD_NAME`        | `SHARD_NAME`            |
               | `PORT`              | `CLUSTER_NAME`      |                         |
               | `HOSTNAME_AND_PORT` |                     |                         |
               | `REPLICA_SET_NAME`  |                     |                         |
               
               
               
               All other types of alerts do not support matchers.
        :param str operator: The operator to test the field’s value.
               Accepted values are:
        :param str value: Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
        """
        AlertConfigurationMatcher._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_name=field_name,
            operator=operator,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_name: str,
             operator: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_name", field_name)
        _setter("operator", operator)
        _setter("value", value)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        """
        Name of the field in the target object to match on.

        | Host alerts         | Replica set alerts  |  Sharded cluster alerts |
        |:----------           |:-------------       |:------                 |
        | `TYPE_NAME`         | `REPLICA_SET_NAME`  | `CLUSTER_NAME`          |
        | `HOSTNAME`          | `SHARD_NAME`        | `SHARD_NAME`            |
        | `PORT`              | `CLUSTER_NAME`      |                         |
        | `HOSTNAME_AND_PORT` |                     |                         |
        | `REPLICA_SET_NAME`  |                     |                         |



        All other types of alerts do not support matchers.
        """
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator to test the field’s value.
        Accepted values are:
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AlertConfigurationMetricThresholdConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertConfigurationMetricThresholdConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertConfigurationMetricThresholdConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertConfigurationMetricThresholdConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: str,
                 mode: Optional[str] = None,
                 operator: Optional[str] = None,
                 threshold: Optional[float] = None,
                 units: Optional[str] = None):
        """
        :param str metric_name: Name of the metric to check. The full list being quite large, please refer to atlas docs [here for general metrics](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types) and [here for serverless metrics](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-create-config/#serverless-measurements)
        :param str mode: This must be set to AVERAGE. Atlas computes the current metric value as an average.
        :param str operator: The operator to test the field’s value.
               Accepted values are:
        :param float threshold: Threshold value outside of which an alert will be triggered.
        :param str units: The units for the threshold value. Depends on the type of metric.
               Refer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.
        """
        AlertConfigurationMetricThresholdConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric_name=metric_name,
            mode=mode,
            operator=operator,
            threshold=threshold,
            units=units,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric_name: str,
             mode: Optional[str] = None,
             operator: Optional[str] = None,
             threshold: Optional[float] = None,
             units: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric_name", metric_name)
        if mode is not None:
            _setter("mode", mode)
        if operator is not None:
            _setter("operator", operator)
        if threshold is not None:
            _setter("threshold", threshold)
        if units is not None:
            _setter("units", units)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        Name of the metric to check. The full list being quite large, please refer to atlas docs [here for general metrics](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types) and [here for serverless metrics](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-create-config/#serverless-measurements)
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        This must be set to AVERAGE. Atlas computes the current metric value as an average.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        The operator to test the field’s value.
        Accepted values are:
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        """
        Threshold value outside of which an alert will be triggered.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def units(self) -> Optional[str]:
        """
        The units for the threshold value. Depends on the type of metric.
        Refer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.
        """
        return pulumi.get(self, "units")


@pulumi.output_type
class AlertConfigurationNotification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeName":
            suggest = "type_name"
        elif key == "apiToken":
            suggest = "api_token"
        elif key == "channelName":
            suggest = "channel_name"
        elif key == "datadogApiKey":
            suggest = "datadog_api_key"
        elif key == "datadogRegion":
            suggest = "datadog_region"
        elif key == "delayMin":
            suggest = "delay_min"
        elif key == "emailAddress":
            suggest = "email_address"
        elif key == "emailEnabled":
            suggest = "email_enabled"
        elif key == "intervalMin":
            suggest = "interval_min"
        elif key == "microsoftTeamsWebhookUrl":
            suggest = "microsoft_teams_webhook_url"
        elif key == "mobileNumber":
            suggest = "mobile_number"
        elif key == "opsGenieApiKey":
            suggest = "ops_genie_api_key"
        elif key == "opsGenieRegion":
            suggest = "ops_genie_region"
        elif key == "serviceKey":
            suggest = "service_key"
        elif key == "smsEnabled":
            suggest = "sms_enabled"
        elif key == "teamId":
            suggest = "team_id"
        elif key == "teamName":
            suggest = "team_name"
        elif key == "victorOpsApiKey":
            suggest = "victor_ops_api_key"
        elif key == "victorOpsRoutingKey":
            suggest = "victor_ops_routing_key"
        elif key == "webhookSecret":
            suggest = "webhook_secret"
        elif key == "webhookUrl":
            suggest = "webhook_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertConfigurationNotification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertConfigurationNotification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertConfigurationNotification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type_name: str,
                 api_token: Optional[str] = None,
                 channel_name: Optional[str] = None,
                 datadog_api_key: Optional[str] = None,
                 datadog_region: Optional[str] = None,
                 delay_min: Optional[int] = None,
                 email_address: Optional[str] = None,
                 email_enabled: Optional[bool] = None,
                 interval_min: Optional[int] = None,
                 microsoft_teams_webhook_url: Optional[str] = None,
                 mobile_number: Optional[str] = None,
                 ops_genie_api_key: Optional[str] = None,
                 ops_genie_region: Optional[str] = None,
                 roles: Optional[Sequence[str]] = None,
                 service_key: Optional[str] = None,
                 sms_enabled: Optional[bool] = None,
                 team_id: Optional[str] = None,
                 team_name: Optional[str] = None,
                 username: Optional[str] = None,
                 victor_ops_api_key: Optional[str] = None,
                 victor_ops_routing_key: Optional[str] = None,
                 webhook_secret: Optional[str] = None,
                 webhook_url: Optional[str] = None):
        """
        :param str type_name: Type of alert notification.
               Accepted values are:
        :param str api_token: Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param str channel_name: Slack channel name. Required for the SLACK notifications type.
        :param str datadog_api_key: Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        :param str datadog_region: Region that indicates which API URL to use. Accepted regions are: `US`, `EU`. The default Datadog region is US.
        :param int delay_min: Number of minutes to wait after an alert condition is detected before sending out the first notification.
        :param str email_address: Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        :param bool email_enabled: Flag indicating email notifications should be sent. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        :param int interval_min: Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5. **NOTE** `PAGER_DUTY`, `VICTOR_OPS`, and `OPS_GENIE` notifications do not return this value. The notification interval must be configured and managed within each external service.
        :param str microsoft_teams_webhook_url: Microsoft Teams Webhook Uniform Resource Locator (URL) that MongoDB Cloud needs to send this notification via Microsoft Teams. Required if `type_name` is `MICROSOFT_TEAMS`. If the URL later becomes invalid, MongoDB Cloud sends an email to the project owners. If the key remains invalid, MongoDB Cloud removes it.
        :param str mobile_number: Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        :param str ops_genie_api_key: Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param str ops_genie_region: Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        :param Sequence[str] roles: Optional. One or more roles that receive the configured alert. If you include this field, Atlas sends alerts only to users assigned the roles you specify in the array. If you omit this field, Atlas sends alerts to users assigned any role. This parameter is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
               Accepted values are:
               
               | Project roles                   | Organization roles  |
               |:----------                      |:-----------         |
               | `GROUP_CHARTS_ADMIN`            | `ORG_OWNER`         |
               | `GROUP_CLUSTER_MANAGER`         | `ORG_MEMBER`        |
               | `GROUP_DATA_ACCESS_ADMIN`       | `ORG_GROUP_CREATOR` |
               | `GROUP_DATA_ACCESS_READ_ONLY`   | `ORG_BILLING_ADMIN` |
               | `GROUP_DATA_ACCESS_READ_WRITE`  | `ORG_READ_ONLY`     |
               | `GROUP_OWNER`                   |                     |
               | `GROUP_READ_ONLY`               |                     |
        :param str service_key: PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param bool sms_enabled: Flag indicating if text message notifications should be sent to this user's mobile phone. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        :param str team_id: Unique identifier of a team.
        :param str team_name: Label for the team that receives this notification.
        :param str username: Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        :param str victor_ops_api_key: VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param str victor_ops_routing_key: VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param str webhook_secret: Optional authentication secret for the `WEBHOOK` notifications type.
        :param str webhook_url: Target URL  for the `WEBHOOK` notifications type.
        """
        AlertConfigurationNotification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type_name=type_name,
            api_token=api_token,
            channel_name=channel_name,
            datadog_api_key=datadog_api_key,
            datadog_region=datadog_region,
            delay_min=delay_min,
            email_address=email_address,
            email_enabled=email_enabled,
            interval_min=interval_min,
            microsoft_teams_webhook_url=microsoft_teams_webhook_url,
            mobile_number=mobile_number,
            ops_genie_api_key=ops_genie_api_key,
            ops_genie_region=ops_genie_region,
            roles=roles,
            service_key=service_key,
            sms_enabled=sms_enabled,
            team_id=team_id,
            team_name=team_name,
            username=username,
            victor_ops_api_key=victor_ops_api_key,
            victor_ops_routing_key=victor_ops_routing_key,
            webhook_secret=webhook_secret,
            webhook_url=webhook_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type_name: str,
             api_token: Optional[str] = None,
             channel_name: Optional[str] = None,
             datadog_api_key: Optional[str] = None,
             datadog_region: Optional[str] = None,
             delay_min: Optional[int] = None,
             email_address: Optional[str] = None,
             email_enabled: Optional[bool] = None,
             interval_min: Optional[int] = None,
             microsoft_teams_webhook_url: Optional[str] = None,
             mobile_number: Optional[str] = None,
             ops_genie_api_key: Optional[str] = None,
             ops_genie_region: Optional[str] = None,
             roles: Optional[Sequence[str]] = None,
             service_key: Optional[str] = None,
             sms_enabled: Optional[bool] = None,
             team_id: Optional[str] = None,
             team_name: Optional[str] = None,
             username: Optional[str] = None,
             victor_ops_api_key: Optional[str] = None,
             victor_ops_routing_key: Optional[str] = None,
             webhook_secret: Optional[str] = None,
             webhook_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type_name", type_name)
        if api_token is not None:
            _setter("api_token", api_token)
        if channel_name is not None:
            _setter("channel_name", channel_name)
        if datadog_api_key is not None:
            _setter("datadog_api_key", datadog_api_key)
        if datadog_region is not None:
            _setter("datadog_region", datadog_region)
        if delay_min is not None:
            _setter("delay_min", delay_min)
        if email_address is not None:
            _setter("email_address", email_address)
        if email_enabled is not None:
            _setter("email_enabled", email_enabled)
        if interval_min is not None:
            _setter("interval_min", interval_min)
        if microsoft_teams_webhook_url is not None:
            _setter("microsoft_teams_webhook_url", microsoft_teams_webhook_url)
        if mobile_number is not None:
            _setter("mobile_number", mobile_number)
        if ops_genie_api_key is not None:
            _setter("ops_genie_api_key", ops_genie_api_key)
        if ops_genie_region is not None:
            _setter("ops_genie_region", ops_genie_region)
        if roles is not None:
            _setter("roles", roles)
        if service_key is not None:
            _setter("service_key", service_key)
        if sms_enabled is not None:
            _setter("sms_enabled", sms_enabled)
        if team_id is not None:
            _setter("team_id", team_id)
        if team_name is not None:
            _setter("team_name", team_name)
        if username is not None:
            _setter("username", username)
        if victor_ops_api_key is not None:
            _setter("victor_ops_api_key", victor_ops_api_key)
        if victor_ops_routing_key is not None:
            _setter("victor_ops_routing_key", victor_ops_routing_key)
        if webhook_secret is not None:
            _setter("webhook_secret", webhook_secret)
        if webhook_url is not None:
            _setter("webhook_url", webhook_url)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        """
        Type of alert notification.
        Accepted values are:
        """
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional[str]:
        """
        Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> Optional[str]:
        """
        Slack channel name. Required for the SLACK notifications type.
        """
        return pulumi.get(self, "channel_name")

    @property
    @pulumi.getter(name="datadogApiKey")
    def datadog_api_key(self) -> Optional[str]:
        """
        Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        """
        return pulumi.get(self, "datadog_api_key")

    @property
    @pulumi.getter(name="datadogRegion")
    def datadog_region(self) -> Optional[str]:
        """
        Region that indicates which API URL to use. Accepted regions are: `US`, `EU`. The default Datadog region is US.
        """
        return pulumi.get(self, "datadog_region")

    @property
    @pulumi.getter(name="delayMin")
    def delay_min(self) -> Optional[int]:
        """
        Number of minutes to wait after an alert condition is detected before sending out the first notification.
        """
        return pulumi.get(self, "delay_min")

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> Optional[str]:
        """
        Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter(name="emailEnabled")
    def email_enabled(self) -> Optional[bool]:
        """
        Flag indicating email notifications should be sent. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        """
        return pulumi.get(self, "email_enabled")

    @property
    @pulumi.getter(name="intervalMin")
    def interval_min(self) -> Optional[int]:
        """
        Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5. **NOTE** `PAGER_DUTY`, `VICTOR_OPS`, and `OPS_GENIE` notifications do not return this value. The notification interval must be configured and managed within each external service.
        """
        return pulumi.get(self, "interval_min")

    @property
    @pulumi.getter(name="microsoftTeamsWebhookUrl")
    def microsoft_teams_webhook_url(self) -> Optional[str]:
        """
        Microsoft Teams Webhook Uniform Resource Locator (URL) that MongoDB Cloud needs to send this notification via Microsoft Teams. Required if `type_name` is `MICROSOFT_TEAMS`. If the URL later becomes invalid, MongoDB Cloud sends an email to the project owners. If the key remains invalid, MongoDB Cloud removes it.
        """
        return pulumi.get(self, "microsoft_teams_webhook_url")

    @property
    @pulumi.getter(name="mobileNumber")
    def mobile_number(self) -> Optional[str]:
        """
        Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        """
        return pulumi.get(self, "mobile_number")

    @property
    @pulumi.getter(name="opsGenieApiKey")
    def ops_genie_api_key(self) -> Optional[str]:
        """
        Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "ops_genie_api_key")

    @property
    @pulumi.getter(name="opsGenieRegion")
    def ops_genie_region(self) -> Optional[str]:
        """
        Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        """
        return pulumi.get(self, "ops_genie_region")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        """
        Optional. One or more roles that receive the configured alert. If you include this field, Atlas sends alerts only to users assigned the roles you specify in the array. If you omit this field, Atlas sends alerts to users assigned any role. This parameter is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        Accepted values are:

        | Project roles                   | Organization roles  |
        |:----------                      |:-----------         |
        | `GROUP_CHARTS_ADMIN`            | `ORG_OWNER`         |
        | `GROUP_CLUSTER_MANAGER`         | `ORG_MEMBER`        |
        | `GROUP_DATA_ACCESS_ADMIN`       | `ORG_GROUP_CREATOR` |
        | `GROUP_DATA_ACCESS_READ_ONLY`   | `ORG_BILLING_ADMIN` |
        | `GROUP_DATA_ACCESS_READ_WRITE`  | `ORG_READ_ONLY`     |
        | `GROUP_OWNER`                   |                     |
        | `GROUP_READ_ONLY`               |                     |
        """
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter(name="serviceKey")
    def service_key(self) -> Optional[str]:
        """
        PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "service_key")

    @property
    @pulumi.getter(name="smsEnabled")
    def sms_enabled(self) -> Optional[bool]:
        """
        Flag indicating if text message notifications should be sent to this user's mobile phone. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        """
        return pulumi.get(self, "sms_enabled")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[str]:
        """
        Unique identifier of a team.
        """
        return pulumi.get(self, "team_id")

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> Optional[str]:
        """
        Label for the team that receives this notification.
        """
        return pulumi.get(self, "team_name")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="victorOpsApiKey")
    def victor_ops_api_key(self) -> Optional[str]:
        """
        VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "victor_ops_api_key")

    @property
    @pulumi.getter(name="victorOpsRoutingKey")
    def victor_ops_routing_key(self) -> Optional[str]:
        """
        VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "victor_ops_routing_key")

    @property
    @pulumi.getter(name="webhookSecret")
    def webhook_secret(self) -> Optional[str]:
        """
        Optional authentication secret for the `WEBHOOK` notifications type.
        """
        return pulumi.get(self, "webhook_secret")

    @property
    @pulumi.getter(name="webhookUrl")
    def webhook_url(self) -> Optional[str]:
        """
        Target URL  for the `WEBHOOK` notifications type.
        """
        return pulumi.get(self, "webhook_url")


@pulumi.output_type
class AlertConfigurationThresholdConfig(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 threshold: Optional[float] = None,
                 units: Optional[str] = None):
        """
        :param str operator: The operator to test the field’s value.
               Accepted values are:
        :param float threshold: Threshold value outside of which an alert will be triggered.
        :param str units: The units for the threshold value. Depends on the type of metric.
               Refer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.
        """
        AlertConfigurationThresholdConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            threshold=threshold,
            units=units,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: Optional[str] = None,
             threshold: Optional[float] = None,
             units: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if operator is not None:
            _setter("operator", operator)
        if threshold is not None:
            _setter("threshold", threshold)
        if units is not None:
            _setter("units", units)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        The operator to test the field’s value.
        Accepted values are:
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        """
        Threshold value outside of which an alert will be triggered.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def units(self) -> Optional[str]:
        """
        The units for the threshold value. Depends on the type of metric.
        Refer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.
        """
        return pulumi.get(self, "units")


@pulumi.output_type
class BackupCompliancePolicyOnDemandPolicyItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupCompliancePolicyOnDemandPolicyItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupCompliancePolicyOnDemandPolicyItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupCompliancePolicyOnDemandPolicyItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 retention_unit: str,
                 retention_value: int,
                 frequency_type: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, or `months`.
        :param int retention_value: Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        :param str frequency_type: Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        """
        BackupCompliancePolicyOnDemandPolicyItem._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frequency_interval=frequency_interval,
            retention_unit=retention_unit,
            retention_value=retention_value,
            frequency_type=frequency_type,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frequency_interval: int,
             retention_unit: str,
             retention_value: int,
             frequency_type: Optional[str] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("frequency_interval", frequency_interval)
        _setter("retention_unit", retention_unit)
        _setter("retention_value", retention_value)
        if frequency_type is not None:
            _setter("frequency_type", frequency_type)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, or `months`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        """
        return pulumi.get(self, "retention_value")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        """
        Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class BackupCompliancePolicyPolicyItemDaily(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupCompliancePolicyPolicyItemDaily. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupCompliancePolicyPolicyItemDaily.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupCompliancePolicyPolicyItemDaily.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 retention_unit: str,
                 retention_value: int,
                 frequency_type: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, or `months`.
        :param int retention_value: Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        :param str frequency_type: Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        """
        BackupCompliancePolicyPolicyItemDaily._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frequency_interval=frequency_interval,
            retention_unit=retention_unit,
            retention_value=retention_value,
            frequency_type=frequency_type,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frequency_interval: int,
             retention_unit: str,
             retention_value: int,
             frequency_type: Optional[str] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("frequency_interval", frequency_interval)
        _setter("retention_unit", retention_unit)
        _setter("retention_value", retention_value)
        if frequency_type is not None:
            _setter("frequency_type", frequency_type)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, or `months`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        """
        return pulumi.get(self, "retention_value")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        """
        Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class BackupCompliancePolicyPolicyItemHourly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupCompliancePolicyPolicyItemHourly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupCompliancePolicyPolicyItemHourly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupCompliancePolicyPolicyItemHourly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 retention_unit: str,
                 retention_value: int,
                 frequency_type: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, or `months`.
        :param int retention_value: Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        :param str frequency_type: Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        """
        BackupCompliancePolicyPolicyItemHourly._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frequency_interval=frequency_interval,
            retention_unit=retention_unit,
            retention_value=retention_value,
            frequency_type=frequency_type,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frequency_interval: int,
             retention_unit: str,
             retention_value: int,
             frequency_type: Optional[str] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("frequency_interval", frequency_interval)
        _setter("retention_unit", retention_unit)
        _setter("retention_value", retention_value)
        if frequency_type is not None:
            _setter("frequency_type", frequency_type)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, or `months`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        """
        return pulumi.get(self, "retention_value")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        """
        Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class BackupCompliancePolicyPolicyItemMonthly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupCompliancePolicyPolicyItemMonthly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupCompliancePolicyPolicyItemMonthly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupCompliancePolicyPolicyItemMonthly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 retention_unit: str,
                 retention_value: int,
                 frequency_type: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, or `months`.
        :param int retention_value: Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        :param str frequency_type: Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        """
        BackupCompliancePolicyPolicyItemMonthly._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frequency_interval=frequency_interval,
            retention_unit=retention_unit,
            retention_value=retention_value,
            frequency_type=frequency_type,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frequency_interval: int,
             retention_unit: str,
             retention_value: int,
             frequency_type: Optional[str] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("frequency_interval", frequency_interval)
        _setter("retention_unit", retention_unit)
        _setter("retention_value", retention_value)
        if frequency_type is not None:
            _setter("frequency_type", frequency_type)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, or `months`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        """
        return pulumi.get(self, "retention_value")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        """
        Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class BackupCompliancePolicyPolicyItemWeekly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupCompliancePolicyPolicyItemWeekly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupCompliancePolicyPolicyItemWeekly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupCompliancePolicyPolicyItemWeekly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 retention_unit: str,
                 retention_value: int,
                 frequency_type: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, or `months`.
        :param int retention_value: Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        :param str frequency_type: Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        """
        BackupCompliancePolicyPolicyItemWeekly._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frequency_interval=frequency_interval,
            retention_unit=retention_unit,
            retention_value=retention_value,
            frequency_type=frequency_type,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frequency_interval: int,
             retention_unit: str,
             retention_value: int,
             frequency_type: Optional[str] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("frequency_interval", frequency_interval)
        _setter("retention_unit", retention_unit)
        _setter("retention_value", retention_value)
        if frequency_type is not None:
            _setter("frequency_type", frequency_type)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, or `months`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        """
        return pulumi.get(self, "retention_value")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        """
        Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class CloudBackupScheduleCopySetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudProvider":
            suggest = "cloud_provider"
        elif key == "regionName":
            suggest = "region_name"
        elif key == "replicationSpecId":
            suggest = "replication_spec_id"
        elif key == "shouldCopyOplogs":
            suggest = "should_copy_oplogs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupScheduleCopySetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupScheduleCopySetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupScheduleCopySetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_provider: Optional[str] = None,
                 frequencies: Optional[Sequence[str]] = None,
                 region_name: Optional[str] = None,
                 replication_spec_id: Optional[str] = None,
                 should_copy_oplogs: Optional[bool] = None):
        """
        :param str cloud_provider: Human-readable label that identifies the cloud provider that stores the snapshot copy. i.e. "AWS" "AZURE" "GCP"
        :param Sequence[str] frequencies: List that describes which types of snapshots to copy. i.e. "HOURLY" "DAILY" "WEEKLY" "MONTHLY" "ON_DEMAND"
        :param str region_name: Target region to copy snapshots belonging to replicationSpecId to. Please supply the 'Atlas Region' which can be found under https://www.mongodb.com/docs/atlas/reference/cloud-providers/ 'regions' link
        :param str replication_spec_id: Unique 24-hexadecimal digit string that identifies the replication object for a zone in a cluster. For global clusters, there can be multiple zones to choose from. For sharded clusters and replica set clusters, there is only one zone in the cluster. To find the Replication Spec Id, consult the replicationSpecs array returned from [Return One Multi-Cloud Cluster in One Project](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Clusters/operation/getCluster).
        :param bool should_copy_oplogs: Flag that indicates whether to copy the oplogs to the target region. You can use the oplogs to perform point-in-time restores.
        """
        CloudBackupScheduleCopySetting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_provider=cloud_provider,
            frequencies=frequencies,
            region_name=region_name,
            replication_spec_id=replication_spec_id,
            should_copy_oplogs=should_copy_oplogs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_provider: Optional[str] = None,
             frequencies: Optional[Sequence[str]] = None,
             region_name: Optional[str] = None,
             replication_spec_id: Optional[str] = None,
             should_copy_oplogs: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cloud_provider is not None:
            _setter("cloud_provider", cloud_provider)
        if frequencies is not None:
            _setter("frequencies", frequencies)
        if region_name is not None:
            _setter("region_name", region_name)
        if replication_spec_id is not None:
            _setter("replication_spec_id", replication_spec_id)
        if should_copy_oplogs is not None:
            _setter("should_copy_oplogs", should_copy_oplogs)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[str]:
        """
        Human-readable label that identifies the cloud provider that stores the snapshot copy. i.e. "AWS" "AZURE" "GCP"
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def frequencies(self) -> Optional[Sequence[str]]:
        """
        List that describes which types of snapshots to copy. i.e. "HOURLY" "DAILY" "WEEKLY" "MONTHLY" "ON_DEMAND"
        """
        return pulumi.get(self, "frequencies")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> Optional[str]:
        """
        Target region to copy snapshots belonging to replicationSpecId to. Please supply the 'Atlas Region' which can be found under https://www.mongodb.com/docs/atlas/reference/cloud-providers/ 'regions' link
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter(name="replicationSpecId")
    def replication_spec_id(self) -> Optional[str]:
        """
        Unique 24-hexadecimal digit string that identifies the replication object for a zone in a cluster. For global clusters, there can be multiple zones to choose from. For sharded clusters and replica set clusters, there is only one zone in the cluster. To find the Replication Spec Id, consult the replicationSpecs array returned from [Return One Multi-Cloud Cluster in One Project](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Clusters/operation/getCluster).
        """
        return pulumi.get(self, "replication_spec_id")

    @property
    @pulumi.getter(name="shouldCopyOplogs")
    def should_copy_oplogs(self) -> Optional[bool]:
        """
        Flag that indicates whether to copy the oplogs to the target region. You can use the oplogs to perform point-in-time restores.
        """
        return pulumi.get(self, "should_copy_oplogs")


@pulumi.output_type
class CloudBackupScheduleExport(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportBucketId":
            suggest = "export_bucket_id"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupScheduleExport. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupScheduleExport.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupScheduleExport.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_bucket_id: Optional[str] = None,
                 frequency_type: Optional[str] = None):
        """
        :param str export_bucket_id: Unique identifier of the CloudBackupSnapshotExportBucket export_bucket_id value.
        :param str frequency_type: Frequency associated with the export snapshot item.
        """
        CloudBackupScheduleExport._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            export_bucket_id=export_bucket_id,
            frequency_type=frequency_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             export_bucket_id: Optional[str] = None,
             frequency_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if export_bucket_id is not None:
            _setter("export_bucket_id", export_bucket_id)
        if frequency_type is not None:
            _setter("frequency_type", frequency_type)

    @property
    @pulumi.getter(name="exportBucketId")
    def export_bucket_id(self) -> Optional[str]:
        """
        Unique identifier of the CloudBackupSnapshotExportBucket export_bucket_id value.
        """
        return pulumi.get(self, "export_bucket_id")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        """
        Frequency associated with the export snapshot item.
        """
        return pulumi.get(self, "frequency_type")


@pulumi.output_type
class CloudBackupSchedulePolicyItemDaily(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSchedulePolicyItemDaily. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSchedulePolicyItemDaily.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSchedulePolicyItemDaily.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 retention_unit: str,
                 retention_value: int,
                 frequency_type: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (daily in this case). The only supported value for daily policies is `1` day.
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, or `months`.
        :param int retention_value: Value to associate with `retention_unit`.  Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the hourly policy item specifies a retention of two days, the daily retention policy must specify two days or greater.
        :param str frequency_type: Frequency associated with the backup policy item. For daily policies, the frequency type is defined as `daily`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        """
        CloudBackupSchedulePolicyItemDaily._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frequency_interval=frequency_interval,
            retention_unit=retention_unit,
            retention_value=retention_value,
            frequency_type=frequency_type,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frequency_interval: int,
             retention_unit: str,
             retention_value: int,
             frequency_type: Optional[str] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("frequency_interval", frequency_interval)
        _setter("retention_unit", retention_unit)
        _setter("retention_value", retention_value)
        if frequency_type is not None:
            _setter("frequency_type", frequency_type)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (daily in this case). The only supported value for daily policies is `1` day.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, or `months`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`.  Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the hourly policy item specifies a retention of two days, the daily retention policy must specify two days or greater.
        """
        return pulumi.get(self, "retention_value")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        """
        Frequency associated with the backup policy item. For daily policies, the frequency type is defined as `daily`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class CloudBackupSchedulePolicyItemHourly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSchedulePolicyItemHourly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSchedulePolicyItemHourly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSchedulePolicyItemHourly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 retention_unit: str,
                 retention_value: int,
                 frequency_type: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (hourly in this case). The supported values for hourly policies are `1`, `2`, `4`, `6`, `8` or `12` hours. Note that `12` hours is the only accepted value for NVMe clusters.
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, or `months`.
        :param int retention_value: Value to associate with `retention_unit`.
        :param str frequency_type: Frequency associated with the backup policy item. For hourly policies, the frequency type is defined as `hourly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        """
        CloudBackupSchedulePolicyItemHourly._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frequency_interval=frequency_interval,
            retention_unit=retention_unit,
            retention_value=retention_value,
            frequency_type=frequency_type,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frequency_interval: int,
             retention_unit: str,
             retention_value: int,
             frequency_type: Optional[str] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("frequency_interval", frequency_interval)
        _setter("retention_unit", retention_unit)
        _setter("retention_value", retention_value)
        if frequency_type is not None:
            _setter("frequency_type", frequency_type)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (hourly in this case). The supported values for hourly policies are `1`, `2`, `4`, `6`, `8` or `12` hours. Note that `12` hours is the only accepted value for NVMe clusters.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, or `months`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`.
        """
        return pulumi.get(self, "retention_value")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        """
        Frequency associated with the backup policy item. For hourly policies, the frequency type is defined as `hourly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class CloudBackupSchedulePolicyItemMonthly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSchedulePolicyItemMonthly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSchedulePolicyItemMonthly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSchedulePolicyItemMonthly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 retention_unit: str,
                 retention_value: int,
                 frequency_type: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, or `months`.
        :param int retention_value: Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        :param str frequency_type: Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        """
        CloudBackupSchedulePolicyItemMonthly._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frequency_interval=frequency_interval,
            retention_unit=retention_unit,
            retention_value=retention_value,
            frequency_type=frequency_type,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frequency_interval: int,
             retention_unit: str,
             retention_value: int,
             frequency_type: Optional[str] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("frequency_interval", frequency_interval)
        _setter("retention_unit", retention_unit)
        _setter("retention_value", retention_value)
        if frequency_type is not None:
            _setter("frequency_type", frequency_type)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, or `months`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        """
        return pulumi.get(self, "retention_value")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        """
        Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class CloudBackupSchedulePolicyItemWeekly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSchedulePolicyItemWeekly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSchedulePolicyItemWeekly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSchedulePolicyItemWeekly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 retention_unit: str,
                 retention_value: int,
                 frequency_type: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (weekly in this case). The supported values for weekly policies are `1` through `7`, where `1` represents Monday and `7` represents Sunday.
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, or `months`.
        :param int retention_value: Value to associate with `retention_unit`. Weekly policy must have retention of at least 7 days or 1 week. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the daily policy item specifies a retention of two weeks, the weekly retention policy must specify two weeks or greater.
        :param str frequency_type: Frequency associated with the backup policy item. For weekly policies, the frequency type is defined as `weekly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        """
        CloudBackupSchedulePolicyItemWeekly._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frequency_interval=frequency_interval,
            retention_unit=retention_unit,
            retention_value=retention_value,
            frequency_type=frequency_type,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frequency_interval: int,
             retention_unit: str,
             retention_value: int,
             frequency_type: Optional[str] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("frequency_interval", frequency_interval)
        _setter("retention_unit", retention_unit)
        _setter("retention_value", retention_value)
        if frequency_type is not None:
            _setter("frequency_type", frequency_type)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (weekly in this case). The supported values for weekly policies are `1` through `7`, where `1` represents Monday and `7` represents Sunday.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, or `months`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Weekly policy must have retention of at least 7 days or 1 week. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the daily policy item specifies a retention of two weeks, the weekly retention policy must specify two weeks or greater.
        """
        return pulumi.get(self, "retention_value")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        """
        Frequency associated with the backup policy item. For weekly policies, the frequency type is defined as `weekly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class CloudBackupSnapshotExportJobComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportId":
            suggest = "export_id"
        elif key == "replicaSetName":
            suggest = "replica_set_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSnapshotExportJobComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSnapshotExportJobComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSnapshotExportJobComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_id: Optional[str] = None,
                 replica_set_name: Optional[str] = None):
        """
        :param str export_id: _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        :param str replica_set_name: _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
        CloudBackupSnapshotExportJobComponent._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            export_id=export_id,
            replica_set_name=replica_set_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             export_id: Optional[str] = None,
             replica_set_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if export_id is not None:
            _setter("export_id", export_id)
        if replica_set_name is not None:
            _setter("replica_set_name", replica_set_name)

    @property
    @pulumi.getter(name="exportId")
    def export_id(self) -> Optional[str]:
        """
        _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        """
        return pulumi.get(self, "export_id")

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> Optional[str]:
        """
        _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
        return pulumi.get(self, "replica_set_name")


@pulumi.output_type
class CloudBackupSnapshotExportJobCustomData(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Required if you want to include custom data using `custom_data` in the metadata file uploaded to the bucket. Key to include in the metadata file that Atlas uploads to the bucket when the export job finishes.
        :param str value: Required if you specify `key`.
        """
        CloudBackupSnapshotExportJobCustomData._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Required if you want to include custom data using `custom_data` in the metadata file uploaded to the bucket. Key to include in the metadata file that Atlas uploads to the bucket when the export job finishes.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Required if you specify `key`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CloudBackupSnapshotMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudProvider":
            suggest = "cloud_provider"
        elif key == "replicaSetName":
            suggest = "replica_set_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSnapshotMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSnapshotMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSnapshotMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_provider: Optional[str] = None,
                 id: Optional[str] = None,
                 replica_set_name: Optional[str] = None):
        """
        :param str cloud_provider: Cloud provider that stores this snapshot.
        :param str id: Unique identifier for the sharded cluster snapshot.
        :param str replica_set_name: Label given to a shard or config server from which Atlas took this snapshot.
        """
        CloudBackupSnapshotMember._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_provider=cloud_provider,
            id=id,
            replica_set_name=replica_set_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_provider: Optional[str] = None,
             id: Optional[str] = None,
             replica_set_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cloud_provider is not None:
            _setter("cloud_provider", cloud_provider)
        if id is not None:
            _setter("id", id)
        if replica_set_name is not None:
            _setter("replica_set_name", replica_set_name)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[str]:
        """
        Cloud provider that stores this snapshot.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier for the sharded cluster snapshot.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> Optional[str]:
        """
        Label given to a shard or config server from which Atlas took this snapshot.
        """
        return pulumi.get(self, "replica_set_name")


@pulumi.output_type
class CloudBackupSnapshotRestoreJobDeliveryTypeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oplogInc":
            suggest = "oplog_inc"
        elif key == "oplogTs":
            suggest = "oplog_ts"
        elif key == "pointInTime":
            suggest = "point_in_time"
        elif key == "pointInTimeUtcSeconds":
            suggest = "point_in_time_utc_seconds"
        elif key == "targetClusterName":
            suggest = "target_cluster_name"
        elif key == "targetProjectId":
            suggest = "target_project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSnapshotRestoreJobDeliveryTypeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSnapshotRestoreJobDeliveryTypeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSnapshotRestoreJobDeliveryTypeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automated: Optional[bool] = None,
                 download: Optional[bool] = None,
                 oplog_inc: Optional[int] = None,
                 oplog_ts: Optional[int] = None,
                 point_in_time: Optional[bool] = None,
                 point_in_time_utc_seconds: Optional[int] = None,
                 target_cluster_name: Optional[str] = None,
                 target_project_id: Optional[str] = None):
        """
        :param str target_cluster_name: Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.
        :param str target_project_id: Name of the target Atlas project of the restore job. Only visible if deliveryType is automated.
        """
        CloudBackupSnapshotRestoreJobDeliveryTypeConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            automated=automated,
            download=download,
            oplog_inc=oplog_inc,
            oplog_ts=oplog_ts,
            point_in_time=point_in_time,
            point_in_time_utc_seconds=point_in_time_utc_seconds,
            target_cluster_name=target_cluster_name,
            target_project_id=target_project_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             automated: Optional[bool] = None,
             download: Optional[bool] = None,
             oplog_inc: Optional[int] = None,
             oplog_ts: Optional[int] = None,
             point_in_time: Optional[bool] = None,
             point_in_time_utc_seconds: Optional[int] = None,
             target_cluster_name: Optional[str] = None,
             target_project_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if automated is not None:
            _setter("automated", automated)
        if download is not None:
            _setter("download", download)
        if oplog_inc is not None:
            _setter("oplog_inc", oplog_inc)
        if oplog_ts is not None:
            _setter("oplog_ts", oplog_ts)
        if point_in_time is not None:
            _setter("point_in_time", point_in_time)
        if point_in_time_utc_seconds is not None:
            _setter("point_in_time_utc_seconds", point_in_time_utc_seconds)
        if target_cluster_name is not None:
            _setter("target_cluster_name", target_cluster_name)
        if target_project_id is not None:
            _setter("target_project_id", target_project_id)

    @property
    @pulumi.getter
    def automated(self) -> Optional[bool]:
        return pulumi.get(self, "automated")

    @property
    @pulumi.getter
    def download(self) -> Optional[bool]:
        return pulumi.get(self, "download")

    @property
    @pulumi.getter(name="oplogInc")
    def oplog_inc(self) -> Optional[int]:
        return pulumi.get(self, "oplog_inc")

    @property
    @pulumi.getter(name="oplogTs")
    def oplog_ts(self) -> Optional[int]:
        return pulumi.get(self, "oplog_ts")

    @property
    @pulumi.getter(name="pointInTime")
    def point_in_time(self) -> Optional[bool]:
        return pulumi.get(self, "point_in_time")

    @property
    @pulumi.getter(name="pointInTimeUtcSeconds")
    def point_in_time_utc_seconds(self) -> Optional[int]:
        return pulumi.get(self, "point_in_time_utc_seconds")

    @property
    @pulumi.getter(name="targetClusterName")
    def target_cluster_name(self) -> Optional[str]:
        """
        Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.
        """
        return pulumi.get(self, "target_cluster_name")

    @property
    @pulumi.getter(name="targetProjectId")
    def target_project_id(self) -> Optional[str]:
        """
        Name of the target Atlas project of the restore job. Only visible if deliveryType is automated.
        """
        return pulumi.get(self, "target_project_id")


@pulumi.output_type
class CloudProviderAccessAuthorizationAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iamAssumedRoleArn":
            suggest = "iam_assumed_role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudProviderAccessAuthorizationAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudProviderAccessAuthorizationAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudProviderAccessAuthorizationAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iam_assumed_role_arn: str):
        CloudProviderAccessAuthorizationAws._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            iam_assumed_role_arn=iam_assumed_role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             iam_assumed_role_arn: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("iam_assumed_role_arn", iam_assumed_role_arn)

    @property
    @pulumi.getter(name="iamAssumedRoleArn")
    def iam_assumed_role_arn(self) -> str:
        return pulumi.get(self, "iam_assumed_role_arn")


@pulumi.output_type
class CloudProviderAccessAuthorizationAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "atlasAzureAppId":
            suggest = "atlas_azure_app_id"
        elif key == "servicePrincipalId":
            suggest = "service_principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudProviderAccessAuthorizationAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudProviderAccessAuthorizationAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudProviderAccessAuthorizationAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 atlas_azure_app_id: str,
                 service_principal_id: str,
                 tenant_id: str):
        CloudProviderAccessAuthorizationAzure._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            atlas_azure_app_id=atlas_azure_app_id,
            service_principal_id=service_principal_id,
            tenant_id=tenant_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             atlas_azure_app_id: str,
             service_principal_id: str,
             tenant_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("atlas_azure_app_id", atlas_azure_app_id)
        _setter("service_principal_id", service_principal_id)
        _setter("tenant_id", tenant_id)

    @property
    @pulumi.getter(name="atlasAzureAppId")
    def atlas_azure_app_id(self) -> str:
        return pulumi.get(self, "atlas_azure_app_id")

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> str:
        return pulumi.get(self, "service_principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class CloudProviderAccessAuthorizationFeatureUsage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "featureId":
            suggest = "feature_id"
        elif key == "featureType":
            suggest = "feature_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudProviderAccessAuthorizationFeatureUsage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudProviderAccessAuthorizationFeatureUsage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudProviderAccessAuthorizationFeatureUsage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 feature_id: Optional[Mapping[str, Any]] = None,
                 feature_type: Optional[str] = None):
        CloudProviderAccessAuthorizationFeatureUsage._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            feature_id=feature_id,
            feature_type=feature_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             feature_id: Optional[Mapping[str, Any]] = None,
             feature_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if feature_id is not None:
            _setter("feature_id", feature_id)
        if feature_type is not None:
            _setter("feature_type", feature_type)

    @property
    @pulumi.getter(name="featureId")
    def feature_id(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "feature_id")

    @property
    @pulumi.getter(name="featureType")
    def feature_type(self) -> Optional[str]:
        return pulumi.get(self, "feature_type")


@pulumi.output_type
class CloudProviderAccessFeatureUsage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "featureId":
            suggest = "feature_id"
        elif key == "featureType":
            suggest = "feature_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudProviderAccessFeatureUsage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudProviderAccessFeatureUsage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudProviderAccessFeatureUsage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 feature_id: Optional[Mapping[str, Any]] = None,
                 feature_type: Optional[str] = None):
        CloudProviderAccessFeatureUsage._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            feature_id=feature_id,
            feature_type=feature_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             feature_id: Optional[Mapping[str, Any]] = None,
             feature_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if feature_id is not None:
            _setter("feature_id", feature_id)
        if feature_type is not None:
            _setter("feature_type", feature_type)

    @property
    @pulumi.getter(name="featureId")
    def feature_id(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "feature_id")

    @property
    @pulumi.getter(name="featureType")
    def feature_type(self) -> Optional[str]:
        return pulumi.get(self, "feature_type")


@pulumi.output_type
class CloudProviderAccessSetupAwsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "atlasAssumedRoleExternalId":
            suggest = "atlas_assumed_role_external_id"
        elif key == "atlasAwsAccountArn":
            suggest = "atlas_aws_account_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudProviderAccessSetupAwsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudProviderAccessSetupAwsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudProviderAccessSetupAwsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 atlas_assumed_role_external_id: Optional[str] = None,
                 atlas_aws_account_arn: Optional[str] = None):
        CloudProviderAccessSetupAwsConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            atlas_assumed_role_external_id=atlas_assumed_role_external_id,
            atlas_aws_account_arn=atlas_aws_account_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             atlas_assumed_role_external_id: Optional[str] = None,
             atlas_aws_account_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if atlas_assumed_role_external_id is not None:
            _setter("atlas_assumed_role_external_id", atlas_assumed_role_external_id)
        if atlas_aws_account_arn is not None:
            _setter("atlas_aws_account_arn", atlas_aws_account_arn)

    @property
    @pulumi.getter(name="atlasAssumedRoleExternalId")
    def atlas_assumed_role_external_id(self) -> Optional[str]:
        return pulumi.get(self, "atlas_assumed_role_external_id")

    @property
    @pulumi.getter(name="atlasAwsAccountArn")
    def atlas_aws_account_arn(self) -> Optional[str]:
        return pulumi.get(self, "atlas_aws_account_arn")


@pulumi.output_type
class CloudProviderAccessSetupAzureConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "atlasAzureAppId":
            suggest = "atlas_azure_app_id"
        elif key == "servicePrincipalId":
            suggest = "service_principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudProviderAccessSetupAzureConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudProviderAccessSetupAzureConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudProviderAccessSetupAzureConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 atlas_azure_app_id: str,
                 service_principal_id: str,
                 tenant_id: str):
        CloudProviderAccessSetupAzureConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            atlas_azure_app_id=atlas_azure_app_id,
            service_principal_id=service_principal_id,
            tenant_id=tenant_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             atlas_azure_app_id: str,
             service_principal_id: str,
             tenant_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("atlas_azure_app_id", atlas_azure_app_id)
        _setter("service_principal_id", service_principal_id)
        _setter("tenant_id", tenant_id)

    @property
    @pulumi.getter(name="atlasAzureAppId")
    def atlas_azure_app_id(self) -> str:
        return pulumi.get(self, "atlas_azure_app_id")

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> str:
        return pulumi.get(self, "service_principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class ClusterAdvancedConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultReadConcern":
            suggest = "default_read_concern"
        elif key == "defaultWriteConcern":
            suggest = "default_write_concern"
        elif key == "failIndexKeyTooLong":
            suggest = "fail_index_key_too_long"
        elif key == "javascriptEnabled":
            suggest = "javascript_enabled"
        elif key == "minimumEnabledTlsProtocol":
            suggest = "minimum_enabled_tls_protocol"
        elif key == "noTableScan":
            suggest = "no_table_scan"
        elif key == "oplogMinRetentionHours":
            suggest = "oplog_min_retention_hours"
        elif key == "oplogSizeMb":
            suggest = "oplog_size_mb"
        elif key == "sampleRefreshIntervalBiConnector":
            suggest = "sample_refresh_interval_bi_connector"
        elif key == "sampleSizeBiConnector":
            suggest = "sample_size_bi_connector"
        elif key == "transactionLifetimeLimitSeconds":
            suggest = "transaction_lifetime_limit_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAdvancedConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAdvancedConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAdvancedConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_read_concern: Optional[str] = None,
                 default_write_concern: Optional[str] = None,
                 fail_index_key_too_long: Optional[bool] = None,
                 javascript_enabled: Optional[bool] = None,
                 minimum_enabled_tls_protocol: Optional[str] = None,
                 no_table_scan: Optional[bool] = None,
                 oplog_min_retention_hours: Optional[int] = None,
                 oplog_size_mb: Optional[int] = None,
                 sample_refresh_interval_bi_connector: Optional[int] = None,
                 sample_size_bi_connector: Optional[int] = None,
                 transaction_lifetime_limit_seconds: Optional[int] = None):
        """
        :param str default_read_concern: [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        :param str default_write_concern: [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        :param bool fail_index_key_too_long: When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        :param bool javascript_enabled: When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        :param str minimum_enabled_tls_protocol: Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
               
               - TLS1_0
               - TLS1_1
               - TLS1_2
        :param bool no_table_scan: When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        :param int oplog_min_retention_hours: Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
               * **Note**  A minimum oplog retention is required when seeking to change a cluster's class to Local NVMe SSD. To learn more and for latest guidance see  [`oplogMinRetentionHours`](https://www.mongodb.com/docs/manual/core/replica-set-oplog/#std-label-replica-set-minimum-oplog-size)
        :param int oplog_size_mb: The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        :param int sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param int sample_size_bi_connector: Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param int transaction_lifetime_limit_seconds: Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        ClusterAdvancedConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_read_concern=default_read_concern,
            default_write_concern=default_write_concern,
            fail_index_key_too_long=fail_index_key_too_long,
            javascript_enabled=javascript_enabled,
            minimum_enabled_tls_protocol=minimum_enabled_tls_protocol,
            no_table_scan=no_table_scan,
            oplog_min_retention_hours=oplog_min_retention_hours,
            oplog_size_mb=oplog_size_mb,
            sample_refresh_interval_bi_connector=sample_refresh_interval_bi_connector,
            sample_size_bi_connector=sample_size_bi_connector,
            transaction_lifetime_limit_seconds=transaction_lifetime_limit_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_read_concern: Optional[str] = None,
             default_write_concern: Optional[str] = None,
             fail_index_key_too_long: Optional[bool] = None,
             javascript_enabled: Optional[bool] = None,
             minimum_enabled_tls_protocol: Optional[str] = None,
             no_table_scan: Optional[bool] = None,
             oplog_min_retention_hours: Optional[int] = None,
             oplog_size_mb: Optional[int] = None,
             sample_refresh_interval_bi_connector: Optional[int] = None,
             sample_size_bi_connector: Optional[int] = None,
             transaction_lifetime_limit_seconds: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if default_read_concern is not None:
            _setter("default_read_concern", default_read_concern)
        if default_write_concern is not None:
            _setter("default_write_concern", default_write_concern)
        if fail_index_key_too_long is not None:
            _setter("fail_index_key_too_long", fail_index_key_too_long)
        if javascript_enabled is not None:
            _setter("javascript_enabled", javascript_enabled)
        if minimum_enabled_tls_protocol is not None:
            _setter("minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        if no_table_scan is not None:
            _setter("no_table_scan", no_table_scan)
        if oplog_min_retention_hours is not None:
            _setter("oplog_min_retention_hours", oplog_min_retention_hours)
        if oplog_size_mb is not None:
            _setter("oplog_size_mb", oplog_size_mb)
        if sample_refresh_interval_bi_connector is not None:
            _setter("sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        if sample_size_bi_connector is not None:
            _setter("sample_size_bi_connector", sample_size_bi_connector)
        if transaction_lifetime_limit_seconds is not None:
            _setter("transaction_lifetime_limit_seconds", transaction_lifetime_limit_seconds)

    @property
    @pulumi.getter(name="defaultReadConcern")
    def default_read_concern(self) -> Optional[str]:
        """
        [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        """
        return pulumi.get(self, "default_read_concern")

    @property
    @pulumi.getter(name="defaultWriteConcern")
    def default_write_concern(self) -> Optional[str]:
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        return pulumi.get(self, "default_write_concern")

    @property
    @pulumi.getter(name="failIndexKeyTooLong")
    def fail_index_key_too_long(self) -> Optional[bool]:
        """
        When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        """
        return pulumi.get(self, "fail_index_key_too_long")

    @property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> Optional[bool]:
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        return pulumi.get(self, "javascript_enabled")

    @property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> Optional[str]:
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:

        - TLS1_0
        - TLS1_1
        - TLS1_2
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> Optional[bool]:
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        return pulumi.get(self, "no_table_scan")

    @property
    @pulumi.getter(name="oplogMinRetentionHours")
    def oplog_min_retention_hours(self) -> Optional[int]:
        """
        Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        * **Note**  A minimum oplog retention is required when seeking to change a cluster's class to Local NVMe SSD. To learn more and for latest guidance see  [`oplogMinRetentionHours`](https://www.mongodb.com/docs/manual/core/replica-set-oplog/#std-label-replica-set-minimum-oplog-size)
        """
        return pulumi.get(self, "oplog_min_retention_hours")

    @property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> Optional[int]:
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        return pulumi.get(self, "oplog_size_mb")

    @property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> Optional[int]:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> Optional[int]:
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_size_bi_connector")

    @property
    @pulumi.getter(name="transactionLifetimeLimitSeconds")
    def transaction_lifetime_limit_seconds(self) -> Optional[int]:
        """
        Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        return pulumi.get(self, "transaction_lifetime_limit_seconds")


@pulumi.output_type
class ClusterBiConnectorConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readPreference":
            suggest = "read_preference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterBiConnectorConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterBiConnectorConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterBiConnectorConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 read_preference: Optional[str] = None):
        """
        :param bool enabled: Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
               *
               - Set to `true` to enable BI Connector for Atlas.
               - Set to `false` to disable BI Connector for Atlas.
        :param str read_preference: Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
               
               - Set to "primary" to have BI Connector for Atlas read from the primary.
               
               - Set to "secondary" to have BI Connector for Atlas read from a secondary member. Default if there are no analytics nodes in the cluster.
               
               - Set to "analytics" to have BI Connector for Atlas read from an analytics node. Default if the cluster contains analytics nodes.
        """
        ClusterBiConnectorConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            read_preference=read_preference,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             read_preference: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enabled is not None:
            _setter("enabled", enabled)
        if read_preference is not None:
            _setter("read_preference", read_preference)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
        *
        - Set to `true` to enable BI Connector for Atlas.
        - Set to `false` to disable BI Connector for Atlas.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> Optional[str]:
        """
        Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).

        - Set to "primary" to have BI Connector for Atlas read from the primary.

        - Set to "secondary" to have BI Connector for Atlas read from a secondary member. Default if there are no analytics nodes in the cluster.

        - Set to "analytics" to have BI Connector for Atlas read from an analytics node. Default if the cluster contains analytics nodes.
        """
        return pulumi.get(self, "read_preference")


@pulumi.output_type
class ClusterConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateEndpoints":
            suggest = "private_endpoints"
        elif key == "privateSrv":
            suggest = "private_srv"
        elif key == "standardSrv":
            suggest = "standard_srv"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private: Optional[str] = None,
                 private_endpoints: Optional[Sequence['outputs.ClusterConnectionStringPrivateEndpoint']] = None,
                 private_srv: Optional[str] = None,
                 standard: Optional[str] = None,
                 standard_srv: Optional[str] = None):
        ClusterConnectionString._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private=private,
            private_endpoints=private_endpoints,
            private_srv=private_srv,
            standard=standard,
            standard_srv=standard_srv,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private: Optional[str] = None,
             private_endpoints: Optional[Sequence['outputs.ClusterConnectionStringPrivateEndpoint']] = None,
             private_srv: Optional[str] = None,
             standard: Optional[str] = None,
             standard_srv: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if private is not None:
            _setter("private", private)
        if private_endpoints is not None:
            _setter("private_endpoints", private_endpoints)
        if private_srv is not None:
            _setter("private_srv", private_srv)
        if standard is not None:
            _setter("standard", standard)
        if standard_srv is not None:
            _setter("standard_srv", standard_srv)

    @property
    @pulumi.getter
    def private(self) -> Optional[str]:
        return pulumi.get(self, "private")

    @property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Optional[Sequence['outputs.ClusterConnectionStringPrivateEndpoint']]:
        return pulumi.get(self, "private_endpoints")

    @property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> Optional[str]:
        return pulumi.get(self, "private_srv")

    @property
    @pulumi.getter
    def standard(self) -> Optional[str]:
        return pulumi.get(self, "standard")

    @property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> Optional[str]:
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class ClusterConnectionStringPrivateEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionString":
            suggest = "connection_string"
        elif key == "srvConnectionString":
            suggest = "srv_connection_string"
        elif key == "srvShardOptimizedConnectionString":
            suggest = "srv_shard_optimized_connection_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterConnectionStringPrivateEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterConnectionStringPrivateEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterConnectionStringPrivateEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_string: Optional[str] = None,
                 endpoints: Optional[Sequence['outputs.ClusterConnectionStringPrivateEndpointEndpoint']] = None,
                 srv_connection_string: Optional[str] = None,
                 srv_shard_optimized_connection_string: Optional[str] = None,
                 type: Optional[str] = None):
        ClusterConnectionStringPrivateEndpoint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_string=connection_string,
            endpoints=endpoints,
            srv_connection_string=srv_connection_string,
            srv_shard_optimized_connection_string=srv_shard_optimized_connection_string,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_string: Optional[str] = None,
             endpoints: Optional[Sequence['outputs.ClusterConnectionStringPrivateEndpointEndpoint']] = None,
             srv_connection_string: Optional[str] = None,
             srv_shard_optimized_connection_string: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if connection_string is not None:
            _setter("connection_string", connection_string)
        if endpoints is not None:
            _setter("endpoints", endpoints)
        if srv_connection_string is not None:
            _setter("srv_connection_string", srv_connection_string)
        if srv_shard_optimized_connection_string is not None:
            _setter("srv_shard_optimized_connection_string", srv_shard_optimized_connection_string)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[str]:
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence['outputs.ClusterConnectionStringPrivateEndpointEndpoint']]:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> Optional[str]:
        return pulumi.get(self, "srv_connection_string")

    @property
    @pulumi.getter(name="srvShardOptimizedConnectionString")
    def srv_shard_optimized_connection_string(self) -> Optional[str]:
        return pulumi.get(self, "srv_shard_optimized_connection_string")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class ClusterConnectionStringPrivateEndpointEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointId":
            suggest = "endpoint_id"
        elif key == "providerName":
            suggest = "provider_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterConnectionStringPrivateEndpointEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterConnectionStringPrivateEndpointEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterConnectionStringPrivateEndpointEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_id: Optional[str] = None,
                 provider_name: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str provider_name: Cloud service provider on which the servers are provisioned.
               
               The possible values are:
        """
        ClusterConnectionStringPrivateEndpointEndpoint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_id=endpoint_id,
            provider_name=provider_name,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_id: Optional[str] = None,
             provider_name: Optional[str] = None,
             region: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if endpoint_id is not None:
            _setter("endpoint_id", endpoint_id)
        if provider_name is not None:
            _setter("provider_name", provider_name)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[str]:
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> Optional[str]:
        """
        Cloud service provider on which the servers are provisioned.

        The possible values are:
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class ClusterLabel(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
               
               > **NOTE:** MongoDB Atlas doesn't display your labels.
        """
        ClusterLabel._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value that you want to write.

        > **NOTE:** MongoDB Atlas doesn't display your labels.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterOutageSimulationOutageFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudProvider":
            suggest = "cloud_provider"
        elif key == "regionName":
            suggest = "region_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterOutageSimulationOutageFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterOutageSimulationOutageFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterOutageSimulationOutageFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_provider: str,
                 region_name: str,
                 type: Optional[str] = None):
        """
        :param str cloud_provider: The cloud provider of the region that undergoes the outage simulation. Following values are supported:
        :param str region_name: The Atlas name of the region to undergo an outage simulation.
        :param str type: The type of cluster outage simulation. Following values are supported:
        """
        ClusterOutageSimulationOutageFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_provider=cloud_provider,
            region_name=region_name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_provider: str,
             region_name: str,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cloud_provider", cloud_provider)
        _setter("region_name", region_name)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        The cloud provider of the region that undergoes the outage simulation. Following values are supported:
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        The Atlas name of the region to undergo an outage simulation.
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of cluster outage simulation. Following values are supported:
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ClusterReplicationSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numShards":
            suggest = "num_shards"
        elif key == "regionsConfigs":
            suggest = "regions_configs"
        elif key == "zoneName":
            suggest = "zone_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterReplicationSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterReplicationSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterReplicationSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_shards: int,
                 id: Optional[str] = None,
                 regions_configs: Optional[Sequence['outputs.ClusterReplicationSpecRegionsConfig']] = None,
                 zone_name: Optional[str] = None):
        """
        :param int num_shards: Selects whether the cluster is a replica set or a sharded cluster. If you use the replicationSpecs parameter, you must set num_shards.
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster.
        :param Sequence['ClusterReplicationSpecRegionsConfigArgs'] regions_configs: Physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        :param str zone_name: Name for the zone in a Global Cluster.
               
               
               **Region Config**
        """
        ClusterReplicationSpec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            num_shards=num_shards,
            id=id,
            regions_configs=regions_configs,
            zone_name=zone_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             num_shards: int,
             id: Optional[str] = None,
             regions_configs: Optional[Sequence['outputs.ClusterReplicationSpecRegionsConfig']] = None,
             zone_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("num_shards", num_shards)
        if id is not None:
            _setter("id", id)
        if regions_configs is not None:
            _setter("regions_configs", regions_configs)
        if zone_name is not None:
            _setter("zone_name", zone_name)

    @property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> int:
        """
        Selects whether the cluster is a replica set or a sharded cluster. If you use the replicationSpecs parameter, you must set num_shards.
        """
        return pulumi.get(self, "num_shards")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifer of the replication document for a zone in a Global Cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="regionsConfigs")
    def regions_configs(self) -> Optional[Sequence['outputs.ClusterReplicationSpecRegionsConfig']]:
        """
        Physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        """
        return pulumi.get(self, "regions_configs")

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> Optional[str]:
        """
        Name for the zone in a Global Cluster.


        **Region Config**
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class ClusterReplicationSpecRegionsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionName":
            suggest = "region_name"
        elif key == "analyticsNodes":
            suggest = "analytics_nodes"
        elif key == "electableNodes":
            suggest = "electable_nodes"
        elif key == "readOnlyNodes":
            suggest = "read_only_nodes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterReplicationSpecRegionsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterReplicationSpecRegionsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterReplicationSpecRegionsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region_name: str,
                 analytics_nodes: Optional[int] = None,
                 electable_nodes: Optional[int] = None,
                 priority: Optional[int] = None,
                 read_only_nodes: Optional[int] = None):
        """
        :param str region_name: Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        :param int analytics_nodes: The number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary. If you do not specify this option, no analytics nodes are deployed to the region.
        :param int electable_nodes: Number of electable nodes for Atlas to deploy to the region. Electable nodes can become the primary and can facilitate local reads.
               * The total number of electableNodes across all replication spec regions  must total 3, 5, or 7.
               * Specify 0 if you do not want any electable nodes in the region.
               * You cannot create electable nodes in a region if `priority` is 0.
        :param int priority: Election priority of the region. For regions with only read-only nodes, set this value to 0.
               * For regions where `electable_nodes` is at least 1, each region must have a priority of exactly one (1) less than the previous region. The first region must have a priority of 7. The lowest possible priority is 1.
               * The priority 7 region identifies the Preferred Region of the cluster. Atlas places the primary node in the Preferred Region. Priorities 1 through 7 are exclusive - no more than one region per cluster can be assigned a given priority.
               * Example: If you have three regions, their priorities would be 7, 6, and 5 respectively. If you added two more regions for supporting electable nodes, the priorities of those regions would be 4 and 3 respectively.
        :param int read_only_nodes: Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        """
        ClusterReplicationSpecRegionsConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            region_name=region_name,
            analytics_nodes=analytics_nodes,
            electable_nodes=electable_nodes,
            priority=priority,
            read_only_nodes=read_only_nodes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             region_name: str,
             analytics_nodes: Optional[int] = None,
             electable_nodes: Optional[int] = None,
             priority: Optional[int] = None,
             read_only_nodes: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("region_name", region_name)
        if analytics_nodes is not None:
            _setter("analytics_nodes", analytics_nodes)
        if electable_nodes is not None:
            _setter("electable_nodes", electable_nodes)
        if priority is not None:
            _setter("priority", priority)
        if read_only_nodes is not None:
            _setter("read_only_nodes", read_only_nodes)

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter(name="analyticsNodes")
    def analytics_nodes(self) -> Optional[int]:
        """
        The number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary. If you do not specify this option, no analytics nodes are deployed to the region.
        """
        return pulumi.get(self, "analytics_nodes")

    @property
    @pulumi.getter(name="electableNodes")
    def electable_nodes(self) -> Optional[int]:
        """
        Number of electable nodes for Atlas to deploy to the region. Electable nodes can become the primary and can facilitate local reads.
        * The total number of electableNodes across all replication spec regions  must total 3, 5, or 7.
        * Specify 0 if you do not want any electable nodes in the region.
        * You cannot create electable nodes in a region if `priority` is 0.
        """
        return pulumi.get(self, "electable_nodes")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Election priority of the region. For regions with only read-only nodes, set this value to 0.
        * For regions where `electable_nodes` is at least 1, each region must have a priority of exactly one (1) less than the previous region. The first region must have a priority of 7. The lowest possible priority is 1.
        * The priority 7 region identifies the Preferred Region of the cluster. Atlas places the primary node in the Preferred Region. Priorities 1 through 7 are exclusive - no more than one region per cluster can be assigned a given priority.
        * Example: If you have three regions, their priorities would be 7, 6, and 5 respectively. If you added two more regions for supporting electable nodes, the priorities of those regions would be 4 and 3 respectively.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="readOnlyNodes")
    def read_only_nodes(self) -> Optional[int]:
        """
        Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        """
        return pulumi.get(self, "read_only_nodes")


@pulumi.output_type
class ClusterSnapshotBackupPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterId":
            suggest = "cluster_id"
        elif key == "clusterName":
            suggest = "cluster_name"
        elif key == "nextSnapshot":
            suggest = "next_snapshot"
        elif key == "referenceHourOfDay":
            suggest = "reference_hour_of_day"
        elif key == "referenceMinuteOfHour":
            suggest = "reference_minute_of_hour"
        elif key == "restoreWindowDays":
            suggest = "restore_window_days"
        elif key == "updateSnapshots":
            suggest = "update_snapshots"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSnapshotBackupPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSnapshotBackupPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSnapshotBackupPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_id: Optional[str] = None,
                 cluster_name: Optional[str] = None,
                 next_snapshot: Optional[str] = None,
                 policies: Optional[Sequence['outputs.ClusterSnapshotBackupPolicyPolicy']] = None,
                 reference_hour_of_day: Optional[int] = None,
                 reference_minute_of_hour: Optional[int] = None,
                 restore_window_days: Optional[int] = None,
                 update_snapshots: Optional[bool] = None):
        """
        :param str cluster_id: The cluster ID.
        """
        ClusterSnapshotBackupPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster_id=cluster_id,
            cluster_name=cluster_name,
            next_snapshot=next_snapshot,
            policies=policies,
            reference_hour_of_day=reference_hour_of_day,
            reference_minute_of_hour=reference_minute_of_hour,
            restore_window_days=restore_window_days,
            update_snapshots=update_snapshots,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster_id: Optional[str] = None,
             cluster_name: Optional[str] = None,
             next_snapshot: Optional[str] = None,
             policies: Optional[Sequence['outputs.ClusterSnapshotBackupPolicyPolicy']] = None,
             reference_hour_of_day: Optional[int] = None,
             reference_minute_of_hour: Optional[int] = None,
             restore_window_days: Optional[int] = None,
             update_snapshots: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cluster_id is not None:
            _setter("cluster_id", cluster_id)
        if cluster_name is not None:
            _setter("cluster_name", cluster_name)
        if next_snapshot is not None:
            _setter("next_snapshot", next_snapshot)
        if policies is not None:
            _setter("policies", policies)
        if reference_hour_of_day is not None:
            _setter("reference_hour_of_day", reference_hour_of_day)
        if reference_minute_of_hour is not None:
            _setter("reference_minute_of_hour", reference_minute_of_hour)
        if restore_window_days is not None:
            _setter("restore_window_days", restore_window_days)
        if update_snapshots is not None:
            _setter("update_snapshots", update_snapshots)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[str]:
        """
        The cluster ID.
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="nextSnapshot")
    def next_snapshot(self) -> Optional[str]:
        return pulumi.get(self, "next_snapshot")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence['outputs.ClusterSnapshotBackupPolicyPolicy']]:
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="referenceHourOfDay")
    def reference_hour_of_day(self) -> Optional[int]:
        return pulumi.get(self, "reference_hour_of_day")

    @property
    @pulumi.getter(name="referenceMinuteOfHour")
    def reference_minute_of_hour(self) -> Optional[int]:
        return pulumi.get(self, "reference_minute_of_hour")

    @property
    @pulumi.getter(name="restoreWindowDays")
    def restore_window_days(self) -> Optional[int]:
        return pulumi.get(self, "restore_window_days")

    @property
    @pulumi.getter(name="updateSnapshots")
    def update_snapshots(self) -> Optional[bool]:
        return pulumi.get(self, "update_snapshots")


@pulumi.output_type
class ClusterSnapshotBackupPolicyPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyItems":
            suggest = "policy_items"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSnapshotBackupPolicyPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSnapshotBackupPolicyPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSnapshotBackupPolicyPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[str] = None,
                 policy_items: Optional[Sequence['outputs.ClusterSnapshotBackupPolicyPolicyPolicyItem']] = None):
        """
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster.
        """
        ClusterSnapshotBackupPolicyPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            policy_items=policy_items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             policy_items: Optional[Sequence['outputs.ClusterSnapshotBackupPolicyPolicyPolicyItem']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if id is not None:
            _setter("id", id)
        if policy_items is not None:
            _setter("policy_items", policy_items)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifer of the replication document for a zone in a Global Cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="policyItems")
    def policy_items(self) -> Optional[Sequence['outputs.ClusterSnapshotBackupPolicyPolicyPolicyItem']]:
        return pulumi.get(self, "policy_items")


@pulumi.output_type
class ClusterSnapshotBackupPolicyPolicyPolicyItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "frequencyType":
            suggest = "frequency_type"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSnapshotBackupPolicyPolicyPolicyItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSnapshotBackupPolicyPolicyPolicyItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSnapshotBackupPolicyPolicyPolicyItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: Optional[int] = None,
                 frequency_type: Optional[str] = None,
                 id: Optional[str] = None,
                 retention_unit: Optional[str] = None,
                 retention_value: Optional[int] = None):
        """
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster.
        """
        ClusterSnapshotBackupPolicyPolicyPolicyItem._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frequency_interval=frequency_interval,
            frequency_type=frequency_type,
            id=id,
            retention_unit=retention_unit,
            retention_value=retention_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frequency_interval: Optional[int] = None,
             frequency_type: Optional[str] = None,
             id: Optional[str] = None,
             retention_unit: Optional[str] = None,
             retention_value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if frequency_interval is not None:
            _setter("frequency_interval", frequency_interval)
        if frequency_type is not None:
            _setter("frequency_type", frequency_type)
        if id is not None:
            _setter("id", id)
        if retention_unit is not None:
            _setter("retention_unit", retention_unit)
        if retention_value is not None:
            _setter("retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> Optional[int]:
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifer of the replication document for a zone in a Global Cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> Optional[str]:
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> Optional[int]:
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class ClusterTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Constant that defines the set of the tag.
        :param str value: Variable that belongs to the set of the tag.
               
               To learn more, see [Resource Tags](https://dochub.mongodb.org/core/add-cluster-tag-atlas).
        """
        ClusterTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Constant that defines the set of the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Variable that belongs to the set of the tag.

        To learn more, see [Resource Tags](https://dochub.mongodb.org/core/add-cluster-tag-atlas).
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomDbRoleAction(dict):
    def __init__(__self__, *,
                 action: str,
                 resources: Sequence['outputs.CustomDbRoleActionResource']):
        """
        :param str action: Name of the privilege action. For a complete list of actions available in the Atlas API, see [Custom Role Actions](https://docs.atlas.mongodb.com/reference/api/custom-role-actions)
               > **Note**: The privilege actions available to the Custom Roles API resource represent a subset of the privilege actions available in the Atlas Custom Roles UI.
        :param Sequence['CustomDbRoleActionResourceArgs'] resources: Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
               
               * `resources.#.collection_name` - (Optional) Collection on which the action is granted. If this value is an empty string, the action is granted on all collections within the database specified in the actions.resources.db field.
               
               > **NOTE** This field is mutually exclusive with the `actions.resources.cluster` field.
               
               * `resources.#.database_name`	Database on which the action is granted.
               
               > **NOTE** This field is mutually exclusive with the `actions.resources.cluster` field.
               
               * `resources.#.cluster`	(Optional) Set to true to indicate that the action is granted on the cluster resource.
               
               > **NOTE** This field is mutually exclusive with the `actions.resources.collection` and `actions.resources.db fields`.
        """
        CustomDbRoleAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            resources=resources,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: str,
             resources: Sequence['outputs.CustomDbRoleActionResource'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action", action)
        _setter("resources", resources)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Name of the privilege action. For a complete list of actions available in the Atlas API, see [Custom Role Actions](https://docs.atlas.mongodb.com/reference/api/custom-role-actions)
        > **Note**: The privilege actions available to the Custom Roles API resource represent a subset of the privilege actions available in the Atlas Custom Roles UI.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.CustomDbRoleActionResource']:
        """
        Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.

        * `resources.#.collection_name` - (Optional) Collection on which the action is granted. If this value is an empty string, the action is granted on all collections within the database specified in the actions.resources.db field.

        > **NOTE** This field is mutually exclusive with the `actions.resources.cluster` field.

        * `resources.#.database_name`	Database on which the action is granted.

        > **NOTE** This field is mutually exclusive with the `actions.resources.cluster` field.

        * `resources.#.cluster`	(Optional) Set to true to indicate that the action is granted on the cluster resource.

        > **NOTE** This field is mutually exclusive with the `actions.resources.collection` and `actions.resources.db fields`.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class CustomDbRoleActionResource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collectionName":
            suggest = "collection_name"
        elif key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomDbRoleActionResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomDbRoleActionResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomDbRoleActionResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster: Optional[bool] = None,
                 collection_name: Optional[str] = None,
                 database_name: Optional[str] = None):
        """
        :param str database_name: Database on which the inherited role is granted.
               
               > **NOTE** This value should be admin for all roles except read and readWrite.
        """
        CustomDbRoleActionResource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster=cluster,
            collection_name=collection_name,
            database_name=database_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster: Optional[bool] = None,
             collection_name: Optional[str] = None,
             database_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cluster is not None:
            _setter("cluster", cluster)
        if collection_name is not None:
            _setter("collection_name", collection_name)
        if database_name is not None:
            _setter("database_name", database_name)

    @property
    @pulumi.getter
    def cluster(self) -> Optional[bool]:
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[str]:
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        Database on which the inherited role is granted.

        > **NOTE** This value should be admin for all roles except read and readWrite.
        """
        return pulumi.get(self, "database_name")


@pulumi.output_type
class CustomDbRoleInheritedRole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "roleName":
            suggest = "role_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomDbRoleInheritedRole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomDbRoleInheritedRole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomDbRoleInheritedRole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 role_name: str):
        """
        :param str database_name: Database on which the inherited role is granted.
               
               > **NOTE** This value should be admin for all roles except read and readWrite.
        :param str role_name: Name of the inherited role. This can either be another custom role or a built-in role.
        """
        CustomDbRoleInheritedRole._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            role_name=role_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: str,
             role_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database_name", database_name)
        _setter("role_name", role_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Database on which the inherited role is granted.

        > **NOTE** This value should be admin for all roles except read and readWrite.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        """
        Name of the inherited role. This can either be another custom role or a built-in role.
        """
        return pulumi.get(self, "role_name")


@pulumi.output_type
class DataLakeAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleId":
            suggest = "role_id"
        elif key == "testS3Bucket":
            suggest = "test_s3_bucket"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "iamAssumedRoleArn":
            suggest = "iam_assumed_role_arn"
        elif key == "iamUserArn":
            suggest = "iam_user_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakeAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakeAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakeAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_id: str,
                 test_s3_bucket: str,
                 external_id: Optional[str] = None,
                 iam_assumed_role_arn: Optional[str] = None,
                 iam_user_arn: Optional[str] = None):
        DataLakeAws._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_id=role_id,
            test_s3_bucket=test_s3_bucket,
            external_id=external_id,
            iam_assumed_role_arn=iam_assumed_role_arn,
            iam_user_arn=iam_user_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_id: str,
             test_s3_bucket: str,
             external_id: Optional[str] = None,
             iam_assumed_role_arn: Optional[str] = None,
             iam_user_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("role_id", role_id)
        _setter("test_s3_bucket", test_s3_bucket)
        if external_id is not None:
            _setter("external_id", external_id)
        if iam_assumed_role_arn is not None:
            _setter("iam_assumed_role_arn", iam_assumed_role_arn)
        if iam_user_arn is not None:
            _setter("iam_user_arn", iam_user_arn)

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> str:
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="testS3Bucket")
    def test_s3_bucket(self) -> str:
        return pulumi.get(self, "test_s3_bucket")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="iamAssumedRoleArn")
    def iam_assumed_role_arn(self) -> Optional[str]:
        return pulumi.get(self, "iam_assumed_role_arn")

    @property
    @pulumi.getter(name="iamUserArn")
    def iam_user_arn(self) -> Optional[str]:
        return pulumi.get(self, "iam_user_arn")


@pulumi.output_type
class DataLakeDataProcessRegion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudProvider":
            suggest = "cloud_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakeDataProcessRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakeDataProcessRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakeDataProcessRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_provider: str,
                 region: str):
        DataLakeDataProcessRegion._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_provider=cloud_provider,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_provider: str,
             region: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cloud_provider", cloud_provider)
        _setter("region", region)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class DataLakePipelineIngestionSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "frequencyType":
            suggest = "frequency_type"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakePipelineIngestionSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakePipelineIngestionSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakePipelineIngestionSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: Optional[int] = None,
                 frequency_type: Optional[str] = None,
                 id: Optional[str] = None,
                 retention_unit: Optional[str] = None,
                 retention_value: Optional[int] = None):
        """
        :param str id: Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.
        """
        DataLakePipelineIngestionSchedule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frequency_interval=frequency_interval,
            frequency_type=frequency_type,
            id=id,
            retention_unit=retention_unit,
            retention_value=retention_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frequency_interval: Optional[int] = None,
             frequency_type: Optional[str] = None,
             id: Optional[str] = None,
             retention_unit: Optional[str] = None,
             retention_value: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if frequency_interval is not None:
            _setter("frequency_interval", frequency_interval)
        if frequency_type is not None:
            _setter("frequency_type", frequency_type)
        if id is not None:
            _setter("id", id)
        if retention_unit is not None:
            _setter("retention_unit", retention_unit)
        if retention_value is not None:
            _setter("retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> Optional[int]:
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> Optional[str]:
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> Optional[int]:
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class DataLakePipelineSink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "partitionFields":
            suggest = "partition_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakePipelineSink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakePipelineSink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakePipelineSink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 partition_fields: Optional[Sequence['outputs.DataLakePipelineSinkPartitionField']] = None,
                 provider: Optional[str] = None,
                 region: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param Sequence['DataLakePipelineSinkPartitionFieldArgs'] partition_fields: Ordered fields used to physically organize data in the destination.
               * `partition_fields.#.field_name` - Human-readable label that identifies the field name used to partition data.
               * `partition_fields.#.order` - Sequence in which MongoDB Atlas slices the collection data to create partitions. The resource expresses this sequence starting with zero.
        :param str provider: Target cloud provider for this Data Lake Pipeline.
        :param str region: Target cloud provider region for this Data Lake Pipeline. [Supported cloud provider regions](https://www.mongodb.com/docs/datalake/limitations).
        :param str type: Type of ingestion source of this Data Lake Pipeline.
        """
        DataLakePipelineSink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            partition_fields=partition_fields,
            provider=provider,
            region=region,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             partition_fields: Optional[Sequence['outputs.DataLakePipelineSinkPartitionField']] = None,
             provider: Optional[str] = None,
             region: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if partition_fields is not None:
            _setter("partition_fields", partition_fields)
        if provider is not None:
            _setter("provider", provider)
        if region is not None:
            _setter("region", region)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="partitionFields")
    def partition_fields(self) -> Optional[Sequence['outputs.DataLakePipelineSinkPartitionField']]:
        """
        Ordered fields used to physically organize data in the destination.
        * `partition_fields.#.field_name` - Human-readable label that identifies the field name used to partition data.
        * `partition_fields.#.order` - Sequence in which MongoDB Atlas slices the collection data to create partitions. The resource expresses this sequence starting with zero.
        """
        return pulumi.get(self, "partition_fields")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        """
        Target cloud provider for this Data Lake Pipeline.
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Target cloud provider region for this Data Lake Pipeline. [Supported cloud provider regions](https://www.mongodb.com/docs/datalake/limitations).
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DataLakePipelineSinkPartitionField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakePipelineSinkPartitionField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakePipelineSinkPartitionField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakePipelineSinkPartitionField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: str,
                 order: int):
        DataLakePipelineSinkPartitionField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_name=field_name,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_name: str,
             order: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_name", field_name)
        _setter("order", order)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def order(self) -> int:
        return pulumi.get(self, "order")


@pulumi.output_type
class DataLakePipelineSnapshot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyRegion":
            suggest = "copy_region"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "expiresAt":
            suggest = "expires_at"
        elif key == "frequencyYype":
            suggest = "frequency_yype"
        elif key == "masterKey":
            suggest = "master_key"
        elif key == "mongodVersion":
            suggest = "mongod_version"
        elif key == "replicaSetName":
            suggest = "replica_set_name"
        elif key == "snapshotType":
            suggest = "snapshot_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakePipelineSnapshot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakePipelineSnapshot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakePipelineSnapshot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_region: Optional[str] = None,
                 created_at: Optional[str] = None,
                 expires_at: Optional[str] = None,
                 frequency_yype: Optional[str] = None,
                 id: Optional[str] = None,
                 master_key: Optional[str] = None,
                 mongod_version: Optional[str] = None,
                 policies: Optional[Sequence[str]] = None,
                 provider: Optional[str] = None,
                 replica_set_name: Optional[str] = None,
                 size: Optional[int] = None,
                 snapshot_type: Optional[str] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.
        :param str provider: Target cloud provider for this Data Lake Pipeline.
        :param str type: Type of ingestion source of this Data Lake Pipeline.
        """
        DataLakePipelineSnapshot._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            copy_region=copy_region,
            created_at=created_at,
            expires_at=expires_at,
            frequency_yype=frequency_yype,
            id=id,
            master_key=master_key,
            mongod_version=mongod_version,
            policies=policies,
            provider=provider,
            replica_set_name=replica_set_name,
            size=size,
            snapshot_type=snapshot_type,
            status=status,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             copy_region: Optional[str] = None,
             created_at: Optional[str] = None,
             expires_at: Optional[str] = None,
             frequency_yype: Optional[str] = None,
             id: Optional[str] = None,
             master_key: Optional[str] = None,
             mongod_version: Optional[str] = None,
             policies: Optional[Sequence[str]] = None,
             provider: Optional[str] = None,
             replica_set_name: Optional[str] = None,
             size: Optional[int] = None,
             snapshot_type: Optional[str] = None,
             status: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if copy_region is not None:
            _setter("copy_region", copy_region)
        if created_at is not None:
            _setter("created_at", created_at)
        if expires_at is not None:
            _setter("expires_at", expires_at)
        if frequency_yype is not None:
            _setter("frequency_yype", frequency_yype)
        if id is not None:
            _setter("id", id)
        if master_key is not None:
            _setter("master_key", master_key)
        if mongod_version is not None:
            _setter("mongod_version", mongod_version)
        if policies is not None:
            _setter("policies", policies)
        if provider is not None:
            _setter("provider", provider)
        if replica_set_name is not None:
            _setter("replica_set_name", replica_set_name)
        if size is not None:
            _setter("size", size)
        if snapshot_type is not None:
            _setter("snapshot_type", snapshot_type)
        if status is not None:
            _setter("status", status)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="copyRegion")
    def copy_region(self) -> Optional[str]:
        return pulumi.get(self, "copy_region")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[str]:
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter(name="frequencyYype")
    def frequency_yype(self) -> Optional[str]:
        return pulumi.get(self, "frequency_yype")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="masterKey")
    def master_key(self) -> Optional[str]:
        return pulumi.get(self, "master_key")

    @property
    @pulumi.getter(name="mongodVersion")
    def mongod_version(self) -> Optional[str]:
        return pulumi.get(self, "mongod_version")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        """
        Target cloud provider for this Data Lake Pipeline.
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> Optional[str]:
        return pulumi.get(self, "replica_set_name")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="snapshotType")
    def snapshot_type(self) -> Optional[str]:
        return pulumi.get(self, "snapshot_type")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DataLakePipelineSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"
        elif key == "collectionName":
            suggest = "collection_name"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "policyItemId":
            suggest = "policy_item_id"
        elif key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakePipelineSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakePipelineSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakePipelineSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_name: Optional[str] = None,
                 collection_name: Optional[str] = None,
                 database_name: Optional[str] = None,
                 policy_item_id: Optional[str] = None,
                 project_id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str cluster_name: Human-readable name that identifies the cluster.
        :param str collection_name: Human-readable name that identifies the collection.
        :param str database_name: Human-readable name that identifies the database.
        :param str project_id: The unique ID for the project to create a data lake pipeline.
        :param str type: Type of ingestion source of this Data Lake Pipeline.
        """
        DataLakePipelineSource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster_name=cluster_name,
            collection_name=collection_name,
            database_name=database_name,
            policy_item_id=policy_item_id,
            project_id=project_id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster_name: Optional[str] = None,
             collection_name: Optional[str] = None,
             database_name: Optional[str] = None,
             policy_item_id: Optional[str] = None,
             project_id: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cluster_name is not None:
            _setter("cluster_name", cluster_name)
        if collection_name is not None:
            _setter("collection_name", collection_name)
        if database_name is not None:
            _setter("database_name", database_name)
        if policy_item_id is not None:
            _setter("policy_item_id", policy_item_id)
        if project_id is not None:
            _setter("project_id", project_id)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        """
        Human-readable name that identifies the cluster.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[str]:
        """
        Human-readable name that identifies the collection.
        """
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        Human-readable name that identifies the database.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="policyItemId")
    def policy_item_id(self) -> Optional[str]:
        return pulumi.get(self, "policy_item_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        """
        The unique ID for the project to create a data lake pipeline.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DataLakePipelineTransformation(dict):
    def __init__(__self__, *,
                 field: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str type: Type of ingestion source of this Data Lake Pipeline.
        """
        DataLakePipelineTransformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field=field,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if field is not None:
            _setter("field", field)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def field(self) -> Optional[str]:
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DataLakeStorageDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxWildcardCollections":
            suggest = "max_wildcard_collections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakeStorageDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakeStorageDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakeStorageDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collections: Optional[Sequence['outputs.DataLakeStorageDatabaseCollection']] = None,
                 max_wildcard_collections: Optional[int] = None,
                 name: Optional[str] = None,
                 views: Optional[Sequence['outputs.DataLakeStorageDatabaseView']] = None):
        """
        :param str name: Name of the Atlas Data Lake.
        """
        DataLakeStorageDatabase._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            collections=collections,
            max_wildcard_collections=max_wildcard_collections,
            name=name,
            views=views,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             collections: Optional[Sequence['outputs.DataLakeStorageDatabaseCollection']] = None,
             max_wildcard_collections: Optional[int] = None,
             name: Optional[str] = None,
             views: Optional[Sequence['outputs.DataLakeStorageDatabaseView']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if collections is not None:
            _setter("collections", collections)
        if max_wildcard_collections is not None:
            _setter("max_wildcard_collections", max_wildcard_collections)
        if name is not None:
            _setter("name", name)
        if views is not None:
            _setter("views", views)

    @property
    @pulumi.getter
    def collections(self) -> Optional[Sequence['outputs.DataLakeStorageDatabaseCollection']]:
        return pulumi.get(self, "collections")

    @property
    @pulumi.getter(name="maxWildcardCollections")
    def max_wildcard_collections(self) -> Optional[int]:
        return pulumi.get(self, "max_wildcard_collections")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Atlas Data Lake.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def views(self) -> Optional[Sequence['outputs.DataLakeStorageDatabaseView']]:
        return pulumi.get(self, "views")


@pulumi.output_type
class DataLakeStorageDatabaseCollection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSources":
            suggest = "data_sources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakeStorageDatabaseCollection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakeStorageDatabaseCollection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakeStorageDatabaseCollection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_sources: Optional[Sequence['outputs.DataLakeStorageDatabaseCollectionDataSource']] = None,
                 name: Optional[str] = None):
        """
        :param str name: Name of the Atlas Data Lake.
        """
        DataLakeStorageDatabaseCollection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_sources=data_sources,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_sources: Optional[Sequence['outputs.DataLakeStorageDatabaseCollectionDataSource']] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if data_sources is not None:
            _setter("data_sources", data_sources)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Optional[Sequence['outputs.DataLakeStorageDatabaseCollectionDataSource']]:
        return pulumi.get(self, "data_sources")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Atlas Data Lake.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DataLakeStorageDatabaseCollectionDataSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultFormat":
            suggest = "default_format"
        elif key == "storeName":
            suggest = "store_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakeStorageDatabaseCollectionDataSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakeStorageDatabaseCollectionDataSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakeStorageDatabaseCollectionDataSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_format: Optional[str] = None,
                 path: Optional[str] = None,
                 store_name: Optional[str] = None):
        DataLakeStorageDatabaseCollectionDataSource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_format=default_format,
            path=path,
            store_name=store_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_format: Optional[str] = None,
             path: Optional[str] = None,
             store_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if default_format is not None:
            _setter("default_format", default_format)
        if path is not None:
            _setter("path", path)
        if store_name is not None:
            _setter("store_name", store_name)

    @property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> Optional[str]:
        return pulumi.get(self, "default_format")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="storeName")
    def store_name(self) -> Optional[str]:
        return pulumi.get(self, "store_name")


@pulumi.output_type
class DataLakeStorageDatabaseView(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 pipeline: Optional[str] = None,
                 source: Optional[str] = None):
        """
        :param str name: Name of the Atlas Data Lake.
        """
        DataLakeStorageDatabaseView._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            pipeline=pipeline,
            source=source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             pipeline: Optional[str] = None,
             source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)
        if pipeline is not None:
            _setter("pipeline", pipeline)
        if source is not None:
            _setter("source", source)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Atlas Data Lake.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def pipeline(self) -> Optional[str]:
        return pulumi.get(self, "pipeline")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")


@pulumi.output_type
class DataLakeStorageStore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalStorageClasses":
            suggest = "additional_storage_classes"
        elif key == "includeTags":
            suggest = "include_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakeStorageStore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakeStorageStore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakeStorageStore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_storage_classes: Optional[Sequence[str]] = None,
                 bucket: Optional[str] = None,
                 delimiter: Optional[str] = None,
                 include_tags: Optional[bool] = None,
                 name: Optional[str] = None,
                 prefix: Optional[str] = None,
                 provider: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str name: Name of the Atlas Data Lake.
        """
        DataLakeStorageStore._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            additional_storage_classes=additional_storage_classes,
            bucket=bucket,
            delimiter=delimiter,
            include_tags=include_tags,
            name=name,
            prefix=prefix,
            provider=provider,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             additional_storage_classes: Optional[Sequence[str]] = None,
             bucket: Optional[str] = None,
             delimiter: Optional[str] = None,
             include_tags: Optional[bool] = None,
             name: Optional[str] = None,
             prefix: Optional[str] = None,
             provider: Optional[str] = None,
             region: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if additional_storage_classes is not None:
            _setter("additional_storage_classes", additional_storage_classes)
        if bucket is not None:
            _setter("bucket", bucket)
        if delimiter is not None:
            _setter("delimiter", delimiter)
        if include_tags is not None:
            _setter("include_tags", include_tags)
        if name is not None:
            _setter("name", name)
        if prefix is not None:
            _setter("prefix", prefix)
        if provider is not None:
            _setter("provider", provider)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter(name="additionalStorageClasses")
    def additional_storage_classes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "additional_storage_classes")

    @property
    @pulumi.getter
    def bucket(self) -> Optional[str]:
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[str]:
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="includeTags")
    def include_tags(self) -> Optional[bool]:
        return pulumi.get(self, "include_tags")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Atlas Data Lake.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class DatabaseUserLabel(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        DatabaseUserLabel._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DatabaseUserRole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "roleName":
            suggest = "role_name"
        elif key == "collectionName":
            suggest = "collection_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseUserRole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseUserRole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseUserRole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 role_name: str,
                 collection_name: Optional[str] = None):
        """
        :param str database_name: Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.
        :param str role_name: Name of the role to grant. See [Create a Database User](https://docs.atlas.mongodb.com/reference/api/database-users-create-a-user/) `roles.roleName` for valid values and restrictions.
        :param str collection_name: Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        """
        DatabaseUserRole._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            role_name=role_name,
            collection_name=collection_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: str,
             role_name: str,
             collection_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database_name", database_name)
        _setter("role_name", role_name)
        if collection_name is not None:
            _setter("collection_name", collection_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        """
        Name of the role to grant. See [Create a Database User](https://docs.atlas.mongodb.com/reference/api/database-users-create-a-user/) `roles.roleName` for valid values and restrictions.
        """
        return pulumi.get(self, "role_name")

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[str]:
        """
        Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        """
        return pulumi.get(self, "collection_name")


@pulumi.output_type
class DatabaseUserScope(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: Name of the cluster or Atlas Data Lake that the user has access to.
        :param str type: Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
        DatabaseUserScope._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the cluster or Atlas Data Lake that the user has access to.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class EncryptionAtRestAwsKmsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKeyId":
            suggest = "access_key_id"
        elif key == "customerMasterKeyId":
            suggest = "customer_master_key_id"
        elif key == "roleId":
            suggest = "role_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionAtRestAwsKmsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionAtRestAwsKmsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionAtRestAwsKmsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key_id: Optional[str] = None,
                 customer_master_key_id: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 region: Optional[str] = None,
                 role_id: Optional[str] = None,
                 secret_access_key: Optional[str] = None):
        """
        :param str customer_master_key_id: The AWS customer master key used to encrypt and decrypt the MongoDB master keys.
        :param bool enabled: Specifies whether Encryption at Rest is enabled for an Atlas project, To disable Encryption at Rest, pass only this parameter with a value of false, When you disable Encryption at Rest, Atlas also removes the configuration details.
        :param str region: The AWS region in which the AWS customer master key exists: CA_CENTRAL_1, US_EAST_1, US_EAST_2, US_WEST_1, US_WEST_2, SA_EAST_1
        :param str role_id: ID of an AWS IAM role authorized to manage an AWS customer master key. To find the ID for an existing IAM role check the `role_id` attribute of the `CloudProviderAccess` resource.
        """
        EncryptionAtRestAwsKmsConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_key_id=access_key_id,
            customer_master_key_id=customer_master_key_id,
            enabled=enabled,
            region=region,
            role_id=role_id,
            secret_access_key=secret_access_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_key_id: Optional[str] = None,
             customer_master_key_id: Optional[str] = None,
             enabled: Optional[bool] = None,
             region: Optional[str] = None,
             role_id: Optional[str] = None,
             secret_access_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if access_key_id is not None:
            _setter("access_key_id", access_key_id)
        if customer_master_key_id is not None:
            _setter("customer_master_key_id", customer_master_key_id)
        if enabled is not None:
            _setter("enabled", enabled)
        if region is not None:
            _setter("region", region)
        if role_id is not None:
            _setter("role_id", role_id)
        if secret_access_key is not None:
            _setter("secret_access_key", secret_access_key)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[str]:
        return pulumi.get(self, "access_key_id")

    @property
    @pulumi.getter(name="customerMasterKeyId")
    def customer_master_key_id(self) -> Optional[str]:
        """
        The AWS customer master key used to encrypt and decrypt the MongoDB master keys.
        """
        return pulumi.get(self, "customer_master_key_id")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Specifies whether Encryption at Rest is enabled for an Atlas project, To disable Encryption at Rest, pass only this parameter with a value of false, When you disable Encryption at Rest, Atlas also removes the configuration details.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The AWS region in which the AWS customer master key exists: CA_CENTRAL_1, US_EAST_1, US_EAST_2, US_WEST_1, US_WEST_2, SA_EAST_1
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[str]:
        """
        ID of an AWS IAM role authorized to manage an AWS customer master key. To find the ID for an existing IAM role check the `role_id` attribute of the `CloudProviderAccess` resource.
        """
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[str]:
        return pulumi.get(self, "secret_access_key")


@pulumi.output_type
class EncryptionAtRestAzureKeyVaultConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureEnvironment":
            suggest = "azure_environment"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "keyIdentifier":
            suggest = "key_identifier"
        elif key == "keyVaultName":
            suggest = "key_vault_name"
        elif key == "resourceGroupName":
            suggest = "resource_group_name"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionAtRestAzureKeyVaultConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionAtRestAzureKeyVaultConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionAtRestAzureKeyVaultConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_environment: Optional[str] = None,
                 client_id: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 key_identifier: Optional[str] = None,
                 key_vault_name: Optional[str] = None,
                 resource_group_name: Optional[str] = None,
                 secret: Optional[str] = None,
                 subscription_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str azure_environment: The Azure environment where the Azure account credentials reside. Valid values are the following: AZURE, AZURE_CHINA, AZURE_GERMANY
        :param str client_id: The client ID, also known as the application ID, for an Azure application associated with the Azure AD tenant.
        :param bool enabled: Specifies whether Encryption at Rest is enabled for an Atlas project. To disable Encryption at Rest, pass only this parameter with a value of false. When you disable Encryption at Rest, Atlas also removes the configuration details.
        :param str key_identifier: The unique identifier of a key in an Azure Key Vault.
        :param str key_vault_name: The name of an Azure Key Vault containing your key.
        :param str resource_group_name: The name of the Azure Resource group that contains an Azure Key Vault.
        :param str secret: The secret associated with the Azure Key Vault specified by azureKeyVault.tenantID.
        :param str subscription_id: The unique identifier associated with an Azure subscription.
        :param str tenant_id: The unique identifier for an Azure AD tenant within an Azure subscription.
        """
        EncryptionAtRestAzureKeyVaultConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            azure_environment=azure_environment,
            client_id=client_id,
            enabled=enabled,
            key_identifier=key_identifier,
            key_vault_name=key_vault_name,
            resource_group_name=resource_group_name,
            secret=secret,
            subscription_id=subscription_id,
            tenant_id=tenant_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             azure_environment: Optional[str] = None,
             client_id: Optional[str] = None,
             enabled: Optional[bool] = None,
             key_identifier: Optional[str] = None,
             key_vault_name: Optional[str] = None,
             resource_group_name: Optional[str] = None,
             secret: Optional[str] = None,
             subscription_id: Optional[str] = None,
             tenant_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if azure_environment is not None:
            _setter("azure_environment", azure_environment)
        if client_id is not None:
            _setter("client_id", client_id)
        if enabled is not None:
            _setter("enabled", enabled)
        if key_identifier is not None:
            _setter("key_identifier", key_identifier)
        if key_vault_name is not None:
            _setter("key_vault_name", key_vault_name)
        if resource_group_name is not None:
            _setter("resource_group_name", resource_group_name)
        if secret is not None:
            _setter("secret", secret)
        if subscription_id is not None:
            _setter("subscription_id", subscription_id)
        if tenant_id is not None:
            _setter("tenant_id", tenant_id)

    @property
    @pulumi.getter(name="azureEnvironment")
    def azure_environment(self) -> Optional[str]:
        """
        The Azure environment where the Azure account credentials reside. Valid values are the following: AZURE, AZURE_CHINA, AZURE_GERMANY
        """
        return pulumi.get(self, "azure_environment")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The client ID, also known as the application ID, for an Azure application associated with the Azure AD tenant.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Specifies whether Encryption at Rest is enabled for an Atlas project. To disable Encryption at Rest, pass only this parameter with a value of false. When you disable Encryption at Rest, Atlas also removes the configuration details.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="keyIdentifier")
    def key_identifier(self) -> Optional[str]:
        """
        The unique identifier of a key in an Azure Key Vault.
        """
        return pulumi.get(self, "key_identifier")

    @property
    @pulumi.getter(name="keyVaultName")
    def key_vault_name(self) -> Optional[str]:
        """
        The name of an Azure Key Vault containing your key.
        """
        return pulumi.get(self, "key_vault_name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[str]:
        """
        The name of the Azure Resource group that contains an Azure Key Vault.
        """
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        The secret associated with the Azure Key Vault specified by azureKeyVault.tenantID.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[str]:
        """
        The unique identifier associated with an Azure subscription.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The unique identifier for an Azure AD tenant within an Azure subscription.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class EncryptionAtRestGoogleCloudKmsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVersionResourceId":
            suggest = "key_version_resource_id"
        elif key == "serviceAccountKey":
            suggest = "service_account_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionAtRestGoogleCloudKmsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionAtRestGoogleCloudKmsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionAtRestGoogleCloudKmsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 key_version_resource_id: Optional[str] = None,
                 service_account_key: Optional[str] = None):
        """
        :param bool enabled: Specifies whether Encryption at Rest is enabled for an Atlas project. To disable Encryption at Rest, pass only this parameter with a value of false. When you disable Encryption at Rest, Atlas also removes the configuration details.
        :param str key_version_resource_id: The Key Version Resource ID from your GCP account.
        :param str service_account_key: String-formatted JSON object containing GCP KMS credentials from your GCP account.
        """
        EncryptionAtRestGoogleCloudKmsConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            key_version_resource_id=key_version_resource_id,
            service_account_key=service_account_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             key_version_resource_id: Optional[str] = None,
             service_account_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enabled is not None:
            _setter("enabled", enabled)
        if key_version_resource_id is not None:
            _setter("key_version_resource_id", key_version_resource_id)
        if service_account_key is not None:
            _setter("service_account_key", service_account_key)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Specifies whether Encryption at Rest is enabled for an Atlas project. To disable Encryption at Rest, pass only this parameter with a value of false. When you disable Encryption at Rest, Atlas also removes the configuration details.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="keyVersionResourceId")
    def key_version_resource_id(self) -> Optional[str]:
        """
        The Key Version Resource ID from your GCP account.
        """
        return pulumi.get(self, "key_version_resource_id")

    @property
    @pulumi.getter(name="serviceAccountKey")
    def service_account_key(self) -> Optional[str]:
        """
        String-formatted JSON object containing GCP KMS credentials from your GCP account.
        """
        return pulumi.get(self, "service_account_key")


@pulumi.output_type
class EventTriggerEventProcessors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsEventbridge":
            suggest = "aws_eventbridge"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventTriggerEventProcessors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventTriggerEventProcessors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventTriggerEventProcessors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_eventbridge: Optional['outputs.EventTriggerEventProcessorsAwsEventbridge'] = None):
        EventTriggerEventProcessors._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aws_eventbridge=aws_eventbridge,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aws_eventbridge: Optional['outputs.EventTriggerEventProcessorsAwsEventbridge'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if aws_eventbridge is not None:
            _setter("aws_eventbridge", aws_eventbridge)

    @property
    @pulumi.getter(name="awsEventbridge")
    def aws_eventbridge(self) -> Optional['outputs.EventTriggerEventProcessorsAwsEventbridge']:
        return pulumi.get(self, "aws_eventbridge")


@pulumi.output_type
class EventTriggerEventProcessorsAwsEventbridge(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configAccountId":
            suggest = "config_account_id"
        elif key == "configRegion":
            suggest = "config_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventTriggerEventProcessorsAwsEventbridge. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventTriggerEventProcessorsAwsEventbridge.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventTriggerEventProcessorsAwsEventbridge.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_account_id: Optional[str] = None,
                 config_region: Optional[str] = None):
        EventTriggerEventProcessorsAwsEventbridge._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_account_id=config_account_id,
            config_region=config_region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_account_id: Optional[str] = None,
             config_region: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if config_account_id is not None:
            _setter("config_account_id", config_account_id)
        if config_region is not None:
            _setter("config_region", config_region)

    @property
    @pulumi.getter(name="configAccountId")
    def config_account_id(self) -> Optional[str]:
        return pulumi.get(self, "config_account_id")

    @property
    @pulumi.getter(name="configRegion")
    def config_region(self) -> Optional[str]:
        return pulumi.get(self, "config_region")


@pulumi.output_type
class FederatedDatabaseInstanceCloudProviderConfig(dict):
    def __init__(__self__, *,
                 aws: 'outputs.FederatedDatabaseInstanceCloudProviderConfigAws'):
        FederatedDatabaseInstanceCloudProviderConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aws=aws,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aws: 'outputs.FederatedDatabaseInstanceCloudProviderConfigAws',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aws", aws)

    @property
    @pulumi.getter
    def aws(self) -> 'outputs.FederatedDatabaseInstanceCloudProviderConfigAws':
        return pulumi.get(self, "aws")


@pulumi.output_type
class FederatedDatabaseInstanceCloudProviderConfigAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleId":
            suggest = "role_id"
        elif key == "testS3Bucket":
            suggest = "test_s3_bucket"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "iamAssumedRoleArn":
            suggest = "iam_assumed_role_arn"
        elif key == "iamUserArn":
            suggest = "iam_user_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedDatabaseInstanceCloudProviderConfigAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedDatabaseInstanceCloudProviderConfigAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedDatabaseInstanceCloudProviderConfigAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_id: str,
                 test_s3_bucket: str,
                 external_id: Optional[str] = None,
                 iam_assumed_role_arn: Optional[str] = None,
                 iam_user_arn: Optional[str] = None):
        """
        :param str role_id: Unique identifier of the role that the Federated Instance can use to access the data stores. If necessary, use the Atlas [UI](https://docs.atlas.mongodb.com/security/manage-iam-roles/) or [API](https://docs.atlas.mongodb.com/reference/api/cloud-provider-access-get-roles/) to retrieve the role ID. You must also specify the `test_s3_bucket`.
        :param str test_s3_bucket: Name of the S3 data bucket that the provided role ID is authorized to access. You must also specify the `role_id`.
               ### `data_process_region` - (Optional) The cloud provider region to which the Federated Instance routes client connections for data processing.
        :param str external_id: Unique identifier associated with the IAM Role that the Federated Database Instance assumes when accessing the data stores.
        :param str iam_assumed_role_arn: Amazon Resource Name (ARN) of the IAM Role that the Federated Database Instance assumes when accessing S3 Bucket data stores. The IAM Role must support the following actions against each S3 bucket:
               * `s3:GetObject`
               * `s3:ListBucket`
               * `s3:GetObjectVersion`
        :param str iam_user_arn: Amazon Resource Name (ARN) of the user that the Federated Database Instance assumes when accessing S3 Bucket data stores.
        """
        FederatedDatabaseInstanceCloudProviderConfigAws._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_id=role_id,
            test_s3_bucket=test_s3_bucket,
            external_id=external_id,
            iam_assumed_role_arn=iam_assumed_role_arn,
            iam_user_arn=iam_user_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_id: str,
             test_s3_bucket: str,
             external_id: Optional[str] = None,
             iam_assumed_role_arn: Optional[str] = None,
             iam_user_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("role_id", role_id)
        _setter("test_s3_bucket", test_s3_bucket)
        if external_id is not None:
            _setter("external_id", external_id)
        if iam_assumed_role_arn is not None:
            _setter("iam_assumed_role_arn", iam_assumed_role_arn)
        if iam_user_arn is not None:
            _setter("iam_user_arn", iam_user_arn)

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> str:
        """
        Unique identifier of the role that the Federated Instance can use to access the data stores. If necessary, use the Atlas [UI](https://docs.atlas.mongodb.com/security/manage-iam-roles/) or [API](https://docs.atlas.mongodb.com/reference/api/cloud-provider-access-get-roles/) to retrieve the role ID. You must also specify the `test_s3_bucket`.
        """
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="testS3Bucket")
    def test_s3_bucket(self) -> str:
        """
        Name of the S3 data bucket that the provided role ID is authorized to access. You must also specify the `role_id`.
        ### `data_process_region` - (Optional) The cloud provider region to which the Federated Instance routes client connections for data processing.
        """
        return pulumi.get(self, "test_s3_bucket")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        """
        Unique identifier associated with the IAM Role that the Federated Database Instance assumes when accessing the data stores.
        """
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="iamAssumedRoleArn")
    def iam_assumed_role_arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN) of the IAM Role that the Federated Database Instance assumes when accessing S3 Bucket data stores. The IAM Role must support the following actions against each S3 bucket:
        * `s3:GetObject`
        * `s3:ListBucket`
        * `s3:GetObjectVersion`
        """
        return pulumi.get(self, "iam_assumed_role_arn")

    @property
    @pulumi.getter(name="iamUserArn")
    def iam_user_arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN) of the user that the Federated Database Instance assumes when accessing S3 Bucket data stores.
        """
        return pulumi.get(self, "iam_user_arn")


@pulumi.output_type
class FederatedDatabaseInstanceDataProcessRegion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudProvider":
            suggest = "cloud_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedDatabaseInstanceDataProcessRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedDatabaseInstanceDataProcessRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedDatabaseInstanceDataProcessRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_provider: str,
                 region: str):
        """
        :param str cloud_provider: Name of the cloud service provider. Atlas Federated Database only supports AWS.
        :param str region: Name of the region to which the Federanted Instnace routes client connections for data processing. See the [documention](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation/operation/createFederatedDatabase) for the available region.
        """
        FederatedDatabaseInstanceDataProcessRegion._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_provider=cloud_provider,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_provider: str,
             region: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cloud_provider", cloud_provider)
        _setter("region", region)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        Name of the cloud service provider. Atlas Federated Database only supports AWS.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Name of the region to which the Federanted Instnace routes client connections for data processing. See the [documention](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation/operation/createFederatedDatabase) for the available region.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class FederatedDatabaseInstanceStorageDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxWildcardCollections":
            suggest = "max_wildcard_collections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedDatabaseInstanceStorageDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedDatabaseInstanceStorageDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedDatabaseInstanceStorageDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collections: Optional[Sequence['outputs.FederatedDatabaseInstanceStorageDatabaseCollection']] = None,
                 max_wildcard_collections: Optional[int] = None,
                 name: Optional[str] = None,
                 views: Optional[Sequence['outputs.FederatedDatabaseInstanceStorageDatabaseView']] = None):
        """
        :param str name: Name of the Atlas Federated Database Instance.
               ### `cloud_provider_config` - (Optional) Cloud provider linked to this data federated instance.
               #### `aws` - (Required) AWS provider of the cloud service where the Federated Database Instance can access the S3 Bucket. Note this parameter is only required if using `cloud_provider_config` since AWS is currently the only supported Cloud vendor on this feature at this time.
        """
        FederatedDatabaseInstanceStorageDatabase._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            collections=collections,
            max_wildcard_collections=max_wildcard_collections,
            name=name,
            views=views,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             collections: Optional[Sequence['outputs.FederatedDatabaseInstanceStorageDatabaseCollection']] = None,
             max_wildcard_collections: Optional[int] = None,
             name: Optional[str] = None,
             views: Optional[Sequence['outputs.FederatedDatabaseInstanceStorageDatabaseView']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if collections is not None:
            _setter("collections", collections)
        if max_wildcard_collections is not None:
            _setter("max_wildcard_collections", max_wildcard_collections)
        if name is not None:
            _setter("name", name)
        if views is not None:
            _setter("views", views)

    @property
    @pulumi.getter
    def collections(self) -> Optional[Sequence['outputs.FederatedDatabaseInstanceStorageDatabaseCollection']]:
        return pulumi.get(self, "collections")

    @property
    @pulumi.getter(name="maxWildcardCollections")
    def max_wildcard_collections(self) -> Optional[int]:
        return pulumi.get(self, "max_wildcard_collections")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Atlas Federated Database Instance.
        ### `cloud_provider_config` - (Optional) Cloud provider linked to this data federated instance.
        #### `aws` - (Required) AWS provider of the cloud service where the Federated Database Instance can access the S3 Bucket. Note this parameter is only required if using `cloud_provider_config` since AWS is currently the only supported Cloud vendor on this feature at this time.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def views(self) -> Optional[Sequence['outputs.FederatedDatabaseInstanceStorageDatabaseView']]:
        return pulumi.get(self, "views")


@pulumi.output_type
class FederatedDatabaseInstanceStorageDatabaseCollection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSources":
            suggest = "data_sources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedDatabaseInstanceStorageDatabaseCollection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedDatabaseInstanceStorageDatabaseCollection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedDatabaseInstanceStorageDatabaseCollection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_sources: Optional[Sequence['outputs.FederatedDatabaseInstanceStorageDatabaseCollectionDataSource']] = None,
                 name: Optional[str] = None):
        """
        :param str name: Name of the Atlas Federated Database Instance.
               ### `cloud_provider_config` - (Optional) Cloud provider linked to this data federated instance.
               #### `aws` - (Required) AWS provider of the cloud service where the Federated Database Instance can access the S3 Bucket. Note this parameter is only required if using `cloud_provider_config` since AWS is currently the only supported Cloud vendor on this feature at this time.
        """
        FederatedDatabaseInstanceStorageDatabaseCollection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_sources=data_sources,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_sources: Optional[Sequence['outputs.FederatedDatabaseInstanceStorageDatabaseCollectionDataSource']] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if data_sources is not None:
            _setter("data_sources", data_sources)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Optional[Sequence['outputs.FederatedDatabaseInstanceStorageDatabaseCollectionDataSource']]:
        return pulumi.get(self, "data_sources")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Atlas Federated Database Instance.
        ### `cloud_provider_config` - (Optional) Cloud provider linked to this data federated instance.
        #### `aws` - (Required) AWS provider of the cloud service where the Federated Database Instance can access the S3 Bucket. Note this parameter is only required if using `cloud_provider_config` since AWS is currently the only supported Cloud vendor on this feature at this time.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class FederatedDatabaseInstanceStorageDatabaseCollectionDataSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowInsecure":
            suggest = "allow_insecure"
        elif key == "collectionRegex":
            suggest = "collection_regex"
        elif key == "databaseRegex":
            suggest = "database_regex"
        elif key == "datasetName":
            suggest = "dataset_name"
        elif key == "defaultFormat":
            suggest = "default_format"
        elif key == "provenanceFieldName":
            suggest = "provenance_field_name"
        elif key == "storeName":
            suggest = "store_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedDatabaseInstanceStorageDatabaseCollectionDataSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedDatabaseInstanceStorageDatabaseCollectionDataSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedDatabaseInstanceStorageDatabaseCollectionDataSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_insecure: Optional[bool] = None,
                 collection: Optional[str] = None,
                 collection_regex: Optional[str] = None,
                 database: Optional[str] = None,
                 database_regex: Optional[str] = None,
                 dataset_name: Optional[str] = None,
                 default_format: Optional[str] = None,
                 path: Optional[str] = None,
                 provenance_field_name: Optional[str] = None,
                 store_name: Optional[str] = None,
                 urls: Optional[Sequence[str]] = None):
        FederatedDatabaseInstanceStorageDatabaseCollectionDataSource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_insecure=allow_insecure,
            collection=collection,
            collection_regex=collection_regex,
            database=database,
            database_regex=database_regex,
            dataset_name=dataset_name,
            default_format=default_format,
            path=path,
            provenance_field_name=provenance_field_name,
            store_name=store_name,
            urls=urls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_insecure: Optional[bool] = None,
             collection: Optional[str] = None,
             collection_regex: Optional[str] = None,
             database: Optional[str] = None,
             database_regex: Optional[str] = None,
             dataset_name: Optional[str] = None,
             default_format: Optional[str] = None,
             path: Optional[str] = None,
             provenance_field_name: Optional[str] = None,
             store_name: Optional[str] = None,
             urls: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if allow_insecure is not None:
            _setter("allow_insecure", allow_insecure)
        if collection is not None:
            _setter("collection", collection)
        if collection_regex is not None:
            _setter("collection_regex", collection_regex)
        if database is not None:
            _setter("database", database)
        if database_regex is not None:
            _setter("database_regex", database_regex)
        if dataset_name is not None:
            _setter("dataset_name", dataset_name)
        if default_format is not None:
            _setter("default_format", default_format)
        if path is not None:
            _setter("path", path)
        if provenance_field_name is not None:
            _setter("provenance_field_name", provenance_field_name)
        if store_name is not None:
            _setter("store_name", store_name)
        if urls is not None:
            _setter("urls", urls)

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> Optional[bool]:
        return pulumi.get(self, "allow_insecure")

    @property
    @pulumi.getter
    def collection(self) -> Optional[str]:
        return pulumi.get(self, "collection")

    @property
    @pulumi.getter(name="collectionRegex")
    def collection_regex(self) -> Optional[str]:
        return pulumi.get(self, "collection_regex")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="databaseRegex")
    def database_regex(self) -> Optional[str]:
        return pulumi.get(self, "database_regex")

    @property
    @pulumi.getter(name="datasetName")
    def dataset_name(self) -> Optional[str]:
        return pulumi.get(self, "dataset_name")

    @property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> Optional[str]:
        return pulumi.get(self, "default_format")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="provenanceFieldName")
    def provenance_field_name(self) -> Optional[str]:
        return pulumi.get(self, "provenance_field_name")

    @property
    @pulumi.getter(name="storeName")
    def store_name(self) -> Optional[str]:
        return pulumi.get(self, "store_name")

    @property
    @pulumi.getter
    def urls(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "urls")


@pulumi.output_type
class FederatedDatabaseInstanceStorageDatabaseView(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 pipeline: Optional[str] = None,
                 source: Optional[str] = None):
        """
        :param str name: Name of the Atlas Federated Database Instance.
               ### `cloud_provider_config` - (Optional) Cloud provider linked to this data federated instance.
               #### `aws` - (Required) AWS provider of the cloud service where the Federated Database Instance can access the S3 Bucket. Note this parameter is only required if using `cloud_provider_config` since AWS is currently the only supported Cloud vendor on this feature at this time.
        """
        FederatedDatabaseInstanceStorageDatabaseView._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            pipeline=pipeline,
            source=source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             pipeline: Optional[str] = None,
             source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)
        if pipeline is not None:
            _setter("pipeline", pipeline)
        if source is not None:
            _setter("source", source)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Atlas Federated Database Instance.
        ### `cloud_provider_config` - (Optional) Cloud provider linked to this data federated instance.
        #### `aws` - (Required) AWS provider of the cloud service where the Federated Database Instance can access the S3 Bucket. Note this parameter is only required if using `cloud_provider_config` since AWS is currently the only supported Cloud vendor on this feature at this time.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def pipeline(self) -> Optional[str]:
        return pulumi.get(self, "pipeline")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")


@pulumi.output_type
class FederatedDatabaseInstanceStorageStore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalStorageClasses":
            suggest = "additional_storage_classes"
        elif key == "allowInsecure":
            suggest = "allow_insecure"
        elif key == "clusterId":
            suggest = "cluster_id"
        elif key == "clusterName":
            suggest = "cluster_name"
        elif key == "defaultFormat":
            suggest = "default_format"
        elif key == "includeTags":
            suggest = "include_tags"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "readPreference":
            suggest = "read_preference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedDatabaseInstanceStorageStore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedDatabaseInstanceStorageStore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedDatabaseInstanceStorageStore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_storage_classes: Optional[Sequence[str]] = None,
                 allow_insecure: Optional[bool] = None,
                 bucket: Optional[str] = None,
                 cluster_id: Optional[str] = None,
                 cluster_name: Optional[str] = None,
                 default_format: Optional[str] = None,
                 delimiter: Optional[str] = None,
                 include_tags: Optional[bool] = None,
                 name: Optional[str] = None,
                 prefix: Optional[str] = None,
                 project_id: Optional[str] = None,
                 provider: Optional[str] = None,
                 public: Optional[str] = None,
                 read_preference: Optional['outputs.FederatedDatabaseInstanceStorageStoreReadPreference'] = None,
                 region: Optional[str] = None,
                 urls: Optional[Sequence[str]] = None):
        """
        :param str name: Name of the Atlas Federated Database Instance.
               ### `cloud_provider_config` - (Optional) Cloud provider linked to this data federated instance.
               #### `aws` - (Required) AWS provider of the cloud service where the Federated Database Instance can access the S3 Bucket. Note this parameter is only required if using `cloud_provider_config` since AWS is currently the only supported Cloud vendor on this feature at this time.
        :param str project_id: The unique ID for the project to create a Federated Database Instance.
        :param str region: Name of the region to which the Federanted Instnace routes client connections for data processing. See the [documention](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation/operation/createFederatedDatabase) for the available region.
        """
        FederatedDatabaseInstanceStorageStore._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            additional_storage_classes=additional_storage_classes,
            allow_insecure=allow_insecure,
            bucket=bucket,
            cluster_id=cluster_id,
            cluster_name=cluster_name,
            default_format=default_format,
            delimiter=delimiter,
            include_tags=include_tags,
            name=name,
            prefix=prefix,
            project_id=project_id,
            provider=provider,
            public=public,
            read_preference=read_preference,
            region=region,
            urls=urls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             additional_storage_classes: Optional[Sequence[str]] = None,
             allow_insecure: Optional[bool] = None,
             bucket: Optional[str] = None,
             cluster_id: Optional[str] = None,
             cluster_name: Optional[str] = None,
             default_format: Optional[str] = None,
             delimiter: Optional[str] = None,
             include_tags: Optional[bool] = None,
             name: Optional[str] = None,
             prefix: Optional[str] = None,
             project_id: Optional[str] = None,
             provider: Optional[str] = None,
             public: Optional[str] = None,
             read_preference: Optional['outputs.FederatedDatabaseInstanceStorageStoreReadPreference'] = None,
             region: Optional[str] = None,
             urls: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if additional_storage_classes is not None:
            _setter("additional_storage_classes", additional_storage_classes)
        if allow_insecure is not None:
            _setter("allow_insecure", allow_insecure)
        if bucket is not None:
            _setter("bucket", bucket)
        if cluster_id is not None:
            _setter("cluster_id", cluster_id)
        if cluster_name is not None:
            _setter("cluster_name", cluster_name)
        if default_format is not None:
            _setter("default_format", default_format)
        if delimiter is not None:
            _setter("delimiter", delimiter)
        if include_tags is not None:
            _setter("include_tags", include_tags)
        if name is not None:
            _setter("name", name)
        if prefix is not None:
            _setter("prefix", prefix)
        if project_id is not None:
            _setter("project_id", project_id)
        if provider is not None:
            _setter("provider", provider)
        if public is not None:
            _setter("public", public)
        if read_preference is not None:
            _setter("read_preference", read_preference)
        if region is not None:
            _setter("region", region)
        if urls is not None:
            _setter("urls", urls)

    @property
    @pulumi.getter(name="additionalStorageClasses")
    def additional_storage_classes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "additional_storage_classes")

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> Optional[bool]:
        return pulumi.get(self, "allow_insecure")

    @property
    @pulumi.getter
    def bucket(self) -> Optional[str]:
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[str]:
        warnings.warn("""this parameter is deprecated and will be removed by September 2024""", DeprecationWarning)
        pulumi.log.warn("""cluster_id is deprecated: this parameter is deprecated and will be removed by September 2024""")

        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> Optional[str]:
        return pulumi.get(self, "default_format")

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[str]:
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="includeTags")
    def include_tags(self) -> Optional[bool]:
        return pulumi.get(self, "include_tags")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Atlas Federated Database Instance.
        ### `cloud_provider_config` - (Optional) Cloud provider linked to this data federated instance.
        #### `aws` - (Required) AWS provider of the cloud service where the Federated Database Instance can access the S3 Bucket. Note this parameter is only required if using `cloud_provider_config` since AWS is currently the only supported Cloud vendor on this feature at this time.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        """
        The unique ID for the project to create a Federated Database Instance.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def public(self) -> Optional[str]:
        return pulumi.get(self, "public")

    @property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> Optional['outputs.FederatedDatabaseInstanceStorageStoreReadPreference']:
        return pulumi.get(self, "read_preference")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Name of the region to which the Federanted Instnace routes client connections for data processing. See the [documention](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation/operation/createFederatedDatabase) for the available region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def urls(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "urls")


@pulumi.output_type
class FederatedDatabaseInstanceStorageStoreReadPreference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxStalenessSeconds":
            suggest = "max_staleness_seconds"
        elif key == "tagSets":
            suggest = "tag_sets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedDatabaseInstanceStorageStoreReadPreference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedDatabaseInstanceStorageStoreReadPreference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedDatabaseInstanceStorageStoreReadPreference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_staleness_seconds: Optional[int] = None,
                 mode: Optional[str] = None,
                 tag_sets: Optional[Sequence['outputs.FederatedDatabaseInstanceStorageStoreReadPreferenceTagSet']] = None):
        FederatedDatabaseInstanceStorageStoreReadPreference._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_staleness_seconds=max_staleness_seconds,
            mode=mode,
            tag_sets=tag_sets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_staleness_seconds: Optional[int] = None,
             mode: Optional[str] = None,
             tag_sets: Optional[Sequence['outputs.FederatedDatabaseInstanceStorageStoreReadPreferenceTagSet']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max_staleness_seconds is not None:
            _setter("max_staleness_seconds", max_staleness_seconds)
        if mode is not None:
            _setter("mode", mode)
        if tag_sets is not None:
            _setter("tag_sets", tag_sets)

    @property
    @pulumi.getter(name="maxStalenessSeconds")
    def max_staleness_seconds(self) -> Optional[int]:
        return pulumi.get(self, "max_staleness_seconds")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="tagSets")
    def tag_sets(self) -> Optional[Sequence['outputs.FederatedDatabaseInstanceStorageStoreReadPreferenceTagSet']]:
        return pulumi.get(self, "tag_sets")


@pulumi.output_type
class FederatedDatabaseInstanceStorageStoreReadPreferenceTagSet(dict):
    def __init__(__self__, *,
                 tags: Sequence['outputs.FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTag']):
        FederatedDatabaseInstanceStorageStoreReadPreferenceTagSet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tags: Sequence['outputs.FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTag'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("tags", tags)

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTag']:
        return pulumi.get(self, "tags")


@pulumi.output_type
class FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTag(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: Name of the Atlas Federated Database Instance.
               ### `cloud_provider_config` - (Optional) Cloud provider linked to this data federated instance.
               #### `aws` - (Required) AWS provider of the cloud service where the Federated Database Instance can access the S3 Bucket. Note this parameter is only required if using `cloud_provider_config` since AWS is currently the only supported Cloud vendor on this feature at this time.
        """
        FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Atlas Federated Database Instance.
        ### `cloud_provider_config` - (Optional) Cloud provider linked to this data federated instance.
        #### `aws` - (Required) AWS provider of the cloud service where the Federated Database Instance can access the S3 Bucket. Note this parameter is only required if using `cloud_provider_config` since AWS is currently the only supported Cloud vendor on this feature at this time.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class FederatedSettingsOrgRoleMappingRoleAssignment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupId":
            suggest = "group_id"
        elif key == "orgId":
            suggest = "org_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedSettingsOrgRoleMappingRoleAssignment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedSettingsOrgRoleMappingRoleAssignment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedSettingsOrgRoleMappingRoleAssignment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_id: Optional[str] = None,
                 org_id: Optional[str] = None,
                 roles: Optional[Sequence[str]] = None):
        """
        :param str group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param Sequence[str] roles: Specifies the Roles that are attached to the Role Mapping. Available role IDs can be found on [the User Roles
               Reference](https://www.mongodb.com/docs/atlas/reference/user-roles/).
        """
        FederatedSettingsOrgRoleMappingRoleAssignment._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_id=group_id,
            org_id=org_id,
            roles=roles,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_id: Optional[str] = None,
             org_id: Optional[str] = None,
             roles: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if group_id is not None:
            _setter("group_id", group_id)
        if org_id is not None:
            _setter("org_id", org_id)
        if roles is not None:
            _setter("roles", roles)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[str]:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        """
        Specifies the Roles that are attached to the Role Mapping. Available role IDs can be found on [the User Roles
        Reference](https://www.mongodb.com/docs/atlas/reference/user-roles/).
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class GlobalClusterConfigCustomZoneMapping(dict):
    def __init__(__self__, *,
                 location: Optional[str] = None,
                 zone: Optional[str] = None):
        """
        :param str location: The ISO location code to which you want to map a zone in your Global Cluster. You can find a list of all supported location codes [here](https://cloud.mongodb.com/static/atlas/country_iso_codes.txt).
        :param str zone: The name of the zone in your Global Cluster that you want to map to location.
        """
        GlobalClusterConfigCustomZoneMapping._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            location=location,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             location: Optional[str] = None,
             zone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if location is not None:
            _setter("location", location)
        if zone is not None:
            _setter("zone", zone)

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        The ISO location code to which you want to map a zone in your Global Cluster. You can find a list of all supported location codes [here](https://cloud.mongodb.com/static/atlas/country_iso_codes.txt).
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        """
        The name of the zone in your Global Cluster that you want to map to location.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GlobalClusterConfigManagedNamespace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customShardKey":
            suggest = "custom_shard_key"
        elif key == "isCustomShardKeyHashed":
            suggest = "is_custom_shard_key_hashed"
        elif key == "isShardKeyUnique":
            suggest = "is_shard_key_unique"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalClusterConfigManagedNamespace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalClusterConfigManagedNamespace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalClusterConfigManagedNamespace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collection: str,
                 custom_shard_key: str,
                 db: str,
                 is_custom_shard_key_hashed: Optional[bool] = None,
                 is_shard_key_unique: Optional[bool] = None):
        """
        :param str collection: The name of the collection associated with the managed namespace.
        :param str custom_shard_key: The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        :param str db: The name of the database containing the collection.
        :param bool is_custom_shard_key_hashed: Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.
        :param bool is_shard_key_unique: Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).
        """
        GlobalClusterConfigManagedNamespace._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            collection=collection,
            custom_shard_key=custom_shard_key,
            db=db,
            is_custom_shard_key_hashed=is_custom_shard_key_hashed,
            is_shard_key_unique=is_shard_key_unique,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             collection: str,
             custom_shard_key: str,
             db: str,
             is_custom_shard_key_hashed: Optional[bool] = None,
             is_shard_key_unique: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("collection", collection)
        _setter("custom_shard_key", custom_shard_key)
        _setter("db", db)
        if is_custom_shard_key_hashed is not None:
            _setter("is_custom_shard_key_hashed", is_custom_shard_key_hashed)
        if is_shard_key_unique is not None:
            _setter("is_shard_key_unique", is_shard_key_unique)

    @property
    @pulumi.getter
    def collection(self) -> str:
        """
        The name of the collection associated with the managed namespace.
        """
        return pulumi.get(self, "collection")

    @property
    @pulumi.getter(name="customShardKey")
    def custom_shard_key(self) -> str:
        """
        The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        """
        return pulumi.get(self, "custom_shard_key")

    @property
    @pulumi.getter
    def db(self) -> str:
        """
        The name of the database containing the collection.
        """
        return pulumi.get(self, "db")

    @property
    @pulumi.getter(name="isCustomShardKeyHashed")
    def is_custom_shard_key_hashed(self) -> Optional[bool]:
        """
        Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.
        """
        return pulumi.get(self, "is_custom_shard_key_hashed")

    @property
    @pulumi.getter(name="isShardKeyUnique")
    def is_shard_key_unique(self) -> Optional[bool]:
        """
        Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).
        """
        return pulumi.get(self, "is_shard_key_unique")


@pulumi.output_type
class LdapConfigurationUserToDnMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ldapQuery":
            suggest = "ldap_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LdapConfigurationUserToDnMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LdapConfigurationUserToDnMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LdapConfigurationUserToDnMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ldap_query: Optional[str] = None,
                 match: Optional[str] = None,
                 substitution: Optional[str] = None):
        LdapConfigurationUserToDnMapping._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ldap_query=ldap_query,
            match=match,
            substitution=substitution,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ldap_query: Optional[str] = None,
             match: Optional[str] = None,
             substitution: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ldap_query is not None:
            _setter("ldap_query", ldap_query)
        if match is not None:
            _setter("match", match)
        if substitution is not None:
            _setter("substitution", substitution)

    @property
    @pulumi.getter(name="ldapQuery")
    def ldap_query(self) -> Optional[str]:
        return pulumi.get(self, "ldap_query")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def substitution(self) -> Optional[str]:
        return pulumi.get(self, "substitution")


@pulumi.output_type
class LdapVerifyLink(dict):
    def __init__(__self__, *,
                 href: Optional[str] = None,
                 rel: Optional[str] = None):
        LdapVerifyLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            href=href,
            rel=rel,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             href: Optional[str] = None,
             rel: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if href is not None:
            _setter("href", href)
        if rel is not None:
            _setter("rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[str]:
        return pulumi.get(self, "href")

    @property
    @pulumi.getter
    def rel(self) -> Optional[str]:
        return pulumi.get(self, "rel")


@pulumi.output_type
class LdapVerifyValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "validationType":
            suggest = "validation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LdapVerifyValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LdapVerifyValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LdapVerifyValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status: Optional[str] = None,
                 validation_type: Optional[str] = None):
        """
        :param str status: The current status of the LDAP over TLS/SSL configuration. One of the following values: `PENDING`, `SUCCESS`, and `FAILED`.
        """
        LdapVerifyValidation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            status=status,
            validation_type=validation_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             status: Optional[str] = None,
             validation_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if status is not None:
            _setter("status", status)
        if validation_type is not None:
            _setter("validation_type", validation_type)

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The current status of the LDAP over TLS/SSL configuration. One of the following values: `PENDING`, `SUCCESS`, and `FAILED`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="validationType")
    def validation_type(self) -> Optional[str]:
        return pulumi.get(self, "validation_type")


@pulumi.output_type
class OnlineArchiveCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateField":
            suggest = "date_field"
        elif key == "dateFormat":
            suggest = "date_format"
        elif key == "expireAfterDays":
            suggest = "expire_after_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineArchiveCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineArchiveCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineArchiveCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 date_field: Optional[str] = None,
                 date_format: Optional[str] = None,
                 expire_after_days: Optional[int] = None,
                 query: Optional[str] = None):
        """
        :param str type: Type of criteria (DATE, CUSTOM)
               
               The following fields are required for criteria type `DATE`
        :param str date_field: Indexed database parameter that stores the date that determines when data moves to the online archive. MongoDB Cloud archives the data when the current date exceeds the date in this database parameter plus the number of days specified through the expireAfterDays parameter.
        :param str date_format: Syntax used to write the date after which data moves to the online archive. Date can be expressed as ISO 8601 or Epoch timestamps. The Epoch timestamp can be expressed as nanoseconds, milliseconds, or seconds. You must set `type` to `DATE` if `collectionType` is `TIMESERIES`. Valid values:  ISODATE (default), EPOCH_SECONDS, EPOCH_MILLIS, EPOCH_NANOSECONDS.
        :param int expire_after_days: Number of days after the value in the criteria.dateField when MongoDB Cloud archives data in the specified cluster.
               
               **_NOTE: if `DATE` is selected, the `partition_fields.field_name` must be completed with the `date_field` value_**
               
               The only field required for criteria type `CUSTOM`
        :param str query: JSON query to use to select documents for archiving. Atlas uses the specified query with the db.collection.find(query) command. The empty document {} to return all documents is not supported.
        """
        OnlineArchiveCriteria._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            date_field=date_field,
            date_format=date_format,
            expire_after_days=expire_after_days,
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             date_field: Optional[str] = None,
             date_format: Optional[str] = None,
             expire_after_days: Optional[int] = None,
             query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if date_field is not None:
            _setter("date_field", date_field)
        if date_format is not None:
            _setter("date_format", date_format)
        if expire_after_days is not None:
            _setter("expire_after_days", expire_after_days)
        if query is not None:
            _setter("query", query)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of criteria (DATE, CUSTOM)

        The following fields are required for criteria type `DATE`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="dateField")
    def date_field(self) -> Optional[str]:
        """
        Indexed database parameter that stores the date that determines when data moves to the online archive. MongoDB Cloud archives the data when the current date exceeds the date in this database parameter plus the number of days specified through the expireAfterDays parameter.
        """
        return pulumi.get(self, "date_field")

    @property
    @pulumi.getter(name="dateFormat")
    def date_format(self) -> Optional[str]:
        """
        Syntax used to write the date after which data moves to the online archive. Date can be expressed as ISO 8601 or Epoch timestamps. The Epoch timestamp can be expressed as nanoseconds, milliseconds, or seconds. You must set `type` to `DATE` if `collectionType` is `TIMESERIES`. Valid values:  ISODATE (default), EPOCH_SECONDS, EPOCH_MILLIS, EPOCH_NANOSECONDS.
        """
        return pulumi.get(self, "date_format")

    @property
    @pulumi.getter(name="expireAfterDays")
    def expire_after_days(self) -> Optional[int]:
        """
        Number of days after the value in the criteria.dateField when MongoDB Cloud archives data in the specified cluster.

        **_NOTE: if `DATE` is selected, the `partition_fields.field_name` must be completed with the `date_field` value_**

        The only field required for criteria type `CUSTOM`
        """
        return pulumi.get(self, "expire_after_days")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        JSON query to use to select documents for archiving. Atlas uses the specified query with the db.collection.find(query) command. The empty document {} to return all documents is not supported.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class OnlineArchivePartitionField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "fieldType":
            suggest = "field_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineArchivePartitionField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineArchivePartitionField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineArchivePartitionField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: str,
                 order: int,
                 field_type: Optional[str] = None):
        """
        :param str field_name: Human-readable label that identifies the parameter that MongoDB Cloud uses to partition data. To specify a nested parameter, use the dot notation.
        :param int order: Sequence in which MongoDB Cloud slices the collection data to create partitions. The resource expresses this sequence starting with zero. The value of the `criteria.dateField` parameter defaults as the first item in the partition sequence.
        :param str field_type: Data type of the parameter that that MongoDB Cloud uses to partition data. Partition parameters of type UUID must be of binary subtype 4. MongoDB Cloud skips partition parameters of type UUID with subtype 3. Valid values: `date`, `int`, `long`, `objectId`, `string`, `uuid`.
        """
        OnlineArchivePartitionField._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_name=field_name,
            order=order,
            field_type=field_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_name: str,
             order: int,
             field_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_name", field_name)
        _setter("order", order)
        if field_type is not None:
            _setter("field_type", field_type)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        """
        Human-readable label that identifies the parameter that MongoDB Cloud uses to partition data. To specify a nested parameter, use the dot notation.
        """
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def order(self) -> int:
        """
        Sequence in which MongoDB Cloud slices the collection data to create partitions. The resource expresses this sequence starting with zero. The value of the `criteria.dateField` parameter defaults as the first item in the partition sequence.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> Optional[str]:
        """
        Data type of the parameter that that MongoDB Cloud uses to partition data. Partition parameters of type UUID must be of binary subtype 4. MongoDB Cloud skips partition parameters of type UUID with subtype 3. Valid values: `date`, `int`, `long`, `objectId`, `string`, `uuid`.
        """
        return pulumi.get(self, "field_type")


@pulumi.output_type
class OnlineArchiveSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfMonth":
            suggest = "day_of_month"
        elif key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "endHour":
            suggest = "end_hour"
        elif key == "endMinute":
            suggest = "end_minute"
        elif key == "startHour":
            suggest = "start_hour"
        elif key == "startMinute":
            suggest = "start_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineArchiveSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineArchiveSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineArchiveSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 day_of_month: Optional[int] = None,
                 day_of_week: Optional[int] = None,
                 end_hour: Optional[int] = None,
                 end_minute: Optional[int] = None,
                 start_hour: Optional[int] = None,
                 start_minute: Optional[int] = None):
        """
        :param str type: Type of schedule (``DAILY`, `MONTHLY`, `WEEKLY`).
        :param int day_of_month: Day of the month when the scheduled archive starts. This field should be provided only when schedule `type` is `MONTHLY`.
        :param int day_of_week: Day of the week when the scheduled archive starts. The week starts with Monday (1) and ends with Sunday (7). This field should be provided only when schedule `type` is `WEEKLY`.
        :param int end_hour: Hour of the day when the scheduled window to run one online archive ends.
        :param int end_minute: Minute of the hour when the scheduled window to run one online archive ends.
        :param int start_hour: Hour of the day when the when the scheduled window to run one online archive starts.
        :param int start_minute: Minute of the hour when the scheduled window to run one online archive starts.
        """
        OnlineArchiveSchedule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            day_of_month=day_of_month,
            day_of_week=day_of_week,
            end_hour=end_hour,
            end_minute=end_minute,
            start_hour=start_hour,
            start_minute=start_minute,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             day_of_month: Optional[int] = None,
             day_of_week: Optional[int] = None,
             end_hour: Optional[int] = None,
             end_minute: Optional[int] = None,
             start_hour: Optional[int] = None,
             start_minute: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if day_of_month is not None:
            _setter("day_of_month", day_of_month)
        if day_of_week is not None:
            _setter("day_of_week", day_of_week)
        if end_hour is not None:
            _setter("end_hour", end_hour)
        if end_minute is not None:
            _setter("end_minute", end_minute)
        if start_hour is not None:
            _setter("start_hour", start_hour)
        if start_minute is not None:
            _setter("start_minute", start_minute)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of schedule (``DAILY`, `MONTHLY`, `WEEKLY`).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[int]:
        """
        Day of the month when the scheduled archive starts. This field should be provided only when schedule `type` is `MONTHLY`.
        """
        return pulumi.get(self, "day_of_month")

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[int]:
        """
        Day of the week when the scheduled archive starts. The week starts with Monday (1) and ends with Sunday (7). This field should be provided only when schedule `type` is `WEEKLY`.
        """
        return pulumi.get(self, "day_of_week")

    @property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> Optional[int]:
        """
        Hour of the day when the scheduled window to run one online archive ends.
        """
        return pulumi.get(self, "end_hour")

    @property
    @pulumi.getter(name="endMinute")
    def end_minute(self) -> Optional[int]:
        """
        Minute of the hour when the scheduled window to run one online archive ends.
        """
        return pulumi.get(self, "end_minute")

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> Optional[int]:
        """
        Hour of the day when the when the scheduled window to run one online archive starts.
        """
        return pulumi.get(self, "start_hour")

    @property
    @pulumi.getter(name="startMinute")
    def start_minute(self) -> Optional[int]:
        """
        Minute of the hour when the scheduled window to run one online archive starts.
        """
        return pulumi.get(self, "start_minute")


@pulumi.output_type
class PrivateLinkEndpointServiceEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointName":
            suggest = "endpoint_name"
        elif key == "ipAddress":
            suggest = "ip_address"
        elif key == "serviceAttachmentName":
            suggest = "service_attachment_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkEndpointServiceEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkEndpointServiceEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkEndpointServiceEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_name: Optional[str] = None,
                 ip_address: Optional[str] = None,
                 service_attachment_name: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str endpoint_name: Forwarding rule that corresponds to the endpoint you created in GCP.
        :param str ip_address: Private IP address of the endpoint you created in GCP.
        :param str service_attachment_name: Unique alphanumeric and special character strings that identify the service attachment associated with the endpoint.
        :param str status: Status of the endpoint. Atlas returns one of the [values shown above](https://docs.atlas.mongodb.com/reference/api/private-endpoints-endpoint-create-one/#std-label-ref-status-field).
        """
        PrivateLinkEndpointServiceEndpoint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_name=endpoint_name,
            ip_address=ip_address,
            service_attachment_name=service_attachment_name,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_name: Optional[str] = None,
             ip_address: Optional[str] = None,
             service_attachment_name: Optional[str] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if endpoint_name is not None:
            _setter("endpoint_name", endpoint_name)
        if ip_address is not None:
            _setter("ip_address", ip_address)
        if service_attachment_name is not None:
            _setter("service_attachment_name", service_attachment_name)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter(name="endpointName")
    def endpoint_name(self) -> Optional[str]:
        """
        Forwarding rule that corresponds to the endpoint you created in GCP.
        """
        return pulumi.get(self, "endpoint_name")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        Private IP address of the endpoint you created in GCP.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="serviceAttachmentName")
    def service_attachment_name(self) -> Optional[str]:
        """
        Unique alphanumeric and special character strings that identify the service attachment associated with the endpoint.
        """
        return pulumi.get(self, "service_attachment_name")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of the endpoint. Atlas returns one of the [values shown above](https://docs.atlas.mongodb.com/reference/api/private-endpoints-endpoint-create-one/#std-label-ref-status-field).
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ProjectApiKeyProjectAssignment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"
        elif key == "roleNames":
            suggest = "role_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectApiKeyProjectAssignment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectApiKeyProjectAssignment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectApiKeyProjectAssignment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_id: str,
                 role_names: Sequence[str]):
        """
        :param str project_id: Project ID to assign to Access Key
        :param Sequence[str] role_names: List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project. You must specify an array even if you are only associating a single role with the Programmatic API key. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) describes the valid roles that can be assigned.
        """
        ProjectApiKeyProjectAssignment._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            project_id=project_id,
            role_names=role_names,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             project_id: str,
             role_names: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("project_id", project_id)
        _setter("role_names", role_names)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Project ID to assign to Access Key
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[str]:
        """
        List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project. You must specify an array even if you are only associating a single role with the Programmatic API key. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) describes the valid roles that can be assigned.
        """
        return pulumi.get(self, "role_names")


@pulumi.output_type
class ProjectIpAccessListTimeouts(dict):
    def __init__(__self__, *,
                 delete: Optional[str] = None,
                 read: Optional[str] = None):
        ProjectIpAccessListTimeouts._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delete=delete,
            read=read,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delete: Optional[str] = None,
             read: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if delete is not None:
            _setter("delete", delete)
        if read is not None:
            _setter("read", read)

    @property
    @pulumi.getter
    def delete(self) -> Optional[str]:
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        return pulumi.get(self, "read")


@pulumi.output_type
class ProjectLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currentUsage":
            suggest = "current_usage"
        elif key == "defaultLimit":
            suggest = "default_limit"
        elif key == "maximumLimit":
            suggest = "maximum_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 value: int,
                 current_usage: Optional[int] = None,
                 default_limit: Optional[int] = None,
                 maximum_limit: Optional[int] = None):
        """
        :param str name: Human-readable label that identifies this project limit. See [Project Limit Documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Projects/operation/setProjectLimit) under `limitName` parameter to find all the limits that can be defined.
        :param int value: Amount to set the limit to. Use the [Project Limit Documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Projects/operation/setProjectLimit) under `limitName` parameter to verify the override limits.
        """
        ProjectLimit._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
            current_usage=current_usage,
            default_limit=default_limit,
            maximum_limit=maximum_limit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             value: int,
             current_usage: Optional[int] = None,
             default_limit: Optional[int] = None,
             maximum_limit: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("value", value)
        if current_usage is not None:
            _setter("current_usage", current_usage)
        if default_limit is not None:
            _setter("default_limit", default_limit)
        if maximum_limit is not None:
            _setter("maximum_limit", maximum_limit)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Human-readable label that identifies this project limit. See [Project Limit Documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Projects/operation/setProjectLimit) under `limitName` parameter to find all the limits that can be defined.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Amount to set the limit to. Use the [Project Limit Documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Projects/operation/setProjectLimit) under `limitName` parameter to verify the override limits.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="currentUsage")
    def current_usage(self) -> Optional[int]:
        return pulumi.get(self, "current_usage")

    @property
    @pulumi.getter(name="defaultLimit")
    def default_limit(self) -> Optional[int]:
        return pulumi.get(self, "default_limit")

    @property
    @pulumi.getter(name="maximumLimit")
    def maximum_limit(self) -> Optional[int]:
        return pulumi.get(self, "maximum_limit")


@pulumi.output_type
class ProjectTeam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleNames":
            suggest = "role_names"
        elif key == "teamId":
            suggest = "team_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectTeam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectTeam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectTeam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_names: Sequence[str],
                 team_id: str):
        """
        :param Sequence[str] role_names: Each string in the array represents a project role you want to assign to the team. Every user associated with the team inherits these roles. You must specify an array even if you are only associating a single role with the team. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles a user can have.
               
               > **NOTE:** Project created by API Keys must belong to an existing organization.
        :param str team_id: The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
        """
        ProjectTeam._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_names=role_names,
            team_id=team_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_names: Sequence[str],
             team_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("role_names", role_names)
        _setter("team_id", team_id)

    @property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[str]:
        """
        Each string in the array represents a project role you want to assign to the team. Every user associated with the team inherits these roles. You must specify an array even if you are only associating a single role with the team. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles a user can have.

        > **NOTE:** Project created by API Keys must belong to an existing organization.
        """
        return pulumi.get(self, "role_names")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> str:
        """
        The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
        """
        return pulumi.get(self, "team_id")


@pulumi.output_type
class SearchIndexSynonym(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceCollection":
            suggest = "source_collection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SearchIndexSynonym. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SearchIndexSynonym.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SearchIndexSynonym.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 analyzer: str,
                 name: str,
                 source_collection: str):
        """
        :param str analyzer: Name of the [analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use with this synonym mapping. Atlas Search doesn't support these [custom analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-custom-analyzers) tokenizers and token filters in [analyzers used in synonym mappings](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#options):
               * [nGram](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-ngram-tokenizer-ref) Tokenizer
               * [edgeGram](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-edgegram-tokenizer-ref) Tokenizers
               * [daitchMokotoffSoundex](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-daitchmokotoffsoundex-tf-ref) token filter
               * [nGram](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-ngram-tf-ref) token filter
               * [edgeGram](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-edgegram-tf-ref) token filter
               * [shingle](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-shingle-tf-ref) token filter
               
               ```python
               import pulumi
               ```
               
               
               
               For more information see: [MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/atlas-search/) - [and MongoDB Atlas API - Search](https://docs.atlas.mongodb.com/reference/api/atlas-search/) Documentation for more information.
        :param str name: Name of the [synonym mapping definition](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-ref). Name must be unique in this index definition and it can't be an empty string.
        :param str source_collection: Name of the source MongoDB collection for the synonyms. Documents in this collection must be in the format described in the [Synonyms Source Collection Documents](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-coll-spec).
        """
        SearchIndexSynonym._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            analyzer=analyzer,
            name=name,
            source_collection=source_collection,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             analyzer: str,
             name: str,
             source_collection: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("analyzer", analyzer)
        _setter("name", name)
        _setter("source_collection", source_collection)

    @property
    @pulumi.getter
    def analyzer(self) -> str:
        """
        Name of the [analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use with this synonym mapping. Atlas Search doesn't support these [custom analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-custom-analyzers) tokenizers and token filters in [analyzers used in synonym mappings](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#options):
        * [nGram](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-ngram-tokenizer-ref) Tokenizer
        * [edgeGram](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-edgegram-tokenizer-ref) Tokenizers
        * [daitchMokotoffSoundex](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-daitchmokotoffsoundex-tf-ref) token filter
        * [nGram](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-ngram-tf-ref) token filter
        * [edgeGram](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-edgegram-tf-ref) token filter
        * [shingle](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-shingle-tf-ref) token filter

        ```python
        import pulumi
        ```



        For more information see: [MongoDB Atlas API Reference.](https://docs.atlas.mongodb.com/atlas-search/) - [and MongoDB Atlas API - Search](https://docs.atlas.mongodb.com/reference/api/atlas-search/) Documentation for more information.
        """
        return pulumi.get(self, "analyzer")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the [synonym mapping definition](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-ref). Name must be unique in this index definition and it can't be an empty string.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sourceCollection")
    def source_collection(self) -> str:
        """
        Name of the source MongoDB collection for the synonyms. Documents in this collection must be in the format described in the [Synonyms Source Collection Documents](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-coll-spec).
        """
        return pulumi.get(self, "source_collection")


@pulumi.output_type
class ServerlessInstanceLink(dict):
    def __init__(__self__, *,
                 href: Optional[str] = None,
                 rel: Optional[str] = None):
        ServerlessInstanceLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            href=href,
            rel=rel,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             href: Optional[str] = None,
             rel: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if href is not None:
            _setter("href", href)
        if rel is not None:
            _setter("rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[str]:
        return pulumi.get(self, "href")

    @property
    @pulumi.getter
    def rel(self) -> Optional[str]:
        return pulumi.get(self, "rel")


@pulumi.output_type
class ServerlessInstanceTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Constant that defines the set of the tag.
        :param str value: Variable that belongs to the set of the tag.
               
               To learn more, see [Resource Tags](https://dochub.mongodb.org/core/add-cluster-tag-atlas).
        """
        ServerlessInstanceTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Constant that defines the set of the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Variable that belongs to the set of the tag.

        To learn more, see [Resource Tags](https://dochub.mongodb.org/core/add-cluster-tag-atlas).
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class X509AuthenticationDatabaseUserCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "notAfter":
            suggest = "not_after"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in X509AuthenticationDatabaseUserCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        X509AuthenticationDatabaseUserCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        X509AuthenticationDatabaseUserCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 group_id: Optional[str] = None,
                 id: Optional[int] = None,
                 not_after: Optional[str] = None,
                 subject: Optional[str] = None):
        X509AuthenticationDatabaseUserCertificate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_at=created_at,
            group_id=group_id,
            id=id,
            not_after=not_after,
            subject=subject,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_at: Optional[str] = None,
             group_id: Optional[str] = None,
             id: Optional[int] = None,
             not_after: Optional[str] = None,
             subject: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if created_at is not None:
            _setter("created_at", created_at)
        if group_id is not None:
            _setter("group_id", group_id)
        if id is not None:
            _setter("id", id)
        if not_after is not None:
            _setter("not_after", not_after)
        if subject is not None:
            _setter("subject", subject)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> Optional[str]:
        return pulumi.get(self, "not_after")

    @property
    @pulumi.getter
    def subject(self) -> Optional[str]:
        return pulumi.get(self, "subject")


@pulumi.output_type
class Get509AuthenticationDatabaseUserCertificateResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 group_id: str,
                 id: int,
                 not_after: str,
                 subject: str):
        Get509AuthenticationDatabaseUserCertificateResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_at=created_at,
            group_id=group_id,
            id=id,
            not_after=not_after,
            subject=subject,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_at: str,
             group_id: str,
             id: int,
             not_after: str,
             subject: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("created_at", created_at)
        _setter("group_id", group_id)
        _setter("id", id)
        _setter("not_after", not_after)
        _setter("subject", subject)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> str:
        return pulumi.get(self, "not_after")

    @property
    @pulumi.getter
    def subject(self) -> str:
        return pulumi.get(self, "subject")


@pulumi.output_type
class GetAccessListApiKeysResultResult(dict):
    def __init__(__self__, *,
                 access_count: int,
                 cidr_block: str,
                 created: str,
                 ip_address: str,
                 last_used: str,
                 last_used_address: str):
        """
        :param str cidr_block: Range of IP addresses in CIDR notation to be added to the access list.
        :param str ip_address: Single IP address to be added to the access list.
        """
        GetAccessListApiKeysResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_count=access_count,
            cidr_block=cidr_block,
            created=created,
            ip_address=ip_address,
            last_used=last_used,
            last_used_address=last_used_address,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_count: int,
             cidr_block: str,
             created: str,
             ip_address: str,
             last_used: str,
             last_used_address: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("access_count", access_count)
        _setter("cidr_block", cidr_block)
        _setter("created", created)
        _setter("ip_address", ip_address)
        _setter("last_used", last_used)
        _setter("last_used_address", last_used_address)

    @property
    @pulumi.getter(name="accessCount")
    def access_count(self) -> int:
        return pulumi.get(self, "access_count")

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> str:
        """
        Range of IP addresses in CIDR notation to be added to the access list.
        """
        return pulumi.get(self, "cidr_block")

    @property
    @pulumi.getter
    def created(self) -> str:
        return pulumi.get(self, "created")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        Single IP address to be added to the access list.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="lastUsed")
    def last_used(self) -> str:
        return pulumi.get(self, "last_used")

    @property
    @pulumi.getter(name="lastUsedAddress")
    def last_used_address(self) -> str:
        return pulumi.get(self, "last_used_address")


@pulumi.output_type
class GetAdvancedClusterAdvancedConfigurationResult(dict):
    def __init__(__self__, *,
                 default_read_concern: str,
                 default_write_concern: str,
                 fail_index_key_too_long: bool,
                 javascript_enabled: bool,
                 minimum_enabled_tls_protocol: str,
                 no_table_scan: bool,
                 oplog_min_retention_hours: int,
                 oplog_size_mb: int,
                 sample_refresh_interval_bi_connector: int,
                 sample_size_bi_connector: int,
                 transaction_lifetime_limit_seconds: int):
        """
        :param str default_read_concern: [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        :param str default_write_concern: [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        :param bool fail_index_key_too_long: When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        :param bool javascript_enabled: When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        :param str minimum_enabled_tls_protocol: Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        :param bool no_table_scan: When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        :param int oplog_min_retention_hours: Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        :param int oplog_size_mb: The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        :param int sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param int sample_size_bi_connector: Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param int transaction_lifetime_limit_seconds: Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        GetAdvancedClusterAdvancedConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_read_concern=default_read_concern,
            default_write_concern=default_write_concern,
            fail_index_key_too_long=fail_index_key_too_long,
            javascript_enabled=javascript_enabled,
            minimum_enabled_tls_protocol=minimum_enabled_tls_protocol,
            no_table_scan=no_table_scan,
            oplog_min_retention_hours=oplog_min_retention_hours,
            oplog_size_mb=oplog_size_mb,
            sample_refresh_interval_bi_connector=sample_refresh_interval_bi_connector,
            sample_size_bi_connector=sample_size_bi_connector,
            transaction_lifetime_limit_seconds=transaction_lifetime_limit_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_read_concern: str,
             default_write_concern: str,
             fail_index_key_too_long: bool,
             javascript_enabled: bool,
             minimum_enabled_tls_protocol: str,
             no_table_scan: bool,
             oplog_min_retention_hours: int,
             oplog_size_mb: int,
             sample_refresh_interval_bi_connector: int,
             sample_size_bi_connector: int,
             transaction_lifetime_limit_seconds: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("default_read_concern", default_read_concern)
        _setter("default_write_concern", default_write_concern)
        _setter("fail_index_key_too_long", fail_index_key_too_long)
        _setter("javascript_enabled", javascript_enabled)
        _setter("minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        _setter("no_table_scan", no_table_scan)
        _setter("oplog_min_retention_hours", oplog_min_retention_hours)
        _setter("oplog_size_mb", oplog_size_mb)
        _setter("sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        _setter("sample_size_bi_connector", sample_size_bi_connector)
        _setter("transaction_lifetime_limit_seconds", transaction_lifetime_limit_seconds)

    @property
    @pulumi.getter(name="defaultReadConcern")
    def default_read_concern(self) -> str:
        """
        [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        """
        return pulumi.get(self, "default_read_concern")

    @property
    @pulumi.getter(name="defaultWriteConcern")
    def default_write_concern(self) -> str:
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        return pulumi.get(self, "default_write_concern")

    @property
    @pulumi.getter(name="failIndexKeyTooLong")
    def fail_index_key_too_long(self) -> bool:
        """
        When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        """
        return pulumi.get(self, "fail_index_key_too_long")

    @property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> bool:
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        return pulumi.get(self, "javascript_enabled")

    @property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> str:
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> bool:
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        return pulumi.get(self, "no_table_scan")

    @property
    @pulumi.getter(name="oplogMinRetentionHours")
    def oplog_min_retention_hours(self) -> int:
        """
        Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        """
        return pulumi.get(self, "oplog_min_retention_hours")

    @property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> int:
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        return pulumi.get(self, "oplog_size_mb")

    @property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> int:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> int:
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_size_bi_connector")

    @property
    @pulumi.getter(name="transactionLifetimeLimitSeconds")
    def transaction_lifetime_limit_seconds(self) -> int:
        """
        Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        return pulumi.get(self, "transaction_lifetime_limit_seconds")


@pulumi.output_type
class GetAdvancedClusterBiConnectorConfigResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 read_preference: str):
        """
        :param bool enabled: Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
        :param str read_preference: Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        GetAdvancedClusterBiConnectorConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            read_preference=read_preference,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: bool,
             read_preference: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("enabled", enabled)
        _setter("read_preference", read_preference)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> str:
        """
        Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        return pulumi.get(self, "read_preference")


@pulumi.output_type
class GetAdvancedClusterConnectionStringResult(dict):
    def __init__(__self__, *,
                 private: str,
                 private_endpoints: Sequence['outputs.GetAdvancedClusterConnectionStringPrivateEndpointResult'],
                 private_srv: str,
                 standard: str,
                 standard_srv: str):
        GetAdvancedClusterConnectionStringResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private=private,
            private_endpoints=private_endpoints,
            private_srv=private_srv,
            standard=standard,
            standard_srv=standard_srv,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private: str,
             private_endpoints: Sequence['outputs.GetAdvancedClusterConnectionStringPrivateEndpointResult'],
             private_srv: str,
             standard: str,
             standard_srv: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("private", private)
        _setter("private_endpoints", private_endpoints)
        _setter("private_srv", private_srv)
        _setter("standard", standard)
        _setter("standard_srv", standard_srv)

    @property
    @pulumi.getter
    def private(self) -> str:
        return pulumi.get(self, "private")

    @property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Sequence['outputs.GetAdvancedClusterConnectionStringPrivateEndpointResult']:
        return pulumi.get(self, "private_endpoints")

    @property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> str:
        return pulumi.get(self, "private_srv")

    @property
    @pulumi.getter
    def standard(self) -> str:
        return pulumi.get(self, "standard")

    @property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> str:
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class GetAdvancedClusterConnectionStringPrivateEndpointResult(dict):
    def __init__(__self__, *,
                 connection_string: str,
                 endpoints: Sequence['outputs.GetAdvancedClusterConnectionStringPrivateEndpointEndpointResult'],
                 srv_connection_string: str,
                 srv_shard_optimized_connection_string: str,
                 type: str):
        GetAdvancedClusterConnectionStringPrivateEndpointResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_string=connection_string,
            endpoints=endpoints,
            srv_connection_string=srv_connection_string,
            srv_shard_optimized_connection_string=srv_shard_optimized_connection_string,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_string: str,
             endpoints: Sequence['outputs.GetAdvancedClusterConnectionStringPrivateEndpointEndpointResult'],
             srv_connection_string: str,
             srv_shard_optimized_connection_string: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("connection_string", connection_string)
        _setter("endpoints", endpoints)
        _setter("srv_connection_string", srv_connection_string)
        _setter("srv_shard_optimized_connection_string", srv_shard_optimized_connection_string)
        _setter("type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> str:
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def endpoints(self) -> Sequence['outputs.GetAdvancedClusterConnectionStringPrivateEndpointEndpointResult']:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> str:
        return pulumi.get(self, "srv_connection_string")

    @property
    @pulumi.getter(name="srvShardOptimizedConnectionString")
    def srv_shard_optimized_connection_string(self) -> str:
        return pulumi.get(self, "srv_shard_optimized_connection_string")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAdvancedClusterConnectionStringPrivateEndpointEndpointResult(dict):
    def __init__(__self__, *,
                 endpoint_id: str,
                 provider_name: str,
                 region: str):
        """
        :param str provider_name: Cloud service provider on which the servers are provisioned.
        """
        GetAdvancedClusterConnectionStringPrivateEndpointEndpointResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_id=endpoint_id,
            provider_name=provider_name,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_id: str,
             provider_name: str,
             region: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("endpoint_id", endpoint_id)
        _setter("provider_name", provider_name)
        _setter("region", region)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> str:
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetAdvancedClusterLabelResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        GetAdvancedClusterLabelResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecResult(dict):
    def __init__(__self__, *,
                 container_id: Mapping[str, str],
                 id: str,
                 num_shards: int,
                 region_configs: Sequence['outputs.GetAdvancedClusterReplicationSpecRegionConfigResult'],
                 zone_name: str):
        """
        :param Mapping[str, str] container_id: A key-value map of the Network Peering Container ID(s) for the configuration specified in `region_configs`. The Container ID is the id of the container either created programmatically by the user before any clusters existed in a project or when the first cluster in the region (AWS/Azure) or project (GCP) was created.  The syntax is `"providerName:regionName" = "containerId"`. Example `AWS:US_EAST_1" = "61e0797dde08fb498ca11a71`.
        :param int num_shards: Provide this value if you set a `cluster_type` of SHARDED or GEOSHARDED.
        :param Sequence['GetAdvancedClusterReplicationSpecRegionConfigArgs'] region_configs: Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below
        :param str zone_name: Name for the zone in a Global Cluster.
        """
        GetAdvancedClusterReplicationSpecResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            container_id=container_id,
            id=id,
            num_shards=num_shards,
            region_configs=region_configs,
            zone_name=zone_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             container_id: Mapping[str, str],
             id: str,
             num_shards: int,
             region_configs: Sequence['outputs.GetAdvancedClusterReplicationSpecRegionConfigResult'],
             zone_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("container_id", container_id)
        _setter("id", id)
        _setter("num_shards", num_shards)
        _setter("region_configs", region_configs)
        _setter("zone_name", zone_name)

    @property
    @pulumi.getter(name="containerId")
    def container_id(self) -> Mapping[str, str]:
        """
        A key-value map of the Network Peering Container ID(s) for the configuration specified in `region_configs`. The Container ID is the id of the container either created programmatically by the user before any clusters existed in a project or when the first cluster in the region (AWS/Azure) or project (GCP) was created.  The syntax is `"providerName:regionName" = "containerId"`. Example `AWS:US_EAST_1" = "61e0797dde08fb498ca11a71`.
        """
        return pulumi.get(self, "container_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> int:
        """
        Provide this value if you set a `cluster_type` of SHARDED or GEOSHARDED.
        """
        return pulumi.get(self, "num_shards")

    @property
    @pulumi.getter(name="regionConfigs")
    def region_configs(self) -> Sequence['outputs.GetAdvancedClusterReplicationSpecRegionConfigResult']:
        """
        Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below
        """
        return pulumi.get(self, "region_configs")

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> str:
        """
        Name for the zone in a Global Cluster.
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecRegionConfigResult(dict):
    def __init__(__self__, *,
                 analytics_auto_scalings: Sequence['outputs.GetAdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingResult'],
                 auto_scalings: Sequence['outputs.GetAdvancedClusterReplicationSpecRegionConfigAutoScalingResult'],
                 backing_provider_name: str,
                 priority: int,
                 provider_name: str,
                 region_name: str,
                 analytics_specs: Optional['outputs.GetAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsResult'] = None,
                 electable_specs: Optional['outputs.GetAdvancedClusterReplicationSpecRegionConfigElectableSpecsResult'] = None,
                 read_only_specs: Optional['outputs.GetAdvancedClusterReplicationSpecRegionConfigReadOnlySpecsResult'] = None):
        """
        :param Sequence['GetAdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingArgs'] analytics_auto_scalings: Configuration for the Collection of settings that configures analytics-auto-scaling information for the cluster. See below
        :param Sequence['GetAdvancedClusterReplicationSpecRegionConfigAutoScalingArgs'] auto_scalings: Configuration for the Collection of settings that configures auto-scaling information for the cluster. See below
        :param str backing_provider_name: Cloud service provider on which you provision the host for a multi-tenant cluster.
        :param int priority: Election priority of the region.
        :param str provider_name: Cloud service provider on which the servers are provisioned.
        :param str region_name: Physical location of your MongoDB cluster.
        :param 'GetAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgs' analytics_specs: Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. See below
        :param 'GetAdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs' electable_specs: Hardware specifications for electable nodes in the region.
        :param 'GetAdvancedClusterReplicationSpecRegionConfigReadOnlySpecsArgs' read_only_specs: Hardware specifications for read-only nodes in the region. See below
        """
        GetAdvancedClusterReplicationSpecRegionConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            analytics_auto_scalings=analytics_auto_scalings,
            auto_scalings=auto_scalings,
            backing_provider_name=backing_provider_name,
            priority=priority,
            provider_name=provider_name,
            region_name=region_name,
            analytics_specs=analytics_specs,
            electable_specs=electable_specs,
            read_only_specs=read_only_specs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             analytics_auto_scalings: Sequence['outputs.GetAdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingResult'],
             auto_scalings: Sequence['outputs.GetAdvancedClusterReplicationSpecRegionConfigAutoScalingResult'],
             backing_provider_name: str,
             priority: int,
             provider_name: str,
             region_name: str,
             analytics_specs: Optional['outputs.GetAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsResult'] = None,
             electable_specs: Optional['outputs.GetAdvancedClusterReplicationSpecRegionConfigElectableSpecsResult'] = None,
             read_only_specs: Optional['outputs.GetAdvancedClusterReplicationSpecRegionConfigReadOnlySpecsResult'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("analytics_auto_scalings", analytics_auto_scalings)
        _setter("auto_scalings", auto_scalings)
        _setter("backing_provider_name", backing_provider_name)
        _setter("priority", priority)
        _setter("provider_name", provider_name)
        _setter("region_name", region_name)
        if analytics_specs is not None:
            _setter("analytics_specs", analytics_specs)
        if electable_specs is not None:
            _setter("electable_specs", electable_specs)
        if read_only_specs is not None:
            _setter("read_only_specs", read_only_specs)

    @property
    @pulumi.getter(name="analyticsAutoScalings")
    def analytics_auto_scalings(self) -> Sequence['outputs.GetAdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingResult']:
        """
        Configuration for the Collection of settings that configures analytics-auto-scaling information for the cluster. See below
        """
        return pulumi.get(self, "analytics_auto_scalings")

    @property
    @pulumi.getter(name="autoScalings")
    def auto_scalings(self) -> Sequence['outputs.GetAdvancedClusterReplicationSpecRegionConfigAutoScalingResult']:
        """
        Configuration for the Collection of settings that configures auto-scaling information for the cluster. See below
        """
        return pulumi.get(self, "auto_scalings")

    @property
    @pulumi.getter(name="backingProviderName")
    def backing_provider_name(self) -> str:
        """
        Cloud service provider on which you provision the host for a multi-tenant cluster.
        """
        return pulumi.get(self, "backing_provider_name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Election priority of the region.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        Physical location of your MongoDB cluster.
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter(name="analyticsSpecs")
    def analytics_specs(self) -> Optional['outputs.GetAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsResult']:
        """
        Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. See below
        """
        return pulumi.get(self, "analytics_specs")

    @property
    @pulumi.getter(name="electableSpecs")
    def electable_specs(self) -> Optional['outputs.GetAdvancedClusterReplicationSpecRegionConfigElectableSpecsResult']:
        """
        Hardware specifications for electable nodes in the region.
        """
        return pulumi.get(self, "electable_specs")

    @property
    @pulumi.getter(name="readOnlySpecs")
    def read_only_specs(self) -> Optional['outputs.GetAdvancedClusterReplicationSpecRegionConfigReadOnlySpecsResult']:
        """
        Hardware specifications for read-only nodes in the region. See below
        """
        return pulumi.get(self, "read_only_specs")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingResult(dict):
    def __init__(__self__, *,
                 compute_enabled: bool,
                 compute_max_instance_size: str,
                 compute_min_instance_size: str,
                 compute_scale_down_enabled: bool,
                 disk_gb_enabled: bool):
        """
        :param bool compute_enabled: Flag that indicates whether instance size auto-scaling is enabled.
        :param str compute_max_instance_size: Maximum instance size to which your cluster can automatically scale (such as M40). 
               #### Advanced Configuration
        :param str compute_min_instance_size: Minimum instance size to which your cluster can automatically scale (such as M10).
        :param bool compute_scale_down_enabled: Flag that indicates whether the instance size may scale down.
        :param bool disk_gb_enabled: Flag that indicates whether this cluster enables disk auto-scaling.
        """
        GetAdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compute_enabled=compute_enabled,
            compute_max_instance_size=compute_max_instance_size,
            compute_min_instance_size=compute_min_instance_size,
            compute_scale_down_enabled=compute_scale_down_enabled,
            disk_gb_enabled=disk_gb_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compute_enabled: bool,
             compute_max_instance_size: str,
             compute_min_instance_size: str,
             compute_scale_down_enabled: bool,
             disk_gb_enabled: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("compute_enabled", compute_enabled)
        _setter("compute_max_instance_size", compute_max_instance_size)
        _setter("compute_min_instance_size", compute_min_instance_size)
        _setter("compute_scale_down_enabled", compute_scale_down_enabled)
        _setter("disk_gb_enabled", disk_gb_enabled)

    @property
    @pulumi.getter(name="computeEnabled")
    def compute_enabled(self) -> bool:
        """
        Flag that indicates whether instance size auto-scaling is enabled.
        """
        return pulumi.get(self, "compute_enabled")

    @property
    @pulumi.getter(name="computeMaxInstanceSize")
    def compute_max_instance_size(self) -> str:
        """
        Maximum instance size to which your cluster can automatically scale (such as M40). 
        #### Advanced Configuration
        """
        return pulumi.get(self, "compute_max_instance_size")

    @property
    @pulumi.getter(name="computeMinInstanceSize")
    def compute_min_instance_size(self) -> str:
        """
        Minimum instance size to which your cluster can automatically scale (such as M10).
        """
        return pulumi.get(self, "compute_min_instance_size")

    @property
    @pulumi.getter(name="computeScaleDownEnabled")
    def compute_scale_down_enabled(self) -> bool:
        """
        Flag that indicates whether the instance size may scale down.
        """
        return pulumi.get(self, "compute_scale_down_enabled")

    @property
    @pulumi.getter(name="diskGbEnabled")
    def disk_gb_enabled(self) -> bool:
        """
        Flag that indicates whether this cluster enables disk auto-scaling.
        """
        return pulumi.get(self, "disk_gb_enabled")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsResult(dict):
    def __init__(__self__, *,
                 instance_size: str,
                 disk_iops: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 node_count: Optional[int] = None):
        """
        :param str instance_size: Hardware specification for the instance sizes in this region.
        :param int disk_iops: Target throughput (IOPS) desired for AWS storage attached to your cluster.
        :param str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster.
        :param int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        GetAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_size=instance_size,
            disk_iops=disk_iops,
            ebs_volume_type=ebs_volume_type,
            node_count=node_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_size: str,
             disk_iops: Optional[int] = None,
             ebs_volume_type: Optional[str] = None,
             node_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("instance_size", instance_size)
        if disk_iops is not None:
            _setter("disk_iops", disk_iops)
        if ebs_volume_type is not None:
            _setter("ebs_volume_type", ebs_volume_type)
        if node_count is not None:
            _setter("node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[int]:
        """
        Target throughput (IOPS) desired for AWS storage attached to your cluster.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster.
        """
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecRegionConfigAutoScalingResult(dict):
    def __init__(__self__, *,
                 compute_enabled: bool,
                 compute_max_instance_size: str,
                 compute_min_instance_size: str,
                 compute_scale_down_enabled: bool,
                 disk_gb_enabled: bool):
        """
        :param bool compute_enabled: Flag that indicates whether instance size auto-scaling is enabled.
        :param str compute_max_instance_size: Maximum instance size to which your cluster can automatically scale (such as M40). 
               #### Advanced Configuration
        :param str compute_min_instance_size: Minimum instance size to which your cluster can automatically scale (such as M10).
        :param bool compute_scale_down_enabled: Flag that indicates whether the instance size may scale down.
        :param bool disk_gb_enabled: Flag that indicates whether this cluster enables disk auto-scaling.
        """
        GetAdvancedClusterReplicationSpecRegionConfigAutoScalingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compute_enabled=compute_enabled,
            compute_max_instance_size=compute_max_instance_size,
            compute_min_instance_size=compute_min_instance_size,
            compute_scale_down_enabled=compute_scale_down_enabled,
            disk_gb_enabled=disk_gb_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compute_enabled: bool,
             compute_max_instance_size: str,
             compute_min_instance_size: str,
             compute_scale_down_enabled: bool,
             disk_gb_enabled: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("compute_enabled", compute_enabled)
        _setter("compute_max_instance_size", compute_max_instance_size)
        _setter("compute_min_instance_size", compute_min_instance_size)
        _setter("compute_scale_down_enabled", compute_scale_down_enabled)
        _setter("disk_gb_enabled", disk_gb_enabled)

    @property
    @pulumi.getter(name="computeEnabled")
    def compute_enabled(self) -> bool:
        """
        Flag that indicates whether instance size auto-scaling is enabled.
        """
        return pulumi.get(self, "compute_enabled")

    @property
    @pulumi.getter(name="computeMaxInstanceSize")
    def compute_max_instance_size(self) -> str:
        """
        Maximum instance size to which your cluster can automatically scale (such as M40). 
        #### Advanced Configuration
        """
        return pulumi.get(self, "compute_max_instance_size")

    @property
    @pulumi.getter(name="computeMinInstanceSize")
    def compute_min_instance_size(self) -> str:
        """
        Minimum instance size to which your cluster can automatically scale (such as M10).
        """
        return pulumi.get(self, "compute_min_instance_size")

    @property
    @pulumi.getter(name="computeScaleDownEnabled")
    def compute_scale_down_enabled(self) -> bool:
        """
        Flag that indicates whether the instance size may scale down.
        """
        return pulumi.get(self, "compute_scale_down_enabled")

    @property
    @pulumi.getter(name="diskGbEnabled")
    def disk_gb_enabled(self) -> bool:
        """
        Flag that indicates whether this cluster enables disk auto-scaling.
        """
        return pulumi.get(self, "disk_gb_enabled")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecRegionConfigElectableSpecsResult(dict):
    def __init__(__self__, *,
                 instance_size: str,
                 disk_iops: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 node_count: Optional[int] = None):
        """
        :param str instance_size: Hardware specification for the instance sizes in this region.
        :param int disk_iops: Target throughput (IOPS) desired for AWS storage attached to your cluster.
        :param str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster.
        :param int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        GetAdvancedClusterReplicationSpecRegionConfigElectableSpecsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_size=instance_size,
            disk_iops=disk_iops,
            ebs_volume_type=ebs_volume_type,
            node_count=node_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_size: str,
             disk_iops: Optional[int] = None,
             ebs_volume_type: Optional[str] = None,
             node_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("instance_size", instance_size)
        if disk_iops is not None:
            _setter("disk_iops", disk_iops)
        if ebs_volume_type is not None:
            _setter("ebs_volume_type", ebs_volume_type)
        if node_count is not None:
            _setter("node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[int]:
        """
        Target throughput (IOPS) desired for AWS storage attached to your cluster.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster.
        """
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecRegionConfigReadOnlySpecsResult(dict):
    def __init__(__self__, *,
                 instance_size: str,
                 disk_iops: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 node_count: Optional[int] = None):
        """
        :param str instance_size: Hardware specification for the instance sizes in this region.
        :param int disk_iops: Target throughput (IOPS) desired for AWS storage attached to your cluster.
        :param str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster.
        :param int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        GetAdvancedClusterReplicationSpecRegionConfigReadOnlySpecsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_size=instance_size,
            disk_iops=disk_iops,
            ebs_volume_type=ebs_volume_type,
            node_count=node_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_size: str,
             disk_iops: Optional[int] = None,
             ebs_volume_type: Optional[str] = None,
             node_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("instance_size", instance_size)
        if disk_iops is not None:
            _setter("disk_iops", disk_iops)
        if ebs_volume_type is not None:
            _setter("ebs_volume_type", ebs_volume_type)
        if node_count is not None:
            _setter("node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[int]:
        """
        Target throughput (IOPS) desired for AWS storage attached to your cluster.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster.
        """
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAdvancedClusterTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        GetAdvancedClusterTagResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAdvancedClustersResultResult(dict):
    def __init__(__self__, *,
                 advanced_configurations: Sequence['outputs.GetAdvancedClustersResultAdvancedConfigurationResult'],
                 backup_enabled: bool,
                 bi_connector_configs: Sequence['outputs.GetAdvancedClustersResultBiConnectorConfigResult'],
                 cluster_type: str,
                 connection_strings: Sequence['outputs.GetAdvancedClustersResultConnectionStringResult'],
                 create_date: str,
                 disk_size_gb: float,
                 encryption_at_rest_provider: str,
                 labels: Sequence['outputs.GetAdvancedClustersResultLabelResult'],
                 mongo_db_major_version: str,
                 mongo_db_version: str,
                 name: str,
                 paused: bool,
                 pit_enabled: bool,
                 replication_specs: Sequence['outputs.GetAdvancedClustersResultReplicationSpecResult'],
                 root_cert_type: str,
                 state_name: str,
                 tags: Sequence['outputs.GetAdvancedClustersResultTagResult'],
                 termination_protection_enabled: bool,
                 version_release_system: str):
        """
        :param Sequence['GetAdvancedClustersResultAdvancedConfigurationArgs'] advanced_configurations: Get the advanced configuration options. See Advanced Configuration below for more details.
        :param Sequence['GetAdvancedClustersResultBiConnectorConfigArgs'] bi_connector_configs: Configuration settings applied to BI Connector for Atlas on this cluster. See below. **NOTE** Prior version of provider had parameter as `bi_connector`
        :param str cluster_type: Type of the cluster that you want to create.
        :param Sequence['GetAdvancedClustersResultConnectionStringArgs'] connection_strings: Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.
        :param float disk_size_gb: Capacity, in gigabytes, of the host's root volume.
        :param str encryption_at_rest_provider: Possible values are AWS, GCP, AZURE or NONE.
        :param Sequence['GetAdvancedClustersResultLabelArgs'] labels: Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.
        :param str mongo_db_major_version: Version of the cluster to deploy.
        :param str mongo_db_version: Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.
        :param bool paused: Flag that indicates whether the cluster is paused or not.
        :param bool pit_enabled: Flag that indicates if the cluster uses Continuous Cloud Backup.
        :param Sequence['GetAdvancedClustersResultReplicationSpecArgs'] replication_specs: Configuration for cluster regions and the hardware provisioned in them. See below
        :param str root_cert_type: Certificate Authority that MongoDB Atlas clusters use.
        :param str state_name: Current state of the cluster. The possible states are:
        :param Sequence['GetAdvancedClustersResultTagArgs'] tags: Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.
        :param bool termination_protection_enabled: Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.
        :param str version_release_system: Release cadence that Atlas uses for this cluster.
        """
        GetAdvancedClustersResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            advanced_configurations=advanced_configurations,
            backup_enabled=backup_enabled,
            bi_connector_configs=bi_connector_configs,
            cluster_type=cluster_type,
            connection_strings=connection_strings,
            create_date=create_date,
            disk_size_gb=disk_size_gb,
            encryption_at_rest_provider=encryption_at_rest_provider,
            labels=labels,
            mongo_db_major_version=mongo_db_major_version,
            mongo_db_version=mongo_db_version,
            name=name,
            paused=paused,
            pit_enabled=pit_enabled,
            replication_specs=replication_specs,
            root_cert_type=root_cert_type,
            state_name=state_name,
            tags=tags,
            termination_protection_enabled=termination_protection_enabled,
            version_release_system=version_release_system,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             advanced_configurations: Sequence['outputs.GetAdvancedClustersResultAdvancedConfigurationResult'],
             backup_enabled: bool,
             bi_connector_configs: Sequence['outputs.GetAdvancedClustersResultBiConnectorConfigResult'],
             cluster_type: str,
             connection_strings: Sequence['outputs.GetAdvancedClustersResultConnectionStringResult'],
             create_date: str,
             disk_size_gb: float,
             encryption_at_rest_provider: str,
             labels: Sequence['outputs.GetAdvancedClustersResultLabelResult'],
             mongo_db_major_version: str,
             mongo_db_version: str,
             name: str,
             paused: bool,
             pit_enabled: bool,
             replication_specs: Sequence['outputs.GetAdvancedClustersResultReplicationSpecResult'],
             root_cert_type: str,
             state_name: str,
             tags: Sequence['outputs.GetAdvancedClustersResultTagResult'],
             termination_protection_enabled: bool,
             version_release_system: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("advanced_configurations", advanced_configurations)
        _setter("backup_enabled", backup_enabled)
        _setter("bi_connector_configs", bi_connector_configs)
        _setter("cluster_type", cluster_type)
        _setter("connection_strings", connection_strings)
        _setter("create_date", create_date)
        _setter("disk_size_gb", disk_size_gb)
        _setter("encryption_at_rest_provider", encryption_at_rest_provider)
        _setter("labels", labels)
        _setter("mongo_db_major_version", mongo_db_major_version)
        _setter("mongo_db_version", mongo_db_version)
        _setter("name", name)
        _setter("paused", paused)
        _setter("pit_enabled", pit_enabled)
        _setter("replication_specs", replication_specs)
        _setter("root_cert_type", root_cert_type)
        _setter("state_name", state_name)
        _setter("tags", tags)
        _setter("termination_protection_enabled", termination_protection_enabled)
        _setter("version_release_system", version_release_system)

    @property
    @pulumi.getter(name="advancedConfigurations")
    def advanced_configurations(self) -> Sequence['outputs.GetAdvancedClustersResultAdvancedConfigurationResult']:
        """
        Get the advanced configuration options. See Advanced Configuration below for more details.
        """
        return pulumi.get(self, "advanced_configurations")

    @property
    @pulumi.getter(name="backupEnabled")
    def backup_enabled(self) -> bool:
        return pulumi.get(self, "backup_enabled")

    @property
    @pulumi.getter(name="biConnectorConfigs")
    def bi_connector_configs(self) -> Sequence['outputs.GetAdvancedClustersResultBiConnectorConfigResult']:
        """
        Configuration settings applied to BI Connector for Atlas on this cluster. See below. **NOTE** Prior version of provider had parameter as `bi_connector`
        """
        return pulumi.get(self, "bi_connector_configs")

    @property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> str:
        """
        Type of the cluster that you want to create.
        """
        return pulumi.get(self, "cluster_type")

    @property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Sequence['outputs.GetAdvancedClustersResultConnectionStringResult']:
        """
        Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.
        """
        return pulumi.get(self, "connection_strings")

    @property
    @pulumi.getter(name="createDate")
    def create_date(self) -> str:
        return pulumi.get(self, "create_date")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> float:
        """
        Capacity, in gigabytes, of the host's root volume.
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter(name="encryptionAtRestProvider")
    def encryption_at_rest_provider(self) -> str:
        """
        Possible values are AWS, GCP, AZURE or NONE.
        """
        return pulumi.get(self, "encryption_at_rest_provider")

    @property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetAdvancedClustersResultLabelResult']:
        """
        Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.
        """
        warnings.warn("""this parameter is deprecated and will be removed by September 2024, please transition to tags""", DeprecationWarning)
        pulumi.log.warn("""labels is deprecated: this parameter is deprecated and will be removed by September 2024, please transition to tags""")

        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="mongoDbMajorVersion")
    def mongo_db_major_version(self) -> str:
        """
        Version of the cluster to deploy.
        """
        return pulumi.get(self, "mongo_db_major_version")

    @property
    @pulumi.getter(name="mongoDbVersion")
    def mongo_db_version(self) -> str:
        """
        Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.
        """
        return pulumi.get(self, "mongo_db_version")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def paused(self) -> bool:
        """
        Flag that indicates whether the cluster is paused or not.
        """
        return pulumi.get(self, "paused")

    @property
    @pulumi.getter(name="pitEnabled")
    def pit_enabled(self) -> bool:
        """
        Flag that indicates if the cluster uses Continuous Cloud Backup.
        """
        return pulumi.get(self, "pit_enabled")

    @property
    @pulumi.getter(name="replicationSpecs")
    def replication_specs(self) -> Sequence['outputs.GetAdvancedClustersResultReplicationSpecResult']:
        """
        Configuration for cluster regions and the hardware provisioned in them. See below
        """
        return pulumi.get(self, "replication_specs")

    @property
    @pulumi.getter(name="rootCertType")
    def root_cert_type(self) -> str:
        """
        Certificate Authority that MongoDB Atlas clusters use.
        """
        return pulumi.get(self, "root_cert_type")

    @property
    @pulumi.getter(name="stateName")
    def state_name(self) -> str:
        """
        Current state of the cluster. The possible states are:
        """
        return pulumi.get(self, "state_name")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetAdvancedClustersResultTagResult']:
        """
        Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="terminationProtectionEnabled")
    def termination_protection_enabled(self) -> bool:
        """
        Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.
        """
        return pulumi.get(self, "termination_protection_enabled")

    @property
    @pulumi.getter(name="versionReleaseSystem")
    def version_release_system(self) -> str:
        """
        Release cadence that Atlas uses for this cluster.
        """
        return pulumi.get(self, "version_release_system")


@pulumi.output_type
class GetAdvancedClustersResultAdvancedConfigurationResult(dict):
    def __init__(__self__, *,
                 default_read_concern: str,
                 default_write_concern: str,
                 fail_index_key_too_long: bool,
                 javascript_enabled: bool,
                 minimum_enabled_tls_protocol: str,
                 no_table_scan: bool,
                 oplog_min_retention_hours: int,
                 oplog_size_mb: int,
                 sample_refresh_interval_bi_connector: int,
                 sample_size_bi_connector: int,
                 transaction_lifetime_limit_seconds: int):
        """
        :param str default_read_concern: [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        :param str default_write_concern: [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        :param bool fail_index_key_too_long: When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        :param bool javascript_enabled: When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        :param str minimum_enabled_tls_protocol: Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        :param bool no_table_scan: When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        :param int oplog_min_retention_hours: Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        :param int oplog_size_mb: The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        :param int sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param int sample_size_bi_connector: Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        GetAdvancedClustersResultAdvancedConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_read_concern=default_read_concern,
            default_write_concern=default_write_concern,
            fail_index_key_too_long=fail_index_key_too_long,
            javascript_enabled=javascript_enabled,
            minimum_enabled_tls_protocol=minimum_enabled_tls_protocol,
            no_table_scan=no_table_scan,
            oplog_min_retention_hours=oplog_min_retention_hours,
            oplog_size_mb=oplog_size_mb,
            sample_refresh_interval_bi_connector=sample_refresh_interval_bi_connector,
            sample_size_bi_connector=sample_size_bi_connector,
            transaction_lifetime_limit_seconds=transaction_lifetime_limit_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_read_concern: str,
             default_write_concern: str,
             fail_index_key_too_long: bool,
             javascript_enabled: bool,
             minimum_enabled_tls_protocol: str,
             no_table_scan: bool,
             oplog_min_retention_hours: int,
             oplog_size_mb: int,
             sample_refresh_interval_bi_connector: int,
             sample_size_bi_connector: int,
             transaction_lifetime_limit_seconds: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("default_read_concern", default_read_concern)
        _setter("default_write_concern", default_write_concern)
        _setter("fail_index_key_too_long", fail_index_key_too_long)
        _setter("javascript_enabled", javascript_enabled)
        _setter("minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        _setter("no_table_scan", no_table_scan)
        _setter("oplog_min_retention_hours", oplog_min_retention_hours)
        _setter("oplog_size_mb", oplog_size_mb)
        _setter("sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        _setter("sample_size_bi_connector", sample_size_bi_connector)
        _setter("transaction_lifetime_limit_seconds", transaction_lifetime_limit_seconds)

    @property
    @pulumi.getter(name="defaultReadConcern")
    def default_read_concern(self) -> str:
        """
        [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        """
        return pulumi.get(self, "default_read_concern")

    @property
    @pulumi.getter(name="defaultWriteConcern")
    def default_write_concern(self) -> str:
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        return pulumi.get(self, "default_write_concern")

    @property
    @pulumi.getter(name="failIndexKeyTooLong")
    def fail_index_key_too_long(self) -> bool:
        """
        When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        """
        return pulumi.get(self, "fail_index_key_too_long")

    @property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> bool:
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        return pulumi.get(self, "javascript_enabled")

    @property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> str:
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> bool:
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        return pulumi.get(self, "no_table_scan")

    @property
    @pulumi.getter(name="oplogMinRetentionHours")
    def oplog_min_retention_hours(self) -> int:
        """
        Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        """
        return pulumi.get(self, "oplog_min_retention_hours")

    @property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> int:
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        return pulumi.get(self, "oplog_size_mb")

    @property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> int:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> int:
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_size_bi_connector")

    @property
    @pulumi.getter(name="transactionLifetimeLimitSeconds")
    def transaction_lifetime_limit_seconds(self) -> int:
        return pulumi.get(self, "transaction_lifetime_limit_seconds")


@pulumi.output_type
class GetAdvancedClustersResultBiConnectorConfigResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 read_preference: str):
        """
        :param bool enabled: Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
        :param str read_preference: Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        GetAdvancedClustersResultBiConnectorConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            read_preference=read_preference,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: bool,
             read_preference: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("enabled", enabled)
        _setter("read_preference", read_preference)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> str:
        """
        Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        return pulumi.get(self, "read_preference")


@pulumi.output_type
class GetAdvancedClustersResultConnectionStringResult(dict):
    def __init__(__self__, *,
                 private: str,
                 private_endpoints: Sequence['outputs.GetAdvancedClustersResultConnectionStringPrivateEndpointResult'],
                 private_srv: str,
                 standard: str,
                 standard_srv: str):
        GetAdvancedClustersResultConnectionStringResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private=private,
            private_endpoints=private_endpoints,
            private_srv=private_srv,
            standard=standard,
            standard_srv=standard_srv,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private: str,
             private_endpoints: Sequence['outputs.GetAdvancedClustersResultConnectionStringPrivateEndpointResult'],
             private_srv: str,
             standard: str,
             standard_srv: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("private", private)
        _setter("private_endpoints", private_endpoints)
        _setter("private_srv", private_srv)
        _setter("standard", standard)
        _setter("standard_srv", standard_srv)

    @property
    @pulumi.getter
    def private(self) -> str:
        return pulumi.get(self, "private")

    @property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Sequence['outputs.GetAdvancedClustersResultConnectionStringPrivateEndpointResult']:
        return pulumi.get(self, "private_endpoints")

    @property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> str:
        return pulumi.get(self, "private_srv")

    @property
    @pulumi.getter
    def standard(self) -> str:
        return pulumi.get(self, "standard")

    @property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> str:
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class GetAdvancedClustersResultConnectionStringPrivateEndpointResult(dict):
    def __init__(__self__, *,
                 connection_string: str,
                 endpoints: Sequence['outputs.GetAdvancedClustersResultConnectionStringPrivateEndpointEndpointResult'],
                 srv_connection_string: str,
                 srv_shard_optimized_connection_string: str,
                 type: str):
        GetAdvancedClustersResultConnectionStringPrivateEndpointResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_string=connection_string,
            endpoints=endpoints,
            srv_connection_string=srv_connection_string,
            srv_shard_optimized_connection_string=srv_shard_optimized_connection_string,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_string: str,
             endpoints: Sequence['outputs.GetAdvancedClustersResultConnectionStringPrivateEndpointEndpointResult'],
             srv_connection_string: str,
             srv_shard_optimized_connection_string: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("connection_string", connection_string)
        _setter("endpoints", endpoints)
        _setter("srv_connection_string", srv_connection_string)
        _setter("srv_shard_optimized_connection_string", srv_shard_optimized_connection_string)
        _setter("type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> str:
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def endpoints(self) -> Sequence['outputs.GetAdvancedClustersResultConnectionStringPrivateEndpointEndpointResult']:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> str:
        return pulumi.get(self, "srv_connection_string")

    @property
    @pulumi.getter(name="srvShardOptimizedConnectionString")
    def srv_shard_optimized_connection_string(self) -> str:
        return pulumi.get(self, "srv_shard_optimized_connection_string")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAdvancedClustersResultConnectionStringPrivateEndpointEndpointResult(dict):
    def __init__(__self__, *,
                 endpoint_id: str,
                 provider_name: str,
                 region: str):
        """
        :param str provider_name: Cloud service provider on which the servers are provisioned.
        """
        GetAdvancedClustersResultConnectionStringPrivateEndpointEndpointResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_id=endpoint_id,
            provider_name=provider_name,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_id: str,
             provider_name: str,
             region: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("endpoint_id", endpoint_id)
        _setter("provider_name", provider_name)
        _setter("region", region)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> str:
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetAdvancedClustersResultLabelResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        GetAdvancedClustersResultLabelResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecResult(dict):
    def __init__(__self__, *,
                 container_id: Mapping[str, str],
                 id: str,
                 num_shards: int,
                 region_configs: Sequence['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigResult'],
                 zone_name: str):
        """
        :param Mapping[str, str] container_id: A key-value map of the Network Peering Container ID(s) for the configuration specified in `region_configs`. The Container ID is the id of the container either created programmatically by the user before any clusters existed in a project or when the first cluster in the region (AWS/Azure) or project (GCP) was created.  The syntax is `"providerName:regionName" = "containerId"`. Example `AWS:US_EAST_1" = "61e0797dde08fb498ca11a71`.
        :param int num_shards: Provide this value if you set a `cluster_type` of SHARDED or GEOSHARDED.
        :param Sequence['GetAdvancedClustersResultReplicationSpecRegionConfigArgs'] region_configs: Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below
        :param str zone_name: Name for the zone in a Global Cluster.
        """
        GetAdvancedClustersResultReplicationSpecResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            container_id=container_id,
            id=id,
            num_shards=num_shards,
            region_configs=region_configs,
            zone_name=zone_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             container_id: Mapping[str, str],
             id: str,
             num_shards: int,
             region_configs: Sequence['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigResult'],
             zone_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("container_id", container_id)
        _setter("id", id)
        _setter("num_shards", num_shards)
        _setter("region_configs", region_configs)
        _setter("zone_name", zone_name)

    @property
    @pulumi.getter(name="containerId")
    def container_id(self) -> Mapping[str, str]:
        """
        A key-value map of the Network Peering Container ID(s) for the configuration specified in `region_configs`. The Container ID is the id of the container either created programmatically by the user before any clusters existed in a project or when the first cluster in the region (AWS/Azure) or project (GCP) was created.  The syntax is `"providerName:regionName" = "containerId"`. Example `AWS:US_EAST_1" = "61e0797dde08fb498ca11a71`.
        """
        return pulumi.get(self, "container_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> int:
        """
        Provide this value if you set a `cluster_type` of SHARDED or GEOSHARDED.
        """
        return pulumi.get(self, "num_shards")

    @property
    @pulumi.getter(name="regionConfigs")
    def region_configs(self) -> Sequence['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigResult']:
        """
        Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below
        """
        return pulumi.get(self, "region_configs")

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> str:
        """
        Name for the zone in a Global Cluster.
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecRegionConfigResult(dict):
    def __init__(__self__, *,
                 analytics_auto_scalings: Sequence['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsAutoScalingResult'],
                 auto_scalings: Sequence['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigAutoScalingResult'],
                 backing_provider_name: str,
                 priority: int,
                 provider_name: str,
                 region_name: str,
                 analytics_specs: Optional['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecsResult'] = None,
                 electable_specs: Optional['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigElectableSpecsResult'] = None,
                 read_only_specs: Optional['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecsResult'] = None):
        """
        :param Sequence['GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsAutoScalingArgs'] analytics_auto_scalings: Configuration for the Collection of settings that configures analytis-auto-scaling information for the cluster. See below
        :param Sequence['GetAdvancedClustersResultReplicationSpecRegionConfigAutoScalingArgs'] auto_scalings: Configuration for the Collection of settings that configures auto-scaling information for the cluster. See below
        :param str backing_provider_name: Cloud service provider on which you provision the host for a multi-tenant cluster.
        :param int priority: Election priority of the region.
        :param str provider_name: Cloud service provider on which the servers are provisioned.
        :param str region_name: Physical location of your MongoDB cluster.
        :param 'GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecsArgs' analytics_specs: Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. See below
        :param 'GetAdvancedClustersResultReplicationSpecRegionConfigElectableSpecsArgs' electable_specs: Hardware specifications for electable nodes in the region.
        :param 'GetAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecsArgs' read_only_specs: Hardware specifications for read-only nodes in the region. See below
        """
        GetAdvancedClustersResultReplicationSpecRegionConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            analytics_auto_scalings=analytics_auto_scalings,
            auto_scalings=auto_scalings,
            backing_provider_name=backing_provider_name,
            priority=priority,
            provider_name=provider_name,
            region_name=region_name,
            analytics_specs=analytics_specs,
            electable_specs=electable_specs,
            read_only_specs=read_only_specs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             analytics_auto_scalings: Sequence['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsAutoScalingResult'],
             auto_scalings: Sequence['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigAutoScalingResult'],
             backing_provider_name: str,
             priority: int,
             provider_name: str,
             region_name: str,
             analytics_specs: Optional['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecsResult'] = None,
             electable_specs: Optional['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigElectableSpecsResult'] = None,
             read_only_specs: Optional['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecsResult'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("analytics_auto_scalings", analytics_auto_scalings)
        _setter("auto_scalings", auto_scalings)
        _setter("backing_provider_name", backing_provider_name)
        _setter("priority", priority)
        _setter("provider_name", provider_name)
        _setter("region_name", region_name)
        if analytics_specs is not None:
            _setter("analytics_specs", analytics_specs)
        if electable_specs is not None:
            _setter("electable_specs", electable_specs)
        if read_only_specs is not None:
            _setter("read_only_specs", read_only_specs)

    @property
    @pulumi.getter(name="analyticsAutoScalings")
    def analytics_auto_scalings(self) -> Sequence['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsAutoScalingResult']:
        """
        Configuration for the Collection of settings that configures analytis-auto-scaling information for the cluster. See below
        """
        return pulumi.get(self, "analytics_auto_scalings")

    @property
    @pulumi.getter(name="autoScalings")
    def auto_scalings(self) -> Sequence['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigAutoScalingResult']:
        """
        Configuration for the Collection of settings that configures auto-scaling information for the cluster. See below
        """
        return pulumi.get(self, "auto_scalings")

    @property
    @pulumi.getter(name="backingProviderName")
    def backing_provider_name(self) -> str:
        """
        Cloud service provider on which you provision the host for a multi-tenant cluster.
        """
        return pulumi.get(self, "backing_provider_name")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Election priority of the region.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        Physical location of your MongoDB cluster.
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter(name="analyticsSpecs")
    def analytics_specs(self) -> Optional['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecsResult']:
        """
        Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. See below
        """
        return pulumi.get(self, "analytics_specs")

    @property
    @pulumi.getter(name="electableSpecs")
    def electable_specs(self) -> Optional['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigElectableSpecsResult']:
        """
        Hardware specifications for electable nodes in the region.
        """
        return pulumi.get(self, "electable_specs")

    @property
    @pulumi.getter(name="readOnlySpecs")
    def read_only_specs(self) -> Optional['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecsResult']:
        """
        Hardware specifications for read-only nodes in the region. See below
        """
        return pulumi.get(self, "read_only_specs")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsAutoScalingResult(dict):
    def __init__(__self__, *,
                 compute_enabled: bool,
                 compute_max_instance_size: str,
                 compute_min_instance_size: str,
                 compute_scale_down_enabled: bool,
                 disk_gb_enabled: bool):
        """
        :param bool compute_enabled: Flag that indicates whether instance size auto-scaling is enabled.
        :param str compute_max_instance_size: Maximum instance size to which your cluster can automatically scale (such as M40).
        :param str compute_min_instance_size: Minimum instance size to which your cluster can automatically scale (such as M10).
        :param bool compute_scale_down_enabled: Flag that indicates whether the instance size may scale down.
        :param bool disk_gb_enabled: Flag that indicates whether this cluster enables disk auto-scaling.
        """
        GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsAutoScalingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compute_enabled=compute_enabled,
            compute_max_instance_size=compute_max_instance_size,
            compute_min_instance_size=compute_min_instance_size,
            compute_scale_down_enabled=compute_scale_down_enabled,
            disk_gb_enabled=disk_gb_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compute_enabled: bool,
             compute_max_instance_size: str,
             compute_min_instance_size: str,
             compute_scale_down_enabled: bool,
             disk_gb_enabled: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("compute_enabled", compute_enabled)
        _setter("compute_max_instance_size", compute_max_instance_size)
        _setter("compute_min_instance_size", compute_min_instance_size)
        _setter("compute_scale_down_enabled", compute_scale_down_enabled)
        _setter("disk_gb_enabled", disk_gb_enabled)

    @property
    @pulumi.getter(name="computeEnabled")
    def compute_enabled(self) -> bool:
        """
        Flag that indicates whether instance size auto-scaling is enabled.
        """
        return pulumi.get(self, "compute_enabled")

    @property
    @pulumi.getter(name="computeMaxInstanceSize")
    def compute_max_instance_size(self) -> str:
        """
        Maximum instance size to which your cluster can automatically scale (such as M40).
        """
        return pulumi.get(self, "compute_max_instance_size")

    @property
    @pulumi.getter(name="computeMinInstanceSize")
    def compute_min_instance_size(self) -> str:
        """
        Minimum instance size to which your cluster can automatically scale (such as M10).
        """
        return pulumi.get(self, "compute_min_instance_size")

    @property
    @pulumi.getter(name="computeScaleDownEnabled")
    def compute_scale_down_enabled(self) -> bool:
        """
        Flag that indicates whether the instance size may scale down.
        """
        return pulumi.get(self, "compute_scale_down_enabled")

    @property
    @pulumi.getter(name="diskGbEnabled")
    def disk_gb_enabled(self) -> bool:
        """
        Flag that indicates whether this cluster enables disk auto-scaling.
        """
        return pulumi.get(self, "disk_gb_enabled")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecsResult(dict):
    def __init__(__self__, *,
                 instance_size: str,
                 disk_iops: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 node_count: Optional[int] = None):
        """
        :param str instance_size: Hardware specification for the instance sizes in this region.
        :param int disk_iops: Target throughput (IOPS) desired for AWS storage attached to your cluster.
        :param str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster.
        :param int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_size=instance_size,
            disk_iops=disk_iops,
            ebs_volume_type=ebs_volume_type,
            node_count=node_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_size: str,
             disk_iops: Optional[int] = None,
             ebs_volume_type: Optional[str] = None,
             node_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("instance_size", instance_size)
        if disk_iops is not None:
            _setter("disk_iops", disk_iops)
        if ebs_volume_type is not None:
            _setter("ebs_volume_type", ebs_volume_type)
        if node_count is not None:
            _setter("node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[int]:
        """
        Target throughput (IOPS) desired for AWS storage attached to your cluster.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster.
        """
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecRegionConfigAutoScalingResult(dict):
    def __init__(__self__, *,
                 compute_enabled: bool,
                 compute_max_instance_size: str,
                 compute_min_instance_size: str,
                 compute_scale_down_enabled: bool,
                 disk_gb_enabled: bool):
        """
        :param bool compute_enabled: Flag that indicates whether instance size auto-scaling is enabled.
        :param str compute_max_instance_size: Maximum instance size to which your cluster can automatically scale (such as M40).
        :param str compute_min_instance_size: Minimum instance size to which your cluster can automatically scale (such as M10).
        :param bool compute_scale_down_enabled: Flag that indicates whether the instance size may scale down.
        :param bool disk_gb_enabled: Flag that indicates whether this cluster enables disk auto-scaling.
        """
        GetAdvancedClustersResultReplicationSpecRegionConfigAutoScalingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compute_enabled=compute_enabled,
            compute_max_instance_size=compute_max_instance_size,
            compute_min_instance_size=compute_min_instance_size,
            compute_scale_down_enabled=compute_scale_down_enabled,
            disk_gb_enabled=disk_gb_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compute_enabled: bool,
             compute_max_instance_size: str,
             compute_min_instance_size: str,
             compute_scale_down_enabled: bool,
             disk_gb_enabled: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("compute_enabled", compute_enabled)
        _setter("compute_max_instance_size", compute_max_instance_size)
        _setter("compute_min_instance_size", compute_min_instance_size)
        _setter("compute_scale_down_enabled", compute_scale_down_enabled)
        _setter("disk_gb_enabled", disk_gb_enabled)

    @property
    @pulumi.getter(name="computeEnabled")
    def compute_enabled(self) -> bool:
        """
        Flag that indicates whether instance size auto-scaling is enabled.
        """
        return pulumi.get(self, "compute_enabled")

    @property
    @pulumi.getter(name="computeMaxInstanceSize")
    def compute_max_instance_size(self) -> str:
        """
        Maximum instance size to which your cluster can automatically scale (such as M40).
        """
        return pulumi.get(self, "compute_max_instance_size")

    @property
    @pulumi.getter(name="computeMinInstanceSize")
    def compute_min_instance_size(self) -> str:
        """
        Minimum instance size to which your cluster can automatically scale (such as M10).
        """
        return pulumi.get(self, "compute_min_instance_size")

    @property
    @pulumi.getter(name="computeScaleDownEnabled")
    def compute_scale_down_enabled(self) -> bool:
        """
        Flag that indicates whether the instance size may scale down.
        """
        return pulumi.get(self, "compute_scale_down_enabled")

    @property
    @pulumi.getter(name="diskGbEnabled")
    def disk_gb_enabled(self) -> bool:
        """
        Flag that indicates whether this cluster enables disk auto-scaling.
        """
        return pulumi.get(self, "disk_gb_enabled")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecRegionConfigElectableSpecsResult(dict):
    def __init__(__self__, *,
                 instance_size: str,
                 disk_iops: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 node_count: Optional[int] = None):
        """
        :param str instance_size: Hardware specification for the instance sizes in this region.
        :param int disk_iops: Target throughput (IOPS) desired for AWS storage attached to your cluster.
        :param str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster.
        :param int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        GetAdvancedClustersResultReplicationSpecRegionConfigElectableSpecsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_size=instance_size,
            disk_iops=disk_iops,
            ebs_volume_type=ebs_volume_type,
            node_count=node_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_size: str,
             disk_iops: Optional[int] = None,
             ebs_volume_type: Optional[str] = None,
             node_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("instance_size", instance_size)
        if disk_iops is not None:
            _setter("disk_iops", disk_iops)
        if ebs_volume_type is not None:
            _setter("ebs_volume_type", ebs_volume_type)
        if node_count is not None:
            _setter("node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[int]:
        """
        Target throughput (IOPS) desired for AWS storage attached to your cluster.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster.
        """
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecsResult(dict):
    def __init__(__self__, *,
                 instance_size: str,
                 disk_iops: Optional[int] = None,
                 ebs_volume_type: Optional[str] = None,
                 node_count: Optional[int] = None):
        """
        :param str instance_size: Hardware specification for the instance sizes in this region.
        :param int disk_iops: Target throughput (IOPS) desired for AWS storage attached to your cluster.
        :param str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster.
        :param int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        GetAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_size=instance_size,
            disk_iops=disk_iops,
            ebs_volume_type=ebs_volume_type,
            node_count=node_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_size: str,
             disk_iops: Optional[int] = None,
             ebs_volume_type: Optional[str] = None,
             node_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("instance_size", instance_size)
        if disk_iops is not None:
            _setter("disk_iops", disk_iops)
        if ebs_volume_type is not None:
            _setter("ebs_volume_type", ebs_volume_type)
        if node_count is not None:
            _setter("node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[int]:
        """
        Target throughput (IOPS) desired for AWS storage attached to your cluster.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster.
        """
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAdvancedClustersResultTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        GetAdvancedClustersResultTagResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAlertConfigurationMatcherResult(dict):
    def __init__(__self__, *,
                 field_name: str,
                 operator: str,
                 value: str):
        """
        :param str field_name: Name of the field in the target object to match on.
        :param str operator: Operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
        :param str value: Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
        """
        GetAlertConfigurationMatcherResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_name=field_name,
            operator=operator,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_name: str,
             operator: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_name", field_name)
        _setter("operator", operator)
        _setter("value", value)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        """
        Name of the field in the target object to match on.
        """
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAlertConfigurationMetricThresholdConfigResult(dict):
    def __init__(__self__, *,
                 metric_name: str,
                 mode: str,
                 operator: str,
                 threshold: float,
                 units: str):
        """
        :param str metric_name: Name of the metric to check. The full list being quite large, please refer to atlas docs [here for general metrics](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types) and [here for serverless metrics](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-create-config/#serverless-measurements)
        :param str mode: This must be set to AVERAGE. Atlas computes the current metric value as an average.
        :param str operator: Operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
        :param float threshold: Threshold value outside of which an alert will be triggered.
        :param str units: The units for the threshold value. Depends on the type of metric.
               Refer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.
        """
        GetAlertConfigurationMetricThresholdConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric_name=metric_name,
            mode=mode,
            operator=operator,
            threshold=threshold,
            units=units,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric_name: str,
             mode: str,
             operator: str,
             threshold: float,
             units: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric_name", metric_name)
        _setter("mode", mode)
        _setter("operator", operator)
        _setter("threshold", threshold)
        _setter("units", units)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        Name of the metric to check. The full list being quite large, please refer to atlas docs [here for general metrics](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types) and [here for serverless metrics](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-create-config/#serverless-measurements)
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        This must be set to AVERAGE. Atlas computes the current metric value as an average.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        Threshold value outside of which an alert will be triggered.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def units(self) -> str:
        """
        The units for the threshold value. Depends on the type of metric.
        Refer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.
        """
        return pulumi.get(self, "units")


@pulumi.output_type
class GetAlertConfigurationNotificationResult(dict):
    def __init__(__self__, *,
                 api_token: str,
                 channel_name: str,
                 datadog_api_key: str,
                 datadog_region: str,
                 delay_min: int,
                 email_address: str,
                 email_enabled: bool,
                 interval_min: int,
                 microsoft_teams_webhook_url: str,
                 mobile_number: str,
                 ops_genie_api_key: str,
                 ops_genie_region: str,
                 roles: Sequence[str],
                 service_key: str,
                 sms_enabled: bool,
                 team_id: str,
                 team_name: str,
                 type_name: str,
                 username: str,
                 victor_ops_api_key: str,
                 victor_ops_routing_key: str,
                 webhook_secret: str,
                 webhook_url: str):
        """
        :param str api_token: Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param str channel_name: Slack channel name. Required for the SLACK notifications type.
        :param str datadog_api_key: Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        :param str datadog_region: Region that indicates which API URL to use. Accepted regions are: `US`, `EU`. The default Datadog region is US.
        :param int delay_min: Number of minutes to wait after an alert condition is detected before sending out the first notification.
        :param str email_address: Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        :param bool email_enabled: Flag indicating email notifications should be sent. Atlas returns this value if `type_name` is set  to `ORG`, `GROUP`, or `USER`.
        :param int interval_min: Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5.
        :param str microsoft_teams_webhook_url: Microsoft Teams channel incoming webhook URL. Required for the `MICROSOFT_TEAMS` notifications type.
        :param str mobile_number: Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        :param str ops_genie_api_key: Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param str ops_genie_region: Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        :param Sequence[str] roles: Atlas role in current Project or Organization. Atlas returns this value if you set `type_name` to `ORG` or `GROUP`.
        :param str service_key: PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param bool sms_enabled: Flag indicating text notifications should be sent. Atlas returns this value if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        :param str team_id: Unique identifier of a team.
        :param str team_name: Label for the team that receives this notification.
        :param str type_name: Type of alert notification.
               Accepted values are:
        :param str username: Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        :param str victor_ops_api_key: VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param str victor_ops_routing_key: VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param str webhook_secret: Authentication secret for the `WEBHOOK` notifications type.
        :param str webhook_url: Target URL  for the `WEBHOOK` notifications type.
        """
        GetAlertConfigurationNotificationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_token=api_token,
            channel_name=channel_name,
            datadog_api_key=datadog_api_key,
            datadog_region=datadog_region,
            delay_min=delay_min,
            email_address=email_address,
            email_enabled=email_enabled,
            interval_min=interval_min,
            microsoft_teams_webhook_url=microsoft_teams_webhook_url,
            mobile_number=mobile_number,
            ops_genie_api_key=ops_genie_api_key,
            ops_genie_region=ops_genie_region,
            roles=roles,
            service_key=service_key,
            sms_enabled=sms_enabled,
            team_id=team_id,
            team_name=team_name,
            type_name=type_name,
            username=username,
            victor_ops_api_key=victor_ops_api_key,
            victor_ops_routing_key=victor_ops_routing_key,
            webhook_secret=webhook_secret,
            webhook_url=webhook_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_token: str,
             channel_name: str,
             datadog_api_key: str,
             datadog_region: str,
             delay_min: int,
             email_address: str,
             email_enabled: bool,
             interval_min: int,
             microsoft_teams_webhook_url: str,
             mobile_number: str,
             ops_genie_api_key: str,
             ops_genie_region: str,
             roles: Sequence[str],
             service_key: str,
             sms_enabled: bool,
             team_id: str,
             team_name: str,
             type_name: str,
             username: str,
             victor_ops_api_key: str,
             victor_ops_routing_key: str,
             webhook_secret: str,
             webhook_url: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("api_token", api_token)
        _setter("channel_name", channel_name)
        _setter("datadog_api_key", datadog_api_key)
        _setter("datadog_region", datadog_region)
        _setter("delay_min", delay_min)
        _setter("email_address", email_address)
        _setter("email_enabled", email_enabled)
        _setter("interval_min", interval_min)
        _setter("microsoft_teams_webhook_url", microsoft_teams_webhook_url)
        _setter("mobile_number", mobile_number)
        _setter("ops_genie_api_key", ops_genie_api_key)
        _setter("ops_genie_region", ops_genie_region)
        _setter("roles", roles)
        _setter("service_key", service_key)
        _setter("sms_enabled", sms_enabled)
        _setter("team_id", team_id)
        _setter("team_name", team_name)
        _setter("type_name", type_name)
        _setter("username", username)
        _setter("victor_ops_api_key", victor_ops_api_key)
        _setter("victor_ops_routing_key", victor_ops_routing_key)
        _setter("webhook_secret", webhook_secret)
        _setter("webhook_url", webhook_url)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> str:
        """
        Slack channel name. Required for the SLACK notifications type.
        """
        return pulumi.get(self, "channel_name")

    @property
    @pulumi.getter(name="datadogApiKey")
    def datadog_api_key(self) -> str:
        """
        Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        """
        return pulumi.get(self, "datadog_api_key")

    @property
    @pulumi.getter(name="datadogRegion")
    def datadog_region(self) -> str:
        """
        Region that indicates which API URL to use. Accepted regions are: `US`, `EU`. The default Datadog region is US.
        """
        return pulumi.get(self, "datadog_region")

    @property
    @pulumi.getter(name="delayMin")
    def delay_min(self) -> int:
        """
        Number of minutes to wait after an alert condition is detected before sending out the first notification.
        """
        return pulumi.get(self, "delay_min")

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> str:
        """
        Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter(name="emailEnabled")
    def email_enabled(self) -> bool:
        """
        Flag indicating email notifications should be sent. Atlas returns this value if `type_name` is set  to `ORG`, `GROUP`, or `USER`.
        """
        return pulumi.get(self, "email_enabled")

    @property
    @pulumi.getter(name="intervalMin")
    def interval_min(self) -> int:
        """
        Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5.
        """
        return pulumi.get(self, "interval_min")

    @property
    @pulumi.getter(name="microsoftTeamsWebhookUrl")
    def microsoft_teams_webhook_url(self) -> str:
        """
        Microsoft Teams channel incoming webhook URL. Required for the `MICROSOFT_TEAMS` notifications type.
        """
        return pulumi.get(self, "microsoft_teams_webhook_url")

    @property
    @pulumi.getter(name="mobileNumber")
    def mobile_number(self) -> str:
        """
        Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        """
        return pulumi.get(self, "mobile_number")

    @property
    @pulumi.getter(name="opsGenieApiKey")
    def ops_genie_api_key(self) -> str:
        """
        Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "ops_genie_api_key")

    @property
    @pulumi.getter(name="opsGenieRegion")
    def ops_genie_region(self) -> str:
        """
        Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        """
        return pulumi.get(self, "ops_genie_region")

    @property
    @pulumi.getter
    def roles(self) -> Sequence[str]:
        """
        Atlas role in current Project or Organization. Atlas returns this value if you set `type_name` to `ORG` or `GROUP`.
        """
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter(name="serviceKey")
    def service_key(self) -> str:
        """
        PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "service_key")

    @property
    @pulumi.getter(name="smsEnabled")
    def sms_enabled(self) -> bool:
        """
        Flag indicating text notifications should be sent. Atlas returns this value if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        """
        return pulumi.get(self, "sms_enabled")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> str:
        """
        Unique identifier of a team.
        """
        return pulumi.get(self, "team_id")

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> str:
        """
        Label for the team that receives this notification.
        """
        return pulumi.get(self, "team_name")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        """
        Type of alert notification.
        Accepted values are:
        """
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="victorOpsApiKey")
    def victor_ops_api_key(self) -> str:
        """
        VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "victor_ops_api_key")

    @property
    @pulumi.getter(name="victorOpsRoutingKey")
    def victor_ops_routing_key(self) -> str:
        """
        VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "victor_ops_routing_key")

    @property
    @pulumi.getter(name="webhookSecret")
    def webhook_secret(self) -> str:
        """
        Authentication secret for the `WEBHOOK` notifications type.
        """
        return pulumi.get(self, "webhook_secret")

    @property
    @pulumi.getter(name="webhookUrl")
    def webhook_url(self) -> str:
        """
        Target URL  for the `WEBHOOK` notifications type.
        """
        return pulumi.get(self, "webhook_url")


@pulumi.output_type
class GetAlertConfigurationOutputResult(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str,
                 label: Optional[str] = None):
        """
        :param str value: Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
        """
        GetAlertConfigurationOutputResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            value=value,
            label=label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             value: str,
             label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        _setter("value", value)
        if label is not None:
            _setter("label", label)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        return pulumi.get(self, "label")


@pulumi.output_type
class GetAlertConfigurationThresholdConfigResult(dict):
    def __init__(__self__, *,
                 operator: str,
                 threshold: float,
                 units: str):
        """
        :param str operator: Operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
        :param float threshold: Threshold value outside of which an alert will be triggered.
        :param str units: The units for the threshold value. Depends on the type of metric.
               Refer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.
        """
        GetAlertConfigurationThresholdConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            threshold=threshold,
            units=units,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: str,
             threshold: float,
             units: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("operator", operator)
        _setter("threshold", threshold)
        _setter("units", units)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        Threshold value outside of which an alert will be triggered.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def units(self) -> str:
        """
        The units for the threshold value. Depends on the type of metric.
        Refer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.
        """
        return pulumi.get(self, "units")


@pulumi.output_type
class GetAlertConfigurationsListOptionResult(dict):
    def __init__(__self__, *,
                 include_count: Optional[bool] = None,
                 items_per_page: Optional[int] = None,
                 page_num: Optional[int] = None):
        GetAlertConfigurationsListOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            include_count=include_count,
            items_per_page=items_per_page,
            page_num=page_num,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             include_count: Optional[bool] = None,
             items_per_page: Optional[int] = None,
             page_num: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if include_count is not None:
            _setter("include_count", include_count)
        if items_per_page is not None:
            _setter("items_per_page", items_per_page)
        if page_num is not None:
            _setter("page_num", page_num)

    @property
    @pulumi.getter(name="includeCount")
    def include_count(self) -> Optional[bool]:
        return pulumi.get(self, "include_count")

    @property
    @pulumi.getter(name="itemsPerPage")
    def items_per_page(self) -> Optional[int]:
        return pulumi.get(self, "items_per_page")

    @property
    @pulumi.getter(name="pageNum")
    def page_num(self) -> Optional[int]:
        return pulumi.get(self, "page_num")


@pulumi.output_type
class GetAlertConfigurationsResultResult(dict):
    def __init__(__self__, *,
                 alert_configuration_id: str,
                 created: str,
                 enabled: bool,
                 event_type: str,
                 id: str,
                 matchers: Sequence['outputs.GetAlertConfigurationsResultMatcherResult'],
                 metric_threshold_configs: Sequence['outputs.GetAlertConfigurationsResultMetricThresholdConfigResult'],
                 notifications: Sequence['outputs.GetAlertConfigurationsResultNotificationResult'],
                 outputs: Sequence['outputs.GetAlertConfigurationsResultOutputResult'],
                 project_id: str,
                 threshold_configs: Sequence['outputs.GetAlertConfigurationsResultThresholdConfigResult'],
                 updated: str):
        """
        :param str alert_configuration_id: The ID of the alert configuration
        :param str created: Timestamp in ISO 8601 date and time format in UTC when this alert configuration was created.
        :param bool enabled: If set to true, the alert configuration is enabled. If enabled is not exported it is set to false.
        :param str event_type: The type of event that will trigger an alert.
        :param Sequence['GetAlertConfigurationsResultMatcherArgs'] matchers: Rules to apply when matching an object against this alert configuration
        :param Sequence['GetAlertConfigurationsResultMetricThresholdConfigArgs'] metric_threshold_configs: The threshold that causes an alert to be triggered. Required if `event_type_name` : `OUTSIDE_METRIC_THRESHOLD` or `OUTSIDE_SERVERLESS_METRIC_THRESHOLD`
        :param Sequence['GetAlertConfigurationsResultOutputArgs'] outputs: Requested output string format for the alert configuration
        :param str project_id: The unique ID for the project to get the alert configurations.
        :param Sequence['GetAlertConfigurationsResultThresholdConfigArgs'] threshold_configs: Threshold that triggers an alert. Required if `event_type_name` is any value other than `OUTSIDE_METRIC_THRESHOLD` or `OUTSIDE_SERVERLESS_METRIC_THRESHOLD`.
        :param str updated: Timestamp in ISO 8601 date and time format in UTC when this alert configuration was last updated.
        """
        GetAlertConfigurationsResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alert_configuration_id=alert_configuration_id,
            created=created,
            enabled=enabled,
            event_type=event_type,
            id=id,
            matchers=matchers,
            metric_threshold_configs=metric_threshold_configs,
            notifications=notifications,
            outputs=outputs,
            project_id=project_id,
            threshold_configs=threshold_configs,
            updated=updated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alert_configuration_id: str,
             created: str,
             enabled: bool,
             event_type: str,
             id: str,
             matchers: Sequence['outputs.GetAlertConfigurationsResultMatcherResult'],
             metric_threshold_configs: Sequence['outputs.GetAlertConfigurationsResultMetricThresholdConfigResult'],
             notifications: Sequence['outputs.GetAlertConfigurationsResultNotificationResult'],
             outputs: Sequence['outputs.GetAlertConfigurationsResultOutputResult'],
             project_id: str,
             threshold_configs: Sequence['outputs.GetAlertConfigurationsResultThresholdConfigResult'],
             updated: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("alert_configuration_id", alert_configuration_id)
        _setter("created", created)
        _setter("enabled", enabled)
        _setter("event_type", event_type)
        _setter("id", id)
        _setter("matchers", matchers)
        _setter("metric_threshold_configs", metric_threshold_configs)
        _setter("notifications", notifications)
        _setter("outputs", outputs)
        _setter("project_id", project_id)
        _setter("threshold_configs", threshold_configs)
        _setter("updated", updated)

    @property
    @pulumi.getter(name="alertConfigurationId")
    def alert_configuration_id(self) -> str:
        """
        The ID of the alert configuration
        """
        return pulumi.get(self, "alert_configuration_id")

    @property
    @pulumi.getter
    def created(self) -> str:
        """
        Timestamp in ISO 8601 date and time format in UTC when this alert configuration was created.
        """
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        If set to true, the alert configuration is enabled. If enabled is not exported it is set to false.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> str:
        """
        The type of event that will trigger an alert.
        """
        return pulumi.get(self, "event_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def matchers(self) -> Sequence['outputs.GetAlertConfigurationsResultMatcherResult']:
        """
        Rules to apply when matching an object against this alert configuration
        """
        return pulumi.get(self, "matchers")

    @property
    @pulumi.getter(name="metricThresholdConfigs")
    def metric_threshold_configs(self) -> Sequence['outputs.GetAlertConfigurationsResultMetricThresholdConfigResult']:
        """
        The threshold that causes an alert to be triggered. Required if `event_type_name` : `OUTSIDE_METRIC_THRESHOLD` or `OUTSIDE_SERVERLESS_METRIC_THRESHOLD`
        """
        return pulumi.get(self, "metric_threshold_configs")

    @property
    @pulumi.getter
    def notifications(self) -> Sequence['outputs.GetAlertConfigurationsResultNotificationResult']:
        return pulumi.get(self, "notifications")

    @property
    @pulumi.getter
    def outputs(self) -> Sequence['outputs.GetAlertConfigurationsResultOutputResult']:
        """
        Requested output string format for the alert configuration
        """
        return pulumi.get(self, "outputs")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project to get the alert configurations.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="thresholdConfigs")
    def threshold_configs(self) -> Sequence['outputs.GetAlertConfigurationsResultThresholdConfigResult']:
        """
        Threshold that triggers an alert. Required if `event_type_name` is any value other than `OUTSIDE_METRIC_THRESHOLD` or `OUTSIDE_SERVERLESS_METRIC_THRESHOLD`.
        """
        return pulumi.get(self, "threshold_configs")

    @property
    @pulumi.getter
    def updated(self) -> str:
        """
        Timestamp in ISO 8601 date and time format in UTC when this alert configuration was last updated.
        """
        return pulumi.get(self, "updated")


@pulumi.output_type
class GetAlertConfigurationsResultMatcherResult(dict):
    def __init__(__self__, *,
                 field_name: str,
                 operator: str,
                 value: str):
        GetAlertConfigurationsResultMatcherResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_name=field_name,
            operator=operator,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_name: str,
             operator: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_name", field_name)
        _setter("operator", operator)
        _setter("value", value)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAlertConfigurationsResultMetricThresholdConfigResult(dict):
    def __init__(__self__, *,
                 metric_name: str,
                 mode: str,
                 operator: str,
                 threshold: float,
                 units: str):
        GetAlertConfigurationsResultMetricThresholdConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric_name=metric_name,
            mode=mode,
            operator=operator,
            threshold=threshold,
            units=units,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric_name: str,
             mode: str,
             operator: str,
             threshold: float,
             units: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric_name", metric_name)
        _setter("mode", mode)
        _setter("operator", operator)
        _setter("threshold", threshold)
        _setter("units", units)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def mode(self) -> str:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def units(self) -> str:
        return pulumi.get(self, "units")


@pulumi.output_type
class GetAlertConfigurationsResultNotificationResult(dict):
    def __init__(__self__, *,
                 api_token: str,
                 channel_name: str,
                 datadog_api_key: str,
                 datadog_region: str,
                 delay_min: int,
                 email_address: str,
                 email_enabled: bool,
                 interval_min: int,
                 microsoft_teams_webhook_url: str,
                 mobile_number: str,
                 ops_genie_api_key: str,
                 ops_genie_region: str,
                 roles: Sequence[str],
                 service_key: str,
                 sms_enabled: bool,
                 team_id: str,
                 team_name: str,
                 type_name: str,
                 username: str,
                 victor_ops_api_key: str,
                 victor_ops_routing_key: str,
                 webhook_secret: str,
                 webhook_url: str):
        GetAlertConfigurationsResultNotificationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_token=api_token,
            channel_name=channel_name,
            datadog_api_key=datadog_api_key,
            datadog_region=datadog_region,
            delay_min=delay_min,
            email_address=email_address,
            email_enabled=email_enabled,
            interval_min=interval_min,
            microsoft_teams_webhook_url=microsoft_teams_webhook_url,
            mobile_number=mobile_number,
            ops_genie_api_key=ops_genie_api_key,
            ops_genie_region=ops_genie_region,
            roles=roles,
            service_key=service_key,
            sms_enabled=sms_enabled,
            team_id=team_id,
            team_name=team_name,
            type_name=type_name,
            username=username,
            victor_ops_api_key=victor_ops_api_key,
            victor_ops_routing_key=victor_ops_routing_key,
            webhook_secret=webhook_secret,
            webhook_url=webhook_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_token: str,
             channel_name: str,
             datadog_api_key: str,
             datadog_region: str,
             delay_min: int,
             email_address: str,
             email_enabled: bool,
             interval_min: int,
             microsoft_teams_webhook_url: str,
             mobile_number: str,
             ops_genie_api_key: str,
             ops_genie_region: str,
             roles: Sequence[str],
             service_key: str,
             sms_enabled: bool,
             team_id: str,
             team_name: str,
             type_name: str,
             username: str,
             victor_ops_api_key: str,
             victor_ops_routing_key: str,
             webhook_secret: str,
             webhook_url: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("api_token", api_token)
        _setter("channel_name", channel_name)
        _setter("datadog_api_key", datadog_api_key)
        _setter("datadog_region", datadog_region)
        _setter("delay_min", delay_min)
        _setter("email_address", email_address)
        _setter("email_enabled", email_enabled)
        _setter("interval_min", interval_min)
        _setter("microsoft_teams_webhook_url", microsoft_teams_webhook_url)
        _setter("mobile_number", mobile_number)
        _setter("ops_genie_api_key", ops_genie_api_key)
        _setter("ops_genie_region", ops_genie_region)
        _setter("roles", roles)
        _setter("service_key", service_key)
        _setter("sms_enabled", sms_enabled)
        _setter("team_id", team_id)
        _setter("team_name", team_name)
        _setter("type_name", type_name)
        _setter("username", username)
        _setter("victor_ops_api_key", victor_ops_api_key)
        _setter("victor_ops_routing_key", victor_ops_routing_key)
        _setter("webhook_secret", webhook_secret)
        _setter("webhook_url", webhook_url)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> str:
        return pulumi.get(self, "channel_name")

    @property
    @pulumi.getter(name="datadogApiKey")
    def datadog_api_key(self) -> str:
        return pulumi.get(self, "datadog_api_key")

    @property
    @pulumi.getter(name="datadogRegion")
    def datadog_region(self) -> str:
        return pulumi.get(self, "datadog_region")

    @property
    @pulumi.getter(name="delayMin")
    def delay_min(self) -> int:
        return pulumi.get(self, "delay_min")

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> str:
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter(name="emailEnabled")
    def email_enabled(self) -> bool:
        return pulumi.get(self, "email_enabled")

    @property
    @pulumi.getter(name="intervalMin")
    def interval_min(self) -> int:
        return pulumi.get(self, "interval_min")

    @property
    @pulumi.getter(name="microsoftTeamsWebhookUrl")
    def microsoft_teams_webhook_url(self) -> str:
        return pulumi.get(self, "microsoft_teams_webhook_url")

    @property
    @pulumi.getter(name="mobileNumber")
    def mobile_number(self) -> str:
        return pulumi.get(self, "mobile_number")

    @property
    @pulumi.getter(name="opsGenieApiKey")
    def ops_genie_api_key(self) -> str:
        return pulumi.get(self, "ops_genie_api_key")

    @property
    @pulumi.getter(name="opsGenieRegion")
    def ops_genie_region(self) -> str:
        return pulumi.get(self, "ops_genie_region")

    @property
    @pulumi.getter
    def roles(self) -> Sequence[str]:
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter(name="serviceKey")
    def service_key(self) -> str:
        return pulumi.get(self, "service_key")

    @property
    @pulumi.getter(name="smsEnabled")
    def sms_enabled(self) -> bool:
        return pulumi.get(self, "sms_enabled")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> str:
        return pulumi.get(self, "team_id")

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> str:
        return pulumi.get(self, "team_name")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="victorOpsApiKey")
    def victor_ops_api_key(self) -> str:
        return pulumi.get(self, "victor_ops_api_key")

    @property
    @pulumi.getter(name="victorOpsRoutingKey")
    def victor_ops_routing_key(self) -> str:
        return pulumi.get(self, "victor_ops_routing_key")

    @property
    @pulumi.getter(name="webhookSecret")
    def webhook_secret(self) -> str:
        return pulumi.get(self, "webhook_secret")

    @property
    @pulumi.getter(name="webhookUrl")
    def webhook_url(self) -> str:
        return pulumi.get(self, "webhook_url")


@pulumi.output_type
class GetAlertConfigurationsResultOutputResult(dict):
    def __init__(__self__, *,
                 label: str,
                 type: str,
                 value: str):
        GetAlertConfigurationsResultOutputResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            label=label,
            type=type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             label: str,
             type: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("label", label)
        _setter("type", type)
        _setter("value", value)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAlertConfigurationsResultThresholdConfigResult(dict):
    def __init__(__self__, *,
                 operator: str,
                 threshold: float,
                 units: str):
        GetAlertConfigurationsResultThresholdConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            threshold=threshold,
            units=units,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: str,
             threshold: float,
             units: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("operator", operator)
        _setter("threshold", threshold)
        _setter("units", units)

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def units(self) -> str:
        return pulumi.get(self, "units")


@pulumi.output_type
class GetApiKeysResultResult(dict):
    def __init__(__self__, *,
                 api_key_id: str,
                 description: str,
                 public_key: str,
                 role_names: Sequence[str]):
        """
        :param str api_key_id: Unique identifier for the API key you want to update. Use the /orgs/{ORG-ID}/apiKeys endpoint to retrieve all API keys to which the authenticated user has access for the specified organization.
        :param str description: Description of this Organization API key.
        :param Sequence[str] role_names: Name of the role. This resource returns all the roles the user has in Atlas.
               
               The following are valid roles:
        """
        GetApiKeysResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_key_id=api_key_id,
            description=description,
            public_key=public_key,
            role_names=role_names,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_key_id: str,
             description: str,
             public_key: str,
             role_names: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("api_key_id", api_key_id)
        _setter("description", description)
        _setter("public_key", public_key)
        _setter("role_names", role_names)

    @property
    @pulumi.getter(name="apiKeyId")
    def api_key_id(self) -> str:
        """
        Unique identifier for the API key you want to update. Use the /orgs/{ORG-ID}/apiKeys endpoint to retrieve all API keys to which the authenticated user has access for the specified organization.
        """
        return pulumi.get(self, "api_key_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of this Organization API key.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> str:
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[str]:
        """
        Name of the role. This resource returns all the roles the user has in Atlas.

        The following are valid roles:
        """
        return pulumi.get(self, "role_names")


@pulumi.output_type
class GetAtlasUserLinkResult(dict):
    def __init__(__self__, *,
                 href: str,
                 rel: str):
        GetAtlasUserLinkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            href=href,
            rel=rel,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             href: str,
             rel: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("href", href)
        _setter("rel", rel)

    @property
    @pulumi.getter
    def href(self) -> str:
        return pulumi.get(self, "href")

    @property
    @pulumi.getter
    def rel(self) -> str:
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetAtlasUserRoleResult(dict):
    def __init__(__self__, *,
                 group_id: str,
                 org_id: str,
                 role_name: str):
        GetAtlasUserRoleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_id=group_id,
            org_id=org_id,
            role_name=role_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_id: str,
             org_id: str,
             role_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("group_id", group_id)
        _setter("org_id", org_id)
        _setter("role_name", role_name)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetAtlasUsersResultResult(dict):
    def __init__(__self__, *,
                 country: str,
                 created_at: str,
                 email_address: str,
                 first_name: str,
                 id: str,
                 last_auth: str,
                 last_name: str,
                 links: Sequence['outputs.GetAtlasUsersResultLinkResult'],
                 mobile_number: str,
                 roles: Sequence['outputs.GetAtlasUsersResultRoleResult'],
                 team_ids: Sequence[str],
                 user_id: str,
                 username: str):
        """
        :param str country: Two alphabet characters that identifies MongoDB Cloud user's geographic location. This parameter uses the ISO 3166-1a2 code format.
        :param str created_at: Date and time when the current account is created. This value is in the ISO 8601 timestamp format in UTC.
        :param str email_address: Email address that belongs to the MongoDB Atlas user.
        :param str first_name: First or given name that belongs to the MongoDB Atlas user.
        :param str last_auth: Date and time when the current account last authenticated. This value is in the ISO 8601 timestamp format in UTC.
        :param str last_name: Last name, family name, or surname that belongs to the MongoDB Atlas user.
        :param str mobile_number: Mobile phone number that belongs to the MongoDB Atlas user.
        :param Sequence[str] team_ids: List of unique 24-hexadecimal digit strings that identifies the teams to which this MongoDB Atlas user belongs.
               * `links.#.href` - Uniform Resource Locator (URL) that points another API resource to which this response has some relationship. This URL often begins with https://cloud.mongodb.com/api/atlas.
               * `links.#.rel` - Uniform Resource Locator (URL) that defines the semantic relationship between this resource and another API resource. This URL often begins with https://cloud.mongodb.com/api/atlas.
               * `roles.#.group_id` - Unique 24-hexadecimal digit string that identifies the project to which this role belongs. You can set a value for this parameter or orgId but not both in the same request.
               * `roles.#.org_id` - Unique 24-hexadecimal digit string that identifies the organization to which this role belongs. You can set a value for this parameter or groupId but not both in the same request.
               * `roles.#.role_name` - Human-readable label that identifies the collection of privileges that MongoDB Atlas grants a specific API key, user, or team. These roles include organization- and project-level roles. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#service-user-roles) describes the valid roles that can be assigned.
        :param str user_id: Unique 24-hexadecimal digit string that identifies this user.
        :param str username: Email address that belongs to the MongoDB Atlas user account. You cannot modify this address after creating the user.
        """
        GetAtlasUsersResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            country=country,
            created_at=created_at,
            email_address=email_address,
            first_name=first_name,
            id=id,
            last_auth=last_auth,
            last_name=last_name,
            links=links,
            mobile_number=mobile_number,
            roles=roles,
            team_ids=team_ids,
            user_id=user_id,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             country: str,
             created_at: str,
             email_address: str,
             first_name: str,
             id: str,
             last_auth: str,
             last_name: str,
             links: Sequence['outputs.GetAtlasUsersResultLinkResult'],
             mobile_number: str,
             roles: Sequence['outputs.GetAtlasUsersResultRoleResult'],
             team_ids: Sequence[str],
             user_id: str,
             username: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("country", country)
        _setter("created_at", created_at)
        _setter("email_address", email_address)
        _setter("first_name", first_name)
        _setter("id", id)
        _setter("last_auth", last_auth)
        _setter("last_name", last_name)
        _setter("links", links)
        _setter("mobile_number", mobile_number)
        _setter("roles", roles)
        _setter("team_ids", team_ids)
        _setter("user_id", user_id)
        _setter("username", username)

    @property
    @pulumi.getter
    def country(self) -> str:
        """
        Two alphabet characters that identifies MongoDB Cloud user's geographic location. This parameter uses the ISO 3166-1a2 code format.
        """
        return pulumi.get(self, "country")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Date and time when the current account is created. This value is in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> str:
        """
        Email address that belongs to the MongoDB Atlas user.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> str:
        """
        First or given name that belongs to the MongoDB Atlas user.
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastAuth")
    def last_auth(self) -> str:
        """
        Date and time when the current account last authenticated. This value is in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "last_auth")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> str:
        """
        Last name, family name, or surname that belongs to the MongoDB Atlas user.
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter
    def links(self) -> Sequence['outputs.GetAtlasUsersResultLinkResult']:
        return pulumi.get(self, "links")

    @property
    @pulumi.getter(name="mobileNumber")
    def mobile_number(self) -> str:
        """
        Mobile phone number that belongs to the MongoDB Atlas user.
        """
        return pulumi.get(self, "mobile_number")

    @property
    @pulumi.getter
    def roles(self) -> Sequence['outputs.GetAtlasUsersResultRoleResult']:
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter(name="teamIds")
    def team_ids(self) -> Sequence[str]:
        """
        List of unique 24-hexadecimal digit strings that identifies the teams to which this MongoDB Atlas user belongs.
        * `links.#.href` - Uniform Resource Locator (URL) that points another API resource to which this response has some relationship. This URL often begins with https://cloud.mongodb.com/api/atlas.
        * `links.#.rel` - Uniform Resource Locator (URL) that defines the semantic relationship between this resource and another API resource. This URL often begins with https://cloud.mongodb.com/api/atlas.
        * `roles.#.group_id` - Unique 24-hexadecimal digit string that identifies the project to which this role belongs. You can set a value for this parameter or orgId but not both in the same request.
        * `roles.#.org_id` - Unique 24-hexadecimal digit string that identifies the organization to which this role belongs. You can set a value for this parameter or groupId but not both in the same request.
        * `roles.#.role_name` - Human-readable label that identifies the collection of privileges that MongoDB Atlas grants a specific API key, user, or team. These roles include organization- and project-level roles. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#service-user-roles) describes the valid roles that can be assigned.
        """
        return pulumi.get(self, "team_ids")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies this user.
        """
        return pulumi.get(self, "user_id")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Email address that belongs to the MongoDB Atlas user account. You cannot modify this address after creating the user.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetAtlasUsersResultLinkResult(dict):
    def __init__(__self__, *,
                 href: str,
                 rel: str):
        GetAtlasUsersResultLinkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            href=href,
            rel=rel,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             href: str,
             rel: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("href", href)
        _setter("rel", rel)

    @property
    @pulumi.getter
    def href(self) -> str:
        return pulumi.get(self, "href")

    @property
    @pulumi.getter
    def rel(self) -> str:
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetAtlasUsersResultRoleResult(dict):
    def __init__(__self__, *,
                 group_id: str,
                 org_id: str,
                 role_name: str):
        """
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization whose users you want to return. Also needed when `team_id` attributes is defined.
        """
        GetAtlasUsersResultRoleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_id=group_id,
            org_id=org_id,
            role_name=role_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_id: str,
             org_id: str,
             role_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("group_id", group_id)
        _setter("org_id", org_id)
        _setter("role_name", role_name)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization whose users you want to return. Also needed when `team_id` attributes is defined.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetBackupCompliancePolicyOnDemandPolicyItemResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        :param str frequency_type: Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, or `months`.
        :param int retention_value: Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        """
        GetBackupCompliancePolicyOnDemandPolicyItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frequency_interval=frequency_interval,
            frequency_type=frequency_type,
            id=id,
            retention_unit=retention_unit,
            retention_value=retention_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frequency_interval: int,
             frequency_type: str,
             id: str,
             retention_unit: str,
             retention_value: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("frequency_interval", frequency_interval)
        _setter("frequency_type", frequency_type)
        _setter("id", id)
        _setter("retention_unit", retention_unit)
        _setter("retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        """
        Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, or `months`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetBackupCompliancePolicyPolicyItemDailyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        :param str frequency_type: Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, or `months`.
        :param int retention_value: Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        """
        GetBackupCompliancePolicyPolicyItemDailyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frequency_interval=frequency_interval,
            frequency_type=frequency_type,
            id=id,
            retention_unit=retention_unit,
            retention_value=retention_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frequency_interval: int,
             frequency_type: str,
             id: str,
             retention_unit: str,
             retention_value: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("frequency_interval", frequency_interval)
        _setter("frequency_type", frequency_type)
        _setter("id", id)
        _setter("retention_unit", retention_unit)
        _setter("retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        """
        Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, or `months`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetBackupCompliancePolicyPolicyItemHourlyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        :param str frequency_type: Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, or `months`.
        :param int retention_value: Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        """
        GetBackupCompliancePolicyPolicyItemHourlyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frequency_interval=frequency_interval,
            frequency_type=frequency_type,
            id=id,
            retention_unit=retention_unit,
            retention_value=retention_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frequency_interval: int,
             frequency_type: str,
             id: str,
             retention_unit: str,
             retention_value: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("frequency_interval", frequency_interval)
        _setter("frequency_type", frequency_type)
        _setter("id", id)
        _setter("retention_unit", retention_unit)
        _setter("retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        """
        Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, or `months`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetBackupCompliancePolicyPolicyItemMonthlyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        :param str frequency_type: Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, or `months`.
        :param int retention_value: Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        """
        GetBackupCompliancePolicyPolicyItemMonthlyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frequency_interval=frequency_interval,
            frequency_type=frequency_type,
            id=id,
            retention_unit=retention_unit,
            retention_value=retention_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frequency_interval: int,
             frequency_type: str,
             id: str,
             retention_unit: str,
             retention_value: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("frequency_interval", frequency_interval)
        _setter("frequency_type", frequency_type)
        _setter("id", id)
        _setter("retention_unit", retention_unit)
        _setter("retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        """
        Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, or `months`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetBackupCompliancePolicyPolicyItemWeeklyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        :param str frequency_type: Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, or `months`.
        :param int retention_value: Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        """
        GetBackupCompliancePolicyPolicyItemWeeklyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frequency_interval=frequency_interval,
            frequency_type=frequency_type,
            id=id,
            retention_unit=retention_unit,
            retention_value=retention_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frequency_interval: int,
             frequency_type: str,
             id: str,
             retention_unit: str,
             retention_value: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("frequency_interval", frequency_interval)
        _setter("frequency_type", frequency_type)
        _setter("id", id)
        _setter("retention_unit", retention_unit)
        _setter("retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        """
        Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, or `months`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetCloudBackupScheduleCopySettingResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 frequencies: Sequence[str],
                 region_name: str,
                 replication_spec_id: str,
                 should_copy_oplogs: bool):
        """
        :param str cloud_provider: Human-readable label that identifies the cloud provider that stores the snapshot copy. i.e. "AWS" "AZURE" "GCP"
        :param Sequence[str] frequencies: List that describes which types of snapshots to copy. i.e. "HOURLY" "DAILY" "WEEKLY" "MONTHLY" "ON_DEMAND"
        :param str region_name: Target region to copy snapshots belonging to replicationSpecId to. Please supply the 'Atlas Region' which can be found under https://www.mongodb.com/docs/atlas/reference/cloud-providers/ 'regions' link
        :param str replication_spec_id: Unique 24-hexadecimal digit string that identifies the replication object for a zone in a cluster. For global clusters, there can be multiple zones to choose from. For sharded clusters and replica set clusters, there is only one zone in the cluster. To find the Replication Spec Id, consult the replicationSpecs array returned from [Return One Multi-Cloud Cluster in One Project](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Clusters/operation/getCluster).
        :param bool should_copy_oplogs: Flag that indicates whether to copy the oplogs to the target region. You can use the oplogs to perform point-in-time restores.
        """
        GetCloudBackupScheduleCopySettingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_provider=cloud_provider,
            frequencies=frequencies,
            region_name=region_name,
            replication_spec_id=replication_spec_id,
            should_copy_oplogs=should_copy_oplogs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_provider: str,
             frequencies: Sequence[str],
             region_name: str,
             replication_spec_id: str,
             should_copy_oplogs: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cloud_provider", cloud_provider)
        _setter("frequencies", frequencies)
        _setter("region_name", region_name)
        _setter("replication_spec_id", replication_spec_id)
        _setter("should_copy_oplogs", should_copy_oplogs)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        Human-readable label that identifies the cloud provider that stores the snapshot copy. i.e. "AWS" "AZURE" "GCP"
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def frequencies(self) -> Sequence[str]:
        """
        List that describes which types of snapshots to copy. i.e. "HOURLY" "DAILY" "WEEKLY" "MONTHLY" "ON_DEMAND"
        """
        return pulumi.get(self, "frequencies")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        Target region to copy snapshots belonging to replicationSpecId to. Please supply the 'Atlas Region' which can be found under https://www.mongodb.com/docs/atlas/reference/cloud-providers/ 'regions' link
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter(name="replicationSpecId")
    def replication_spec_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the replication object for a zone in a cluster. For global clusters, there can be multiple zones to choose from. For sharded clusters and replica set clusters, there is only one zone in the cluster. To find the Replication Spec Id, consult the replicationSpecs array returned from [Return One Multi-Cloud Cluster in One Project](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Clusters/operation/getCluster).
        """
        return pulumi.get(self, "replication_spec_id")

    @property
    @pulumi.getter(name="shouldCopyOplogs")
    def should_copy_oplogs(self) -> bool:
        """
        Flag that indicates whether to copy the oplogs to the target region. You can use the oplogs to perform point-in-time restores.
        """
        return pulumi.get(self, "should_copy_oplogs")


@pulumi.output_type
class GetCloudBackupScheduleExportResult(dict):
    def __init__(__self__, *,
                 export_bucket_id: str,
                 frequency_type: str):
        """
        :param str export_bucket_id: Unique identifier of the CloudBackupSnapshotExportBucket export_bucket_id value.
        :param str frequency_type: Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        GetCloudBackupScheduleExportResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            export_bucket_id=export_bucket_id,
            frequency_type=frequency_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             export_bucket_id: str,
             frequency_type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("export_bucket_id", export_bucket_id)
        _setter("frequency_type", frequency_type)

    @property
    @pulumi.getter(name="exportBucketId")
    def export_bucket_id(self) -> str:
        """
        Unique identifier of the CloudBackupSnapshotExportBucket export_bucket_id value.
        """
        return pulumi.get(self, "export_bucket_id")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        """
        Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")


@pulumi.output_type
class GetCloudBackupSchedulePolicyItemDailyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        :param str frequency_type: Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, or `months`.
        :param int retention_value: Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        """
        GetCloudBackupSchedulePolicyItemDailyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frequency_interval=frequency_interval,
            frequency_type=frequency_type,
            id=id,
            retention_unit=retention_unit,
            retention_value=retention_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frequency_interval: int,
             frequency_type: str,
             id: str,
             retention_unit: str,
             retention_value: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("frequency_interval", frequency_interval)
        _setter("frequency_type", frequency_type)
        _setter("id", id)
        _setter("retention_unit", retention_unit)
        _setter("retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        """
        Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, or `months`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetCloudBackupSchedulePolicyItemHourlyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        :param str frequency_type: Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, or `months`.
        :param int retention_value: Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        """
        GetCloudBackupSchedulePolicyItemHourlyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frequency_interval=frequency_interval,
            frequency_type=frequency_type,
            id=id,
            retention_unit=retention_unit,
            retention_value=retention_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frequency_interval: int,
             frequency_type: str,
             id: str,
             retention_unit: str,
             retention_value: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("frequency_interval", frequency_interval)
        _setter("frequency_type", frequency_type)
        _setter("id", id)
        _setter("retention_unit", retention_unit)
        _setter("retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        """
        Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, or `months`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetCloudBackupSchedulePolicyItemMonthlyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        :param str frequency_type: Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, or `months`.
        :param int retention_value: Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        """
        GetCloudBackupSchedulePolicyItemMonthlyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frequency_interval=frequency_interval,
            frequency_type=frequency_type,
            id=id,
            retention_unit=retention_unit,
            retention_value=retention_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frequency_interval: int,
             frequency_type: str,
             id: str,
             retention_unit: str,
             retention_value: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("frequency_interval", frequency_interval)
        _setter("frequency_type", frequency_type)
        _setter("id", id)
        _setter("retention_unit", retention_unit)
        _setter("retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        """
        Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, or `months`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetCloudBackupSchedulePolicyItemWeeklyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        :param str frequency_type: Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, or `months`.
        :param int retention_value: Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        """
        GetCloudBackupSchedulePolicyItemWeeklyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frequency_interval=frequency_interval,
            frequency_type=frequency_type,
            id=id,
            retention_unit=retention_unit,
            retention_value=retention_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frequency_interval: int,
             frequency_type: str,
             id: str,
             retention_unit: str,
             retention_value: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("frequency_interval", frequency_interval)
        _setter("frequency_type", frequency_type)
        _setter("id", id)
        _setter("retention_unit", retention_unit)
        _setter("retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        """
        Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, or `months`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetCloudBackupSnapshotExportBucketsResultResult(dict):
    def __init__(__self__, *,
                 bucket_name: str,
                 cloud_provider: str,
                 export_bucket_id: str,
                 iam_role_id: str):
        """
        :param str bucket_name: Name of the bucket that the provided role ID is authorized to access. You must also specify the `iam_role_id`.
        :param str cloud_provider: Name of the provider of the cloud service where Atlas can access the S3 bucket. Atlas only supports `AWS`.
        :param str export_bucket_id: Unique identifier of the snapshot bucket id.
        :param str iam_role_id: Unique identifier of the role that Atlas can use to access the bucket. You must also specify the `bucket_name`.
        """
        GetCloudBackupSnapshotExportBucketsResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            cloud_provider=cloud_provider,
            export_bucket_id=export_bucket_id,
            iam_role_id=iam_role_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: str,
             cloud_provider: str,
             export_bucket_id: str,
             iam_role_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("bucket_name", bucket_name)
        _setter("cloud_provider", cloud_provider)
        _setter("export_bucket_id", export_bucket_id)
        _setter("iam_role_id", iam_role_id)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> str:
        """
        Name of the bucket that the provided role ID is authorized to access. You must also specify the `iam_role_id`.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        Name of the provider of the cloud service where Atlas can access the S3 bucket. Atlas only supports `AWS`.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="exportBucketId")
    def export_bucket_id(self) -> str:
        """
        Unique identifier of the snapshot bucket id.
        """
        return pulumi.get(self, "export_bucket_id")

    @property
    @pulumi.getter(name="iamRoleId")
    def iam_role_id(self) -> str:
        """
        Unique identifier of the role that Atlas can use to access the bucket. You must also specify the `bucket_name`.
        """
        return pulumi.get(self, "iam_role_id")


@pulumi.output_type
class GetCloudBackupSnapshotExportJobComponentResult(dict):
    def __init__(__self__, *,
                 export_id: str,
                 replica_set_name: str):
        """
        :param str export_id: _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        :param str replica_set_name: _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
        GetCloudBackupSnapshotExportJobComponentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            export_id=export_id,
            replica_set_name=replica_set_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             export_id: str,
             replica_set_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("export_id", export_id)
        _setter("replica_set_name", replica_set_name)

    @property
    @pulumi.getter(name="exportId")
    def export_id(self) -> str:
        """
        _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        """
        return pulumi.get(self, "export_id")

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> str:
        """
        _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
        return pulumi.get(self, "replica_set_name")


@pulumi.output_type
class GetCloudBackupSnapshotExportJobCustomDataResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Custom data specified as key in the key and value pair.
        :param str value: Value for the key specified using `key`.
        """
        GetCloudBackupSnapshotExportJobCustomDataResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Custom data specified as key in the key and value pair.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value for the key specified using `key`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCloudBackupSnapshotExportJobsResultResult(dict):
    def __init__(__self__, *,
                 components: Sequence['outputs.GetCloudBackupSnapshotExportJobsResultComponentResult'],
                 created_at: str,
                 custom_datas: Sequence['outputs.GetCloudBackupSnapshotExportJobsResultCustomDataResult'],
                 err_msg: str,
                 export_bucket_id: str,
                 export_job_id: str,
                 export_status_exported_collections: int,
                 export_status_total_collections: int,
                 finished_at: str,
                 prefix: str,
                 snapshot_id: str,
                 state: str):
        """
        :param Sequence['GetCloudBackupSnapshotExportJobsResultComponentArgs'] components: _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        :param str created_at: Timestamp in ISO 8601 date and time format in UTC when the export job was created.
        :param Sequence['GetCloudBackupSnapshotExportJobsResultCustomDataArgs'] custom_datas: Custom data to include in the metadata file named `.complete` that Atlas uploads to the bucket when the export job finishes. Custom data can be specified as key and value pairs.
        :param str err_msg: Error message, only if the export job failed.
        :param str export_bucket_id: Unique identifier of the AWS bucket to export the Cloud Backup snapshot to.
        :param str export_job_id: Unique identifier of the export job.
               * `prefix ` - Full path on the cloud provider bucket to the folder where the snapshot is exported. The path is in the following format:`/exported_snapshots/{ORG-NAME}/{PROJECT-NAME}/{CLUSTER-NAME}/{SNAPSHOT-INITIATION-DATE}/{TIMESTAMP}`
        :param str finished_at: Timestamp in ISO 8601 date and time format in UTC when the export job completes.
        :param str snapshot_id: Unique identifier of the Cloud Backup snapshot to export.
        :param str state: Status of the export job. Value can be one of the following:
        """
        GetCloudBackupSnapshotExportJobsResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            components=components,
            created_at=created_at,
            custom_datas=custom_datas,
            err_msg=err_msg,
            export_bucket_id=export_bucket_id,
            export_job_id=export_job_id,
            export_status_exported_collections=export_status_exported_collections,
            export_status_total_collections=export_status_total_collections,
            finished_at=finished_at,
            prefix=prefix,
            snapshot_id=snapshot_id,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             components: Sequence['outputs.GetCloudBackupSnapshotExportJobsResultComponentResult'],
             created_at: str,
             custom_datas: Sequence['outputs.GetCloudBackupSnapshotExportJobsResultCustomDataResult'],
             err_msg: str,
             export_bucket_id: str,
             export_job_id: str,
             export_status_exported_collections: int,
             export_status_total_collections: int,
             finished_at: str,
             prefix: str,
             snapshot_id: str,
             state: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("components", components)
        _setter("created_at", created_at)
        _setter("custom_datas", custom_datas)
        _setter("err_msg", err_msg)
        _setter("export_bucket_id", export_bucket_id)
        _setter("export_job_id", export_job_id)
        _setter("export_status_exported_collections", export_status_exported_collections)
        _setter("export_status_total_collections", export_status_total_collections)
        _setter("finished_at", finished_at)
        _setter("prefix", prefix)
        _setter("snapshot_id", snapshot_id)
        _setter("state", state)

    @property
    @pulumi.getter
    def components(self) -> Sequence['outputs.GetCloudBackupSnapshotExportJobsResultComponentResult']:
        """
        _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        """
        return pulumi.get(self, "components")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Timestamp in ISO 8601 date and time format in UTC when the export job was created.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="customDatas")
    def custom_datas(self) -> Sequence['outputs.GetCloudBackupSnapshotExportJobsResultCustomDataResult']:
        """
        Custom data to include in the metadata file named `.complete` that Atlas uploads to the bucket when the export job finishes. Custom data can be specified as key and value pairs.
        """
        return pulumi.get(self, "custom_datas")

    @property
    @pulumi.getter(name="errMsg")
    def err_msg(self) -> str:
        """
        Error message, only if the export job failed.
        """
        return pulumi.get(self, "err_msg")

    @property
    @pulumi.getter(name="exportBucketId")
    def export_bucket_id(self) -> str:
        """
        Unique identifier of the AWS bucket to export the Cloud Backup snapshot to.
        """
        return pulumi.get(self, "export_bucket_id")

    @property
    @pulumi.getter(name="exportJobId")
    def export_job_id(self) -> str:
        """
        Unique identifier of the export job.
        * `prefix ` - Full path on the cloud provider bucket to the folder where the snapshot is exported. The path is in the following format:`/exported_snapshots/{ORG-NAME}/{PROJECT-NAME}/{CLUSTER-NAME}/{SNAPSHOT-INITIATION-DATE}/{TIMESTAMP}`
        """
        return pulumi.get(self, "export_job_id")

    @property
    @pulumi.getter(name="exportStatusExportedCollections")
    def export_status_exported_collections(self) -> int:
        return pulumi.get(self, "export_status_exported_collections")

    @property
    @pulumi.getter(name="exportStatusTotalCollections")
    def export_status_total_collections(self) -> int:
        return pulumi.get(self, "export_status_total_collections")

    @property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> str:
        """
        Timestamp in ISO 8601 date and time format in UTC when the export job completes.
        """
        return pulumi.get(self, "finished_at")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> str:
        """
        Unique identifier of the Cloud Backup snapshot to export.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Status of the export job. Value can be one of the following:
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetCloudBackupSnapshotExportJobsResultComponentResult(dict):
    def __init__(__self__, *,
                 export_id: str,
                 replica_set_name: str):
        """
        :param str export_id: _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        :param str replica_set_name: _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
        GetCloudBackupSnapshotExportJobsResultComponentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            export_id=export_id,
            replica_set_name=replica_set_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             export_id: str,
             replica_set_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("export_id", export_id)
        _setter("replica_set_name", replica_set_name)

    @property
    @pulumi.getter(name="exportId")
    def export_id(self) -> str:
        """
        _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        """
        return pulumi.get(self, "export_id")

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> str:
        """
        _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
        return pulumi.get(self, "replica_set_name")


@pulumi.output_type
class GetCloudBackupSnapshotExportJobsResultCustomDataResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Custom data specified as key in the key and value pair.
        :param str value: Value for the key specified using `key`.
        """
        GetCloudBackupSnapshotExportJobsResultCustomDataResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Custom data specified as key in the key and value pair.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value for the key specified using `key`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCloudBackupSnapshotMemberResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 id: str,
                 replica_set_name: str):
        """
        :param str cloud_provider: Cloud provider that stores this snapshot.
        :param str id: Unique identifier for the sharded cluster snapshot.
        :param str replica_set_name: Label given to a shard or config server from which Atlas took this snapshot.
        """
        GetCloudBackupSnapshotMemberResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_provider=cloud_provider,
            id=id,
            replica_set_name=replica_set_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_provider: str,
             id: str,
             replica_set_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cloud_provider", cloud_provider)
        _setter("id", id)
        _setter("replica_set_name", replica_set_name)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        Cloud provider that stores this snapshot.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier for the sharded cluster snapshot.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> str:
        """
        Label given to a shard or config server from which Atlas took this snapshot.
        """
        return pulumi.get(self, "replica_set_name")


@pulumi.output_type
class GetCloudBackupSnapshotRestoreJobsResultResult(dict):
    def __init__(__self__, *,
                 cancelled: bool,
                 created_at: str,
                 delivery_type: str,
                 delivery_urls: Sequence[str],
                 expired: bool,
                 expires_at: str,
                 finished_at: str,
                 id: str,
                 oplog_inc: int,
                 oplog_ts: int,
                 point_in_time_utc_seconds: int,
                 snapshot_id: str,
                 target_cluster_name: str,
                 target_project_id: str,
                 timestamp: str):
        """
        :param bool cancelled: Indicates whether the restore job was canceled.
        :param str created_at: UTC ISO 8601 formatted point in time when Atlas created the restore job.
        :param str delivery_type: Type of restore job to create. Possible values are: automated and download.
        :param Sequence[str] delivery_urls: One or more URLs for the compressed snapshot files for manual download. Only visible if deliveryType is download.
        :param bool expired: Indicates whether the restore job expired.
        :param str expires_at: UTC ISO 8601 formatted point in time when the restore job expires.
        :param str finished_at: UTC ISO 8601 formatted point in time when the restore job completed.
        :param str id: The unique identifier of the restore job.
        :param str snapshot_id: Unique identifier of the source snapshot ID of the restore job.
        :param str target_cluster_name: Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.
        :param str target_project_id: Name of the target Atlas project of the restore job. Only visible if deliveryType is automated.
        :param str timestamp: Timestamp in ISO 8601 date and time format in UTC when the snapshot associated to snapshotId was taken.
        """
        GetCloudBackupSnapshotRestoreJobsResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cancelled=cancelled,
            created_at=created_at,
            delivery_type=delivery_type,
            delivery_urls=delivery_urls,
            expired=expired,
            expires_at=expires_at,
            finished_at=finished_at,
            id=id,
            oplog_inc=oplog_inc,
            oplog_ts=oplog_ts,
            point_in_time_utc_seconds=point_in_time_utc_seconds,
            snapshot_id=snapshot_id,
            target_cluster_name=target_cluster_name,
            target_project_id=target_project_id,
            timestamp=timestamp,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cancelled: bool,
             created_at: str,
             delivery_type: str,
             delivery_urls: Sequence[str],
             expired: bool,
             expires_at: str,
             finished_at: str,
             id: str,
             oplog_inc: int,
             oplog_ts: int,
             point_in_time_utc_seconds: int,
             snapshot_id: str,
             target_cluster_name: str,
             target_project_id: str,
             timestamp: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cancelled", cancelled)
        _setter("created_at", created_at)
        _setter("delivery_type", delivery_type)
        _setter("delivery_urls", delivery_urls)
        _setter("expired", expired)
        _setter("expires_at", expires_at)
        _setter("finished_at", finished_at)
        _setter("id", id)
        _setter("oplog_inc", oplog_inc)
        _setter("oplog_ts", oplog_ts)
        _setter("point_in_time_utc_seconds", point_in_time_utc_seconds)
        _setter("snapshot_id", snapshot_id)
        _setter("target_cluster_name", target_cluster_name)
        _setter("target_project_id", target_project_id)
        _setter("timestamp", timestamp)

    @property
    @pulumi.getter
    def cancelled(self) -> bool:
        """
        Indicates whether the restore job was canceled.
        """
        return pulumi.get(self, "cancelled")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        UTC ISO 8601 formatted point in time when Atlas created the restore job.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="deliveryType")
    def delivery_type(self) -> str:
        """
        Type of restore job to create. Possible values are: automated and download.
        """
        return pulumi.get(self, "delivery_type")

    @property
    @pulumi.getter(name="deliveryUrls")
    def delivery_urls(self) -> Sequence[str]:
        """
        One or more URLs for the compressed snapshot files for manual download. Only visible if deliveryType is download.
        """
        return pulumi.get(self, "delivery_urls")

    @property
    @pulumi.getter
    def expired(self) -> bool:
        """
        Indicates whether the restore job expired.
        """
        return pulumi.get(self, "expired")

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> str:
        """
        UTC ISO 8601 formatted point in time when the restore job expires.
        """
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> str:
        """
        UTC ISO 8601 formatted point in time when the restore job completed.
        """
        return pulumi.get(self, "finished_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique identifier of the restore job.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="oplogInc")
    def oplog_inc(self) -> int:
        return pulumi.get(self, "oplog_inc")

    @property
    @pulumi.getter(name="oplogTs")
    def oplog_ts(self) -> int:
        return pulumi.get(self, "oplog_ts")

    @property
    @pulumi.getter(name="pointInTimeUtcSeconds")
    def point_in_time_utc_seconds(self) -> int:
        return pulumi.get(self, "point_in_time_utc_seconds")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> str:
        """
        Unique identifier of the source snapshot ID of the restore job.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter(name="targetClusterName")
    def target_cluster_name(self) -> str:
        """
        Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.
        """
        return pulumi.get(self, "target_cluster_name")

    @property
    @pulumi.getter(name="targetProjectId")
    def target_project_id(self) -> str:
        """
        Name of the target Atlas project of the restore job. Only visible if deliveryType is automated.
        """
        return pulumi.get(self, "target_project_id")

    @property
    @pulumi.getter
    def timestamp(self) -> str:
        """
        Timestamp in ISO 8601 date and time format in UTC when the snapshot associated to snapshotId was taken.
        """
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class GetCloudBackupSnapshotsResultResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 created_at: str,
                 description: str,
                 expires_at: str,
                 id: str,
                 master_key_uuid: str,
                 members: Sequence['outputs.GetCloudBackupSnapshotsResultMemberResult'],
                 mongod_version: str,
                 replica_set_name: str,
                 snapshot_ids: Sequence[str],
                 snapshot_type: str,
                 status: str,
                 storage_size_bytes: int,
                 type: str):
        """
        :param str cloud_provider: Cloud provider that stores this snapshot.
        :param str created_at: UTC ISO 8601 formatted point in time when Atlas took the snapshot.
        :param str description: UDescription of the snapshot. Only present for on-demand snapshots.
        :param str expires_at: UTC ISO 8601 formatted point in time when Atlas will delete the snapshot.
        :param str id: Unique identifier for the sharded cluster snapshot.
        :param str master_key_uuid: Unique ID of the AWS KMS Customer Master Key used to encrypt the snapshot. Only visible for clusters using Encryption at Rest via Customer KMS.
        :param Sequence['GetCloudBackupSnapshotsResultMemberArgs'] members: Block of List of snapshots and the cloud provider where the snapshots are stored. See below
        :param str mongod_version: Version of the MongoDB server.
        :param str replica_set_name: Label given to a shard or config server from which Atlas took this snapshot.
        :param Sequence[str] snapshot_ids: Unique identifiers of the snapshots created for the shards and config server for a sharded cluster.
        :param str snapshot_type: Specified the type of snapshot. Valid values are onDemand and scheduled.
        :param str status: Current status of the snapshot. One of the following values: queued, inProgress, completed, failed.
        :param int storage_size_bytes: Specifies the size of the snapshot in bytes.
        :param str type: Specifies the type of cluster: replicaSet or shardedCluster.
        """
        GetCloudBackupSnapshotsResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_provider=cloud_provider,
            created_at=created_at,
            description=description,
            expires_at=expires_at,
            id=id,
            master_key_uuid=master_key_uuid,
            members=members,
            mongod_version=mongod_version,
            replica_set_name=replica_set_name,
            snapshot_ids=snapshot_ids,
            snapshot_type=snapshot_type,
            status=status,
            storage_size_bytes=storage_size_bytes,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_provider: str,
             created_at: str,
             description: str,
             expires_at: str,
             id: str,
             master_key_uuid: str,
             members: Sequence['outputs.GetCloudBackupSnapshotsResultMemberResult'],
             mongod_version: str,
             replica_set_name: str,
             snapshot_ids: Sequence[str],
             snapshot_type: str,
             status: str,
             storage_size_bytes: int,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cloud_provider", cloud_provider)
        _setter("created_at", created_at)
        _setter("description", description)
        _setter("expires_at", expires_at)
        _setter("id", id)
        _setter("master_key_uuid", master_key_uuid)
        _setter("members", members)
        _setter("mongod_version", mongod_version)
        _setter("replica_set_name", replica_set_name)
        _setter("snapshot_ids", snapshot_ids)
        _setter("snapshot_type", snapshot_type)
        _setter("status", status)
        _setter("storage_size_bytes", storage_size_bytes)
        _setter("type", type)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        Cloud provider that stores this snapshot.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        UTC ISO 8601 formatted point in time when Atlas took the snapshot.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        UDescription of the snapshot. Only present for on-demand snapshots.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> str:
        """
        UTC ISO 8601 formatted point in time when Atlas will delete the snapshot.
        """
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier for the sharded cluster snapshot.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="masterKeyUuid")
    def master_key_uuid(self) -> str:
        """
        Unique ID of the AWS KMS Customer Master Key used to encrypt the snapshot. Only visible for clusters using Encryption at Rest via Customer KMS.
        """
        return pulumi.get(self, "master_key_uuid")

    @property
    @pulumi.getter
    def members(self) -> Sequence['outputs.GetCloudBackupSnapshotsResultMemberResult']:
        """
        Block of List of snapshots and the cloud provider where the snapshots are stored. See below
        """
        return pulumi.get(self, "members")

    @property
    @pulumi.getter(name="mongodVersion")
    def mongod_version(self) -> str:
        """
        Version of the MongoDB server.
        """
        return pulumi.get(self, "mongod_version")

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> str:
        """
        Label given to a shard or config server from which Atlas took this snapshot.
        """
        return pulumi.get(self, "replica_set_name")

    @property
    @pulumi.getter(name="snapshotIds")
    def snapshot_ids(self) -> Sequence[str]:
        """
        Unique identifiers of the snapshots created for the shards and config server for a sharded cluster.
        """
        return pulumi.get(self, "snapshot_ids")

    @property
    @pulumi.getter(name="snapshotType")
    def snapshot_type(self) -> str:
        """
        Specified the type of snapshot. Valid values are onDemand and scheduled.
        """
        return pulumi.get(self, "snapshot_type")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Current status of the snapshot. One of the following values: queued, inProgress, completed, failed.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="storageSizeBytes")
    def storage_size_bytes(self) -> int:
        """
        Specifies the size of the snapshot in bytes.
        """
        return pulumi.get(self, "storage_size_bytes")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of cluster: replicaSet or shardedCluster.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetCloudBackupSnapshotsResultMemberResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 id: str,
                 replica_set_name: str):
        """
        :param str cloud_provider: Cloud provider that stores this snapshot.
        :param str id: Unique identifier for the sharded cluster snapshot.
        :param str replica_set_name: Label given to a shard or config server from which Atlas took this snapshot.
        """
        GetCloudBackupSnapshotsResultMemberResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_provider=cloud_provider,
            id=id,
            replica_set_name=replica_set_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_provider: str,
             id: str,
             replica_set_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cloud_provider", cloud_provider)
        _setter("id", id)
        _setter("replica_set_name", replica_set_name)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        Cloud provider that stores this snapshot.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier for the sharded cluster snapshot.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> str:
        """
        Label given to a shard or config server from which Atlas took this snapshot.
        """
        return pulumi.get(self, "replica_set_name")


@pulumi.output_type
class GetCloudProviderAccessAwsIamRoleResult(dict):
    def __init__(__self__, *,
                 atlas_assumed_role_external_id: str,
                 atlas_aws_account_arn: str,
                 authorized_date: str,
                 created_date: str,
                 feature_usages: Sequence['outputs.GetCloudProviderAccessAwsIamRoleFeatureUsageResult'],
                 iam_assumed_role_arn: str,
                 provider_name: str,
                 role_id: str):
        """
        :param str atlas_assumed_role_external_id: Unique external ID Atlas uses when assuming the IAM role in your AWS account.
        :param str atlas_aws_account_arn: ARN associated with the Atlas AWS account used to assume IAM roles in your AWS account.
        :param str authorized_date: Date on which this role was authorized.
        :param str created_date: Date on which this role was created.
        :param Sequence['GetCloudProviderAccessAwsIamRoleFeatureUsageArgs'] feature_usages: Atlas features this AWS IAM role is linked to.
        :param str iam_assumed_role_arn: ARN of the IAM Role that Atlas assumes when accessing resources in your AWS account.
        :param str provider_name: Name of the cloud provider. Currently limited to AWS.
        :param str role_id: Unique ID of this role.
        """
        GetCloudProviderAccessAwsIamRoleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            atlas_assumed_role_external_id=atlas_assumed_role_external_id,
            atlas_aws_account_arn=atlas_aws_account_arn,
            authorized_date=authorized_date,
            created_date=created_date,
            feature_usages=feature_usages,
            iam_assumed_role_arn=iam_assumed_role_arn,
            provider_name=provider_name,
            role_id=role_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             atlas_assumed_role_external_id: str,
             atlas_aws_account_arn: str,
             authorized_date: str,
             created_date: str,
             feature_usages: Sequence['outputs.GetCloudProviderAccessAwsIamRoleFeatureUsageResult'],
             iam_assumed_role_arn: str,
             provider_name: str,
             role_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("atlas_assumed_role_external_id", atlas_assumed_role_external_id)
        _setter("atlas_aws_account_arn", atlas_aws_account_arn)
        _setter("authorized_date", authorized_date)
        _setter("created_date", created_date)
        _setter("feature_usages", feature_usages)
        _setter("iam_assumed_role_arn", iam_assumed_role_arn)
        _setter("provider_name", provider_name)
        _setter("role_id", role_id)

    @property
    @pulumi.getter(name="atlasAssumedRoleExternalId")
    def atlas_assumed_role_external_id(self) -> str:
        """
        Unique external ID Atlas uses when assuming the IAM role in your AWS account.
        """
        return pulumi.get(self, "atlas_assumed_role_external_id")

    @property
    @pulumi.getter(name="atlasAwsAccountArn")
    def atlas_aws_account_arn(self) -> str:
        """
        ARN associated with the Atlas AWS account used to assume IAM roles in your AWS account.
        """
        return pulumi.get(self, "atlas_aws_account_arn")

    @property
    @pulumi.getter(name="authorizedDate")
    def authorized_date(self) -> str:
        """
        Date on which this role was authorized.
        """
        return pulumi.get(self, "authorized_date")

    @property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> str:
        """
        Date on which this role was created.
        """
        return pulumi.get(self, "created_date")

    @property
    @pulumi.getter(name="featureUsages")
    def feature_usages(self) -> Sequence['outputs.GetCloudProviderAccessAwsIamRoleFeatureUsageResult']:
        """
        Atlas features this AWS IAM role is linked to.
        """
        return pulumi.get(self, "feature_usages")

    @property
    @pulumi.getter(name="iamAssumedRoleArn")
    def iam_assumed_role_arn(self) -> str:
        """
        ARN of the IAM Role that Atlas assumes when accessing resources in your AWS account.
        """
        return pulumi.get(self, "iam_assumed_role_arn")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Name of the cloud provider. Currently limited to AWS.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> str:
        """
        Unique ID of this role.
        """
        return pulumi.get(self, "role_id")


@pulumi.output_type
class GetCloudProviderAccessAwsIamRoleFeatureUsageResult(dict):
    def __init__(__self__, *,
                 feature_id: Mapping[str, Any],
                 feature_type: str):
        GetCloudProviderAccessAwsIamRoleFeatureUsageResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            feature_id=feature_id,
            feature_type=feature_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             feature_id: Mapping[str, Any],
             feature_type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("feature_id", feature_id)
        _setter("feature_type", feature_type)

    @property
    @pulumi.getter(name="featureId")
    def feature_id(self) -> Mapping[str, Any]:
        return pulumi.get(self, "feature_id")

    @property
    @pulumi.getter(name="featureType")
    def feature_type(self) -> str:
        return pulumi.get(self, "feature_type")


@pulumi.output_type
class GetCloudProviderAccessSetupAwsConfigResult(dict):
    def __init__(__self__, *,
                 atlas_assumed_role_external_id: str,
                 atlas_aws_account_arn: str):
        """
        :param str atlas_assumed_role_external_id: Unique external ID Atlas uses when assuming the IAM role in your AWS account.
        :param str atlas_aws_account_arn: ARN associated with the Atlas AWS account used to assume IAM roles in your AWS account.
        """
        GetCloudProviderAccessSetupAwsConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            atlas_assumed_role_external_id=atlas_assumed_role_external_id,
            atlas_aws_account_arn=atlas_aws_account_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             atlas_assumed_role_external_id: str,
             atlas_aws_account_arn: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("atlas_assumed_role_external_id", atlas_assumed_role_external_id)
        _setter("atlas_aws_account_arn", atlas_aws_account_arn)

    @property
    @pulumi.getter(name="atlasAssumedRoleExternalId")
    def atlas_assumed_role_external_id(self) -> str:
        """
        Unique external ID Atlas uses when assuming the IAM role in your AWS account.
        """
        return pulumi.get(self, "atlas_assumed_role_external_id")

    @property
    @pulumi.getter(name="atlasAwsAccountArn")
    def atlas_aws_account_arn(self) -> str:
        """
        ARN associated with the Atlas AWS account used to assume IAM roles in your AWS account.
        """
        return pulumi.get(self, "atlas_aws_account_arn")


@pulumi.output_type
class GetCloudProviderAccessSetupAzureConfigResult(dict):
    def __init__(__self__, *,
                 atlas_azure_app_id: str,
                 service_principal_id: str,
                 tenant_id: str):
        """
        :param str atlas_azure_app_id: Azure Active Directory Application ID of Atlas.
        :param str service_principal_id: UUID string that identifies the Azure Service Principal.
        :param str tenant_id: UUID String that identifies the Azure Active Directory Tenant ID.
        """
        GetCloudProviderAccessSetupAzureConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            atlas_azure_app_id=atlas_azure_app_id,
            service_principal_id=service_principal_id,
            tenant_id=tenant_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             atlas_azure_app_id: str,
             service_principal_id: str,
             tenant_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("atlas_azure_app_id", atlas_azure_app_id)
        _setter("service_principal_id", service_principal_id)
        _setter("tenant_id", tenant_id)

    @property
    @pulumi.getter(name="atlasAzureAppId")
    def atlas_azure_app_id(self) -> str:
        """
        Azure Active Directory Application ID of Atlas.
        """
        return pulumi.get(self, "atlas_azure_app_id")

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> str:
        """
        UUID string that identifies the Azure Service Principal.
        """
        return pulumi.get(self, "service_principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        UUID String that identifies the Azure Active Directory Tenant ID.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetClusterAdvancedConfigurationResult(dict):
    def __init__(__self__, *,
                 default_read_concern: str,
                 default_write_concern: str,
                 fail_index_key_too_long: bool,
                 javascript_enabled: bool,
                 minimum_enabled_tls_protocol: str,
                 no_table_scan: bool,
                 oplog_min_retention_hours: int,
                 oplog_size_mb: int,
                 sample_refresh_interval_bi_connector: int,
                 sample_size_bi_connector: int,
                 transaction_lifetime_limit_seconds: int):
        """
        :param str default_read_concern: [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        :param str default_write_concern: [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        :param bool fail_index_key_too_long: When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        :param bool javascript_enabled: When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        :param str minimum_enabled_tls_protocol: Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        :param bool no_table_scan: When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        :param int oplog_min_retention_hours: Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        :param int oplog_size_mb: The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        :param int sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param int sample_size_bi_connector: Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param int transaction_lifetime_limit_seconds: Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        GetClusterAdvancedConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_read_concern=default_read_concern,
            default_write_concern=default_write_concern,
            fail_index_key_too_long=fail_index_key_too_long,
            javascript_enabled=javascript_enabled,
            minimum_enabled_tls_protocol=minimum_enabled_tls_protocol,
            no_table_scan=no_table_scan,
            oplog_min_retention_hours=oplog_min_retention_hours,
            oplog_size_mb=oplog_size_mb,
            sample_refresh_interval_bi_connector=sample_refresh_interval_bi_connector,
            sample_size_bi_connector=sample_size_bi_connector,
            transaction_lifetime_limit_seconds=transaction_lifetime_limit_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_read_concern: str,
             default_write_concern: str,
             fail_index_key_too_long: bool,
             javascript_enabled: bool,
             minimum_enabled_tls_protocol: str,
             no_table_scan: bool,
             oplog_min_retention_hours: int,
             oplog_size_mb: int,
             sample_refresh_interval_bi_connector: int,
             sample_size_bi_connector: int,
             transaction_lifetime_limit_seconds: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("default_read_concern", default_read_concern)
        _setter("default_write_concern", default_write_concern)
        _setter("fail_index_key_too_long", fail_index_key_too_long)
        _setter("javascript_enabled", javascript_enabled)
        _setter("minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        _setter("no_table_scan", no_table_scan)
        _setter("oplog_min_retention_hours", oplog_min_retention_hours)
        _setter("oplog_size_mb", oplog_size_mb)
        _setter("sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        _setter("sample_size_bi_connector", sample_size_bi_connector)
        _setter("transaction_lifetime_limit_seconds", transaction_lifetime_limit_seconds)

    @property
    @pulumi.getter(name="defaultReadConcern")
    def default_read_concern(self) -> str:
        """
        [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        """
        return pulumi.get(self, "default_read_concern")

    @property
    @pulumi.getter(name="defaultWriteConcern")
    def default_write_concern(self) -> str:
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        return pulumi.get(self, "default_write_concern")

    @property
    @pulumi.getter(name="failIndexKeyTooLong")
    def fail_index_key_too_long(self) -> bool:
        """
        When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        """
        return pulumi.get(self, "fail_index_key_too_long")

    @property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> bool:
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        return pulumi.get(self, "javascript_enabled")

    @property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> str:
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> bool:
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        return pulumi.get(self, "no_table_scan")

    @property
    @pulumi.getter(name="oplogMinRetentionHours")
    def oplog_min_retention_hours(self) -> int:
        """
        Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        """
        return pulumi.get(self, "oplog_min_retention_hours")

    @property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> int:
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        return pulumi.get(self, "oplog_size_mb")

    @property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> int:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> int:
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_size_bi_connector")

    @property
    @pulumi.getter(name="transactionLifetimeLimitSeconds")
    def transaction_lifetime_limit_seconds(self) -> int:
        """
        Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        return pulumi.get(self, "transaction_lifetime_limit_seconds")


@pulumi.output_type
class GetClusterBiConnectorConfigResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 read_preference: str):
        """
        :param bool enabled: Indicates whether or not BI Connector for Atlas is enabled on the cluster.
        :param str read_preference: Indicates the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        GetClusterBiConnectorConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            read_preference=read_preference,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: bool,
             read_preference: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("enabled", enabled)
        _setter("read_preference", read_preference)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Indicates whether or not BI Connector for Atlas is enabled on the cluster.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> str:
        """
        Indicates the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        return pulumi.get(self, "read_preference")


@pulumi.output_type
class GetClusterConnectionStringResult(dict):
    def __init__(__self__, *,
                 aws_private_link: Mapping[str, Any],
                 aws_private_link_srv: Mapping[str, Any],
                 private: str,
                 private_endpoints: Sequence['outputs.GetClusterConnectionStringPrivateEndpointResult'],
                 private_srv: str,
                 standard: str,
                 standard_srv: str):
        GetClusterConnectionStringResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aws_private_link=aws_private_link,
            aws_private_link_srv=aws_private_link_srv,
            private=private,
            private_endpoints=private_endpoints,
            private_srv=private_srv,
            standard=standard,
            standard_srv=standard_srv,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aws_private_link: Mapping[str, Any],
             aws_private_link_srv: Mapping[str, Any],
             private: str,
             private_endpoints: Sequence['outputs.GetClusterConnectionStringPrivateEndpointResult'],
             private_srv: str,
             standard: str,
             standard_srv: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aws_private_link", aws_private_link)
        _setter("aws_private_link_srv", aws_private_link_srv)
        _setter("private", private)
        _setter("private_endpoints", private_endpoints)
        _setter("private_srv", private_srv)
        _setter("standard", standard)
        _setter("standard_srv", standard_srv)

    @property
    @pulumi.getter(name="awsPrivateLink")
    def aws_private_link(self) -> Mapping[str, Any]:
        return pulumi.get(self, "aws_private_link")

    @property
    @pulumi.getter(name="awsPrivateLinkSrv")
    def aws_private_link_srv(self) -> Mapping[str, Any]:
        return pulumi.get(self, "aws_private_link_srv")

    @property
    @pulumi.getter
    def private(self) -> str:
        return pulumi.get(self, "private")

    @property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Sequence['outputs.GetClusterConnectionStringPrivateEndpointResult']:
        return pulumi.get(self, "private_endpoints")

    @property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> str:
        return pulumi.get(self, "private_srv")

    @property
    @pulumi.getter
    def standard(self) -> str:
        return pulumi.get(self, "standard")

    @property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> str:
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class GetClusterConnectionStringPrivateEndpointResult(dict):
    def __init__(__self__, *,
                 connection_string: str,
                 endpoints: Sequence['outputs.GetClusterConnectionStringPrivateEndpointEndpointResult'],
                 srv_connection_string: str,
                 srv_shard_optimized_connection_string: str,
                 type: str):
        GetClusterConnectionStringPrivateEndpointResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_string=connection_string,
            endpoints=endpoints,
            srv_connection_string=srv_connection_string,
            srv_shard_optimized_connection_string=srv_shard_optimized_connection_string,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_string: str,
             endpoints: Sequence['outputs.GetClusterConnectionStringPrivateEndpointEndpointResult'],
             srv_connection_string: str,
             srv_shard_optimized_connection_string: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("connection_string", connection_string)
        _setter("endpoints", endpoints)
        _setter("srv_connection_string", srv_connection_string)
        _setter("srv_shard_optimized_connection_string", srv_shard_optimized_connection_string)
        _setter("type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> str:
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def endpoints(self) -> Sequence['outputs.GetClusterConnectionStringPrivateEndpointEndpointResult']:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> str:
        return pulumi.get(self, "srv_connection_string")

    @property
    @pulumi.getter(name="srvShardOptimizedConnectionString")
    def srv_shard_optimized_connection_string(self) -> str:
        return pulumi.get(self, "srv_shard_optimized_connection_string")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetClusterConnectionStringPrivateEndpointEndpointResult(dict):
    def __init__(__self__, *,
                 endpoint_id: str,
                 provider_name: str,
                 region: str):
        """
        :param str provider_name: Indicates the cloud service provider on which the servers are provisioned.
        """
        GetClusterConnectionStringPrivateEndpointEndpointResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_id=endpoint_id,
            provider_name=provider_name,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_id: str,
             provider_name: str,
             region: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("endpoint_id", endpoint_id)
        _setter("provider_name", provider_name)
        _setter("region", region)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> str:
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Indicates the cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetClusterLabelResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        GetClusterLabelResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterOutageSimulationOutageFilterResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 region_name: str,
                 type: str):
        """
        :param str cloud_provider: The cloud provider of the region that undergoes the outage simulation. Following values are supported:
        :param str region_name: The Atlas name of the region undergoing an outage simulation.
        :param str type: The type of cluster outage simulation. Following values are supported:
        """
        GetClusterOutageSimulationOutageFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_provider=cloud_provider,
            region_name=region_name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_provider: str,
             region_name: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cloud_provider", cloud_provider)
        _setter("region_name", region_name)
        _setter("type", type)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        The cloud provider of the region that undergoes the outage simulation. Following values are supported:
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        The Atlas name of the region undergoing an outage simulation.
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of cluster outage simulation. Following values are supported:
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetClusterReplicationSpecResult(dict):
    def __init__(__self__, *,
                 id: str,
                 num_shards: int,
                 regions_configs: Sequence['outputs.GetClusterReplicationSpecRegionsConfigResult'],
                 zone_name: str):
        """
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster.
        :param int num_shards: Number of shards to deploy in the specified zone.
        :param Sequence['GetClusterReplicationSpecRegionsConfigArgs'] regions_configs: Describes the physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        :param str zone_name: Indicates the n ame for the zone in a Global Cluster.
        """
        GetClusterReplicationSpecResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            num_shards=num_shards,
            regions_configs=regions_configs,
            zone_name=zone_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             num_shards: int,
             regions_configs: Sequence['outputs.GetClusterReplicationSpecRegionsConfigResult'],
             zone_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("num_shards", num_shards)
        _setter("regions_configs", regions_configs)
        _setter("zone_name", zone_name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifer of the replication document for a zone in a Global Cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> int:
        """
        Number of shards to deploy in the specified zone.
        """
        return pulumi.get(self, "num_shards")

    @property
    @pulumi.getter(name="regionsConfigs")
    def regions_configs(self) -> Sequence['outputs.GetClusterReplicationSpecRegionsConfigResult']:
        """
        Describes the physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        """
        return pulumi.get(self, "regions_configs")

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> str:
        """
        Indicates the n ame for the zone in a Global Cluster.
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class GetClusterReplicationSpecRegionsConfigResult(dict):
    def __init__(__self__, *,
                 analytics_nodes: int,
                 electable_nodes: int,
                 priority: int,
                 read_only_nodes: int,
                 region_name: str):
        """
        :param int analytics_nodes: Indicates the number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary.
        :param int electable_nodes: Number of electable nodes for Atlas to deploy to the region.
        :param int priority: Election priority of the region. For regions with only read-only nodes, set this value to 0.
        :param int read_only_nodes: Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        :param str region_name: Name for the region specified.
        """
        GetClusterReplicationSpecRegionsConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            analytics_nodes=analytics_nodes,
            electable_nodes=electable_nodes,
            priority=priority,
            read_only_nodes=read_only_nodes,
            region_name=region_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             analytics_nodes: int,
             electable_nodes: int,
             priority: int,
             read_only_nodes: int,
             region_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("analytics_nodes", analytics_nodes)
        _setter("electable_nodes", electable_nodes)
        _setter("priority", priority)
        _setter("read_only_nodes", read_only_nodes)
        _setter("region_name", region_name)

    @property
    @pulumi.getter(name="analyticsNodes")
    def analytics_nodes(self) -> int:
        """
        Indicates the number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary.
        """
        return pulumi.get(self, "analytics_nodes")

    @property
    @pulumi.getter(name="electableNodes")
    def electable_nodes(self) -> int:
        """
        Number of electable nodes for Atlas to deploy to the region.
        """
        return pulumi.get(self, "electable_nodes")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Election priority of the region. For regions with only read-only nodes, set this value to 0.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="readOnlyNodes")
    def read_only_nodes(self) -> int:
        """
        Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        """
        return pulumi.get(self, "read_only_nodes")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        Name for the region specified.
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class GetClusterSnapshotBackupPolicyResult(dict):
    def __init__(__self__, *,
                 cluster_id: str,
                 cluster_name: str,
                 next_snapshot: str,
                 policies: Sequence['outputs.GetClusterSnapshotBackupPolicyPolicyResult'],
                 reference_hour_of_day: int,
                 reference_minute_of_hour: int,
                 restore_window_days: int,
                 update_snapshots: bool):
        GetClusterSnapshotBackupPolicyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster_id=cluster_id,
            cluster_name=cluster_name,
            next_snapshot=next_snapshot,
            policies=policies,
            reference_hour_of_day=reference_hour_of_day,
            reference_minute_of_hour=reference_minute_of_hour,
            restore_window_days=restore_window_days,
            update_snapshots=update_snapshots,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster_id: str,
             cluster_name: str,
             next_snapshot: str,
             policies: Sequence['outputs.GetClusterSnapshotBackupPolicyPolicyResult'],
             reference_hour_of_day: int,
             reference_minute_of_hour: int,
             restore_window_days: int,
             update_snapshots: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cluster_id", cluster_id)
        _setter("cluster_name", cluster_name)
        _setter("next_snapshot", next_snapshot)
        _setter("policies", policies)
        _setter("reference_hour_of_day", reference_hour_of_day)
        _setter("reference_minute_of_hour", reference_minute_of_hour)
        _setter("restore_window_days", restore_window_days)
        _setter("update_snapshots", update_snapshots)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="nextSnapshot")
    def next_snapshot(self) -> str:
        return pulumi.get(self, "next_snapshot")

    @property
    @pulumi.getter
    def policies(self) -> Sequence['outputs.GetClusterSnapshotBackupPolicyPolicyResult']:
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="referenceHourOfDay")
    def reference_hour_of_day(self) -> int:
        return pulumi.get(self, "reference_hour_of_day")

    @property
    @pulumi.getter(name="referenceMinuteOfHour")
    def reference_minute_of_hour(self) -> int:
        return pulumi.get(self, "reference_minute_of_hour")

    @property
    @pulumi.getter(name="restoreWindowDays")
    def restore_window_days(self) -> int:
        return pulumi.get(self, "restore_window_days")

    @property
    @pulumi.getter(name="updateSnapshots")
    def update_snapshots(self) -> bool:
        return pulumi.get(self, "update_snapshots")


@pulumi.output_type
class GetClusterSnapshotBackupPolicyPolicyResult(dict):
    def __init__(__self__, *,
                 id: str,
                 policy_items: Sequence['outputs.GetClusterSnapshotBackupPolicyPolicyPolicyItemResult']):
        """
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster.
        """
        GetClusterSnapshotBackupPolicyPolicyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            policy_items=policy_items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             policy_items: Sequence['outputs.GetClusterSnapshotBackupPolicyPolicyPolicyItemResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("policy_items", policy_items)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifer of the replication document for a zone in a Global Cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="policyItems")
    def policy_items(self) -> Sequence['outputs.GetClusterSnapshotBackupPolicyPolicyPolicyItemResult']:
        return pulumi.get(self, "policy_items")


@pulumi.output_type
class GetClusterSnapshotBackupPolicyPolicyPolicyItemResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster.
        """
        GetClusterSnapshotBackupPolicyPolicyPolicyItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frequency_interval=frequency_interval,
            frequency_type=frequency_type,
            id=id,
            retention_unit=retention_unit,
            retention_value=retention_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frequency_interval: int,
             frequency_type: str,
             id: str,
             retention_unit: str,
             retention_value: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("frequency_interval", frequency_interval)
        _setter("frequency_type", frequency_type)
        _setter("id", id)
        _setter("retention_unit", retention_unit)
        _setter("retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifer of the replication document for a zone in a Global Cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetClusterTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        GetClusterTagResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClustersResultResult(dict):
    def __init__(__self__, *,
                 advanced_configurations: Sequence['outputs.GetClustersResultAdvancedConfigurationResult'],
                 auto_scaling_compute_enabled: bool,
                 auto_scaling_compute_scale_down_enabled: bool,
                 auto_scaling_disk_gb_enabled: bool,
                 backing_provider_name: str,
                 backup_enabled: bool,
                 bi_connector_configs: Sequence['outputs.GetClustersResultBiConnectorConfigResult'],
                 cluster_type: str,
                 connection_strings: Sequence['outputs.GetClustersResultConnectionStringResult'],
                 container_id: str,
                 disk_size_gb: float,
                 encryption_at_rest_provider: str,
                 labels: Sequence['outputs.GetClustersResultLabelResult'],
                 mongo_db_major_version: str,
                 mongo_db_version: str,
                 mongo_uri: str,
                 mongo_uri_updated: str,
                 mongo_uri_with_options: str,
                 name: str,
                 num_shards: int,
                 paused: bool,
                 pit_enabled: bool,
                 provider_auto_scaling_compute_max_instance_size: str,
                 provider_auto_scaling_compute_min_instance_size: str,
                 provider_backup_enabled: bool,
                 provider_disk_iops: int,
                 provider_disk_type_name: str,
                 provider_encrypt_ebs_volume: bool,
                 provider_instance_size_name: str,
                 provider_name: str,
                 provider_region_name: str,
                 provider_volume_type: str,
                 replication_factor: int,
                 replication_specs: Sequence['outputs.GetClustersResultReplicationSpecResult'],
                 snapshot_backup_policies: Sequence['outputs.GetClustersResultSnapshotBackupPolicyResult'],
                 srv_address: str,
                 state_name: str,
                 tags: Sequence['outputs.GetClustersResultTagResult'],
                 termination_protection_enabled: bool,
                 version_release_system: str):
        """
        :param Sequence['GetClustersResultAdvancedConfigurationArgs'] advanced_configurations: Get the advanced configuration options. See Advanced Configuration below for more details.
        :param bool auto_scaling_compute_enabled: Specifies whether cluster tier auto-scaling is enabled. The default is false.
        :param bool auto_scaling_compute_scale_down_enabled: * `auto_scaling_compute_scale_down_enabled` - Specifies whether cluster tier auto-down-scaling is enabled.
        :param bool auto_scaling_disk_gb_enabled: Indicates whether disk auto-scaling is enabled.
        :param str backing_provider_name: Indicates Cloud service provider on which the server for a multi-tenant cluster is provisioned.
        :param bool backup_enabled: Legacy Option, Indicates whether Atlas continuous backups are enabled for the cluster.
        :param Sequence['GetClustersResultBiConnectorConfigArgs'] bi_connector_configs: Indicates BI Connector for Atlas configuration on this cluster. BI Connector for Atlas is only available for M10+ clusters. See BI Connector below for more details.
        :param str cluster_type: Indicates the type of the cluster that you want to modify. You cannot convert a sharded cluster deployment to a replica set deployment.
        :param Sequence['GetClustersResultConnectionStringArgs'] connection_strings: Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.
               - `connection_strings.standard` -   Public mongodb:// connection string for this cluster.
               - `connection_strings.standard_srv` - Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t, use connectionStrings.standard.
               - `connection_strings.private` -   [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
               - `connection_strings.private_srv` -  [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
               - `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
               - `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint.
               - `connection_strings.private_endpoint.#.srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint.
               - `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
               - `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`
               - `connection_strings.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.
               - `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
               - `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.
        :param str container_id: The Network Peering Container ID.
        :param float disk_size_gb: Indicates the size in gigabytes of the server’s root volume (AWS/GCP Only).
        :param str encryption_at_rest_provider: Indicates whether Encryption at Rest is enabled or disabled.
        :param Sequence['GetClustersResultLabelArgs'] labels: Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below. **DEPRECATED** Use `tags` instead.
        :param str mongo_db_major_version: Indicates the version of the cluster to deploy.
        :param str mongo_db_version: Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.
        :param str mongo_uri: Base connection string for the cluster. Atlas only displays this field after the cluster is operational, not while it builds the cluster.
        :param str mongo_uri_updated: Lists when the connection string was last updated. The connection string changes, for example, if you change a replica set to a sharded cluster.
        :param str mongo_uri_with_options: Describes connection string for connecting to the Atlas cluster. Includes the replicaSet, ssl, and authSource query parameters in the connection string with values appropriate for the cluster.
        :param str name: The name of the current plugin
        :param int num_shards: Number of shards to deploy in the specified zone.
        :param bool paused: Flag that indicates whether the cluster is paused or not.
        :param bool pit_enabled: Flag that indicates if the cluster uses Continuous Cloud Backup.
        :param str provider_auto_scaling_compute_max_instance_size: Maximum instance size to which your cluster can automatically scale.
        :param str provider_auto_scaling_compute_min_instance_size: Minimum instance size to which your cluster can automatically scale.
        :param bool provider_backup_enabled: Flag indicating if the cluster uses Cloud Backup Snapshots for backups. **DEPRECATED** Use `cloud_backup` instead.
        :param int provider_disk_iops: Indicates the maximum input/output operations per second (IOPS) the system can perform. The possible values depend on the selected providerSettings.instanceSizeName and diskSizeGB.
        :param str provider_disk_type_name: Describes Azure disk type of the server’s root volume (Azure Only).
        :param bool provider_encrypt_ebs_volume: **(DEPRECATED)** Indicates whether the Amazon EBS encryption is enabled. This feature encrypts the server’s root volume for both data at rest within the volume and data moving between the volume and the instance. By default this attribute is always enabled, per deprecation process showing the real value at `provider_encrypt_ebs_volume_flag` computed attribute.
        :param str provider_instance_size_name: Atlas provides different instance sizes, each with a default storage capacity and RAM size.
        :param str provider_name: Indicates the cloud service provider on which the servers are provisioned.
        :param str provider_region_name: Indicates Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases. Requires the Atlas Region name, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        :param str provider_volume_type: Indicates the type of the volume. The possible values are: `STANDARD` and `PROVISIONED`.
               > **NOTE:** `STANDARD` is not available for NVME clusters.
        :param int replication_factor: (Deprecated) Number of replica set members. Each member keeps a copy of your databases, providing high availability and data redundancy. The possible values are 3, 5, or 7. The default value is 3.
        :param Sequence['GetClustersResultReplicationSpecArgs'] replication_specs: Configuration for cluster regions.  See Replication Spec below for more details.
        :param Sequence['GetClustersResultSnapshotBackupPolicyArgs'] snapshot_backup_policies: current snapshot schedule and retention settings for the cluster.
        :param str srv_address: Connection string for connecting to the Atlas cluster. The +srv modifier forces the connection to use TLS/SSL. See the mongoURI for additional options.
        :param str state_name: Indicates the current state of the cluster. The possible states are:
               - IDLE
               - CREATING
               - UPDATING
               - DELETING
               - DELETED
               - REPAIRING
        :param Sequence['GetClustersResultTagArgs'] tags: Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.
        :param bool termination_protection_enabled: Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.
        :param str version_release_system: Release cadence that Atlas uses for this cluster.
        """
        GetClustersResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            advanced_configurations=advanced_configurations,
            auto_scaling_compute_enabled=auto_scaling_compute_enabled,
            auto_scaling_compute_scale_down_enabled=auto_scaling_compute_scale_down_enabled,
            auto_scaling_disk_gb_enabled=auto_scaling_disk_gb_enabled,
            backing_provider_name=backing_provider_name,
            backup_enabled=backup_enabled,
            bi_connector_configs=bi_connector_configs,
            cluster_type=cluster_type,
            connection_strings=connection_strings,
            container_id=container_id,
            disk_size_gb=disk_size_gb,
            encryption_at_rest_provider=encryption_at_rest_provider,
            labels=labels,
            mongo_db_major_version=mongo_db_major_version,
            mongo_db_version=mongo_db_version,
            mongo_uri=mongo_uri,
            mongo_uri_updated=mongo_uri_updated,
            mongo_uri_with_options=mongo_uri_with_options,
            name=name,
            num_shards=num_shards,
            paused=paused,
            pit_enabled=pit_enabled,
            provider_auto_scaling_compute_max_instance_size=provider_auto_scaling_compute_max_instance_size,
            provider_auto_scaling_compute_min_instance_size=provider_auto_scaling_compute_min_instance_size,
            provider_backup_enabled=provider_backup_enabled,
            provider_disk_iops=provider_disk_iops,
            provider_disk_type_name=provider_disk_type_name,
            provider_encrypt_ebs_volume=provider_encrypt_ebs_volume,
            provider_instance_size_name=provider_instance_size_name,
            provider_name=provider_name,
            provider_region_name=provider_region_name,
            provider_volume_type=provider_volume_type,
            replication_factor=replication_factor,
            replication_specs=replication_specs,
            snapshot_backup_policies=snapshot_backup_policies,
            srv_address=srv_address,
            state_name=state_name,
            tags=tags,
            termination_protection_enabled=termination_protection_enabled,
            version_release_system=version_release_system,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             advanced_configurations: Sequence['outputs.GetClustersResultAdvancedConfigurationResult'],
             auto_scaling_compute_enabled: bool,
             auto_scaling_compute_scale_down_enabled: bool,
             auto_scaling_disk_gb_enabled: bool,
             backing_provider_name: str,
             backup_enabled: bool,
             bi_connector_configs: Sequence['outputs.GetClustersResultBiConnectorConfigResult'],
             cluster_type: str,
             connection_strings: Sequence['outputs.GetClustersResultConnectionStringResult'],
             container_id: str,
             disk_size_gb: float,
             encryption_at_rest_provider: str,
             labels: Sequence['outputs.GetClustersResultLabelResult'],
             mongo_db_major_version: str,
             mongo_db_version: str,
             mongo_uri: str,
             mongo_uri_updated: str,
             mongo_uri_with_options: str,
             name: str,
             num_shards: int,
             paused: bool,
             pit_enabled: bool,
             provider_auto_scaling_compute_max_instance_size: str,
             provider_auto_scaling_compute_min_instance_size: str,
             provider_backup_enabled: bool,
             provider_disk_iops: int,
             provider_disk_type_name: str,
             provider_encrypt_ebs_volume: bool,
             provider_instance_size_name: str,
             provider_name: str,
             provider_region_name: str,
             provider_volume_type: str,
             replication_factor: int,
             replication_specs: Sequence['outputs.GetClustersResultReplicationSpecResult'],
             snapshot_backup_policies: Sequence['outputs.GetClustersResultSnapshotBackupPolicyResult'],
             srv_address: str,
             state_name: str,
             tags: Sequence['outputs.GetClustersResultTagResult'],
             termination_protection_enabled: bool,
             version_release_system: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("advanced_configurations", advanced_configurations)
        _setter("auto_scaling_compute_enabled", auto_scaling_compute_enabled)
        _setter("auto_scaling_compute_scale_down_enabled", auto_scaling_compute_scale_down_enabled)
        _setter("auto_scaling_disk_gb_enabled", auto_scaling_disk_gb_enabled)
        _setter("backing_provider_name", backing_provider_name)
        _setter("backup_enabled", backup_enabled)
        _setter("bi_connector_configs", bi_connector_configs)
        _setter("cluster_type", cluster_type)
        _setter("connection_strings", connection_strings)
        _setter("container_id", container_id)
        _setter("disk_size_gb", disk_size_gb)
        _setter("encryption_at_rest_provider", encryption_at_rest_provider)
        _setter("labels", labels)
        _setter("mongo_db_major_version", mongo_db_major_version)
        _setter("mongo_db_version", mongo_db_version)
        _setter("mongo_uri", mongo_uri)
        _setter("mongo_uri_updated", mongo_uri_updated)
        _setter("mongo_uri_with_options", mongo_uri_with_options)
        _setter("name", name)
        _setter("num_shards", num_shards)
        _setter("paused", paused)
        _setter("pit_enabled", pit_enabled)
        _setter("provider_auto_scaling_compute_max_instance_size", provider_auto_scaling_compute_max_instance_size)
        _setter("provider_auto_scaling_compute_min_instance_size", provider_auto_scaling_compute_min_instance_size)
        _setter("provider_backup_enabled", provider_backup_enabled)
        _setter("provider_disk_iops", provider_disk_iops)
        _setter("provider_disk_type_name", provider_disk_type_name)
        _setter("provider_encrypt_ebs_volume", provider_encrypt_ebs_volume)
        _setter("provider_instance_size_name", provider_instance_size_name)
        _setter("provider_name", provider_name)
        _setter("provider_region_name", provider_region_name)
        _setter("provider_volume_type", provider_volume_type)
        _setter("replication_factor", replication_factor)
        _setter("replication_specs", replication_specs)
        _setter("snapshot_backup_policies", snapshot_backup_policies)
        _setter("srv_address", srv_address)
        _setter("state_name", state_name)
        _setter("tags", tags)
        _setter("termination_protection_enabled", termination_protection_enabled)
        _setter("version_release_system", version_release_system)

    @property
    @pulumi.getter(name="advancedConfigurations")
    def advanced_configurations(self) -> Sequence['outputs.GetClustersResultAdvancedConfigurationResult']:
        """
        Get the advanced configuration options. See Advanced Configuration below for more details.
        """
        return pulumi.get(self, "advanced_configurations")

    @property
    @pulumi.getter(name="autoScalingComputeEnabled")
    def auto_scaling_compute_enabled(self) -> bool:
        """
        Specifies whether cluster tier auto-scaling is enabled. The default is false.
        """
        return pulumi.get(self, "auto_scaling_compute_enabled")

    @property
    @pulumi.getter(name="autoScalingComputeScaleDownEnabled")
    def auto_scaling_compute_scale_down_enabled(self) -> bool:
        """
        * `auto_scaling_compute_scale_down_enabled` - Specifies whether cluster tier auto-down-scaling is enabled.
        """
        return pulumi.get(self, "auto_scaling_compute_scale_down_enabled")

    @property
    @pulumi.getter(name="autoScalingDiskGbEnabled")
    def auto_scaling_disk_gb_enabled(self) -> bool:
        """
        Indicates whether disk auto-scaling is enabled.
        """
        return pulumi.get(self, "auto_scaling_disk_gb_enabled")

    @property
    @pulumi.getter(name="backingProviderName")
    def backing_provider_name(self) -> str:
        """
        Indicates Cloud service provider on which the server for a multi-tenant cluster is provisioned.
        """
        return pulumi.get(self, "backing_provider_name")

    @property
    @pulumi.getter(name="backupEnabled")
    def backup_enabled(self) -> bool:
        """
        Legacy Option, Indicates whether Atlas continuous backups are enabled for the cluster.
        """
        return pulumi.get(self, "backup_enabled")

    @property
    @pulumi.getter(name="biConnectorConfigs")
    def bi_connector_configs(self) -> Sequence['outputs.GetClustersResultBiConnectorConfigResult']:
        """
        Indicates BI Connector for Atlas configuration on this cluster. BI Connector for Atlas is only available for M10+ clusters. See BI Connector below for more details.
        """
        return pulumi.get(self, "bi_connector_configs")

    @property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> str:
        """
        Indicates the type of the cluster that you want to modify. You cannot convert a sharded cluster deployment to a replica set deployment.
        """
        return pulumi.get(self, "cluster_type")

    @property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Sequence['outputs.GetClustersResultConnectionStringResult']:
        """
        Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.
        - `connection_strings.standard` -   Public mongodb:// connection string for this cluster.
        - `connection_strings.standard_srv` - Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t, use connectionStrings.standard.
        - `connection_strings.private` -   [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        - `connection_strings.private_srv` -  [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        - `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
        - `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint.
        - `connection_strings.private_endpoint.#.srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint.
        - `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
        - `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`
        - `connection_strings.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.
        - `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
        - `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.
        """
        return pulumi.get(self, "connection_strings")

    @property
    @pulumi.getter(name="containerId")
    def container_id(self) -> str:
        """
        The Network Peering Container ID.
        """
        return pulumi.get(self, "container_id")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> float:
        """
        Indicates the size in gigabytes of the server’s root volume (AWS/GCP Only).
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter(name="encryptionAtRestProvider")
    def encryption_at_rest_provider(self) -> str:
        """
        Indicates whether Encryption at Rest is enabled or disabled.
        """
        return pulumi.get(self, "encryption_at_rest_provider")

    @property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetClustersResultLabelResult']:
        """
        Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below. **DEPRECATED** Use `tags` instead.
        """
        warnings.warn("""this parameter is deprecated and will be removed by September 2024, please transition to tags""", DeprecationWarning)
        pulumi.log.warn("""labels is deprecated: this parameter is deprecated and will be removed by September 2024, please transition to tags""")

        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="mongoDbMajorVersion")
    def mongo_db_major_version(self) -> str:
        """
        Indicates the version of the cluster to deploy.
        """
        return pulumi.get(self, "mongo_db_major_version")

    @property
    @pulumi.getter(name="mongoDbVersion")
    def mongo_db_version(self) -> str:
        """
        Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.
        """
        return pulumi.get(self, "mongo_db_version")

    @property
    @pulumi.getter(name="mongoUri")
    def mongo_uri(self) -> str:
        """
        Base connection string for the cluster. Atlas only displays this field after the cluster is operational, not while it builds the cluster.
        """
        return pulumi.get(self, "mongo_uri")

    @property
    @pulumi.getter(name="mongoUriUpdated")
    def mongo_uri_updated(self) -> str:
        """
        Lists when the connection string was last updated. The connection string changes, for example, if you change a replica set to a sharded cluster.
        """
        return pulumi.get(self, "mongo_uri_updated")

    @property
    @pulumi.getter(name="mongoUriWithOptions")
    def mongo_uri_with_options(self) -> str:
        """
        Describes connection string for connecting to the Atlas cluster. Includes the replicaSet, ssl, and authSource query parameters in the connection string with values appropriate for the cluster.
        """
        return pulumi.get(self, "mongo_uri_with_options")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the current plugin
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> int:
        """
        Number of shards to deploy in the specified zone.
        """
        return pulumi.get(self, "num_shards")

    @property
    @pulumi.getter
    def paused(self) -> bool:
        """
        Flag that indicates whether the cluster is paused or not.
        """
        return pulumi.get(self, "paused")

    @property
    @pulumi.getter(name="pitEnabled")
    def pit_enabled(self) -> bool:
        """
        Flag that indicates if the cluster uses Continuous Cloud Backup.
        """
        return pulumi.get(self, "pit_enabled")

    @property
    @pulumi.getter(name="providerAutoScalingComputeMaxInstanceSize")
    def provider_auto_scaling_compute_max_instance_size(self) -> str:
        """
        Maximum instance size to which your cluster can automatically scale.
        """
        return pulumi.get(self, "provider_auto_scaling_compute_max_instance_size")

    @property
    @pulumi.getter(name="providerAutoScalingComputeMinInstanceSize")
    def provider_auto_scaling_compute_min_instance_size(self) -> str:
        """
        Minimum instance size to which your cluster can automatically scale.
        """
        return pulumi.get(self, "provider_auto_scaling_compute_min_instance_size")

    @property
    @pulumi.getter(name="providerBackupEnabled")
    def provider_backup_enabled(self) -> bool:
        """
        Flag indicating if the cluster uses Cloud Backup Snapshots for backups. **DEPRECATED** Use `cloud_backup` instead.
        """
        return pulumi.get(self, "provider_backup_enabled")

    @property
    @pulumi.getter(name="providerDiskIops")
    def provider_disk_iops(self) -> int:
        """
        Indicates the maximum input/output operations per second (IOPS) the system can perform. The possible values depend on the selected providerSettings.instanceSizeName and diskSizeGB.
        """
        return pulumi.get(self, "provider_disk_iops")

    @property
    @pulumi.getter(name="providerDiskTypeName")
    def provider_disk_type_name(self) -> str:
        """
        Describes Azure disk type of the server’s root volume (Azure Only).
        """
        return pulumi.get(self, "provider_disk_type_name")

    @property
    @pulumi.getter(name="providerEncryptEbsVolume")
    def provider_encrypt_ebs_volume(self) -> bool:
        """
        **(DEPRECATED)** Indicates whether the Amazon EBS encryption is enabled. This feature encrypts the server’s root volume for both data at rest within the volume and data moving between the volume and the instance. By default this attribute is always enabled, per deprecation process showing the real value at `provider_encrypt_ebs_volume_flag` computed attribute.
        """
        return pulumi.get(self, "provider_encrypt_ebs_volume")

    @property
    @pulumi.getter(name="providerInstanceSizeName")
    def provider_instance_size_name(self) -> str:
        """
        Atlas provides different instance sizes, each with a default storage capacity and RAM size.
        """
        return pulumi.get(self, "provider_instance_size_name")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Indicates the cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter(name="providerRegionName")
    def provider_region_name(self) -> str:
        """
        Indicates Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases. Requires the Atlas Region name, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        """
        return pulumi.get(self, "provider_region_name")

    @property
    @pulumi.getter(name="providerVolumeType")
    def provider_volume_type(self) -> str:
        """
        Indicates the type of the volume. The possible values are: `STANDARD` and `PROVISIONED`.
        > **NOTE:** `STANDARD` is not available for NVME clusters.
        """
        return pulumi.get(self, "provider_volume_type")

    @property
    @pulumi.getter(name="replicationFactor")
    def replication_factor(self) -> int:
        """
        (Deprecated) Number of replica set members. Each member keeps a copy of your databases, providing high availability and data redundancy. The possible values are 3, 5, or 7. The default value is 3.
        """
        return pulumi.get(self, "replication_factor")

    @property
    @pulumi.getter(name="replicationSpecs")
    def replication_specs(self) -> Sequence['outputs.GetClustersResultReplicationSpecResult']:
        """
        Configuration for cluster regions.  See Replication Spec below for more details.
        """
        return pulumi.get(self, "replication_specs")

    @property
    @pulumi.getter(name="snapshotBackupPolicies")
    def snapshot_backup_policies(self) -> Sequence['outputs.GetClustersResultSnapshotBackupPolicyResult']:
        """
        current snapshot schedule and retention settings for the cluster.
        """
        return pulumi.get(self, "snapshot_backup_policies")

    @property
    @pulumi.getter(name="srvAddress")
    def srv_address(self) -> str:
        """
        Connection string for connecting to the Atlas cluster. The +srv modifier forces the connection to use TLS/SSL. See the mongoURI for additional options.
        """
        return pulumi.get(self, "srv_address")

    @property
    @pulumi.getter(name="stateName")
    def state_name(self) -> str:
        """
        Indicates the current state of the cluster. The possible states are:
        - IDLE
        - CREATING
        - UPDATING
        - DELETING
        - DELETED
        - REPAIRING
        """
        return pulumi.get(self, "state_name")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetClustersResultTagResult']:
        """
        Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="terminationProtectionEnabled")
    def termination_protection_enabled(self) -> bool:
        """
        Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.
        """
        return pulumi.get(self, "termination_protection_enabled")

    @property
    @pulumi.getter(name="versionReleaseSystem")
    def version_release_system(self) -> str:
        """
        Release cadence that Atlas uses for this cluster.
        """
        return pulumi.get(self, "version_release_system")


@pulumi.output_type
class GetClustersResultAdvancedConfigurationResult(dict):
    def __init__(__self__, *,
                 default_read_concern: str,
                 default_write_concern: str,
                 fail_index_key_too_long: bool,
                 javascript_enabled: bool,
                 minimum_enabled_tls_protocol: str,
                 no_table_scan: bool,
                 oplog_min_retention_hours: int,
                 oplog_size_mb: int,
                 sample_refresh_interval_bi_connector: int,
                 sample_size_bi_connector: int,
                 transaction_lifetime_limit_seconds: int):
        """
        :param str default_read_concern: [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        :param str default_write_concern: [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        :param bool fail_index_key_too_long: When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        :param bool javascript_enabled: When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        :param str minimum_enabled_tls_protocol: Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        :param bool no_table_scan: When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        :param int oplog_min_retention_hours: Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        :param int oplog_size_mb: The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        :param int sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param int sample_size_bi_connector: Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        GetClustersResultAdvancedConfigurationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_read_concern=default_read_concern,
            default_write_concern=default_write_concern,
            fail_index_key_too_long=fail_index_key_too_long,
            javascript_enabled=javascript_enabled,
            minimum_enabled_tls_protocol=minimum_enabled_tls_protocol,
            no_table_scan=no_table_scan,
            oplog_min_retention_hours=oplog_min_retention_hours,
            oplog_size_mb=oplog_size_mb,
            sample_refresh_interval_bi_connector=sample_refresh_interval_bi_connector,
            sample_size_bi_connector=sample_size_bi_connector,
            transaction_lifetime_limit_seconds=transaction_lifetime_limit_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_read_concern: str,
             default_write_concern: str,
             fail_index_key_too_long: bool,
             javascript_enabled: bool,
             minimum_enabled_tls_protocol: str,
             no_table_scan: bool,
             oplog_min_retention_hours: int,
             oplog_size_mb: int,
             sample_refresh_interval_bi_connector: int,
             sample_size_bi_connector: int,
             transaction_lifetime_limit_seconds: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("default_read_concern", default_read_concern)
        _setter("default_write_concern", default_write_concern)
        _setter("fail_index_key_too_long", fail_index_key_too_long)
        _setter("javascript_enabled", javascript_enabled)
        _setter("minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        _setter("no_table_scan", no_table_scan)
        _setter("oplog_min_retention_hours", oplog_min_retention_hours)
        _setter("oplog_size_mb", oplog_size_mb)
        _setter("sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        _setter("sample_size_bi_connector", sample_size_bi_connector)
        _setter("transaction_lifetime_limit_seconds", transaction_lifetime_limit_seconds)

    @property
    @pulumi.getter(name="defaultReadConcern")
    def default_read_concern(self) -> str:
        """
        [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        """
        return pulumi.get(self, "default_read_concern")

    @property
    @pulumi.getter(name="defaultWriteConcern")
    def default_write_concern(self) -> str:
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        return pulumi.get(self, "default_write_concern")

    @property
    @pulumi.getter(name="failIndexKeyTooLong")
    def fail_index_key_too_long(self) -> bool:
        """
        When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        """
        return pulumi.get(self, "fail_index_key_too_long")

    @property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> bool:
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        return pulumi.get(self, "javascript_enabled")

    @property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> str:
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> bool:
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        return pulumi.get(self, "no_table_scan")

    @property
    @pulumi.getter(name="oplogMinRetentionHours")
    def oplog_min_retention_hours(self) -> int:
        """
        Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        """
        return pulumi.get(self, "oplog_min_retention_hours")

    @property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> int:
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        return pulumi.get(self, "oplog_size_mb")

    @property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> int:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> int:
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_size_bi_connector")

    @property
    @pulumi.getter(name="transactionLifetimeLimitSeconds")
    def transaction_lifetime_limit_seconds(self) -> int:
        return pulumi.get(self, "transaction_lifetime_limit_seconds")


@pulumi.output_type
class GetClustersResultBiConnectorConfigResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 read_preference: str):
        """
        :param bool enabled: Indicates whether or not BI Connector for Atlas is enabled on the cluster.
        :param str read_preference: Indicates the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        GetClustersResultBiConnectorConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            read_preference=read_preference,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: bool,
             read_preference: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("enabled", enabled)
        _setter("read_preference", read_preference)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Indicates whether or not BI Connector for Atlas is enabled on the cluster.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> str:
        """
        Indicates the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        return pulumi.get(self, "read_preference")


@pulumi.output_type
class GetClustersResultConnectionStringResult(dict):
    def __init__(__self__, *,
                 aws_private_link: Mapping[str, Any],
                 aws_private_link_srv: Mapping[str, Any],
                 private: str,
                 private_endpoints: Sequence['outputs.GetClustersResultConnectionStringPrivateEndpointResult'],
                 private_srv: str,
                 standard: str,
                 standard_srv: str):
        GetClustersResultConnectionStringResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aws_private_link=aws_private_link,
            aws_private_link_srv=aws_private_link_srv,
            private=private,
            private_endpoints=private_endpoints,
            private_srv=private_srv,
            standard=standard,
            standard_srv=standard_srv,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aws_private_link: Mapping[str, Any],
             aws_private_link_srv: Mapping[str, Any],
             private: str,
             private_endpoints: Sequence['outputs.GetClustersResultConnectionStringPrivateEndpointResult'],
             private_srv: str,
             standard: str,
             standard_srv: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aws_private_link", aws_private_link)
        _setter("aws_private_link_srv", aws_private_link_srv)
        _setter("private", private)
        _setter("private_endpoints", private_endpoints)
        _setter("private_srv", private_srv)
        _setter("standard", standard)
        _setter("standard_srv", standard_srv)

    @property
    @pulumi.getter(name="awsPrivateLink")
    def aws_private_link(self) -> Mapping[str, Any]:
        return pulumi.get(self, "aws_private_link")

    @property
    @pulumi.getter(name="awsPrivateLinkSrv")
    def aws_private_link_srv(self) -> Mapping[str, Any]:
        return pulumi.get(self, "aws_private_link_srv")

    @property
    @pulumi.getter
    def private(self) -> str:
        return pulumi.get(self, "private")

    @property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Sequence['outputs.GetClustersResultConnectionStringPrivateEndpointResult']:
        return pulumi.get(self, "private_endpoints")

    @property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> str:
        return pulumi.get(self, "private_srv")

    @property
    @pulumi.getter
    def standard(self) -> str:
        return pulumi.get(self, "standard")

    @property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> str:
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class GetClustersResultConnectionStringPrivateEndpointResult(dict):
    def __init__(__self__, *,
                 connection_string: str,
                 endpoints: Sequence['outputs.GetClustersResultConnectionStringPrivateEndpointEndpointResult'],
                 srv_connection_string: str,
                 srv_shard_optimized_connection_string: str,
                 type: str):
        GetClustersResultConnectionStringPrivateEndpointResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_string=connection_string,
            endpoints=endpoints,
            srv_connection_string=srv_connection_string,
            srv_shard_optimized_connection_string=srv_shard_optimized_connection_string,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_string: str,
             endpoints: Sequence['outputs.GetClustersResultConnectionStringPrivateEndpointEndpointResult'],
             srv_connection_string: str,
             srv_shard_optimized_connection_string: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("connection_string", connection_string)
        _setter("endpoints", endpoints)
        _setter("srv_connection_string", srv_connection_string)
        _setter("srv_shard_optimized_connection_string", srv_shard_optimized_connection_string)
        _setter("type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> str:
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def endpoints(self) -> Sequence['outputs.GetClustersResultConnectionStringPrivateEndpointEndpointResult']:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> str:
        return pulumi.get(self, "srv_connection_string")

    @property
    @pulumi.getter(name="srvShardOptimizedConnectionString")
    def srv_shard_optimized_connection_string(self) -> str:
        return pulumi.get(self, "srv_shard_optimized_connection_string")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetClustersResultConnectionStringPrivateEndpointEndpointResult(dict):
    def __init__(__self__, *,
                 endpoint_id: str,
                 provider_name: str,
                 region: str):
        """
        :param str provider_name: Indicates the cloud service provider on which the servers are provisioned.
        """
        GetClustersResultConnectionStringPrivateEndpointEndpointResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_id=endpoint_id,
            provider_name=provider_name,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_id: str,
             provider_name: str,
             region: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("endpoint_id", endpoint_id)
        _setter("provider_name", provider_name)
        _setter("region", region)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> str:
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Indicates the cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetClustersResultLabelResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        GetClustersResultLabelResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClustersResultReplicationSpecResult(dict):
    def __init__(__self__, *,
                 id: str,
                 num_shards: int,
                 regions_configs: Sequence['outputs.GetClustersResultReplicationSpecRegionsConfigResult'],
                 zone_name: str):
        """
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster.
        :param int num_shards: Number of shards to deploy in the specified zone.
        :param Sequence['GetClustersResultReplicationSpecRegionsConfigArgs'] regions_configs: Describes the physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        :param str zone_name: Indicates the n ame for the zone in a Global Cluster.
        """
        GetClustersResultReplicationSpecResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            num_shards=num_shards,
            regions_configs=regions_configs,
            zone_name=zone_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             num_shards: int,
             regions_configs: Sequence['outputs.GetClustersResultReplicationSpecRegionsConfigResult'],
             zone_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("num_shards", num_shards)
        _setter("regions_configs", regions_configs)
        _setter("zone_name", zone_name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifer of the replication document for a zone in a Global Cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> int:
        """
        Number of shards to deploy in the specified zone.
        """
        return pulumi.get(self, "num_shards")

    @property
    @pulumi.getter(name="regionsConfigs")
    def regions_configs(self) -> Sequence['outputs.GetClustersResultReplicationSpecRegionsConfigResult']:
        """
        Describes the physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        """
        return pulumi.get(self, "regions_configs")

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> str:
        """
        Indicates the n ame for the zone in a Global Cluster.
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class GetClustersResultReplicationSpecRegionsConfigResult(dict):
    def __init__(__self__, *,
                 analytics_nodes: int,
                 electable_nodes: int,
                 priority: int,
                 read_only_nodes: int,
                 region_name: str):
        """
        :param int analytics_nodes: Indicates the number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary.
        :param int electable_nodes: Number of electable nodes for Atlas to deploy to the region.
        :param int priority: Election priority of the region. For regions with only read-only nodes, set this value to 0.
        :param int read_only_nodes: Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        :param str region_name: Name for the region specified.
        """
        GetClustersResultReplicationSpecRegionsConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            analytics_nodes=analytics_nodes,
            electable_nodes=electable_nodes,
            priority=priority,
            read_only_nodes=read_only_nodes,
            region_name=region_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             analytics_nodes: int,
             electable_nodes: int,
             priority: int,
             read_only_nodes: int,
             region_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("analytics_nodes", analytics_nodes)
        _setter("electable_nodes", electable_nodes)
        _setter("priority", priority)
        _setter("read_only_nodes", read_only_nodes)
        _setter("region_name", region_name)

    @property
    @pulumi.getter(name="analyticsNodes")
    def analytics_nodes(self) -> int:
        """
        Indicates the number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary.
        """
        return pulumi.get(self, "analytics_nodes")

    @property
    @pulumi.getter(name="electableNodes")
    def electable_nodes(self) -> int:
        """
        Number of electable nodes for Atlas to deploy to the region.
        """
        return pulumi.get(self, "electable_nodes")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Election priority of the region. For regions with only read-only nodes, set this value to 0.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="readOnlyNodes")
    def read_only_nodes(self) -> int:
        """
        Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        """
        return pulumi.get(self, "read_only_nodes")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        Name for the region specified.
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class GetClustersResultSnapshotBackupPolicyResult(dict):
    def __init__(__self__, *,
                 cluster_id: str,
                 cluster_name: str,
                 next_snapshot: str,
                 policies: Sequence['outputs.GetClustersResultSnapshotBackupPolicyPolicyResult'],
                 reference_hour_of_day: int,
                 reference_minute_of_hour: int,
                 restore_window_days: int,
                 update_snapshots: bool):
        GetClustersResultSnapshotBackupPolicyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster_id=cluster_id,
            cluster_name=cluster_name,
            next_snapshot=next_snapshot,
            policies=policies,
            reference_hour_of_day=reference_hour_of_day,
            reference_minute_of_hour=reference_minute_of_hour,
            restore_window_days=restore_window_days,
            update_snapshots=update_snapshots,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster_id: str,
             cluster_name: str,
             next_snapshot: str,
             policies: Sequence['outputs.GetClustersResultSnapshotBackupPolicyPolicyResult'],
             reference_hour_of_day: int,
             reference_minute_of_hour: int,
             restore_window_days: int,
             update_snapshots: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cluster_id", cluster_id)
        _setter("cluster_name", cluster_name)
        _setter("next_snapshot", next_snapshot)
        _setter("policies", policies)
        _setter("reference_hour_of_day", reference_hour_of_day)
        _setter("reference_minute_of_hour", reference_minute_of_hour)
        _setter("restore_window_days", restore_window_days)
        _setter("update_snapshots", update_snapshots)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="nextSnapshot")
    def next_snapshot(self) -> str:
        return pulumi.get(self, "next_snapshot")

    @property
    @pulumi.getter
    def policies(self) -> Sequence['outputs.GetClustersResultSnapshotBackupPolicyPolicyResult']:
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="referenceHourOfDay")
    def reference_hour_of_day(self) -> int:
        return pulumi.get(self, "reference_hour_of_day")

    @property
    @pulumi.getter(name="referenceMinuteOfHour")
    def reference_minute_of_hour(self) -> int:
        return pulumi.get(self, "reference_minute_of_hour")

    @property
    @pulumi.getter(name="restoreWindowDays")
    def restore_window_days(self) -> int:
        return pulumi.get(self, "restore_window_days")

    @property
    @pulumi.getter(name="updateSnapshots")
    def update_snapshots(self) -> bool:
        return pulumi.get(self, "update_snapshots")


@pulumi.output_type
class GetClustersResultSnapshotBackupPolicyPolicyResult(dict):
    def __init__(__self__, *,
                 id: str,
                 policy_items: Sequence['outputs.GetClustersResultSnapshotBackupPolicyPolicyPolicyItemResult']):
        """
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster.
        """
        GetClustersResultSnapshotBackupPolicyPolicyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            policy_items=policy_items,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             policy_items: Sequence['outputs.GetClustersResultSnapshotBackupPolicyPolicyPolicyItemResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("policy_items", policy_items)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifer of the replication document for a zone in a Global Cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="policyItems")
    def policy_items(self) -> Sequence['outputs.GetClustersResultSnapshotBackupPolicyPolicyPolicyItemResult']:
        return pulumi.get(self, "policy_items")


@pulumi.output_type
class GetClustersResultSnapshotBackupPolicyPolicyPolicyItemResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster.
        """
        GetClustersResultSnapshotBackupPolicyPolicyPolicyItemResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frequency_interval=frequency_interval,
            frequency_type=frequency_type,
            id=id,
            retention_unit=retention_unit,
            retention_value=retention_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frequency_interval: int,
             frequency_type: str,
             id: str,
             retention_unit: str,
             retention_value: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("frequency_interval", frequency_interval)
        _setter("frequency_type", frequency_type)
        _setter("id", id)
        _setter("retention_unit", retention_unit)
        _setter("retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifer of the replication document for a zone in a Global Cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetClustersResultTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        GetClustersResultTagResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCustomDbRoleActionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 resources: Sequence['outputs.GetCustomDbRoleActionResourceResult']):
        """
        :param str action: (Required) Name of the privilege action. For a complete list of actions available in the Atlas API, see Custom Role Actions.
        :param Sequence['GetCustomDbRoleActionResourceArgs'] resources: (Required) Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
        """
        GetCustomDbRoleActionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            resources=resources,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: str,
             resources: Sequence['outputs.GetCustomDbRoleActionResourceResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action", action)
        _setter("resources", resources)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        (Required) Name of the privilege action. For a complete list of actions available in the Atlas API, see Custom Role Actions.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetCustomDbRoleActionResourceResult']:
        """
        (Required) Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetCustomDbRoleActionResourceResult(dict):
    def __init__(__self__, *,
                 cluster: bool,
                 collection_name: str,
                 database_name: str):
        """
        :param str database_name: (Required) Database on which the inherited role is granted.
        """
        GetCustomDbRoleActionResourceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster=cluster,
            collection_name=collection_name,
            database_name=database_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster: bool,
             collection_name: str,
             database_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cluster", cluster)
        _setter("collection_name", collection_name)
        _setter("database_name", database_name)

    @property
    @pulumi.getter
    def cluster(self) -> bool:
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> str:
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        (Required) Database on which the inherited role is granted.
        """
        return pulumi.get(self, "database_name")


@pulumi.output_type
class GetCustomDbRoleInheritedRoleResult(dict):
    def __init__(__self__, *,
                 database_name: str,
                 role_name: str):
        """
        :param str database_name: (Required) Database on which the inherited role is granted.
        :param str role_name: Name of the custom role.
        """
        GetCustomDbRoleInheritedRoleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            role_name=role_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: str,
             role_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database_name", database_name)
        _setter("role_name", role_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        (Required) Database on which the inherited role is granted.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        """
        Name of the custom role.
        """
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetCustomDbRolesResultResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetCustomDbRolesResultActionResult'],
                 inherited_roles: Sequence['outputs.GetCustomDbRolesResultInheritedRoleResult'],
                 role_name: str):
        """
        :param str role_name: (Required) Name of the inherited role. This can either be another custom role or a built-in role.
        """
        GetCustomDbRolesResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            inherited_roles=inherited_roles,
            role_name=role_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Sequence['outputs.GetCustomDbRolesResultActionResult'],
             inherited_roles: Sequence['outputs.GetCustomDbRolesResultInheritedRoleResult'],
             role_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("actions", actions)
        _setter("inherited_roles", inherited_roles)
        _setter("role_name", role_name)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetCustomDbRolesResultActionResult']:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="inheritedRoles")
    def inherited_roles(self) -> Sequence['outputs.GetCustomDbRolesResultInheritedRoleResult']:
        return pulumi.get(self, "inherited_roles")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        """
        (Required) Name of the inherited role. This can either be another custom role or a built-in role.
        """
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetCustomDbRolesResultActionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 resources: Sequence['outputs.GetCustomDbRolesResultActionResourceResult']):
        """
        :param str action: (Required) Name of the privilege action. For a complete list of actions available in the Atlas API, see Custom Role Actions.
        :param Sequence['GetCustomDbRolesResultActionResourceArgs'] resources: (Required) Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
        """
        GetCustomDbRolesResultActionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            resources=resources,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: str,
             resources: Sequence['outputs.GetCustomDbRolesResultActionResourceResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action", action)
        _setter("resources", resources)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        (Required) Name of the privilege action. For a complete list of actions available in the Atlas API, see Custom Role Actions.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetCustomDbRolesResultActionResourceResult']:
        """
        (Required) Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetCustomDbRolesResultActionResourceResult(dict):
    def __init__(__self__, *,
                 cluster: bool,
                 collection_name: str,
                 database_name: str):
        """
        :param str database_name: (Required) Database on which the inherited role is granted.
        """
        GetCustomDbRolesResultActionResourceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster=cluster,
            collection_name=collection_name,
            database_name=database_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster: bool,
             collection_name: str,
             database_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cluster", cluster)
        _setter("collection_name", collection_name)
        _setter("database_name", database_name)

    @property
    @pulumi.getter
    def cluster(self) -> bool:
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> str:
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        (Required) Database on which the inherited role is granted.
        """
        return pulumi.get(self, "database_name")


@pulumi.output_type
class GetCustomDbRolesResultInheritedRoleResult(dict):
    def __init__(__self__, *,
                 database_name: str,
                 role_name: str):
        """
        :param str database_name: (Required) Database on which the inherited role is granted.
        :param str role_name: (Required) Name of the inherited role. This can either be another custom role or a built-in role.
        """
        GetCustomDbRolesResultInheritedRoleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            role_name=role_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: str,
             role_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database_name", database_name)
        _setter("role_name", role_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        (Required) Database on which the inherited role is granted.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        """
        (Required) Name of the inherited role. This can either be another custom role or a built-in role.
        """
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetDataLakeAwResult(dict):
    def __init__(__self__, *,
                 external_id: str,
                 iam_assumed_role_arn: str,
                 iam_user_arn: str,
                 role_id: str,
                 test_s3_bucket: str):
        GetDataLakeAwResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            external_id=external_id,
            iam_assumed_role_arn=iam_assumed_role_arn,
            iam_user_arn=iam_user_arn,
            role_id=role_id,
            test_s3_bucket=test_s3_bucket,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             external_id: str,
             iam_assumed_role_arn: str,
             iam_user_arn: str,
             role_id: str,
             test_s3_bucket: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("external_id", external_id)
        _setter("iam_assumed_role_arn", iam_assumed_role_arn)
        _setter("iam_user_arn", iam_user_arn)
        _setter("role_id", role_id)
        _setter("test_s3_bucket", test_s3_bucket)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> str:
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="iamAssumedRoleArn")
    def iam_assumed_role_arn(self) -> str:
        return pulumi.get(self, "iam_assumed_role_arn")

    @property
    @pulumi.getter(name="iamUserArn")
    def iam_user_arn(self) -> str:
        return pulumi.get(self, "iam_user_arn")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> str:
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="testS3Bucket")
    def test_s3_bucket(self) -> str:
        return pulumi.get(self, "test_s3_bucket")


@pulumi.output_type
class GetDataLakeDataProcessRegionResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 region: str):
        GetDataLakeDataProcessRegionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_provider=cloud_provider,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_provider: str,
             region: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cloud_provider", cloud_provider)
        _setter("region", region)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetDataLakePipelineIngestionScheduleResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param str id: Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.
        """
        GetDataLakePipelineIngestionScheduleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            frequency_interval=frequency_interval,
            frequency_type=frequency_type,
            id=id,
            retention_unit=retention_unit,
            retention_value=retention_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             frequency_interval: int,
             frequency_type: str,
             id: str,
             retention_unit: str,
             retention_value: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("frequency_interval", frequency_interval)
        _setter("frequency_type", frequency_type)
        _setter("id", id)
        _setter("retention_unit", retention_unit)
        _setter("retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetDataLakePipelineRunStatResult(dict):
    def __init__(__self__, *,
                 bytes_exported: int,
                 num_docs: int):
        """
        :param int bytes_exported: Total data size in bytes exported for this pipeline run.
        :param int num_docs: Number of docs ingested for a this pipeline run.
        """
        GetDataLakePipelineRunStatResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bytes_exported=bytes_exported,
            num_docs=num_docs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bytes_exported: int,
             num_docs: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("bytes_exported", bytes_exported)
        _setter("num_docs", num_docs)

    @property
    @pulumi.getter(name="bytesExported")
    def bytes_exported(self) -> int:
        """
        Total data size in bytes exported for this pipeline run.
        """
        return pulumi.get(self, "bytes_exported")

    @property
    @pulumi.getter(name="numDocs")
    def num_docs(self) -> int:
        """
        Number of docs ingested for a this pipeline run.
        """
        return pulumi.get(self, "num_docs")


@pulumi.output_type
class GetDataLakePipelineRunsResultResult(dict):
    def __init__(__self__, *,
                 backup_frequency_type: str,
                 created_date: str,
                 id: str,
                 last_updated_date: str,
                 phase: str,
                 pipeline_id: str,
                 pipeline_run_id: str,
                 snapshot_id: str,
                 state: str,
                 stats: Sequence['outputs.GetDataLakePipelineRunsResultStatResult']):
        """
        :param str backup_frequency_type: Backup schedule interval of the Data Lake Pipeline.
        :param str created_date: Timestamp that indicates when the pipeline run was created.
        :param str id: Unique 24-hexadecimal character string that identifies a Data Lake Pipeline run.
        :param str last_updated_date: Unique 24-hexadecimal character string that identifies a Data Lake Pipeline run.
        :param str phase: Processing phase of the Data Lake Pipeline.
        :param str pipeline_id: Unique 24-hexadecimal character string that identifies a Data Lake Pipeline.
        :param str pipeline_run_id: Unique 24-hexadecimal character string that identifies a Data Lake Pipeline run.
        :param str snapshot_id: Unique 24-hexadecimal character string that identifies the snapshot of a cluster.
        :param str state: State of the pipeline run.
        :param Sequence['GetDataLakePipelineRunsResultStatArgs'] stats: Runtime statistics for this Data Lake Pipeline run.
        """
        GetDataLakePipelineRunsResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backup_frequency_type=backup_frequency_type,
            created_date=created_date,
            id=id,
            last_updated_date=last_updated_date,
            phase=phase,
            pipeline_id=pipeline_id,
            pipeline_run_id=pipeline_run_id,
            snapshot_id=snapshot_id,
            state=state,
            stats=stats,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backup_frequency_type: str,
             created_date: str,
             id: str,
             last_updated_date: str,
             phase: str,
             pipeline_id: str,
             pipeline_run_id: str,
             snapshot_id: str,
             state: str,
             stats: Sequence['outputs.GetDataLakePipelineRunsResultStatResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("backup_frequency_type", backup_frequency_type)
        _setter("created_date", created_date)
        _setter("id", id)
        _setter("last_updated_date", last_updated_date)
        _setter("phase", phase)
        _setter("pipeline_id", pipeline_id)
        _setter("pipeline_run_id", pipeline_run_id)
        _setter("snapshot_id", snapshot_id)
        _setter("state", state)
        _setter("stats", stats)

    @property
    @pulumi.getter(name="backupFrequencyType")
    def backup_frequency_type(self) -> str:
        """
        Backup schedule interval of the Data Lake Pipeline.
        """
        return pulumi.get(self, "backup_frequency_type")

    @property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> str:
        """
        Timestamp that indicates when the pipeline run was created.
        """
        return pulumi.get(self, "created_date")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique 24-hexadecimal character string that identifies a Data Lake Pipeline run.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastUpdatedDate")
    def last_updated_date(self) -> str:
        """
        Unique 24-hexadecimal character string that identifies a Data Lake Pipeline run.
        """
        return pulumi.get(self, "last_updated_date")

    @property
    @pulumi.getter
    def phase(self) -> str:
        """
        Processing phase of the Data Lake Pipeline.
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> str:
        """
        Unique 24-hexadecimal character string that identifies a Data Lake Pipeline.
        """
        return pulumi.get(self, "pipeline_id")

    @property
    @pulumi.getter(name="pipelineRunId")
    def pipeline_run_id(self) -> str:
        """
        Unique 24-hexadecimal character string that identifies a Data Lake Pipeline run.
        """
        return pulumi.get(self, "pipeline_run_id")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> str:
        """
        Unique 24-hexadecimal character string that identifies the snapshot of a cluster.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        State of the pipeline run.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def stats(self) -> Sequence['outputs.GetDataLakePipelineRunsResultStatResult']:
        """
        Runtime statistics for this Data Lake Pipeline run.
        """
        return pulumi.get(self, "stats")


@pulumi.output_type
class GetDataLakePipelineRunsResultStatResult(dict):
    def __init__(__self__, *,
                 bytes_exported: int,
                 num_docs: int):
        """
        :param int bytes_exported: Total data size in bytes exported for this pipeline run.
        :param int num_docs: Number of docs ingested for a this pipeline run.
        """
        GetDataLakePipelineRunsResultStatResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bytes_exported=bytes_exported,
            num_docs=num_docs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bytes_exported: int,
             num_docs: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("bytes_exported", bytes_exported)
        _setter("num_docs", num_docs)

    @property
    @pulumi.getter(name="bytesExported")
    def bytes_exported(self) -> int:
        """
        Total data size in bytes exported for this pipeline run.
        """
        return pulumi.get(self, "bytes_exported")

    @property
    @pulumi.getter(name="numDocs")
    def num_docs(self) -> int:
        """
        Number of docs ingested for a this pipeline run.
        """
        return pulumi.get(self, "num_docs")


@pulumi.output_type
class GetDataLakePipelineSinkResult(dict):
    def __init__(__self__, *,
                 partition_fields: Sequence['outputs.GetDataLakePipelineSinkPartitionFieldResult'],
                 provider: str,
                 region: str,
                 type: str):
        """
        :param Sequence['GetDataLakePipelineSinkPartitionFieldArgs'] partition_fields: Ordered fields used to physically organize data in the destination.
               * `partition_fields.#.field_name` - Human-readable label that identifies the field name used to partition data.
               * `partition_fields.#.order` - Sequence in which MongoDB Atlas slices the collection data to create partitions. The resource expresses this sequence starting with zero.
        :param str provider: Target cloud provider for this Data Lake Pipeline.
        :param str region: Target cloud provider region for this Data Lake Pipeline. [Supported cloud provider regions](https://www.mongodb.com/docs/datalake/limitations).
        :param str type: Type of ingestion source of this Data Lake Pipeline.
        """
        GetDataLakePipelineSinkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            partition_fields=partition_fields,
            provider=provider,
            region=region,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             partition_fields: Sequence['outputs.GetDataLakePipelineSinkPartitionFieldResult'],
             provider: str,
             region: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("partition_fields", partition_fields)
        _setter("provider", provider)
        _setter("region", region)
        _setter("type", type)

    @property
    @pulumi.getter(name="partitionFields")
    def partition_fields(self) -> Sequence['outputs.GetDataLakePipelineSinkPartitionFieldResult']:
        """
        Ordered fields used to physically organize data in the destination.
        * `partition_fields.#.field_name` - Human-readable label that identifies the field name used to partition data.
        * `partition_fields.#.order` - Sequence in which MongoDB Atlas slices the collection data to create partitions. The resource expresses this sequence starting with zero.
        """
        return pulumi.get(self, "partition_fields")

    @property
    @pulumi.getter
    def provider(self) -> str:
        """
        Target cloud provider for this Data Lake Pipeline.
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Target cloud provider region for this Data Lake Pipeline. [Supported cloud provider regions](https://www.mongodb.com/docs/datalake/limitations).
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDataLakePipelineSinkPartitionFieldResult(dict):
    def __init__(__self__, *,
                 field_name: str,
                 order: int):
        GetDataLakePipelineSinkPartitionFieldResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_name=field_name,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_name: str,
             order: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_name", field_name)
        _setter("order", order)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def order(self) -> int:
        return pulumi.get(self, "order")


@pulumi.output_type
class GetDataLakePipelineSnapshotResult(dict):
    def __init__(__self__, *,
                 copy_region: str,
                 created_at: str,
                 expires_at: str,
                 frequency_yype: str,
                 id: str,
                 master_key: str,
                 mongod_version: str,
                 policies: Sequence[str],
                 provider: str,
                 replica_set_name: str,
                 size: int,
                 status: str,
                 type: str):
        """
        :param str id: Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.
        :param str provider: Target cloud provider for this Data Lake Pipeline.
        :param str type: Type of ingestion source of this Data Lake Pipeline.
        """
        GetDataLakePipelineSnapshotResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            copy_region=copy_region,
            created_at=created_at,
            expires_at=expires_at,
            frequency_yype=frequency_yype,
            id=id,
            master_key=master_key,
            mongod_version=mongod_version,
            policies=policies,
            provider=provider,
            replica_set_name=replica_set_name,
            size=size,
            status=status,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             copy_region: str,
             created_at: str,
             expires_at: str,
             frequency_yype: str,
             id: str,
             master_key: str,
             mongod_version: str,
             policies: Sequence[str],
             provider: str,
             replica_set_name: str,
             size: int,
             status: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("copy_region", copy_region)
        _setter("created_at", created_at)
        _setter("expires_at", expires_at)
        _setter("frequency_yype", frequency_yype)
        _setter("id", id)
        _setter("master_key", master_key)
        _setter("mongod_version", mongod_version)
        _setter("policies", policies)
        _setter("provider", provider)
        _setter("replica_set_name", replica_set_name)
        _setter("size", size)
        _setter("status", status)
        _setter("type", type)

    @property
    @pulumi.getter(name="copyRegion")
    def copy_region(self) -> str:
        return pulumi.get(self, "copy_region")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> str:
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter(name="frequencyYype")
    def frequency_yype(self) -> str:
        return pulumi.get(self, "frequency_yype")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="masterKey")
    def master_key(self) -> str:
        return pulumi.get(self, "master_key")

    @property
    @pulumi.getter(name="mongodVersion")
    def mongod_version(self) -> str:
        return pulumi.get(self, "mongod_version")

    @property
    @pulumi.getter
    def policies(self) -> Sequence[str]:
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter
    def provider(self) -> str:
        """
        Target cloud provider for this Data Lake Pipeline.
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> str:
        return pulumi.get(self, "replica_set_name")

    @property
    @pulumi.getter
    def size(self) -> int:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDataLakePipelineSourceResult(dict):
    def __init__(__self__, *,
                 cluster_name: str,
                 collection_name: str,
                 database_name: str,
                 project_id: str,
                 type: str):
        """
        :param str cluster_name: Human-readable name that identifies the cluster.
        :param str collection_name: Human-readable name that identifies the collection.
        :param str database_name: Human-readable name that identifies the database.
        :param str project_id: The unique ID for the project to create a Data Lake Pipeline.
        :param str type: Type of ingestion source of this Data Lake Pipeline.
        """
        GetDataLakePipelineSourceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster_name=cluster_name,
            collection_name=collection_name,
            database_name=database_name,
            project_id=project_id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster_name: str,
             collection_name: str,
             database_name: str,
             project_id: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cluster_name", cluster_name)
        _setter("collection_name", collection_name)
        _setter("database_name", database_name)
        _setter("project_id", project_id)
        _setter("type", type)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        Human-readable name that identifies the cluster.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> str:
        """
        Human-readable name that identifies the collection.
        """
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Human-readable name that identifies the database.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project to create a Data Lake Pipeline.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDataLakePipelineTransformationResult(dict):
    def __init__(__self__, *,
                 field: str,
                 type: str):
        """
        :param str type: Type of ingestion source of this Data Lake Pipeline.
        """
        GetDataLakePipelineTransformationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field=field,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field", field)
        _setter("type", type)

    @property
    @pulumi.getter
    def field(self) -> str:
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDataLakePipelinesResultResult(dict):
    def __init__(__self__, *,
                 created_date: str,
                 id: str,
                 last_updated_date: str,
                 name: str,
                 project_id: str,
                 sinks: Sequence['outputs.GetDataLakePipelinesResultSinkResult'],
                 sources: Sequence['outputs.GetDataLakePipelinesResultSourceResult'],
                 state: str,
                 transformations: Sequence['outputs.GetDataLakePipelinesResultTransformationResult']):
        """
        :param str created_date: Timestamp that indicates when the Data Lake Pipeline was created.
        :param str id: Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.
        :param str last_updated_date: Timestamp that indicates the last time that the Data Lake Pipeline was updated.
        :param str project_id: The unique ID for the project to create a data lake pipeline.
        :param str state: State of this Data Lake Pipeline.
        :param Sequence['GetDataLakePipelinesResultTransformationArgs'] transformations: Fields to be excluded for this Data Lake Pipeline.
               * `transformations.#.field` - Key in the document.
               * `transformations.#.type` - Type of transformation applied during the export of the namespace in a Data Lake Pipeline.
        """
        GetDataLakePipelinesResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_date=created_date,
            id=id,
            last_updated_date=last_updated_date,
            name=name,
            project_id=project_id,
            sinks=sinks,
            sources=sources,
            state=state,
            transformations=transformations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_date: str,
             id: str,
             last_updated_date: str,
             name: str,
             project_id: str,
             sinks: Sequence['outputs.GetDataLakePipelinesResultSinkResult'],
             sources: Sequence['outputs.GetDataLakePipelinesResultSourceResult'],
             state: str,
             transformations: Sequence['outputs.GetDataLakePipelinesResultTransformationResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("created_date", created_date)
        _setter("id", id)
        _setter("last_updated_date", last_updated_date)
        _setter("name", name)
        _setter("project_id", project_id)
        _setter("sinks", sinks)
        _setter("sources", sources)
        _setter("state", state)
        _setter("transformations", transformations)

    @property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> str:
        """
        Timestamp that indicates when the Data Lake Pipeline was created.
        """
        return pulumi.get(self, "created_date")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastUpdatedDate")
    def last_updated_date(self) -> str:
        """
        Timestamp that indicates the last time that the Data Lake Pipeline was updated.
        """
        return pulumi.get(self, "last_updated_date")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project to create a data lake pipeline.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def sinks(self) -> Sequence['outputs.GetDataLakePipelinesResultSinkResult']:
        return pulumi.get(self, "sinks")

    @property
    @pulumi.getter
    def sources(self) -> Sequence['outputs.GetDataLakePipelinesResultSourceResult']:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        State of this Data Lake Pipeline.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def transformations(self) -> Sequence['outputs.GetDataLakePipelinesResultTransformationResult']:
        """
        Fields to be excluded for this Data Lake Pipeline.
        * `transformations.#.field` - Key in the document.
        * `transformations.#.type` - Type of transformation applied during the export of the namespace in a Data Lake Pipeline.
        """
        return pulumi.get(self, "transformations")


@pulumi.output_type
class GetDataLakePipelinesResultSinkResult(dict):
    def __init__(__self__, *,
                 partition_fields: Sequence['outputs.GetDataLakePipelinesResultSinkPartitionFieldResult'],
                 provider: str,
                 region: str,
                 type: str):
        """
        :param Sequence['GetDataLakePipelinesResultSinkPartitionFieldArgs'] partition_fields: Ordered fields used to physically organize data in the destination.
               * `partition_fields.#.field_name` - Human-readable label that identifies the field name used to partition data.
               * `partition_fields.#.order` - Sequence in which MongoDB Atlas slices the collection data to create partitions. The resource expresses this sequence starting with zero.
        :param str provider: Target cloud provider for this Data Lake Pipeline.
        :param str region: Target cloud provider region for this Data Lake Pipeline. [Supported cloud provider regions](https://www.mongodb.com/docs/datalake/limitations).
        :param str type: Type of ingestion source of this Data Lake Pipeline.
        """
        GetDataLakePipelinesResultSinkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            partition_fields=partition_fields,
            provider=provider,
            region=region,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             partition_fields: Sequence['outputs.GetDataLakePipelinesResultSinkPartitionFieldResult'],
             provider: str,
             region: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("partition_fields", partition_fields)
        _setter("provider", provider)
        _setter("region", region)
        _setter("type", type)

    @property
    @pulumi.getter(name="partitionFields")
    def partition_fields(self) -> Sequence['outputs.GetDataLakePipelinesResultSinkPartitionFieldResult']:
        """
        Ordered fields used to physically organize data in the destination.
        * `partition_fields.#.field_name` - Human-readable label that identifies the field name used to partition data.
        * `partition_fields.#.order` - Sequence in which MongoDB Atlas slices the collection data to create partitions. The resource expresses this sequence starting with zero.
        """
        return pulumi.get(self, "partition_fields")

    @property
    @pulumi.getter
    def provider(self) -> str:
        """
        Target cloud provider for this Data Lake Pipeline.
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Target cloud provider region for this Data Lake Pipeline. [Supported cloud provider regions](https://www.mongodb.com/docs/datalake/limitations).
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDataLakePipelinesResultSinkPartitionFieldResult(dict):
    def __init__(__self__, *,
                 field_name: str,
                 order: int):
        GetDataLakePipelinesResultSinkPartitionFieldResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_name=field_name,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_name: str,
             order: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_name", field_name)
        _setter("order", order)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def order(self) -> int:
        return pulumi.get(self, "order")


@pulumi.output_type
class GetDataLakePipelinesResultSourceResult(dict):
    def __init__(__self__, *,
                 cluster_name: str,
                 collection_name: str,
                 database_name: str,
                 project_id: str,
                 type: str):
        """
        :param str cluster_name: Human-readable name that identifies the cluster.
        :param str collection_name: Human-readable name that identifies the collection.
        :param str database_name: Human-readable name that identifies the database.
        :param str project_id: The unique ID for the project to create a data lake pipeline.
        :param str type: Type of ingestion source of this Data Lake Pipeline.
        """
        GetDataLakePipelinesResultSourceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster_name=cluster_name,
            collection_name=collection_name,
            database_name=database_name,
            project_id=project_id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster_name: str,
             collection_name: str,
             database_name: str,
             project_id: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cluster_name", cluster_name)
        _setter("collection_name", collection_name)
        _setter("database_name", database_name)
        _setter("project_id", project_id)
        _setter("type", type)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        Human-readable name that identifies the cluster.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> str:
        """
        Human-readable name that identifies the collection.
        """
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Human-readable name that identifies the database.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project to create a data lake pipeline.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDataLakePipelinesResultTransformationResult(dict):
    def __init__(__self__, *,
                 field: str,
                 type: str):
        """
        :param str type: Type of ingestion source of this Data Lake Pipeline.
        """
        GetDataLakePipelinesResultTransformationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field=field,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field", field)
        _setter("type", type)

    @property
    @pulumi.getter
    def field(self) -> str:
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDataLakeStorageDatabaseResult(dict):
    def __init__(__self__, *,
                 collections: Sequence['outputs.GetDataLakeStorageDatabaseCollectionResult'],
                 max_wildcard_collections: int,
                 name: str,
                 views: Sequence['outputs.GetDataLakeStorageDatabaseViewResult']):
        """
        :param str name: Name of the data lake.
        """
        GetDataLakeStorageDatabaseResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            collections=collections,
            max_wildcard_collections=max_wildcard_collections,
            name=name,
            views=views,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             collections: Sequence['outputs.GetDataLakeStorageDatabaseCollectionResult'],
             max_wildcard_collections: int,
             name: str,
             views: Sequence['outputs.GetDataLakeStorageDatabaseViewResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("collections", collections)
        _setter("max_wildcard_collections", max_wildcard_collections)
        _setter("name", name)
        _setter("views", views)

    @property
    @pulumi.getter
    def collections(self) -> Sequence['outputs.GetDataLakeStorageDatabaseCollectionResult']:
        return pulumi.get(self, "collections")

    @property
    @pulumi.getter(name="maxWildcardCollections")
    def max_wildcard_collections(self) -> int:
        return pulumi.get(self, "max_wildcard_collections")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the data lake.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def views(self) -> Sequence['outputs.GetDataLakeStorageDatabaseViewResult']:
        return pulumi.get(self, "views")


@pulumi.output_type
class GetDataLakeStorageDatabaseCollectionResult(dict):
    def __init__(__self__, *,
                 data_sources: Sequence['outputs.GetDataLakeStorageDatabaseCollectionDataSourceResult'],
                 name: str):
        """
        :param str name: Name of the data lake.
        """
        GetDataLakeStorageDatabaseCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_sources=data_sources,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_sources: Sequence['outputs.GetDataLakeStorageDatabaseCollectionDataSourceResult'],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_sources", data_sources)
        _setter("name", name)

    @property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Sequence['outputs.GetDataLakeStorageDatabaseCollectionDataSourceResult']:
        return pulumi.get(self, "data_sources")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the data lake.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDataLakeStorageDatabaseCollectionDataSourceResult(dict):
    def __init__(__self__, *,
                 default_format: str,
                 path: str,
                 store_name: str):
        GetDataLakeStorageDatabaseCollectionDataSourceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_format=default_format,
            path=path,
            store_name=store_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_format: str,
             path: str,
             store_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("default_format", default_format)
        _setter("path", path)
        _setter("store_name", store_name)

    @property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> str:
        return pulumi.get(self, "default_format")

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="storeName")
    def store_name(self) -> str:
        return pulumi.get(self, "store_name")


@pulumi.output_type
class GetDataLakeStorageDatabaseViewResult(dict):
    def __init__(__self__, *,
                 name: str,
                 pipeline: str,
                 source: str):
        """
        :param str name: Name of the data lake.
        """
        GetDataLakeStorageDatabaseViewResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            pipeline=pipeline,
            source=source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             pipeline: str,
             source: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("pipeline", pipeline)
        _setter("source", source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the data lake.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def pipeline(self) -> str:
        return pulumi.get(self, "pipeline")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")


@pulumi.output_type
class GetDataLakeStorageStoreResult(dict):
    def __init__(__self__, *,
                 additional_storage_classes: Sequence[str],
                 bucket: str,
                 delimiter: str,
                 include_tags: bool,
                 name: str,
                 prefix: str,
                 provider: str,
                 region: str):
        """
        :param str name: Name of the data lake.
        """
        GetDataLakeStorageStoreResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            additional_storage_classes=additional_storage_classes,
            bucket=bucket,
            delimiter=delimiter,
            include_tags=include_tags,
            name=name,
            prefix=prefix,
            provider=provider,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             additional_storage_classes: Sequence[str],
             bucket: str,
             delimiter: str,
             include_tags: bool,
             name: str,
             prefix: str,
             provider: str,
             region: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("additional_storage_classes", additional_storage_classes)
        _setter("bucket", bucket)
        _setter("delimiter", delimiter)
        _setter("include_tags", include_tags)
        _setter("name", name)
        _setter("prefix", prefix)
        _setter("provider", provider)
        _setter("region", region)

    @property
    @pulumi.getter(name="additionalStorageClasses")
    def additional_storage_classes(self) -> Sequence[str]:
        return pulumi.get(self, "additional_storage_classes")

    @property
    @pulumi.getter
    def bucket(self) -> str:
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def delimiter(self) -> str:
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="includeTags")
    def include_tags(self) -> bool:
        return pulumi.get(self, "include_tags")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the data lake.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def provider(self) -> str:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetDataLakesResultResult(dict):
    def __init__(__self__, *,
                 aws: Sequence['outputs.GetDataLakesResultAwResult'],
                 data_process_regions: Sequence['outputs.GetDataLakesResultDataProcessRegionResult'],
                 hostnames: Sequence[str],
                 name: str,
                 project_id: str,
                 state: str,
                 storage_databases: Sequence['outputs.GetDataLakesResultStorageDatabaseResult'],
                 storage_stores: Sequence['outputs.GetDataLakesResultStorageStoreResult']):
        """
        :param Sequence['GetDataLakesResultDataProcessRegionArgs'] data_process_regions: The cloud provider region to which Atlas Data Lake routes client connections for data processing.
               * `data_process_region.0.cloud_provider` - Name of the cloud service provider.
               * `data_process_region.0.region` -Name of the region to which Data Lake routes client connections for data processing.
        :param Sequence[str] hostnames: The list of hostnames assigned to the Atlas Data Lake. Each string in the array is a hostname assigned to the Atlas Data Lake.
        :param str project_id: The unique ID for the project to get all data lakes.
        :param str state: Current state of the Atlas Data Lake:
        :param Sequence['GetDataLakesResultStorageDatabaseArgs'] storage_databases: Configuration details for mapping each data store to queryable databases and collections.
               * `storage_databases.#.name` - Name of the database to which Data Lake maps the data contained in the data store.
               * `storage_databases.#.collections` -     Array of objects where each object represents a collection and data sources that map to a [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#mongodb-datalakeconf-datalakeconf.stores) data store.
               * `storage_databases.#.collections.#.name` - Name of the collection.
               * `storage_databases.#.collections.#.data_sources` -     Array of objects where each object represents a stores data store to map with the collection.
               * `storage_databases.#.collections.#.data_sources.#.store_name` -     Name of a data store to map to the `<collection>`.
               * `storage_databases.#.collections.#.data_sources.#.default_format` - Default format that Data Lake assumes if it encounters a file without an extension while searching the storeName.
               * `storage_databases.#.collections.#.data_sources.#.path` - Controls how Atlas Data Lake searches for and parses files in the storeName before mapping them to the `<collection>`.
               * `storage_databases.#.views` -     Array of objects where each object represents an [aggregation pipeline](https://docs.mongodb.com/manual/core/aggregation-pipeline/#id1) on a collection.
               * `storage_databases.#.views.#.name` - Name of the view.
               * `storage_databases.#.views.#.source` -  Name of the source collection for the view.
               * `storage_databases.#.views.#.pipeline`- Aggregation pipeline stage(s) to apply to the source collection.
        :param Sequence['GetDataLakesResultStorageStoreArgs'] storage_stores: Each object in the array represents a data store. Data Lake uses the storage.databases configuration details to map data in each data store to queryable databases and collections.
               * `storage_stores.#.name` - Name of the data store.
               * `storage_stores.#.provider` - Defines where the data is stored.
               * `storage_stores.#.region` - Name of the AWS region in which the S3 bucket is hosted.
               * `storage_stores.#.bucket` - Name of the AWS S3 bucket.
               * `storage_stores.#.prefix` - Prefix Data Lake applies when searching for files in the S3 bucket .
               * `storage_stores.#.delimiter` - The delimiter that separates `storage_databases.#.collections.#.data_sources.#.path` segments in the data store.
               * `storage_stores.#.include_tags` - Determines whether or not to use S3 tags on the files in the given path as additional partition attributes.
        """
        GetDataLakesResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aws=aws,
            data_process_regions=data_process_regions,
            hostnames=hostnames,
            name=name,
            project_id=project_id,
            state=state,
            storage_databases=storage_databases,
            storage_stores=storage_stores,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aws: Sequence['outputs.GetDataLakesResultAwResult'],
             data_process_regions: Sequence['outputs.GetDataLakesResultDataProcessRegionResult'],
             hostnames: Sequence[str],
             name: str,
             project_id: str,
             state: str,
             storage_databases: Sequence['outputs.GetDataLakesResultStorageDatabaseResult'],
             storage_stores: Sequence['outputs.GetDataLakesResultStorageStoreResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aws", aws)
        _setter("data_process_regions", data_process_regions)
        _setter("hostnames", hostnames)
        _setter("name", name)
        _setter("project_id", project_id)
        _setter("state", state)
        _setter("storage_databases", storage_databases)
        _setter("storage_stores", storage_stores)

    @property
    @pulumi.getter
    def aws(self) -> Sequence['outputs.GetDataLakesResultAwResult']:
        return pulumi.get(self, "aws")

    @property
    @pulumi.getter(name="dataProcessRegions")
    def data_process_regions(self) -> Sequence['outputs.GetDataLakesResultDataProcessRegionResult']:
        """
        The cloud provider region to which Atlas Data Lake routes client connections for data processing.
        * `data_process_region.0.cloud_provider` - Name of the cloud service provider.
        * `data_process_region.0.region` -Name of the region to which Data Lake routes client connections for data processing.
        """
        return pulumi.get(self, "data_process_regions")

    @property
    @pulumi.getter
    def hostnames(self) -> Sequence[str]:
        """
        The list of hostnames assigned to the Atlas Data Lake. Each string in the array is a hostname assigned to the Atlas Data Lake.
        """
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project to get all data lakes.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Current state of the Atlas Data Lake:
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="storageDatabases")
    def storage_databases(self) -> Sequence['outputs.GetDataLakesResultStorageDatabaseResult']:
        """
        Configuration details for mapping each data store to queryable databases and collections.
        * `storage_databases.#.name` - Name of the database to which Data Lake maps the data contained in the data store.
        * `storage_databases.#.collections` -     Array of objects where each object represents a collection and data sources that map to a [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#mongodb-datalakeconf-datalakeconf.stores) data store.
        * `storage_databases.#.collections.#.name` - Name of the collection.
        * `storage_databases.#.collections.#.data_sources` -     Array of objects where each object represents a stores data store to map with the collection.
        * `storage_databases.#.collections.#.data_sources.#.store_name` -     Name of a data store to map to the `<collection>`.
        * `storage_databases.#.collections.#.data_sources.#.default_format` - Default format that Data Lake assumes if it encounters a file without an extension while searching the storeName.
        * `storage_databases.#.collections.#.data_sources.#.path` - Controls how Atlas Data Lake searches for and parses files in the storeName before mapping them to the `<collection>`.
        * `storage_databases.#.views` -     Array of objects where each object represents an [aggregation pipeline](https://docs.mongodb.com/manual/core/aggregation-pipeline/#id1) on a collection.
        * `storage_databases.#.views.#.name` - Name of the view.
        * `storage_databases.#.views.#.source` -  Name of the source collection for the view.
        * `storage_databases.#.views.#.pipeline`- Aggregation pipeline stage(s) to apply to the source collection.
        """
        return pulumi.get(self, "storage_databases")

    @property
    @pulumi.getter(name="storageStores")
    def storage_stores(self) -> Sequence['outputs.GetDataLakesResultStorageStoreResult']:
        """
        Each object in the array represents a data store. Data Lake uses the storage.databases configuration details to map data in each data store to queryable databases and collections.
        * `storage_stores.#.name` - Name of the data store.
        * `storage_stores.#.provider` - Defines where the data is stored.
        * `storage_stores.#.region` - Name of the AWS region in which the S3 bucket is hosted.
        * `storage_stores.#.bucket` - Name of the AWS S3 bucket.
        * `storage_stores.#.prefix` - Prefix Data Lake applies when searching for files in the S3 bucket .
        * `storage_stores.#.delimiter` - The delimiter that separates `storage_databases.#.collections.#.data_sources.#.path` segments in the data store.
        * `storage_stores.#.include_tags` - Determines whether or not to use S3 tags on the files in the given path as additional partition attributes.
        """
        return pulumi.get(self, "storage_stores")


@pulumi.output_type
class GetDataLakesResultAwResult(dict):
    def __init__(__self__, *,
                 external_id: str,
                 iam_assumed_role_arn: str,
                 iam_user_arn: str,
                 role_id: str,
                 test_s3_bucket: str):
        GetDataLakesResultAwResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            external_id=external_id,
            iam_assumed_role_arn=iam_assumed_role_arn,
            iam_user_arn=iam_user_arn,
            role_id=role_id,
            test_s3_bucket=test_s3_bucket,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             external_id: str,
             iam_assumed_role_arn: str,
             iam_user_arn: str,
             role_id: str,
             test_s3_bucket: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("external_id", external_id)
        _setter("iam_assumed_role_arn", iam_assumed_role_arn)
        _setter("iam_user_arn", iam_user_arn)
        _setter("role_id", role_id)
        _setter("test_s3_bucket", test_s3_bucket)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> str:
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="iamAssumedRoleArn")
    def iam_assumed_role_arn(self) -> str:
        return pulumi.get(self, "iam_assumed_role_arn")

    @property
    @pulumi.getter(name="iamUserArn")
    def iam_user_arn(self) -> str:
        return pulumi.get(self, "iam_user_arn")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> str:
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="testS3Bucket")
    def test_s3_bucket(self) -> str:
        return pulumi.get(self, "test_s3_bucket")


@pulumi.output_type
class GetDataLakesResultDataProcessRegionResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 region: str):
        GetDataLakesResultDataProcessRegionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_provider=cloud_provider,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_provider: str,
             region: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cloud_provider", cloud_provider)
        _setter("region", region)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetDataLakesResultStorageDatabaseResult(dict):
    def __init__(__self__, *,
                 collections: Sequence['outputs.GetDataLakesResultStorageDatabaseCollectionResult'],
                 max_wildcard_collections: int,
                 name: str,
                 views: Sequence['outputs.GetDataLakesResultStorageDatabaseViewResult']):
        GetDataLakesResultStorageDatabaseResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            collections=collections,
            max_wildcard_collections=max_wildcard_collections,
            name=name,
            views=views,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             collections: Sequence['outputs.GetDataLakesResultStorageDatabaseCollectionResult'],
             max_wildcard_collections: int,
             name: str,
             views: Sequence['outputs.GetDataLakesResultStorageDatabaseViewResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("collections", collections)
        _setter("max_wildcard_collections", max_wildcard_collections)
        _setter("name", name)
        _setter("views", views)

    @property
    @pulumi.getter
    def collections(self) -> Sequence['outputs.GetDataLakesResultStorageDatabaseCollectionResult']:
        return pulumi.get(self, "collections")

    @property
    @pulumi.getter(name="maxWildcardCollections")
    def max_wildcard_collections(self) -> int:
        return pulumi.get(self, "max_wildcard_collections")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def views(self) -> Sequence['outputs.GetDataLakesResultStorageDatabaseViewResult']:
        return pulumi.get(self, "views")


@pulumi.output_type
class GetDataLakesResultStorageDatabaseCollectionResult(dict):
    def __init__(__self__, *,
                 data_sources: Sequence['outputs.GetDataLakesResultStorageDatabaseCollectionDataSourceResult'],
                 name: str):
        GetDataLakesResultStorageDatabaseCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_sources=data_sources,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_sources: Sequence['outputs.GetDataLakesResultStorageDatabaseCollectionDataSourceResult'],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_sources", data_sources)
        _setter("name", name)

    @property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Sequence['outputs.GetDataLakesResultStorageDatabaseCollectionDataSourceResult']:
        return pulumi.get(self, "data_sources")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDataLakesResultStorageDatabaseCollectionDataSourceResult(dict):
    def __init__(__self__, *,
                 default_format: str,
                 path: str,
                 store_name: str):
        GetDataLakesResultStorageDatabaseCollectionDataSourceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_format=default_format,
            path=path,
            store_name=store_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_format: str,
             path: str,
             store_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("default_format", default_format)
        _setter("path", path)
        _setter("store_name", store_name)

    @property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> str:
        return pulumi.get(self, "default_format")

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="storeName")
    def store_name(self) -> str:
        return pulumi.get(self, "store_name")


@pulumi.output_type
class GetDataLakesResultStorageDatabaseViewResult(dict):
    def __init__(__self__, *,
                 name: str,
                 pipeline: str,
                 source: str):
        GetDataLakesResultStorageDatabaseViewResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            pipeline=pipeline,
            source=source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             pipeline: str,
             source: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("pipeline", pipeline)
        _setter("source", source)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def pipeline(self) -> str:
        return pulumi.get(self, "pipeline")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")


@pulumi.output_type
class GetDataLakesResultStorageStoreResult(dict):
    def __init__(__self__, *,
                 additional_storage_classes: Sequence[str],
                 bucket: str,
                 delimiter: str,
                 include_tags: bool,
                 name: str,
                 prefix: str,
                 provider: str,
                 region: str):
        GetDataLakesResultStorageStoreResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            additional_storage_classes=additional_storage_classes,
            bucket=bucket,
            delimiter=delimiter,
            include_tags=include_tags,
            name=name,
            prefix=prefix,
            provider=provider,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             additional_storage_classes: Sequence[str],
             bucket: str,
             delimiter: str,
             include_tags: bool,
             name: str,
             prefix: str,
             provider: str,
             region: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("additional_storage_classes", additional_storage_classes)
        _setter("bucket", bucket)
        _setter("delimiter", delimiter)
        _setter("include_tags", include_tags)
        _setter("name", name)
        _setter("prefix", prefix)
        _setter("provider", provider)
        _setter("region", region)

    @property
    @pulumi.getter(name="additionalStorageClasses")
    def additional_storage_classes(self) -> Sequence[str]:
        return pulumi.get(self, "additional_storage_classes")

    @property
    @pulumi.getter
    def bucket(self) -> str:
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def delimiter(self) -> str:
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="includeTags")
    def include_tags(self) -> bool:
        return pulumi.get(self, "include_tags")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def provider(self) -> str:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetDatabaseUserLabelResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        GetDatabaseUserLabelResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDatabaseUserRoleResult(dict):
    def __init__(__self__, *,
                 collection_name: str,
                 database_name: str,
                 role_name: str):
        """
        :param str collection_name: Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        :param str database_name: Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.
        """
        GetDatabaseUserRoleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            collection_name=collection_name,
            database_name=database_name,
            role_name=role_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             collection_name: str,
             database_name: str,
             role_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("collection_name", collection_name)
        _setter("database_name", database_name)
        _setter("role_name", role_name)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> str:
        """
        Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        """
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetDatabaseUserScopeResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str):
        """
        :param str name: Name of the role to grant.
        :param str type: Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
        GetDatabaseUserScopeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the role to grant.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDatabaseUsersResultResult(dict):
    def __init__(__self__, *,
                 auth_database_name: str,
                 aws_iam_type: str,
                 id: str,
                 labels: Sequence['outputs.GetDatabaseUsersResultLabelResult'],
                 ldap_auth_type: str,
                 oidc_auth_type: str,
                 password: str,
                 project_id: str,
                 roles: Sequence['outputs.GetDatabaseUsersResultRoleResult'],
                 scopes: Sequence['outputs.GetDatabaseUsersResultScopeResult'],
                 username: str,
                 x509_type: str):
        """
        :param str auth_database_name: (Required) Database against which Atlas authenticates the user. A user must provide both a username and authentication database to log into MongoDB.
               Possible values include:
        :param str aws_iam_type: The new database user authenticates with AWS IAM credentials. Default is `NONE`, `USER` means user has AWS IAM user credentials, `ROLE` - means user has credentials associated with an AWS IAM role.
        :param str id: Autogenerated Unique ID for this data source.
        :param str ldap_auth_type: Method by which the provided username is authenticated. Default is `NONE`. Other valid values are: `USER`, `GROUP`.
        :param str oidc_auth_type: (Optional) Human-readable label that indicates whether the new database user authenticates with OIDC (OpenID Connect) federated authentication. If no value is given, Atlas uses the default value of `NONE`. The accepted types are:
        :param str project_id: The unique ID for the project to get all database users.
        :param Sequence['GetDatabaseUsersResultRoleArgs'] roles: List of user’s roles and the databases / collections on which the roles apply. A role allows the user to perform particular actions on the specified database. A role on the admin database can include privileges that apply to the other databases as well. See Roles below for more details.
        :param Sequence['GetDatabaseUsersResultScopeArgs'] scopes: Array of clusters and Atlas Data Lakes that this user has access to.
        :param str username: Username for authenticating to MongoDB.
        :param str x509_type: X.509 method by which the provided username is authenticated.
        """
        GetDatabaseUsersResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auth_database_name=auth_database_name,
            aws_iam_type=aws_iam_type,
            id=id,
            labels=labels,
            ldap_auth_type=ldap_auth_type,
            oidc_auth_type=oidc_auth_type,
            password=password,
            project_id=project_id,
            roles=roles,
            scopes=scopes,
            username=username,
            x509_type=x509_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auth_database_name: str,
             aws_iam_type: str,
             id: str,
             labels: Sequence['outputs.GetDatabaseUsersResultLabelResult'],
             ldap_auth_type: str,
             oidc_auth_type: str,
             password: str,
             project_id: str,
             roles: Sequence['outputs.GetDatabaseUsersResultRoleResult'],
             scopes: Sequence['outputs.GetDatabaseUsersResultScopeResult'],
             username: str,
             x509_type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("auth_database_name", auth_database_name)
        _setter("aws_iam_type", aws_iam_type)
        _setter("id", id)
        _setter("labels", labels)
        _setter("ldap_auth_type", ldap_auth_type)
        _setter("oidc_auth_type", oidc_auth_type)
        _setter("password", password)
        _setter("project_id", project_id)
        _setter("roles", roles)
        _setter("scopes", scopes)
        _setter("username", username)
        _setter("x509_type", x509_type)

    @property
    @pulumi.getter(name="authDatabaseName")
    def auth_database_name(self) -> str:
        """
        (Required) Database against which Atlas authenticates the user. A user must provide both a username and authentication database to log into MongoDB.
        Possible values include:
        """
        return pulumi.get(self, "auth_database_name")

    @property
    @pulumi.getter(name="awsIamType")
    def aws_iam_type(self) -> str:
        """
        The new database user authenticates with AWS IAM credentials. Default is `NONE`, `USER` means user has AWS IAM user credentials, `ROLE` - means user has credentials associated with an AWS IAM role.
        """
        return pulumi.get(self, "aws_iam_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Autogenerated Unique ID for this data source.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetDatabaseUsersResultLabelResult']:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="ldapAuthType")
    def ldap_auth_type(self) -> str:
        """
        Method by which the provided username is authenticated. Default is `NONE`. Other valid values are: `USER`, `GROUP`.
        """
        return pulumi.get(self, "ldap_auth_type")

    @property
    @pulumi.getter(name="oidcAuthType")
    def oidc_auth_type(self) -> str:
        """
        (Optional) Human-readable label that indicates whether the new database user authenticates with OIDC (OpenID Connect) federated authentication. If no value is given, Atlas uses the default value of `NONE`. The accepted types are:
        """
        return pulumi.get(self, "oidc_auth_type")

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project to get all database users.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def roles(self) -> Sequence['outputs.GetDatabaseUsersResultRoleResult']:
        """
        List of user’s roles and the databases / collections on which the roles apply. A role allows the user to perform particular actions on the specified database. A role on the admin database can include privileges that apply to the other databases as well. See Roles below for more details.
        """
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence['outputs.GetDatabaseUsersResultScopeResult']:
        """
        Array of clusters and Atlas Data Lakes that this user has access to.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username for authenticating to MongoDB.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="x509Type")
    def x509_type(self) -> str:
        """
        X.509 method by which the provided username is authenticated.
        """
        return pulumi.get(self, "x509_type")


@pulumi.output_type
class GetDatabaseUsersResultLabelResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        GetDatabaseUsersResultLabelResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDatabaseUsersResultRoleResult(dict):
    def __init__(__self__, *,
                 collection_name: str,
                 database_name: str,
                 role_name: str):
        """
        :param str collection_name: Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        :param str database_name: Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.
        """
        GetDatabaseUsersResultRoleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            collection_name=collection_name,
            database_name=database_name,
            role_name=role_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             collection_name: str,
             database_name: str,
             role_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("collection_name", collection_name)
        _setter("database_name", database_name)
        _setter("role_name", role_name)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> str:
        """
        Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        """
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetDatabaseUsersResultScopeResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str):
        """
        :param str name: Name of the role to grant.
        :param str type: Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
        GetDatabaseUsersResultScopeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the role to grant.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetEventTriggerEventProcessorResult(dict):
    def __init__(__self__, *,
                 aws_eventbridges: Sequence['outputs.GetEventTriggerEventProcessorAwsEventbridgeResult']):
        GetEventTriggerEventProcessorResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aws_eventbridges=aws_eventbridges,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aws_eventbridges: Sequence['outputs.GetEventTriggerEventProcessorAwsEventbridgeResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aws_eventbridges", aws_eventbridges)

    @property
    @pulumi.getter(name="awsEventbridges")
    def aws_eventbridges(self) -> Sequence['outputs.GetEventTriggerEventProcessorAwsEventbridgeResult']:
        return pulumi.get(self, "aws_eventbridges")


@pulumi.output_type
class GetEventTriggerEventProcessorAwsEventbridgeResult(dict):
    def __init__(__self__, *,
                 config_account_id: str,
                 config_region: str):
        GetEventTriggerEventProcessorAwsEventbridgeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_account_id=config_account_id,
            config_region=config_region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_account_id: str,
             config_region: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("config_account_id", config_account_id)
        _setter("config_region", config_region)

    @property
    @pulumi.getter(name="configAccountId")
    def config_account_id(self) -> str:
        return pulumi.get(self, "config_account_id")

    @property
    @pulumi.getter(name="configRegion")
    def config_region(self) -> str:
        return pulumi.get(self, "config_region")


@pulumi.output_type
class GetEventTriggersResultResult(dict):
    def __init__(__self__, *,
                 config_collection: str,
                 config_database: str,
                 config_full_document: bool,
                 config_full_document_before: bool,
                 config_match: str,
                 config_operation_type: str,
                 config_operation_types: Sequence[str],
                 config_project: str,
                 config_providers: Sequence[str],
                 config_schedule: str,
                 config_schedule_type: str,
                 config_service_id: str,
                 disabled: bool,
                 event_processors: Sequence['outputs.GetEventTriggersResultEventProcessorResult'],
                 function_id: str,
                 function_name: str,
                 name: str,
                 trigger_id: str,
                 type: str,
                 unordered: bool):
        """
        :param str config_collection: The name of the MongoDB collection that the trigger watches for change events.
        :param str config_database: The name of the MongoDB database that contains the watched collection.
        :param bool config_full_document: If true, indicates that `UPDATE` change events should include the most current [majority-committed](https://docs.mongodb.com/manual/reference/read-concern-majority/) version of the modified document in the fullDocument field.
        :param str config_match: A [$match](https://docs.mongodb.com/manual/reference/operator/aggregation/match/) expression document that MongoDB Realm includes in the underlying change stream pipeline for the trigger.
        :param str config_operation_type: The [authentication operation type](https://docs.mongodb.com/realm/triggers/authentication-triggers/#std-label-authentication-event-operation-types) to listen for.
        :param Sequence[str] config_operation_types: The [database event operation types](https://docs.mongodb.com/realm/triggers/database-triggers/#std-label-database-events) to listen for.
        :param str config_project: A [$project](https://docs.mongodb.com/manual/reference/operator/aggregation/project/) expression document that Realm uses to filter the fields that appear in change event objects.
        :param Sequence[str] config_providers: A list of one or more [authentication provider](https://docs.mongodb.com/realm/authentication/providers/) id values. The trigger will only listen for authentication events produced by these providers.
        :param str config_schedule: A [cron expression](https://docs.mongodb.com/realm/triggers/cron-expressions/) that defines the trigger schedule.
        :param str config_service_id: The ID of the MongoDB Service associated with the trigger.
        :param bool disabled: Status of a trigger.
        :param Sequence['GetEventTriggersResultEventProcessorArgs'] event_processors: An object where each field name is an event processor ID and each value is an object that configures its corresponding event processor.
               * `event_processors.0.aws_eventbridge.config_account_id` - AWS Account ID.
               * `event_processors.0.aws_eventbridge.config_region` - Region of AWS Account.
        :param str function_id: The ID of the function associated with the trigger.
        :param str function_name: The name of the function associated with the trigger.
        :param str name: The name of the trigger.
        :param str type: The type of the trigger. Possible Values: `DATABASE`, `AUTHENTICATION`
        :param bool unordered: Sort order for `DATABASE` type.
        """
        GetEventTriggersResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_collection=config_collection,
            config_database=config_database,
            config_full_document=config_full_document,
            config_full_document_before=config_full_document_before,
            config_match=config_match,
            config_operation_type=config_operation_type,
            config_operation_types=config_operation_types,
            config_project=config_project,
            config_providers=config_providers,
            config_schedule=config_schedule,
            config_schedule_type=config_schedule_type,
            config_service_id=config_service_id,
            disabled=disabled,
            event_processors=event_processors,
            function_id=function_id,
            function_name=function_name,
            name=name,
            trigger_id=trigger_id,
            type=type,
            unordered=unordered,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_collection: str,
             config_database: str,
             config_full_document: bool,
             config_full_document_before: bool,
             config_match: str,
             config_operation_type: str,
             config_operation_types: Sequence[str],
             config_project: str,
             config_providers: Sequence[str],
             config_schedule: str,
             config_schedule_type: str,
             config_service_id: str,
             disabled: bool,
             event_processors: Sequence['outputs.GetEventTriggersResultEventProcessorResult'],
             function_id: str,
             function_name: str,
             name: str,
             trigger_id: str,
             type: str,
             unordered: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("config_collection", config_collection)
        _setter("config_database", config_database)
        _setter("config_full_document", config_full_document)
        _setter("config_full_document_before", config_full_document_before)
        _setter("config_match", config_match)
        _setter("config_operation_type", config_operation_type)
        _setter("config_operation_types", config_operation_types)
        _setter("config_project", config_project)
        _setter("config_providers", config_providers)
        _setter("config_schedule", config_schedule)
        _setter("config_schedule_type", config_schedule_type)
        _setter("config_service_id", config_service_id)
        _setter("disabled", disabled)
        _setter("event_processors", event_processors)
        _setter("function_id", function_id)
        _setter("function_name", function_name)
        _setter("name", name)
        _setter("trigger_id", trigger_id)
        _setter("type", type)
        _setter("unordered", unordered)

    @property
    @pulumi.getter(name="configCollection")
    def config_collection(self) -> str:
        """
        The name of the MongoDB collection that the trigger watches for change events.
        """
        return pulumi.get(self, "config_collection")

    @property
    @pulumi.getter(name="configDatabase")
    def config_database(self) -> str:
        """
        The name of the MongoDB database that contains the watched collection.
        """
        return pulumi.get(self, "config_database")

    @property
    @pulumi.getter(name="configFullDocument")
    def config_full_document(self) -> bool:
        """
        If true, indicates that `UPDATE` change events should include the most current [majority-committed](https://docs.mongodb.com/manual/reference/read-concern-majority/) version of the modified document in the fullDocument field.
        """
        return pulumi.get(self, "config_full_document")

    @property
    @pulumi.getter(name="configFullDocumentBefore")
    def config_full_document_before(self) -> bool:
        return pulumi.get(self, "config_full_document_before")

    @property
    @pulumi.getter(name="configMatch")
    def config_match(self) -> str:
        """
        A [$match](https://docs.mongodb.com/manual/reference/operator/aggregation/match/) expression document that MongoDB Realm includes in the underlying change stream pipeline for the trigger.
        """
        return pulumi.get(self, "config_match")

    @property
    @pulumi.getter(name="configOperationType")
    def config_operation_type(self) -> str:
        """
        The [authentication operation type](https://docs.mongodb.com/realm/triggers/authentication-triggers/#std-label-authentication-event-operation-types) to listen for.
        """
        return pulumi.get(self, "config_operation_type")

    @property
    @pulumi.getter(name="configOperationTypes")
    def config_operation_types(self) -> Sequence[str]:
        """
        The [database event operation types](https://docs.mongodb.com/realm/triggers/database-triggers/#std-label-database-events) to listen for.
        """
        return pulumi.get(self, "config_operation_types")

    @property
    @pulumi.getter(name="configProject")
    def config_project(self) -> str:
        """
        A [$project](https://docs.mongodb.com/manual/reference/operator/aggregation/project/) expression document that Realm uses to filter the fields that appear in change event objects.
        """
        return pulumi.get(self, "config_project")

    @property
    @pulumi.getter(name="configProviders")
    def config_providers(self) -> Sequence[str]:
        """
        A list of one or more [authentication provider](https://docs.mongodb.com/realm/authentication/providers/) id values. The trigger will only listen for authentication events produced by these providers.
        """
        return pulumi.get(self, "config_providers")

    @property
    @pulumi.getter(name="configSchedule")
    def config_schedule(self) -> str:
        """
        A [cron expression](https://docs.mongodb.com/realm/triggers/cron-expressions/) that defines the trigger schedule.
        """
        return pulumi.get(self, "config_schedule")

    @property
    @pulumi.getter(name="configScheduleType")
    def config_schedule_type(self) -> str:
        return pulumi.get(self, "config_schedule_type")

    @property
    @pulumi.getter(name="configServiceId")
    def config_service_id(self) -> str:
        """
        The ID of the MongoDB Service associated with the trigger.
        """
        return pulumi.get(self, "config_service_id")

    @property
    @pulumi.getter
    def disabled(self) -> bool:
        """
        Status of a trigger.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="eventProcessors")
    def event_processors(self) -> Sequence['outputs.GetEventTriggersResultEventProcessorResult']:
        """
        An object where each field name is an event processor ID and each value is an object that configures its corresponding event processor.
        * `event_processors.0.aws_eventbridge.config_account_id` - AWS Account ID.
        * `event_processors.0.aws_eventbridge.config_region` - Region of AWS Account.
        """
        return pulumi.get(self, "event_processors")

    @property
    @pulumi.getter(name="functionId")
    def function_id(self) -> str:
        """
        The ID of the function associated with the trigger.
        """
        return pulumi.get(self, "function_id")

    @property
    @pulumi.getter(name="functionName")
    def function_name(self) -> str:
        """
        The name of the function associated with the trigger.
        """
        return pulumi.get(self, "function_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the trigger.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="triggerId")
    def trigger_id(self) -> str:
        return pulumi.get(self, "trigger_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the trigger. Possible Values: `DATABASE`, `AUTHENTICATION`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unordered(self) -> bool:
        """
        Sort order for `DATABASE` type.
        """
        return pulumi.get(self, "unordered")


@pulumi.output_type
class GetEventTriggersResultEventProcessorResult(dict):
    def __init__(__self__, *,
                 aws_eventbridges: Sequence['outputs.GetEventTriggersResultEventProcessorAwsEventbridgeResult']):
        GetEventTriggersResultEventProcessorResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aws_eventbridges=aws_eventbridges,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aws_eventbridges: Sequence['outputs.GetEventTriggersResultEventProcessorAwsEventbridgeResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aws_eventbridges", aws_eventbridges)

    @property
    @pulumi.getter(name="awsEventbridges")
    def aws_eventbridges(self) -> Sequence['outputs.GetEventTriggersResultEventProcessorAwsEventbridgeResult']:
        return pulumi.get(self, "aws_eventbridges")


@pulumi.output_type
class GetEventTriggersResultEventProcessorAwsEventbridgeResult(dict):
    def __init__(__self__, *,
                 config_account_id: str,
                 config_region: str):
        GetEventTriggersResultEventProcessorAwsEventbridgeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config_account_id=config_account_id,
            config_region=config_region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config_account_id: str,
             config_region: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("config_account_id", config_account_id)
        _setter("config_region", config_region)

    @property
    @pulumi.getter(name="configAccountId")
    def config_account_id(self) -> str:
        return pulumi.get(self, "config_account_id")

    @property
    @pulumi.getter(name="configRegion")
    def config_region(self) -> str:
        return pulumi.get(self, "config_region")


@pulumi.output_type
class GetFederatedDatabaseInstanceCloudProviderConfigResult(dict):
    def __init__(__self__, *,
                 aws: 'outputs.GetFederatedDatabaseInstanceCloudProviderConfigAwsResult'):
        GetFederatedDatabaseInstanceCloudProviderConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aws=aws,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aws: 'outputs.GetFederatedDatabaseInstanceCloudProviderConfigAwsResult',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aws", aws)

    @property
    @pulumi.getter
    def aws(self) -> 'outputs.GetFederatedDatabaseInstanceCloudProviderConfigAwsResult':
        return pulumi.get(self, "aws")


@pulumi.output_type
class GetFederatedDatabaseInstanceCloudProviderConfigAwsResult(dict):
    def __init__(__self__, *,
                 external_id: str,
                 iam_assumed_role_arn: str,
                 iam_user_arn: str,
                 role_id: str,
                 test_s3_bucket: str):
        """
        :param str external_id: Unique identifier associated with the IAM Role that the Federated Database Instance assumes when accessing the data stores.
        :param str iam_assumed_role_arn: Amazon Resource Name (ARN) of the IAM Role that the Federated Database Instance assumes when accessing S3 Bucket data stores. The IAM Role must support the following actions against each S3 bucket:
               * `s3:GetObject`
               * `s3:ListBucket`
               * `s3:GetObjectVersion`
        :param str iam_user_arn: Amazon Resource Name (ARN) of the user that the Federated Database Instance assumes when accessing S3 Bucket data stores.
        :param str role_id: Unique identifier of the role that the data lake can use to access the data stores.
        """
        GetFederatedDatabaseInstanceCloudProviderConfigAwsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            external_id=external_id,
            iam_assumed_role_arn=iam_assumed_role_arn,
            iam_user_arn=iam_user_arn,
            role_id=role_id,
            test_s3_bucket=test_s3_bucket,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             external_id: str,
             iam_assumed_role_arn: str,
             iam_user_arn: str,
             role_id: str,
             test_s3_bucket: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("external_id", external_id)
        _setter("iam_assumed_role_arn", iam_assumed_role_arn)
        _setter("iam_user_arn", iam_user_arn)
        _setter("role_id", role_id)
        _setter("test_s3_bucket", test_s3_bucket)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> str:
        """
        Unique identifier associated with the IAM Role that the Federated Database Instance assumes when accessing the data stores.
        """
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="iamAssumedRoleArn")
    def iam_assumed_role_arn(self) -> str:
        """
        Amazon Resource Name (ARN) of the IAM Role that the Federated Database Instance assumes when accessing S3 Bucket data stores. The IAM Role must support the following actions against each S3 bucket:
        * `s3:GetObject`
        * `s3:ListBucket`
        * `s3:GetObjectVersion`
        """
        return pulumi.get(self, "iam_assumed_role_arn")

    @property
    @pulumi.getter(name="iamUserArn")
    def iam_user_arn(self) -> str:
        """
        Amazon Resource Name (ARN) of the user that the Federated Database Instance assumes when accessing S3 Bucket data stores.
        """
        return pulumi.get(self, "iam_user_arn")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> str:
        """
        Unique identifier of the role that the data lake can use to access the data stores.
        """
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="testS3Bucket")
    def test_s3_bucket(self) -> str:
        return pulumi.get(self, "test_s3_bucket")


@pulumi.output_type
class GetFederatedDatabaseInstanceDataProcessRegionResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 region: str):
        """
        :param str cloud_provider: Name of the cloud service provider. Atlas Federated Database only supports AWS.
        :param str region: Name of the region to which the Federanted Instnace routes client connections for data processing.
        """
        GetFederatedDatabaseInstanceDataProcessRegionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_provider=cloud_provider,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_provider: str,
             region: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cloud_provider", cloud_provider)
        _setter("region", region)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        Name of the cloud service provider. Atlas Federated Database only supports AWS.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Name of the region to which the Federanted Instnace routes client connections for data processing.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetFederatedDatabaseInstanceStorageDatabaseResult(dict):
    def __init__(__self__, *,
                 collections: Sequence['outputs.GetFederatedDatabaseInstanceStorageDatabaseCollectionResult'],
                 max_wildcard_collections: int,
                 name: str,
                 views: Sequence['outputs.GetFederatedDatabaseInstanceStorageDatabaseViewResult']):
        """
        :param str name: Name of the Atlas Federated Database Instance.
        """
        GetFederatedDatabaseInstanceStorageDatabaseResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            collections=collections,
            max_wildcard_collections=max_wildcard_collections,
            name=name,
            views=views,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             collections: Sequence['outputs.GetFederatedDatabaseInstanceStorageDatabaseCollectionResult'],
             max_wildcard_collections: int,
             name: str,
             views: Sequence['outputs.GetFederatedDatabaseInstanceStorageDatabaseViewResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("collections", collections)
        _setter("max_wildcard_collections", max_wildcard_collections)
        _setter("name", name)
        _setter("views", views)

    @property
    @pulumi.getter
    def collections(self) -> Sequence['outputs.GetFederatedDatabaseInstanceStorageDatabaseCollectionResult']:
        return pulumi.get(self, "collections")

    @property
    @pulumi.getter(name="maxWildcardCollections")
    def max_wildcard_collections(self) -> int:
        return pulumi.get(self, "max_wildcard_collections")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def views(self) -> Sequence['outputs.GetFederatedDatabaseInstanceStorageDatabaseViewResult']:
        return pulumi.get(self, "views")


@pulumi.output_type
class GetFederatedDatabaseInstanceStorageDatabaseCollectionResult(dict):
    def __init__(__self__, *,
                 data_sources: Sequence['outputs.GetFederatedDatabaseInstanceStorageDatabaseCollectionDataSourceResult'],
                 name: str):
        """
        :param str name: Name of the Atlas Federated Database Instance.
        """
        GetFederatedDatabaseInstanceStorageDatabaseCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_sources=data_sources,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_sources: Sequence['outputs.GetFederatedDatabaseInstanceStorageDatabaseCollectionDataSourceResult'],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_sources", data_sources)
        _setter("name", name)

    @property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Sequence['outputs.GetFederatedDatabaseInstanceStorageDatabaseCollectionDataSourceResult']:
        return pulumi.get(self, "data_sources")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetFederatedDatabaseInstanceStorageDatabaseCollectionDataSourceResult(dict):
    def __init__(__self__, *,
                 allow_insecure: bool,
                 collection: str,
                 collection_regex: str,
                 database: str,
                 database_regex: str,
                 dataset_name: str,
                 default_format: str,
                 path: str,
                 provenance_field_name: str,
                 store_name: str,
                 urls: Sequence[str]):
        GetFederatedDatabaseInstanceStorageDatabaseCollectionDataSourceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_insecure=allow_insecure,
            collection=collection,
            collection_regex=collection_regex,
            database=database,
            database_regex=database_regex,
            dataset_name=dataset_name,
            default_format=default_format,
            path=path,
            provenance_field_name=provenance_field_name,
            store_name=store_name,
            urls=urls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_insecure: bool,
             collection: str,
             collection_regex: str,
             database: str,
             database_regex: str,
             dataset_name: str,
             default_format: str,
             path: str,
             provenance_field_name: str,
             store_name: str,
             urls: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("allow_insecure", allow_insecure)
        _setter("collection", collection)
        _setter("collection_regex", collection_regex)
        _setter("database", database)
        _setter("database_regex", database_regex)
        _setter("dataset_name", dataset_name)
        _setter("default_format", default_format)
        _setter("path", path)
        _setter("provenance_field_name", provenance_field_name)
        _setter("store_name", store_name)
        _setter("urls", urls)

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> bool:
        return pulumi.get(self, "allow_insecure")

    @property
    @pulumi.getter
    def collection(self) -> str:
        return pulumi.get(self, "collection")

    @property
    @pulumi.getter(name="collectionRegex")
    def collection_regex(self) -> str:
        return pulumi.get(self, "collection_regex")

    @property
    @pulumi.getter
    def database(self) -> str:
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="databaseRegex")
    def database_regex(self) -> str:
        return pulumi.get(self, "database_regex")

    @property
    @pulumi.getter(name="datasetName")
    def dataset_name(self) -> str:
        return pulumi.get(self, "dataset_name")

    @property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> str:
        return pulumi.get(self, "default_format")

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="provenanceFieldName")
    def provenance_field_name(self) -> str:
        return pulumi.get(self, "provenance_field_name")

    @property
    @pulumi.getter(name="storeName")
    def store_name(self) -> str:
        return pulumi.get(self, "store_name")

    @property
    @pulumi.getter
    def urls(self) -> Sequence[str]:
        return pulumi.get(self, "urls")


@pulumi.output_type
class GetFederatedDatabaseInstanceStorageDatabaseViewResult(dict):
    def __init__(__self__, *,
                 name: str,
                 pipeline: str,
                 source: str):
        """
        :param str name: Name of the Atlas Federated Database Instance.
        """
        GetFederatedDatabaseInstanceStorageDatabaseViewResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            pipeline=pipeline,
            source=source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             pipeline: str,
             source: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("pipeline", pipeline)
        _setter("source", source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def pipeline(self) -> str:
        return pulumi.get(self, "pipeline")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")


@pulumi.output_type
class GetFederatedDatabaseInstanceStorageStoreResult(dict):
    def __init__(__self__, *,
                 additional_storage_classes: Sequence[str],
                 allow_insecure: bool,
                 bucket: str,
                 cluster_id: str,
                 cluster_name: str,
                 default_format: str,
                 delimiter: str,
                 include_tags: bool,
                 name: str,
                 prefix: str,
                 project_id: str,
                 provider: str,
                 public: str,
                 read_preferences: Sequence['outputs.GetFederatedDatabaseInstanceStorageStoreReadPreferenceResult'],
                 region: str,
                 urls: Sequence[str]):
        """
        :param str name: Name of the Atlas Federated Database Instance.
        :param str project_id: The unique ID for the project to create a Federated Database Instance.
        :param str region: Name of the region to which the Federanted Instnace routes client connections for data processing.
        """
        GetFederatedDatabaseInstanceStorageStoreResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            additional_storage_classes=additional_storage_classes,
            allow_insecure=allow_insecure,
            bucket=bucket,
            cluster_id=cluster_id,
            cluster_name=cluster_name,
            default_format=default_format,
            delimiter=delimiter,
            include_tags=include_tags,
            name=name,
            prefix=prefix,
            project_id=project_id,
            provider=provider,
            public=public,
            read_preferences=read_preferences,
            region=region,
            urls=urls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             additional_storage_classes: Sequence[str],
             allow_insecure: bool,
             bucket: str,
             cluster_id: str,
             cluster_name: str,
             default_format: str,
             delimiter: str,
             include_tags: bool,
             name: str,
             prefix: str,
             project_id: str,
             provider: str,
             public: str,
             read_preferences: Sequence['outputs.GetFederatedDatabaseInstanceStorageStoreReadPreferenceResult'],
             region: str,
             urls: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("additional_storage_classes", additional_storage_classes)
        _setter("allow_insecure", allow_insecure)
        _setter("bucket", bucket)
        _setter("cluster_id", cluster_id)
        _setter("cluster_name", cluster_name)
        _setter("default_format", default_format)
        _setter("delimiter", delimiter)
        _setter("include_tags", include_tags)
        _setter("name", name)
        _setter("prefix", prefix)
        _setter("project_id", project_id)
        _setter("provider", provider)
        _setter("public", public)
        _setter("read_preferences", read_preferences)
        _setter("region", region)
        _setter("urls", urls)

    @property
    @pulumi.getter(name="additionalStorageClasses")
    def additional_storage_classes(self) -> Sequence[str]:
        return pulumi.get(self, "additional_storage_classes")

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> bool:
        return pulumi.get(self, "allow_insecure")

    @property
    @pulumi.getter
    def bucket(self) -> str:
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        warnings.warn("""this parameter is deprecated and will be removed by September 2024""", DeprecationWarning)
        pulumi.log.warn("""cluster_id is deprecated: this parameter is deprecated and will be removed by September 2024""")

        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> str:
        return pulumi.get(self, "default_format")

    @property
    @pulumi.getter
    def delimiter(self) -> str:
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="includeTags")
    def include_tags(self) -> bool:
        return pulumi.get(self, "include_tags")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project to create a Federated Database Instance.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def provider(self) -> str:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def public(self) -> str:
        return pulumi.get(self, "public")

    @property
    @pulumi.getter(name="readPreferences")
    def read_preferences(self) -> Sequence['outputs.GetFederatedDatabaseInstanceStorageStoreReadPreferenceResult']:
        return pulumi.get(self, "read_preferences")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Name of the region to which the Federanted Instnace routes client connections for data processing.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def urls(self) -> Sequence[str]:
        return pulumi.get(self, "urls")


@pulumi.output_type
class GetFederatedDatabaseInstanceStorageStoreReadPreferenceResult(dict):
    def __init__(__self__, *,
                 max_staleness_seconds: int,
                 mode: str,
                 tag_sets: Sequence['outputs.GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetResult']):
        GetFederatedDatabaseInstanceStorageStoreReadPreferenceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_staleness_seconds=max_staleness_seconds,
            mode=mode,
            tag_sets=tag_sets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_staleness_seconds: int,
             mode: str,
             tag_sets: Sequence['outputs.GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("max_staleness_seconds", max_staleness_seconds)
        _setter("mode", mode)
        _setter("tag_sets", tag_sets)

    @property
    @pulumi.getter(name="maxStalenessSeconds")
    def max_staleness_seconds(self) -> int:
        return pulumi.get(self, "max_staleness_seconds")

    @property
    @pulumi.getter
    def mode(self) -> str:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="tagSets")
    def tag_sets(self) -> Sequence['outputs.GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetResult']:
        return pulumi.get(self, "tag_sets")


@pulumi.output_type
class GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetResult(dict):
    def __init__(__self__, *,
                 tags: Sequence['outputs.GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTagResult']):
        GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tags: Sequence['outputs.GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTagResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("tags", tags)

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTagResult']:
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTagResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the Atlas Federated Database Instance.
        """
        GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTagResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultResult(dict):
    def __init__(__self__, *,
                 cloud_provider_config: 'outputs.GetFederatedDatabaseInstancesResultCloudProviderConfigResult',
                 data_process_regions: Sequence['outputs.GetFederatedDatabaseInstancesResultDataProcessRegionResult'],
                 hostnames: Sequence[str],
                 name: str,
                 project_id: str,
                 state: str,
                 storage_databases: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageDatabaseResult'],
                 storage_stores: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageStoreResult']):
        """
        :param Sequence[str] hostnames: The list of hostnames assigned to the Federated Database Instance. Each string in the array is a hostname assigned to the Federated Database Instance.
        :param str project_id: The unique ID for the project to create a Federated Database Instance.
        :param str state: Current state of the Federated Database Instance:
        :param Sequence['GetFederatedDatabaseInstancesResultStorageDatabaseArgs'] storage_databases: Configuration details for mapping each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [databases](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-databases-reference). An empty object indicates that the Federated Database Instance has no mapping configuration for any data store.
               * `storage_databases.#.name` - Name of the database to which the Federated Database Instance maps the data contained in the data store.
               * `storage_databases.#.collections` -     Array of objects where each object represents a collection and data sources that map to a [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#mongodb-datalakeconf-datalakeconf.stores) data store.
               * `storage_databases.#.collections.#.name` - Name of the collection.
               * `storage_databases.#.collections.#.data_sources` -     Array of objects where each object represents a stores data store to map with the collection.
               * `storage_databases.#.collections.#.data_sources.#.store_name` -     Name of a data store to map to the `<collection>`. Must match the name of an object in the stores array.
               * `storage_databases.#.collections.#.data_sources.#.dataset_name` -     Human-readable label that identifies the dataset that Atlas generates for an ingestion pipeline run or Online Archive.
               * `storage_databases.#.collections.#.data_sources.#.default_format` - Default format that Federated Database assumes if it encounters a file without an extension while searching the storeName.
               * `storage_databases.#.collections.#.data_sources.#.path` - File path that controls how MongoDB Cloud searches for and parses files in the storeName before mapping them to a collection. Specify / to capture all files and folders from the prefix path.
               * `storage_databases.#.collections.#.data_sources.#.database` - Human-readable label that identifies the database, which contains the collection in the cluster.
               * `storage_databases.#.collections.#.data_sources.#.allow_insecure` - Flag that validates the scheme in the specified URLs. If true, allows insecure HTTP scheme, doesn't verify the server's certificate chain and hostname, and accepts any certificate with any hostname presented by the server. If false, allows secure HTTPS scheme only.
               * `storage_databases.#.collections.#.data_sources.#.database_regex` - Regex pattern to use for creating the wildcard database.
               * `storage_databases.#.collections.#.data_sources.#.collection` - Human-readable label that identifies the collection in the database.
               * `storage_databases.#.collections.#.data_sources.#.collection_regex` - Regex pattern to use for creating the wildcard (*) collection.
               * `storage_databases.#.collections.#.data_sources.#.provenance_field_name` - Name for the field that includes the provenance of the documents in the results.
               * `storage_databases.#.collections.#.data_sources.#.storeName` - Human-readable label that identifies the data store that MongoDB Cloud maps to the collection.
               * `storage_databases.#.collections.#.data_sources.#.urls` - URLs of the publicly accessible data files. You can't specify URLs that require authentication.
               * `storage_databases.#.views` -     Array of objects where each object represents an [aggregation pipeline](https://docs.mongodb.com/manual/core/aggregation-pipeline/#id1) on a collection. To learn more about views, see [Views](https://docs.mongodb.com/manual/core/views/).
               * `storage_databases.#.views.#.name` - Name of the view.
               * `storage_databases.#.views.#.source` -  Name of the source collection for the view.
               * `storage_databases.#.views.#.pipeline`- Aggregation pipeline stage(s) to apply to the source collection.
        :param Sequence['GetFederatedDatabaseInstancesResultStorageStoreArgs'] storage_stores: Each object in the array represents a data store. Federated Database uses the storage.databases configuration details to map data in each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-stores-reference). An empty object indicates that the Federated Database Instance has no configured data stores.
               * `storage_stores.#.name` - Name of the data store.
               * `storage_stores.#.provider` - Defines where the data is stored.
               * `storage_stores.#.region` - Name of the AWS region in which the S3 bucket is hosted.
               * `storage_stores.#.bucket` - Name of the AWS S3 bucket.
               * `storage_stores.#.prefix` - Prefix the Federated Database Instance applies when searching for files in the S3 bucket.
               * `storage_stores.#.delimiter` - The delimiter that separates `storage_databases.#.collections.#.data_sources.#.path` segments in the data store.
               * `storage_stores.#.include_tags` - Determines whether or not to use S3 tags on the files in the given path as additional partition attributes.
               * `storage_stores.#.cluster_name` - Human-readable label of the MongoDB Cloud cluster on which the store is based.
               * `storage_stores.#.cluster_id` - ID of the Cluster the Online Archive belongs to.
               * `storage_stores.#.allow_insecure` - Flag that validates the scheme in the specified URLs.
               * `storage_stores.#.public` - Flag that indicates whether the bucket is public.
               * `storage_stores.#.default_format` - Default format that Data Lake assumes if it encounters a file without an extension while searching the storeName.
               * `storage_stores.#.urls` - Comma-separated list of publicly accessible HTTP URLs where data is stored.
               * `storage_stores.#.read_preference` - MongoDB Cloud cluster read preference, which describes how to route read requests to the cluster.
               * `storage_stores.#.read_preference.maxStalenessSeconds` - Maximum replication lag, or staleness, for reads from secondaries.
               * `storage_stores.#.read_preference.mode` - Read preference mode that specifies to which replica set member to route the read requests.
               * `storage_stores.#.read_preference.tag_sets` - List that contains tag sets or tag specification documents.
               * `storage_stores.#.read_preference.tags` - List of all tags within a tag set
               * `storage_stores.#.read_preference.tags.name` - Human-readable label of the tag.
               * `storage_stores.#.read_preference.tags.value` - Value of the tag.
        """
        GetFederatedDatabaseInstancesResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_provider_config=cloud_provider_config,
            data_process_regions=data_process_regions,
            hostnames=hostnames,
            name=name,
            project_id=project_id,
            state=state,
            storage_databases=storage_databases,
            storage_stores=storage_stores,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_provider_config: 'outputs.GetFederatedDatabaseInstancesResultCloudProviderConfigResult',
             data_process_regions: Sequence['outputs.GetFederatedDatabaseInstancesResultDataProcessRegionResult'],
             hostnames: Sequence[str],
             name: str,
             project_id: str,
             state: str,
             storage_databases: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageDatabaseResult'],
             storage_stores: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageStoreResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cloud_provider_config", cloud_provider_config)
        _setter("data_process_regions", data_process_regions)
        _setter("hostnames", hostnames)
        _setter("name", name)
        _setter("project_id", project_id)
        _setter("state", state)
        _setter("storage_databases", storage_databases)
        _setter("storage_stores", storage_stores)

    @property
    @pulumi.getter(name="cloudProviderConfig")
    def cloud_provider_config(self) -> 'outputs.GetFederatedDatabaseInstancesResultCloudProviderConfigResult':
        return pulumi.get(self, "cloud_provider_config")

    @property
    @pulumi.getter(name="dataProcessRegions")
    def data_process_regions(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultDataProcessRegionResult']:
        return pulumi.get(self, "data_process_regions")

    @property
    @pulumi.getter
    def hostnames(self) -> Sequence[str]:
        """
        The list of hostnames assigned to the Federated Database Instance. Each string in the array is a hostname assigned to the Federated Database Instance.
        """
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project to create a Federated Database Instance.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Current state of the Federated Database Instance:
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="storageDatabases")
    def storage_databases(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultStorageDatabaseResult']:
        """
        Configuration details for mapping each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [databases](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-databases-reference). An empty object indicates that the Federated Database Instance has no mapping configuration for any data store.
        * `storage_databases.#.name` - Name of the database to which the Federated Database Instance maps the data contained in the data store.
        * `storage_databases.#.collections` -     Array of objects where each object represents a collection and data sources that map to a [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#mongodb-datalakeconf-datalakeconf.stores) data store.
        * `storage_databases.#.collections.#.name` - Name of the collection.
        * `storage_databases.#.collections.#.data_sources` -     Array of objects where each object represents a stores data store to map with the collection.
        * `storage_databases.#.collections.#.data_sources.#.store_name` -     Name of a data store to map to the `<collection>`. Must match the name of an object in the stores array.
        * `storage_databases.#.collections.#.data_sources.#.dataset_name` -     Human-readable label that identifies the dataset that Atlas generates for an ingestion pipeline run or Online Archive.
        * `storage_databases.#.collections.#.data_sources.#.default_format` - Default format that Federated Database assumes if it encounters a file without an extension while searching the storeName.
        * `storage_databases.#.collections.#.data_sources.#.path` - File path that controls how MongoDB Cloud searches for and parses files in the storeName before mapping them to a collection. Specify / to capture all files and folders from the prefix path.
        * `storage_databases.#.collections.#.data_sources.#.database` - Human-readable label that identifies the database, which contains the collection in the cluster.
        * `storage_databases.#.collections.#.data_sources.#.allow_insecure` - Flag that validates the scheme in the specified URLs. If true, allows insecure HTTP scheme, doesn't verify the server's certificate chain and hostname, and accepts any certificate with any hostname presented by the server. If false, allows secure HTTPS scheme only.
        * `storage_databases.#.collections.#.data_sources.#.database_regex` - Regex pattern to use for creating the wildcard database.
        * `storage_databases.#.collections.#.data_sources.#.collection` - Human-readable label that identifies the collection in the database.
        * `storage_databases.#.collections.#.data_sources.#.collection_regex` - Regex pattern to use for creating the wildcard (*) collection.
        * `storage_databases.#.collections.#.data_sources.#.provenance_field_name` - Name for the field that includes the provenance of the documents in the results.
        * `storage_databases.#.collections.#.data_sources.#.storeName` - Human-readable label that identifies the data store that MongoDB Cloud maps to the collection.
        * `storage_databases.#.collections.#.data_sources.#.urls` - URLs of the publicly accessible data files. You can't specify URLs that require authentication.
        * `storage_databases.#.views` -     Array of objects where each object represents an [aggregation pipeline](https://docs.mongodb.com/manual/core/aggregation-pipeline/#id1) on a collection. To learn more about views, see [Views](https://docs.mongodb.com/manual/core/views/).
        * `storage_databases.#.views.#.name` - Name of the view.
        * `storage_databases.#.views.#.source` -  Name of the source collection for the view.
        * `storage_databases.#.views.#.pipeline`- Aggregation pipeline stage(s) to apply to the source collection.
        """
        return pulumi.get(self, "storage_databases")

    @property
    @pulumi.getter(name="storageStores")
    def storage_stores(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultStorageStoreResult']:
        """
        Each object in the array represents a data store. Federated Database uses the storage.databases configuration details to map data in each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-stores-reference). An empty object indicates that the Federated Database Instance has no configured data stores.
        * `storage_stores.#.name` - Name of the data store.
        * `storage_stores.#.provider` - Defines where the data is stored.
        * `storage_stores.#.region` - Name of the AWS region in which the S3 bucket is hosted.
        * `storage_stores.#.bucket` - Name of the AWS S3 bucket.
        * `storage_stores.#.prefix` - Prefix the Federated Database Instance applies when searching for files in the S3 bucket.
        * `storage_stores.#.delimiter` - The delimiter that separates `storage_databases.#.collections.#.data_sources.#.path` segments in the data store.
        * `storage_stores.#.include_tags` - Determines whether or not to use S3 tags on the files in the given path as additional partition attributes.
        * `storage_stores.#.cluster_name` - Human-readable label of the MongoDB Cloud cluster on which the store is based.
        * `storage_stores.#.cluster_id` - ID of the Cluster the Online Archive belongs to.
        * `storage_stores.#.allow_insecure` - Flag that validates the scheme in the specified URLs.
        * `storage_stores.#.public` - Flag that indicates whether the bucket is public.
        * `storage_stores.#.default_format` - Default format that Data Lake assumes if it encounters a file without an extension while searching the storeName.
        * `storage_stores.#.urls` - Comma-separated list of publicly accessible HTTP URLs where data is stored.
        * `storage_stores.#.read_preference` - MongoDB Cloud cluster read preference, which describes how to route read requests to the cluster.
        * `storage_stores.#.read_preference.maxStalenessSeconds` - Maximum replication lag, or staleness, for reads from secondaries.
        * `storage_stores.#.read_preference.mode` - Read preference mode that specifies to which replica set member to route the read requests.
        * `storage_stores.#.read_preference.tag_sets` - List that contains tag sets or tag specification documents.
        * `storage_stores.#.read_preference.tags` - List of all tags within a tag set
        * `storage_stores.#.read_preference.tags.name` - Human-readable label of the tag.
        * `storage_stores.#.read_preference.tags.value` - Value of the tag.
        """
        return pulumi.get(self, "storage_stores")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultCloudProviderConfigResult(dict):
    def __init__(__self__, *,
                 aws: 'outputs.GetFederatedDatabaseInstancesResultCloudProviderConfigAwsResult'):
        GetFederatedDatabaseInstancesResultCloudProviderConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aws=aws,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aws: 'outputs.GetFederatedDatabaseInstancesResultCloudProviderConfigAwsResult',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aws", aws)

    @property
    @pulumi.getter
    def aws(self) -> 'outputs.GetFederatedDatabaseInstancesResultCloudProviderConfigAwsResult':
        return pulumi.get(self, "aws")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultCloudProviderConfigAwsResult(dict):
    def __init__(__self__, *,
                 external_id: str,
                 iam_assumed_role_arn: str,
                 iam_user_arn: str,
                 role_id: str,
                 test_s3_bucket: str):
        """
        :param str external_id: Unique identifier associated with the IAM Role that the Federated Database Instance assumes when accessing the data stores.
        :param str iam_assumed_role_arn: Amazon Resource Name (ARN) of the IAM Role that the Federated Database Instance assumes when accessing S3 Bucket data stores. The IAM Role must support the following actions against each S3 bucket:
               * `s3:GetObject`
               * `s3:ListBucket`
               * `s3:GetObjectVersion`
        :param str iam_user_arn: Amazon Resource Name (ARN) of the user that the Federated Database Instance assumes when accessing S3 Bucket data stores.
        :param str role_id: Unique identifier of the role that the data lake can use to access the data stores.
               #### `data_process_region` - The cloud provider region to which the Federated Instance routes client connections for data processing.
        """
        GetFederatedDatabaseInstancesResultCloudProviderConfigAwsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            external_id=external_id,
            iam_assumed_role_arn=iam_assumed_role_arn,
            iam_user_arn=iam_user_arn,
            role_id=role_id,
            test_s3_bucket=test_s3_bucket,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             external_id: str,
             iam_assumed_role_arn: str,
             iam_user_arn: str,
             role_id: str,
             test_s3_bucket: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("external_id", external_id)
        _setter("iam_assumed_role_arn", iam_assumed_role_arn)
        _setter("iam_user_arn", iam_user_arn)
        _setter("role_id", role_id)
        _setter("test_s3_bucket", test_s3_bucket)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> str:
        """
        Unique identifier associated with the IAM Role that the Federated Database Instance assumes when accessing the data stores.
        """
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="iamAssumedRoleArn")
    def iam_assumed_role_arn(self) -> str:
        """
        Amazon Resource Name (ARN) of the IAM Role that the Federated Database Instance assumes when accessing S3 Bucket data stores. The IAM Role must support the following actions against each S3 bucket:
        * `s3:GetObject`
        * `s3:ListBucket`
        * `s3:GetObjectVersion`
        """
        return pulumi.get(self, "iam_assumed_role_arn")

    @property
    @pulumi.getter(name="iamUserArn")
    def iam_user_arn(self) -> str:
        """
        Amazon Resource Name (ARN) of the user that the Federated Database Instance assumes when accessing S3 Bucket data stores.
        """
        return pulumi.get(self, "iam_user_arn")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> str:
        """
        Unique identifier of the role that the data lake can use to access the data stores.
        #### `data_process_region` - The cloud provider region to which the Federated Instance routes client connections for data processing.
        """
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="testS3Bucket")
    def test_s3_bucket(self) -> str:
        return pulumi.get(self, "test_s3_bucket")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultDataProcessRegionResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 region: str):
        """
        :param str cloud_provider: Name of the cloud service provider. Atlas Federated Database only supports AWS.
        :param str region: Name of the region to which the Federanted Instnace routes client connections for data processing.
        """
        GetFederatedDatabaseInstancesResultDataProcessRegionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_provider=cloud_provider,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_provider: str,
             region: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cloud_provider", cloud_provider)
        _setter("region", region)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        Name of the cloud service provider. Atlas Federated Database only supports AWS.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Name of the region to which the Federanted Instnace routes client connections for data processing.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultStorageDatabaseResult(dict):
    def __init__(__self__, *,
                 collections: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageDatabaseCollectionResult'],
                 max_wildcard_collections: int,
                 name: str,
                 views: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageDatabaseViewResult']):
        GetFederatedDatabaseInstancesResultStorageDatabaseResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            collections=collections,
            max_wildcard_collections=max_wildcard_collections,
            name=name,
            views=views,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             collections: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageDatabaseCollectionResult'],
             max_wildcard_collections: int,
             name: str,
             views: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageDatabaseViewResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("collections", collections)
        _setter("max_wildcard_collections", max_wildcard_collections)
        _setter("name", name)
        _setter("views", views)

    @property
    @pulumi.getter
    def collections(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultStorageDatabaseCollectionResult']:
        return pulumi.get(self, "collections")

    @property
    @pulumi.getter(name="maxWildcardCollections")
    def max_wildcard_collections(self) -> int:
        return pulumi.get(self, "max_wildcard_collections")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def views(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultStorageDatabaseViewResult']:
        return pulumi.get(self, "views")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultStorageDatabaseCollectionResult(dict):
    def __init__(__self__, *,
                 data_sources: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageDatabaseCollectionDataSourceResult'],
                 name: str):
        GetFederatedDatabaseInstancesResultStorageDatabaseCollectionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_sources=data_sources,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_sources: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageDatabaseCollectionDataSourceResult'],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_sources", data_sources)
        _setter("name", name)

    @property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultStorageDatabaseCollectionDataSourceResult']:
        return pulumi.get(self, "data_sources")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultStorageDatabaseCollectionDataSourceResult(dict):
    def __init__(__self__, *,
                 allow_insecure: bool,
                 collection: str,
                 collection_regex: str,
                 database: str,
                 database_regex: str,
                 dataset_name: str,
                 default_format: str,
                 path: str,
                 provenance_field_name: str,
                 store_name: str,
                 urls: Sequence[str]):
        GetFederatedDatabaseInstancesResultStorageDatabaseCollectionDataSourceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_insecure=allow_insecure,
            collection=collection,
            collection_regex=collection_regex,
            database=database,
            database_regex=database_regex,
            dataset_name=dataset_name,
            default_format=default_format,
            path=path,
            provenance_field_name=provenance_field_name,
            store_name=store_name,
            urls=urls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_insecure: bool,
             collection: str,
             collection_regex: str,
             database: str,
             database_regex: str,
             dataset_name: str,
             default_format: str,
             path: str,
             provenance_field_name: str,
             store_name: str,
             urls: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("allow_insecure", allow_insecure)
        _setter("collection", collection)
        _setter("collection_regex", collection_regex)
        _setter("database", database)
        _setter("database_regex", database_regex)
        _setter("dataset_name", dataset_name)
        _setter("default_format", default_format)
        _setter("path", path)
        _setter("provenance_field_name", provenance_field_name)
        _setter("store_name", store_name)
        _setter("urls", urls)

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> bool:
        return pulumi.get(self, "allow_insecure")

    @property
    @pulumi.getter
    def collection(self) -> str:
        return pulumi.get(self, "collection")

    @property
    @pulumi.getter(name="collectionRegex")
    def collection_regex(self) -> str:
        return pulumi.get(self, "collection_regex")

    @property
    @pulumi.getter
    def database(self) -> str:
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="databaseRegex")
    def database_regex(self) -> str:
        return pulumi.get(self, "database_regex")

    @property
    @pulumi.getter(name="datasetName")
    def dataset_name(self) -> str:
        return pulumi.get(self, "dataset_name")

    @property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> str:
        return pulumi.get(self, "default_format")

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="provenanceFieldName")
    def provenance_field_name(self) -> str:
        return pulumi.get(self, "provenance_field_name")

    @property
    @pulumi.getter(name="storeName")
    def store_name(self) -> str:
        return pulumi.get(self, "store_name")

    @property
    @pulumi.getter
    def urls(self) -> Sequence[str]:
        return pulumi.get(self, "urls")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultStorageDatabaseViewResult(dict):
    def __init__(__self__, *,
                 name: str,
                 pipeline: str,
                 source: str):
        GetFederatedDatabaseInstancesResultStorageDatabaseViewResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            pipeline=pipeline,
            source=source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             pipeline: str,
             source: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("pipeline", pipeline)
        _setter("source", source)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def pipeline(self) -> str:
        return pulumi.get(self, "pipeline")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultStorageStoreResult(dict):
    def __init__(__self__, *,
                 additional_storage_classes: Sequence[str],
                 allow_insecure: bool,
                 bucket: str,
                 cluster_id: str,
                 cluster_name: str,
                 default_format: str,
                 delimiter: str,
                 include_tags: bool,
                 name: str,
                 prefix: str,
                 project_id: str,
                 provider: str,
                 public: str,
                 read_preferences: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceResult'],
                 region: str,
                 urls: Sequence[str]):
        """
        :param str project_id: The unique ID for the project to create a Federated Database Instance.
        :param str region: Name of the region to which the Federanted Instnace routes client connections for data processing.
        """
        GetFederatedDatabaseInstancesResultStorageStoreResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            additional_storage_classes=additional_storage_classes,
            allow_insecure=allow_insecure,
            bucket=bucket,
            cluster_id=cluster_id,
            cluster_name=cluster_name,
            default_format=default_format,
            delimiter=delimiter,
            include_tags=include_tags,
            name=name,
            prefix=prefix,
            project_id=project_id,
            provider=provider,
            public=public,
            read_preferences=read_preferences,
            region=region,
            urls=urls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             additional_storage_classes: Sequence[str],
             allow_insecure: bool,
             bucket: str,
             cluster_id: str,
             cluster_name: str,
             default_format: str,
             delimiter: str,
             include_tags: bool,
             name: str,
             prefix: str,
             project_id: str,
             provider: str,
             public: str,
             read_preferences: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceResult'],
             region: str,
             urls: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("additional_storage_classes", additional_storage_classes)
        _setter("allow_insecure", allow_insecure)
        _setter("bucket", bucket)
        _setter("cluster_id", cluster_id)
        _setter("cluster_name", cluster_name)
        _setter("default_format", default_format)
        _setter("delimiter", delimiter)
        _setter("include_tags", include_tags)
        _setter("name", name)
        _setter("prefix", prefix)
        _setter("project_id", project_id)
        _setter("provider", provider)
        _setter("public", public)
        _setter("read_preferences", read_preferences)
        _setter("region", region)
        _setter("urls", urls)

    @property
    @pulumi.getter(name="additionalStorageClasses")
    def additional_storage_classes(self) -> Sequence[str]:
        return pulumi.get(self, "additional_storage_classes")

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> bool:
        return pulumi.get(self, "allow_insecure")

    @property
    @pulumi.getter
    def bucket(self) -> str:
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        warnings.warn("""this parameter is deprecated and will be removed by September 2024""", DeprecationWarning)
        pulumi.log.warn("""cluster_id is deprecated: this parameter is deprecated and will be removed by September 2024""")

        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> str:
        return pulumi.get(self, "default_format")

    @property
    @pulumi.getter
    def delimiter(self) -> str:
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="includeTags")
    def include_tags(self) -> bool:
        return pulumi.get(self, "include_tags")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project to create a Federated Database Instance.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def provider(self) -> str:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def public(self) -> str:
        return pulumi.get(self, "public")

    @property
    @pulumi.getter(name="readPreferences")
    def read_preferences(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceResult']:
        return pulumi.get(self, "read_preferences")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Name of the region to which the Federanted Instnace routes client connections for data processing.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def urls(self) -> Sequence[str]:
        return pulumi.get(self, "urls")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceResult(dict):
    def __init__(__self__, *,
                 max_staleness_seconds: int,
                 mode: str,
                 tag_sets: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetResult']):
        GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_staleness_seconds=max_staleness_seconds,
            mode=mode,
            tag_sets=tag_sets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_staleness_seconds: int,
             mode: str,
             tag_sets: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("max_staleness_seconds", max_staleness_seconds)
        _setter("mode", mode)
        _setter("tag_sets", tag_sets)

    @property
    @pulumi.getter(name="maxStalenessSeconds")
    def max_staleness_seconds(self) -> int:
        return pulumi.get(self, "max_staleness_seconds")

    @property
    @pulumi.getter
    def mode(self) -> str:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="tagSets")
    def tag_sets(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetResult']:
        return pulumi.get(self, "tag_sets")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetResult(dict):
    def __init__(__self__, *,
                 tags: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetTagResult']):
        GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tags: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetTagResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("tags", tags)

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetTagResult']:
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetTagResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetTagResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetFederatedQueryLimitsResultResult(dict):
    def __init__(__self__, *,
                 current_usage: int,
                 default_limit: int,
                 last_modified_date: str,
                 limit_name: str,
                 maximum_limit: int,
                 overrun_policy: str,
                 project_id: str,
                 tenant_name: str,
                 value: int):
        """
        :param int current_usage: Amount that indicates the current usage of the limit.
        :param int default_limit: Default value of the limit.
        :param str project_id: The unique ID for the project to create a Federated Database Instance.
        :param str tenant_name: Name of the Atlas Federated Database Instance.
        """
        GetFederatedQueryLimitsResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            current_usage=current_usage,
            default_limit=default_limit,
            last_modified_date=last_modified_date,
            limit_name=limit_name,
            maximum_limit=maximum_limit,
            overrun_policy=overrun_policy,
            project_id=project_id,
            tenant_name=tenant_name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             current_usage: int,
             default_limit: int,
             last_modified_date: str,
             limit_name: str,
             maximum_limit: int,
             overrun_policy: str,
             project_id: str,
             tenant_name: str,
             value: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("current_usage", current_usage)
        _setter("default_limit", default_limit)
        _setter("last_modified_date", last_modified_date)
        _setter("limit_name", limit_name)
        _setter("maximum_limit", maximum_limit)
        _setter("overrun_policy", overrun_policy)
        _setter("project_id", project_id)
        _setter("tenant_name", tenant_name)
        _setter("value", value)

    @property
    @pulumi.getter(name="currentUsage")
    def current_usage(self) -> int:
        """
        Amount that indicates the current usage of the limit.
        """
        return pulumi.get(self, "current_usage")

    @property
    @pulumi.getter(name="defaultLimit")
    def default_limit(self) -> int:
        """
        Default value of the limit.
        """
        return pulumi.get(self, "default_limit")

    @property
    @pulumi.getter(name="lastModifiedDate")
    def last_modified_date(self) -> str:
        return pulumi.get(self, "last_modified_date")

    @property
    @pulumi.getter(name="limitName")
    def limit_name(self) -> str:
        return pulumi.get(self, "limit_name")

    @property
    @pulumi.getter(name="maximumLimit")
    def maximum_limit(self) -> int:
        return pulumi.get(self, "maximum_limit")

    @property
    @pulumi.getter(name="overrunPolicy")
    def overrun_policy(self) -> str:
        return pulumi.get(self, "overrun_policy")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project to create a Federated Database Instance.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="tenantName")
    def tenant_name(self) -> str:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "tenant_name")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetFederatedSettingsIdentityProviderAssociatedOrgResult(dict):
    def __init__(__self__, *,
                 domain_allow_lists: Sequence[str],
                 domain_restriction_enabled: bool,
                 identity_provider_id: str,
                 org_id: str,
                 post_auth_role_grants: Sequence[str],
                 role_mappings: Sequence['outputs.GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingResult'],
                 user_conflicts: Sequence['outputs.GetFederatedSettingsIdentityProviderAssociatedOrgUserConflictResult']):
        """
        :param Sequence[str] domain_allow_lists: List that contains the approved domains from which organization users can log in.
        :param bool domain_restriction_enabled: Flag that indicates whether domain restriction is enabled for the connected organization.
        :param str identity_provider_id: Unique 20-hexadecimal digit string that identifies the IdP.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param Sequence[str] post_auth_role_grants: List that contains the default roles granted to users who authenticate through the IdP in a connected organization. If you provide a postAuthRoleGrants field in the request, the array that you provide replaces the current postAuthRoleGrants.
        """
        GetFederatedSettingsIdentityProviderAssociatedOrgResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain_allow_lists=domain_allow_lists,
            domain_restriction_enabled=domain_restriction_enabled,
            identity_provider_id=identity_provider_id,
            org_id=org_id,
            post_auth_role_grants=post_auth_role_grants,
            role_mappings=role_mappings,
            user_conflicts=user_conflicts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain_allow_lists: Sequence[str],
             domain_restriction_enabled: bool,
             identity_provider_id: str,
             org_id: str,
             post_auth_role_grants: Sequence[str],
             role_mappings: Sequence['outputs.GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingResult'],
             user_conflicts: Sequence['outputs.GetFederatedSettingsIdentityProviderAssociatedOrgUserConflictResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("domain_allow_lists", domain_allow_lists)
        _setter("domain_restriction_enabled", domain_restriction_enabled)
        _setter("identity_provider_id", identity_provider_id)
        _setter("org_id", org_id)
        _setter("post_auth_role_grants", post_auth_role_grants)
        _setter("role_mappings", role_mappings)
        _setter("user_conflicts", user_conflicts)

    @property
    @pulumi.getter(name="domainAllowLists")
    def domain_allow_lists(self) -> Sequence[str]:
        """
        List that contains the approved domains from which organization users can log in.
        """
        return pulumi.get(self, "domain_allow_lists")

    @property
    @pulumi.getter(name="domainRestrictionEnabled")
    def domain_restriction_enabled(self) -> bool:
        """
        Flag that indicates whether domain restriction is enabled for the connected organization.
        """
        return pulumi.get(self, "domain_restriction_enabled")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        Unique 20-hexadecimal digit string that identifies the IdP.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter(name="postAuthRoleGrants")
    def post_auth_role_grants(self) -> Sequence[str]:
        """
        List that contains the default roles granted to users who authenticate through the IdP in a connected organization. If you provide a postAuthRoleGrants field in the request, the array that you provide replaces the current postAuthRoleGrants.
        """
        return pulumi.get(self, "post_auth_role_grants")

    @property
    @pulumi.getter(name="roleMappings")
    def role_mappings(self) -> Sequence['outputs.GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingResult']:
        return pulumi.get(self, "role_mappings")

    @property
    @pulumi.getter(name="userConflicts")
    def user_conflicts(self) -> Sequence['outputs.GetFederatedSettingsIdentityProviderAssociatedOrgUserConflictResult']:
        return pulumi.get(self, "user_conflicts")


@pulumi.output_type
class GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingResult(dict):
    def __init__(__self__, *,
                 external_group_name: str,
                 id: str,
                 role_assignments: Sequence['outputs.GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignmentResult']):
        """
        :param str external_group_name: Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        :param str id: Unique 24-hexadecimal digit string that identifies this role mapping.
        :param Sequence['GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignmentArgs'] role_assignments: Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            external_group_name=external_group_name,
            id=id,
            role_assignments=role_assignments,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             external_group_name: str,
             id: str,
             role_assignments: Sequence['outputs.GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignmentResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("external_group_name", external_group_name)
        _setter("id", id)
        _setter("role_assignments", role_assignments)

    @property
    @pulumi.getter(name="externalGroupName")
    def external_group_name(self) -> str:
        """
        Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        """
        return pulumi.get(self, "external_group_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies this role mapping.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="roleAssignments")
    def role_assignments(self) -> Sequence['outputs.GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignmentResult']:
        """
        Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        return pulumi.get(self, "role_assignments")


@pulumi.output_type
class GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 group_id: str,
                 org_id: str,
                 role: str):
        """
        :param str group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param str role: Specifies the Role that is attached to the Role Mapping.
        """
        GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_id=group_id,
            org_id=org_id,
            role=role,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_id: str,
             org_id: str,
             role: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("group_id", group_id)
        _setter("org_id", org_id)
        _setter("role", role)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Specifies the Role that is attached to the Role Mapping.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetFederatedSettingsIdentityProviderAssociatedOrgUserConflictResult(dict):
    def __init__(__self__, *,
                 email_address: str,
                 federation_settings_id: str,
                 first_name: str,
                 last_name: str,
                 user_id: str):
        """
        :param str email_address: Email address of the the user that conflicts with selected domains.
        :param str federation_settings_id: Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        :param str first_name: First name of the the user that conflicts with selected domains.
        :param str last_name: Last name of the the user that conflicts with selected domains.
        :param str user_id: Name of the Atlas user that conflicts with selected domains.
        """
        GetFederatedSettingsIdentityProviderAssociatedOrgUserConflictResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            email_address=email_address,
            federation_settings_id=federation_settings_id,
            first_name=first_name,
            last_name=last_name,
            user_id=user_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             email_address: str,
             federation_settings_id: str,
             first_name: str,
             last_name: str,
             user_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("email_address", email_address)
        _setter("federation_settings_id", federation_settings_id)
        _setter("first_name", first_name)
        _setter("last_name", last_name)
        _setter("user_id", user_id)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> str:
        """
        Email address of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter(name="federationSettingsId")
    def federation_settings_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        """
        return pulumi.get(self, "federation_settings_id")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> str:
        """
        First name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> str:
        """
        Last name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        """
        Name of the Atlas user that conflicts with selected domains.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetFederatedSettingsIdentityProviderPemFileInfoResult(dict):
    def __init__(__self__, *,
                 certificates: Sequence['outputs.GetFederatedSettingsIdentityProviderPemFileInfoCertificateResult'],
                 file_name: str):
        """
        :param str file_name: Filename of certificate
        """
        GetFederatedSettingsIdentityProviderPemFileInfoResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificates=certificates,
            file_name=file_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificates: Sequence['outputs.GetFederatedSettingsIdentityProviderPemFileInfoCertificateResult'],
             file_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("certificates", certificates)
        _setter("file_name", file_name)

    @property
    @pulumi.getter
    def certificates(self) -> Sequence['outputs.GetFederatedSettingsIdentityProviderPemFileInfoCertificateResult']:
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> str:
        """
        Filename of certificate
        """
        return pulumi.get(self, "file_name")


@pulumi.output_type
class GetFederatedSettingsIdentityProviderPemFileInfoCertificateResult(dict):
    def __init__(__self__, *,
                 not_after: str,
                 not_before: str):
        """
        :param str not_after: Expiration  Date.
        :param str not_before: Start Date.
        """
        GetFederatedSettingsIdentityProviderPemFileInfoCertificateResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            not_after=not_after,
            not_before=not_before,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             not_after: str,
             not_before: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("not_after", not_after)
        _setter("not_before", not_before)

    @property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> str:
        """
        Expiration  Date.
        """
        return pulumi.get(self, "not_after")

    @property
    @pulumi.getter(name="notBefore")
    def not_before(self) -> str:
        """
        Start Date.
        """
        return pulumi.get(self, "not_before")


@pulumi.output_type
class GetFederatedSettingsIdentityProvidersResultResult(dict):
    def __init__(__self__, *,
                 acs_url: str,
                 associated_domains: Sequence[str],
                 associated_orgs: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgResult'],
                 audience_uri: str,
                 display_name: str,
                 issuer_uri: str,
                 okta_idp_id: str,
                 pem_file_infos: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultPemFileInfoResult'],
                 request_binding: str,
                 response_signature_algorithm: str,
                 sso_debug_enabled: bool,
                 sso_url: str,
                 status: str):
        """
        :param str acs_url: Assertion consumer service URL to which the IdP sends the SAML response.
        :param Sequence[str] associated_domains: List that contains the configured domains from which users can log in for this IdP.
        :param Sequence['GetFederatedSettingsIdentityProvidersResultAssociatedOrgArgs'] associated_orgs: List that contains the configured domains from which users can log in for this IdP.
        :param str audience_uri: Identifier for the intended audience of the SAML Assertion.
        :param str display_name: Human-readable label that identifies the IdP.
        :param str issuer_uri: Identifier for the issuer of the SAML Assertion.
        :param str request_binding: SAML Authentication Request Protocol binding used to send the AuthNRequest. Atlas supports the following binding values:
               - HTTP POST
               - HTTP REDIRECT
        :param str response_signature_algorithm: Algorithm used to encrypt the IdP signature. Atlas supports the following signature algorithm values:
               - SHA-1
               - SHA-256
        :param bool sso_debug_enabled: Flag that indicates whether the IdP has enabled Bypass SAML Mode. Enabling this mode generates a URL that allows you bypass SAML and login to your organizations at any point. You can authenticate with this special URL only when Bypass Mode is enabled. Set this parameter to true during testing. This keeps you from getting locked out of MongoDB.
        :param str sso_url: URL of the receiver of the SAML AuthNRequest.
        :param str status: Label that indicates whether the identity provider is active. The IdP is Inactive until you map at least one domain to the IdP.
        """
        GetFederatedSettingsIdentityProvidersResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acs_url=acs_url,
            associated_domains=associated_domains,
            associated_orgs=associated_orgs,
            audience_uri=audience_uri,
            display_name=display_name,
            issuer_uri=issuer_uri,
            okta_idp_id=okta_idp_id,
            pem_file_infos=pem_file_infos,
            request_binding=request_binding,
            response_signature_algorithm=response_signature_algorithm,
            sso_debug_enabled=sso_debug_enabled,
            sso_url=sso_url,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acs_url: str,
             associated_domains: Sequence[str],
             associated_orgs: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgResult'],
             audience_uri: str,
             display_name: str,
             issuer_uri: str,
             okta_idp_id: str,
             pem_file_infos: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultPemFileInfoResult'],
             request_binding: str,
             response_signature_algorithm: str,
             sso_debug_enabled: bool,
             sso_url: str,
             status: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("acs_url", acs_url)
        _setter("associated_domains", associated_domains)
        _setter("associated_orgs", associated_orgs)
        _setter("audience_uri", audience_uri)
        _setter("display_name", display_name)
        _setter("issuer_uri", issuer_uri)
        _setter("okta_idp_id", okta_idp_id)
        _setter("pem_file_infos", pem_file_infos)
        _setter("request_binding", request_binding)
        _setter("response_signature_algorithm", response_signature_algorithm)
        _setter("sso_debug_enabled", sso_debug_enabled)
        _setter("sso_url", sso_url)
        _setter("status", status)

    @property
    @pulumi.getter(name="acsUrl")
    def acs_url(self) -> str:
        """
        Assertion consumer service URL to which the IdP sends the SAML response.
        """
        return pulumi.get(self, "acs_url")

    @property
    @pulumi.getter(name="associatedDomains")
    def associated_domains(self) -> Sequence[str]:
        """
        List that contains the configured domains from which users can log in for this IdP.
        """
        return pulumi.get(self, "associated_domains")

    @property
    @pulumi.getter(name="associatedOrgs")
    def associated_orgs(self) -> Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgResult']:
        """
        List that contains the configured domains from which users can log in for this IdP.
        """
        return pulumi.get(self, "associated_orgs")

    @property
    @pulumi.getter(name="audienceUri")
    def audience_uri(self) -> str:
        """
        Identifier for the intended audience of the SAML Assertion.
        """
        return pulumi.get(self, "audience_uri")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        Human-readable label that identifies the IdP.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="issuerUri")
    def issuer_uri(self) -> str:
        """
        Identifier for the issuer of the SAML Assertion.
        """
        return pulumi.get(self, "issuer_uri")

    @property
    @pulumi.getter(name="oktaIdpId")
    def okta_idp_id(self) -> str:
        return pulumi.get(self, "okta_idp_id")

    @property
    @pulumi.getter(name="pemFileInfos")
    def pem_file_infos(self) -> Sequence['outputs.GetFederatedSettingsIdentityProvidersResultPemFileInfoResult']:
        return pulumi.get(self, "pem_file_infos")

    @property
    @pulumi.getter(name="requestBinding")
    def request_binding(self) -> str:
        """
        SAML Authentication Request Protocol binding used to send the AuthNRequest. Atlas supports the following binding values:
        - HTTP POST
        - HTTP REDIRECT
        """
        return pulumi.get(self, "request_binding")

    @property
    @pulumi.getter(name="responseSignatureAlgorithm")
    def response_signature_algorithm(self) -> str:
        """
        Algorithm used to encrypt the IdP signature. Atlas supports the following signature algorithm values:
        - SHA-1
        - SHA-256
        """
        return pulumi.get(self, "response_signature_algorithm")

    @property
    @pulumi.getter(name="ssoDebugEnabled")
    def sso_debug_enabled(self) -> bool:
        """
        Flag that indicates whether the IdP has enabled Bypass SAML Mode. Enabling this mode generates a URL that allows you bypass SAML and login to your organizations at any point. You can authenticate with this special URL only when Bypass Mode is enabled. Set this parameter to true during testing. This keeps you from getting locked out of MongoDB.
        """
        return pulumi.get(self, "sso_debug_enabled")

    @property
    @pulumi.getter(name="ssoUrl")
    def sso_url(self) -> str:
        """
        URL of the receiver of the SAML AuthNRequest.
        """
        return pulumi.get(self, "sso_url")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Label that indicates whether the identity provider is active. The IdP is Inactive until you map at least one domain to the IdP.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetFederatedSettingsIdentityProvidersResultAssociatedOrgResult(dict):
    def __init__(__self__, *,
                 domain_allow_lists: Sequence[str],
                 domain_restriction_enabled: bool,
                 identity_provider_id: str,
                 org_id: str,
                 post_auth_role_grants: Sequence[str],
                 role_mappings: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingResult'],
                 user_conflicts: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgUserConflictResult']):
        """
        :param Sequence[str] domain_allow_lists: List that contains the approved domains from which organization users can log in.
        :param bool domain_restriction_enabled: Flag that indicates whether domain restriction is enabled for the connected organization.
        :param str identity_provider_id: Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param Sequence[str] post_auth_role_grants: List that contains the default roles granted to users who authenticate through the IdP in a connected organization. If you provide a postAuthRoleGrants field in the request, the array that you provide replaces the current postAuthRoleGrants.
        """
        GetFederatedSettingsIdentityProvidersResultAssociatedOrgResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain_allow_lists=domain_allow_lists,
            domain_restriction_enabled=domain_restriction_enabled,
            identity_provider_id=identity_provider_id,
            org_id=org_id,
            post_auth_role_grants=post_auth_role_grants,
            role_mappings=role_mappings,
            user_conflicts=user_conflicts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain_allow_lists: Sequence[str],
             domain_restriction_enabled: bool,
             identity_provider_id: str,
             org_id: str,
             post_auth_role_grants: Sequence[str],
             role_mappings: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingResult'],
             user_conflicts: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgUserConflictResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("domain_allow_lists", domain_allow_lists)
        _setter("domain_restriction_enabled", domain_restriction_enabled)
        _setter("identity_provider_id", identity_provider_id)
        _setter("org_id", org_id)
        _setter("post_auth_role_grants", post_auth_role_grants)
        _setter("role_mappings", role_mappings)
        _setter("user_conflicts", user_conflicts)

    @property
    @pulumi.getter(name="domainAllowLists")
    def domain_allow_lists(self) -> Sequence[str]:
        """
        List that contains the approved domains from which organization users can log in.
        """
        return pulumi.get(self, "domain_allow_lists")

    @property
    @pulumi.getter(name="domainRestrictionEnabled")
    def domain_restriction_enabled(self) -> bool:
        """
        Flag that indicates whether domain restriction is enabled for the connected organization.
        """
        return pulumi.get(self, "domain_restriction_enabled")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter(name="postAuthRoleGrants")
    def post_auth_role_grants(self) -> Sequence[str]:
        """
        List that contains the default roles granted to users who authenticate through the IdP in a connected organization. If you provide a postAuthRoleGrants field in the request, the array that you provide replaces the current postAuthRoleGrants.
        """
        return pulumi.get(self, "post_auth_role_grants")

    @property
    @pulumi.getter(name="roleMappings")
    def role_mappings(self) -> Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingResult']:
        return pulumi.get(self, "role_mappings")

    @property
    @pulumi.getter(name="userConflicts")
    def user_conflicts(self) -> Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgUserConflictResult']:
        return pulumi.get(self, "user_conflicts")


@pulumi.output_type
class GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingResult(dict):
    def __init__(__self__, *,
                 external_group_name: str,
                 id: str,
                 role_assignments: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignmentResult']):
        """
        :param str external_group_name: Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        :param str id: Unique 24-hexadecimal digit string that identifies this role mapping.
        :param Sequence['GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignmentArgs'] role_assignments: Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            external_group_name=external_group_name,
            id=id,
            role_assignments=role_assignments,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             external_group_name: str,
             id: str,
             role_assignments: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignmentResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("external_group_name", external_group_name)
        _setter("id", id)
        _setter("role_assignments", role_assignments)

    @property
    @pulumi.getter(name="externalGroupName")
    def external_group_name(self) -> str:
        """
        Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        """
        return pulumi.get(self, "external_group_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies this role mapping.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="roleAssignments")
    def role_assignments(self) -> Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignmentResult']:
        """
        Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        return pulumi.get(self, "role_assignments")


@pulumi.output_type
class GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 group_id: str,
                 org_id: str,
                 role: str):
        """
        :param str group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param str role: Specifies the Role that is attached to the Role Mapping.
        """
        GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_id=group_id,
            org_id=org_id,
            role=role,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_id: str,
             org_id: str,
             role: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("group_id", group_id)
        _setter("org_id", org_id)
        _setter("role", role)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Specifies the Role that is attached to the Role Mapping.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetFederatedSettingsIdentityProvidersResultAssociatedOrgUserConflictResult(dict):
    def __init__(__self__, *,
                 email_address: str,
                 federation_settings_id: str,
                 first_name: str,
                 last_name: str,
                 user_id: str):
        """
        :param str email_address: Email address of the the user that conflicts with selected domains.
        :param str federation_settings_id: Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        :param str first_name: First name of the the user that conflicts with selected domains.
        :param str last_name: Last name of the the user that conflicts with selected domains.
        :param str user_id: Name of the Atlas user that conflicts with selected domains.
        """
        GetFederatedSettingsIdentityProvidersResultAssociatedOrgUserConflictResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            email_address=email_address,
            federation_settings_id=federation_settings_id,
            first_name=first_name,
            last_name=last_name,
            user_id=user_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             email_address: str,
             federation_settings_id: str,
             first_name: str,
             last_name: str,
             user_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("email_address", email_address)
        _setter("federation_settings_id", federation_settings_id)
        _setter("first_name", first_name)
        _setter("last_name", last_name)
        _setter("user_id", user_id)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> str:
        """
        Email address of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter(name="federationSettingsId")
    def federation_settings_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        """
        return pulumi.get(self, "federation_settings_id")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> str:
        """
        First name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> str:
        """
        Last name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        """
        Name of the Atlas user that conflicts with selected domains.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetFederatedSettingsIdentityProvidersResultPemFileInfoResult(dict):
    def __init__(__self__, *,
                 certificates: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultPemFileInfoCertificateResult'],
                 file_name: str):
        """
        :param str file_name: Filename of certificate
        """
        GetFederatedSettingsIdentityProvidersResultPemFileInfoResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificates=certificates,
            file_name=file_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificates: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultPemFileInfoCertificateResult'],
             file_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("certificates", certificates)
        _setter("file_name", file_name)

    @property
    @pulumi.getter
    def certificates(self) -> Sequence['outputs.GetFederatedSettingsIdentityProvidersResultPemFileInfoCertificateResult']:
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> str:
        """
        Filename of certificate
        """
        return pulumi.get(self, "file_name")


@pulumi.output_type
class GetFederatedSettingsIdentityProvidersResultPemFileInfoCertificateResult(dict):
    def __init__(__self__, *,
                 not_after: str,
                 not_before: str):
        """
        :param str not_after: Expiration  Date.
        :param str not_before: Start Date.
        """
        GetFederatedSettingsIdentityProvidersResultPemFileInfoCertificateResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            not_after=not_after,
            not_before=not_before,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             not_after: str,
             not_before: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("not_after", not_after)
        _setter("not_before", not_before)

    @property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> str:
        """
        Expiration  Date.
        """
        return pulumi.get(self, "not_after")

    @property
    @pulumi.getter(name="notBefore")
    def not_before(self) -> str:
        """
        Start Date.
        """
        return pulumi.get(self, "not_before")


@pulumi.output_type
class GetFederatedSettingsOrgConfigRoleMappingResult(dict):
    def __init__(__self__, *,
                 external_group_name: str,
                 id: str,
                 role_assignments: Sequence['outputs.GetFederatedSettingsOrgConfigRoleMappingRoleAssignmentResult']):
        """
        :param str external_group_name: Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        :param str id: Unique 24-hexadecimal digit string that identifies this role mapping.
        :param Sequence['GetFederatedSettingsOrgConfigRoleMappingRoleAssignmentArgs'] role_assignments: Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        GetFederatedSettingsOrgConfigRoleMappingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            external_group_name=external_group_name,
            id=id,
            role_assignments=role_assignments,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             external_group_name: str,
             id: str,
             role_assignments: Sequence['outputs.GetFederatedSettingsOrgConfigRoleMappingRoleAssignmentResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("external_group_name", external_group_name)
        _setter("id", id)
        _setter("role_assignments", role_assignments)

    @property
    @pulumi.getter(name="externalGroupName")
    def external_group_name(self) -> str:
        """
        Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        """
        return pulumi.get(self, "external_group_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies this role mapping.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="roleAssignments")
    def role_assignments(self) -> Sequence['outputs.GetFederatedSettingsOrgConfigRoleMappingRoleAssignmentResult']:
        """
        Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        return pulumi.get(self, "role_assignments")


@pulumi.output_type
class GetFederatedSettingsOrgConfigRoleMappingRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 group_id: str,
                 org_id: str,
                 role: str):
        """
        :param str group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param str role: Specifies the Role that is attached to the Role Mapping.
        """
        GetFederatedSettingsOrgConfigRoleMappingRoleAssignmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_id=group_id,
            org_id=org_id,
            role=role,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_id: str,
             org_id: str,
             role: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("group_id", group_id)
        _setter("org_id", org_id)
        _setter("role", role)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Specifies the Role that is attached to the Role Mapping.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetFederatedSettingsOrgConfigUserConflictResult(dict):
    def __init__(__self__, *,
                 email_address: str,
                 federation_settings_id: str,
                 first_name: str,
                 last_name: str,
                 user_id: str):
        """
        :param str email_address: Email address of the the user that conflicts with selected domains.
        :param str federation_settings_id: Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        :param str first_name: First name of the the user that conflicts with selected domains.
        :param str last_name: Last name of the the user that conflicts with selected domains.
        :param str user_id: Name of the Atlas user that conflicts with selected domains.
        """
        GetFederatedSettingsOrgConfigUserConflictResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            email_address=email_address,
            federation_settings_id=federation_settings_id,
            first_name=first_name,
            last_name=last_name,
            user_id=user_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             email_address: str,
             federation_settings_id: str,
             first_name: str,
             last_name: str,
             user_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("email_address", email_address)
        _setter("federation_settings_id", federation_settings_id)
        _setter("first_name", first_name)
        _setter("last_name", last_name)
        _setter("user_id", user_id)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> str:
        """
        Email address of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter(name="federationSettingsId")
    def federation_settings_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        """
        return pulumi.get(self, "federation_settings_id")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> str:
        """
        First name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> str:
        """
        Last name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        """
        Name of the Atlas user that conflicts with selected domains.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetFederatedSettingsOrgConfigsResultResult(dict):
    def __init__(__self__, *,
                 domain_allow_lists: Sequence[str],
                 domain_restriction_enabled: bool,
                 identity_provider_id: str,
                 org_id: str,
                 post_auth_role_grants: Sequence[str],
                 role_mappings: Sequence['outputs.GetFederatedSettingsOrgConfigsResultRoleMappingResult'],
                 user_conflicts: Sequence['outputs.GetFederatedSettingsOrgConfigsResultUserConflictResult']):
        """
        :param Sequence[str] domain_allow_lists: List that contains the approved domains from which organization users can log in.
        :param bool domain_restriction_enabled: Flag that indicates whether domain restriction is enabled for the connected organization.
        :param str identity_provider_id: Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param Sequence[str] post_auth_role_grants: List that contains the default roles granted to users who authenticate through the IdP in a connected organization.
        """
        GetFederatedSettingsOrgConfigsResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain_allow_lists=domain_allow_lists,
            domain_restriction_enabled=domain_restriction_enabled,
            identity_provider_id=identity_provider_id,
            org_id=org_id,
            post_auth_role_grants=post_auth_role_grants,
            role_mappings=role_mappings,
            user_conflicts=user_conflicts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain_allow_lists: Sequence[str],
             domain_restriction_enabled: bool,
             identity_provider_id: str,
             org_id: str,
             post_auth_role_grants: Sequence[str],
             role_mappings: Sequence['outputs.GetFederatedSettingsOrgConfigsResultRoleMappingResult'],
             user_conflicts: Sequence['outputs.GetFederatedSettingsOrgConfigsResultUserConflictResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("domain_allow_lists", domain_allow_lists)
        _setter("domain_restriction_enabled", domain_restriction_enabled)
        _setter("identity_provider_id", identity_provider_id)
        _setter("org_id", org_id)
        _setter("post_auth_role_grants", post_auth_role_grants)
        _setter("role_mappings", role_mappings)
        _setter("user_conflicts", user_conflicts)

    @property
    @pulumi.getter(name="domainAllowLists")
    def domain_allow_lists(self) -> Sequence[str]:
        """
        List that contains the approved domains from which organization users can log in.
        """
        return pulumi.get(self, "domain_allow_lists")

    @property
    @pulumi.getter(name="domainRestrictionEnabled")
    def domain_restriction_enabled(self) -> bool:
        """
        Flag that indicates whether domain restriction is enabled for the connected organization.
        """
        return pulumi.get(self, "domain_restriction_enabled")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter(name="postAuthRoleGrants")
    def post_auth_role_grants(self) -> Sequence[str]:
        """
        List that contains the default roles granted to users who authenticate through the IdP in a connected organization.
        """
        return pulumi.get(self, "post_auth_role_grants")

    @property
    @pulumi.getter(name="roleMappings")
    def role_mappings(self) -> Sequence['outputs.GetFederatedSettingsOrgConfigsResultRoleMappingResult']:
        return pulumi.get(self, "role_mappings")

    @property
    @pulumi.getter(name="userConflicts")
    def user_conflicts(self) -> Sequence['outputs.GetFederatedSettingsOrgConfigsResultUserConflictResult']:
        return pulumi.get(self, "user_conflicts")


@pulumi.output_type
class GetFederatedSettingsOrgConfigsResultRoleMappingResult(dict):
    def __init__(__self__, *,
                 external_group_name: str,
                 id: str,
                 role_assignments: Sequence['outputs.GetFederatedSettingsOrgConfigsResultRoleMappingRoleAssignmentResult']):
        """
        :param str external_group_name: Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        :param str id: Unique 24-hexadecimal digit string that identifies this role mapping.
        :param Sequence['GetFederatedSettingsOrgConfigsResultRoleMappingRoleAssignmentArgs'] role_assignments: Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        GetFederatedSettingsOrgConfigsResultRoleMappingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            external_group_name=external_group_name,
            id=id,
            role_assignments=role_assignments,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             external_group_name: str,
             id: str,
             role_assignments: Sequence['outputs.GetFederatedSettingsOrgConfigsResultRoleMappingRoleAssignmentResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("external_group_name", external_group_name)
        _setter("id", id)
        _setter("role_assignments", role_assignments)

    @property
    @pulumi.getter(name="externalGroupName")
    def external_group_name(self) -> str:
        """
        Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        """
        return pulumi.get(self, "external_group_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies this role mapping.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="roleAssignments")
    def role_assignments(self) -> Sequence['outputs.GetFederatedSettingsOrgConfigsResultRoleMappingRoleAssignmentResult']:
        """
        Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        return pulumi.get(self, "role_assignments")


@pulumi.output_type
class GetFederatedSettingsOrgConfigsResultRoleMappingRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 group_id: str,
                 org_id: str,
                 role: str):
        """
        :param str group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param str role: Specifies the Role that is attached to the Role Mapping.
        """
        GetFederatedSettingsOrgConfigsResultRoleMappingRoleAssignmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_id=group_id,
            org_id=org_id,
            role=role,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_id: str,
             org_id: str,
             role: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("group_id", group_id)
        _setter("org_id", org_id)
        _setter("role", role)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Specifies the Role that is attached to the Role Mapping.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetFederatedSettingsOrgConfigsResultUserConflictResult(dict):
    def __init__(__self__, *,
                 email_address: str,
                 federation_settings_id: str,
                 first_name: str,
                 last_name: str,
                 user_id: str):
        """
        :param str email_address: Email address of the the user that conflicts with selected domains.
        :param str federation_settings_id: Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        :param str first_name: First name of the the user that conflicts with selected domains.
        :param str last_name: Last name of the the user that conflicts with selected domains.
        :param str user_id: Name of the Atlas user that conflicts with selected domains.
        """
        GetFederatedSettingsOrgConfigsResultUserConflictResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            email_address=email_address,
            federation_settings_id=federation_settings_id,
            first_name=first_name,
            last_name=last_name,
            user_id=user_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             email_address: str,
             federation_settings_id: str,
             first_name: str,
             last_name: str,
             user_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("email_address", email_address)
        _setter("federation_settings_id", federation_settings_id)
        _setter("first_name", first_name)
        _setter("last_name", last_name)
        _setter("user_id", user_id)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> str:
        """
        Email address of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter(name="federationSettingsId")
    def federation_settings_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        """
        return pulumi.get(self, "federation_settings_id")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> str:
        """
        First name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> str:
        """
        Last name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        """
        Name of the Atlas user that conflicts with selected domains.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetFederatedSettingsOrgRoleMappingRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 group_id: str,
                 org_id: str,
                 role: str):
        """
        :param str group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param str role: Specifies the Role that is attached to the Role Mapping.
        """
        GetFederatedSettingsOrgRoleMappingRoleAssignmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_id=group_id,
            org_id=org_id,
            role=role,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_id: str,
             org_id: str,
             role: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("group_id", group_id)
        _setter("org_id", org_id)
        _setter("role", role)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Specifies the Role that is attached to the Role Mapping.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetFederatedSettingsOrgRoleMappingsResultResult(dict):
    def __init__(__self__, *,
                 external_group_name: str,
                 id: str,
                 role_assignments: Sequence['outputs.GetFederatedSettingsOrgRoleMappingsResultRoleAssignmentResult']):
        """
        :param str external_group_name: Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        :param str id: Unique 24-hexadecimal digit string that identifies this role mapping.
        :param Sequence['GetFederatedSettingsOrgRoleMappingsResultRoleAssignmentArgs'] role_assignments: Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        GetFederatedSettingsOrgRoleMappingsResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            external_group_name=external_group_name,
            id=id,
            role_assignments=role_assignments,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             external_group_name: str,
             id: str,
             role_assignments: Sequence['outputs.GetFederatedSettingsOrgRoleMappingsResultRoleAssignmentResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("external_group_name", external_group_name)
        _setter("id", id)
        _setter("role_assignments", role_assignments)

    @property
    @pulumi.getter(name="externalGroupName")
    def external_group_name(self) -> str:
        """
        Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        """
        return pulumi.get(self, "external_group_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies this role mapping.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="roleAssignments")
    def role_assignments(self) -> Sequence['outputs.GetFederatedSettingsOrgRoleMappingsResultRoleAssignmentResult']:
        """
        Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        return pulumi.get(self, "role_assignments")


@pulumi.output_type
class GetFederatedSettingsOrgRoleMappingsResultRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 group_id: str,
                 org_id: str,
                 role: str):
        """
        :param str group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param str role: Specifies the Role that is attached to the Role Mapping.
        """
        GetFederatedSettingsOrgRoleMappingsResultRoleAssignmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            group_id=group_id,
            org_id=org_id,
            role=role,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             group_id: str,
             org_id: str,
             role: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("group_id", group_id)
        _setter("org_id", org_id)
        _setter("role", role)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Specifies the Role that is attached to the Role Mapping.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetGlobalClusterConfigManagedNamespaceResult(dict):
    def __init__(__self__, *,
                 collection: str,
                 custom_shard_key: str,
                 db: str,
                 is_custom_shard_key_hashed: bool,
                 is_shard_key_unique: bool):
        """
        :param str collection: (Required) The name of the collection associated with the managed namespace.
        :param str custom_shard_key: (Required)	The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        :param str db: (Required) The name of the database containing the collection.
        :param bool is_custom_shard_key_hashed: Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.
        :param bool is_shard_key_unique: Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).
        """
        GetGlobalClusterConfigManagedNamespaceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            collection=collection,
            custom_shard_key=custom_shard_key,
            db=db,
            is_custom_shard_key_hashed=is_custom_shard_key_hashed,
            is_shard_key_unique=is_shard_key_unique,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             collection: str,
             custom_shard_key: str,
             db: str,
             is_custom_shard_key_hashed: bool,
             is_shard_key_unique: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("collection", collection)
        _setter("custom_shard_key", custom_shard_key)
        _setter("db", db)
        _setter("is_custom_shard_key_hashed", is_custom_shard_key_hashed)
        _setter("is_shard_key_unique", is_shard_key_unique)

    @property
    @pulumi.getter
    def collection(self) -> str:
        """
        (Required) The name of the collection associated with the managed namespace.
        """
        return pulumi.get(self, "collection")

    @property
    @pulumi.getter(name="customShardKey")
    def custom_shard_key(self) -> str:
        """
        (Required)	The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        """
        return pulumi.get(self, "custom_shard_key")

    @property
    @pulumi.getter
    def db(self) -> str:
        """
        (Required) The name of the database containing the collection.
        """
        return pulumi.get(self, "db")

    @property
    @pulumi.getter(name="isCustomShardKeyHashed")
    def is_custom_shard_key_hashed(self) -> bool:
        """
        Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.
        """
        return pulumi.get(self, "is_custom_shard_key_hashed")

    @property
    @pulumi.getter(name="isShardKeyUnique")
    def is_shard_key_unique(self) -> bool:
        """
        Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).
        """
        return pulumi.get(self, "is_shard_key_unique")


@pulumi.output_type
class GetLdapConfigurationUserToDnMappingResult(dict):
    def __init__(__self__, *,
                 ldap_query: str,
                 match: str,
                 substitution: str):
        GetLdapConfigurationUserToDnMappingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ldap_query=ldap_query,
            match=match,
            substitution=substitution,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ldap_query: str,
             match: str,
             substitution: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("ldap_query", ldap_query)
        _setter("match", match)
        _setter("substitution", substitution)

    @property
    @pulumi.getter(name="ldapQuery")
    def ldap_query(self) -> str:
        return pulumi.get(self, "ldap_query")

    @property
    @pulumi.getter
    def match(self) -> str:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def substitution(self) -> str:
        return pulumi.get(self, "substitution")


@pulumi.output_type
class GetLdapVerifyLinkResult(dict):
    def __init__(__self__, *,
                 href: str,
                 rel: str):
        GetLdapVerifyLinkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            href=href,
            rel=rel,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             href: str,
             rel: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("href", href)
        _setter("rel", rel)

    @property
    @pulumi.getter
    def href(self) -> str:
        return pulumi.get(self, "href")

    @property
    @pulumi.getter
    def rel(self) -> str:
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetLdapVerifyValidationResult(dict):
    def __init__(__self__, *,
                 status: str,
                 validation_type: str):
        """
        :param str status: The current status of the LDAP over TLS/SSL configuration.
        """
        GetLdapVerifyValidationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            status=status,
            validation_type=validation_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             status: str,
             validation_type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("status", status)
        _setter("validation_type", validation_type)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The current status of the LDAP over TLS/SSL configuration.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="validationType")
    def validation_type(self) -> str:
        return pulumi.get(self, "validation_type")


@pulumi.output_type
class GetNetworkContainersResultResult(dict):
    def __init__(__self__, *,
                 atlas_cidr_block: str,
                 azure_subscription_id: str,
                 gcp_project_id: str,
                 id: str,
                 network_name: str,
                 provider_name: str,
                 provisioned: bool,
                 region: str,
                 region_name: str,
                 regions: Sequence[str],
                 vnet_name: str,
                 vpc_id: str):
        """
        :param str atlas_cidr_block: CIDR block that Atlas uses for your clusters. Atlas uses the specified CIDR block for all other Network Peering connections created in the project. The Atlas CIDR block must be at least a /24 and at most a /21 in one of the following [private networks](https://tools.ietf.org/html/rfc1918.html#section-3).
        :param str azure_subscription_id: Unique identifer of the Azure subscription in which the VNet resides.
        :param str gcp_project_id: Unique identifier of the GCP project in which the Network Peering connection resides.
        :param str id: The Network Peering Container ID.
        :param str network_name: Name of the Network Peering connection in the Atlas project.
        :param str provider_name: Cloud provider for this Network peering container. Accepted values are AWS, GCP, and Azure.
        :param bool provisioned: Indicates whether the project has Network Peering connections deployed in the container.
        :param str region: The Atlas Azure region name for where this container exists.
        :param str region_name: The Atlas AWS region name for where this container exists.
        :param Sequence[str] regions: Atlas GCP regions where the container resides.
        :param str vnet_name: The name of the Azure VNet. This value is null until you provision an Azure VNet in the container.
        :param str vpc_id: Unique identifier of the project’s VPC.
        """
        GetNetworkContainersResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            atlas_cidr_block=atlas_cidr_block,
            azure_subscription_id=azure_subscription_id,
            gcp_project_id=gcp_project_id,
            id=id,
            network_name=network_name,
            provider_name=provider_name,
            provisioned=provisioned,
            region=region,
            region_name=region_name,
            regions=regions,
            vnet_name=vnet_name,
            vpc_id=vpc_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             atlas_cidr_block: str,
             azure_subscription_id: str,
             gcp_project_id: str,
             id: str,
             network_name: str,
             provider_name: str,
             provisioned: bool,
             region: str,
             region_name: str,
             regions: Sequence[str],
             vnet_name: str,
             vpc_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("atlas_cidr_block", atlas_cidr_block)
        _setter("azure_subscription_id", azure_subscription_id)
        _setter("gcp_project_id", gcp_project_id)
        _setter("id", id)
        _setter("network_name", network_name)
        _setter("provider_name", provider_name)
        _setter("provisioned", provisioned)
        _setter("region", region)
        _setter("region_name", region_name)
        _setter("regions", regions)
        _setter("vnet_name", vnet_name)
        _setter("vpc_id", vpc_id)

    @property
    @pulumi.getter(name="atlasCidrBlock")
    def atlas_cidr_block(self) -> str:
        """
        CIDR block that Atlas uses for your clusters. Atlas uses the specified CIDR block for all other Network Peering connections created in the project. The Atlas CIDR block must be at least a /24 and at most a /21 in one of the following [private networks](https://tools.ietf.org/html/rfc1918.html#section-3).
        """
        return pulumi.get(self, "atlas_cidr_block")

    @property
    @pulumi.getter(name="azureSubscriptionId")
    def azure_subscription_id(self) -> str:
        """
        Unique identifer of the Azure subscription in which the VNet resides.
        """
        return pulumi.get(self, "azure_subscription_id")

    @property
    @pulumi.getter(name="gcpProjectId")
    def gcp_project_id(self) -> str:
        """
        Unique identifier of the GCP project in which the Network Peering connection resides.
        """
        return pulumi.get(self, "gcp_project_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The Network Peering Container ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="networkName")
    def network_name(self) -> str:
        """
        Name of the Network Peering connection in the Atlas project.
        """
        return pulumi.get(self, "network_name")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Cloud provider for this Network peering container. Accepted values are AWS, GCP, and Azure.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def provisioned(self) -> bool:
        """
        Indicates whether the project has Network Peering connections deployed in the container.
        """
        return pulumi.get(self, "provisioned")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The Atlas Azure region name for where this container exists.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        The Atlas AWS region name for where this container exists.
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter
    def regions(self) -> Sequence[str]:
        """
        Atlas GCP regions where the container resides.
        """
        return pulumi.get(self, "regions")

    @property
    @pulumi.getter(name="vnetName")
    def vnet_name(self) -> str:
        """
        The name of the Azure VNet. This value is null until you provision an Azure VNet in the container.
        """
        return pulumi.get(self, "vnet_name")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        Unique identifier of the project’s VPC.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetNetworkPeeringsResultResult(dict):
    def __init__(__self__, *,
                 accepter_region_name: str,
                 atlas_cidr_block: str,
                 aws_account_id: str,
                 azure_directory_id: str,
                 azure_subscription_id: str,
                 connection_id: str,
                 container_id: str,
                 error_message: str,
                 error_state: str,
                 error_state_name: str,
                 gcp_project_id: str,
                 network_name: str,
                 peering_id: str,
                 provider_name: str,
                 resource_group_name: str,
                 route_table_cidr_block: str,
                 status: str,
                 status_name: str,
                 vnet_name: str,
                 vpc_id: str):
        """
        :param str accepter_region_name: Specifies the region where the peer VPC resides. For complete lists of supported regions, see [Amazon Web Services](https://docs.atlas.mongodb.com/reference/amazon-aws/).
        :param str aws_account_id: Account ID of the owner of the peer VPC.
        :param str azure_directory_id: Unique identifier for an Azure AD directory.
        :param str azure_subscription_id: Unique identifer of the Azure subscription in which the VNet resides.
        :param str connection_id: Unique identifier for the peering connection.
        :param str error_message: When `"status" : "FAILED"`, Atlas provides a description of the error.
        :param str error_state: Description of the Atlas error when `status` is `Failed`, Otherwise, Atlas returns `null`.
        :param str error_state_name: Error state, if any. The VPC peering connection error state value can be one of the following: `REJECTED`, `EXPIRED`, `INVALID_ARGUMENT`.
        :param str gcp_project_id: GCP project ID of the owner of the network peer.
        :param str network_name: Name of the network peer to which Atlas connects.
        :param str peering_id: Atlas assigned unique ID for the peering connection.
        :param str provider_name: Cloud provider for this VPC peering connection. If omitted, Atlas sets this parameter to AWS. (Possible Values `AWS`, `AZURE`, `GCP`).
        :param str resource_group_name: Name of your Azure resource group.
        :param str route_table_cidr_block: Peer VPC CIDR block or subnet.
        :param str status: Status of the Atlas network peering connection: `ADDING_PEER`, `AVAILABLE`, `FAILED`, `DELETING`, `WAITING_FOR_USER`.
        :param str status_name: The VPC peering connection status value can be one of the following: `INITIATING`, `PENDING_ACCEPTANCE`, `FAILED`, `FINALIZING`, `AVAILABLE`, `TERMINATING`.
        :param str vnet_name: Name of your Azure VNet.
        :param str vpc_id: Unique identifier of the peer VPC.
        """
        GetNetworkPeeringsResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            accepter_region_name=accepter_region_name,
            atlas_cidr_block=atlas_cidr_block,
            aws_account_id=aws_account_id,
            azure_directory_id=azure_directory_id,
            azure_subscription_id=azure_subscription_id,
            connection_id=connection_id,
            container_id=container_id,
            error_message=error_message,
            error_state=error_state,
            error_state_name=error_state_name,
            gcp_project_id=gcp_project_id,
            network_name=network_name,
            peering_id=peering_id,
            provider_name=provider_name,
            resource_group_name=resource_group_name,
            route_table_cidr_block=route_table_cidr_block,
            status=status,
            status_name=status_name,
            vnet_name=vnet_name,
            vpc_id=vpc_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             accepter_region_name: str,
             atlas_cidr_block: str,
             aws_account_id: str,
             azure_directory_id: str,
             azure_subscription_id: str,
             connection_id: str,
             container_id: str,
             error_message: str,
             error_state: str,
             error_state_name: str,
             gcp_project_id: str,
             network_name: str,
             peering_id: str,
             provider_name: str,
             resource_group_name: str,
             route_table_cidr_block: str,
             status: str,
             status_name: str,
             vnet_name: str,
             vpc_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("accepter_region_name", accepter_region_name)
        _setter("atlas_cidr_block", atlas_cidr_block)
        _setter("aws_account_id", aws_account_id)
        _setter("azure_directory_id", azure_directory_id)
        _setter("azure_subscription_id", azure_subscription_id)
        _setter("connection_id", connection_id)
        _setter("container_id", container_id)
        _setter("error_message", error_message)
        _setter("error_state", error_state)
        _setter("error_state_name", error_state_name)
        _setter("gcp_project_id", gcp_project_id)
        _setter("network_name", network_name)
        _setter("peering_id", peering_id)
        _setter("provider_name", provider_name)
        _setter("resource_group_name", resource_group_name)
        _setter("route_table_cidr_block", route_table_cidr_block)
        _setter("status", status)
        _setter("status_name", status_name)
        _setter("vnet_name", vnet_name)
        _setter("vpc_id", vpc_id)

    @property
    @pulumi.getter(name="accepterRegionName")
    def accepter_region_name(self) -> str:
        """
        Specifies the region where the peer VPC resides. For complete lists of supported regions, see [Amazon Web Services](https://docs.atlas.mongodb.com/reference/amazon-aws/).
        """
        return pulumi.get(self, "accepter_region_name")

    @property
    @pulumi.getter(name="atlasCidrBlock")
    def atlas_cidr_block(self) -> str:
        return pulumi.get(self, "atlas_cidr_block")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> str:
        """
        Account ID of the owner of the peer VPC.
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="azureDirectoryId")
    def azure_directory_id(self) -> str:
        """
        Unique identifier for an Azure AD directory.
        """
        return pulumi.get(self, "azure_directory_id")

    @property
    @pulumi.getter(name="azureSubscriptionId")
    def azure_subscription_id(self) -> str:
        """
        Unique identifer of the Azure subscription in which the VNet resides.
        """
        return pulumi.get(self, "azure_subscription_id")

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> str:
        """
        Unique identifier for the peering connection.
        """
        return pulumi.get(self, "connection_id")

    @property
    @pulumi.getter(name="containerId")
    def container_id(self) -> str:
        return pulumi.get(self, "container_id")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> str:
        """
        When `"status" : "FAILED"`, Atlas provides a description of the error.
        """
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter(name="errorState")
    def error_state(self) -> str:
        """
        Description of the Atlas error when `status` is `Failed`, Otherwise, Atlas returns `null`.
        """
        return pulumi.get(self, "error_state")

    @property
    @pulumi.getter(name="errorStateName")
    def error_state_name(self) -> str:
        """
        Error state, if any. The VPC peering connection error state value can be one of the following: `REJECTED`, `EXPIRED`, `INVALID_ARGUMENT`.
        """
        return pulumi.get(self, "error_state_name")

    @property
    @pulumi.getter(name="gcpProjectId")
    def gcp_project_id(self) -> str:
        """
        GCP project ID of the owner of the network peer.
        """
        return pulumi.get(self, "gcp_project_id")

    @property
    @pulumi.getter(name="networkName")
    def network_name(self) -> str:
        """
        Name of the network peer to which Atlas connects.
        """
        return pulumi.get(self, "network_name")

    @property
    @pulumi.getter(name="peeringId")
    def peering_id(self) -> str:
        """
        Atlas assigned unique ID for the peering connection.
        """
        return pulumi.get(self, "peering_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Cloud provider for this VPC peering connection. If omitted, Atlas sets this parameter to AWS. (Possible Values `AWS`, `AZURE`, `GCP`).
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> str:
        """
        Name of your Azure resource group.
        """
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter(name="routeTableCidrBlock")
    def route_table_cidr_block(self) -> str:
        """
        Peer VPC CIDR block or subnet.
        """
        return pulumi.get(self, "route_table_cidr_block")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the Atlas network peering connection: `ADDING_PEER`, `AVAILABLE`, `FAILED`, `DELETING`, `WAITING_FOR_USER`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="statusName")
    def status_name(self) -> str:
        """
        The VPC peering connection status value can be one of the following: `INITIATING`, `PENDING_ACCEPTANCE`, `FAILED`, `FINALIZING`, `AVAILABLE`, `TERMINATING`.
        """
        return pulumi.get(self, "status_name")

    @property
    @pulumi.getter(name="vnetName")
    def vnet_name(self) -> str:
        """
        Name of your Azure VNet.
        """
        return pulumi.get(self, "vnet_name")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        Unique identifier of the peer VPC.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetOnlineArchiveCriteriaResult(dict):
    def __init__(__self__, *,
                 date_field: str,
                 date_format: str,
                 expire_after_days: int,
                 query: str,
                 type: str):
        GetOnlineArchiveCriteriaResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_field=date_field,
            date_format=date_format,
            expire_after_days=expire_after_days,
            query=query,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_field: str,
             date_format: str,
             expire_after_days: int,
             query: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("date_field", date_field)
        _setter("date_format", date_format)
        _setter("expire_after_days", expire_after_days)
        _setter("query", query)
        _setter("type", type)

    @property
    @pulumi.getter(name="dateField")
    def date_field(self) -> str:
        return pulumi.get(self, "date_field")

    @property
    @pulumi.getter(name="dateFormat")
    def date_format(self) -> str:
        return pulumi.get(self, "date_format")

    @property
    @pulumi.getter(name="expireAfterDays")
    def expire_after_days(self) -> int:
        return pulumi.get(self, "expire_after_days")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetOnlineArchivePartitionFieldResult(dict):
    def __init__(__self__, *,
                 field_name: str,
                 field_type: str,
                 order: int):
        GetOnlineArchivePartitionFieldResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_name=field_name,
            field_type=field_type,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_name: str,
             field_type: str,
             order: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_name", field_name)
        _setter("field_type", field_type)
        _setter("order", order)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> str:
        return pulumi.get(self, "field_type")

    @property
    @pulumi.getter
    def order(self) -> int:
        return pulumi.get(self, "order")


@pulumi.output_type
class GetOnlineArchiveScheduleResult(dict):
    def __init__(__self__, *,
                 end_hour: int,
                 end_minute: int,
                 start_hour: int,
                 start_minute: int,
                 type: str,
                 day_of_month: Optional[int] = None,
                 day_of_week: Optional[int] = None):
        GetOnlineArchiveScheduleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end_hour=end_hour,
            end_minute=end_minute,
            start_hour=start_hour,
            start_minute=start_minute,
            type=type,
            day_of_month=day_of_month,
            day_of_week=day_of_week,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end_hour: int,
             end_minute: int,
             start_hour: int,
             start_minute: int,
             type: str,
             day_of_month: Optional[int] = None,
             day_of_week: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("end_hour", end_hour)
        _setter("end_minute", end_minute)
        _setter("start_hour", start_hour)
        _setter("start_minute", start_minute)
        _setter("type", type)
        if day_of_month is not None:
            _setter("day_of_month", day_of_month)
        if day_of_week is not None:
            _setter("day_of_week", day_of_week)

    @property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> int:
        return pulumi.get(self, "end_hour")

    @property
    @pulumi.getter(name="endMinute")
    def end_minute(self) -> int:
        return pulumi.get(self, "end_minute")

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> int:
        return pulumi.get(self, "start_hour")

    @property
    @pulumi.getter(name="startMinute")
    def start_minute(self) -> int:
        return pulumi.get(self, "start_minute")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[int]:
        return pulumi.get(self, "day_of_month")

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[int]:
        return pulumi.get(self, "day_of_week")


@pulumi.output_type
class GetOnlineArchivesResultResult(dict):
    def __init__(__self__, *,
                 archive_id: str,
                 cluster_name: str,
                 coll_name: str,
                 collection_type: str,
                 criterias: Sequence['outputs.GetOnlineArchivesResultCriteriaResult'],
                 db_name: str,
                 partition_fields: Sequence['outputs.GetOnlineArchivesResultPartitionFieldResult'],
                 paused: bool,
                 project_id: str,
                 schedules: Sequence['outputs.GetOnlineArchivesResultScheduleResult'],
                 state: str):
        """
        :param str cluster_name: Name of the cluster that contains the collection.
               
               # Attributes Reference
               
               In addition to all arguments above, the following attributes are exported:
        :param str project_id: The unique ID for the project.
        """
        GetOnlineArchivesResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            archive_id=archive_id,
            cluster_name=cluster_name,
            coll_name=coll_name,
            collection_type=collection_type,
            criterias=criterias,
            db_name=db_name,
            partition_fields=partition_fields,
            paused=paused,
            project_id=project_id,
            schedules=schedules,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             archive_id: str,
             cluster_name: str,
             coll_name: str,
             collection_type: str,
             criterias: Sequence['outputs.GetOnlineArchivesResultCriteriaResult'],
             db_name: str,
             partition_fields: Sequence['outputs.GetOnlineArchivesResultPartitionFieldResult'],
             paused: bool,
             project_id: str,
             schedules: Sequence['outputs.GetOnlineArchivesResultScheduleResult'],
             state: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("archive_id", archive_id)
        _setter("cluster_name", cluster_name)
        _setter("coll_name", coll_name)
        _setter("collection_type", collection_type)
        _setter("criterias", criterias)
        _setter("db_name", db_name)
        _setter("partition_fields", partition_fields)
        _setter("paused", paused)
        _setter("project_id", project_id)
        _setter("schedules", schedules)
        _setter("state", state)

    @property
    @pulumi.getter(name="archiveId")
    def archive_id(self) -> str:
        return pulumi.get(self, "archive_id")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        Name of the cluster that contains the collection.

        # Attributes Reference

        In addition to all arguments above, the following attributes are exported:
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="collName")
    def coll_name(self) -> str:
        return pulumi.get(self, "coll_name")

    @property
    @pulumi.getter(name="collectionType")
    def collection_type(self) -> str:
        return pulumi.get(self, "collection_type")

    @property
    @pulumi.getter
    def criterias(self) -> Sequence['outputs.GetOnlineArchivesResultCriteriaResult']:
        return pulumi.get(self, "criterias")

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> str:
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="partitionFields")
    def partition_fields(self) -> Sequence['outputs.GetOnlineArchivesResultPartitionFieldResult']:
        return pulumi.get(self, "partition_fields")

    @property
    @pulumi.getter
    def paused(self) -> bool:
        return pulumi.get(self, "paused")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.GetOnlineArchivesResultScheduleResult']:
        return pulumi.get(self, "schedules")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")


@pulumi.output_type
class GetOnlineArchivesResultCriteriaResult(dict):
    def __init__(__self__, *,
                 date_field: str,
                 date_format: str,
                 expire_after_days: int,
                 query: str,
                 type: str):
        GetOnlineArchivesResultCriteriaResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            date_field=date_field,
            date_format=date_format,
            expire_after_days=expire_after_days,
            query=query,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             date_field: str,
             date_format: str,
             expire_after_days: int,
             query: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("date_field", date_field)
        _setter("date_format", date_format)
        _setter("expire_after_days", expire_after_days)
        _setter("query", query)
        _setter("type", type)

    @property
    @pulumi.getter(name="dateField")
    def date_field(self) -> str:
        return pulumi.get(self, "date_field")

    @property
    @pulumi.getter(name="dateFormat")
    def date_format(self) -> str:
        return pulumi.get(self, "date_format")

    @property
    @pulumi.getter(name="expireAfterDays")
    def expire_after_days(self) -> int:
        return pulumi.get(self, "expire_after_days")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetOnlineArchivesResultPartitionFieldResult(dict):
    def __init__(__self__, *,
                 field_name: str,
                 field_type: str,
                 order: int):
        GetOnlineArchivesResultPartitionFieldResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field_name=field_name,
            field_type=field_type,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field_name: str,
             field_type: str,
             order: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field_name", field_name)
        _setter("field_type", field_type)
        _setter("order", order)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> str:
        return pulumi.get(self, "field_type")

    @property
    @pulumi.getter
    def order(self) -> int:
        return pulumi.get(self, "order")


@pulumi.output_type
class GetOnlineArchivesResultScheduleResult(dict):
    def __init__(__self__, *,
                 end_hour: int,
                 end_minute: int,
                 start_hour: int,
                 start_minute: int,
                 type: str,
                 day_of_month: Optional[int] = None,
                 day_of_week: Optional[int] = None):
        GetOnlineArchivesResultScheduleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end_hour=end_hour,
            end_minute=end_minute,
            start_hour=start_hour,
            start_minute=start_minute,
            type=type,
            day_of_month=day_of_month,
            day_of_week=day_of_week,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end_hour: int,
             end_minute: int,
             start_hour: int,
             start_minute: int,
             type: str,
             day_of_month: Optional[int] = None,
             day_of_week: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("end_hour", end_hour)
        _setter("end_minute", end_minute)
        _setter("start_hour", start_hour)
        _setter("start_minute", start_minute)
        _setter("type", type)
        if day_of_month is not None:
            _setter("day_of_month", day_of_month)
        if day_of_week is not None:
            _setter("day_of_week", day_of_week)

    @property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> int:
        return pulumi.get(self, "end_hour")

    @property
    @pulumi.getter(name="endMinute")
    def end_minute(self) -> int:
        return pulumi.get(self, "end_minute")

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> int:
        return pulumi.get(self, "start_hour")

    @property
    @pulumi.getter(name="startMinute")
    def start_minute(self) -> int:
        return pulumi.get(self, "start_minute")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[int]:
        return pulumi.get(self, "day_of_month")

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[int]:
        return pulumi.get(self, "day_of_week")


@pulumi.output_type
class GetOrganizationLinkResult(dict):
    def __init__(__self__, *,
                 href: str,
                 rel: str):
        GetOrganizationLinkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            href=href,
            rel=rel,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             href: str,
             rel: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("href", href)
        _setter("rel", rel)

    @property
    @pulumi.getter
    def href(self) -> str:
        return pulumi.get(self, "href")

    @property
    @pulumi.getter
    def rel(self) -> str:
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetOrganizationsResultResult(dict):
    def __init__(__self__, *,
                 id: str,
                 is_deleted: bool,
                 links: Sequence['outputs.GetOrganizationsResultLinkResult'],
                 name: str):
        """
        :param str id: Autogenerated Unique ID for this data source.
        :param bool is_deleted: Flag that indicates whether this organization has been deleted.
               
               See [MongoDB Atlas API - Organizations](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Organizations/operation/listOrganizations)  Documentation for more information.
        :param str name: Human-readable label that identifies the organization.
        """
        GetOrganizationsResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            is_deleted=is_deleted,
            links=links,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             is_deleted: bool,
             links: Sequence['outputs.GetOrganizationsResultLinkResult'],
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("is_deleted", is_deleted)
        _setter("links", links)
        _setter("name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Autogenerated Unique ID for this data source.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isDeleted")
    def is_deleted(self) -> bool:
        """
        Flag that indicates whether this organization has been deleted.

        See [MongoDB Atlas API - Organizations](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Organizations/operation/listOrganizations)  Documentation for more information.
        """
        return pulumi.get(self, "is_deleted")

    @property
    @pulumi.getter
    def links(self) -> Sequence['outputs.GetOrganizationsResultLinkResult']:
        return pulumi.get(self, "links")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Human-readable label that identifies the organization.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetOrganizationsResultLinkResult(dict):
    def __init__(__self__, *,
                 href: str,
                 rel: str):
        GetOrganizationsResultLinkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            href=href,
            rel=rel,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             href: str,
             rel: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("href", href)
        _setter("rel", rel)

    @property
    @pulumi.getter
    def href(self) -> str:
        return pulumi.get(self, "href")

    @property
    @pulumi.getter
    def rel(self) -> str:
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetPrivateLinkEndpointServiceEndpointResult(dict):
    def __init__(__self__, *,
                 endpoint_name: str,
                 ip_address: str,
                 service_attachment_name: str,
                 status: str):
        """
        :param str endpoint_name: Forwarding rule that corresponds to the endpoint you created in GCP.
        :param str ip_address: Private IP address of the network endpoint group you created in GCP.
        :param str service_attachment_name: Unique alphanumeric and special character strings that identify the service attachment associated with the endpoint.
        :param str status: Status of the endpoint. Atlas returns one of the [values shown above](https://docs.atlas.mongodb.com/reference/api/private-endpoints-endpoint-create-one/#std-label-ref-status-field).
        """
        GetPrivateLinkEndpointServiceEndpointResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_name=endpoint_name,
            ip_address=ip_address,
            service_attachment_name=service_attachment_name,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_name: str,
             ip_address: str,
             service_attachment_name: str,
             status: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("endpoint_name", endpoint_name)
        _setter("ip_address", ip_address)
        _setter("service_attachment_name", service_attachment_name)
        _setter("status", status)

    @property
    @pulumi.getter(name="endpointName")
    def endpoint_name(self) -> str:
        """
        Forwarding rule that corresponds to the endpoint you created in GCP.
        """
        return pulumi.get(self, "endpoint_name")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        Private IP address of the network endpoint group you created in GCP.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="serviceAttachmentName")
    def service_attachment_name(self) -> str:
        """
        Unique alphanumeric and special character strings that identify the service attachment associated with the endpoint.
        """
        return pulumi.get(self, "service_attachment_name")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the endpoint. Atlas returns one of the [values shown above](https://docs.atlas.mongodb.com/reference/api/private-endpoints-endpoint-create-one/#std-label-ref-status-field).
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetPrivatelinkEndpointServiceDataFederationOnlineArchivesResultResult(dict):
    def __init__(__self__, *,
                 comment: str,
                 endpoint_id: str,
                 provider_name: str,
                 type: str):
        """
        :param str comment: Human-readable string to associate with this private endpoint.
        :param str endpoint_id: Unique 22-character alphanumeric string that identifies the private endpoint. See [Atlas Data Lake supports Amazon Web Services private endpoints using the AWS PrivateLink feature](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation/operation/createDataFederationPrivateEndpoint:~:text=Atlas%20Data%20Lake%20supports%20Amazon%20Web%20Services%20private%20endpoints%20using%20the%20AWS%20PrivateLink%20feature).
        :param str provider_name: Human-readable label that identifies the cloud service provider.
        :param str type: Human-readable label that identifies the resource type associated with this private endpoint.
        """
        GetPrivatelinkEndpointServiceDataFederationOnlineArchivesResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comment=comment,
            endpoint_id=endpoint_id,
            provider_name=provider_name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comment: str,
             endpoint_id: str,
             provider_name: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("comment", comment)
        _setter("endpoint_id", endpoint_id)
        _setter("provider_name", provider_name)
        _setter("type", type)

    @property
    @pulumi.getter
    def comment(self) -> str:
        """
        Human-readable string to associate with this private endpoint.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> str:
        """
        Unique 22-character alphanumeric string that identifies the private endpoint. See [Atlas Data Lake supports Amazon Web Services private endpoints using the AWS PrivateLink feature](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation/operation/createDataFederationPrivateEndpoint:~:text=Atlas%20Data%20Lake%20supports%20Amazon%20Web%20Services%20private%20endpoints%20using%20the%20AWS%20PrivateLink%20feature).
        """
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Human-readable label that identifies the cloud service provider.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Human-readable label that identifies the resource type associated with this private endpoint.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetPrivatelinkEndpointsServiceAdlLinkResult(dict):
    def __init__(__self__, *,
                 href: str,
                 rel: str):
        GetPrivatelinkEndpointsServiceAdlLinkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            href=href,
            rel=rel,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             href: str,
             rel: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("href", href)
        _setter("rel", rel)

    @property
    @pulumi.getter
    def href(self) -> str:
        return pulumi.get(self, "href")

    @property
    @pulumi.getter
    def rel(self) -> str:
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetPrivatelinkEndpointsServiceAdlResultResult(dict):
    def __init__(__self__, *,
                 comment: str,
                 endpoint_id: str,
                 provider_name: str,
                 type: str):
        """
        :param str comment: Human-readable string to associate with this private endpoint.
               
               See [MongoDB Atlas API](https://docs.atlas.mongodb.com/reference/api/online-archive-get-all-for-cluster/) Documentation for more information.
        :param str endpoint_id: Unique 22-character alphanumeric string that identifies the private endpoint. Atlas supports AWS private endpoints using the [|aws| PrivateLink](https://aws.amazon.com/privatelink/) feature.
        :param str provider_name: Human-readable label that identifies the cloud provider for this endpoint.
        :param str type: Human-readable label that identifies the type of resource to associate with this private endpoint.
        """
        GetPrivatelinkEndpointsServiceAdlResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comment=comment,
            endpoint_id=endpoint_id,
            provider_name=provider_name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comment: str,
             endpoint_id: str,
             provider_name: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("comment", comment)
        _setter("endpoint_id", endpoint_id)
        _setter("provider_name", provider_name)
        _setter("type", type)

    @property
    @pulumi.getter
    def comment(self) -> str:
        """
        Human-readable string to associate with this private endpoint.

        See [MongoDB Atlas API](https://docs.atlas.mongodb.com/reference/api/online-archive-get-all-for-cluster/) Documentation for more information.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> str:
        """
        Unique 22-character alphanumeric string that identifies the private endpoint. Atlas supports AWS private endpoints using the [|aws| PrivateLink](https://aws.amazon.com/privatelink/) feature.
        """
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Human-readable label that identifies the cloud provider for this endpoint.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Human-readable label that identifies the type of resource to associate with this private endpoint.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetPrivatelinkEndpointsServiceServerlessResultResult(dict):
    def __init__(__self__, *,
                 cloud_provider_endpoint_id: str,
                 comment: str,
                 endpoint_id: str,
                 endpoint_service_name: str,
                 error_message: str,
                 private_endpoint_ip_address: str,
                 private_link_service_resource_id: str,
                 status: str):
        """
        :param str cloud_provider_endpoint_id: Unique string that identifies the private endpoint's network interface.
        :param str comment: Human-readable string to associate with this private endpoint.
        :param str endpoint_id: (Required) Unique 22-character alphanumeric string that identifies the private endpoint. Atlas supports AWS private endpoints using the [AWS PrivateLink](https://aws.amazon.com/privatelink/) feature.
        :param str endpoint_service_name: Unique string that identifies the PrivateLink endpoint service. MongoDB Cloud returns null while it creates the endpoint service.
        :param str private_endpoint_ip_address: IPv4 address of the private endpoint in your Azure VNet that someone added to this private endpoint service.
        :param str private_link_service_resource_id: Root-relative path that identifies the Azure Private Link Service that MongoDB Cloud manages.
        :param str status: Human-readable label that indicates the current operating status of the private endpoint. Values include: RESERVATION_REQUESTED, RESERVED, INITIATING, AVAILABLE, FAILED, DELETING.
        """
        GetPrivatelinkEndpointsServiceServerlessResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_provider_endpoint_id=cloud_provider_endpoint_id,
            comment=comment,
            endpoint_id=endpoint_id,
            endpoint_service_name=endpoint_service_name,
            error_message=error_message,
            private_endpoint_ip_address=private_endpoint_ip_address,
            private_link_service_resource_id=private_link_service_resource_id,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_provider_endpoint_id: str,
             comment: str,
             endpoint_id: str,
             endpoint_service_name: str,
             error_message: str,
             private_endpoint_ip_address: str,
             private_link_service_resource_id: str,
             status: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cloud_provider_endpoint_id", cloud_provider_endpoint_id)
        _setter("comment", comment)
        _setter("endpoint_id", endpoint_id)
        _setter("endpoint_service_name", endpoint_service_name)
        _setter("error_message", error_message)
        _setter("private_endpoint_ip_address", private_endpoint_ip_address)
        _setter("private_link_service_resource_id", private_link_service_resource_id)
        _setter("status", status)

    @property
    @pulumi.getter(name="cloudProviderEndpointId")
    def cloud_provider_endpoint_id(self) -> str:
        """
        Unique string that identifies the private endpoint's network interface.
        """
        return pulumi.get(self, "cloud_provider_endpoint_id")

    @property
    @pulumi.getter
    def comment(self) -> str:
        """
        Human-readable string to associate with this private endpoint.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> str:
        """
        (Required) Unique 22-character alphanumeric string that identifies the private endpoint. Atlas supports AWS private endpoints using the [AWS PrivateLink](https://aws.amazon.com/privatelink/) feature.
        """
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="endpointServiceName")
    def endpoint_service_name(self) -> str:
        """
        Unique string that identifies the PrivateLink endpoint service. MongoDB Cloud returns null while it creates the endpoint service.
        """
        return pulumi.get(self, "endpoint_service_name")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> str:
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter(name="privateEndpointIpAddress")
    def private_endpoint_ip_address(self) -> str:
        """
        IPv4 address of the private endpoint in your Azure VNet that someone added to this private endpoint service.
        """
        return pulumi.get(self, "private_endpoint_ip_address")

    @property
    @pulumi.getter(name="privateLinkServiceResourceId")
    def private_link_service_resource_id(self) -> str:
        """
        Root-relative path that identifies the Azure Private Link Service that MongoDB Cloud manages.
        """
        return pulumi.get(self, "private_link_service_resource_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Human-readable label that indicates the current operating status of the private endpoint. Values include: RESERVATION_REQUESTED, RESERVED, INITIATING, AVAILABLE, FAILED, DELETING.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetProjectApiKeyProjectAssignmentResult(dict):
    def __init__(__self__, *,
                 project_id: str,
                 role_names: Sequence[str]):
        """
        :param str project_id: The unique ID for the project.
        :param Sequence[str] role_names: List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project. You must specify an array even if you are only associating a single role with the Programmatic API key. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) describes the valid roles that can be assigned.
        """
        GetProjectApiKeyProjectAssignmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            project_id=project_id,
            role_names=role_names,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             project_id: str,
             role_names: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("project_id", project_id)
        _setter("role_names", role_names)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[str]:
        """
        List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project. You must specify an array even if you are only associating a single role with the Programmatic API key. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) describes the valid roles that can be assigned.
        """
        return pulumi.get(self, "role_names")


@pulumi.output_type
class GetProjectApiKeysResultResult(dict):
    def __init__(__self__, *,
                 api_key_id: str,
                 description: str,
                 private_key: str,
                 public_key: str,
                 project_assignments: Optional[Sequence['outputs.GetProjectApiKeysResultProjectAssignmentResult']] = None):
        """
        :param str api_key_id: Unique identifier for the API key you want to update. Use the /orgs/{ORG-ID}/apiKeys endpoint to retrieve all API keys to which the authenticated user has access for the specified organization.
        :param str description: Description of this Project API key.
        """
        GetProjectApiKeysResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            api_key_id=api_key_id,
            description=description,
            private_key=private_key,
            public_key=public_key,
            project_assignments=project_assignments,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             api_key_id: str,
             description: str,
             private_key: str,
             public_key: str,
             project_assignments: Optional[Sequence['outputs.GetProjectApiKeysResultProjectAssignmentResult']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("api_key_id", api_key_id)
        _setter("description", description)
        _setter("private_key", private_key)
        _setter("public_key", public_key)
        if project_assignments is not None:
            _setter("project_assignments", project_assignments)

    @property
    @pulumi.getter(name="apiKeyId")
    def api_key_id(self) -> str:
        """
        Unique identifier for the API key you want to update. Use the /orgs/{ORG-ID}/apiKeys endpoint to retrieve all API keys to which the authenticated user has access for the specified organization.
        """
        return pulumi.get(self, "api_key_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of this Project API key.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> str:
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter(name="projectAssignments")
    def project_assignments(self) -> Optional[Sequence['outputs.GetProjectApiKeysResultProjectAssignmentResult']]:
        return pulumi.get(self, "project_assignments")


@pulumi.output_type
class GetProjectApiKeysResultProjectAssignmentResult(dict):
    def __init__(__self__, *,
                 project_id: str,
                 role_names: Sequence[str]):
        """
        :param str project_id: Project ID to assign to Access Key
        :param Sequence[str] role_names: List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project. You must specify an array even if you are only associating a single role with the Programmatic API key. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) describes the valid roles that can be assigned.
               
               
               See [MongoDB Atlas API - API Keys](https://www.mongodb.com/docs/atlas/reference/api/projectApiKeys/get-all-apiKeys-in-one-project/) - Documentation for more information.
        """
        GetProjectApiKeysResultProjectAssignmentResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            project_id=project_id,
            role_names=role_names,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             project_id: str,
             role_names: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("project_id", project_id)
        _setter("role_names", role_names)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Project ID to assign to Access Key
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[str]:
        """
        List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project. You must specify an array even if you are only associating a single role with the Programmatic API key. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) describes the valid roles that can be assigned.


        See [MongoDB Atlas API - API Keys](https://www.mongodb.com/docs/atlas/reference/api/projectApiKeys/get-all-apiKeys-in-one-project/) - Documentation for more information.
        """
        return pulumi.get(self, "role_names")


@pulumi.output_type
class GetProjectLimitResult(dict):
    def __init__(__self__, *,
                 current_usage: int,
                 default_limit: int,
                 maximum_limit: int,
                 name: str,
                 value: int):
        """
        :param str name: The unique ID for the project.
               
               > **IMPORTANT:** Either `project_id` or `name` must be configurated.
        """
        GetProjectLimitResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            current_usage=current_usage,
            default_limit=default_limit,
            maximum_limit=maximum_limit,
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             current_usage: int,
             default_limit: int,
             maximum_limit: int,
             name: str,
             value: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("current_usage", current_usage)
        _setter("default_limit", default_limit)
        _setter("maximum_limit", maximum_limit)
        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter(name="currentUsage")
    def current_usage(self) -> int:
        return pulumi.get(self, "current_usage")

    @property
    @pulumi.getter(name="defaultLimit")
    def default_limit(self) -> int:
        return pulumi.get(self, "default_limit")

    @property
    @pulumi.getter(name="maximumLimit")
    def maximum_limit(self) -> int:
        return pulumi.get(self, "maximum_limit")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The unique ID for the project.

        > **IMPORTANT:** Either `project_id` or `name` must be configurated.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetProjectTeamResult(dict):
    def __init__(__self__, *,
                 role_names: Sequence[str],
                 team_id: str):
        GetProjectTeamResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_names=role_names,
            team_id=team_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_names: Sequence[str],
             team_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("role_names", role_names)
        _setter("team_id", team_id)

    @property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[str]:
        return pulumi.get(self, "role_names")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> str:
        return pulumi.get(self, "team_id")


@pulumi.output_type
class GetProjectsResultResult(dict):
    def __init__(__self__, *,
                 cluster_count: int,
                 created: str,
                 id: str,
                 is_collect_database_specifics_statistics_enabled: bool,
                 is_data_explorer_enabled: bool,
                 is_extended_storage_sizes_enabled: bool,
                 is_performance_advisor_enabled: bool,
                 is_realtime_performance_panel_enabled: bool,
                 is_schema_advisor_enabled: bool,
                 limits: Sequence['outputs.GetProjectsResultLimitResult'],
                 name: str,
                 org_id: str,
                 project_id: str,
                 region_usage_restrictions: str,
                 teams: Sequence['outputs.GetProjectsResultTeamResult']):
        """
        :param int cluster_count: The number of Atlas clusters deployed in the project.
        :param str created: The ISO-8601-formatted timestamp of when Atlas created the project.
               * `teams.#.team_id` - The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
               * `teams.#.role_names` - Each string in the array represents a project role assigned to the team. Every user associated with the team inherits these roles. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles a user can have.
               * `limits.#.name` - Human-readable label that identifies this project limit.
               * `limits.#.value` - Amount the limit is set to.
               * `limits.#.current_usage` - Amount that indicates the current usage of the limit.
               * `limits.#.default_limit` - Default value of the limit.
               * `limits.#.maximum_limit` - Maximum value of the limit.
        :param str id: Autogenerated Unique ID for this data source.
        :param bool is_collect_database_specifics_statistics_enabled: Flag that indicates whether to enable statistics in [cluster metrics](https://www.mongodb.com/docs/atlas/monitor-cluster-metrics/) collection for the project.
        :param bool is_data_explorer_enabled: Flag that indicates whether to enable Data Explorer for the project. If enabled, you can query your database with an easy to use interface.
        :param bool is_extended_storage_sizes_enabled: Flag that indicates whether to enable extended storage sizes for the specified project.
        :param bool is_performance_advisor_enabled: Flag that indicates whether to enable Performance Advisor and Profiler for the project. If enabled, you can analyze database logs to recommend performance improvements.
        :param bool is_realtime_performance_panel_enabled: Flag that indicates whether to enable Real Time Performance Panel for the project. If enabled, you can see real time metrics from your MongoDB database.
        :param bool is_schema_advisor_enabled: Flag that indicates whether to enable Schema Advisor for the project. If enabled, you receive customized recommendations to optimize your data model and enhance performance. Disable this setting to disable schema suggestions in the [Performance Advisor](https://www.mongodb.com/docs/atlas/performance-advisor/#std-label-performance-advisor) and the [Data Explorer](https://www.mongodb.com/docs/atlas/atlas-ui/#std-label-atlas-ui).
        :param str name: The name of the project you want to create.
        :param str org_id: The ID of the organization you want to create the project within.
        :param str region_usage_restrictions: If GOV_REGIONS_ONLY the project can be used for government regions only, otherwise defaults to standard regions. For more information see [MongoDB Atlas for Government](https://www.mongodb.com/docs/atlas/government/api/#creating-a-project).
               
               See [MongoDB Atlas API - Projects](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Projects) - [and MongoDB Atlas API - Teams](https://docs.atlas.mongodb.com/reference/api/project-get-teams/) Documentation for more information.
        """
        GetProjectsResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster_count=cluster_count,
            created=created,
            id=id,
            is_collect_database_specifics_statistics_enabled=is_collect_database_specifics_statistics_enabled,
            is_data_explorer_enabled=is_data_explorer_enabled,
            is_extended_storage_sizes_enabled=is_extended_storage_sizes_enabled,
            is_performance_advisor_enabled=is_performance_advisor_enabled,
            is_realtime_performance_panel_enabled=is_realtime_performance_panel_enabled,
            is_schema_advisor_enabled=is_schema_advisor_enabled,
            limits=limits,
            name=name,
            org_id=org_id,
            project_id=project_id,
            region_usage_restrictions=region_usage_restrictions,
            teams=teams,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster_count: int,
             created: str,
             id: str,
             is_collect_database_specifics_statistics_enabled: bool,
             is_data_explorer_enabled: bool,
             is_extended_storage_sizes_enabled: bool,
             is_performance_advisor_enabled: bool,
             is_realtime_performance_panel_enabled: bool,
             is_schema_advisor_enabled: bool,
             limits: Sequence['outputs.GetProjectsResultLimitResult'],
             name: str,
             org_id: str,
             project_id: str,
             region_usage_restrictions: str,
             teams: Sequence['outputs.GetProjectsResultTeamResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cluster_count", cluster_count)
        _setter("created", created)
        _setter("id", id)
        _setter("is_collect_database_specifics_statistics_enabled", is_collect_database_specifics_statistics_enabled)
        _setter("is_data_explorer_enabled", is_data_explorer_enabled)
        _setter("is_extended_storage_sizes_enabled", is_extended_storage_sizes_enabled)
        _setter("is_performance_advisor_enabled", is_performance_advisor_enabled)
        _setter("is_realtime_performance_panel_enabled", is_realtime_performance_panel_enabled)
        _setter("is_schema_advisor_enabled", is_schema_advisor_enabled)
        _setter("limits", limits)
        _setter("name", name)
        _setter("org_id", org_id)
        _setter("project_id", project_id)
        _setter("region_usage_restrictions", region_usage_restrictions)
        _setter("teams", teams)

    @property
    @pulumi.getter(name="clusterCount")
    def cluster_count(self) -> int:
        """
        The number of Atlas clusters deployed in the project.
        """
        return pulumi.get(self, "cluster_count")

    @property
    @pulumi.getter
    def created(self) -> str:
        """
        The ISO-8601-formatted timestamp of when Atlas created the project.
        * `teams.#.team_id` - The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
        * `teams.#.role_names` - Each string in the array represents a project role assigned to the team. Every user associated with the team inherits these roles. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles a user can have.
        * `limits.#.name` - Human-readable label that identifies this project limit.
        * `limits.#.value` - Amount the limit is set to.
        * `limits.#.current_usage` - Amount that indicates the current usage of the limit.
        * `limits.#.default_limit` - Default value of the limit.
        * `limits.#.maximum_limit` - Maximum value of the limit.
        """
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Autogenerated Unique ID for this data source.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isCollectDatabaseSpecificsStatisticsEnabled")
    def is_collect_database_specifics_statistics_enabled(self) -> bool:
        """
        Flag that indicates whether to enable statistics in [cluster metrics](https://www.mongodb.com/docs/atlas/monitor-cluster-metrics/) collection for the project.
        """
        return pulumi.get(self, "is_collect_database_specifics_statistics_enabled")

    @property
    @pulumi.getter(name="isDataExplorerEnabled")
    def is_data_explorer_enabled(self) -> bool:
        """
        Flag that indicates whether to enable Data Explorer for the project. If enabled, you can query your database with an easy to use interface.
        """
        return pulumi.get(self, "is_data_explorer_enabled")

    @property
    @pulumi.getter(name="isExtendedStorageSizesEnabled")
    def is_extended_storage_sizes_enabled(self) -> bool:
        """
        Flag that indicates whether to enable extended storage sizes for the specified project.
        """
        return pulumi.get(self, "is_extended_storage_sizes_enabled")

    @property
    @pulumi.getter(name="isPerformanceAdvisorEnabled")
    def is_performance_advisor_enabled(self) -> bool:
        """
        Flag that indicates whether to enable Performance Advisor and Profiler for the project. If enabled, you can analyze database logs to recommend performance improvements.
        """
        return pulumi.get(self, "is_performance_advisor_enabled")

    @property
    @pulumi.getter(name="isRealtimePerformancePanelEnabled")
    def is_realtime_performance_panel_enabled(self) -> bool:
        """
        Flag that indicates whether to enable Real Time Performance Panel for the project. If enabled, you can see real time metrics from your MongoDB database.
        """
        return pulumi.get(self, "is_realtime_performance_panel_enabled")

    @property
    @pulumi.getter(name="isSchemaAdvisorEnabled")
    def is_schema_advisor_enabled(self) -> bool:
        """
        Flag that indicates whether to enable Schema Advisor for the project. If enabled, you receive customized recommendations to optimize your data model and enhance performance. Disable this setting to disable schema suggestions in the [Performance Advisor](https://www.mongodb.com/docs/atlas/performance-advisor/#std-label-performance-advisor) and the [Data Explorer](https://www.mongodb.com/docs/atlas/atlas-ui/#std-label-atlas-ui).
        """
        return pulumi.get(self, "is_schema_advisor_enabled")

    @property
    @pulumi.getter
    def limits(self) -> Sequence['outputs.GetProjectsResultLimitResult']:
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the project you want to create.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        The ID of the organization you want to create the project within.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="regionUsageRestrictions")
    def region_usage_restrictions(self) -> str:
        """
        If GOV_REGIONS_ONLY the project can be used for government regions only, otherwise defaults to standard regions. For more information see [MongoDB Atlas for Government](https://www.mongodb.com/docs/atlas/government/api/#creating-a-project).

        See [MongoDB Atlas API - Projects](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Projects) - [and MongoDB Atlas API - Teams](https://docs.atlas.mongodb.com/reference/api/project-get-teams/) Documentation for more information.
        """
        return pulumi.get(self, "region_usage_restrictions")

    @property
    @pulumi.getter
    def teams(self) -> Sequence['outputs.GetProjectsResultTeamResult']:
        return pulumi.get(self, "teams")


@pulumi.output_type
class GetProjectsResultLimitResult(dict):
    def __init__(__self__, *,
                 current_usage: int,
                 default_limit: int,
                 maximum_limit: int,
                 name: str,
                 value: int):
        """
        :param str name: The name of the project you want to create.
        """
        GetProjectsResultLimitResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            current_usage=current_usage,
            default_limit=default_limit,
            maximum_limit=maximum_limit,
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             current_usage: int,
             default_limit: int,
             maximum_limit: int,
             name: str,
             value: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("current_usage", current_usage)
        _setter("default_limit", default_limit)
        _setter("maximum_limit", maximum_limit)
        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter(name="currentUsage")
    def current_usage(self) -> int:
        return pulumi.get(self, "current_usage")

    @property
    @pulumi.getter(name="defaultLimit")
    def default_limit(self) -> int:
        return pulumi.get(self, "default_limit")

    @property
    @pulumi.getter(name="maximumLimit")
    def maximum_limit(self) -> int:
        return pulumi.get(self, "maximum_limit")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the project you want to create.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetProjectsResultTeamResult(dict):
    def __init__(__self__, *,
                 role_names: Sequence[str],
                 team_id: str):
        GetProjectsResultTeamResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_names=role_names,
            team_id=team_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_names: Sequence[str],
             team_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("role_names", role_names)
        _setter("team_id", team_id)

    @property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[str]:
        return pulumi.get(self, "role_names")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> str:
        return pulumi.get(self, "team_id")


@pulumi.output_type
class GetSearchIndexSynonymResult(dict):
    def __init__(__self__, *,
                 analyzer: str,
                 name: str,
                 source_collection: str):
        """
        :param str analyzer: [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.
        :param str name: Name of the index.
        """
        GetSearchIndexSynonymResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            analyzer=analyzer,
            name=name,
            source_collection=source_collection,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             analyzer: str,
             name: str,
             source_collection: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("analyzer", analyzer)
        _setter("name", name)
        _setter("source_collection", source_collection)

    @property
    @pulumi.getter
    def analyzer(self) -> str:
        """
        [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.
        """
        return pulumi.get(self, "analyzer")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the index.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sourceCollection")
    def source_collection(self) -> str:
        return pulumi.get(self, "source_collection")


@pulumi.output_type
class GetSearchIndexesResultResult(dict):
    def __init__(__self__, *,
                 cluster_name: str,
                 collection_name: str,
                 database: str,
                 index_id: str,
                 name: str,
                 project_id: str,
                 status: str,
                 analyzer: Optional[str] = None,
                 analyzers: Optional[str] = None,
                 mappings_dynamic: Optional[bool] = None,
                 mappings_fields: Optional[str] = None,
                 search_analyzer: Optional[str] = None,
                 synonyms: Optional[Sequence['outputs.GetSearchIndexesResultSynonymResult']] = None,
                 wait_for_index_build_completion: Optional[bool] = None):
        """
        :param str cluster_name: Name of the cluster containing the collection with one or more Atlas Search indexes.
        :param str collection_name: Name of the collection with one or more Atlas Search indexes.
        :param str database: (Required) Name of the database the collection is in.
        :param str name: Name of the index.
        :param str project_id: Unique identifier for the [project](https://docs.atlas.mongodb.com/organizations-projects/#std-label-projects) that contains the specified cluster.
        :param str analyzer: [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.
        :param str analyzers: [Custom analyzers](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-custom-analyzers) to use in this index (this is an array of objects).
        :param bool mappings_dynamic: Flag indicating whether the index uses dynamic or static mappings.
        :param str mappings_fields: Object containing one or more field specifications.
        :param str search_analyzer: [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when searching the index.
        :param Sequence['GetSearchIndexesResultSynonymArgs'] synonyms: Synonyms mapping definition to use in this index.
               * `synonyms.#.name` - Name of the [synonym mapping definition](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-ref).
               * `synonyms.#.source_collection` - Name of the source MongoDB collection for the synonyms.
               * `synonyms.#.analyzer` - Name of the [analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use with this synonym mapping.
        """
        GetSearchIndexesResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster_name=cluster_name,
            collection_name=collection_name,
            database=database,
            index_id=index_id,
            name=name,
            project_id=project_id,
            status=status,
            analyzer=analyzer,
            analyzers=analyzers,
            mappings_dynamic=mappings_dynamic,
            mappings_fields=mappings_fields,
            search_analyzer=search_analyzer,
            synonyms=synonyms,
            wait_for_index_build_completion=wait_for_index_build_completion,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster_name: str,
             collection_name: str,
             database: str,
             index_id: str,
             name: str,
             project_id: str,
             status: str,
             analyzer: Optional[str] = None,
             analyzers: Optional[str] = None,
             mappings_dynamic: Optional[bool] = None,
             mappings_fields: Optional[str] = None,
             search_analyzer: Optional[str] = None,
             synonyms: Optional[Sequence['outputs.GetSearchIndexesResultSynonymResult']] = None,
             wait_for_index_build_completion: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cluster_name", cluster_name)
        _setter("collection_name", collection_name)
        _setter("database", database)
        _setter("index_id", index_id)
        _setter("name", name)
        _setter("project_id", project_id)
        _setter("status", status)
        if analyzer is not None:
            _setter("analyzer", analyzer)
        if analyzers is not None:
            _setter("analyzers", analyzers)
        if mappings_dynamic is not None:
            _setter("mappings_dynamic", mappings_dynamic)
        if mappings_fields is not None:
            _setter("mappings_fields", mappings_fields)
        if search_analyzer is not None:
            _setter("search_analyzer", search_analyzer)
        if synonyms is not None:
            _setter("synonyms", synonyms)
        if wait_for_index_build_completion is not None:
            _setter("wait_for_index_build_completion", wait_for_index_build_completion)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        Name of the cluster containing the collection with one or more Atlas Search indexes.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> str:
        """
        Name of the collection with one or more Atlas Search indexes.
        """
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        (Required) Name of the database the collection is in.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="indexId")
    def index_id(self) -> str:
        return pulumi.get(self, "index_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the index.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Unique identifier for the [project](https://docs.atlas.mongodb.com/organizations-projects/#std-label-projects) that contains the specified cluster.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def analyzer(self) -> Optional[str]:
        """
        [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.
        """
        return pulumi.get(self, "analyzer")

    @property
    @pulumi.getter
    def analyzers(self) -> Optional[str]:
        """
        [Custom analyzers](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-custom-analyzers) to use in this index (this is an array of objects).
        """
        return pulumi.get(self, "analyzers")

    @property
    @pulumi.getter(name="mappingsDynamic")
    def mappings_dynamic(self) -> Optional[bool]:
        """
        Flag indicating whether the index uses dynamic or static mappings.
        """
        return pulumi.get(self, "mappings_dynamic")

    @property
    @pulumi.getter(name="mappingsFields")
    def mappings_fields(self) -> Optional[str]:
        """
        Object containing one or more field specifications.
        """
        return pulumi.get(self, "mappings_fields")

    @property
    @pulumi.getter(name="searchAnalyzer")
    def search_analyzer(self) -> Optional[str]:
        """
        [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when searching the index.
        """
        return pulumi.get(self, "search_analyzer")

    @property
    @pulumi.getter
    def synonyms(self) -> Optional[Sequence['outputs.GetSearchIndexesResultSynonymResult']]:
        """
        Synonyms mapping definition to use in this index.
        * `synonyms.#.name` - Name of the [synonym mapping definition](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-ref).
        * `synonyms.#.source_collection` - Name of the source MongoDB collection for the synonyms.
        * `synonyms.#.analyzer` - Name of the [analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use with this synonym mapping.
        """
        return pulumi.get(self, "synonyms")

    @property
    @pulumi.getter(name="waitForIndexBuildCompletion")
    def wait_for_index_build_completion(self) -> Optional[bool]:
        return pulumi.get(self, "wait_for_index_build_completion")


@pulumi.output_type
class GetSearchIndexesResultSynonymResult(dict):
    def __init__(__self__, *,
                 analyzer: str,
                 name: str,
                 source_collection: str):
        """
        :param str analyzer: [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.
        :param str name: Name of the index.
        """
        GetSearchIndexesResultSynonymResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            analyzer=analyzer,
            name=name,
            source_collection=source_collection,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             analyzer: str,
             name: str,
             source_collection: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("analyzer", analyzer)
        _setter("name", name)
        _setter("source_collection", source_collection)

    @property
    @pulumi.getter
    def analyzer(self) -> str:
        """
        [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.
        """
        return pulumi.get(self, "analyzer")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the index.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sourceCollection")
    def source_collection(self) -> str:
        return pulumi.get(self, "source_collection")


@pulumi.output_type
class GetServerlessInstanceLinkResult(dict):
    def __init__(__self__, *,
                 href: str,
                 rel: str):
        GetServerlessInstanceLinkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            href=href,
            rel=rel,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             href: str,
             rel: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("href", href)
        _setter("rel", rel)

    @property
    @pulumi.getter
    def href(self) -> str:
        return pulumi.get(self, "href")

    @property
    @pulumi.getter
    def rel(self) -> str:
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetServerlessInstanceTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Constant that defines the set of the tag.
        :param str value: Variable that belongs to the set of the tag.
        """
        GetServerlessInstanceTagResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Constant that defines the set of the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Variable that belongs to the set of the tag.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetServerlessInstancesResultResult(dict):
    def __init__(__self__, *,
                 connection_strings_private_endpoint_srvs: Sequence[str],
                 connection_strings_standard_srv: str,
                 continuous_backup_enabled: bool,
                 create_date: str,
                 id: str,
                 links: Sequence['outputs.GetServerlessInstancesResultLinkResult'],
                 mongo_db_version: str,
                 name: str,
                 project_id: str,
                 provider_settings_backing_provider_name: str,
                 provider_settings_provider_name: str,
                 provider_settings_region_name: str,
                 state_name: str,
                 tags: Sequence['outputs.GetServerlessInstancesResultTagResult'],
                 termination_protection_enabled: bool):
        """
        :param str connection_strings_standard_srv: Public `mongodb+srv://` connection string that you can use to connect to this serverless instance.
        :param bool continuous_backup_enabled: Flag that indicates whether the serverless instance uses Serverless Continuous Backup.
        :param str id: Unique 24-hexadecimal digit string that identifies the serverless instance.
        :param str mongo_db_version: Version of MongoDB that the serverless instance runs, in `<major version>`.`<minor version>` format.
        :param str name: (Required) Human-readable label that identifies your serverless instance.
        :param str project_id: Unique identifier for the [project](https://docs.atlas.mongodb.com/organizations-projects/#std-label-projects) that contains the specified cluster.
        :param str provider_settings_backing_provider_name: Cloud service provider on which MongoDB Cloud provisioned the serverless instance.
        :param str provider_settings_provider_name: Cloud service provider that applies to the provisioned the serverless instance.
        :param str provider_settings_region_name: Human-readable label that identifies the physical location of your MongoDB serverless instance. The region you choose can affect network latency for clients accessing your databases.
        :param str state_name: Stage of deployment of this serverless instance when the resource made its request.
        :param Sequence['GetServerlessInstancesResultTagArgs'] tags: Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.
        :param bool termination_protection_enabled: Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.
        """
        GetServerlessInstancesResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_strings_private_endpoint_srvs=connection_strings_private_endpoint_srvs,
            connection_strings_standard_srv=connection_strings_standard_srv,
            continuous_backup_enabled=continuous_backup_enabled,
            create_date=create_date,
            id=id,
            links=links,
            mongo_db_version=mongo_db_version,
            name=name,
            project_id=project_id,
            provider_settings_backing_provider_name=provider_settings_backing_provider_name,
            provider_settings_provider_name=provider_settings_provider_name,
            provider_settings_region_name=provider_settings_region_name,
            state_name=state_name,
            tags=tags,
            termination_protection_enabled=termination_protection_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_strings_private_endpoint_srvs: Sequence[str],
             connection_strings_standard_srv: str,
             continuous_backup_enabled: bool,
             create_date: str,
             id: str,
             links: Sequence['outputs.GetServerlessInstancesResultLinkResult'],
             mongo_db_version: str,
             name: str,
             project_id: str,
             provider_settings_backing_provider_name: str,
             provider_settings_provider_name: str,
             provider_settings_region_name: str,
             state_name: str,
             tags: Sequence['outputs.GetServerlessInstancesResultTagResult'],
             termination_protection_enabled: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("connection_strings_private_endpoint_srvs", connection_strings_private_endpoint_srvs)
        _setter("connection_strings_standard_srv", connection_strings_standard_srv)
        _setter("continuous_backup_enabled", continuous_backup_enabled)
        _setter("create_date", create_date)
        _setter("id", id)
        _setter("links", links)
        _setter("mongo_db_version", mongo_db_version)
        _setter("name", name)
        _setter("project_id", project_id)
        _setter("provider_settings_backing_provider_name", provider_settings_backing_provider_name)
        _setter("provider_settings_provider_name", provider_settings_provider_name)
        _setter("provider_settings_region_name", provider_settings_region_name)
        _setter("state_name", state_name)
        _setter("tags", tags)
        _setter("termination_protection_enabled", termination_protection_enabled)

    @property
    @pulumi.getter(name="connectionStringsPrivateEndpointSrvs")
    def connection_strings_private_endpoint_srvs(self) -> Sequence[str]:
        return pulumi.get(self, "connection_strings_private_endpoint_srvs")

    @property
    @pulumi.getter(name="connectionStringsStandardSrv")
    def connection_strings_standard_srv(self) -> str:
        """
        Public `mongodb+srv://` connection string that you can use to connect to this serverless instance.
        """
        return pulumi.get(self, "connection_strings_standard_srv")

    @property
    @pulumi.getter(name="continuousBackupEnabled")
    def continuous_backup_enabled(self) -> bool:
        """
        Flag that indicates whether the serverless instance uses Serverless Continuous Backup.
        """
        return pulumi.get(self, "continuous_backup_enabled")

    @property
    @pulumi.getter(name="createDate")
    def create_date(self) -> str:
        return pulumi.get(self, "create_date")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the serverless instance.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def links(self) -> Sequence['outputs.GetServerlessInstancesResultLinkResult']:
        return pulumi.get(self, "links")

    @property
    @pulumi.getter(name="mongoDbVersion")
    def mongo_db_version(self) -> str:
        """
        Version of MongoDB that the serverless instance runs, in `<major version>`.`<minor version>` format.
        """
        return pulumi.get(self, "mongo_db_version")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        (Required) Human-readable label that identifies your serverless instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Unique identifier for the [project](https://docs.atlas.mongodb.com/organizations-projects/#std-label-projects) that contains the specified cluster.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="providerSettingsBackingProviderName")
    def provider_settings_backing_provider_name(self) -> str:
        """
        Cloud service provider on which MongoDB Cloud provisioned the serverless instance.
        """
        return pulumi.get(self, "provider_settings_backing_provider_name")

    @property
    @pulumi.getter(name="providerSettingsProviderName")
    def provider_settings_provider_name(self) -> str:
        """
        Cloud service provider that applies to the provisioned the serverless instance.
        """
        return pulumi.get(self, "provider_settings_provider_name")

    @property
    @pulumi.getter(name="providerSettingsRegionName")
    def provider_settings_region_name(self) -> str:
        """
        Human-readable label that identifies the physical location of your MongoDB serverless instance. The region you choose can affect network latency for clients accessing your databases.
        """
        return pulumi.get(self, "provider_settings_region_name")

    @property
    @pulumi.getter(name="stateName")
    def state_name(self) -> str:
        """
        Stage of deployment of this serverless instance when the resource made its request.
        """
        return pulumi.get(self, "state_name")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetServerlessInstancesResultTagResult']:
        """
        Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="terminationProtectionEnabled")
    def termination_protection_enabled(self) -> bool:
        """
        Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.
        """
        return pulumi.get(self, "termination_protection_enabled")


@pulumi.output_type
class GetServerlessInstancesResultLinkResult(dict):
    def __init__(__self__, *,
                 href: str,
                 rel: str):
        GetServerlessInstancesResultLinkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            href=href,
            rel=rel,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             href: str,
             rel: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("href", href)
        _setter("rel", rel)

    @property
    @pulumi.getter
    def href(self) -> str:
        return pulumi.get(self, "href")

    @property
    @pulumi.getter
    def rel(self) -> str:
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetServerlessInstancesResultTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Constant that defines the set of the tag.
        :param str value: Variable that belongs to the set of the tag.
        """
        GetServerlessInstancesResultTagResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Constant that defines the set of the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Variable that belongs to the set of the tag.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetSharedTierRestoreJobsResultResult(dict):
    def __init__(__self__, *,
                 delivery_type: str,
                 expiration_date: str,
                 job_id: str,
                 restore_finished_date: str,
                 restore_scheduled_date: str,
                 snapshot_finished_date: str,
                 snapshot_id: str,
                 snapshot_url: str,
                 status: str,
                 target_deployment_item_name: str,
                 target_project_id: str):
        GetSharedTierRestoreJobsResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delivery_type=delivery_type,
            expiration_date=expiration_date,
            job_id=job_id,
            restore_finished_date=restore_finished_date,
            restore_scheduled_date=restore_scheduled_date,
            snapshot_finished_date=snapshot_finished_date,
            snapshot_id=snapshot_id,
            snapshot_url=snapshot_url,
            status=status,
            target_deployment_item_name=target_deployment_item_name,
            target_project_id=target_project_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delivery_type: str,
             expiration_date: str,
             job_id: str,
             restore_finished_date: str,
             restore_scheduled_date: str,
             snapshot_finished_date: str,
             snapshot_id: str,
             snapshot_url: str,
             status: str,
             target_deployment_item_name: str,
             target_project_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("delivery_type", delivery_type)
        _setter("expiration_date", expiration_date)
        _setter("job_id", job_id)
        _setter("restore_finished_date", restore_finished_date)
        _setter("restore_scheduled_date", restore_scheduled_date)
        _setter("snapshot_finished_date", snapshot_finished_date)
        _setter("snapshot_id", snapshot_id)
        _setter("snapshot_url", snapshot_url)
        _setter("status", status)
        _setter("target_deployment_item_name", target_deployment_item_name)
        _setter("target_project_id", target_project_id)

    @property
    @pulumi.getter(name="deliveryType")
    def delivery_type(self) -> str:
        return pulumi.get(self, "delivery_type")

    @property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> str:
        return pulumi.get(self, "expiration_date")

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> str:
        return pulumi.get(self, "job_id")

    @property
    @pulumi.getter(name="restoreFinishedDate")
    def restore_finished_date(self) -> str:
        return pulumi.get(self, "restore_finished_date")

    @property
    @pulumi.getter(name="restoreScheduledDate")
    def restore_scheduled_date(self) -> str:
        return pulumi.get(self, "restore_scheduled_date")

    @property
    @pulumi.getter(name="snapshotFinishedDate")
    def snapshot_finished_date(self) -> str:
        return pulumi.get(self, "snapshot_finished_date")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> str:
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter(name="snapshotUrl")
    def snapshot_url(self) -> str:
        return pulumi.get(self, "snapshot_url")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="targetDeploymentItemName")
    def target_deployment_item_name(self) -> str:
        return pulumi.get(self, "target_deployment_item_name")

    @property
    @pulumi.getter(name="targetProjectId")
    def target_project_id(self) -> str:
        return pulumi.get(self, "target_project_id")


@pulumi.output_type
class GetSharedTierSnapshotsResultResult(dict):
    def __init__(__self__, *,
                 expiration: str,
                 finish_time: str,
                 mongo_db_version: str,
                 scheduled_time: str,
                 snapshot_id: str,
                 start_time: str,
                 status: str):
        GetSharedTierSnapshotsResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expiration=expiration,
            finish_time=finish_time,
            mongo_db_version=mongo_db_version,
            scheduled_time=scheduled_time,
            snapshot_id=snapshot_id,
            start_time=start_time,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expiration: str,
             finish_time: str,
             mongo_db_version: str,
             scheduled_time: str,
             snapshot_id: str,
             start_time: str,
             status: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("expiration", expiration)
        _setter("finish_time", finish_time)
        _setter("mongo_db_version", mongo_db_version)
        _setter("scheduled_time", scheduled_time)
        _setter("snapshot_id", snapshot_id)
        _setter("start_time", start_time)
        _setter("status", status)

    @property
    @pulumi.getter
    def expiration(self) -> str:
        return pulumi.get(self, "expiration")

    @property
    @pulumi.getter(name="finishTime")
    def finish_time(self) -> str:
        return pulumi.get(self, "finish_time")

    @property
    @pulumi.getter(name="mongoDbVersion")
    def mongo_db_version(self) -> str:
        return pulumi.get(self, "mongo_db_version")

    @property
    @pulumi.getter(name="scheduledTime")
    def scheduled_time(self) -> str:
        return pulumi.get(self, "scheduled_time")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> str:
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetThirdPartyIntegrationsResultResult(dict):
    def __init__(__self__, *,
                 account_id: str,
                 api_key: str,
                 api_token: str,
                 channel_name: str,
                 license_key: str,
                 project_id: str,
                 region: str,
                 routing_key: str,
                 secret: str,
                 service_key: str,
                 team_name: str,
                 type: str,
                 url: str,
                 enabled: Optional[bool] = None,
                 microsoft_teams_webhook_url: Optional[str] = None,
                 scheme: Optional[str] = None,
                 service_discovery: Optional[str] = None,
                 user_name: Optional[str] = None):
        """
        :param str account_id: Unique identifier of your New Relic account.
        :param str api_key: Your API Key.
        :param str api_token: Your API Token.
        :param str license_key: Your License Key.
        :param str project_id: The unique ID for the project to get all Third-Party service integrations
        :param str region: Indicates which API URL to use, either US or EU. Opsgenie will use US by default.
        :param str routing_key: An optional field for your Routing Key.
        :param str secret: An optional field for your webhook secret.
        :param str service_key: Your Service Key.
        :param str type: (Required) Thirt-Party service integration type.
        :param str url: Your webhook URL.
        :param bool enabled: Whether your cluster has Prometheus enabled.
        :param str microsoft_teams_webhook_url: Your Microsoft Teams incoming webhook URL.
        :param str scheme: Your Prometheus protocol scheme configured for requests.
        :param str service_discovery: Indicates which service discovery method is used, either file or http.
        :param str user_name: Your Prometheus username.
        """
        GetThirdPartyIntegrationsResultResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account_id=account_id,
            api_key=api_key,
            api_token=api_token,
            channel_name=channel_name,
            license_key=license_key,
            project_id=project_id,
            region=region,
            routing_key=routing_key,
            secret=secret,
            service_key=service_key,
            team_name=team_name,
            type=type,
            url=url,
            enabled=enabled,
            microsoft_teams_webhook_url=microsoft_teams_webhook_url,
            scheme=scheme,
            service_discovery=service_discovery,
            user_name=user_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account_id: str,
             api_key: str,
             api_token: str,
             channel_name: str,
             license_key: str,
             project_id: str,
             region: str,
             routing_key: str,
             secret: str,
             service_key: str,
             team_name: str,
             type: str,
             url: str,
             enabled: Optional[bool] = None,
             microsoft_teams_webhook_url: Optional[str] = None,
             scheme: Optional[str] = None,
             service_discovery: Optional[str] = None,
             user_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("account_id", account_id)
        _setter("api_key", api_key)
        _setter("api_token", api_token)
        _setter("channel_name", channel_name)
        _setter("license_key", license_key)
        _setter("project_id", project_id)
        _setter("region", region)
        _setter("routing_key", routing_key)
        _setter("secret", secret)
        _setter("service_key", service_key)
        _setter("team_name", team_name)
        _setter("type", type)
        _setter("url", url)
        if enabled is not None:
            _setter("enabled", enabled)
        if microsoft_teams_webhook_url is not None:
            _setter("microsoft_teams_webhook_url", microsoft_teams_webhook_url)
        if scheme is not None:
            _setter("scheme", scheme)
        if service_discovery is not None:
            _setter("service_discovery", service_discovery)
        if user_name is not None:
            _setter("user_name", user_name)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        """
        Unique identifier of your New Relic account.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Your API Key.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        Your API Token.
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> str:
        return pulumi.get(self, "channel_name")

    @property
    @pulumi.getter(name="licenseKey")
    def license_key(self) -> str:
        """
        Your License Key.
        """
        return pulumi.get(self, "license_key")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project to get all Third-Party service integrations
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Indicates which API URL to use, either US or EU. Opsgenie will use US by default.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="routingKey")
    def routing_key(self) -> str:
        """
        An optional field for your Routing Key.
        """
        return pulumi.get(self, "routing_key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        An optional field for your webhook secret.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="serviceKey")
    def service_key(self) -> str:
        """
        Your Service Key.
        """
        return pulumi.get(self, "service_key")

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> str:
        return pulumi.get(self, "team_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        (Required) Thirt-Party service integration type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Your webhook URL.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether your cluster has Prometheus enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="microsoftTeamsWebhookUrl")
    def microsoft_teams_webhook_url(self) -> Optional[str]:
        """
        Your Microsoft Teams incoming webhook URL.
        """
        return pulumi.get(self, "microsoft_teams_webhook_url")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        """
        Your Prometheus protocol scheme configured for requests.
        """
        return pulumi.get(self, "scheme")

    @property
    @pulumi.getter(name="serviceDiscovery")
    def service_discovery(self) -> Optional[str]:
        """
        Indicates which service discovery method is used, either file or http.
        """
        return pulumi.get(self, "service_discovery")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        """
        Your Prometheus username.
        """
        return pulumi.get(self, "user_name")


