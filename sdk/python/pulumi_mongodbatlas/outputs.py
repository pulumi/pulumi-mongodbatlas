# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'AdvancedClusterAdvancedConfiguration',
    'AdvancedClusterBiConnectorConfig',
    'AdvancedClusterConnectionStrings',
    'AdvancedClusterConnectionStringsPrivateEndpoint',
    'AdvancedClusterConnectionStringsPrivateEndpointEndpoint',
    'AdvancedClusterPinnedFcv',
    'AdvancedClusterReplicationSpec',
    'AdvancedClusterReplicationSpecRegionConfig',
    'AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling',
    'AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs',
    'AdvancedClusterReplicationSpecRegionConfigAutoScaling',
    'AdvancedClusterReplicationSpecRegionConfigElectableSpecs',
    'AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs',
    'AdvancedClusterTimeouts',
    'AlertConfigurationMatcher',
    'AlertConfigurationMetricThresholdConfig',
    'AlertConfigurationNotification',
    'AlertConfigurationThresholdConfig',
    'BackupCompliancePolicyOnDemandPolicyItem',
    'BackupCompliancePolicyPolicyItemDaily',
    'BackupCompliancePolicyPolicyItemHourly',
    'BackupCompliancePolicyPolicyItemMonthly',
    'BackupCompliancePolicyPolicyItemWeekly',
    'BackupCompliancePolicyPolicyItemYearly',
    'CloudBackupScheduleCopySetting',
    'CloudBackupScheduleExport',
    'CloudBackupSchedulePolicyItemDaily',
    'CloudBackupSchedulePolicyItemHourly',
    'CloudBackupSchedulePolicyItemMonthly',
    'CloudBackupSchedulePolicyItemWeekly',
    'CloudBackupSchedulePolicyItemYearly',
    'CloudBackupSnapshotExportJobComponent',
    'CloudBackupSnapshotExportJobCustomData',
    'CloudBackupSnapshotMember',
    'CloudBackupSnapshotRestoreJobDeliveryTypeConfig',
    'CloudProviderAccessAuthorizationAws',
    'CloudProviderAccessAuthorizationAzure',
    'CloudProviderAccessAuthorizationFeatureUsage',
    'CloudProviderAccessAuthorizationGcp',
    'CloudProviderAccessSetupAwsConfig',
    'CloudProviderAccessSetupAzureConfig',
    'CloudProviderAccessSetupGcpConfig',
    'CloudUserOrgAssignmentRoles',
    'CloudUserOrgAssignmentRolesProjectRoleAssignment',
    'CloudUserTeamAssignmentRoles',
    'CloudUserTeamAssignmentRolesProjectRoleAssignment',
    'ClusterAdvancedConfiguration',
    'ClusterBiConnectorConfig',
    'ClusterConnectionString',
    'ClusterConnectionStringPrivateEndpoint',
    'ClusterConnectionStringPrivateEndpointEndpoint',
    'ClusterLabel',
    'ClusterOutageSimulationOutageFilter',
    'ClusterPinnedFcv',
    'ClusterReplicationSpec',
    'ClusterReplicationSpecRegionsConfig',
    'ClusterSnapshotBackupPolicy',
    'ClusterSnapshotBackupPolicyPolicy',
    'ClusterSnapshotBackupPolicyPolicyPolicyItem',
    'ClusterTag',
    'CustomDbRoleAction',
    'CustomDbRoleActionResource',
    'CustomDbRoleInheritedRole',
    'DatabaseUserLabel',
    'DatabaseUserRole',
    'DatabaseUserScope',
    'EncryptionAtRestAwsKmsConfig',
    'EncryptionAtRestAzureKeyVaultConfig',
    'EncryptionAtRestGoogleCloudKmsConfig',
    'EncryptionAtRestPrivateEndpointTimeouts',
    'EventTriggerEventProcessors',
    'EventTriggerEventProcessorsAwsEventbridge',
    'FederatedDatabaseInstanceCloudProviderConfig',
    'FederatedDatabaseInstanceCloudProviderConfigAws',
    'FederatedDatabaseInstanceCloudProviderConfigAzure',
    'FederatedDatabaseInstanceDataProcessRegion',
    'FederatedDatabaseInstanceStorageDatabase',
    'FederatedDatabaseInstanceStorageDatabaseCollection',
    'FederatedDatabaseInstanceStorageDatabaseCollectionDataSource',
    'FederatedDatabaseInstanceStorageDatabaseView',
    'FederatedDatabaseInstanceStorageStore',
    'FederatedDatabaseInstanceStorageStoreReadPreference',
    'FederatedDatabaseInstanceStorageStoreReadPreferenceTagSet',
    'FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTag',
    'FederatedSettingsOrgConfigUserConflict',
    'FederatedSettingsOrgRoleMappingRoleAssignment',
    'FlexClusterBackupSettings',
    'FlexClusterConnectionStrings',
    'FlexClusterProviderSettings',
    'FlexClusterTimeouts',
    'GlobalClusterConfigCustomZoneMapping',
    'GlobalClusterConfigManagedNamespace',
    'LdapConfigurationUserToDnMapping',
    'LdapVerifyLink',
    'LdapVerifyValidation',
    'MaintenanceWindowProtectedHours',
    'OnlineArchiveCriteria',
    'OnlineArchiveDataExpirationRule',
    'OnlineArchiveDataProcessRegion',
    'OnlineArchivePartitionField',
    'OnlineArchiveSchedule',
    'PrivateLinkEndpointServiceEndpoint',
    'ProjectApiKeyProjectAssignment',
    'ProjectIpAccessListTimeouts',
    'ProjectIpAddresses',
    'ProjectIpAddressesServices',
    'ProjectIpAddressesServicesCluster',
    'ProjectLimit',
    'ProjectServiceAccountSecret',
    'ProjectTeam',
    'PushBasedLogExportTimeouts',
    'ResourcePolicyCreatedByUser',
    'ResourcePolicyLastUpdatedByUser',
    'ResourcePolicyPolicy',
    'SearchDeploymentSpec',
    'SearchDeploymentTimeouts',
    'SearchIndexSynonym',
    'SearchIndexTypeSet',
    'ServerlessInstanceLink',
    'ServerlessInstanceTag',
    'ServiceAccountSecret',
    'StreamConnectionAuthentication',
    'StreamConnectionAws',
    'StreamConnectionDbRoleToExecute',
    'StreamConnectionNetworking',
    'StreamConnectionNetworkingAccess',
    'StreamConnectionSchemaRegistryAuthentication',
    'StreamConnectionSecurity',
    'StreamInstanceDataProcessRegion',
    'StreamInstanceStreamConfig',
    'StreamProcessorOptions',
    'StreamProcessorOptionsDlq',
    'StreamProcessorTimeouts',
    'StreamWorkspaceDataProcessRegion',
    'StreamWorkspaceStreamConfig',
    'X509AuthenticationDatabaseUserCertificate',
    'GetAccessListApiKeysResultResult',
    'GetAdvancedClusterAdvancedConfigurationResult',
    'GetAdvancedClusterBiConnectorConfigResult',
    'GetAdvancedClusterConnectionStringsResult',
    'GetAdvancedClusterConnectionStringsPrivateEndpointResult',
    'GetAdvancedClusterConnectionStringsPrivateEndpointEndpointResult',
    'GetAdvancedClusterPinnedFcvResult',
    'GetAdvancedClusterReplicationSpecResult',
    'GetAdvancedClusterReplicationSpecRegionConfigResult',
    'GetAdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingResult',
    'GetAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsResult',
    'GetAdvancedClusterReplicationSpecRegionConfigAutoScalingResult',
    'GetAdvancedClusterReplicationSpecRegionConfigEffectiveAnalyticsSpecsResult',
    'GetAdvancedClusterReplicationSpecRegionConfigEffectiveElectableSpecsResult',
    'GetAdvancedClusterReplicationSpecRegionConfigEffectiveReadOnlySpecsResult',
    'GetAdvancedClusterReplicationSpecRegionConfigElectableSpecsResult',
    'GetAdvancedClusterReplicationSpecRegionConfigReadOnlySpecsResult',
    'GetAdvancedClustersResultResult',
    'GetAdvancedClustersResultAdvancedConfigurationResult',
    'GetAdvancedClustersResultBiConnectorConfigResult',
    'GetAdvancedClustersResultConnectionStringsResult',
    'GetAdvancedClustersResultConnectionStringsPrivateEndpointResult',
    'GetAdvancedClustersResultConnectionStringsPrivateEndpointEndpointResult',
    'GetAdvancedClustersResultPinnedFcvResult',
    'GetAdvancedClustersResultReplicationSpecResult',
    'GetAdvancedClustersResultReplicationSpecRegionConfigResult',
    'GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsAutoScalingResult',
    'GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecsResult',
    'GetAdvancedClustersResultReplicationSpecRegionConfigAutoScalingResult',
    'GetAdvancedClustersResultReplicationSpecRegionConfigEffectiveAnalyticsSpecsResult',
    'GetAdvancedClustersResultReplicationSpecRegionConfigEffectiveElectableSpecsResult',
    'GetAdvancedClustersResultReplicationSpecRegionConfigEffectiveReadOnlySpecsResult',
    'GetAdvancedClustersResultReplicationSpecRegionConfigElectableSpecsResult',
    'GetAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecsResult',
    'GetAlertConfigurationMatcherResult',
    'GetAlertConfigurationMetricThresholdConfigResult',
    'GetAlertConfigurationNotificationResult',
    'GetAlertConfigurationOutputResult',
    'GetAlertConfigurationThresholdConfigResult',
    'GetAlertConfigurationsListOptionResult',
    'GetAlertConfigurationsResultResult',
    'GetAlertConfigurationsResultMatcherResult',
    'GetAlertConfigurationsResultMetricThresholdConfigResult',
    'GetAlertConfigurationsResultNotificationResult',
    'GetAlertConfigurationsResultOutputResult',
    'GetAlertConfigurationsResultThresholdConfigResult',
    'GetApiKeyProjectAssignmentsResultResult',
    'GetApiKeysResultResult',
    'GetAtlasUserLinkResult',
    'GetAtlasUserRoleResult',
    'GetAtlasUsersResultResult',
    'GetAtlasUsersResultLinkResult',
    'GetAtlasUsersResultRoleResult',
    'GetBackupCompliancePolicyOnDemandPolicyItemResult',
    'GetBackupCompliancePolicyPolicyItemDailyResult',
    'GetBackupCompliancePolicyPolicyItemHourlyResult',
    'GetBackupCompliancePolicyPolicyItemMonthlyResult',
    'GetBackupCompliancePolicyPolicyItemWeeklyResult',
    'GetBackupCompliancePolicyPolicyItemYearlyResult',
    'GetCloudBackupScheduleCopySettingResult',
    'GetCloudBackupScheduleExportResult',
    'GetCloudBackupSchedulePolicyItemDailyResult',
    'GetCloudBackupSchedulePolicyItemHourlyResult',
    'GetCloudBackupSchedulePolicyItemMonthlyResult',
    'GetCloudBackupSchedulePolicyItemWeeklyResult',
    'GetCloudBackupSchedulePolicyItemYearlyResult',
    'GetCloudBackupSnapshotExportBucketsResultResult',
    'GetCloudBackupSnapshotExportJobComponentResult',
    'GetCloudBackupSnapshotExportJobCustomDataResult',
    'GetCloudBackupSnapshotExportJobsResultResult',
    'GetCloudBackupSnapshotExportJobsResultComponentResult',
    'GetCloudBackupSnapshotExportJobsResultCustomDataResult',
    'GetCloudBackupSnapshotMemberResult',
    'GetCloudBackupSnapshotRestoreJobsResultResult',
    'GetCloudBackupSnapshotsResultResult',
    'GetCloudBackupSnapshotsResultMemberResult',
    'GetCloudProviderAccessSetupAwsConfigResult',
    'GetCloudProviderAccessSetupAzureConfigResult',
    'GetCloudProviderAccessSetupGcpConfigResult',
    'GetCloudUserOrgAssignmentRolesResult',
    'GetCloudUserOrgAssignmentRolesProjectRoleAssignmentResult',
    'GetCloudUserTeamAssignmentRolesResult',
    'GetCloudUserTeamAssignmentRolesProjectRoleAssignmentResult',
    'GetClusterAdvancedConfigurationResult',
    'GetClusterBiConnectorConfigResult',
    'GetClusterConnectionStringResult',
    'GetClusterConnectionStringPrivateEndpointResult',
    'GetClusterConnectionStringPrivateEndpointEndpointResult',
    'GetClusterLabelResult',
    'GetClusterOutageSimulationOutageFilterResult',
    'GetClusterPinnedFcvResult',
    'GetClusterReplicationSpecResult',
    'GetClusterReplicationSpecRegionsConfigResult',
    'GetClusterSnapshotBackupPolicyResult',
    'GetClusterSnapshotBackupPolicyPolicyResult',
    'GetClusterSnapshotBackupPolicyPolicyPolicyItemResult',
    'GetClusterTagResult',
    'GetClustersResultResult',
    'GetClustersResultAdvancedConfigurationResult',
    'GetClustersResultBiConnectorConfigResult',
    'GetClustersResultConnectionStringResult',
    'GetClustersResultConnectionStringPrivateEndpointResult',
    'GetClustersResultConnectionStringPrivateEndpointEndpointResult',
    'GetClustersResultLabelResult',
    'GetClustersResultPinnedFcvResult',
    'GetClustersResultReplicationSpecResult',
    'GetClustersResultReplicationSpecRegionsConfigResult',
    'GetClustersResultSnapshotBackupPolicyResult',
    'GetClustersResultSnapshotBackupPolicyPolicyResult',
    'GetClustersResultSnapshotBackupPolicyPolicyPolicyItemResult',
    'GetClustersResultTagResult',
    'GetControlPlaneIpAddressesInboundResult',
    'GetControlPlaneIpAddressesOutboundResult',
    'GetCustomDbRoleActionResult',
    'GetCustomDbRoleActionResourceResult',
    'GetCustomDbRoleInheritedRoleResult',
    'GetCustomDbRolesResultResult',
    'GetCustomDbRolesResultActionResult',
    'GetCustomDbRolesResultActionResourceResult',
    'GetCustomDbRolesResultInheritedRoleResult',
    'GetDatabaseUserLabelResult',
    'GetDatabaseUserRoleResult',
    'GetDatabaseUserScopeResult',
    'GetDatabaseUsersResultResult',
    'GetDatabaseUsersResultLabelResult',
    'GetDatabaseUsersResultRoleResult',
    'GetDatabaseUsersResultScopeResult',
    'GetEncryptionAtRestAwsKmsConfigResult',
    'GetEncryptionAtRestAzureKeyVaultConfigResult',
    'GetEncryptionAtRestGoogleCloudKmsConfigResult',
    'GetEncryptionAtRestPrivateEndpointsResultResult',
    'GetEventTriggerEventProcessorResult',
    'GetEventTriggerEventProcessorAwsEventbridgeResult',
    'GetEventTriggersResultResult',
    'GetEventTriggersResultEventProcessorResult',
    'GetEventTriggersResultEventProcessorAwsEventbridgeResult',
    'GetFederatedDatabaseInstanceCloudProviderConfigResult',
    'GetFederatedDatabaseInstanceCloudProviderConfigAwResult',
    'GetFederatedDatabaseInstanceCloudProviderConfigAzureResult',
    'GetFederatedDatabaseInstanceDataProcessRegionResult',
    'GetFederatedDatabaseInstanceStorageDatabaseResult',
    'GetFederatedDatabaseInstanceStorageDatabaseCollectionResult',
    'GetFederatedDatabaseInstanceStorageDatabaseCollectionDataSourceResult',
    'GetFederatedDatabaseInstanceStorageDatabaseViewResult',
    'GetFederatedDatabaseInstanceStorageStoreResult',
    'GetFederatedDatabaseInstanceStorageStoreReadPreferenceResult',
    'GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetResult',
    'GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTagResult',
    'GetFederatedDatabaseInstancesResultResult',
    'GetFederatedDatabaseInstancesResultCloudProviderConfigResult',
    'GetFederatedDatabaseInstancesResultCloudProviderConfigAwResult',
    'GetFederatedDatabaseInstancesResultCloudProviderConfigAzureResult',
    'GetFederatedDatabaseInstancesResultDataProcessRegionResult',
    'GetFederatedDatabaseInstancesResultStorageDatabaseResult',
    'GetFederatedDatabaseInstancesResultStorageDatabaseCollectionResult',
    'GetFederatedDatabaseInstancesResultStorageDatabaseCollectionDataSourceResult',
    'GetFederatedDatabaseInstancesResultStorageDatabaseViewResult',
    'GetFederatedDatabaseInstancesResultStorageStoreResult',
    'GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceResult',
    'GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetResult',
    'GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetTagResult',
    'GetFederatedQueryLimitsResultResult',
    'GetFederatedSettingsIdentityProviderAssociatedOrgResult',
    'GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingResult',
    'GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignmentResult',
    'GetFederatedSettingsIdentityProviderAssociatedOrgUserConflictResult',
    'GetFederatedSettingsIdentityProviderPemFileInfoResult',
    'GetFederatedSettingsIdentityProviderPemFileInfoCertificateResult',
    'GetFederatedSettingsIdentityProvidersResultResult',
    'GetFederatedSettingsIdentityProvidersResultAssociatedOrgResult',
    'GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingResult',
    'GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignmentResult',
    'GetFederatedSettingsIdentityProvidersResultAssociatedOrgUserConflictResult',
    'GetFederatedSettingsIdentityProvidersResultPemFileInfoResult',
    'GetFederatedSettingsIdentityProvidersResultPemFileInfoCertificateResult',
    'GetFederatedSettingsOrgConfigRoleMappingResult',
    'GetFederatedSettingsOrgConfigRoleMappingRoleAssignmentResult',
    'GetFederatedSettingsOrgConfigUserConflictResult',
    'GetFederatedSettingsOrgConfigsResultResult',
    'GetFederatedSettingsOrgConfigsResultRoleMappingResult',
    'GetFederatedSettingsOrgConfigsResultRoleMappingRoleAssignmentResult',
    'GetFederatedSettingsOrgConfigsResultUserConflictResult',
    'GetFederatedSettingsOrgRoleMappingRoleAssignmentResult',
    'GetFederatedSettingsOrgRoleMappingsResultResult',
    'GetFederatedSettingsOrgRoleMappingsResultRoleAssignmentResult',
    'GetFlexClusterBackupSettingsResult',
    'GetFlexClusterConnectionStringsResult',
    'GetFlexClusterProviderSettingsResult',
    'GetFlexClustersResultResult',
    'GetFlexClustersResultBackupSettingsResult',
    'GetFlexClustersResultConnectionStringsResult',
    'GetFlexClustersResultProviderSettingsResult',
    'GetFlexRestoreJobsResultResult',
    'GetFlexSnapshotsResultResult',
    'GetGlobalClusterConfigManagedNamespaceResult',
    'GetLdapConfigurationUserToDnMappingResult',
    'GetLdapVerifyLinkResult',
    'GetLdapVerifyValidationResult',
    'GetMaintenanceWindowProtectedHourResult',
    'GetNetworkContainersResultResult',
    'GetNetworkPeeringsResultResult',
    'GetOnlineArchiveCriteriaResult',
    'GetOnlineArchiveDataExpirationRuleResult',
    'GetOnlineArchiveDataProcessRegionResult',
    'GetOnlineArchivePartitionFieldResult',
    'GetOnlineArchiveScheduleResult',
    'GetOnlineArchivesResultResult',
    'GetOnlineArchivesResultCriteriaResult',
    'GetOnlineArchivesResultDataExpirationRuleResult',
    'GetOnlineArchivesResultDataProcessRegionResult',
    'GetOnlineArchivesResultPartitionFieldResult',
    'GetOnlineArchivesResultScheduleResult',
    'GetOrganizationLinkResult',
    'GetOrganizationUserResult',
    'GetOrganizationUserRoleResult',
    'GetOrganizationUserRoleProjectRoleAssignmentResult',
    'GetOrganizationsResultResult',
    'GetOrganizationsResultLinkResult',
    'GetOrganizationsResultUserResult',
    'GetOrganizationsResultUserRoleResult',
    'GetOrganizationsResultUserRoleProjectRoleAssignmentResult',
    'GetPrivateLinkEndpointServiceEndpointResult',
    'GetPrivatelinkEndpointServiceDataFederationOnlineArchivesResultResult',
    'GetProjectApiKeyProjectAssignmentResult',
    'GetProjectApiKeysResultResult',
    'GetProjectApiKeysResultProjectAssignmentResult',
    'GetProjectIpAddressesResult',
    'GetProjectIpAddressesServicesResult',
    'GetProjectIpAddressesServicesClusterResult',
    'GetProjectLimitResult',
    'GetProjectServiceAccountAccessListEntriesResultResult',
    'GetProjectServiceAccountSecretResult',
    'GetProjectServiceAccountsResultResult',
    'GetProjectServiceAccountsResultSecretResult',
    'GetProjectTeamResult',
    'GetProjectUserResult',
    'GetProjectsResultResult',
    'GetProjectsResultIpAddressesResult',
    'GetProjectsResultIpAddressesServicesResult',
    'GetProjectsResultIpAddressesServicesClusterResult',
    'GetProjectsResultLimitResult',
    'GetProjectsResultTeamResult',
    'GetProjectsResultUserResult',
    'GetResourcePoliciesResourcePolicyResult',
    'GetResourcePoliciesResourcePolicyCreatedByUserResult',
    'GetResourcePoliciesResourcePolicyLastUpdatedByUserResult',
    'GetResourcePoliciesResourcePolicyPolicyResult',
    'GetResourcePoliciesResultResult',
    'GetResourcePoliciesResultCreatedByUserResult',
    'GetResourcePoliciesResultLastUpdatedByUserResult',
    'GetResourcePoliciesResultPolicyResult',
    'GetResourcePolicyCreatedByUserResult',
    'GetResourcePolicyLastUpdatedByUserResult',
    'GetResourcePolicyPolicyResult',
    'GetSearchDeploymentSpecResult',
    'GetSearchIndexSynonymResult',
    'GetSearchIndexTypeSetResult',
    'GetSearchIndexesResultResult',
    'GetSearchIndexesResultSynonymResult',
    'GetSearchIndexesResultTypeSetResult',
    'GetServerlessInstanceLinkResult',
    'GetServerlessInstanceTagResult',
    'GetServerlessInstancesResultResult',
    'GetServerlessInstancesResultLinkResult',
    'GetServerlessInstancesResultTagResult',
    'GetServiceAccountAccessListEntriesResultResult',
    'GetServiceAccountProjectAssignmentsResultResult',
    'GetServiceAccountSecretResult',
    'GetServiceAccountsResultResult',
    'GetServiceAccountsResultSecretResult',
    'GetSharedTierRestoreJobsResultResult',
    'GetSharedTierSnapshotsResultResult',
    'GetStreamConnectionAuthenticationResult',
    'GetStreamConnectionAwsResult',
    'GetStreamConnectionDbRoleToExecuteResult',
    'GetStreamConnectionNetworkingResult',
    'GetStreamConnectionNetworkingAccessResult',
    'GetStreamConnectionSchemaRegistryAuthenticationResult',
    'GetStreamConnectionSecurityResult',
    'GetStreamConnectionsResultResult',
    'GetStreamConnectionsResultAuthenticationResult',
    'GetStreamConnectionsResultAwsResult',
    'GetStreamConnectionsResultDbRoleToExecuteResult',
    'GetStreamConnectionsResultNetworkingResult',
    'GetStreamConnectionsResultNetworkingAccessResult',
    'GetStreamConnectionsResultSchemaRegistryAuthenticationResult',
    'GetStreamConnectionsResultSecurityResult',
    'GetStreamInstanceDataProcessRegionResult',
    'GetStreamInstanceStreamConfigResult',
    'GetStreamInstancesResultResult',
    'GetStreamInstancesResultDataProcessRegionResult',
    'GetStreamInstancesResultStreamConfigResult',
    'GetStreamPrivatelinkEndpointsResultResult',
    'GetStreamProcessorOptionsResult',
    'GetStreamProcessorOptionsDlqResult',
    'GetStreamProcessorsResultResult',
    'GetStreamProcessorsResultOptionsResult',
    'GetStreamProcessorsResultOptionsDlqResult',
    'GetStreamWorkspaceDataProcessRegionResult',
    'GetStreamWorkspaceStreamConfigResult',
    'GetStreamWorkspacesResultResult',
    'GetStreamWorkspacesResultDataProcessRegionResult',
    'GetStreamWorkspacesResultStreamConfigResult',
    'GetTeamUserResult',
    'GetTeamUserRoleResult',
    'GetTeamUserRoleProjectRoleAssignmentResult',
    'GetThirdPartyIntegrationsResultResult',
    'GetX509AuthenticationDatabaseUserCertificateResult',
]

@pulumi.output_type
class AdvancedClusterAdvancedConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "changeStreamOptionsPreAndPostImagesExpireAfterSeconds":
            suggest = "change_stream_options_pre_and_post_images_expire_after_seconds"
        elif key == "customOpensslCipherConfigTls12s":
            suggest = "custom_openssl_cipher_config_tls12s"
        elif key == "customOpensslCipherConfigTls13s":
            suggest = "custom_openssl_cipher_config_tls13s"
        elif key == "defaultMaxTimeMs":
            suggest = "default_max_time_ms"
        elif key == "defaultWriteConcern":
            suggest = "default_write_concern"
        elif key == "javascriptEnabled":
            suggest = "javascript_enabled"
        elif key == "minimumEnabledTlsProtocol":
            suggest = "minimum_enabled_tls_protocol"
        elif key == "noTableScan":
            suggest = "no_table_scan"
        elif key == "oplogMinRetentionHours":
            suggest = "oplog_min_retention_hours"
        elif key == "oplogSizeMb":
            suggest = "oplog_size_mb"
        elif key == "sampleRefreshIntervalBiConnector":
            suggest = "sample_refresh_interval_bi_connector"
        elif key == "sampleSizeBiConnector":
            suggest = "sample_size_bi_connector"
        elif key == "tlsCipherConfigMode":
            suggest = "tls_cipher_config_mode"
        elif key == "transactionLifetimeLimitSeconds":
            suggest = "transaction_lifetime_limit_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterAdvancedConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterAdvancedConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterAdvancedConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 change_stream_options_pre_and_post_images_expire_after_seconds: Optional[_builtins.int] = None,
                 custom_openssl_cipher_config_tls12s: Optional[Sequence[_builtins.str]] = None,
                 custom_openssl_cipher_config_tls13s: Optional[Sequence[_builtins.str]] = None,
                 default_max_time_ms: Optional[_builtins.int] = None,
                 default_write_concern: Optional[_builtins.str] = None,
                 javascript_enabled: Optional[_builtins.bool] = None,
                 minimum_enabled_tls_protocol: Optional[_builtins.str] = None,
                 no_table_scan: Optional[_builtins.bool] = None,
                 oplog_min_retention_hours: Optional[_builtins.float] = None,
                 oplog_size_mb: Optional[_builtins.int] = None,
                 sample_refresh_interval_bi_connector: Optional[_builtins.int] = None,
                 sample_size_bi_connector: Optional[_builtins.int] = None,
                 tls_cipher_config_mode: Optional[_builtins.str] = None,
                 transaction_lifetime_limit_seconds: Optional[_builtins.int] = None):
        """
        :param _builtins.int change_stream_options_pre_and_post_images_expire_after_seconds: The minimum pre- and post-image retention time in seconds.
        :param Sequence[_builtins.str] custom_openssl_cipher_config_tls12s: The custom OpenSSL cipher suite list for TLS 1.2. This field is only valid when `tls_cipher_config_mode` is set to `CUSTOM`.
        :param Sequence[_builtins.str] custom_openssl_cipher_config_tls13s: The custom OpenSSL cipher suite list for TLS 1.3. This field is only valid when `tls_cipher_config_mode` is set to `CUSTOM`.
        :param _builtins.int default_max_time_ms: Default time limit in milliseconds for individual read operations to complete. This parameter is supported only for MongoDB version 8.0 and above.
        :param _builtins.str default_write_concern: Default level of acknowledgment requested from MongoDB for write operations when none is specified by the driver.
        :param _builtins.bool javascript_enabled: Flag that indicates whether the cluster allows execution of operations that perform server-side executions of JavaScript. When using 8.0+, we recommend disabling server-side JavaScript and using operators of aggregation pipeline as more performant alternative.
        :param _builtins.str minimum_enabled_tls_protocol: Minimum Transport Layer Security (TLS) version that the cluster accepts for incoming connections. Clusters using TLS 1.0 or 1.1 should consider setting TLS 1.2 as the minimum TLS protocol version.
        :param _builtins.bool no_table_scan: Flag that indicates whether the cluster disables executing any query that requires a collection scan to return results.
        :param _builtins.float oplog_min_retention_hours: Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        :param _builtins.int oplog_size_mb: Storage limit of cluster's oplog expressed in megabytes. A value of null indicates that the cluster uses the default oplog size that MongoDB Cloud calculates.
        :param _builtins.int sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema.
        :param _builtins.int sample_size_bi_connector: Number of documents per database to sample when gathering schema information.
        :param _builtins.str tls_cipher_config_mode: The TLS cipher suite configuration mode. Valid values include `CUSTOM` or `DEFAULT`. The `DEFAULT` mode uses the default cipher suites. The `CUSTOM` mode allows you to specify custom cipher suites for both TLS 1.2 and TLS 1.3. To unset, this should be set back to `DEFAULT`.
        :param _builtins.int transaction_lifetime_limit_seconds: Lifetime, in seconds, of multi-document transactions. Atlas considers the transactions that exceed this limit as expired and so aborts them through a periodic cleanup process.
        """
        if change_stream_options_pre_and_post_images_expire_after_seconds is not None:
            pulumi.set(__self__, "change_stream_options_pre_and_post_images_expire_after_seconds", change_stream_options_pre_and_post_images_expire_after_seconds)
        if custom_openssl_cipher_config_tls12s is not None:
            pulumi.set(__self__, "custom_openssl_cipher_config_tls12s", custom_openssl_cipher_config_tls12s)
        if custom_openssl_cipher_config_tls13s is not None:
            pulumi.set(__self__, "custom_openssl_cipher_config_tls13s", custom_openssl_cipher_config_tls13s)
        if default_max_time_ms is not None:
            pulumi.set(__self__, "default_max_time_ms", default_max_time_ms)
        if default_write_concern is not None:
            pulumi.set(__self__, "default_write_concern", default_write_concern)
        if javascript_enabled is not None:
            pulumi.set(__self__, "javascript_enabled", javascript_enabled)
        if minimum_enabled_tls_protocol is not None:
            pulumi.set(__self__, "minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        if no_table_scan is not None:
            pulumi.set(__self__, "no_table_scan", no_table_scan)
        if oplog_min_retention_hours is not None:
            pulumi.set(__self__, "oplog_min_retention_hours", oplog_min_retention_hours)
        if oplog_size_mb is not None:
            pulumi.set(__self__, "oplog_size_mb", oplog_size_mb)
        if sample_refresh_interval_bi_connector is not None:
            pulumi.set(__self__, "sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        if sample_size_bi_connector is not None:
            pulumi.set(__self__, "sample_size_bi_connector", sample_size_bi_connector)
        if tls_cipher_config_mode is not None:
            pulumi.set(__self__, "tls_cipher_config_mode", tls_cipher_config_mode)
        if transaction_lifetime_limit_seconds is not None:
            pulumi.set(__self__, "transaction_lifetime_limit_seconds", transaction_lifetime_limit_seconds)

    @_builtins.property
    @pulumi.getter(name="changeStreamOptionsPreAndPostImagesExpireAfterSeconds")
    def change_stream_options_pre_and_post_images_expire_after_seconds(self) -> Optional[_builtins.int]:
        """
        The minimum pre- and post-image retention time in seconds.
        """
        return pulumi.get(self, "change_stream_options_pre_and_post_images_expire_after_seconds")

    @_builtins.property
    @pulumi.getter(name="customOpensslCipherConfigTls12s")
    def custom_openssl_cipher_config_tls12s(self) -> Optional[Sequence[_builtins.str]]:
        """
        The custom OpenSSL cipher suite list for TLS 1.2. This field is only valid when `tls_cipher_config_mode` is set to `CUSTOM`.
        """
        return pulumi.get(self, "custom_openssl_cipher_config_tls12s")

    @_builtins.property
    @pulumi.getter(name="customOpensslCipherConfigTls13s")
    def custom_openssl_cipher_config_tls13s(self) -> Optional[Sequence[_builtins.str]]:
        """
        The custom OpenSSL cipher suite list for TLS 1.3. This field is only valid when `tls_cipher_config_mode` is set to `CUSTOM`.
        """
        return pulumi.get(self, "custom_openssl_cipher_config_tls13s")

    @_builtins.property
    @pulumi.getter(name="defaultMaxTimeMs")
    def default_max_time_ms(self) -> Optional[_builtins.int]:
        """
        Default time limit in milliseconds for individual read operations to complete. This parameter is supported only for MongoDB version 8.0 and above.
        """
        return pulumi.get(self, "default_max_time_ms")

    @_builtins.property
    @pulumi.getter(name="defaultWriteConcern")
    def default_write_concern(self) -> Optional[_builtins.str]:
        """
        Default level of acknowledgment requested from MongoDB for write operations when none is specified by the driver.
        """
        return pulumi.get(self, "default_write_concern")

    @_builtins.property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> Optional[_builtins.bool]:
        """
        Flag that indicates whether the cluster allows execution of operations that perform server-side executions of JavaScript. When using 8.0+, we recommend disabling server-side JavaScript and using operators of aggregation pipeline as more performant alternative.
        """
        return pulumi.get(self, "javascript_enabled")

    @_builtins.property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> Optional[_builtins.str]:
        """
        Minimum Transport Layer Security (TLS) version that the cluster accepts for incoming connections. Clusters using TLS 1.0 or 1.1 should consider setting TLS 1.2 as the minimum TLS protocol version.
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @_builtins.property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> Optional[_builtins.bool]:
        """
        Flag that indicates whether the cluster disables executing any query that requires a collection scan to return results.
        """
        return pulumi.get(self, "no_table_scan")

    @_builtins.property
    @pulumi.getter(name="oplogMinRetentionHours")
    def oplog_min_retention_hours(self) -> Optional[_builtins.float]:
        """
        Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        """
        return pulumi.get(self, "oplog_min_retention_hours")

    @_builtins.property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> Optional[_builtins.int]:
        """
        Storage limit of cluster's oplog expressed in megabytes. A value of null indicates that the cluster uses the default oplog size that MongoDB Cloud calculates.
        """
        return pulumi.get(self, "oplog_size_mb")

    @_builtins.property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> Optional[_builtins.int]:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @_builtins.property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> Optional[_builtins.int]:
        """
        Number of documents per database to sample when gathering schema information.
        """
        return pulumi.get(self, "sample_size_bi_connector")

    @_builtins.property
    @pulumi.getter(name="tlsCipherConfigMode")
    def tls_cipher_config_mode(self) -> Optional[_builtins.str]:
        """
        The TLS cipher suite configuration mode. Valid values include `CUSTOM` or `DEFAULT`. The `DEFAULT` mode uses the default cipher suites. The `CUSTOM` mode allows you to specify custom cipher suites for both TLS 1.2 and TLS 1.3. To unset, this should be set back to `DEFAULT`.
        """
        return pulumi.get(self, "tls_cipher_config_mode")

    @_builtins.property
    @pulumi.getter(name="transactionLifetimeLimitSeconds")
    def transaction_lifetime_limit_seconds(self) -> Optional[_builtins.int]:
        """
        Lifetime, in seconds, of multi-document transactions. Atlas considers the transactions that exceed this limit as expired and so aborts them through a periodic cleanup process.
        """
        return pulumi.get(self, "transaction_lifetime_limit_seconds")


@pulumi.output_type
class AdvancedClusterBiConnectorConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readPreference":
            suggest = "read_preference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterBiConnectorConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterBiConnectorConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterBiConnectorConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 read_preference: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Specifies whether or not BI Connector for Atlas is enabled on the cluster.
               *
               - Set to `true` to enable BI Connector for Atlas.
               - Set to `false` to disable BI Connector for Atlas.
        :param _builtins.str read_preference: Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
               
               - Set to "primary" to have BI Connector for Atlas read from the primary.
               
               - Set to "secondary" to have BI Connector for Atlas read from a secondary member. Default if there are no analytics nodes in the cluster.
               
               - Set to "analytics" to have BI Connector for Atlas read from an analytics node. Default if the cluster contains analytics nodes.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if read_preference is not None:
            pulumi.set(__self__, "read_preference", read_preference)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether or not BI Connector for Atlas is enabled on the cluster.
        *
        - Set to `true` to enable BI Connector for Atlas.
        - Set to `false` to disable BI Connector for Atlas.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> Optional[_builtins.str]:
        """
        Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).

        - Set to "primary" to have BI Connector for Atlas read from the primary.

        - Set to "secondary" to have BI Connector for Atlas read from a secondary member. Default if there are no analytics nodes in the cluster.

        - Set to "analytics" to have BI Connector for Atlas read from an analytics node. Default if the cluster contains analytics nodes.
        """
        return pulumi.get(self, "read_preference")


@pulumi.output_type
class AdvancedClusterConnectionStrings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateEndpoints":
            suggest = "private_endpoints"
        elif key == "privateSrv":
            suggest = "private_srv"
        elif key == "standardSrv":
            suggest = "standard_srv"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterConnectionStrings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterConnectionStrings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterConnectionStrings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private: Optional[_builtins.str] = None,
                 private_endpoints: Optional[Sequence['outputs.AdvancedClusterConnectionStringsPrivateEndpoint']] = None,
                 private_srv: Optional[_builtins.str] = None,
                 standard: Optional[_builtins.str] = None,
                 standard_srv: Optional[_builtins.str] = None):
        """
        :param _builtins.str private: [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        :param Sequence['AdvancedClusterConnectionStringsPrivateEndpointArgs'] private_endpoints: Private endpoint connection strings. Each object describes the connection strings you can use to connect to this cluster through a private endpoint. Atlas returns this parameter only if you deployed a private endpoint to all regions to which you deployed this cluster's nodes.
               - `connection_strings.private_endpoint[#].connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
               - `connection_strings.private_endpoint[#].srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in DNS . Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don't need to: Append the seed list or Change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn't, use `connection_strings.private_endpoint[#].connection_string`
               - `connection_strings.private_endpoint[#].srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster support it. If it doesn't, use and consult the documentation for `connection_strings.private_endpoint[#].srv_connection_string`.
               - `connection_strings.private_endpoint[#].type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
               - `connection_strings.private_endpoint[#].endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[#].connection_string` or `connection_strings.private_endpoint[#].srv_connection_string`
               - `connection_strings.private_endpoint[#].endpoints[#].endpoint_id` - Unique identifier of the private endpoint.
               - `connection_strings.private_endpoint[#].endpoints[#].provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
               - `connection_strings.private_endpoint[#].endpoints[#].region` - Region to which you deployed the private endpoint.
        :param _builtins.str private_srv: [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        :param _builtins.str standard: Public mongodb:// connection string for this cluster.
        :param _builtins.str standard_srv: Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t  , use connectionStrings.standard.
        """
        if private is not None:
            pulumi.set(__self__, "private", private)
        if private_endpoints is not None:
            pulumi.set(__self__, "private_endpoints", private_endpoints)
        if private_srv is not None:
            pulumi.set(__self__, "private_srv", private_srv)
        if standard is not None:
            pulumi.set(__self__, "standard", standard)
        if standard_srv is not None:
            pulumi.set(__self__, "standard_srv", standard_srv)

    @_builtins.property
    @pulumi.getter
    def private(self) -> Optional[_builtins.str]:
        """
        [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        """
        return pulumi.get(self, "private")

    @_builtins.property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Optional[Sequence['outputs.AdvancedClusterConnectionStringsPrivateEndpoint']]:
        """
        Private endpoint connection strings. Each object describes the connection strings you can use to connect to this cluster through a private endpoint. Atlas returns this parameter only if you deployed a private endpoint to all regions to which you deployed this cluster's nodes.
        - `connection_strings.private_endpoint[#].connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
        - `connection_strings.private_endpoint[#].srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in DNS . Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don't need to: Append the seed list or Change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn't, use `connection_strings.private_endpoint[#].connection_string`
        - `connection_strings.private_endpoint[#].srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster support it. If it doesn't, use and consult the documentation for `connection_strings.private_endpoint[#].srv_connection_string`.
        - `connection_strings.private_endpoint[#].type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
        - `connection_strings.private_endpoint[#].endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[#].connection_string` or `connection_strings.private_endpoint[#].srv_connection_string`
        - `connection_strings.private_endpoint[#].endpoints[#].endpoint_id` - Unique identifier of the private endpoint.
        - `connection_strings.private_endpoint[#].endpoints[#].provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
        - `connection_strings.private_endpoint[#].endpoints[#].region` - Region to which you deployed the private endpoint.
        """
        return pulumi.get(self, "private_endpoints")

    @_builtins.property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> Optional[_builtins.str]:
        """
        [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        """
        return pulumi.get(self, "private_srv")

    @_builtins.property
    @pulumi.getter
    def standard(self) -> Optional[_builtins.str]:
        """
        Public mongodb:// connection string for this cluster.
        """
        return pulumi.get(self, "standard")

    @_builtins.property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> Optional[_builtins.str]:
        """
        Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t  , use connectionStrings.standard.
        """
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class AdvancedClusterConnectionStringsPrivateEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionString":
            suggest = "connection_string"
        elif key == "srvConnectionString":
            suggest = "srv_connection_string"
        elif key == "srvShardOptimizedConnectionString":
            suggest = "srv_shard_optimized_connection_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterConnectionStringsPrivateEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterConnectionStringsPrivateEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterConnectionStringsPrivateEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_string: Optional[_builtins.str] = None,
                 endpoints: Optional[Sequence['outputs.AdvancedClusterConnectionStringsPrivateEndpointEndpoint']] = None,
                 srv_connection_string: Optional[_builtins.str] = None,
                 srv_shard_optimized_connection_string: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str connection_string: Private endpoint-aware connection string that uses the `mongodb://` protocol to connect to MongoDB Cloud through a private endpoint.
        :param Sequence['AdvancedClusterConnectionStringsPrivateEndpointEndpointArgs'] endpoints: List that contains the private endpoints through which you connect to MongoDB Cloud when you use **connectionStrings.privateEndpoint[n].connectionString** or **connectionStrings.privateEndpoint[n].srvConnectionString**.
        :param _builtins.str srv_connection_string: Private endpoint-aware connection string that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in the Domain Name System (DNS). This list synchronizes with the nodes in a cluster. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to append the seed list or change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application supports it. If it doesn't, use connectionStrings.privateEndpoint[n].connectionString.
        :param _builtins.str srv_shard_optimized_connection_string: Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster supports it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[n].srvConnectionString.
        :param _builtins.str type: MongoDB process type to which your application connects. Use `MONGOD` for replica sets and `MONGOS` for sharded clusters.
        """
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if srv_connection_string is not None:
            pulumi.set(__self__, "srv_connection_string", srv_connection_string)
        if srv_shard_optimized_connection_string is not None:
            pulumi.set(__self__, "srv_shard_optimized_connection_string", srv_shard_optimized_connection_string)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[_builtins.str]:
        """
        Private endpoint-aware connection string that uses the `mongodb://` protocol to connect to MongoDB Cloud through a private endpoint.
        """
        return pulumi.get(self, "connection_string")

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence['outputs.AdvancedClusterConnectionStringsPrivateEndpointEndpoint']]:
        """
        List that contains the private endpoints through which you connect to MongoDB Cloud when you use **connectionStrings.privateEndpoint[n].connectionString** or **connectionStrings.privateEndpoint[n].srvConnectionString**.
        """
        return pulumi.get(self, "endpoints")

    @_builtins.property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> Optional[_builtins.str]:
        """
        Private endpoint-aware connection string that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in the Domain Name System (DNS). This list synchronizes with the nodes in a cluster. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to append the seed list or change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application supports it. If it doesn't, use connectionStrings.privateEndpoint[n].connectionString.
        """
        return pulumi.get(self, "srv_connection_string")

    @_builtins.property
    @pulumi.getter(name="srvShardOptimizedConnectionString")
    def srv_shard_optimized_connection_string(self) -> Optional[_builtins.str]:
        """
        Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster supports it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[n].srvConnectionString.
        """
        return pulumi.get(self, "srv_shard_optimized_connection_string")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        MongoDB process type to which your application connects. Use `MONGOD` for replica sets and `MONGOS` for sharded clusters.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AdvancedClusterConnectionStringsPrivateEndpointEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointId":
            suggest = "endpoint_id"
        elif key == "providerName":
            suggest = "provider_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterConnectionStringsPrivateEndpointEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterConnectionStringsPrivateEndpointEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterConnectionStringsPrivateEndpointEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_id: Optional[_builtins.str] = None,
                 provider_name: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        """
        :param _builtins.str endpoint_id: Unique string that the cloud provider uses to identify the private endpoint.
        :param _builtins.str provider_name: Cloud provider in which MongoDB Cloud deploys the private endpoint.
        :param _builtins.str region: Region where the private endpoint is deployed.
        """
        if endpoint_id is not None:
            pulumi.set(__self__, "endpoint_id", endpoint_id)
        if provider_name is not None:
            pulumi.set(__self__, "provider_name", provider_name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[_builtins.str]:
        """
        Unique string that the cloud provider uses to identify the private endpoint.
        """
        return pulumi.get(self, "endpoint_id")

    @_builtins.property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> Optional[_builtins.str]:
        """
        Cloud provider in which MongoDB Cloud deploys the private endpoint.
        """
        return pulumi.get(self, "provider_name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Region where the private endpoint is deployed.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class AdvancedClusterPinnedFcv(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expirationDate":
            suggest = "expiration_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterPinnedFcv. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterPinnedFcv.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterPinnedFcv.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expiration_date: _builtins.str,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str expiration_date: Expiration date of the fixed FCV. This value is in the ISO 8601 timestamp format (e.g. "2024-12-04T16:25:00Z"). Note that this field cannot exceed 4 weeks from the pinned date.
        :param _builtins.str version: Feature compatibility version of the cluster.
        """
        pulumi.set(__self__, "expiration_date", expiration_date)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> _builtins.str:
        """
        Expiration date of the fixed FCV. This value is in the ISO 8601 timestamp format (e.g. "2024-12-04T16:25:00Z"). Note that this field cannot exceed 4 weeks from the pinned date.
        """
        return pulumi.get(self, "expiration_date")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Feature compatibility version of the cluster.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class AdvancedClusterReplicationSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionConfigs":
            suggest = "region_configs"
        elif key == "containerId":
            suggest = "container_id"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "zoneId":
            suggest = "zone_id"
        elif key == "zoneName":
            suggest = "zone_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterReplicationSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterReplicationSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterReplicationSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region_configs: Sequence['outputs.AdvancedClusterReplicationSpecRegionConfig'],
                 container_id: Optional[Mapping[str, _builtins.str]] = None,
                 external_id: Optional[_builtins.str] = None,
                 zone_id: Optional[_builtins.str] = None,
                 zone_name: Optional[_builtins.str] = None):
        """
        :param Sequence['AdvancedClusterReplicationSpecRegionConfigArgs'] region_configs: Configuration for the hardware specifications for nodes set for a given region. Each `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below.
        :param Mapping[str, _builtins.str] container_id: A key-value map of the Network Peering Container ID(s) for the configuration specified in region_configs. The Container ID is the id of the container created when the first cluster in the region (AWS/Azure) or project (GCP) was created.
        :param _builtins.str external_id: Unique 24-hexadecimal digit string that identifies the replication object for a shard in a Cluster. This value corresponds to Shard ID displayed in the UI.
        :param _builtins.str zone_id: Unique 24-hexadecimal digit string that identifies the zone in a Global Cluster. If clusterType is GEOSHARDED, this value indicates the zone that the given shard belongs to and can be used to configure Global Cluster backup policies.
        :param _builtins.str zone_name: Name for the zone in a Global Cluster.
        """
        pulumi.set(__self__, "region_configs", region_configs)
        if container_id is not None:
            pulumi.set(__self__, "container_id", container_id)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)
        if zone_name is not None:
            pulumi.set(__self__, "zone_name", zone_name)

    @_builtins.property
    @pulumi.getter(name="regionConfigs")
    def region_configs(self) -> Sequence['outputs.AdvancedClusterReplicationSpecRegionConfig']:
        """
        Configuration for the hardware specifications for nodes set for a given region. Each `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below.
        """
        return pulumi.get(self, "region_configs")

    @_builtins.property
    @pulumi.getter(name="containerId")
    def container_id(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A key-value map of the Network Peering Container ID(s) for the configuration specified in region_configs. The Container ID is the id of the container created when the first cluster in the region (AWS/Azure) or project (GCP) was created.
        """
        return pulumi.get(self, "container_id")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        Unique 24-hexadecimal digit string that identifies the replication object for a shard in a Cluster. This value corresponds to Shard ID displayed in the UI.
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        """
        Unique 24-hexadecimal digit string that identifies the zone in a Global Cluster. If clusterType is GEOSHARDED, this value indicates the zone that the given shard belongs to and can be used to configure Global Cluster backup policies.
        """
        return pulumi.get(self, "zone_id")

    @_builtins.property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> Optional[_builtins.str]:
        """
        Name for the zone in a Global Cluster.
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class AdvancedClusterReplicationSpecRegionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "providerName":
            suggest = "provider_name"
        elif key == "regionName":
            suggest = "region_name"
        elif key == "analyticsAutoScaling":
            suggest = "analytics_auto_scaling"
        elif key == "analyticsSpecs":
            suggest = "analytics_specs"
        elif key == "autoScaling":
            suggest = "auto_scaling"
        elif key == "backingProviderName":
            suggest = "backing_provider_name"
        elif key == "electableSpecs":
            suggest = "electable_specs"
        elif key == "readOnlySpecs":
            suggest = "read_only_specs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterReplicationSpecRegionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterReplicationSpecRegionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterReplicationSpecRegionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 priority: _builtins.int,
                 provider_name: _builtins.str,
                 region_name: _builtins.str,
                 analytics_auto_scaling: Optional['outputs.AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling'] = None,
                 analytics_specs: Optional['outputs.AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs'] = None,
                 auto_scaling: Optional['outputs.AdvancedClusterReplicationSpecRegionConfigAutoScaling'] = None,
                 backing_provider_name: Optional[_builtins.str] = None,
                 electable_specs: Optional['outputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecs'] = None,
                 read_only_specs: Optional['outputs.AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs'] = None):
        """
        :param _builtins.int priority: Election priority of the region. For regions with only read-only nodes, set this value to 0.
               * If you have multiple `region_configs` objects (your cluster is multi-region or multi-cloud), they must have priorities in descending order. The highest priority is 7.
               * If your region has set `region_configs[#].electable_specs.node_count` to 1 or higher, it must have a priority of exactly one (1) less than another region in the `replication_specs[#].region_configs[#]` array. The highest-priority region must have a priority of 7. The lowest possible priority is 1.
        :param _builtins.str provider_name: Cloud service provider on which the servers are provisioned.
               The possible values are:
               - `AWS` - Amazon AWS
               - `GCP` - Google Cloud Platform
               - `AZURE` - Microsoft Azure
               - `TENANT` - M0 multi-tenant cluster. Use `replication_specs.[0].region_configs[0].backing_provider_name` to set the cloud service provider.
               - `FLEX` - Flex cluster. Use `replication_specs.[0].region_configs[0].backing_provider_name` to set the cloud service provider.
        :param _builtins.str region_name: Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        :param 'AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingArgs' analytics_auto_scaling: Configuration for the Collection of settings that configures analytics-auto-scaling information for the cluster. The values for the `analytics_auto_scaling` attribute must be the same for all `region_configs` of a cluster. See below.
        :param 'AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgs' analytics_specs: Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. Analytics nodes handle analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only and can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary). If you don't specify this parameter, no analytics nodes deploy to this region. See below.
        :param 'AdvancedClusterReplicationSpecRegionConfigAutoScalingArgs' auto_scaling: Configuration for the collection of settings that configures auto-scaling information for the cluster. The values for the `auto_scaling` attribute must be the same for all `region_configs` of a cluster. See below.
        :param _builtins.str backing_provider_name: Cloud service provider on which you provision the host for a multi-tenant cluster. Use this only when the `provider_name` is `TENANT` and `instance_size` is `M0`, or when the `provider_name` is `FLEX`.
        :param 'AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs' electable_specs: Hardware specifications for electable nodes in the region. All `electable_specs` in the `region_configs` of a `replication_specs` must have the same `instance_size`. Electable nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you do not specify this option, no electable nodes are deployed to the region. See below.
        :param 'AdvancedClusterReplicationSpecRegionConfigReadOnlySpecsArgs' read_only_specs: Hardware specifications for read-only nodes in the region. All `read_only_specs` in the `region_configs` of a `replication_specs` must have the same `instance_size` as `electable_specs`. Read-only nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you don't specify this parameter, no read-only nodes are deployed to the region. See below.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "region_name", region_name)
        if analytics_auto_scaling is not None:
            pulumi.set(__self__, "analytics_auto_scaling", analytics_auto_scaling)
        if analytics_specs is not None:
            pulumi.set(__self__, "analytics_specs", analytics_specs)
        if auto_scaling is not None:
            pulumi.set(__self__, "auto_scaling", auto_scaling)
        if backing_provider_name is not None:
            pulumi.set(__self__, "backing_provider_name", backing_provider_name)
        if electable_specs is not None:
            pulumi.set(__self__, "electable_specs", electable_specs)
        if read_only_specs is not None:
            pulumi.set(__self__, "read_only_specs", read_only_specs)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        Election priority of the region. For regions with only read-only nodes, set this value to 0.
        * If you have multiple `region_configs` objects (your cluster is multi-region or multi-cloud), they must have priorities in descending order. The highest priority is 7.
        * If your region has set `region_configs[#].electable_specs.node_count` to 1 or higher, it must have a priority of exactly one (1) less than another region in the `replication_specs[#].region_configs[#]` array. The highest-priority region must have a priority of 7. The lowest possible priority is 1.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> _builtins.str:
        """
        Cloud service provider on which the servers are provisioned.
        The possible values are:
        - `AWS` - Amazon AWS
        - `GCP` - Google Cloud Platform
        - `AZURE` - Microsoft Azure
        - `TENANT` - M0 multi-tenant cluster. Use `replication_specs.[0].region_configs[0].backing_provider_name` to set the cloud service provider.
        - `FLEX` - Flex cluster. Use `replication_specs.[0].region_configs[0].backing_provider_name` to set the cloud service provider.
        """
        return pulumi.get(self, "provider_name")

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> _builtins.str:
        """
        Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        """
        return pulumi.get(self, "region_name")

    @_builtins.property
    @pulumi.getter(name="analyticsAutoScaling")
    def analytics_auto_scaling(self) -> Optional['outputs.AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling']:
        """
        Configuration for the Collection of settings that configures analytics-auto-scaling information for the cluster. The values for the `analytics_auto_scaling` attribute must be the same for all `region_configs` of a cluster. See below.
        """
        return pulumi.get(self, "analytics_auto_scaling")

    @_builtins.property
    @pulumi.getter(name="analyticsSpecs")
    def analytics_specs(self) -> Optional['outputs.AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs']:
        """
        Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. Analytics nodes handle analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only and can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary). If you don't specify this parameter, no analytics nodes deploy to this region. See below.
        """
        return pulumi.get(self, "analytics_specs")

    @_builtins.property
    @pulumi.getter(name="autoScaling")
    def auto_scaling(self) -> Optional['outputs.AdvancedClusterReplicationSpecRegionConfigAutoScaling']:
        """
        Configuration for the collection of settings that configures auto-scaling information for the cluster. The values for the `auto_scaling` attribute must be the same for all `region_configs` of a cluster. See below.
        """
        return pulumi.get(self, "auto_scaling")

    @_builtins.property
    @pulumi.getter(name="backingProviderName")
    def backing_provider_name(self) -> Optional[_builtins.str]:
        """
        Cloud service provider on which you provision the host for a multi-tenant cluster. Use this only when the `provider_name` is `TENANT` and `instance_size` is `M0`, or when the `provider_name` is `FLEX`.
        """
        return pulumi.get(self, "backing_provider_name")

    @_builtins.property
    @pulumi.getter(name="electableSpecs")
    def electable_specs(self) -> Optional['outputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecs']:
        """
        Hardware specifications for electable nodes in the region. All `electable_specs` in the `region_configs` of a `replication_specs` must have the same `instance_size`. Electable nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you do not specify this option, no electable nodes are deployed to the region. See below.
        """
        return pulumi.get(self, "electable_specs")

    @_builtins.property
    @pulumi.getter(name="readOnlySpecs")
    def read_only_specs(self) -> Optional['outputs.AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs']:
        """
        Hardware specifications for read-only nodes in the region. All `read_only_specs` in the `region_configs` of a `replication_specs` must have the same `instance_size` as `electable_specs`. Read-only nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you don't specify this parameter, no read-only nodes are deployed to the region. See below.
        """
        return pulumi.get(self, "read_only_specs")


@pulumi.output_type
class AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeEnabled":
            suggest = "compute_enabled"
        elif key == "computeMaxInstanceSize":
            suggest = "compute_max_instance_size"
        elif key == "computeMinInstanceSize":
            suggest = "compute_min_instance_size"
        elif key == "computeScaleDownEnabled":
            suggest = "compute_scale_down_enabled"
        elif key == "diskGbEnabled":
            suggest = "disk_gb_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_enabled: Optional[_builtins.bool] = None,
                 compute_max_instance_size: Optional[_builtins.str] = None,
                 compute_min_instance_size: Optional[_builtins.str] = None,
                 compute_scale_down_enabled: Optional[_builtins.bool] = None,
                 disk_gb_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool compute_enabled: Flag that indicates whether analytics instance size auto-scaling is enabled. This parameter defaults to false. If a sharded cluster is making use of the New Sharding Configuration, auto-scaling of analytics instance size will be independent for each individual shard. Please reference the Use Auto-Scaling Per Shard section for more details.
        :param _builtins.str compute_max_instance_size: Maximum instance size to which your cluster can automatically scale (such as M40). Atlas requires this parameter if `replication_specs[#].region_configs[#].analytics_auto_scaling.compute_enabled` is true.
               
               **Note:** The configuration options and considerations for analytics auto-scaling are similar to those described in auto_scaling. When using `use_effective_fields = true`, you can read scaled values using `effective_analytics_specs` in the data source. When not using `use_effective_fields`, you may need lifecycle ignore customizations for `analytics_specs` fields similar to the example shown in the auto_scaling section.
        :param _builtins.str compute_min_instance_size: Minimum instance size to which your cluster can automatically scale (such as M10). Atlas requires this parameter if `replication_specs[#].region_configs[#].analytics_auto_scaling.compute_scale_down_enabled` is true.
        :param _builtins.bool compute_scale_down_enabled: Flag that indicates whether the instance size may scale down. Atlas requires this parameter if `replication_specs[#].region_configs[#].analytics_auto_scaling.compute_enabled` : true. If you enable this option, specify a value for `replication_specs[#].region_configs[#].analytics_auto_scaling.compute_min_instance_size`.
        :param _builtins.bool disk_gb_enabled: Flag that indicates whether this cluster enables disk auto-scaling. This parameter defaults to false.
        """
        if compute_enabled is not None:
            pulumi.set(__self__, "compute_enabled", compute_enabled)
        if compute_max_instance_size is not None:
            pulumi.set(__self__, "compute_max_instance_size", compute_max_instance_size)
        if compute_min_instance_size is not None:
            pulumi.set(__self__, "compute_min_instance_size", compute_min_instance_size)
        if compute_scale_down_enabled is not None:
            pulumi.set(__self__, "compute_scale_down_enabled", compute_scale_down_enabled)
        if disk_gb_enabled is not None:
            pulumi.set(__self__, "disk_gb_enabled", disk_gb_enabled)

    @_builtins.property
    @pulumi.getter(name="computeEnabled")
    def compute_enabled(self) -> Optional[_builtins.bool]:
        """
        Flag that indicates whether analytics instance size auto-scaling is enabled. This parameter defaults to false. If a sharded cluster is making use of the New Sharding Configuration, auto-scaling of analytics instance size will be independent for each individual shard. Please reference the Use Auto-Scaling Per Shard section for more details.
        """
        return pulumi.get(self, "compute_enabled")

    @_builtins.property
    @pulumi.getter(name="computeMaxInstanceSize")
    def compute_max_instance_size(self) -> Optional[_builtins.str]:
        """
        Maximum instance size to which your cluster can automatically scale (such as M40). Atlas requires this parameter if `replication_specs[#].region_configs[#].analytics_auto_scaling.compute_enabled` is true.

        **Note:** The configuration options and considerations for analytics auto-scaling are similar to those described in auto_scaling. When using `use_effective_fields = true`, you can read scaled values using `effective_analytics_specs` in the data source. When not using `use_effective_fields`, you may need lifecycle ignore customizations for `analytics_specs` fields similar to the example shown in the auto_scaling section.
        """
        return pulumi.get(self, "compute_max_instance_size")

    @_builtins.property
    @pulumi.getter(name="computeMinInstanceSize")
    def compute_min_instance_size(self) -> Optional[_builtins.str]:
        """
        Minimum instance size to which your cluster can automatically scale (such as M10). Atlas requires this parameter if `replication_specs[#].region_configs[#].analytics_auto_scaling.compute_scale_down_enabled` is true.
        """
        return pulumi.get(self, "compute_min_instance_size")

    @_builtins.property
    @pulumi.getter(name="computeScaleDownEnabled")
    def compute_scale_down_enabled(self) -> Optional[_builtins.bool]:
        """
        Flag that indicates whether the instance size may scale down. Atlas requires this parameter if `replication_specs[#].region_configs[#].analytics_auto_scaling.compute_enabled` : true. If you enable this option, specify a value for `replication_specs[#].region_configs[#].analytics_auto_scaling.compute_min_instance_size`.
        """
        return pulumi.get(self, "compute_scale_down_enabled")

    @_builtins.property
    @pulumi.getter(name="diskGbEnabled")
    def disk_gb_enabled(self) -> Optional[_builtins.bool]:
        """
        Flag that indicates whether this cluster enables disk auto-scaling. This parameter defaults to false.
        """
        return pulumi.get(self, "disk_gb_enabled")


@pulumi.output_type
class AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskIops":
            suggest = "disk_iops"
        elif key == "diskSizeGb":
            suggest = "disk_size_gb"
        elif key == "ebsVolumeType":
            suggest = "ebs_volume_type"
        elif key == "instanceSize":
            suggest = "instance_size"
        elif key == "nodeCount":
            suggest = "node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_iops: Optional[_builtins.int] = None,
                 disk_size_gb: Optional[_builtins.float] = None,
                 ebs_volume_type: Optional[_builtins.str] = None,
                 instance_size: Optional[_builtins.str] = None,
                 node_count: Optional[_builtins.int] = None):
        """
        :param _builtins.int disk_iops: Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. Define this attribute only if you selected AWS as your cloud service provider, `instance_size` is set to "M30" or greater (not including "Mxx_NVME" tiers), and `ebs_volume_type` is "PROVISIONED". You can't set this attribute for a multi-cloud cluster.
        :param _builtins.float disk_size_gb: Storage capacity that the host's root volume possesses expressed in gigabytes. This value must be equal for all shards and node types. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier. **Note:** Using `disk_size_gb` with Standard IOPS could lead to errors and configuration issues. Therefore, it should be used only with the Provisioned IOPS volume type. When using Provisioned IOPS, the disk_size_gb parameter specifies the storage capacity, but the IOPS are set independently. Ensuring that `disk_size_gb` is used exclusively with Provisioned IOPS will help avoid these issues.
        :param _builtins.str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param _builtins.str instance_size: Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size. Electable nodes and read-only nodes (known as "base nodes") within a single shard must use the same instance size. Analytics nodes can scale independently from base nodes within a shard. Both base nodes and analytics nodes can scale independently from their equivalents in other shards.
        :param _builtins.int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        if disk_iops is not None:
            pulumi.set(__self__, "disk_iops", disk_iops)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if instance_size is not None:
            pulumi.set(__self__, "instance_size", instance_size)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)

    @_builtins.property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[_builtins.int]:
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. Define this attribute only if you selected AWS as your cloud service provider, `instance_size` is set to "M30" or greater (not including "Mxx_NVME" tiers), and `ebs_volume_type` is "PROVISIONED". You can't set this attribute for a multi-cloud cluster.
        """
        return pulumi.get(self, "disk_iops")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[_builtins.float]:
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. This value must be equal for all shards and node types. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier. **Note:** Using `disk_size_gb` with Standard IOPS could lead to errors and configuration issues. Therefore, it should be used only with the Provisioned IOPS volume type. When using Provisioned IOPS, the disk_size_gb parameter specifies the storage capacity, but the IOPS are set independently. Ensuring that `disk_size_gb` is used exclusively with Provisioned IOPS will help avoid these issues.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[_builtins.str]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @_builtins.property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> Optional[_builtins.str]:
        """
        Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size. Electable nodes and read-only nodes (known as "base nodes") within a single shard must use the same instance size. Analytics nodes can scale independently from base nodes within a shard. Both base nodes and analytics nodes can scale independently from their equivalents in other shards.
        """
        return pulumi.get(self, "instance_size")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[_builtins.int]:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class AdvancedClusterReplicationSpecRegionConfigAutoScaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeEnabled":
            suggest = "compute_enabled"
        elif key == "computeMaxInstanceSize":
            suggest = "compute_max_instance_size"
        elif key == "computeMinInstanceSize":
            suggest = "compute_min_instance_size"
        elif key == "computeScaleDownEnabled":
            suggest = "compute_scale_down_enabled"
        elif key == "diskGbEnabled":
            suggest = "disk_gb_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterReplicationSpecRegionConfigAutoScaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterReplicationSpecRegionConfigAutoScaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterReplicationSpecRegionConfigAutoScaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_enabled: Optional[_builtins.bool] = None,
                 compute_max_instance_size: Optional[_builtins.str] = None,
                 compute_min_instance_size: Optional[_builtins.str] = None,
                 compute_scale_down_enabled: Optional[_builtins.bool] = None,
                 disk_gb_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool compute_enabled: Flag that indicates whether instance size auto-scaling is enabled. This parameter defaults to false. If a sharded cluster is making use of the New Sharding Configuration, auto-scaling of the instance size will be independent for each individual shard. Please reference the Use Auto-Scaling Per Shard section for more details.
        :param _builtins.str compute_max_instance_size: Minimum instance size to which your cluster can automatically scale. MongoDB Cloud requires this parameter if `"replicationSpecs[n].regionConfigs[m].autoScaling.compute.scaleDownEnabled" : true`.
        :param _builtins.str compute_min_instance_size: Minimum instance size to which your cluster can automatically scale (such as M10). Atlas requires this parameter if `replication_specs[#].region_configs[#].auto_scaling.compute_scale_down_enabled` is true.
        :param _builtins.bool compute_scale_down_enabled: Flag that indicates whether the instance size may scale down. Atlas requires this parameter if `replication_specs[#].region_configs[#].auto_scaling.compute_enabled` : true. If you enable this option, specify a value for `replication_specs[#].region_configs[#].auto_scaling.compute_min_instance_size`.
        :param _builtins.bool disk_gb_enabled: Flag that indicates whether this cluster enables disk auto-scaling. This parameter defaults to false.
        """
        if compute_enabled is not None:
            pulumi.set(__self__, "compute_enabled", compute_enabled)
        if compute_max_instance_size is not None:
            pulumi.set(__self__, "compute_max_instance_size", compute_max_instance_size)
        if compute_min_instance_size is not None:
            pulumi.set(__self__, "compute_min_instance_size", compute_min_instance_size)
        if compute_scale_down_enabled is not None:
            pulumi.set(__self__, "compute_scale_down_enabled", compute_scale_down_enabled)
        if disk_gb_enabled is not None:
            pulumi.set(__self__, "disk_gb_enabled", disk_gb_enabled)

    @_builtins.property
    @pulumi.getter(name="computeEnabled")
    def compute_enabled(self) -> Optional[_builtins.bool]:
        """
        Flag that indicates whether instance size auto-scaling is enabled. This parameter defaults to false. If a sharded cluster is making use of the New Sharding Configuration, auto-scaling of the instance size will be independent for each individual shard. Please reference the Use Auto-Scaling Per Shard section for more details.
        """
        return pulumi.get(self, "compute_enabled")

    @_builtins.property
    @pulumi.getter(name="computeMaxInstanceSize")
    def compute_max_instance_size(self) -> Optional[_builtins.str]:
        """
        Minimum instance size to which your cluster can automatically scale. MongoDB Cloud requires this parameter if `"replicationSpecs[n].regionConfigs[m].autoScaling.compute.scaleDownEnabled" : true`.
        """
        return pulumi.get(self, "compute_max_instance_size")

    @_builtins.property
    @pulumi.getter(name="computeMinInstanceSize")
    def compute_min_instance_size(self) -> Optional[_builtins.str]:
        """
        Minimum instance size to which your cluster can automatically scale (such as M10). Atlas requires this parameter if `replication_specs[#].region_configs[#].auto_scaling.compute_scale_down_enabled` is true.
        """
        return pulumi.get(self, "compute_min_instance_size")

    @_builtins.property
    @pulumi.getter(name="computeScaleDownEnabled")
    def compute_scale_down_enabled(self) -> Optional[_builtins.bool]:
        """
        Flag that indicates whether the instance size may scale down. Atlas requires this parameter if `replication_specs[#].region_configs[#].auto_scaling.compute_enabled` : true. If you enable this option, specify a value for `replication_specs[#].region_configs[#].auto_scaling.compute_min_instance_size`.
        """
        return pulumi.get(self, "compute_scale_down_enabled")

    @_builtins.property
    @pulumi.getter(name="diskGbEnabled")
    def disk_gb_enabled(self) -> Optional[_builtins.bool]:
        """
        Flag that indicates whether this cluster enables disk auto-scaling. This parameter defaults to false.
        """
        return pulumi.get(self, "disk_gb_enabled")


@pulumi.output_type
class AdvancedClusterReplicationSpecRegionConfigElectableSpecs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskIops":
            suggest = "disk_iops"
        elif key == "diskSizeGb":
            suggest = "disk_size_gb"
        elif key == "ebsVolumeType":
            suggest = "ebs_volume_type"
        elif key == "instanceSize":
            suggest = "instance_size"
        elif key == "nodeCount":
            suggest = "node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterReplicationSpecRegionConfigElectableSpecs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterReplicationSpecRegionConfigElectableSpecs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterReplicationSpecRegionConfigElectableSpecs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_iops: Optional[_builtins.int] = None,
                 disk_size_gb: Optional[_builtins.float] = None,
                 ebs_volume_type: Optional[_builtins.str] = None,
                 instance_size: Optional[_builtins.str] = None,
                 node_count: Optional[_builtins.int] = None):
        """
        :param _builtins.int disk_iops: Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. Define this attribute only if you selected AWS as your cloud service provider, `instance_size` is set to "M30" or greater (not including "Mxx_NVME" tiers), and `ebs_volume_type` is "PROVISIONED". You can't set this attribute for a multi-cloud cluster.
        :param _builtins.float disk_size_gb: Storage capacity that the host's root volume possesses expressed in gigabytes. This value must be equal for all shards and node types. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier. **Note:** Using `disk_size_gb` with Standard IOPS could lead to errors and configuration issues. Therefore, it should be used only with the Provisioned IOPS volume type. When using Provisioned IOPS, the disk_size_gb parameter specifies the storage capacity, but the IOPS are set independently. Ensuring that `disk_size_gb` is used exclusively with Provisioned IOPS will help avoid these issues.
        :param _builtins.str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param _builtins.str instance_size: Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size. Electable nodes and read-only nodes (known as "base nodes") within a single shard must use the same instance size. Analytics nodes can scale independently from base nodes within a shard. Both base nodes and analytics nodes can scale independently from their equivalents in other shards.
        :param _builtins.int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        if disk_iops is not None:
            pulumi.set(__self__, "disk_iops", disk_iops)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if instance_size is not None:
            pulumi.set(__self__, "instance_size", instance_size)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)

    @_builtins.property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[_builtins.int]:
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. Define this attribute only if you selected AWS as your cloud service provider, `instance_size` is set to "M30" or greater (not including "Mxx_NVME" tiers), and `ebs_volume_type` is "PROVISIONED". You can't set this attribute for a multi-cloud cluster.
        """
        return pulumi.get(self, "disk_iops")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[_builtins.float]:
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. This value must be equal for all shards and node types. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier. **Note:** Using `disk_size_gb` with Standard IOPS could lead to errors and configuration issues. Therefore, it should be used only with the Provisioned IOPS volume type. When using Provisioned IOPS, the disk_size_gb parameter specifies the storage capacity, but the IOPS are set independently. Ensuring that `disk_size_gb` is used exclusively with Provisioned IOPS will help avoid these issues.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[_builtins.str]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @_builtins.property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> Optional[_builtins.str]:
        """
        Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size. Electable nodes and read-only nodes (known as "base nodes") within a single shard must use the same instance size. Analytics nodes can scale independently from base nodes within a shard. Both base nodes and analytics nodes can scale independently from their equivalents in other shards.
        """
        return pulumi.get(self, "instance_size")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[_builtins.int]:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskIops":
            suggest = "disk_iops"
        elif key == "diskSizeGb":
            suggest = "disk_size_gb"
        elif key == "ebsVolumeType":
            suggest = "ebs_volume_type"
        elif key == "instanceSize":
            suggest = "instance_size"
        elif key == "nodeCount":
            suggest = "node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_iops: Optional[_builtins.int] = None,
                 disk_size_gb: Optional[_builtins.float] = None,
                 ebs_volume_type: Optional[_builtins.str] = None,
                 instance_size: Optional[_builtins.str] = None,
                 node_count: Optional[_builtins.int] = None):
        """
        :param _builtins.int disk_iops: Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. Define this attribute only if you selected AWS as your cloud service provider, `instance_size` is set to "M30" or greater (not including "Mxx_NVME" tiers), and `ebs_volume_type` is "PROVISIONED". You can't set this attribute for a multi-cloud cluster. This parameter defaults to the cluster tier's standard IOPS value.
        :param _builtins.float disk_size_gb: Storage capacity that the host's root volume possesses expressed in gigabytes. This value must be equal for all shards and node types. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier. **Note:** Using `disk_size_gb` with Standard IOPS could lead to errors and configuration issues. Therefore, it should be used only with the Provisioned IOPS volume type. When using Provisioned IOPS, the disk_size_gb parameter specifies the storage capacity, but the IOPS are set independently. Ensuring that `disk_size_gb` is used exclusively with Provisioned IOPS will help avoid these issues.
        :param _builtins.str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param _builtins.str instance_size: Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size. Electable nodes and read-only nodes (known as "base nodes") within a single shard must use the same instance size. Analytics nodes can scale independently from base nodes within a shard. Both base nodes and analytics nodes can scale independently from their equivalents in other shards.
        :param _builtins.int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        if disk_iops is not None:
            pulumi.set(__self__, "disk_iops", disk_iops)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if instance_size is not None:
            pulumi.set(__self__, "instance_size", instance_size)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)

    @_builtins.property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[_builtins.int]:
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. Define this attribute only if you selected AWS as your cloud service provider, `instance_size` is set to "M30" or greater (not including "Mxx_NVME" tiers), and `ebs_volume_type` is "PROVISIONED". You can't set this attribute for a multi-cloud cluster. This parameter defaults to the cluster tier's standard IOPS value.
        """
        return pulumi.get(self, "disk_iops")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[_builtins.float]:
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. This value must be equal for all shards and node types. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier. **Note:** Using `disk_size_gb` with Standard IOPS could lead to errors and configuration issues. Therefore, it should be used only with the Provisioned IOPS volume type. When using Provisioned IOPS, the disk_size_gb parameter specifies the storage capacity, but the IOPS are set independently. Ensuring that `disk_size_gb` is used exclusively with Provisioned IOPS will help avoid these issues.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[_builtins.str]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @_builtins.property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> Optional[_builtins.str]:
        """
        Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size. Electable nodes and read-only nodes (known as "base nodes") within a single shard must use the same instance size. Analytics nodes can scale independently from base nodes within a shard. Both base nodes and analytics nodes can scale independently from their equivalents in other shards.
        """
        return pulumi.get(self, "instance_size")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[_builtins.int]:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class AdvancedClusterTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: (String) A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Default: `3h`.
        :param _builtins.str delete: (String) A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs. Default: `3h`.
        :param _builtins.str update: (String) A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Default: `3h`.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        (String) A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Default: `3h`.
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        (String) A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs. Default: `3h`.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        (String) A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Default: `3h`.
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class AlertConfigurationMatcher(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertConfigurationMatcher. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertConfigurationMatcher.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertConfigurationMatcher.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: _builtins.str,
                 operator: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str field_name: Name of the field in the target object to match on.
               
               | Host alerts         | Replica set alerts  |  Sharded cluster alerts |
               |:----------           |:-------------       |:------                 |
               | `TYPE_NAME`         | `REPLICA_SET_NAME`  | `CLUSTER_NAME`          |
               | `HOSTNAME`          | `SHARD_NAME`        | `SHARD_NAME`            |
               | `PORT`              | `CLUSTER_NAME`      |                         |
               | `HOSTNAME_AND_PORT` |                     |                         |
               | `REPLICA_SET_NAME`  |                     |                         |
               
               
               
               All other types of alerts do not support matchers.
        :param _builtins.str value: Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
               - `PRIMARY`
               - `SECONDARY`
               - `STANDALONE`
               - `CONFIG`
               - `MONGOS`
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> _builtins.str:
        """
        Name of the field in the target object to match on.

        | Host alerts         | Replica set alerts  |  Sharded cluster alerts |
        |:----------           |:-------------       |:------                 |
        | `TYPE_NAME`         | `REPLICA_SET_NAME`  | `CLUSTER_NAME`          |
        | `HOSTNAME`          | `SHARD_NAME`        | `SHARD_NAME`            |
        | `PORT`              | `CLUSTER_NAME`      |                         |
        | `HOSTNAME_AND_PORT` |                     |                         |
        | `REPLICA_SET_NAME`  |                     |                         |



        All other types of alerts do not support matchers.
        """
        return pulumi.get(self, "field_name")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
        - `PRIMARY`
        - `SECONDARY`
        - `STANDALONE`
        - `CONFIG`
        - `MONGOS`
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AlertConfigurationMetricThresholdConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertConfigurationMetricThresholdConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertConfigurationMetricThresholdConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertConfigurationMetricThresholdConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: _builtins.str,
                 mode: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 threshold: Optional[_builtins.float] = None,
                 units: Optional[_builtins.str] = None):
        """
        :param _builtins.str metric_name: Name of the metric to check. The full list being quite large, please refer to atlas docs [here for general metrics](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types) and [here for serverless metrics](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-create-config/#serverless-measurements)
        :param _builtins.str mode: This must be set to AVERAGE. Atlas computes the current metric value as an average.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if units is not None:
            pulumi.set(__self__, "units", units)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        """
        Name of the metric to check. The full list being quite large, please refer to atlas docs [here for general metrics](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types) and [here for serverless metrics](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-create-config/#serverless-measurements)
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        This must be set to AVERAGE. Atlas computes the current metric value as an average.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def units(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "units")


@pulumi.output_type
class AlertConfigurationNotification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeName":
            suggest = "type_name"
        elif key == "apiToken":
            suggest = "api_token"
        elif key == "channelName":
            suggest = "channel_name"
        elif key == "datadogApiKey":
            suggest = "datadog_api_key"
        elif key == "datadogRegion":
            suggest = "datadog_region"
        elif key == "delayMin":
            suggest = "delay_min"
        elif key == "emailAddress":
            suggest = "email_address"
        elif key == "emailEnabled":
            suggest = "email_enabled"
        elif key == "integrationId":
            suggest = "integration_id"
        elif key == "intervalMin":
            suggest = "interval_min"
        elif key == "microsoftTeamsWebhookUrl":
            suggest = "microsoft_teams_webhook_url"
        elif key == "mobileNumber":
            suggest = "mobile_number"
        elif key == "notifierId":
            suggest = "notifier_id"
        elif key == "opsGenieApiKey":
            suggest = "ops_genie_api_key"
        elif key == "opsGenieRegion":
            suggest = "ops_genie_region"
        elif key == "serviceKey":
            suggest = "service_key"
        elif key == "smsEnabled":
            suggest = "sms_enabled"
        elif key == "teamId":
            suggest = "team_id"
        elif key == "teamName":
            suggest = "team_name"
        elif key == "victorOpsApiKey":
            suggest = "victor_ops_api_key"
        elif key == "victorOpsRoutingKey":
            suggest = "victor_ops_routing_key"
        elif key == "webhookSecret":
            suggest = "webhook_secret"
        elif key == "webhookUrl":
            suggest = "webhook_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertConfigurationNotification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertConfigurationNotification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertConfigurationNotification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type_name: _builtins.str,
                 api_token: Optional[_builtins.str] = None,
                 channel_name: Optional[_builtins.str] = None,
                 datadog_api_key: Optional[_builtins.str] = None,
                 datadog_region: Optional[_builtins.str] = None,
                 delay_min: Optional[_builtins.int] = None,
                 email_address: Optional[_builtins.str] = None,
                 email_enabled: Optional[_builtins.bool] = None,
                 integration_id: Optional[_builtins.str] = None,
                 interval_min: Optional[_builtins.int] = None,
                 microsoft_teams_webhook_url: Optional[_builtins.str] = None,
                 mobile_number: Optional[_builtins.str] = None,
                 notifier_id: Optional[_builtins.str] = None,
                 ops_genie_api_key: Optional[_builtins.str] = None,
                 ops_genie_region: Optional[_builtins.str] = None,
                 roles: Optional[Sequence[_builtins.str]] = None,
                 service_key: Optional[_builtins.str] = None,
                 sms_enabled: Optional[_builtins.bool] = None,
                 team_id: Optional[_builtins.str] = None,
                 team_name: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None,
                 victor_ops_api_key: Optional[_builtins.str] = None,
                 victor_ops_routing_key: Optional[_builtins.str] = None,
                 webhook_secret: Optional[_builtins.str] = None,
                 webhook_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str type_name: Type of alert notification.
               Accepted values are:
               - `DATADOG`
               - `EMAIL`
               - `GROUP` (Project)
               - `OPS_GENIE`
               - `ORG`
               - `PAGER_DUTY`
               - `SLACK`
               - `SMS`
               - `TEAM`
               - `USER`
               - `VICTOR_OPS`
               - `WEBHOOK`
               - `MICROSOFT_TEAMS`
        :param _builtins.str api_token: Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param _builtins.str channel_name: Slack channel name. Required for the SLACK notifications type.
        :param _builtins.str datadog_api_key: Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        :param _builtins.str datadog_region: Region that indicates which API URL to use. See the `datadogRegion` field in the `notifications` request parameter of [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/api/doc/atlas-admin-api-v2/operation/operation-createalertconfiguration) for more details. The default Datadog region is US.
        :param _builtins.int delay_min: Number of minutes to wait after an alert condition is detected before sending out the first notification.
        :param _builtins.str email_address: Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        :param _builtins.bool email_enabled: Flag indicating email notifications should be sent. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        :param _builtins.str integration_id: The ID of the associated integration, the credentials of which to use for requests.
        :param _builtins.int interval_min: Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5. **NOTE** `PAGER_DUTY`, `VICTOR_OPS`, and `OPS_GENIE` notifications do not return this value. The notification interval must be configured and managed within each external service.
        :param _builtins.str microsoft_teams_webhook_url: Microsoft Teams Webhook Uniform Resource Locator (URL) that MongoDB Cloud needs to send this notification via Microsoft Teams. Required if `type_name` is `MICROSOFT_TEAMS`. If the URL later becomes invalid, MongoDB Cloud sends an email to the project owners. If the key remains invalid, MongoDB Cloud removes it.
        :param _builtins.str mobile_number: Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        :param _builtins.str notifier_id: The notifier ID is a system-generated unique identifier assigned to each notification method. This is needed when updating third-party notifications without requiring explicit authentication credentials.
        :param _builtins.str ops_genie_api_key: Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param _builtins.str ops_genie_region: Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        :param Sequence[_builtins.str] roles: Optional. One or more roles that receive the configured alert. If you include this field, Atlas sends alerts only to users assigned the roles you specify in the array. If you omit this field, Atlas sends alerts to users assigned any role. This parameter is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
               Accepted values are:
               
               | Project roles                   | Organization roles  |
               |:----------                      |:-----------         |
               | `GROUP_CLUSTER_MANAGER`         | `ORG_OWNER`         |
               | `GROUP_DATA_ACCESS_ADMIN`       | `ORG_MEMBER`        |
               | `GROUP_DATA_ACCESS_READ_ONLY`   | `ORG_GROUP_CREATOR` |
               | `GROUP_DATA_ACCESS_READ_WRITE`  | `ORG_BILLING_ADMIN` |
               | `GROUP_OWNER`                   | `ORG_READ_ONLY`     |
               | `GROUP_READ_ONLY`               |                     |
        :param _builtins.str service_key: PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param _builtins.bool sms_enabled: Flag indicating if text message notifications should be sent to this user's mobile phone. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        :param _builtins.str team_id: Unique identifier of a team.
        :param _builtins.str team_name: Label for the team that receives this notification.
        :param _builtins.str username: Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        :param _builtins.str victor_ops_api_key: VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param _builtins.str victor_ops_routing_key: VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param _builtins.str webhook_secret: Optional authentication secret for the `WEBHOOK` notifications type.
        :param _builtins.str webhook_url: Target URL  for the `WEBHOOK` notifications type.
        """
        pulumi.set(__self__, "type_name", type_name)
        if api_token is not None:
            pulumi.set(__self__, "api_token", api_token)
        if channel_name is not None:
            pulumi.set(__self__, "channel_name", channel_name)
        if datadog_api_key is not None:
            pulumi.set(__self__, "datadog_api_key", datadog_api_key)
        if datadog_region is not None:
            pulumi.set(__self__, "datadog_region", datadog_region)
        if delay_min is not None:
            pulumi.set(__self__, "delay_min", delay_min)
        if email_address is not None:
            pulumi.set(__self__, "email_address", email_address)
        if email_enabled is not None:
            pulumi.set(__self__, "email_enabled", email_enabled)
        if integration_id is not None:
            pulumi.set(__self__, "integration_id", integration_id)
        if interval_min is not None:
            pulumi.set(__self__, "interval_min", interval_min)
        if microsoft_teams_webhook_url is not None:
            pulumi.set(__self__, "microsoft_teams_webhook_url", microsoft_teams_webhook_url)
        if mobile_number is not None:
            pulumi.set(__self__, "mobile_number", mobile_number)
        if notifier_id is not None:
            pulumi.set(__self__, "notifier_id", notifier_id)
        if ops_genie_api_key is not None:
            pulumi.set(__self__, "ops_genie_api_key", ops_genie_api_key)
        if ops_genie_region is not None:
            pulumi.set(__self__, "ops_genie_region", ops_genie_region)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)
        if service_key is not None:
            pulumi.set(__self__, "service_key", service_key)
        if sms_enabled is not None:
            pulumi.set(__self__, "sms_enabled", sms_enabled)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)
        if team_name is not None:
            pulumi.set(__self__, "team_name", team_name)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if victor_ops_api_key is not None:
            pulumi.set(__self__, "victor_ops_api_key", victor_ops_api_key)
        if victor_ops_routing_key is not None:
            pulumi.set(__self__, "victor_ops_routing_key", victor_ops_routing_key)
        if webhook_secret is not None:
            pulumi.set(__self__, "webhook_secret", webhook_secret)
        if webhook_url is not None:
            pulumi.set(__self__, "webhook_url", webhook_url)

    @_builtins.property
    @pulumi.getter(name="typeName")
    def type_name(self) -> _builtins.str:
        """
        Type of alert notification.
        Accepted values are:
        - `DATADOG`
        - `EMAIL`
        - `GROUP` (Project)
        - `OPS_GENIE`
        - `ORG`
        - `PAGER_DUTY`
        - `SLACK`
        - `SMS`
        - `TEAM`
        - `USER`
        - `VICTOR_OPS`
        - `WEBHOOK`
        - `MICROSOFT_TEAMS`
        """
        return pulumi.get(self, "type_name")

    @_builtins.property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional[_builtins.str]:
        """
        Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "api_token")

    @_builtins.property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> Optional[_builtins.str]:
        """
        Slack channel name. Required for the SLACK notifications type.
        """
        return pulumi.get(self, "channel_name")

    @_builtins.property
    @pulumi.getter(name="datadogApiKey")
    def datadog_api_key(self) -> Optional[_builtins.str]:
        """
        Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        """
        return pulumi.get(self, "datadog_api_key")

    @_builtins.property
    @pulumi.getter(name="datadogRegion")
    def datadog_region(self) -> Optional[_builtins.str]:
        """
        Region that indicates which API URL to use. See the `datadogRegion` field in the `notifications` request parameter of [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/api/doc/atlas-admin-api-v2/operation/operation-createalertconfiguration) for more details. The default Datadog region is US.
        """
        return pulumi.get(self, "datadog_region")

    @_builtins.property
    @pulumi.getter(name="delayMin")
    def delay_min(self) -> Optional[_builtins.int]:
        """
        Number of minutes to wait after an alert condition is detected before sending out the first notification.
        """
        return pulumi.get(self, "delay_min")

    @_builtins.property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> Optional[_builtins.str]:
        """
        Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        """
        return pulumi.get(self, "email_address")

    @_builtins.property
    @pulumi.getter(name="emailEnabled")
    def email_enabled(self) -> Optional[_builtins.bool]:
        """
        Flag indicating email notifications should be sent. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        """
        return pulumi.get(self, "email_enabled")

    @_builtins.property
    @pulumi.getter(name="integrationId")
    def integration_id(self) -> Optional[_builtins.str]:
        """
        The ID of the associated integration, the credentials of which to use for requests.
        """
        return pulumi.get(self, "integration_id")

    @_builtins.property
    @pulumi.getter(name="intervalMin")
    def interval_min(self) -> Optional[_builtins.int]:
        """
        Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5. **NOTE** `PAGER_DUTY`, `VICTOR_OPS`, and `OPS_GENIE` notifications do not return this value. The notification interval must be configured and managed within each external service.
        """
        return pulumi.get(self, "interval_min")

    @_builtins.property
    @pulumi.getter(name="microsoftTeamsWebhookUrl")
    def microsoft_teams_webhook_url(self) -> Optional[_builtins.str]:
        """
        Microsoft Teams Webhook Uniform Resource Locator (URL) that MongoDB Cloud needs to send this notification via Microsoft Teams. Required if `type_name` is `MICROSOFT_TEAMS`. If the URL later becomes invalid, MongoDB Cloud sends an email to the project owners. If the key remains invalid, MongoDB Cloud removes it.
        """
        return pulumi.get(self, "microsoft_teams_webhook_url")

    @_builtins.property
    @pulumi.getter(name="mobileNumber")
    def mobile_number(self) -> Optional[_builtins.str]:
        """
        Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        """
        return pulumi.get(self, "mobile_number")

    @_builtins.property
    @pulumi.getter(name="notifierId")
    def notifier_id(self) -> Optional[_builtins.str]:
        """
        The notifier ID is a system-generated unique identifier assigned to each notification method. This is needed when updating third-party notifications without requiring explicit authentication credentials.
        """
        return pulumi.get(self, "notifier_id")

    @_builtins.property
    @pulumi.getter(name="opsGenieApiKey")
    def ops_genie_api_key(self) -> Optional[_builtins.str]:
        """
        Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "ops_genie_api_key")

    @_builtins.property
    @pulumi.getter(name="opsGenieRegion")
    def ops_genie_region(self) -> Optional[_builtins.str]:
        """
        Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        """
        return pulumi.get(self, "ops_genie_region")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional. One or more roles that receive the configured alert. If you include this field, Atlas sends alerts only to users assigned the roles you specify in the array. If you omit this field, Atlas sends alerts to users assigned any role. This parameter is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        Accepted values are:

        | Project roles                   | Organization roles  |
        |:----------                      |:-----------         |
        | `GROUP_CLUSTER_MANAGER`         | `ORG_OWNER`         |
        | `GROUP_DATA_ACCESS_ADMIN`       | `ORG_MEMBER`        |
        | `GROUP_DATA_ACCESS_READ_ONLY`   | `ORG_GROUP_CREATOR` |
        | `GROUP_DATA_ACCESS_READ_WRITE`  | `ORG_BILLING_ADMIN` |
        | `GROUP_OWNER`                   | `ORG_READ_ONLY`     |
        | `GROUP_READ_ONLY`               |                     |
        """
        return pulumi.get(self, "roles")

    @_builtins.property
    @pulumi.getter(name="serviceKey")
    def service_key(self) -> Optional[_builtins.str]:
        """
        PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "service_key")

    @_builtins.property
    @pulumi.getter(name="smsEnabled")
    def sms_enabled(self) -> Optional[_builtins.bool]:
        """
        Flag indicating if text message notifications should be sent to this user's mobile phone. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        """
        return pulumi.get(self, "sms_enabled")

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of a team.
        """
        return pulumi.get(self, "team_id")

    @_builtins.property
    @pulumi.getter(name="teamName")
    def team_name(self) -> Optional[_builtins.str]:
        """
        Label for the team that receives this notification.
        """
        return pulumi.get(self, "team_name")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="victorOpsApiKey")
    def victor_ops_api_key(self) -> Optional[_builtins.str]:
        """
        VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "victor_ops_api_key")

    @_builtins.property
    @pulumi.getter(name="victorOpsRoutingKey")
    def victor_ops_routing_key(self) -> Optional[_builtins.str]:
        """
        VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "victor_ops_routing_key")

    @_builtins.property
    @pulumi.getter(name="webhookSecret")
    def webhook_secret(self) -> Optional[_builtins.str]:
        """
        Optional authentication secret for the `WEBHOOK` notifications type.
        """
        return pulumi.get(self, "webhook_secret")

    @_builtins.property
    @pulumi.getter(name="webhookUrl")
    def webhook_url(self) -> Optional[_builtins.str]:
        """
        Target URL  for the `WEBHOOK` notifications type.
        """
        return pulumi.get(self, "webhook_url")


@pulumi.output_type
class AlertConfigurationThresholdConfig(dict):
    def __init__(__self__, *,
                 operator: Optional[_builtins.str] = None,
                 threshold: Optional[_builtins.float] = None,
                 units: Optional[_builtins.str] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if units is not None:
            pulumi.set(__self__, "units", units)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def units(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "units")


@pulumi.output_type
class BackupCompliancePolicyOnDemandPolicyItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupCompliancePolicyOnDemandPolicyItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupCompliancePolicyOnDemandPolicyItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupCompliancePolicyOnDemandPolicyItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: _builtins.int,
                 retention_unit: _builtins.str,
                 retention_value: _builtins.int,
                 frequency_type: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param _builtins.str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param _builtins.int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        :param _builtins.str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param _builtins.str id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> _builtins.int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @_builtins.property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> _builtins.str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @_builtins.property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> _builtins.int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")

    @_builtins.property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[_builtins.str]:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class BackupCompliancePolicyPolicyItemDaily(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupCompliancePolicyPolicyItemDaily. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupCompliancePolicyPolicyItemDaily.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupCompliancePolicyPolicyItemDaily.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: _builtins.int,
                 retention_unit: _builtins.str,
                 retention_value: _builtins.int,
                 frequency_type: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param _builtins.str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param _builtins.int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        :param _builtins.str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param _builtins.str id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> _builtins.int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @_builtins.property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> _builtins.str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @_builtins.property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> _builtins.int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")

    @_builtins.property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[_builtins.str]:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class BackupCompliancePolicyPolicyItemHourly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupCompliancePolicyPolicyItemHourly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupCompliancePolicyPolicyItemHourly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupCompliancePolicyPolicyItemHourly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: _builtins.int,
                 retention_unit: _builtins.str,
                 retention_value: _builtins.int,
                 frequency_type: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param _builtins.str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param _builtins.int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        :param _builtins.str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param _builtins.str id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> _builtins.int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @_builtins.property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> _builtins.str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @_builtins.property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> _builtins.int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")

    @_builtins.property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[_builtins.str]:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class BackupCompliancePolicyPolicyItemMonthly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupCompliancePolicyPolicyItemMonthly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupCompliancePolicyPolicyItemMonthly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupCompliancePolicyPolicyItemMonthly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: _builtins.int,
                 retention_unit: _builtins.str,
                 retention_value: _builtins.int,
                 frequency_type: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param _builtins.str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param _builtins.int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        :param _builtins.str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param _builtins.str id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> _builtins.int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @_builtins.property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> _builtins.str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @_builtins.property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> _builtins.int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")

    @_builtins.property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[_builtins.str]:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class BackupCompliancePolicyPolicyItemWeekly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupCompliancePolicyPolicyItemWeekly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupCompliancePolicyPolicyItemWeekly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupCompliancePolicyPolicyItemWeekly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: _builtins.int,
                 retention_unit: _builtins.str,
                 retention_value: _builtins.int,
                 frequency_type: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param _builtins.str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param _builtins.int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        :param _builtins.str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param _builtins.str id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> _builtins.int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @_builtins.property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> _builtins.str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @_builtins.property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> _builtins.int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")

    @_builtins.property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[_builtins.str]:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class BackupCompliancePolicyPolicyItemYearly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupCompliancePolicyPolicyItemYearly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupCompliancePolicyPolicyItemYearly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupCompliancePolicyPolicyItemYearly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: _builtins.int,
                 retention_unit: _builtins.str,
                 retention_value: _builtins.int,
                 frequency_type: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param _builtins.str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param _builtins.int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        :param _builtins.str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param _builtins.str id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> _builtins.int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @_builtins.property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> _builtins.str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @_builtins.property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> _builtins.int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")

    @_builtins.property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[_builtins.str]:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class CloudBackupScheduleCopySetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudProvider":
            suggest = "cloud_provider"
        elif key == "regionName":
            suggest = "region_name"
        elif key == "shouldCopyOplogs":
            suggest = "should_copy_oplogs"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupScheduleCopySetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupScheduleCopySetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupScheduleCopySetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_provider: Optional[_builtins.str] = None,
                 frequencies: Optional[Sequence[_builtins.str]] = None,
                 region_name: Optional[_builtins.str] = None,
                 should_copy_oplogs: Optional[_builtins.bool] = None,
                 zone_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str cloud_provider: Human-readable label that identifies the cloud provider that stores the snapshot copy. i.e. "AWS" "AZURE" "GCP"
        :param Sequence[_builtins.str] frequencies: List that describes which types of snapshots to copy. i.e. "HOURLY" "DAILY" "WEEKLY" "MONTHLY" "ON_DEMAND"
        :param _builtins.str region_name: Target region to copy snapshots belonging to replicationSpecId to. Please supply the 'Atlas Region' which can be found under https://www.mongodb.com/docs/atlas/reference/cloud-providers/ 'regions' link
        :param _builtins.bool should_copy_oplogs: Flag that indicates whether to copy the oplogs to the target region. You can use the oplogs to perform point-in-time restores.
        :param _builtins.str zone_id: Unique 24-hexadecimal digit string that identifies the zone in a cluster. For global clusters, there can be multiple zones to choose from. For sharded clusters and replica set clusters, there is only one zone in the cluster. To find appropriate value for `zone_id`, do a GET request to Return One Cluster from One Project and consult the replicationSpecs array Return One Cluster From One Project. Alternately, use `AdvancedCluster` data source or resource and reference `replication_specs.#.zone_id`.
        """
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if frequencies is not None:
            pulumi.set(__self__, "frequencies", frequencies)
        if region_name is not None:
            pulumi.set(__self__, "region_name", region_name)
        if should_copy_oplogs is not None:
            pulumi.set(__self__, "should_copy_oplogs", should_copy_oplogs)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[_builtins.str]:
        """
        Human-readable label that identifies the cloud provider that stores the snapshot copy. i.e. "AWS" "AZURE" "GCP"
        """
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter
    def frequencies(self) -> Optional[Sequence[_builtins.str]]:
        """
        List that describes which types of snapshots to copy. i.e. "HOURLY" "DAILY" "WEEKLY" "MONTHLY" "ON_DEMAND"
        """
        return pulumi.get(self, "frequencies")

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> Optional[_builtins.str]:
        """
        Target region to copy snapshots belonging to replicationSpecId to. Please supply the 'Atlas Region' which can be found under https://www.mongodb.com/docs/atlas/reference/cloud-providers/ 'regions' link
        """
        return pulumi.get(self, "region_name")

    @_builtins.property
    @pulumi.getter(name="shouldCopyOplogs")
    def should_copy_oplogs(self) -> Optional[_builtins.bool]:
        """
        Flag that indicates whether to copy the oplogs to the target region. You can use the oplogs to perform point-in-time restores.
        """
        return pulumi.get(self, "should_copy_oplogs")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[_builtins.str]:
        """
        Unique 24-hexadecimal digit string that identifies the zone in a cluster. For global clusters, there can be multiple zones to choose from. For sharded clusters and replica set clusters, there is only one zone in the cluster. To find appropriate value for `zone_id`, do a GET request to Return One Cluster from One Project and consult the replicationSpecs array Return One Cluster From One Project. Alternately, use `AdvancedCluster` data source or resource and reference `replication_specs.#.zone_id`.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class CloudBackupScheduleExport(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportBucketId":
            suggest = "export_bucket_id"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupScheduleExport. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupScheduleExport.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupScheduleExport.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_bucket_id: Optional[_builtins.str] = None,
                 frequency_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str export_bucket_id: Unique identifier of the CloudBackupSnapshotExportBucket export_bucket_id value.
        :param _builtins.str frequency_type: Frequency associated with the export snapshot item: `weekly`, `monthly`, `yearly`, `daily` (requires reaching out to Customer Support)
        """
        if export_bucket_id is not None:
            pulumi.set(__self__, "export_bucket_id", export_bucket_id)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)

    @_builtins.property
    @pulumi.getter(name="exportBucketId")
    def export_bucket_id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the CloudBackupSnapshotExportBucket export_bucket_id value.
        """
        return pulumi.get(self, "export_bucket_id")

    @_builtins.property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[_builtins.str]:
        """
        Frequency associated with the export snapshot item: `weekly`, `monthly`, `yearly`, `daily` (requires reaching out to Customer Support)
        """
        return pulumi.get(self, "frequency_type")


@pulumi.output_type
class CloudBackupSchedulePolicyItemDaily(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSchedulePolicyItemDaily. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSchedulePolicyItemDaily.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSchedulePolicyItemDaily.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: _builtins.int,
                 retention_unit: _builtins.str,
                 retention_value: _builtins.int,
                 frequency_type: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (daily in this case). The only supported value for daily policies is `1` day.
        :param _builtins.str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param _builtins.int retention_value: Value to associate with `retention_unit`.  Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the hourly policy item specifies a retention of two days, the daily retention policy must specify two days or greater.
        :param _builtins.str frequency_type: Frequency associated with the backup policy item. For daily policies, the frequency type is defined as `daily`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param _builtins.str id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> _builtins.int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (daily in this case). The only supported value for daily policies is `1` day.
        """
        return pulumi.get(self, "frequency_interval")

    @_builtins.property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> _builtins.str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @_builtins.property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> _builtins.int:
        """
        Value to associate with `retention_unit`.  Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the hourly policy item specifies a retention of two days, the daily retention policy must specify two days or greater.
        """
        return pulumi.get(self, "retention_value")

    @_builtins.property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[_builtins.str]:
        """
        Frequency associated with the backup policy item. For daily policies, the frequency type is defined as `daily`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class CloudBackupSchedulePolicyItemHourly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSchedulePolicyItemHourly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSchedulePolicyItemHourly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSchedulePolicyItemHourly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: _builtins.int,
                 retention_unit: _builtins.str,
                 retention_value: _builtins.int,
                 frequency_type: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (hourly in this case). The supported values for hourly policies are `1`, `2`, `4`, `6`, `8` or `12` hours. Note that `12` hours is the only accepted value for NVMe clusters.
        :param _builtins.str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param _builtins.int retention_value: Value to associate with `retention_unit`.
        :param _builtins.str frequency_type: Frequency associated with the backup policy item. For hourly policies, the frequency type is defined as `hourly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param _builtins.str id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> _builtins.int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (hourly in this case). The supported values for hourly policies are `1`, `2`, `4`, `6`, `8` or `12` hours. Note that `12` hours is the only accepted value for NVMe clusters.
        """
        return pulumi.get(self, "frequency_interval")

    @_builtins.property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> _builtins.str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @_builtins.property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> _builtins.int:
        """
        Value to associate with `retention_unit`.
        """
        return pulumi.get(self, "retention_value")

    @_builtins.property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[_builtins.str]:
        """
        Frequency associated with the backup policy item. For hourly policies, the frequency type is defined as `hourly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class CloudBackupSchedulePolicyItemMonthly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSchedulePolicyItemMonthly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSchedulePolicyItemMonthly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSchedulePolicyItemMonthly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: _builtins.int,
                 retention_unit: _builtins.str,
                 retention_value: _builtins.int,
                 frequency_type: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        :param _builtins.str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param _builtins.int retention_value: Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        :param _builtins.str frequency_type: Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param _builtins.str id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> _builtins.int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @_builtins.property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> _builtins.str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @_builtins.property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> _builtins.int:
        """
        Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        """
        return pulumi.get(self, "retention_value")

    @_builtins.property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[_builtins.str]:
        """
        Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class CloudBackupSchedulePolicyItemWeekly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSchedulePolicyItemWeekly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSchedulePolicyItemWeekly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSchedulePolicyItemWeekly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: _builtins.int,
                 retention_unit: _builtins.str,
                 retention_value: _builtins.int,
                 frequency_type: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (weekly in this case). The supported values for weekly policies are `1` through `7`, where `1` represents Monday and `7` represents Sunday.
        :param _builtins.str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param _builtins.int retention_value: Value to associate with `retention_unit`. Weekly policy must have retention of at least 7 days or 1 week. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the daily policy item specifies a retention of two weeks, the weekly retention policy must specify two weeks or greater.
        :param _builtins.str frequency_type: Frequency associated with the backup policy item. For weekly policies, the frequency type is defined as `weekly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param _builtins.str id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> _builtins.int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (weekly in this case). The supported values for weekly policies are `1` through `7`, where `1` represents Monday and `7` represents Sunday.
        """
        return pulumi.get(self, "frequency_interval")

    @_builtins.property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> _builtins.str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @_builtins.property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> _builtins.int:
        """
        Value to associate with `retention_unit`. Weekly policy must have retention of at least 7 days or 1 week. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the daily policy item specifies a retention of two weeks, the weekly retention policy must specify two weeks or greater.
        """
        return pulumi.get(self, "retention_value")

    @_builtins.property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[_builtins.str]:
        """
        Frequency associated with the backup policy item. For weekly policies, the frequency type is defined as `weekly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class CloudBackupSchedulePolicyItemYearly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSchedulePolicyItemYearly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSchedulePolicyItemYearly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSchedulePolicyItemYearly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: _builtins.int,
                 retention_unit: _builtins.str,
                 retention_value: _builtins.int,
                 frequency_type: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param _builtins.str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param _builtins.int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        :param _builtins.str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param _builtins.str id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> _builtins.int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @_builtins.property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> _builtins.str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @_builtins.property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> _builtins.int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")

    @_builtins.property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[_builtins.str]:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class CloudBackupSnapshotExportJobComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportId":
            suggest = "export_id"
        elif key == "replicaSetName":
            suggest = "replica_set_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSnapshotExportJobComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSnapshotExportJobComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSnapshotExportJobComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_id: Optional[_builtins.str] = None,
                 replica_set_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str export_id: _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        :param _builtins.str replica_set_name: _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
        if export_id is not None:
            pulumi.set(__self__, "export_id", export_id)
        if replica_set_name is not None:
            pulumi.set(__self__, "replica_set_name", replica_set_name)

    @_builtins.property
    @pulumi.getter(name="exportId")
    def export_id(self) -> Optional[_builtins.str]:
        """
        _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        """
        return pulumi.get(self, "export_id")

    @_builtins.property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> Optional[_builtins.str]:
        """
        _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
        return pulumi.get(self, "replica_set_name")


@pulumi.output_type
class CloudBackupSnapshotExportJobCustomData(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Required if you want to include custom data using `custom_data` in the metadata file uploaded to the bucket. Key to include in the metadata file that Atlas uploads to the bucket when the export job finishes.
        :param _builtins.str value: Required if you specify `key`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Required if you want to include custom data using `custom_data` in the metadata file uploaded to the bucket. Key to include in the metadata file that Atlas uploads to the bucket when the export job finishes.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Required if you specify `key`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CloudBackupSnapshotMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudProvider":
            suggest = "cloud_provider"
        elif key == "replicaSetName":
            suggest = "replica_set_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSnapshotMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSnapshotMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSnapshotMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_provider: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 replica_set_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str cloud_provider: Cloud provider that stores this snapshot.
        :param _builtins.str id: Unique identifier for the sharded cluster snapshot.
        :param _builtins.str replica_set_name: Label given to a shard or config server from which Atlas took this snapshot.
        """
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if replica_set_name is not None:
            pulumi.set(__self__, "replica_set_name", replica_set_name)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[_builtins.str]:
        """
        Cloud provider that stores this snapshot.
        """
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier for the sharded cluster snapshot.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> Optional[_builtins.str]:
        """
        Label given to a shard or config server from which Atlas took this snapshot.
        """
        return pulumi.get(self, "replica_set_name")


@pulumi.output_type
class CloudBackupSnapshotRestoreJobDeliveryTypeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oplogInc":
            suggest = "oplog_inc"
        elif key == "oplogTs":
            suggest = "oplog_ts"
        elif key == "pointInTime":
            suggest = "point_in_time"
        elif key == "pointInTimeUtcSeconds":
            suggest = "point_in_time_utc_seconds"
        elif key == "targetClusterName":
            suggest = "target_cluster_name"
        elif key == "targetProjectId":
            suggest = "target_project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSnapshotRestoreJobDeliveryTypeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSnapshotRestoreJobDeliveryTypeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSnapshotRestoreJobDeliveryTypeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automated: Optional[_builtins.bool] = None,
                 download: Optional[_builtins.bool] = None,
                 oplog_inc: Optional[_builtins.int] = None,
                 oplog_ts: Optional[_builtins.int] = None,
                 point_in_time: Optional[_builtins.bool] = None,
                 point_in_time_utc_seconds: Optional[_builtins.int] = None,
                 target_cluster_name: Optional[_builtins.str] = None,
                 target_project_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str target_cluster_name: Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.
        :param _builtins.str target_project_id: Name of the target Atlas project of the restore job. Only visible if deliveryType is automated.
        """
        if automated is not None:
            pulumi.set(__self__, "automated", automated)
        if download is not None:
            pulumi.set(__self__, "download", download)
        if oplog_inc is not None:
            pulumi.set(__self__, "oplog_inc", oplog_inc)
        if oplog_ts is not None:
            pulumi.set(__self__, "oplog_ts", oplog_ts)
        if point_in_time is not None:
            pulumi.set(__self__, "point_in_time", point_in_time)
        if point_in_time_utc_seconds is not None:
            pulumi.set(__self__, "point_in_time_utc_seconds", point_in_time_utc_seconds)
        if target_cluster_name is not None:
            pulumi.set(__self__, "target_cluster_name", target_cluster_name)
        if target_project_id is not None:
            pulumi.set(__self__, "target_project_id", target_project_id)

    @_builtins.property
    @pulumi.getter
    def automated(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "automated")

    @_builtins.property
    @pulumi.getter
    def download(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "download")

    @_builtins.property
    @pulumi.getter(name="oplogInc")
    def oplog_inc(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "oplog_inc")

    @_builtins.property
    @pulumi.getter(name="oplogTs")
    def oplog_ts(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "oplog_ts")

    @_builtins.property
    @pulumi.getter(name="pointInTime")
    def point_in_time(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "point_in_time")

    @_builtins.property
    @pulumi.getter(name="pointInTimeUtcSeconds")
    def point_in_time_utc_seconds(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "point_in_time_utc_seconds")

    @_builtins.property
    @pulumi.getter(name="targetClusterName")
    def target_cluster_name(self) -> Optional[_builtins.str]:
        """
        Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.
        """
        return pulumi.get(self, "target_cluster_name")

    @_builtins.property
    @pulumi.getter(name="targetProjectId")
    def target_project_id(self) -> Optional[_builtins.str]:
        """
        Name of the target Atlas project of the restore job. Only visible if deliveryType is automated.
        """
        return pulumi.get(self, "target_project_id")


@pulumi.output_type
class CloudProviderAccessAuthorizationAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iamAssumedRoleArn":
            suggest = "iam_assumed_role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudProviderAccessAuthorizationAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudProviderAccessAuthorizationAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudProviderAccessAuthorizationAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iam_assumed_role_arn: _builtins.str):
        """
        :param _builtins.str iam_assumed_role_arn: ARN of the IAM Role that Atlas assumes when accessing resources in your AWS account. This value is required after the creation (register of the role) as part of [Set Up Unified AWS Access](https://docs.atlas.mongodb.com/security/set-up-unified-aws-access/#set-up-unified-aws-access).
        """
        pulumi.set(__self__, "iam_assumed_role_arn", iam_assumed_role_arn)

    @_builtins.property
    @pulumi.getter(name="iamAssumedRoleArn")
    def iam_assumed_role_arn(self) -> _builtins.str:
        """
        ARN of the IAM Role that Atlas assumes when accessing resources in your AWS account. This value is required after the creation (register of the role) as part of [Set Up Unified AWS Access](https://docs.atlas.mongodb.com/security/set-up-unified-aws-access/#set-up-unified-aws-access).
        """
        return pulumi.get(self, "iam_assumed_role_arn")


@pulumi.output_type
class CloudProviderAccessAuthorizationAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "atlasAzureAppId":
            suggest = "atlas_azure_app_id"
        elif key == "servicePrincipalId":
            suggest = "service_principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudProviderAccessAuthorizationAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudProviderAccessAuthorizationAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudProviderAccessAuthorizationAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 atlas_azure_app_id: _builtins.str,
                 service_principal_id: _builtins.str,
                 tenant_id: _builtins.str):
        """
        :param _builtins.str atlas_azure_app_id: Azure Active Directory Application ID of Atlas.
        :param _builtins.str service_principal_id: UUID string that identifies the Azure Service Principal.
        :param _builtins.str tenant_id: UUID String that identifies the Azure Active Directory Tenant ID.
        """
        pulumi.set(__self__, "atlas_azure_app_id", atlas_azure_app_id)
        pulumi.set(__self__, "service_principal_id", service_principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="atlasAzureAppId")
    def atlas_azure_app_id(self) -> _builtins.str:
        """
        Azure Active Directory Application ID of Atlas.
        """
        return pulumi.get(self, "atlas_azure_app_id")

    @_builtins.property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> _builtins.str:
        """
        UUID string that identifies the Azure Service Principal.
        """
        return pulumi.get(self, "service_principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        UUID String that identifies the Azure Active Directory Tenant ID.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class CloudProviderAccessAuthorizationFeatureUsage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "featureId":
            suggest = "feature_id"
        elif key == "featureType":
            suggest = "feature_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudProviderAccessAuthorizationFeatureUsage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudProviderAccessAuthorizationFeatureUsage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudProviderAccessAuthorizationFeatureUsage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 feature_id: Optional[Mapping[str, _builtins.str]] = None,
                 feature_type: Optional[_builtins.str] = None):
        if feature_id is not None:
            pulumi.set(__self__, "feature_id", feature_id)
        if feature_type is not None:
            pulumi.set(__self__, "feature_type", feature_type)

    @_builtins.property
    @pulumi.getter(name="featureId")
    def feature_id(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "feature_id")

    @_builtins.property
    @pulumi.getter(name="featureType")
    def feature_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "feature_type")


@pulumi.output_type
class CloudProviderAccessAuthorizationGcp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountForAtlas":
            suggest = "service_account_for_atlas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudProviderAccessAuthorizationGcp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudProviderAccessAuthorizationGcp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudProviderAccessAuthorizationGcp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_account_for_atlas: Optional[_builtins.str] = None):
        """
        :param _builtins.str service_account_for_atlas: Email address for the Google Service Account created by Atlas.
        """
        if service_account_for_atlas is not None:
            pulumi.set(__self__, "service_account_for_atlas", service_account_for_atlas)

    @_builtins.property
    @pulumi.getter(name="serviceAccountForAtlas")
    def service_account_for_atlas(self) -> Optional[_builtins.str]:
        """
        Email address for the Google Service Account created by Atlas.
        """
        return pulumi.get(self, "service_account_for_atlas")


@pulumi.output_type
class CloudProviderAccessSetupAwsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "atlasAssumedRoleExternalId":
            suggest = "atlas_assumed_role_external_id"
        elif key == "atlasAwsAccountArn":
            suggest = "atlas_aws_account_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudProviderAccessSetupAwsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudProviderAccessSetupAwsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudProviderAccessSetupAwsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 atlas_assumed_role_external_id: Optional[_builtins.str] = None,
                 atlas_aws_account_arn: Optional[_builtins.str] = None):
        """
        :param _builtins.str atlas_assumed_role_external_id: Unique external ID Atlas uses when assuming the IAM role in your AWS account.
        :param _builtins.str atlas_aws_account_arn: ARN associated with the Atlas AWS account used to assume IAM roles in your AWS account.
        """
        if atlas_assumed_role_external_id is not None:
            pulumi.set(__self__, "atlas_assumed_role_external_id", atlas_assumed_role_external_id)
        if atlas_aws_account_arn is not None:
            pulumi.set(__self__, "atlas_aws_account_arn", atlas_aws_account_arn)

    @_builtins.property
    @pulumi.getter(name="atlasAssumedRoleExternalId")
    def atlas_assumed_role_external_id(self) -> Optional[_builtins.str]:
        """
        Unique external ID Atlas uses when assuming the IAM role in your AWS account.
        """
        return pulumi.get(self, "atlas_assumed_role_external_id")

    @_builtins.property
    @pulumi.getter(name="atlasAwsAccountArn")
    def atlas_aws_account_arn(self) -> Optional[_builtins.str]:
        """
        ARN associated with the Atlas AWS account used to assume IAM roles in your AWS account.
        """
        return pulumi.get(self, "atlas_aws_account_arn")


@pulumi.output_type
class CloudProviderAccessSetupAzureConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "atlasAzureAppId":
            suggest = "atlas_azure_app_id"
        elif key == "servicePrincipalId":
            suggest = "service_principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudProviderAccessSetupAzureConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudProviderAccessSetupAzureConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudProviderAccessSetupAzureConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 atlas_azure_app_id: _builtins.str,
                 service_principal_id: _builtins.str,
                 tenant_id: _builtins.str):
        """
        :param _builtins.str atlas_azure_app_id: Azure Active Directory Application ID of Atlas. This property is required when `provider_name = "AZURE".`
        :param _builtins.str service_principal_id: UUID string that identifies the Azure Service Principal. This property is required when `provider_name = "AZURE".`
        :param _builtins.str tenant_id: UUID String that identifies the Azure Active Directory Tenant ID. This property is required when `provider_name = "AZURE".`
        """
        pulumi.set(__self__, "atlas_azure_app_id", atlas_azure_app_id)
        pulumi.set(__self__, "service_principal_id", service_principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="atlasAzureAppId")
    def atlas_azure_app_id(self) -> _builtins.str:
        """
        Azure Active Directory Application ID of Atlas. This property is required when `provider_name = "AZURE".`
        """
        return pulumi.get(self, "atlas_azure_app_id")

    @_builtins.property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> _builtins.str:
        """
        UUID string that identifies the Azure Service Principal. This property is required when `provider_name = "AZURE".`
        """
        return pulumi.get(self, "service_principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        UUID String that identifies the Azure Active Directory Tenant ID. This property is required when `provider_name = "AZURE".`
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class CloudProviderAccessSetupGcpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccountForAtlas":
            suggest = "service_account_for_atlas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudProviderAccessSetupGcpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudProviderAccessSetupGcpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudProviderAccessSetupGcpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_account_for_atlas: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None):
        """
        :param _builtins.str service_account_for_atlas: The GCP service account email that Atlas uses.
        :param _builtins.str status: The status of the GCP cloud provider access setup. See [MongoDB Atlas API](https://www.mongodb.com/docs/api/doc/atlas-admin-api-v2/operation/operation-getgroupcloudprovideraccess#operation-getgroupcloudprovideraccess-200-body-application-vnd-atlas-2023-01-01-json-gcp-object-status).
        """
        if service_account_for_atlas is not None:
            pulumi.set(__self__, "service_account_for_atlas", service_account_for_atlas)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="serviceAccountForAtlas")
    def service_account_for_atlas(self) -> Optional[_builtins.str]:
        """
        The GCP service account email that Atlas uses.
        """
        return pulumi.get(self, "service_account_for_atlas")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        The status of the GCP cloud provider access setup. See [MongoDB Atlas API](https://www.mongodb.com/docs/api/doc/atlas-admin-api-v2/operation/operation-getgroupcloudprovideraccess#operation-getgroupcloudprovideraccess-200-body-application-vnd-atlas-2023-01-01-json-gcp-object-status).
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class CloudUserOrgAssignmentRoles(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "orgRoles":
            suggest = "org_roles"
        elif key == "projectRoleAssignments":
            suggest = "project_role_assignments"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudUserOrgAssignmentRoles. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudUserOrgAssignmentRoles.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudUserOrgAssignmentRoles.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 org_roles: Optional[Sequence[_builtins.str]] = None,
                 project_role_assignments: Optional[Sequence['outputs.CloudUserOrgAssignmentRolesProjectRoleAssignment']] = None):
        """
        :param Sequence[_builtins.str] org_roles: One or more organization level roles to assign the MongoDB Cloud user.
        :param Sequence['CloudUserOrgAssignmentRolesProjectRoleAssignmentArgs'] project_role_assignments: List of project level role assignments to assign the MongoDB Cloud user.
        """
        if org_roles is not None:
            pulumi.set(__self__, "org_roles", org_roles)
        if project_role_assignments is not None:
            pulumi.set(__self__, "project_role_assignments", project_role_assignments)

    @_builtins.property
    @pulumi.getter(name="orgRoles")
    def org_roles(self) -> Optional[Sequence[_builtins.str]]:
        """
        One or more organization level roles to assign the MongoDB Cloud user.
        """
        return pulumi.get(self, "org_roles")

    @_builtins.property
    @pulumi.getter(name="projectRoleAssignments")
    def project_role_assignments(self) -> Optional[Sequence['outputs.CloudUserOrgAssignmentRolesProjectRoleAssignment']]:
        """
        List of project level role assignments to assign the MongoDB Cloud user.
        """
        return pulumi.get(self, "project_role_assignments")


@pulumi.output_type
class CloudUserOrgAssignmentRolesProjectRoleAssignment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"
        elif key == "projectRoles":
            suggest = "project_roles"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudUserOrgAssignmentRolesProjectRoleAssignment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudUserOrgAssignmentRolesProjectRoleAssignment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudUserOrgAssignmentRolesProjectRoleAssignment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_id: Optional[_builtins.str] = None,
                 project_roles: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str project_id: Unique 24-hexadecimal digit string that identifies the project to which these roles belong.
        :param Sequence[_builtins.str] project_roles: One or more project-level roles assigned to the MongoDB Cloud user.
        """
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if project_roles is not None:
            pulumi.set(__self__, "project_roles", project_roles)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        Unique 24-hexadecimal digit string that identifies the project to which these roles belong.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="projectRoles")
    def project_roles(self) -> Optional[Sequence[_builtins.str]]:
        """
        One or more project-level roles assigned to the MongoDB Cloud user.
        """
        return pulumi.get(self, "project_roles")


@pulumi.output_type
class CloudUserTeamAssignmentRoles(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "orgRoles":
            suggest = "org_roles"
        elif key == "projectRoleAssignments":
            suggest = "project_role_assignments"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudUserTeamAssignmentRoles. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudUserTeamAssignmentRoles.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudUserTeamAssignmentRoles.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 org_roles: Optional[Sequence[_builtins.str]] = None,
                 project_role_assignments: Optional[Sequence['outputs.CloudUserTeamAssignmentRolesProjectRoleAssignment']] = None):
        """
        :param Sequence[_builtins.str] org_roles: One or more organization level roles to assign the MongoDB Cloud user.
        :param Sequence['CloudUserTeamAssignmentRolesProjectRoleAssignmentArgs'] project_role_assignments: List of project level role assignments to assign the MongoDB Cloud user.
        """
        if org_roles is not None:
            pulumi.set(__self__, "org_roles", org_roles)
        if project_role_assignments is not None:
            pulumi.set(__self__, "project_role_assignments", project_role_assignments)

    @_builtins.property
    @pulumi.getter(name="orgRoles")
    def org_roles(self) -> Optional[Sequence[_builtins.str]]:
        """
        One or more organization level roles to assign the MongoDB Cloud user.
        """
        return pulumi.get(self, "org_roles")

    @_builtins.property
    @pulumi.getter(name="projectRoleAssignments")
    def project_role_assignments(self) -> Optional[Sequence['outputs.CloudUserTeamAssignmentRolesProjectRoleAssignment']]:
        """
        List of project level role assignments to assign the MongoDB Cloud user.
        """
        return pulumi.get(self, "project_role_assignments")


@pulumi.output_type
class CloudUserTeamAssignmentRolesProjectRoleAssignment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"
        elif key == "projectRoles":
            suggest = "project_roles"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudUserTeamAssignmentRolesProjectRoleAssignment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudUserTeamAssignmentRolesProjectRoleAssignment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudUserTeamAssignmentRolesProjectRoleAssignment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_id: Optional[_builtins.str] = None,
                 project_roles: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str project_id: Unique 24-hexadecimal digit string that identifies the project to which these roles belong.
        :param Sequence[_builtins.str] project_roles: One or more project-level roles assigned to the MongoDB Cloud user.
        """
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if project_roles is not None:
            pulumi.set(__self__, "project_roles", project_roles)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        Unique 24-hexadecimal digit string that identifies the project to which these roles belong.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="projectRoles")
    def project_roles(self) -> Optional[Sequence[_builtins.str]]:
        """
        One or more project-level roles assigned to the MongoDB Cloud user.
        """
        return pulumi.get(self, "project_roles")


@pulumi.output_type
class ClusterAdvancedConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "changeStreamOptionsPreAndPostImagesExpireAfterSeconds":
            suggest = "change_stream_options_pre_and_post_images_expire_after_seconds"
        elif key == "customOpensslCipherConfigTls12s":
            suggest = "custom_openssl_cipher_config_tls12s"
        elif key == "defaultMaxTimeMs":
            suggest = "default_max_time_ms"
        elif key == "defaultReadConcern":
            suggest = "default_read_concern"
        elif key == "defaultWriteConcern":
            suggest = "default_write_concern"
        elif key == "failIndexKeyTooLong":
            suggest = "fail_index_key_too_long"
        elif key == "javascriptEnabled":
            suggest = "javascript_enabled"
        elif key == "minimumEnabledTlsProtocol":
            suggest = "minimum_enabled_tls_protocol"
        elif key == "noTableScan":
            suggest = "no_table_scan"
        elif key == "oplogMinRetentionHours":
            suggest = "oplog_min_retention_hours"
        elif key == "oplogSizeMb":
            suggest = "oplog_size_mb"
        elif key == "sampleRefreshIntervalBiConnector":
            suggest = "sample_refresh_interval_bi_connector"
        elif key == "sampleSizeBiConnector":
            suggest = "sample_size_bi_connector"
        elif key == "tlsCipherConfigMode":
            suggest = "tls_cipher_config_mode"
        elif key == "transactionLifetimeLimitSeconds":
            suggest = "transaction_lifetime_limit_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAdvancedConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAdvancedConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAdvancedConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 change_stream_options_pre_and_post_images_expire_after_seconds: Optional[_builtins.int] = None,
                 custom_openssl_cipher_config_tls12s: Optional[Sequence[_builtins.str]] = None,
                 default_max_time_ms: Optional[_builtins.int] = None,
                 default_read_concern: Optional[_builtins.str] = None,
                 default_write_concern: Optional[_builtins.str] = None,
                 fail_index_key_too_long: Optional[_builtins.bool] = None,
                 javascript_enabled: Optional[_builtins.bool] = None,
                 minimum_enabled_tls_protocol: Optional[_builtins.str] = None,
                 no_table_scan: Optional[_builtins.bool] = None,
                 oplog_min_retention_hours: Optional[_builtins.float] = None,
                 oplog_size_mb: Optional[_builtins.int] = None,
                 sample_refresh_interval_bi_connector: Optional[_builtins.int] = None,
                 sample_size_bi_connector: Optional[_builtins.int] = None,
                 tls_cipher_config_mode: Optional[_builtins.str] = None,
                 transaction_lifetime_limit_seconds: Optional[_builtins.int] = None):
        """
        :param _builtins.int change_stream_options_pre_and_post_images_expire_after_seconds: The minimum pre- and post-image retention time in seconds. This option corresponds to the `changeStreamOptions.preAndPostImages.expireAfterSeconds` cluster parameter. Defaults to `-1`(off). This setting controls the retention policy of change stream pre- and post-images. Pre- and post-images are the versions of a document before and after document modification, respectively.`expireAfterSeconds` controls how long MongoDB retains pre- and post-images. When set to -1 (off), MongoDB uses the default retention policy: pre- and post-images are retained until the corresponding change stream events are removed from the oplog. To set the minimum pre- and post-image retention time, specify an integer value greater than zero. Setting this too low could increase the risk of interrupting Realm sync or triggers processing. This parameter is only supported for MongoDB version 6.0 and above.
        :param Sequence[_builtins.str] custom_openssl_cipher_config_tls12s: The custom OpenSSL cipher suite list for TLS 1.2. This field is only valid when `tls_cipher_config_mode` is set to `CUSTOM`.
        :param _builtins.str default_read_concern: [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. **(DEPRECATED)** MongoDB 6.0 and later clusters default to `local`. To use a custom read concern level, please refer to your driver documentation.
        :param _builtins.str default_write_concern: [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 6.0 clusters default to [majority](https://docs.mongodb.com/manual/reference/write-concern/).
        :param _builtins.bool fail_index_key_too_long: **(DEPRECATED)** (Optional) When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        :param _builtins.bool javascript_enabled: When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        :param _builtins.str minimum_enabled_tls_protocol: Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections. Valid values are:
               - TLS1_2
               - TLS1_3
        :param _builtins.bool no_table_scan: When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        :param _builtins.float oplog_min_retention_hours: Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
               * **Note**  A minimum oplog retention is required when seeking to change a cluster's class to Local NVMe SSD. To learn more and for latest guidance see  [`oplogMinRetentionHours`](https://www.mongodb.com/docs/manual/core/replica-set-oplog/#std-label-replica-set-minimum-oplog-size)
        :param _builtins.int oplog_size_mb: The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        :param _builtins.int sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param _builtins.int sample_size_bi_connector: Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param _builtins.str tls_cipher_config_mode: The TLS cipher suite configuration mode. Valid values include `CUSTOM` or `DEFAULT`. The `DEFAULT` mode uses the default cipher suites. The `CUSTOM` mode allows you to specify custom cipher suites for both TLS 1.2 and TLS 1.3. To unset, this should be set back to `DEFAULT`.
        :param _builtins.int transaction_lifetime_limit_seconds: Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        if change_stream_options_pre_and_post_images_expire_after_seconds is not None:
            pulumi.set(__self__, "change_stream_options_pre_and_post_images_expire_after_seconds", change_stream_options_pre_and_post_images_expire_after_seconds)
        if custom_openssl_cipher_config_tls12s is not None:
            pulumi.set(__self__, "custom_openssl_cipher_config_tls12s", custom_openssl_cipher_config_tls12s)
        if default_max_time_ms is not None:
            pulumi.set(__self__, "default_max_time_ms", default_max_time_ms)
        if default_read_concern is not None:
            pulumi.set(__self__, "default_read_concern", default_read_concern)
        if default_write_concern is not None:
            pulumi.set(__self__, "default_write_concern", default_write_concern)
        if fail_index_key_too_long is not None:
            pulumi.set(__self__, "fail_index_key_too_long", fail_index_key_too_long)
        if javascript_enabled is not None:
            pulumi.set(__self__, "javascript_enabled", javascript_enabled)
        if minimum_enabled_tls_protocol is not None:
            pulumi.set(__self__, "minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        if no_table_scan is not None:
            pulumi.set(__self__, "no_table_scan", no_table_scan)
        if oplog_min_retention_hours is not None:
            pulumi.set(__self__, "oplog_min_retention_hours", oplog_min_retention_hours)
        if oplog_size_mb is not None:
            pulumi.set(__self__, "oplog_size_mb", oplog_size_mb)
        if sample_refresh_interval_bi_connector is not None:
            pulumi.set(__self__, "sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        if sample_size_bi_connector is not None:
            pulumi.set(__self__, "sample_size_bi_connector", sample_size_bi_connector)
        if tls_cipher_config_mode is not None:
            pulumi.set(__self__, "tls_cipher_config_mode", tls_cipher_config_mode)
        if transaction_lifetime_limit_seconds is not None:
            pulumi.set(__self__, "transaction_lifetime_limit_seconds", transaction_lifetime_limit_seconds)

    @_builtins.property
    @pulumi.getter(name="changeStreamOptionsPreAndPostImagesExpireAfterSeconds")
    def change_stream_options_pre_and_post_images_expire_after_seconds(self) -> Optional[_builtins.int]:
        """
        The minimum pre- and post-image retention time in seconds. This option corresponds to the `changeStreamOptions.preAndPostImages.expireAfterSeconds` cluster parameter. Defaults to `-1`(off). This setting controls the retention policy of change stream pre- and post-images. Pre- and post-images are the versions of a document before and after document modification, respectively.`expireAfterSeconds` controls how long MongoDB retains pre- and post-images. When set to -1 (off), MongoDB uses the default retention policy: pre- and post-images are retained until the corresponding change stream events are removed from the oplog. To set the minimum pre- and post-image retention time, specify an integer value greater than zero. Setting this too low could increase the risk of interrupting Realm sync or triggers processing. This parameter is only supported for MongoDB version 6.0 and above.
        """
        return pulumi.get(self, "change_stream_options_pre_and_post_images_expire_after_seconds")

    @_builtins.property
    @pulumi.getter(name="customOpensslCipherConfigTls12s")
    def custom_openssl_cipher_config_tls12s(self) -> Optional[Sequence[_builtins.str]]:
        """
        The custom OpenSSL cipher suite list for TLS 1.2. This field is only valid when `tls_cipher_config_mode` is set to `CUSTOM`.
        """
        return pulumi.get(self, "custom_openssl_cipher_config_tls12s")

    @_builtins.property
    @pulumi.getter(name="defaultMaxTimeMs")
    def default_max_time_ms(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "default_max_time_ms")

    @_builtins.property
    @pulumi.getter(name="defaultReadConcern")
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide""")
    def default_read_concern(self) -> Optional[_builtins.str]:
        """
        [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. **(DEPRECATED)** MongoDB 6.0 and later clusters default to `local`. To use a custom read concern level, please refer to your driver documentation.
        """
        return pulumi.get(self, "default_read_concern")

    @_builtins.property
    @pulumi.getter(name="defaultWriteConcern")
    def default_write_concern(self) -> Optional[_builtins.str]:
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 6.0 clusters default to [majority](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        return pulumi.get(self, "default_write_concern")

    @_builtins.property
    @pulumi.getter(name="failIndexKeyTooLong")
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide""")
    def fail_index_key_too_long(self) -> Optional[_builtins.bool]:
        """
        **(DEPRECATED)** (Optional) When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        """
        return pulumi.get(self, "fail_index_key_too_long")

    @_builtins.property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> Optional[_builtins.bool]:
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        return pulumi.get(self, "javascript_enabled")

    @_builtins.property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> Optional[_builtins.str]:
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections. Valid values are:
        - TLS1_2
        - TLS1_3
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @_builtins.property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> Optional[_builtins.bool]:
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        return pulumi.get(self, "no_table_scan")

    @_builtins.property
    @pulumi.getter(name="oplogMinRetentionHours")
    def oplog_min_retention_hours(self) -> Optional[_builtins.float]:
        """
        Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        * **Note**  A minimum oplog retention is required when seeking to change a cluster's class to Local NVMe SSD. To learn more and for latest guidance see  [`oplogMinRetentionHours`](https://www.mongodb.com/docs/manual/core/replica-set-oplog/#std-label-replica-set-minimum-oplog-size)
        """
        return pulumi.get(self, "oplog_min_retention_hours")

    @_builtins.property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> Optional[_builtins.int]:
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        return pulumi.get(self, "oplog_size_mb")

    @_builtins.property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> Optional[_builtins.int]:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @_builtins.property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> Optional[_builtins.int]:
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_size_bi_connector")

    @_builtins.property
    @pulumi.getter(name="tlsCipherConfigMode")
    def tls_cipher_config_mode(self) -> Optional[_builtins.str]:
        """
        The TLS cipher suite configuration mode. Valid values include `CUSTOM` or `DEFAULT`. The `DEFAULT` mode uses the default cipher suites. The `CUSTOM` mode allows you to specify custom cipher suites for both TLS 1.2 and TLS 1.3. To unset, this should be set back to `DEFAULT`.
        """
        return pulumi.get(self, "tls_cipher_config_mode")

    @_builtins.property
    @pulumi.getter(name="transactionLifetimeLimitSeconds")
    def transaction_lifetime_limit_seconds(self) -> Optional[_builtins.int]:
        """
        Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        return pulumi.get(self, "transaction_lifetime_limit_seconds")


@pulumi.output_type
class ClusterBiConnectorConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readPreference":
            suggest = "read_preference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterBiConnectorConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterBiConnectorConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterBiConnectorConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 read_preference: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Specifies whether or not BI Connector for Atlas is enabled on the cluster.
               *
               - Set to `true` to enable BI Connector for Atlas.
               - Set to `false` to disable BI Connector for Atlas.
        :param _builtins.str read_preference: Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
               
               - Set to "primary" to have BI Connector for Atlas read from the primary.
               
               - Set to "secondary" to have BI Connector for Atlas read from a secondary member. Default if there are no analytics nodes in the cluster.
               
               - Set to "analytics" to have BI Connector for Atlas read from an analytics node. Default if the cluster contains analytics nodes.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if read_preference is not None:
            pulumi.set(__self__, "read_preference", read_preference)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether or not BI Connector for Atlas is enabled on the cluster.
        *
        - Set to `true` to enable BI Connector for Atlas.
        - Set to `false` to disable BI Connector for Atlas.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> Optional[_builtins.str]:
        """
        Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).

        - Set to "primary" to have BI Connector for Atlas read from the primary.

        - Set to "secondary" to have BI Connector for Atlas read from a secondary member. Default if there are no analytics nodes in the cluster.

        - Set to "analytics" to have BI Connector for Atlas read from an analytics node. Default if the cluster contains analytics nodes.
        """
        return pulumi.get(self, "read_preference")


@pulumi.output_type
class ClusterConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateEndpoints":
            suggest = "private_endpoints"
        elif key == "privateSrv":
            suggest = "private_srv"
        elif key == "standardSrv":
            suggest = "standard_srv"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private: Optional[_builtins.str] = None,
                 private_endpoints: Optional[Sequence['outputs.ClusterConnectionStringPrivateEndpoint']] = None,
                 private_srv: Optional[_builtins.str] = None,
                 standard: Optional[_builtins.str] = None,
                 standard_srv: Optional[_builtins.str] = None):
        if private is not None:
            pulumi.set(__self__, "private", private)
        if private_endpoints is not None:
            pulumi.set(__self__, "private_endpoints", private_endpoints)
        if private_srv is not None:
            pulumi.set(__self__, "private_srv", private_srv)
        if standard is not None:
            pulumi.set(__self__, "standard", standard)
        if standard_srv is not None:
            pulumi.set(__self__, "standard_srv", standard_srv)

    @_builtins.property
    @pulumi.getter
    def private(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "private")

    @_builtins.property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Optional[Sequence['outputs.ClusterConnectionStringPrivateEndpoint']]:
        return pulumi.get(self, "private_endpoints")

    @_builtins.property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "private_srv")

    @_builtins.property
    @pulumi.getter
    def standard(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "standard")

    @_builtins.property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class ClusterConnectionStringPrivateEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionString":
            suggest = "connection_string"
        elif key == "srvConnectionString":
            suggest = "srv_connection_string"
        elif key == "srvShardOptimizedConnectionString":
            suggest = "srv_shard_optimized_connection_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterConnectionStringPrivateEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterConnectionStringPrivateEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterConnectionStringPrivateEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_string: Optional[_builtins.str] = None,
                 endpoints: Optional[Sequence['outputs.ClusterConnectionStringPrivateEndpointEndpoint']] = None,
                 srv_connection_string: Optional[_builtins.str] = None,
                 srv_shard_optimized_connection_string: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if srv_connection_string is not None:
            pulumi.set(__self__, "srv_connection_string", srv_connection_string)
        if srv_shard_optimized_connection_string is not None:
            pulumi.set(__self__, "srv_shard_optimized_connection_string", srv_shard_optimized_connection_string)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "connection_string")

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence['outputs.ClusterConnectionStringPrivateEndpointEndpoint']]:
        return pulumi.get(self, "endpoints")

    @_builtins.property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "srv_connection_string")

    @_builtins.property
    @pulumi.getter(name="srvShardOptimizedConnectionString")
    def srv_shard_optimized_connection_string(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "srv_shard_optimized_connection_string")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class ClusterConnectionStringPrivateEndpointEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointId":
            suggest = "endpoint_id"
        elif key == "providerName":
            suggest = "provider_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterConnectionStringPrivateEndpointEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterConnectionStringPrivateEndpointEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterConnectionStringPrivateEndpointEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_id: Optional[_builtins.str] = None,
                 provider_name: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        """
        :param _builtins.str provider_name: Cloud service provider on which the servers are provisioned.
               
               The possible values are:
               
               - `AWS` - Amazon AWS
               - `GCP` - Google Cloud Platform
               - `AZURE` - Microsoft Azure
               - `TENANT` - A multi-tenant deployment on one of the supported cloud service providers. Only valid when providerSettings.instanceSizeName is M0.
        """
        if endpoint_id is not None:
            pulumi.set(__self__, "endpoint_id", endpoint_id)
        if provider_name is not None:
            pulumi.set(__self__, "provider_name", provider_name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "endpoint_id")

    @_builtins.property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> Optional[_builtins.str]:
        """
        Cloud service provider on which the servers are provisioned.

        The possible values are:

        - `AWS` - Amazon AWS
        - `GCP` - Google Cloud Platform
        - `AZURE` - Microsoft Azure
        - `TENANT` - A multi-tenant deployment on one of the supported cloud service providers. Only valid when providerSettings.instanceSizeName is M0.
        """
        return pulumi.get(self, "provider_name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class ClusterLabel(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: The key that you want to write.
        :param _builtins.str value: The value that you want to write.
               
               > **NOTE:** MongoDB Atlas doesn't display your labels.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value that you want to write.

        > **NOTE:** MongoDB Atlas doesn't display your labels.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterOutageSimulationOutageFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudProvider":
            suggest = "cloud_provider"
        elif key == "regionName":
            suggest = "region_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterOutageSimulationOutageFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterOutageSimulationOutageFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterOutageSimulationOutageFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_provider: _builtins.str,
                 region_name: _builtins.str,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str cloud_provider: The cloud provider of the region that undergoes the outage simulation. Following values are supported:
               * `AWS`
               * `GCP`
               * `AZURE`
        :param _builtins.str region_name: The Atlas name of the region to undergo an outage simulation.
        :param _builtins.str type: The type of cluster outage simulation. Following values are supported:
               * `REGION` - Simulates a cluster outage for a region
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region_name", region_name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> _builtins.str:
        """
        The cloud provider of the region that undergoes the outage simulation. Following values are supported:
        * `AWS`
        * `GCP`
        * `AZURE`
        """
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> _builtins.str:
        """
        The Atlas name of the region to undergo an outage simulation.
        """
        return pulumi.get(self, "region_name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of cluster outage simulation. Following values are supported:
        * `REGION` - Simulates a cluster outage for a region
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ClusterPinnedFcv(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expirationDate":
            suggest = "expiration_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterPinnedFcv. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterPinnedFcv.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterPinnedFcv.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expiration_date: _builtins.str,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str expiration_date: Expiration date of the fixed FCV. This value is in the ISO 8601 timestamp format (e.g. "2024-12-04T16:25:00Z"). Note that this field cannot exceed 4 weeks from the pinned date.
        :param _builtins.str version: Feature compatibility version of the cluster.
        """
        pulumi.set(__self__, "expiration_date", expiration_date)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> _builtins.str:
        """
        Expiration date of the fixed FCV. This value is in the ISO 8601 timestamp format (e.g. "2024-12-04T16:25:00Z"). Note that this field cannot exceed 4 weeks from the pinned date.
        """
        return pulumi.get(self, "expiration_date")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Feature compatibility version of the cluster.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class ClusterReplicationSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numShards":
            suggest = "num_shards"
        elif key == "regionsConfigs":
            suggest = "regions_configs"
        elif key == "zoneName":
            suggest = "zone_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterReplicationSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterReplicationSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterReplicationSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_shards: _builtins.int,
                 id: Optional[_builtins.str] = None,
                 regions_configs: Optional[Sequence['outputs.ClusterReplicationSpecRegionsConfig']] = None,
                 zone_name: Optional[_builtins.str] = None):
        """
        :param _builtins.int num_shards: Selects whether the cluster is a replica set or a sharded cluster. If you use the replicationSpecs parameter, you must set num_shards.
        :param _builtins.str id: Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        :param Sequence['ClusterReplicationSpecRegionsConfigArgs'] regions_configs: Physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        :param _builtins.str zone_name: Name for the zone in a Global Cluster.
               
               
               **Region Config**
        """
        pulumi.set(__self__, "num_shards", num_shards)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if regions_configs is not None:
            pulumi.set(__self__, "regions_configs", regions_configs)
        if zone_name is not None:
            pulumi.set(__self__, "zone_name", zone_name)

    @_builtins.property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> _builtins.int:
        """
        Selects whether the cluster is a replica set or a sharded cluster. If you use the replicationSpecs parameter, you must set num_shards.
        """
        return pulumi.get(self, "num_shards")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="regionsConfigs")
    def regions_configs(self) -> Optional[Sequence['outputs.ClusterReplicationSpecRegionsConfig']]:
        """
        Physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        """
        return pulumi.get(self, "regions_configs")

    @_builtins.property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> Optional[_builtins.str]:
        """
        Name for the zone in a Global Cluster.


        **Region Config**
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class ClusterReplicationSpecRegionsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionName":
            suggest = "region_name"
        elif key == "analyticsNodes":
            suggest = "analytics_nodes"
        elif key == "electableNodes":
            suggest = "electable_nodes"
        elif key == "readOnlyNodes":
            suggest = "read_only_nodes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterReplicationSpecRegionsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterReplicationSpecRegionsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterReplicationSpecRegionsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region_name: _builtins.str,
                 analytics_nodes: Optional[_builtins.int] = None,
                 electable_nodes: Optional[_builtins.int] = None,
                 priority: Optional[_builtins.int] = None,
                 read_only_nodes: Optional[_builtins.int] = None):
        """
        :param _builtins.str region_name: Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        :param _builtins.int analytics_nodes: The number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary. If you do not specify this option, no analytics nodes are deployed to the region.
        :param _builtins.int electable_nodes: Number of electable nodes for Atlas to deploy to the region. Electable nodes can become the primary and can facilitate local reads.
               * The total number of electableNodes across all replication spec regions  must total 3, 5, or 7.
               * Specify 0 if you do not want any electable nodes in the region.
               * You cannot create electable nodes in a region if `priority` is 0.
        :param _builtins.int priority: Election priority of the region. For regions with only read-only nodes, set this value to 0.
               * For regions where `electable_nodes` is at least 1, each region must have a priority of exactly one (1) less than the previous region. The first region must have a priority of 7. The lowest possible priority is 1.
               * The priority 7 region identifies the Preferred Region of the cluster. Atlas places the primary node in the Preferred Region. Priorities 1 through 7 are exclusive - no more than one region per cluster can be assigned a given priority.
               * Example: If you have three regions, their priorities would be 7, 6, and 5 respectively. If you added two more regions for supporting electable nodes, the priorities of those regions would be 4 and 3 respectively.
        :param _builtins.int read_only_nodes: Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        """
        pulumi.set(__self__, "region_name", region_name)
        if analytics_nodes is not None:
            pulumi.set(__self__, "analytics_nodes", analytics_nodes)
        if electable_nodes is not None:
            pulumi.set(__self__, "electable_nodes", electable_nodes)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if read_only_nodes is not None:
            pulumi.set(__self__, "read_only_nodes", read_only_nodes)

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> _builtins.str:
        """
        Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        """
        return pulumi.get(self, "region_name")

    @_builtins.property
    @pulumi.getter(name="analyticsNodes")
    def analytics_nodes(self) -> Optional[_builtins.int]:
        """
        The number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary. If you do not specify this option, no analytics nodes are deployed to the region.
        """
        return pulumi.get(self, "analytics_nodes")

    @_builtins.property
    @pulumi.getter(name="electableNodes")
    def electable_nodes(self) -> Optional[_builtins.int]:
        """
        Number of electable nodes for Atlas to deploy to the region. Electable nodes can become the primary and can facilitate local reads.
        * The total number of electableNodes across all replication spec regions  must total 3, 5, or 7.
        * Specify 0 if you do not want any electable nodes in the region.
        * You cannot create electable nodes in a region if `priority` is 0.
        """
        return pulumi.get(self, "electable_nodes")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.int]:
        """
        Election priority of the region. For regions with only read-only nodes, set this value to 0.
        * For regions where `electable_nodes` is at least 1, each region must have a priority of exactly one (1) less than the previous region. The first region must have a priority of 7. The lowest possible priority is 1.
        * The priority 7 region identifies the Preferred Region of the cluster. Atlas places the primary node in the Preferred Region. Priorities 1 through 7 are exclusive - no more than one region per cluster can be assigned a given priority.
        * Example: If you have three regions, their priorities would be 7, 6, and 5 respectively. If you added two more regions for supporting electable nodes, the priorities of those regions would be 4 and 3 respectively.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="readOnlyNodes")
    def read_only_nodes(self) -> Optional[_builtins.int]:
        """
        Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        """
        return pulumi.get(self, "read_only_nodes")


@pulumi.output_type
class ClusterSnapshotBackupPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterId":
            suggest = "cluster_id"
        elif key == "clusterName":
            suggest = "cluster_name"
        elif key == "nextSnapshot":
            suggest = "next_snapshot"
        elif key == "referenceHourOfDay":
            suggest = "reference_hour_of_day"
        elif key == "referenceMinuteOfHour":
            suggest = "reference_minute_of_hour"
        elif key == "restoreWindowDays":
            suggest = "restore_window_days"
        elif key == "updateSnapshots":
            suggest = "update_snapshots"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSnapshotBackupPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSnapshotBackupPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSnapshotBackupPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_id: Optional[_builtins.str] = None,
                 cluster_name: Optional[_builtins.str] = None,
                 next_snapshot: Optional[_builtins.str] = None,
                 policies: Optional[Sequence['outputs.ClusterSnapshotBackupPolicyPolicy']] = None,
                 reference_hour_of_day: Optional[_builtins.int] = None,
                 reference_minute_of_hour: Optional[_builtins.int] = None,
                 restore_window_days: Optional[_builtins.int] = None,
                 update_snapshots: Optional[_builtins.bool] = None):
        """
        :param _builtins.str cluster_id: The cluster ID.
        """
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if next_snapshot is not None:
            pulumi.set(__self__, "next_snapshot", next_snapshot)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if reference_hour_of_day is not None:
            pulumi.set(__self__, "reference_hour_of_day", reference_hour_of_day)
        if reference_minute_of_hour is not None:
            pulumi.set(__self__, "reference_minute_of_hour", reference_minute_of_hour)
        if restore_window_days is not None:
            pulumi.set(__self__, "restore_window_days", restore_window_days)
        if update_snapshots is not None:
            pulumi.set(__self__, "update_snapshots", update_snapshots)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[_builtins.str]:
        """
        The cluster ID.
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="nextSnapshot")
    def next_snapshot(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "next_snapshot")

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Optional[Sequence['outputs.ClusterSnapshotBackupPolicyPolicy']]:
        return pulumi.get(self, "policies")

    @_builtins.property
    @pulumi.getter(name="referenceHourOfDay")
    def reference_hour_of_day(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "reference_hour_of_day")

    @_builtins.property
    @pulumi.getter(name="referenceMinuteOfHour")
    def reference_minute_of_hour(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "reference_minute_of_hour")

    @_builtins.property
    @pulumi.getter(name="restoreWindowDays")
    def restore_window_days(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "restore_window_days")

    @_builtins.property
    @pulumi.getter(name="updateSnapshots")
    def update_snapshots(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "update_snapshots")


@pulumi.output_type
class ClusterSnapshotBackupPolicyPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyItems":
            suggest = "policy_items"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSnapshotBackupPolicyPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSnapshotBackupPolicyPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSnapshotBackupPolicyPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 policy_items: Optional[Sequence['outputs.ClusterSnapshotBackupPolicyPolicyPolicyItem']] = None):
        """
        :param _builtins.str id: Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if policy_items is not None:
            pulumi.set(__self__, "policy_items", policy_items)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="policyItems")
    def policy_items(self) -> Optional[Sequence['outputs.ClusterSnapshotBackupPolicyPolicyPolicyItem']]:
        return pulumi.get(self, "policy_items")


@pulumi.output_type
class ClusterSnapshotBackupPolicyPolicyPolicyItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "frequencyType":
            suggest = "frequency_type"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSnapshotBackupPolicyPolicyPolicyItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSnapshotBackupPolicyPolicyPolicyItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSnapshotBackupPolicyPolicyPolicyItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: Optional[_builtins.int] = None,
                 frequency_type: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 retention_unit: Optional[_builtins.str] = None,
                 retention_value: Optional[_builtins.int] = None):
        """
        :param _builtins.str id: Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        if frequency_interval is not None:
            pulumi.set(__self__, "frequency_interval", frequency_interval)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if retention_unit is not None:
            pulumi.set(__self__, "retention_unit", retention_unit)
        if retention_value is not None:
            pulumi.set(__self__, "retention_value", retention_value)

    @_builtins.property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "frequency_interval")

    @_builtins.property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "frequency_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "retention_unit")

    @_builtins.property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class ClusterTag(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Constant that defines the set of the tag.
        :param _builtins.str value: Variable that belongs to the set of the tag.
               
               To learn more, see [Resource Tags](https://dochub.mongodb.org/core/add-cluster-tag-atlas).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Constant that defines the set of the tag.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Variable that belongs to the set of the tag.

        To learn more, see [Resource Tags](https://dochub.mongodb.org/core/add-cluster-tag-atlas).
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomDbRoleAction(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 resources: Sequence['outputs.CustomDbRoleActionResource']):
        """
        :param _builtins.str action: Name of the privilege action. For a complete list of actions available in the Atlas API, see [Custom Role Actions](https://docs.atlas.mongodb.com/reference/api/custom-role-actions)
               > **Note**: The privilege actions available to the Custom Roles API resource represent a subset of the privilege actions available in the Atlas Custom Roles UI.
        :param Sequence['CustomDbRoleActionResourceArgs'] resources: Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
               
               * `resources.#.collection_name` - (Optional) Collection on which the action is granted. If this value is an empty string, the action is granted on all collections within the database specified in the actions.resources.db field.
               
               > **NOTE** This field is mutually exclusive with the `actions.resources.cluster` field.
               
               * `resources.#.database_name` Database on which the action is granted. Use the empty string ("") to allow an action on all databases.
               
               > **NOTE** This field is mutually exclusive with the `actions.resources.cluster` field.
               
               * `resources.#.cluster`	(Optional) Set to true to indicate that the action is granted on the cluster resource.
               
               > **NOTE** This field is mutually exclusive with the `actions.resources.collection` and `actions.resources.db fields`.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        Name of the privilege action. For a complete list of actions available in the Atlas API, see [Custom Role Actions](https://docs.atlas.mongodb.com/reference/api/custom-role-actions)
        > **Note**: The privilege actions available to the Custom Roles API resource represent a subset of the privilege actions available in the Atlas Custom Roles UI.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.CustomDbRoleActionResource']:
        """
        Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.

        * `resources.#.collection_name` - (Optional) Collection on which the action is granted. If this value is an empty string, the action is granted on all collections within the database specified in the actions.resources.db field.

        > **NOTE** This field is mutually exclusive with the `actions.resources.cluster` field.

        * `resources.#.database_name` Database on which the action is granted. Use the empty string ("") to allow an action on all databases.

        > **NOTE** This field is mutually exclusive with the `actions.resources.cluster` field.

        * `resources.#.cluster`	(Optional) Set to true to indicate that the action is granted on the cluster resource.

        > **NOTE** This field is mutually exclusive with the `actions.resources.collection` and `actions.resources.db fields`.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class CustomDbRoleActionResource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collectionName":
            suggest = "collection_name"
        elif key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomDbRoleActionResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomDbRoleActionResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomDbRoleActionResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster: Optional[_builtins.bool] = None,
                 collection_name: Optional[_builtins.str] = None,
                 database_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str database_name: Database on which the inherited role is granted.
               
               > **NOTE** This value should be admin for all roles except read and readWrite.
        """
        if cluster is not None:
            pulumi.set(__self__, "cluster", cluster)
        if collection_name is not None:
            pulumi.set(__self__, "collection_name", collection_name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)

    @_builtins.property
    @pulumi.getter
    def cluster(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "cluster")

    @_builtins.property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "collection_name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[_builtins.str]:
        """
        Database on which the inherited role is granted.

        > **NOTE** This value should be admin for all roles except read and readWrite.
        """
        return pulumi.get(self, "database_name")


@pulumi.output_type
class CustomDbRoleInheritedRole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "roleName":
            suggest = "role_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomDbRoleInheritedRole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomDbRoleInheritedRole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomDbRoleInheritedRole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: _builtins.str,
                 role_name: _builtins.str):
        """
        :param _builtins.str database_name: Database on which the inherited role is granted.
               
               > **NOTE** This value should be admin for all roles except read and readWrite.
        :param _builtins.str role_name: Name of the inherited role. This can either be another custom role or a built-in role.
               
               > **NOTE** Built-in roles are present in clusters by default and do not need to be redefined for their properties to be inherited by a custom role.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "role_name", role_name)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        Database on which the inherited role is granted.

        > **NOTE** This value should be admin for all roles except read and readWrite.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="roleName")
    def role_name(self) -> _builtins.str:
        """
        Name of the inherited role. This can either be another custom role or a built-in role.

        > **NOTE** Built-in roles are present in clusters by default and do not need to be redefined for their properties to be inherited by a custom role.
        """
        return pulumi.get(self, "role_name")


@pulumi.output_type
class DatabaseUserLabel(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: The key that you want to write.
        :param _builtins.str value: The value that you want to write.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DatabaseUserRole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "roleName":
            suggest = "role_name"
        elif key == "collectionName":
            suggest = "collection_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseUserRole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseUserRole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseUserRole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: _builtins.str,
                 role_name: _builtins.str,
                 collection_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str database_name: Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases. This field should be set to `admin` for a custom MongoDB role.
        :param _builtins.str role_name: Name of the role to grant. See [Create a Database User](https://docs.atlas.mongodb.com/reference/api/database-users-create-a-user/) `roles.roleName` for valid values and restrictions.
        :param _builtins.str collection_name: Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "role_name", role_name)
        if collection_name is not None:
            pulumi.set(__self__, "collection_name", collection_name)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases. This field should be set to `admin` for a custom MongoDB role.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="roleName")
    def role_name(self) -> _builtins.str:
        """
        Name of the role to grant. See [Create a Database User](https://docs.atlas.mongodb.com/reference/api/database-users-create-a-user/) `roles.roleName` for valid values and restrictions.
        """
        return pulumi.get(self, "role_name")

    @_builtins.property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[_builtins.str]:
        """
        Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        """
        return pulumi.get(self, "collection_name")


@pulumi.output_type
class DatabaseUserScope(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the cluster or Atlas Data Federation that the user has access to.
        :param _builtins.str type: Type of resource that the user has access to. See [Database User API](https://www.mongodb.com/docs/api/doc/atlas-admin-api-v2/operation/operation-createdatabaseuser) for the list of valid values.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the cluster or Atlas Data Federation that the user has access to.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of resource that the user has access to. See [Database User API](https://www.mongodb.com/docs/api/doc/atlas-admin-api-v2/operation/operation-createdatabaseuser) for the list of valid values.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class EncryptionAtRestAwsKmsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKeyId":
            suggest = "access_key_id"
        elif key == "customerMasterKeyId":
            suggest = "customer_master_key_id"
        elif key == "requirePrivateNetworking":
            suggest = "require_private_networking"
        elif key == "roleId":
            suggest = "role_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionAtRestAwsKmsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionAtRestAwsKmsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionAtRestAwsKmsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key_id: Optional[_builtins.str] = None,
                 customer_master_key_id: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 region: Optional[_builtins.str] = None,
                 require_private_networking: Optional[_builtins.bool] = None,
                 role_id: Optional[_builtins.str] = None,
                 secret_access_key: Optional[_builtins.str] = None,
                 valid: Optional[_builtins.bool] = None):
        """
        :param _builtins.str access_key_id: Unique alphanumeric string that identifies an Identity and Access Management (IAM) access key with permissions required to access your Amazon Web Services (AWS) Customer Master Key (CMK).
        :param _builtins.str customer_master_key_id: Unique alphanumeric string that identifies the Amazon Web Services (AWS) Customer Master Key (CMK) you used to encrypt and decrypt the MongoDB master keys.
        :param _builtins.bool enabled: Flag that indicates whether someone enabled encryption at rest for the specified project through Amazon Web Services (AWS) Key Management Service (KMS). To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        :param _builtins.str region: Physical location where MongoDB Atlas deploys your AWS-hosted MongoDB cluster nodes. The region you choose can affect network latency for clients accessing your databases. When MongoDB Cloud deploys a dedicated cluster, it checks if a VPC or VPC connection exists for that provider and region. If not, MongoDB Atlas creates them as part of the deployment. MongoDB Atlas assigns the VPC a CIDR block. To limit a new VPC peering connection to one CIDR block and region, create the connection first. Deploy the cluster after the connection starts.
        :param _builtins.bool require_private_networking: Enable connection to your Amazon Web Services (AWS) Key Management Service (KMS) over private networking.
        :param _builtins.str role_id: Unique 24-hexadecimal digit string that identifies an Amazon Web Services (AWS) Identity and Access Management (IAM) role. This IAM role has the permissions required to manage your AWS customer master key.
        :param _builtins.str secret_access_key: Human-readable label of the Identity and Access Management (IAM) secret access key with permissions required to access your Amazon Web Services (AWS) customer master key.
        :param _builtins.bool valid: Flag that indicates whether the Amazon Web Services (AWS) Key Management Service (KMS) encryption key can encrypt and decrypt data.
        """
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if customer_master_key_id is not None:
            pulumi.set(__self__, "customer_master_key_id", customer_master_key_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if require_private_networking is not None:
            pulumi.set(__self__, "require_private_networking", require_private_networking)
        if role_id is not None:
            pulumi.set(__self__, "role_id", role_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if valid is not None:
            pulumi.set(__self__, "valid", valid)

    @_builtins.property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[_builtins.str]:
        """
        Unique alphanumeric string that identifies an Identity and Access Management (IAM) access key with permissions required to access your Amazon Web Services (AWS) Customer Master Key (CMK).
        """
        return pulumi.get(self, "access_key_id")

    @_builtins.property
    @pulumi.getter(name="customerMasterKeyId")
    def customer_master_key_id(self) -> Optional[_builtins.str]:
        """
        Unique alphanumeric string that identifies the Amazon Web Services (AWS) Customer Master Key (CMK) you used to encrypt and decrypt the MongoDB master keys.
        """
        return pulumi.get(self, "customer_master_key_id")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Flag that indicates whether someone enabled encryption at rest for the specified project through Amazon Web Services (AWS) Key Management Service (KMS). To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Physical location where MongoDB Atlas deploys your AWS-hosted MongoDB cluster nodes. The region you choose can affect network latency for clients accessing your databases. When MongoDB Cloud deploys a dedicated cluster, it checks if a VPC or VPC connection exists for that provider and region. If not, MongoDB Atlas creates them as part of the deployment. MongoDB Atlas assigns the VPC a CIDR block. To limit a new VPC peering connection to one CIDR block and region, create the connection first. Deploy the cluster after the connection starts.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="requirePrivateNetworking")
    def require_private_networking(self) -> Optional[_builtins.bool]:
        """
        Enable connection to your Amazon Web Services (AWS) Key Management Service (KMS) over private networking.
        """
        return pulumi.get(self, "require_private_networking")

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[_builtins.str]:
        """
        Unique 24-hexadecimal digit string that identifies an Amazon Web Services (AWS) Identity and Access Management (IAM) role. This IAM role has the permissions required to manage your AWS customer master key.
        """
        return pulumi.get(self, "role_id")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[_builtins.str]:
        """
        Human-readable label of the Identity and Access Management (IAM) secret access key with permissions required to access your Amazon Web Services (AWS) customer master key.
        """
        return pulumi.get(self, "secret_access_key")

    @_builtins.property
    @pulumi.getter
    def valid(self) -> Optional[_builtins.bool]:
        """
        Flag that indicates whether the Amazon Web Services (AWS) Key Management Service (KMS) encryption key can encrypt and decrypt data.
        """
        return pulumi.get(self, "valid")


@pulumi.output_type
class EncryptionAtRestAzureKeyVaultConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureEnvironment":
            suggest = "azure_environment"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "keyIdentifier":
            suggest = "key_identifier"
        elif key == "keyVaultName":
            suggest = "key_vault_name"
        elif key == "requirePrivateNetworking":
            suggest = "require_private_networking"
        elif key == "resourceGroupName":
            suggest = "resource_group_name"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionAtRestAzureKeyVaultConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionAtRestAzureKeyVaultConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionAtRestAzureKeyVaultConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_environment: Optional[_builtins.str] = None,
                 client_id: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 key_identifier: Optional[_builtins.str] = None,
                 key_vault_name: Optional[_builtins.str] = None,
                 require_private_networking: Optional[_builtins.bool] = None,
                 resource_group_name: Optional[_builtins.str] = None,
                 secret: Optional[_builtins.str] = None,
                 subscription_id: Optional[_builtins.str] = None,
                 tenant_id: Optional[_builtins.str] = None,
                 valid: Optional[_builtins.bool] = None):
        """
        :param _builtins.str azure_environment: Azure environment in which your account credentials reside.
        :param _builtins.str client_id: Unique 36-hexadecimal character string that identifies an Azure application associated with your Azure Active Directory tenant.
        :param _builtins.bool enabled: Flag that indicates whether someone enabled encryption at rest for the specified  project. To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        :param _builtins.str key_identifier: Web address with a unique key that identifies for your Azure Key Vault.
        :param _builtins.str key_vault_name: Unique string that identifies the Azure Key Vault that contains your key.
        :param _builtins.bool require_private_networking: Enable connection to your Azure Key Vault over private networking.
        :param _builtins.str resource_group_name: Name of the Azure resource group that contains your Azure Key Vault.
        :param _builtins.str secret: Private data that you need secured and that belongs to the specified Azure Key Vault (AKV) tenant (**azureKeyVault.tenantID**). This data can include any type of sensitive data such as passwords, database connection strings, API keys, and the like. AKV stores this information as encrypted binary data.
        :param _builtins.str subscription_id: Unique 36-hexadecimal character string that identifies your Azure subscription.
        :param _builtins.str tenant_id: Unique 36-hexadecimal character string that identifies the Azure Active Directory tenant within your Azure subscription.
        :param _builtins.bool valid: Flag that indicates whether the Azure encryption key can encrypt and decrypt data.
        """
        if azure_environment is not None:
            pulumi.set(__self__, "azure_environment", azure_environment)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if key_identifier is not None:
            pulumi.set(__self__, "key_identifier", key_identifier)
        if key_vault_name is not None:
            pulumi.set(__self__, "key_vault_name", key_vault_name)
        if require_private_networking is not None:
            pulumi.set(__self__, "require_private_networking", require_private_networking)
        if resource_group_name is not None:
            pulumi.set(__self__, "resource_group_name", resource_group_name)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if valid is not None:
            pulumi.set(__self__, "valid", valid)

    @_builtins.property
    @pulumi.getter(name="azureEnvironment")
    def azure_environment(self) -> Optional[_builtins.str]:
        """
        Azure environment in which your account credentials reside.
        """
        return pulumi.get(self, "azure_environment")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        Unique 36-hexadecimal character string that identifies an Azure application associated with your Azure Active Directory tenant.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Flag that indicates whether someone enabled encryption at rest for the specified  project. To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="keyIdentifier")
    def key_identifier(self) -> Optional[_builtins.str]:
        """
        Web address with a unique key that identifies for your Azure Key Vault.
        """
        return pulumi.get(self, "key_identifier")

    @_builtins.property
    @pulumi.getter(name="keyVaultName")
    def key_vault_name(self) -> Optional[_builtins.str]:
        """
        Unique string that identifies the Azure Key Vault that contains your key.
        """
        return pulumi.get(self, "key_vault_name")

    @_builtins.property
    @pulumi.getter(name="requirePrivateNetworking")
    def require_private_networking(self) -> Optional[_builtins.bool]:
        """
        Enable connection to your Azure Key Vault over private networking.
        """
        return pulumi.get(self, "require_private_networking")

    @_builtins.property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[_builtins.str]:
        """
        Name of the Azure resource group that contains your Azure Key Vault.
        """
        return pulumi.get(self, "resource_group_name")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        Private data that you need secured and that belongs to the specified Azure Key Vault (AKV) tenant (**azureKeyVault.tenantID**). This data can include any type of sensitive data such as passwords, database connection strings, API keys, and the like. AKV stores this information as encrypted binary data.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[_builtins.str]:
        """
        Unique 36-hexadecimal character string that identifies your Azure subscription.
        """
        return pulumi.get(self, "subscription_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        Unique 36-hexadecimal character string that identifies the Azure Active Directory tenant within your Azure subscription.
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter
    def valid(self) -> Optional[_builtins.bool]:
        """
        Flag that indicates whether the Azure encryption key can encrypt and decrypt data.
        """
        return pulumi.get(self, "valid")


@pulumi.output_type
class EncryptionAtRestGoogleCloudKmsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVersionResourceId":
            suggest = "key_version_resource_id"
        elif key == "roleId":
            suggest = "role_id"
        elif key == "serviceAccountKey":
            suggest = "service_account_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionAtRestGoogleCloudKmsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionAtRestGoogleCloudKmsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionAtRestGoogleCloudKmsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 key_version_resource_id: Optional[_builtins.str] = None,
                 role_id: Optional[_builtins.str] = None,
                 service_account_key: Optional[_builtins.str] = None,
                 valid: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Flag that indicates whether someone enabled encryption at rest for the specified  project. To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        :param _builtins.str key_version_resource_id: Resource path that displays the key version resource ID for your Google Cloud KMS.
        :param _builtins.str role_id: Unique 24-hexadecimal digit string that identifies the Google Cloud Provider Access Role that MongoDB Cloud uses to access the Google Cloud KMS.
        :param _builtins.str service_account_key: JavaScript Object Notation (JSON) object that contains the Google Cloud Key Management Service (KMS). Format the JSON as a string and not as an object.
        :param _builtins.bool valid: Flag that indicates whether the Google Cloud Key Management Service (KMS) encryption key can encrypt and decrypt data.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if key_version_resource_id is not None:
            pulumi.set(__self__, "key_version_resource_id", key_version_resource_id)
        if role_id is not None:
            pulumi.set(__self__, "role_id", role_id)
        if service_account_key is not None:
            pulumi.set(__self__, "service_account_key", service_account_key)
        if valid is not None:
            pulumi.set(__self__, "valid", valid)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Flag that indicates whether someone enabled encryption at rest for the specified  project. To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="keyVersionResourceId")
    def key_version_resource_id(self) -> Optional[_builtins.str]:
        """
        Resource path that displays the key version resource ID for your Google Cloud KMS.
        """
        return pulumi.get(self, "key_version_resource_id")

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[_builtins.str]:
        """
        Unique 24-hexadecimal digit string that identifies the Google Cloud Provider Access Role that MongoDB Cloud uses to access the Google Cloud KMS.
        """
        return pulumi.get(self, "role_id")

    @_builtins.property
    @pulumi.getter(name="serviceAccountKey")
    def service_account_key(self) -> Optional[_builtins.str]:
        """
        JavaScript Object Notation (JSON) object that contains the Google Cloud Key Management Service (KMS). Format the JSON as a string and not as an object.
        """
        return pulumi.get(self, "service_account_key")

    @_builtins.property
    @pulumi.getter
    def valid(self) -> Optional[_builtins.bool]:
        """
        Flag that indicates whether the Google Cloud Key Management Service (KMS) encryption key can encrypt and decrypt data.
        """
        return pulumi.get(self, "valid")


@pulumi.output_type
class EncryptionAtRestPrivateEndpointTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Default: `3h`.
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs. Default: `3h`.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Default: `3h`.
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs. Default: `3h`.
        """
        return pulumi.get(self, "delete")


@pulumi.output_type
class EventTriggerEventProcessors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsEventbridge":
            suggest = "aws_eventbridge"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventTriggerEventProcessors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventTriggerEventProcessors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventTriggerEventProcessors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_eventbridge: Optional['outputs.EventTriggerEventProcessorsAwsEventbridge'] = None):
        if aws_eventbridge is not None:
            pulumi.set(__self__, "aws_eventbridge", aws_eventbridge)

    @_builtins.property
    @pulumi.getter(name="awsEventbridge")
    def aws_eventbridge(self) -> Optional['outputs.EventTriggerEventProcessorsAwsEventbridge']:
        return pulumi.get(self, "aws_eventbridge")


@pulumi.output_type
class EventTriggerEventProcessorsAwsEventbridge(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configAccountId":
            suggest = "config_account_id"
        elif key == "configRegion":
            suggest = "config_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventTriggerEventProcessorsAwsEventbridge. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventTriggerEventProcessorsAwsEventbridge.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventTriggerEventProcessorsAwsEventbridge.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_account_id: Optional[_builtins.str] = None,
                 config_region: Optional[_builtins.str] = None):
        if config_account_id is not None:
            pulumi.set(__self__, "config_account_id", config_account_id)
        if config_region is not None:
            pulumi.set(__self__, "config_region", config_region)

    @_builtins.property
    @pulumi.getter(name="configAccountId")
    def config_account_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "config_account_id")

    @_builtins.property
    @pulumi.getter(name="configRegion")
    def config_region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "config_region")


@pulumi.output_type
class FederatedDatabaseInstanceCloudProviderConfig(dict):
    def __init__(__self__, *,
                 aws: Optional['outputs.FederatedDatabaseInstanceCloudProviderConfigAws'] = None,
                 azure: Optional['outputs.FederatedDatabaseInstanceCloudProviderConfigAzure'] = None):
        """
        :param 'FederatedDatabaseInstanceCloudProviderConfigAwsArgs' aws: Name of the cloud service that hosts the Atlas Data Federation data stores.
        :param 'FederatedDatabaseInstanceCloudProviderConfigAzureArgs' azure: Microsoft Azure cloud service configuration.
        """
        if aws is not None:
            pulumi.set(__self__, "aws", aws)
        if azure is not None:
            pulumi.set(__self__, "azure", azure)

    @_builtins.property
    @pulumi.getter
    def aws(self) -> Optional['outputs.FederatedDatabaseInstanceCloudProviderConfigAws']:
        """
        Name of the cloud service that hosts the Atlas Data Federation data stores.
        """
        return pulumi.get(self, "aws")

    @_builtins.property
    @pulumi.getter
    def azure(self) -> Optional['outputs.FederatedDatabaseInstanceCloudProviderConfigAzure']:
        """
        Microsoft Azure cloud service configuration.
        """
        return pulumi.get(self, "azure")


@pulumi.output_type
class FederatedDatabaseInstanceCloudProviderConfigAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleId":
            suggest = "role_id"
        elif key == "testS3Bucket":
            suggest = "test_s3_bucket"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "iamAssumedRoleArn":
            suggest = "iam_assumed_role_arn"
        elif key == "iamUserArn":
            suggest = "iam_user_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedDatabaseInstanceCloudProviderConfigAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedDatabaseInstanceCloudProviderConfigAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedDatabaseInstanceCloudProviderConfigAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_id: _builtins.str,
                 test_s3_bucket: _builtins.str,
                 external_id: Optional[_builtins.str] = None,
                 iam_assumed_role_arn: Optional[_builtins.str] = None,
                 iam_user_arn: Optional[_builtins.str] = None):
        """
        :param _builtins.str external_id: Unique identifier associated with the IAM Role that the Federated Database Instance assumes when accessing the data stores.
        :param _builtins.str iam_assumed_role_arn: Amazon Resource Name (ARN) of the IAM Role that the Federated Database Instance assumes when accessing S3 Bucket data stores. The IAM Role must support the following actions against each S3 bucket:
               * `s3:GetObject`
               * `s3:ListBucket`
               * `s3:GetObjectVersion`
        :param _builtins.str iam_user_arn: Amazon Resource Name (ARN) of the user that the Federated Database Instance assumes when accessing S3 Bucket data stores.
        """
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "test_s3_bucket", test_s3_bucket)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if iam_assumed_role_arn is not None:
            pulumi.set(__self__, "iam_assumed_role_arn", iam_assumed_role_arn)
        if iam_user_arn is not None:
            pulumi.set(__self__, "iam_user_arn", iam_user_arn)

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> _builtins.str:
        return pulumi.get(self, "role_id")

    @_builtins.property
    @pulumi.getter(name="testS3Bucket")
    def test_s3_bucket(self) -> _builtins.str:
        return pulumi.get(self, "test_s3_bucket")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        Unique identifier associated with the IAM Role that the Federated Database Instance assumes when accessing the data stores.
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="iamAssumedRoleArn")
    def iam_assumed_role_arn(self) -> Optional[_builtins.str]:
        """
        Amazon Resource Name (ARN) of the IAM Role that the Federated Database Instance assumes when accessing S3 Bucket data stores. The IAM Role must support the following actions against each S3 bucket:
        * `s3:GetObject`
        * `s3:ListBucket`
        * `s3:GetObjectVersion`
        """
        return pulumi.get(self, "iam_assumed_role_arn")

    @_builtins.property
    @pulumi.getter(name="iamUserArn")
    def iam_user_arn(self) -> Optional[_builtins.str]:
        """
        Amazon Resource Name (ARN) of the user that the Federated Database Instance assumes when accessing S3 Bucket data stores.
        """
        return pulumi.get(self, "iam_user_arn")


@pulumi.output_type
class FederatedDatabaseInstanceCloudProviderConfigAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleId":
            suggest = "role_id"
        elif key == "atlasAppId":
            suggest = "atlas_app_id"
        elif key == "servicePrincipalId":
            suggest = "service_principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedDatabaseInstanceCloudProviderConfigAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedDatabaseInstanceCloudProviderConfigAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedDatabaseInstanceCloudProviderConfigAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_id: _builtins.str,
                 atlas_app_id: Optional[_builtins.str] = None,
                 service_principal_id: Optional[_builtins.str] = None,
                 tenant_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str service_principal_id: Unique identifier of the Azure service principal that the Federated Database instance uses to access Azure Blob Storage.
        :param _builtins.str tenant_id: Unique identifier of the Azure Active Directory tenant where the service principal resides.
        """
        pulumi.set(__self__, "role_id", role_id)
        if atlas_app_id is not None:
            pulumi.set(__self__, "atlas_app_id", atlas_app_id)
        if service_principal_id is not None:
            pulumi.set(__self__, "service_principal_id", service_principal_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> _builtins.str:
        return pulumi.get(self, "role_id")

    @_builtins.property
    @pulumi.getter(name="atlasAppId")
    def atlas_app_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "atlas_app_id")

    @_builtins.property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Azure service principal that the Federated Database instance uses to access Azure Blob Storage.
        """
        return pulumi.get(self, "service_principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the Azure Active Directory tenant where the service principal resides.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class FederatedDatabaseInstanceDataProcessRegion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudProvider":
            suggest = "cloud_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedDatabaseInstanceDataProcessRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedDatabaseInstanceDataProcessRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedDatabaseInstanceDataProcessRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_provider: _builtins.str,
                 region: _builtins.str):
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> _builtins.str:
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        return pulumi.get(self, "region")


@pulumi.output_type
class FederatedDatabaseInstanceStorageDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxWildcardCollections":
            suggest = "max_wildcard_collections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedDatabaseInstanceStorageDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedDatabaseInstanceStorageDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedDatabaseInstanceStorageDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collections: Optional[Sequence['outputs.FederatedDatabaseInstanceStorageDatabaseCollection']] = None,
                 max_wildcard_collections: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None,
                 views: Optional[Sequence['outputs.FederatedDatabaseInstanceStorageDatabaseView']] = None):
        """
        :param _builtins.str name: Name of the Atlas Federated Database Instance.
        """
        if collections is not None:
            pulumi.set(__self__, "collections", collections)
        if max_wildcard_collections is not None:
            pulumi.set(__self__, "max_wildcard_collections", max_wildcard_collections)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if views is not None:
            pulumi.set(__self__, "views", views)

    @_builtins.property
    @pulumi.getter
    def collections(self) -> Optional[Sequence['outputs.FederatedDatabaseInstanceStorageDatabaseCollection']]:
        return pulumi.get(self, "collections")

    @_builtins.property
    @pulumi.getter(name="maxWildcardCollections")
    def max_wildcard_collections(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_wildcard_collections")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def views(self) -> Optional[Sequence['outputs.FederatedDatabaseInstanceStorageDatabaseView']]:
        return pulumi.get(self, "views")


@pulumi.output_type
class FederatedDatabaseInstanceStorageDatabaseCollection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSources":
            suggest = "data_sources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedDatabaseInstanceStorageDatabaseCollection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedDatabaseInstanceStorageDatabaseCollection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedDatabaseInstanceStorageDatabaseCollection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_sources: Optional[Sequence['outputs.FederatedDatabaseInstanceStorageDatabaseCollectionDataSource']] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the Atlas Federated Database Instance.
        """
        if data_sources is not None:
            pulumi.set(__self__, "data_sources", data_sources)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Optional[Sequence['outputs.FederatedDatabaseInstanceStorageDatabaseCollectionDataSource']]:
        return pulumi.get(self, "data_sources")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class FederatedDatabaseInstanceStorageDatabaseCollectionDataSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowInsecure":
            suggest = "allow_insecure"
        elif key == "collectionRegex":
            suggest = "collection_regex"
        elif key == "databaseRegex":
            suggest = "database_regex"
        elif key == "datasetName":
            suggest = "dataset_name"
        elif key == "defaultFormat":
            suggest = "default_format"
        elif key == "provenanceFieldName":
            suggest = "provenance_field_name"
        elif key == "storeName":
            suggest = "store_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedDatabaseInstanceStorageDatabaseCollectionDataSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedDatabaseInstanceStorageDatabaseCollectionDataSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedDatabaseInstanceStorageDatabaseCollectionDataSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_insecure: Optional[_builtins.bool] = None,
                 collection: Optional[_builtins.str] = None,
                 collection_regex: Optional[_builtins.str] = None,
                 database: Optional[_builtins.str] = None,
                 database_regex: Optional[_builtins.str] = None,
                 dataset_name: Optional[_builtins.str] = None,
                 default_format: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 provenance_field_name: Optional[_builtins.str] = None,
                 store_name: Optional[_builtins.str] = None,
                 urls: Optional[Sequence[_builtins.str]] = None):
        if allow_insecure is not None:
            pulumi.set(__self__, "allow_insecure", allow_insecure)
        if collection is not None:
            pulumi.set(__self__, "collection", collection)
        if collection_regex is not None:
            pulumi.set(__self__, "collection_regex", collection_regex)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if database_regex is not None:
            pulumi.set(__self__, "database_regex", database_regex)
        if dataset_name is not None:
            pulumi.set(__self__, "dataset_name", dataset_name)
        if default_format is not None:
            pulumi.set(__self__, "default_format", default_format)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if provenance_field_name is not None:
            pulumi.set(__self__, "provenance_field_name", provenance_field_name)
        if store_name is not None:
            pulumi.set(__self__, "store_name", store_name)
        if urls is not None:
            pulumi.set(__self__, "urls", urls)

    @_builtins.property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_insecure")

    @_builtins.property
    @pulumi.getter
    def collection(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "collection")

    @_builtins.property
    @pulumi.getter(name="collectionRegex")
    def collection_regex(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "collection_regex")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="databaseRegex")
    def database_regex(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "database_regex")

    @_builtins.property
    @pulumi.getter(name="datasetName")
    def dataset_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dataset_name")

    @_builtins.property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default_format")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="provenanceFieldName")
    def provenance_field_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "provenance_field_name")

    @_builtins.property
    @pulumi.getter(name="storeName")
    def store_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "store_name")

    @_builtins.property
    @pulumi.getter
    def urls(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "urls")


@pulumi.output_type
class FederatedDatabaseInstanceStorageDatabaseView(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 pipeline: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the Atlas Federated Database Instance.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if pipeline is not None:
            pulumi.set(__self__, "pipeline", pipeline)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def pipeline(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pipeline")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "source")


@pulumi.output_type
class FederatedDatabaseInstanceStorageStore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalStorageClasses":
            suggest = "additional_storage_classes"
        elif key == "allowInsecure":
            suggest = "allow_insecure"
        elif key == "clusterName":
            suggest = "cluster_name"
        elif key == "defaultFormat":
            suggest = "default_format"
        elif key == "includeTags":
            suggest = "include_tags"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "readPreference":
            suggest = "read_preference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedDatabaseInstanceStorageStore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedDatabaseInstanceStorageStore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedDatabaseInstanceStorageStore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_storage_classes: Optional[Sequence[_builtins.str]] = None,
                 allow_insecure: Optional[_builtins.bool] = None,
                 bucket: Optional[_builtins.str] = None,
                 cluster_name: Optional[_builtins.str] = None,
                 default_format: Optional[_builtins.str] = None,
                 delimiter: Optional[_builtins.str] = None,
                 include_tags: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.str] = None,
                 project_id: Optional[_builtins.str] = None,
                 provider: Optional[_builtins.str] = None,
                 public: Optional[_builtins.str] = None,
                 read_preference: Optional['outputs.FederatedDatabaseInstanceStorageStoreReadPreference'] = None,
                 region: Optional[_builtins.str] = None,
                 urls: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str name: Name of the Atlas Federated Database Instance.
        :param _builtins.str project_id: The unique ID for the project to create a Federated Database Instance.
        """
        if additional_storage_classes is not None:
            pulumi.set(__self__, "additional_storage_classes", additional_storage_classes)
        if allow_insecure is not None:
            pulumi.set(__self__, "allow_insecure", allow_insecure)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if default_format is not None:
            pulumi.set(__self__, "default_format", default_format)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if include_tags is not None:
            pulumi.set(__self__, "include_tags", include_tags)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if public is not None:
            pulumi.set(__self__, "public", public)
        if read_preference is not None:
            pulumi.set(__self__, "read_preference", read_preference)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if urls is not None:
            pulumi.set(__self__, "urls", urls)

    @_builtins.property
    @pulumi.getter(name="additionalStorageClasses")
    def additional_storage_classes(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "additional_storage_classes")

    @_builtins.property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "allow_insecure")

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default_format")

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "delimiter")

    @_builtins.property
    @pulumi.getter(name="includeTags")
    def include_tags(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "include_tags")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        The unique ID for the project to create a Federated Database Instance.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def public(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "public")

    @_builtins.property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> Optional['outputs.FederatedDatabaseInstanceStorageStoreReadPreference']:
        return pulumi.get(self, "read_preference")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def urls(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "urls")


@pulumi.output_type
class FederatedDatabaseInstanceStorageStoreReadPreference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxStalenessSeconds":
            suggest = "max_staleness_seconds"
        elif key == "tagSets":
            suggest = "tag_sets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedDatabaseInstanceStorageStoreReadPreference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedDatabaseInstanceStorageStoreReadPreference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedDatabaseInstanceStorageStoreReadPreference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_staleness_seconds: Optional[_builtins.int] = None,
                 mode: Optional[_builtins.str] = None,
                 tag_sets: Optional[Sequence['outputs.FederatedDatabaseInstanceStorageStoreReadPreferenceTagSet']] = None):
        if max_staleness_seconds is not None:
            pulumi.set(__self__, "max_staleness_seconds", max_staleness_seconds)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if tag_sets is not None:
            pulumi.set(__self__, "tag_sets", tag_sets)

    @_builtins.property
    @pulumi.getter(name="maxStalenessSeconds")
    def max_staleness_seconds(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_staleness_seconds")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="tagSets")
    def tag_sets(self) -> Optional[Sequence['outputs.FederatedDatabaseInstanceStorageStoreReadPreferenceTagSet']]:
        return pulumi.get(self, "tag_sets")


@pulumi.output_type
class FederatedDatabaseInstanceStorageStoreReadPreferenceTagSet(dict):
    def __init__(__self__, *,
                 tags: Sequence['outputs.FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTag']):
        pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTag']:
        return pulumi.get(self, "tags")


@pulumi.output_type
class FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTag(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the Atlas Federated Database Instance.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class FederatedSettingsOrgConfigUserConflict(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emailAddress":
            suggest = "email_address"
        elif key == "federationSettingsId":
            suggest = "federation_settings_id"
        elif key == "firstName":
            suggest = "first_name"
        elif key == "lastName":
            suggest = "last_name"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedSettingsOrgConfigUserConflict. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedSettingsOrgConfigUserConflict.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedSettingsOrgConfigUserConflict.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email_address: Optional[_builtins.str] = None,
                 federation_settings_id: Optional[_builtins.str] = None,
                 first_name: Optional[_builtins.str] = None,
                 last_name: Optional[_builtins.str] = None,
                 user_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str email_address: Email address of the the user that conflicts with selected domains.
        :param _builtins.str federation_settings_id: Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        :param _builtins.str first_name: First name of the the user that conflicts with selected domains.
        :param _builtins.str last_name: Last name of the the user that conflicts with selected domains.
        :param _builtins.str user_id: Name of the Atlas user that conflicts with selected domains.
        """
        if email_address is not None:
            pulumi.set(__self__, "email_address", email_address)
        if federation_settings_id is not None:
            pulumi.set(__self__, "federation_settings_id", federation_settings_id)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> Optional[_builtins.str]:
        """
        Email address of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "email_address")

    @_builtins.property
    @pulumi.getter(name="federationSettingsId")
    def federation_settings_id(self) -> Optional[_builtins.str]:
        """
        Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        """
        return pulumi.get(self, "federation_settings_id")

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[_builtins.str]:
        """
        First name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[_builtins.str]:
        """
        Last name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "last_name")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.str]:
        """
        Name of the Atlas user that conflicts with selected domains.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class FederatedSettingsOrgRoleMappingRoleAssignment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupId":
            suggest = "group_id"
        elif key == "orgId":
            suggest = "org_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedSettingsOrgRoleMappingRoleAssignment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedSettingsOrgRoleMappingRoleAssignment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedSettingsOrgRoleMappingRoleAssignment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_id: Optional[_builtins.str] = None,
                 org_id: Optional[_builtins.str] = None,
                 roles: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param _builtins.str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param Sequence[_builtins.str] roles: Specifies the Roles that are attached to the Role Mapping. Available role IDs can be found on [the User Roles
               Reference](https://www.mongodb.com/docs/atlas/reference/user-roles/).
        """
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.str]:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[_builtins.str]:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the Roles that are attached to the Role Mapping. Available role IDs can be found on [the User Roles
        Reference](https://www.mongodb.com/docs/atlas/reference/user-roles/).
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class FlexClusterBackupSettings(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Flag that indicates whether backups are performed for this flex cluster. Backup uses [flex cluster backups](https://www.mongodb.com/docs/atlas/backup/cloud-backup/flex-cluster-backup/).
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Flag that indicates whether backups are performed for this flex cluster. Backup uses [flex cluster backups](https://www.mongodb.com/docs/atlas/backup/cloud-backup/flex-cluster-backup/).
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class FlexClusterConnectionStrings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "standardSrv":
            suggest = "standard_srv"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlexClusterConnectionStrings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlexClusterConnectionStrings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlexClusterConnectionStrings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 standard: Optional[_builtins.str] = None,
                 standard_srv: Optional[_builtins.str] = None):
        """
        :param _builtins.str standard: Public connection string that you can use to connect to this cluster. This connection string uses the mongodb:// protocol.
        :param _builtins.str standard_srv: Public connection string that you can use to connect to this flex cluster. This connection string uses the `mongodb+srv://` protocol.
        """
        if standard is not None:
            pulumi.set(__self__, "standard", standard)
        if standard_srv is not None:
            pulumi.set(__self__, "standard_srv", standard_srv)

    @_builtins.property
    @pulumi.getter
    def standard(self) -> Optional[_builtins.str]:
        """
        Public connection string that you can use to connect to this cluster. This connection string uses the mongodb:// protocol.
        """
        return pulumi.get(self, "standard")

    @_builtins.property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> Optional[_builtins.str]:
        """
        Public connection string that you can use to connect to this flex cluster. This connection string uses the `mongodb+srv://` protocol.
        """
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class FlexClusterProviderSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backingProviderName":
            suggest = "backing_provider_name"
        elif key == "regionName":
            suggest = "region_name"
        elif key == "diskSizeGb":
            suggest = "disk_size_gb"
        elif key == "providerName":
            suggest = "provider_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlexClusterProviderSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlexClusterProviderSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlexClusterProviderSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backing_provider_name: _builtins.str,
                 region_name: _builtins.str,
                 disk_size_gb: Optional[_builtins.float] = None,
                 provider_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str backing_provider_name: Cloud service provider on which MongoDB Cloud provisioned the flex cluster.
        :param _builtins.str region_name: Human-readable label that identifies the geographic location of your MongoDB flex cluster. The region you choose can affect network latency for clients accessing your databases. For a complete list of region names, see [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/#std-label-amazon-aws), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), and [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        :param _builtins.float disk_size_gb: Storage capacity available to the flex cluster expressed in gigabytes.
        :param _builtins.str provider_name: Human-readable label that identifies the cloud service provider.
        """
        pulumi.set(__self__, "backing_provider_name", backing_provider_name)
        pulumi.set(__self__, "region_name", region_name)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if provider_name is not None:
            pulumi.set(__self__, "provider_name", provider_name)

    @_builtins.property
    @pulumi.getter(name="backingProviderName")
    def backing_provider_name(self) -> _builtins.str:
        """
        Cloud service provider on which MongoDB Cloud provisioned the flex cluster.
        """
        return pulumi.get(self, "backing_provider_name")

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> _builtins.str:
        """
        Human-readable label that identifies the geographic location of your MongoDB flex cluster. The region you choose can affect network latency for clients accessing your databases. For a complete list of region names, see [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/#std-label-amazon-aws), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), and [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        """
        return pulumi.get(self, "region_name")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[_builtins.float]:
        """
        Storage capacity available to the flex cluster expressed in gigabytes.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> Optional[_builtins.str]:
        """
        Human-readable label that identifies the cloud service provider.
        """
        return pulumi.get(self, "provider_name")


@pulumi.output_type
class FlexClusterTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Default: `3h`.
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs. Default: `3h`.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Default: `3h`.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Default: `3h`.
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs. Default: `3h`.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Default: `3h`.
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class GlobalClusterConfigCustomZoneMapping(dict):
    def __init__(__self__, *,
                 location: Optional[_builtins.str] = None,
                 zone: Optional[_builtins.str] = None):
        """
        :param _builtins.str location: The ISO location code to which you want to map a zone in your Global Cluster. You can find a list of all supported location codes [here](https://cloud.mongodb.com/static/atlas/country_iso_codes.txt).
        :param _builtins.str zone: The name of the zone in your Global Cluster that you want to map to location.
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        """
        The ISO location code to which you want to map a zone in your Global Cluster. You can find a list of all supported location codes [here](https://cloud.mongodb.com/static/atlas/country_iso_codes.txt).
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[_builtins.str]:
        """
        The name of the zone in your Global Cluster that you want to map to location.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GlobalClusterConfigManagedNamespace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customShardKey":
            suggest = "custom_shard_key"
        elif key == "isCustomShardKeyHashed":
            suggest = "is_custom_shard_key_hashed"
        elif key == "isShardKeyUnique":
            suggest = "is_shard_key_unique"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalClusterConfigManagedNamespace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalClusterConfigManagedNamespace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalClusterConfigManagedNamespace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collection: _builtins.str,
                 custom_shard_key: _builtins.str,
                 db: _builtins.str,
                 is_custom_shard_key_hashed: Optional[_builtins.bool] = None,
                 is_shard_key_unique: Optional[_builtins.bool] = None):
        """
        :param _builtins.str collection: The name of the collection associated with the managed namespace.
        :param _builtins.str custom_shard_key: The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        :param _builtins.str db: The name of the database containing the collection.
        :param _builtins.bool is_custom_shard_key_hashed: Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.
        :param _builtins.bool is_shard_key_unique: Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).
        """
        pulumi.set(__self__, "collection", collection)
        pulumi.set(__self__, "custom_shard_key", custom_shard_key)
        pulumi.set(__self__, "db", db)
        if is_custom_shard_key_hashed is not None:
            pulumi.set(__self__, "is_custom_shard_key_hashed", is_custom_shard_key_hashed)
        if is_shard_key_unique is not None:
            pulumi.set(__self__, "is_shard_key_unique", is_shard_key_unique)

    @_builtins.property
    @pulumi.getter
    def collection(self) -> _builtins.str:
        """
        The name of the collection associated with the managed namespace.
        """
        return pulumi.get(self, "collection")

    @_builtins.property
    @pulumi.getter(name="customShardKey")
    def custom_shard_key(self) -> _builtins.str:
        """
        The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        """
        return pulumi.get(self, "custom_shard_key")

    @_builtins.property
    @pulumi.getter
    def db(self) -> _builtins.str:
        """
        The name of the database containing the collection.
        """
        return pulumi.get(self, "db")

    @_builtins.property
    @pulumi.getter(name="isCustomShardKeyHashed")
    def is_custom_shard_key_hashed(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.
        """
        return pulumi.get(self, "is_custom_shard_key_hashed")

    @_builtins.property
    @pulumi.getter(name="isShardKeyUnique")
    def is_shard_key_unique(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).
        """
        return pulumi.get(self, "is_shard_key_unique")


@pulumi.output_type
class LdapConfigurationUserToDnMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ldapQuery":
            suggest = "ldap_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LdapConfigurationUserToDnMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LdapConfigurationUserToDnMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LdapConfigurationUserToDnMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ldap_query: Optional[_builtins.str] = None,
                 match: Optional[_builtins.str] = None,
                 substitution: Optional[_builtins.str] = None):
        if ldap_query is not None:
            pulumi.set(__self__, "ldap_query", ldap_query)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if substitution is not None:
            pulumi.set(__self__, "substitution", substitution)

    @_builtins.property
    @pulumi.getter(name="ldapQuery")
    def ldap_query(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ldap_query")

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter
    def substitution(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "substitution")


@pulumi.output_type
class LdapVerifyLink(dict):
    def __init__(__self__, *,
                 href: Optional[_builtins.str] = None,
                 rel: Optional[_builtins.str] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "href")

    @_builtins.property
    @pulumi.getter
    def rel(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "rel")


@pulumi.output_type
class LdapVerifyValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "validationType":
            suggest = "validation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LdapVerifyValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LdapVerifyValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LdapVerifyValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status: Optional[_builtins.str] = None,
                 validation_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str status: The current status of the LDAP over TLS/SSL configuration. One of the following values: `PENDING`, `SUCCESS`, and `FAILED`.
        """
        if status is not None:
            pulumi.set(__self__, "status", status)
        if validation_type is not None:
            pulumi.set(__self__, "validation_type", validation_type)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        The current status of the LDAP over TLS/SSL configuration. One of the following values: `PENDING`, `SUCCESS`, and `FAILED`.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="validationType")
    def validation_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "validation_type")


@pulumi.output_type
class MaintenanceWindowProtectedHours(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endHourOfDay":
            suggest = "end_hour_of_day"
        elif key == "startHourOfDay":
            suggest = "start_hour_of_day"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MaintenanceWindowProtectedHours. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MaintenanceWindowProtectedHours.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MaintenanceWindowProtectedHours.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_hour_of_day: _builtins.int,
                 start_hour_of_day: _builtins.int):
        """
        :param _builtins.int end_hour_of_day: Zero-based integer that represents the end hour of the day for the protected hours window.
        :param _builtins.int start_hour_of_day: Zero-based integer that represents the beginning hour of the day for the protected hours window.
        """
        pulumi.set(__self__, "end_hour_of_day", end_hour_of_day)
        pulumi.set(__self__, "start_hour_of_day", start_hour_of_day)

    @_builtins.property
    @pulumi.getter(name="endHourOfDay")
    def end_hour_of_day(self) -> _builtins.int:
        """
        Zero-based integer that represents the end hour of the day for the protected hours window.
        """
        return pulumi.get(self, "end_hour_of_day")

    @_builtins.property
    @pulumi.getter(name="startHourOfDay")
    def start_hour_of_day(self) -> _builtins.int:
        """
        Zero-based integer that represents the beginning hour of the day for the protected hours window.
        """
        return pulumi.get(self, "start_hour_of_day")


@pulumi.output_type
class OnlineArchiveCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateField":
            suggest = "date_field"
        elif key == "dateFormat":
            suggest = "date_format"
        elif key == "expireAfterDays":
            suggest = "expire_after_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineArchiveCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineArchiveCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineArchiveCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 date_field: Optional[_builtins.str] = None,
                 date_format: Optional[_builtins.str] = None,
                 expire_after_days: Optional[_builtins.int] = None,
                 query: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Type of criteria (DATE, CUSTOM)
               
               The following fields are required for criteria type `DATE`
        :param _builtins.str date_field: Indexed database parameter that stores the date that determines when data moves to the online archive. MongoDB Cloud archives the data when the current date exceeds the date in this database parameter plus the number of days specified through the expireAfterDays parameter.
        :param _builtins.str date_format: Syntax used to write the date after which data moves to the online archive. Date can be expressed as ISO 8601 or Epoch timestamps. The Epoch timestamp can be expressed as nanoseconds, milliseconds, or seconds. You must set `type` to `DATE` if `collectionType` is `TIMESERIES`. Valid values:  ISODATE (default), EPOCH_SECONDS, EPOCH_MILLIS, EPOCH_NANOSECONDS.
        :param _builtins.int expire_after_days: Number of days after the value in the criteria.dateField when MongoDB Cloud archives data in the specified cluster.
               
               **_NOTE: if `DATE` is selected, the `partition_fields.field_name` must be completed with the `date_field` value_**
               
               The only field required for criteria type `CUSTOM`
        :param _builtins.str query: JSON query to use to select documents for archiving. Atlas uses the specified query with the db.collection.find(query) command. The empty document {} to return all documents is not supported.
        """
        pulumi.set(__self__, "type", type)
        if date_field is not None:
            pulumi.set(__self__, "date_field", date_field)
        if date_format is not None:
            pulumi.set(__self__, "date_format", date_format)
        if expire_after_days is not None:
            pulumi.set(__self__, "expire_after_days", expire_after_days)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of criteria (DATE, CUSTOM)

        The following fields are required for criteria type `DATE`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="dateField")
    def date_field(self) -> Optional[_builtins.str]:
        """
        Indexed database parameter that stores the date that determines when data moves to the online archive. MongoDB Cloud archives the data when the current date exceeds the date in this database parameter plus the number of days specified through the expireAfterDays parameter.
        """
        return pulumi.get(self, "date_field")

    @_builtins.property
    @pulumi.getter(name="dateFormat")
    def date_format(self) -> Optional[_builtins.str]:
        """
        Syntax used to write the date after which data moves to the online archive. Date can be expressed as ISO 8601 or Epoch timestamps. The Epoch timestamp can be expressed as nanoseconds, milliseconds, or seconds. You must set `type` to `DATE` if `collectionType` is `TIMESERIES`. Valid values:  ISODATE (default), EPOCH_SECONDS, EPOCH_MILLIS, EPOCH_NANOSECONDS.
        """
        return pulumi.get(self, "date_format")

    @_builtins.property
    @pulumi.getter(name="expireAfterDays")
    def expire_after_days(self) -> Optional[_builtins.int]:
        """
        Number of days after the value in the criteria.dateField when MongoDB Cloud archives data in the specified cluster.

        **_NOTE: if `DATE` is selected, the `partition_fields.field_name` must be completed with the `date_field` value_**

        The only field required for criteria type `CUSTOM`
        """
        return pulumi.get(self, "expire_after_days")

    @_builtins.property
    @pulumi.getter
    def query(self) -> Optional[_builtins.str]:
        """
        JSON query to use to select documents for archiving. Atlas uses the specified query with the db.collection.find(query) command. The empty document {} to return all documents is not supported.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class OnlineArchiveDataExpirationRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expireAfterDays":
            suggest = "expire_after_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineArchiveDataExpirationRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineArchiveDataExpirationRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineArchiveDataExpirationRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expire_after_days: _builtins.int):
        """
        :param _builtins.int expire_after_days: Number of days used in the date criteria for nominating documents for deletion. Value must be between 7 and 9215.
        """
        pulumi.set(__self__, "expire_after_days", expire_after_days)

    @_builtins.property
    @pulumi.getter(name="expireAfterDays")
    def expire_after_days(self) -> _builtins.int:
        """
        Number of days used in the date criteria for nominating documents for deletion. Value must be between 7 and 9215.
        """
        return pulumi.get(self, "expire_after_days")


@pulumi.output_type
class OnlineArchiveDataProcessRegion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudProvider":
            suggest = "cloud_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineArchiveDataProcessRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineArchiveDataProcessRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineArchiveDataProcessRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_provider: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        """
        :param _builtins.str cloud_provider: Human-readable label that identifies the Cloud service provider where you wish to store your archived data. `AZURE` may be selected only if Azure is the Cloud service provider for the cluster and no AWS online archive has been created for the cluster.
        :param _builtins.str region: Human-readable label that identifies the geographic location of the region where you wish to store your archived data. For allowed values, see [MongoDB Atlas API documentation](https://www.mongodb.com/docs/api/doc/atlas-admin-api-v2/operation/operation-createonlinearchive)
        """
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[_builtins.str]:
        """
        Human-readable label that identifies the Cloud service provider where you wish to store your archived data. `AZURE` may be selected only if Azure is the Cloud service provider for the cluster and no AWS online archive has been created for the cluster.
        """
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Human-readable label that identifies the geographic location of the region where you wish to store your archived data. For allowed values, see [MongoDB Atlas API documentation](https://www.mongodb.com/docs/api/doc/atlas-admin-api-v2/operation/operation-createonlinearchive)
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class OnlineArchivePartitionField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "fieldType":
            suggest = "field_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineArchivePartitionField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineArchivePartitionField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineArchivePartitionField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: _builtins.str,
                 order: _builtins.int,
                 field_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str field_name: Human-readable label that identifies the parameter that MongoDB Cloud uses to partition data. To specify a nested parameter, use the dot notation.
        :param _builtins.int order: Sequence in which MongoDB Cloud slices the collection data to create partitions. The resource expresses this sequence starting with zero. The value of the `criteria.dateField` parameter defaults as the first item in the partition sequence.
        :param _builtins.str field_type: Data type of the parameter that that MongoDB Cloud uses to partition data. Partition parameters of type UUID must be of binary subtype 4. MongoDB Cloud skips partition parameters of type UUID with subtype 3. Valid values: `date`, `int`, `long`, `objectId`, `string`, `uuid`.
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "order", order)
        if field_type is not None:
            pulumi.set(__self__, "field_type", field_type)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> _builtins.str:
        """
        Human-readable label that identifies the parameter that MongoDB Cloud uses to partition data. To specify a nested parameter, use the dot notation.
        """
        return pulumi.get(self, "field_name")

    @_builtins.property
    @pulumi.getter
    def order(self) -> _builtins.int:
        """
        Sequence in which MongoDB Cloud slices the collection data to create partitions. The resource expresses this sequence starting with zero. The value of the `criteria.dateField` parameter defaults as the first item in the partition sequence.
        """
        return pulumi.get(self, "order")

    @_builtins.property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> Optional[_builtins.str]:
        """
        Data type of the parameter that that MongoDB Cloud uses to partition data. Partition parameters of type UUID must be of binary subtype 4. MongoDB Cloud skips partition parameters of type UUID with subtype 3. Valid values: `date`, `int`, `long`, `objectId`, `string`, `uuid`.
        """
        return pulumi.get(self, "field_type")


@pulumi.output_type
class OnlineArchiveSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfMonth":
            suggest = "day_of_month"
        elif key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "endHour":
            suggest = "end_hour"
        elif key == "endMinute":
            suggest = "end_minute"
        elif key == "startHour":
            suggest = "start_hour"
        elif key == "startMinute":
            suggest = "start_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineArchiveSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineArchiveSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineArchiveSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 day_of_month: Optional[_builtins.int] = None,
                 day_of_week: Optional[_builtins.int] = None,
                 end_hour: Optional[_builtins.int] = None,
                 end_minute: Optional[_builtins.int] = None,
                 start_hour: Optional[_builtins.int] = None,
                 start_minute: Optional[_builtins.int] = None):
        """
        :param _builtins.str type: Type of schedule (``DAILY`, `MONTHLY`, `WEEKLY`).
        :param _builtins.int day_of_month: Day of the month when the scheduled archive starts. This field should be provided only when schedule `type` is `MONTHLY`.
        :param _builtins.int day_of_week: Day of the week when the scheduled archive starts. The week starts with Monday (1) and ends with Sunday (7). This field should be provided only when schedule `type` is `WEEKLY`.
        :param _builtins.int end_hour: Hour of the day when the scheduled window to run one online archive ends.
        :param _builtins.int end_minute: Minute of the hour when the scheduled window to run one online archive ends.
        :param _builtins.int start_hour: Hour of the day when the when the scheduled window to run one online archive starts.
        :param _builtins.int start_minute: Minute of the hour when the scheduled window to run one online archive starts.
        """
        pulumi.set(__self__, "type", type)
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if end_hour is not None:
            pulumi.set(__self__, "end_hour", end_hour)
        if end_minute is not None:
            pulumi.set(__self__, "end_minute", end_minute)
        if start_hour is not None:
            pulumi.set(__self__, "start_hour", start_hour)
        if start_minute is not None:
            pulumi.set(__self__, "start_minute", start_minute)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of schedule (``DAILY`, `MONTHLY`, `WEEKLY`).
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[_builtins.int]:
        """
        Day of the month when the scheduled archive starts. This field should be provided only when schedule `type` is `MONTHLY`.
        """
        return pulumi.get(self, "day_of_month")

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[_builtins.int]:
        """
        Day of the week when the scheduled archive starts. The week starts with Monday (1) and ends with Sunday (7). This field should be provided only when schedule `type` is `WEEKLY`.
        """
        return pulumi.get(self, "day_of_week")

    @_builtins.property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> Optional[_builtins.int]:
        """
        Hour of the day when the scheduled window to run one online archive ends.
        """
        return pulumi.get(self, "end_hour")

    @_builtins.property
    @pulumi.getter(name="endMinute")
    def end_minute(self) -> Optional[_builtins.int]:
        """
        Minute of the hour when the scheduled window to run one online archive ends.
        """
        return pulumi.get(self, "end_minute")

    @_builtins.property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> Optional[_builtins.int]:
        """
        Hour of the day when the when the scheduled window to run one online archive starts.
        """
        return pulumi.get(self, "start_hour")

    @_builtins.property
    @pulumi.getter(name="startMinute")
    def start_minute(self) -> Optional[_builtins.int]:
        """
        Minute of the hour when the scheduled window to run one online archive starts.
        """
        return pulumi.get(self, "start_minute")


@pulumi.output_type
class PrivateLinkEndpointServiceEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointName":
            suggest = "endpoint_name"
        elif key == "ipAddress":
            suggest = "ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkEndpointServiceEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkEndpointServiceEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkEndpointServiceEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_name: Optional[_builtins.str] = None,
                 ip_address: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None):
        """
        :param _builtins.str endpoint_name: Forwarding rule that corresponds to the endpoint you created in GCP.
        :param _builtins.str ip_address: Private IP address of the endpoint you created in GCP.
        :param _builtins.str status: Status of the endpoint. Atlas returns one of the [values shown above](https://docs.atlas.mongodb.com/reference/api/private-endpoints-endpoint-create-one/#std-label-ref-status-field).
        """
        if endpoint_name is not None:
            pulumi.set(__self__, "endpoint_name", endpoint_name)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="endpointName")
    def endpoint_name(self) -> Optional[_builtins.str]:
        """
        Forwarding rule that corresponds to the endpoint you created in GCP.
        """
        return pulumi.get(self, "endpoint_name")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[_builtins.str]:
        """
        Private IP address of the endpoint you created in GCP.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Status of the endpoint. Atlas returns one of the [values shown above](https://docs.atlas.mongodb.com/reference/api/private-endpoints-endpoint-create-one/#std-label-ref-status-field).
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ProjectApiKeyProjectAssignment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"
        elif key == "roleNames":
            suggest = "role_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectApiKeyProjectAssignment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectApiKeyProjectAssignment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectApiKeyProjectAssignment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_id: _builtins.str,
                 role_names: Sequence[_builtins.str]):
        """
        :param _builtins.str project_id: Project ID to assign to Access Key
        :param Sequence[_builtins.str] role_names: List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project. You must specify an array even if you are only associating a single role with the Programmatic API key. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) describes the valid roles that can be assigned.
        """
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "role_names", role_names)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Project ID to assign to Access Key
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[_builtins.str]:
        """
        List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project. You must specify an array even if you are only associating a single role with the Programmatic API key. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) describes the valid roles that can be assigned.
        """
        return pulumi.get(self, "role_names")


@pulumi.output_type
class ProjectIpAccessListTimeouts(dict):
    def __init__(__self__, *,
                 delete: Optional[_builtins.str] = None,
                 read: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param _builtins.str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class ProjectIpAddresses(dict):
    def __init__(__self__, *,
                 services: Optional['outputs.ProjectIpAddressesServices'] = None):
        if services is not None:
            pulumi.set(__self__, "services", services)

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional['outputs.ProjectIpAddressesServices']:
        return pulumi.get(self, "services")


@pulumi.output_type
class ProjectIpAddressesServices(dict):
    def __init__(__self__, *,
                 clusters: Optional[Sequence['outputs.ProjectIpAddressesServicesCluster']] = None):
        if clusters is not None:
            pulumi.set(__self__, "clusters", clusters)

    @_builtins.property
    @pulumi.getter
    def clusters(self) -> Optional[Sequence['outputs.ProjectIpAddressesServicesCluster']]:
        return pulumi.get(self, "clusters")


@pulumi.output_type
class ProjectIpAddressesServicesCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectIpAddressesServicesCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectIpAddressesServicesCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectIpAddressesServicesCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_name: Optional[_builtins.str] = None,
                 inbounds: Optional[Sequence[_builtins.str]] = None,
                 outbounds: Optional[Sequence[_builtins.str]] = None):
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if inbounds is not None:
            pulumi.set(__self__, "inbounds", inbounds)
        if outbounds is not None:
            pulumi.set(__self__, "outbounds", outbounds)

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter
    def inbounds(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "inbounds")

    @_builtins.property
    @pulumi.getter
    def outbounds(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "outbounds")


@pulumi.output_type
class ProjectLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currentUsage":
            suggest = "current_usage"
        elif key == "defaultLimit":
            suggest = "default_limit"
        elif key == "maximumLimit":
            suggest = "maximum_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.int,
                 current_usage: Optional[_builtins.int] = None,
                 default_limit: Optional[_builtins.int] = None,
                 maximum_limit: Optional[_builtins.int] = None):
        """
        :param _builtins.str name: Human-readable label that identifies this project limit. See [Project Limit Documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Projects/operation/setProjectLimit) under `limitName` parameter to find all the limits that can be defined.
        :param _builtins.int value: Amount to set the limit to. Use the [Project Limit Documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Projects/operation/setProjectLimit) under `limitName` parameter to verify the override limits.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if current_usage is not None:
            pulumi.set(__self__, "current_usage", current_usage)
        if default_limit is not None:
            pulumi.set(__self__, "default_limit", default_limit)
        if maximum_limit is not None:
            pulumi.set(__self__, "maximum_limit", maximum_limit)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Human-readable label that identifies this project limit. See [Project Limit Documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Projects/operation/setProjectLimit) under `limitName` parameter to find all the limits that can be defined.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        """
        Amount to set the limit to. Use the [Project Limit Documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Projects/operation/setProjectLimit) under `limitName` parameter to verify the override limits.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="currentUsage")
    def current_usage(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "current_usage")

    @_builtins.property
    @pulumi.getter(name="defaultLimit")
    def default_limit(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "default_limit")

    @_builtins.property
    @pulumi.getter(name="maximumLimit")
    def maximum_limit(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "maximum_limit")


@pulumi.output_type
class ProjectServiceAccountSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "expiresAt":
            suggest = "expires_at"
        elif key == "lastUsedAt":
            suggest = "last_used_at"
        elif key == "maskedSecretValue":
            suggest = "masked_secret_value"
        elif key == "secretId":
            suggest = "secret_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectServiceAccountSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectServiceAccountSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectServiceAccountSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 expires_at: Optional[_builtins.str] = None,
                 last_used_at: Optional[_builtins.str] = None,
                 masked_secret_value: Optional[_builtins.str] = None,
                 secret: Optional[_builtins.str] = None,
                 secret_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: The date that the secret was created on. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str expires_at: The date for the expiration of the secret. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str last_used_at: The last time the secret was used. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str masked_secret_value: The masked Service Account secret.
        :param _builtins.str secret: The secret for the Service Account. It will be returned only the first time after creation.
        :param _builtins.str secret_id: Unique 24-hexadecimal digit string that identifies the secret.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if last_used_at is not None:
            pulumi.set(__self__, "last_used_at", last_used_at)
        if masked_secret_value is not None:
            pulumi.set(__self__, "masked_secret_value", masked_secret_value)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if secret_id is not None:
            pulumi.set(__self__, "secret_id", secret_id)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The date that the secret was created on. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[_builtins.str]:
        """
        The date for the expiration of the secret. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter(name="lastUsedAt")
    def last_used_at(self) -> Optional[_builtins.str]:
        """
        The last time the secret was used. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "last_used_at")

    @_builtins.property
    @pulumi.getter(name="maskedSecretValue")
    def masked_secret_value(self) -> Optional[_builtins.str]:
        """
        The masked Service Account secret.
        """
        return pulumi.get(self, "masked_secret_value")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        The secret for the Service Account. It will be returned only the first time after creation.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> Optional[_builtins.str]:
        """
        Unique 24-hexadecimal digit string that identifies the secret.
        """
        return pulumi.get(self, "secret_id")


@pulumi.output_type
class ProjectTeam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleNames":
            suggest = "role_names"
        elif key == "teamId":
            suggest = "team_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectTeam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectTeam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectTeam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_names: Sequence[_builtins.str],
                 team_id: _builtins.str):
        """
        :param Sequence[_builtins.str] role_names: Each string in the array represents a project role you want to assign to the team. Every user associated with the team inherits these roles. You must specify an array even if you are only associating a single role with the team. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles a user can have.
               
               > **NOTE:** Project created by API Keys must belong to an existing organization.
        :param _builtins.str team_id: The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
        """
        pulumi.set(__self__, "role_names", role_names)
        pulumi.set(__self__, "team_id", team_id)

    @_builtins.property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[_builtins.str]:
        """
        Each string in the array represents a project role you want to assign to the team. Every user associated with the team inherits these roles. You must specify an array even if you are only associating a single role with the team. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles a user can have.

        > **NOTE:** Project created by API Keys must belong to an existing organization.
        """
        return pulumi.get(self, "role_names")

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> _builtins.str:
        """
        The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
        """
        return pulumi.get(self, "team_id")


@pulumi.output_type
class PushBasedLogExportTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Default: `15m`.
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs. Default: `15m`.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Default: `15m`.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Default: `15m`.
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs. Default: `15m`.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Default: `15m`.
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class ResourcePolicyCreatedByUser(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Unique 24-hexadecimal character string that identifies a user.
        :param _builtins.str name: Human-readable label that describes a user.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique 24-hexadecimal character string that identifies a user.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Human-readable label that describes a user.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ResourcePolicyLastUpdatedByUser(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Unique 24-hexadecimal character string that identifies a user.
        :param _builtins.str name: Human-readable label that describes a user.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique 24-hexadecimal character string that identifies a user.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Human-readable label that describes a user.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ResourcePolicyPolicy(dict):
    def __init__(__self__, *,
                 body: _builtins.str,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str body: A string that defines the permissions for the policy. The syntax used is the Cedar Policy language.
        :param _builtins.str id: Unique 24-hexadecimal character string that identifies the policy.
        """
        pulumi.set(__self__, "body", body)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def body(self) -> _builtins.str:
        """
        A string that defines the permissions for the policy. The syntax used is the Cedar Policy language.
        """
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique 24-hexadecimal character string that identifies the policy.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class SearchDeploymentSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceSize":
            suggest = "instance_size"
        elif key == "nodeCount":
            suggest = "node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SearchDeploymentSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SearchDeploymentSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SearchDeploymentSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_size: _builtins.str,
                 node_count: _builtins.int):
        """
        :param _builtins.str instance_size: Hardware specification for the search node instance sizes. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Atlas-Search/operation/createAtlasSearchDeployment) describes the valid values. More details can also be found in the [Search Node Documentation](https://www.mongodb.com/docs/atlas/cluster-config/multi-cloud-distribution/#search-tier).
        :param _builtins.int node_count: Number of search nodes in the cluster.
        """
        pulumi.set(__self__, "instance_size", instance_size)
        pulumi.set(__self__, "node_count", node_count)

    @_builtins.property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> _builtins.str:
        """
        Hardware specification for the search node instance sizes. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Atlas-Search/operation/createAtlasSearchDeployment) describes the valid values. More details can also be found in the [Search Node Documentation](https://www.mongodb.com/docs/atlas/cluster-config/multi-cloud-distribution/#search-tier).
        """
        return pulumi.get(self, "instance_size")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> _builtins.int:
        """
        Number of search nodes in the cluster.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class SearchDeploymentTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.str] = None,
                 update: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Default: `3h`.
        :param _builtins.str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs. Default: `3h`.
        :param _builtins.str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Default: `3h`.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Default: `3h`.
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs. Default: `3h`.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Default: `3h`.
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class SearchIndexSynonym(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceCollection":
            suggest = "source_collection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SearchIndexSynonym. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SearchIndexSynonym.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SearchIndexSynonym.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 analyzer: _builtins.str,
                 name: _builtins.str,
                 source_collection: _builtins.str):
        """
        :param _builtins.str analyzer: [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index. Defaults to [lucene.standard](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/standard/#std-label-ref-standard-analyzer)
        :param _builtins.str name: The name of the search index you want to create.
        :param _builtins.str source_collection: (Required) Name of the source MongoDB collection for the synonyms. Documents in this collection must be in the format described in the [Synonyms Source Collection Documents](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-coll-spec).
        """
        pulumi.set(__self__, "analyzer", analyzer)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source_collection", source_collection)

    @_builtins.property
    @pulumi.getter
    def analyzer(self) -> _builtins.str:
        """
        [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index. Defaults to [lucene.standard](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/standard/#std-label-ref-standard-analyzer)
        """
        return pulumi.get(self, "analyzer")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the search index you want to create.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="sourceCollection")
    def source_collection(self) -> _builtins.str:
        """
        (Required) Name of the source MongoDB collection for the synonyms. Documents in this collection must be in the format described in the [Synonyms Source Collection Documents](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-coll-spec).
        """
        return pulumi.get(self, "source_collection")


@pulumi.output_type
class SearchIndexTypeSet(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 types: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the type set.
        :param _builtins.str types: JSON array describing the types.
        """
        pulumi.set(__self__, "name", name)
        if types is not None:
            pulumi.set(__self__, "types", types)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the type set.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def types(self) -> Optional[_builtins.str]:
        """
        JSON array describing the types.
        """
        return pulumi.get(self, "types")


@pulumi.output_type
class ServerlessInstanceLink(dict):
    def __init__(__self__, *,
                 href: Optional[_builtins.str] = None,
                 rel: Optional[_builtins.str] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "href")

    @_builtins.property
    @pulumi.getter
    def rel(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "rel")


@pulumi.output_type
class ServerlessInstanceTag(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Constant that defines the set of the tag.
        :param _builtins.str value: Variable that belongs to the set of the tag.
               
               To learn more, see [Resource Tags](https://dochub.mongodb.org/core/add-cluster-tag-atlas).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Constant that defines the set of the tag.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Variable that belongs to the set of the tag.

        To learn more, see [Resource Tags](https://dochub.mongodb.org/core/add-cluster-tag-atlas).
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceAccountSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "expiresAt":
            suggest = "expires_at"
        elif key == "lastUsedAt":
            suggest = "last_used_at"
        elif key == "maskedSecretValue":
            suggest = "masked_secret_value"
        elif key == "secretId":
            suggest = "secret_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAccountSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAccountSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAccountSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 expires_at: Optional[_builtins.str] = None,
                 last_used_at: Optional[_builtins.str] = None,
                 masked_secret_value: Optional[_builtins.str] = None,
                 secret: Optional[_builtins.str] = None,
                 secret_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: The date that the secret was created on. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str expires_at: The date for the expiration of the secret. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str last_used_at: The last time the secret was used. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str masked_secret_value: The masked Service Account secret.
        :param _builtins.str secret: The secret for the Service Account. It will be returned only the first time after creation.
        :param _builtins.str secret_id: Unique 24-hexadecimal digit string that identifies the secret.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if last_used_at is not None:
            pulumi.set(__self__, "last_used_at", last_used_at)
        if masked_secret_value is not None:
            pulumi.set(__self__, "masked_secret_value", masked_secret_value)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if secret_id is not None:
            pulumi.set(__self__, "secret_id", secret_id)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The date that the secret was created on. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[_builtins.str]:
        """
        The date for the expiration of the secret. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter(name="lastUsedAt")
    def last_used_at(self) -> Optional[_builtins.str]:
        """
        The last time the secret was used. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "last_used_at")

    @_builtins.property
    @pulumi.getter(name="maskedSecretValue")
    def masked_secret_value(self) -> Optional[_builtins.str]:
        """
        The masked Service Account secret.
        """
        return pulumi.get(self, "masked_secret_value")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional[_builtins.str]:
        """
        The secret for the Service Account. It will be returned only the first time after creation.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> Optional[_builtins.str]:
        """
        Unique 24-hexadecimal digit string that identifies the secret.
        """
        return pulumi.get(self, "secret_id")


@pulumi.output_type
class StreamConnectionAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "saslOauthbearerExtensions":
            suggest = "sasl_oauthbearer_extensions"
        elif key == "tokenEndpointUrl":
            suggest = "token_endpoint_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamConnectionAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamConnectionAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamConnectionAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[_builtins.str] = None,
                 client_secret: Optional[_builtins.str] = None,
                 mechanism: Optional[_builtins.str] = None,
                 method: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 sasl_oauthbearer_extensions: Optional[_builtins.str] = None,
                 scope: Optional[_builtins.str] = None,
                 token_endpoint_url: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_id: Public identifier for the Kafka client.
        :param _builtins.str client_secret: Secret known only to the Kafka client and the authorization server.
        :param _builtins.str mechanism: Method of authentication. Value can be `PLAIN`, `SCRAM-256`, or `SCRAM-512`.
        :param _builtins.str method: SASL OAUTHBEARER authentication method. Value must be OIDC.
        :param _builtins.str password: Password of the account to connect to the Kafka cluster.
        :param _builtins.str sasl_oauthbearer_extensions: Additional information to provide to the Kafka broker.
        :param _builtins.str scope: Scope of the access request to the broker specified by the Kafka clients.
        :param _builtins.str token_endpoint_url: OAUTH issuer (IdP provider) token endpoint HTTP(S) URI used to retrieve the token.
        :param _builtins.str username: Username of the account to connect to the Kafka cluster.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if mechanism is not None:
            pulumi.set(__self__, "mechanism", mechanism)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if sasl_oauthbearer_extensions is not None:
            pulumi.set(__self__, "sasl_oauthbearer_extensions", sasl_oauthbearer_extensions)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if token_endpoint_url is not None:
            pulumi.set(__self__, "token_endpoint_url", token_endpoint_url)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        Public identifier for the Kafka client.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[_builtins.str]:
        """
        Secret known only to the Kafka client and the authorization server.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter
    def mechanism(self) -> Optional[_builtins.str]:
        """
        Method of authentication. Value can be `PLAIN`, `SCRAM-256`, or `SCRAM-512`.
        """
        return pulumi.get(self, "mechanism")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        """
        SASL OAUTHBEARER authentication method. Value must be OIDC.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Password of the account to connect to the Kafka cluster.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="saslOauthbearerExtensions")
    def sasl_oauthbearer_extensions(self) -> Optional[_builtins.str]:
        """
        Additional information to provide to the Kafka broker.
        """
        return pulumi.get(self, "sasl_oauthbearer_extensions")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[_builtins.str]:
        """
        Scope of the access request to the broker specified by the Kafka clients.
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter(name="tokenEndpointUrl")
    def token_endpoint_url(self) -> Optional[_builtins.str]:
        """
        OAUTH issuer (IdP provider) token endpoint HTTP(S) URI used to retrieve the token.
        """
        return pulumi.get(self, "token_endpoint_url")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        Username of the account to connect to the Kafka cluster.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class StreamConnectionAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamConnectionAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamConnectionAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamConnectionAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: _builtins.str):
        """
        :param _builtins.str role_arn: Amazon Resource Name (ARN) that identifies the Amazon Web Services (AWS) Identity and Access Management (IAM) role that MongoDB Cloud assumes when it accesses resources in your AWS account.
        """
        pulumi.set(__self__, "role_arn", role_arn)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        """
        Amazon Resource Name (ARN) that identifies the Amazon Web Services (AWS) Identity and Access Management (IAM) role that MongoDB Cloud assumes when it accesses resources in your AWS account.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class StreamConnectionDbRoleToExecute(dict):
    def __init__(__self__, *,
                 role: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str role: The name of the role to use. Value can be  `atlasAdmin`, `readWriteAnyDatabase`, or `readAnyDatabase` if `type` is set to `BUILT_IN`, or the name of a user-defined role if `type` is set to `CUSTOM`.
        :param _builtins.str type: Type of connection. Can be `AWSLambda`, `Cluster`, `Https`, `Kafka`, `Sample`, or `SchemaRegistry`.
               
               > **NOTE:** Either `workspace_name` or `instance_name` must be provided, but not both. These fields are functionally identical and `workspace_name` is an alias for `instance_name`. `workspace_name` should be used instead of `instance_name`.
        """
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The name of the role to use. Value can be  `atlasAdmin`, `readWriteAnyDatabase`, or `readAnyDatabase` if `type` is set to `BUILT_IN`, or the name of a user-defined role if `type` is set to `CUSTOM`.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of connection. Can be `AWSLambda`, `Cluster`, `Https`, `Kafka`, `Sample`, or `SchemaRegistry`.

        > **NOTE:** Either `workspace_name` or `instance_name` must be provided, but not both. These fields are functionally identical and `workspace_name` is an alias for `instance_name`. `workspace_name` should be used instead of `instance_name`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class StreamConnectionNetworking(dict):
    def __init__(__self__, *,
                 access: 'outputs.StreamConnectionNetworkingAccess'):
        """
        :param 'StreamConnectionNetworkingAccessArgs' access: Information about the networking access. See access.
        """
        pulumi.set(__self__, "access", access)

    @_builtins.property
    @pulumi.getter
    def access(self) -> 'outputs.StreamConnectionNetworkingAccess':
        """
        Information about the networking access. See access.
        """
        return pulumi.get(self, "access")


@pulumi.output_type
class StreamConnectionNetworkingAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionId":
            suggest = "connection_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamConnectionNetworkingAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamConnectionNetworkingAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamConnectionNetworkingAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 connection_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Selected networking type. Either `PUBLIC`, `VPC` or `PRIVATE_LINK`. Defaults to `PUBLIC`.
        :param _builtins.str connection_id: Id of the Private Link connection when type is `PRIVATE_LINK`.
        """
        pulumi.set(__self__, "type", type)
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Selected networking type. Either `PUBLIC`, `VPC` or `PRIVATE_LINK`. Defaults to `PUBLIC`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[_builtins.str]:
        """
        Id of the Private Link connection when type is `PRIVATE_LINK`.
        """
        return pulumi.get(self, "connection_id")


@pulumi.output_type
class StreamConnectionSchemaRegistryAuthentication(dict):
    def __init__(__self__, *,
                 password: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str password: Password for the Schema Registry. Required when `type` is `USER_INFO`.
        :param _builtins.str type: Authentication type discriminator. Specifies the authentication mechanism for Confluent Schema Registry. Valid values are `USER_INFO` or `SASL_INHERIT`.
               * `USER_INFO` - Uses username and password authentication for Confluent Schema Registry.
               * `SASL_INHERIT` - Inherits the authentication configuration from Kafka for the Confluent Schema Registry.
        :param _builtins.str username: Username for the Schema Registry. Required when `type` is `USER_INFO`.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Password for the Schema Registry. Required when `type` is `USER_INFO`.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Authentication type discriminator. Specifies the authentication mechanism for Confluent Schema Registry. Valid values are `USER_INFO` or `SASL_INHERIT`.
        * `USER_INFO` - Uses username and password authentication for Confluent Schema Registry.
        * `SASL_INHERIT` - Inherits the authentication configuration from Kafka for the Confluent Schema Registry.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        Username for the Schema Registry. Required when `type` is `USER_INFO`.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class StreamConnectionSecurity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "brokerPublicCertificate":
            suggest = "broker_public_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamConnectionSecurity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamConnectionSecurity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamConnectionSecurity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 broker_public_certificate: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None):
        """
        :param _builtins.str broker_public_certificate: A trusted, public x509 certificate for connecting to Kafka over SSL. String value of the certificate must be defined in the attribute.
        :param _builtins.str protocol: Describes the transport type. Can be either `SASL_PLAINTEXT` or `SASL_SSL`.
        """
        if broker_public_certificate is not None:
            pulumi.set(__self__, "broker_public_certificate", broker_public_certificate)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="brokerPublicCertificate")
    def broker_public_certificate(self) -> Optional[_builtins.str]:
        """
        A trusted, public x509 certificate for connecting to Kafka over SSL. String value of the certificate must be defined in the attribute.
        """
        return pulumi.get(self, "broker_public_certificate")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        Describes the transport type. Can be either `SASL_PLAINTEXT` or `SASL_SSL`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class StreamInstanceDataProcessRegion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudProvider":
            suggest = "cloud_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamInstanceDataProcessRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamInstanceDataProcessRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamInstanceDataProcessRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_provider: _builtins.str,
                 region: _builtins.str):
        """
        :param _builtins.str cloud_provider: Label that identifies the cloud service provider where MongoDB Cloud performs stream processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        :param _builtins.str region: Name of the cloud provider region hosting Atlas Stream Processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> _builtins.str:
        """
        Label that identifies the cloud service provider where MongoDB Cloud performs stream processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Name of the cloud provider region hosting Atlas Stream Processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class StreamInstanceStreamConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxTierSize":
            suggest = "max_tier_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamInstanceStreamConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamInstanceStreamConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamInstanceStreamConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_tier_size: Optional[_builtins.str] = None,
                 tier: Optional[_builtins.str] = None):
        """
        :param _builtins.str tier: Selected tier for the Stream Instance. Configures Memory / VCPU allowances. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        if max_tier_size is not None:
            pulumi.set(__self__, "max_tier_size", max_tier_size)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @_builtins.property
    @pulumi.getter(name="maxTierSize")
    def max_tier_size(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "max_tier_size")

    @_builtins.property
    @pulumi.getter
    def tier(self) -> Optional[_builtins.str]:
        """
        Selected tier for the Stream Instance. Configures Memory / VCPU allowances. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class StreamProcessorOptions(dict):
    def __init__(__self__, *,
                 dlq: 'outputs.StreamProcessorOptionsDlq'):
        """
        :param 'StreamProcessorOptionsDlqArgs' dlq: Dead letter queue for the stream processor. Refer to the [MongoDB Atlas Docs](https://www.mongodb.com/docs/atlas/reference/glossary/#std-term-dead-letter-queue) for more information.
        """
        pulumi.set(__self__, "dlq", dlq)

    @_builtins.property
    @pulumi.getter
    def dlq(self) -> 'outputs.StreamProcessorOptionsDlq':
        """
        Dead letter queue for the stream processor. Refer to the [MongoDB Atlas Docs](https://www.mongodb.com/docs/atlas/reference/glossary/#std-term-dead-letter-queue) for more information.
        """
        return pulumi.get(self, "dlq")


@pulumi.output_type
class StreamProcessorOptionsDlq(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionName":
            suggest = "connection_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamProcessorOptionsDlq. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamProcessorOptionsDlq.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamProcessorOptionsDlq.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 coll: _builtins.str,
                 connection_name: _builtins.str,
                 db: _builtins.str):
        """
        :param _builtins.str coll: Name of the collection to use for the DLQ.
        :param _builtins.str connection_name: Name of the connection to write DLQ messages to. Must be an Atlas connection.
        :param _builtins.str db: Name of the database to use for the DLQ.
        """
        pulumi.set(__self__, "coll", coll)
        pulumi.set(__self__, "connection_name", connection_name)
        pulumi.set(__self__, "db", db)

    @_builtins.property
    @pulumi.getter
    def coll(self) -> _builtins.str:
        """
        Name of the collection to use for the DLQ.
        """
        return pulumi.get(self, "coll")

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> _builtins.str:
        """
        Name of the connection to write DLQ messages to. Must be an Atlas connection.
        """
        return pulumi.get(self, "connection_name")

    @_builtins.property
    @pulumi.getter
    def db(self) -> _builtins.str:
        """
        Name of the database to use for the DLQ.
        """
        return pulumi.get(self, "db")


@pulumi.output_type
class StreamProcessorTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[_builtins.str] = None):
        """
        :param _builtins.str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Default: `3h`.
        """
        if create is not None:
            pulumi.set(__self__, "create", create)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), and "h" (hours). Default: `3h`.
        """
        return pulumi.get(self, "create")


@pulumi.output_type
class StreamWorkspaceDataProcessRegion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudProvider":
            suggest = "cloud_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamWorkspaceDataProcessRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamWorkspaceDataProcessRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamWorkspaceDataProcessRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_provider: _builtins.str,
                 region: _builtins.str):
        """
        :param _builtins.str cloud_provider: Label that identifies the cloud service provider where MongoDB Cloud performs stream processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/creategroupstreamworkspace) describes the valid values.
        :param _builtins.str region: Name of the cloud provider region hosting Atlas Stream Processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/creategroupstreamworkspace) describes the valid values.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> _builtins.str:
        """
        Label that identifies the cloud service provider where MongoDB Cloud performs stream processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/creategroupstreamworkspace) describes the valid values.
        """
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Name of the cloud provider region hosting Atlas Stream Processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/creategroupstreamworkspace) describes the valid values.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class StreamWorkspaceStreamConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxTierSize":
            suggest = "max_tier_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamWorkspaceStreamConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamWorkspaceStreamConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamWorkspaceStreamConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_tier_size: Optional[_builtins.str] = None,
                 tier: Optional[_builtins.str] = None):
        """
        :param _builtins.str max_tier_size: Max tier size for the Stream Workspace. Configures Memory / VCPU allowances.
        :param _builtins.str tier: Selected tier for the Stream Workspace. Configures Memory / VCPU allowances. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/creategroupstreamworkspace) describes the valid values.
        """
        if max_tier_size is not None:
            pulumi.set(__self__, "max_tier_size", max_tier_size)
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @_builtins.property
    @pulumi.getter(name="maxTierSize")
    def max_tier_size(self) -> Optional[_builtins.str]:
        """
        Max tier size for the Stream Workspace. Configures Memory / VCPU allowances.
        """
        return pulumi.get(self, "max_tier_size")

    @_builtins.property
    @pulumi.getter
    def tier(self) -> Optional[_builtins.str]:
        """
        Selected tier for the Stream Workspace. Configures Memory / VCPU allowances. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/creategroupstreamworkspace) describes the valid values.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class X509AuthenticationDatabaseUserCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "notAfter":
            suggest = "not_after"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in X509AuthenticationDatabaseUserCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        X509AuthenticationDatabaseUserCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        X509AuthenticationDatabaseUserCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 group_id: Optional[_builtins.str] = None,
                 id: Optional[_builtins.int] = None,
                 not_after: Optional[_builtins.str] = None,
                 subject: Optional[_builtins.str] = None):
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if not_after is not None:
            pulumi.set(__self__, "not_after", not_after)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "not_after")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subject")


@pulumi.output_type
class GetAccessListApiKeysResultResult(dict):
    def __init__(__self__, *,
                 access_count: _builtins.int,
                 cidr_block: _builtins.str,
                 created: _builtins.str,
                 ip_address: _builtins.str,
                 last_used: _builtins.str,
                 last_used_address: _builtins.str):
        """
        :param _builtins.int access_count: Total number of requests that have originated from this IP address or CIDR block.
        :param _builtins.str cidr_block: Range of IP addresses in CIDR notation included in the API access list.
        :param _builtins.str created: Date and time when the access list entry was created.
        :param _builtins.str ip_address: IP address included in the API access list.
        :param _builtins.str last_used: Date and time when the API key was last used from this IP address or CIDR block.
        :param _builtins.str last_used_address: IP address from which the last API request was made.
        """
        pulumi.set(__self__, "access_count", access_count)
        pulumi.set(__self__, "cidr_block", cidr_block)
        pulumi.set(__self__, "created", created)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "last_used", last_used)
        pulumi.set(__self__, "last_used_address", last_used_address)

    @_builtins.property
    @pulumi.getter(name="accessCount")
    def access_count(self) -> _builtins.int:
        """
        Total number of requests that have originated from this IP address or CIDR block.
        """
        return pulumi.get(self, "access_count")

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> _builtins.str:
        """
        Range of IP addresses in CIDR notation included in the API access list.
        """
        return pulumi.get(self, "cidr_block")

    @_builtins.property
    @pulumi.getter
    def created(self) -> _builtins.str:
        """
        Date and time when the access list entry was created.
        """
        return pulumi.get(self, "created")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> _builtins.str:
        """
        IP address included in the API access list.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter(name="lastUsed")
    def last_used(self) -> _builtins.str:
        """
        Date and time when the API key was last used from this IP address or CIDR block.
        """
        return pulumi.get(self, "last_used")

    @_builtins.property
    @pulumi.getter(name="lastUsedAddress")
    def last_used_address(self) -> _builtins.str:
        """
        IP address from which the last API request was made.
        """
        return pulumi.get(self, "last_used_address")


@pulumi.output_type
class GetAdvancedClusterAdvancedConfigurationResult(dict):
    def __init__(__self__, *,
                 change_stream_options_pre_and_post_images_expire_after_seconds: _builtins.int,
                 custom_openssl_cipher_config_tls12s: Sequence[_builtins.str],
                 custom_openssl_cipher_config_tls13s: Sequence[_builtins.str],
                 default_max_time_ms: _builtins.int,
                 default_write_concern: _builtins.str,
                 javascript_enabled: _builtins.bool,
                 minimum_enabled_tls_protocol: _builtins.str,
                 no_table_scan: _builtins.bool,
                 oplog_min_retention_hours: _builtins.float,
                 oplog_size_mb: _builtins.int,
                 sample_refresh_interval_bi_connector: _builtins.int,
                 sample_size_bi_connector: _builtins.int,
                 tls_cipher_config_mode: _builtins.str,
                 transaction_lifetime_limit_seconds: _builtins.int):
        """
        :param _builtins.int change_stream_options_pre_and_post_images_expire_after_seconds: (Optional) The minimum pre- and post-image retention time in seconds This parameter is only supported for MongoDB version 6.0 and above. Defaults to `-1`(off).
        :param Sequence[_builtins.str] custom_openssl_cipher_config_tls12s: The custom OpenSSL cipher suite list for TLS 1.2. This field is only valid when `tls_cipher_config_mode` is set to `CUSTOM`.
        :param Sequence[_builtins.str] custom_openssl_cipher_config_tls13s: The custom OpenSSL cipher suite list for TLS 1.3. This field is only valid when `tls_cipher_config_mode` is set to `CUSTOM`.
        :param _builtins.int default_max_time_ms: Default time limit in milliseconds for individual read operations to complete. This option corresponds to the [defaultMaxTimeMS](https://www.mongodb.com/docs/upcoming/reference/cluster-parameters/defaultMaxTimeMS/) cluster parameter. This parameter is supported only for MongoDB version 8.0 and above.
        :param _builtins.str default_write_concern: [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 6.0 clusters default to [majority](https://docs.mongodb.com/manual/reference/write-concern/).
        :param _builtins.bool javascript_enabled: When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        :param _builtins.str minimum_enabled_tls_protocol: Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections. Valid values are:
               - TLS1_2
               - TLS1_3
        :param _builtins.bool no_table_scan: When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        :param _builtins.float oplog_min_retention_hours: Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        :param _builtins.int oplog_size_mb: The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        :param _builtins.int sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param _builtins.int sample_size_bi_connector: Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param _builtins.str tls_cipher_config_mode: The TLS cipher suite configuration mode. Valid values include `CUSTOM` or `DEFAULT`. The `DEFAULT` mode uses the default cipher suites. The `CUSTOM` mode allows you to specify custom cipher suites for both TLS 1.2 and TLS 1.3.
        :param _builtins.int transaction_lifetime_limit_seconds: Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        pulumi.set(__self__, "change_stream_options_pre_and_post_images_expire_after_seconds", change_stream_options_pre_and_post_images_expire_after_seconds)
        pulumi.set(__self__, "custom_openssl_cipher_config_tls12s", custom_openssl_cipher_config_tls12s)
        pulumi.set(__self__, "custom_openssl_cipher_config_tls13s", custom_openssl_cipher_config_tls13s)
        pulumi.set(__self__, "default_max_time_ms", default_max_time_ms)
        pulumi.set(__self__, "default_write_concern", default_write_concern)
        pulumi.set(__self__, "javascript_enabled", javascript_enabled)
        pulumi.set(__self__, "minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        pulumi.set(__self__, "no_table_scan", no_table_scan)
        pulumi.set(__self__, "oplog_min_retention_hours", oplog_min_retention_hours)
        pulumi.set(__self__, "oplog_size_mb", oplog_size_mb)
        pulumi.set(__self__, "sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        pulumi.set(__self__, "sample_size_bi_connector", sample_size_bi_connector)
        pulumi.set(__self__, "tls_cipher_config_mode", tls_cipher_config_mode)
        pulumi.set(__self__, "transaction_lifetime_limit_seconds", transaction_lifetime_limit_seconds)

    @_builtins.property
    @pulumi.getter(name="changeStreamOptionsPreAndPostImagesExpireAfterSeconds")
    def change_stream_options_pre_and_post_images_expire_after_seconds(self) -> _builtins.int:
        """
        (Optional) The minimum pre- and post-image retention time in seconds This parameter is only supported for MongoDB version 6.0 and above. Defaults to `-1`(off).
        """
        return pulumi.get(self, "change_stream_options_pre_and_post_images_expire_after_seconds")

    @_builtins.property
    @pulumi.getter(name="customOpensslCipherConfigTls12s")
    def custom_openssl_cipher_config_tls12s(self) -> Sequence[_builtins.str]:
        """
        The custom OpenSSL cipher suite list for TLS 1.2. This field is only valid when `tls_cipher_config_mode` is set to `CUSTOM`.
        """
        return pulumi.get(self, "custom_openssl_cipher_config_tls12s")

    @_builtins.property
    @pulumi.getter(name="customOpensslCipherConfigTls13s")
    def custom_openssl_cipher_config_tls13s(self) -> Sequence[_builtins.str]:
        """
        The custom OpenSSL cipher suite list for TLS 1.3. This field is only valid when `tls_cipher_config_mode` is set to `CUSTOM`.
        """
        return pulumi.get(self, "custom_openssl_cipher_config_tls13s")

    @_builtins.property
    @pulumi.getter(name="defaultMaxTimeMs")
    def default_max_time_ms(self) -> _builtins.int:
        """
        Default time limit in milliseconds for individual read operations to complete. This option corresponds to the [defaultMaxTimeMS](https://www.mongodb.com/docs/upcoming/reference/cluster-parameters/defaultMaxTimeMS/) cluster parameter. This parameter is supported only for MongoDB version 8.0 and above.
        """
        return pulumi.get(self, "default_max_time_ms")

    @_builtins.property
    @pulumi.getter(name="defaultWriteConcern")
    def default_write_concern(self) -> _builtins.str:
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 6.0 clusters default to [majority](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        return pulumi.get(self, "default_write_concern")

    @_builtins.property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> _builtins.bool:
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        return pulumi.get(self, "javascript_enabled")

    @_builtins.property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> _builtins.str:
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections. Valid values are:
        - TLS1_2
        - TLS1_3
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @_builtins.property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> _builtins.bool:
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        return pulumi.get(self, "no_table_scan")

    @_builtins.property
    @pulumi.getter(name="oplogMinRetentionHours")
    def oplog_min_retention_hours(self) -> _builtins.float:
        """
        Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        """
        return pulumi.get(self, "oplog_min_retention_hours")

    @_builtins.property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> _builtins.int:
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        return pulumi.get(self, "oplog_size_mb")

    @_builtins.property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> _builtins.int:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @_builtins.property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> _builtins.int:
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_size_bi_connector")

    @_builtins.property
    @pulumi.getter(name="tlsCipherConfigMode")
    def tls_cipher_config_mode(self) -> _builtins.str:
        """
        The TLS cipher suite configuration mode. Valid values include `CUSTOM` or `DEFAULT`. The `DEFAULT` mode uses the default cipher suites. The `CUSTOM` mode allows you to specify custom cipher suites for both TLS 1.2 and TLS 1.3.
        """
        return pulumi.get(self, "tls_cipher_config_mode")

    @_builtins.property
    @pulumi.getter(name="transactionLifetimeLimitSeconds")
    def transaction_lifetime_limit_seconds(self) -> _builtins.int:
        """
        Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        return pulumi.get(self, "transaction_lifetime_limit_seconds")


@pulumi.output_type
class GetAdvancedClusterBiConnectorConfigResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 read_preference: _builtins.str):
        """
        :param _builtins.bool enabled: Specifies whether or not BI Connector for Atlas is enabled on the cluster.
        :param _builtins.str read_preference: Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "read_preference", read_preference)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Specifies whether or not BI Connector for Atlas is enabled on the cluster.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> _builtins.str:
        """
        Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        return pulumi.get(self, "read_preference")


@pulumi.output_type
class GetAdvancedClusterConnectionStringsResult(dict):
    def __init__(__self__, *,
                 private: _builtins.str,
                 private_endpoints: Sequence['outputs.GetAdvancedClusterConnectionStringsPrivateEndpointResult'],
                 private_srv: _builtins.str,
                 standard: _builtins.str,
                 standard_srv: _builtins.str):
        """
        :param _builtins.str private: [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        :param Sequence['GetAdvancedClusterConnectionStringsPrivateEndpointArgs'] private_endpoints: Private endpoint connection strings. Each object describes the connection strings you can use to connect to this cluster through a private endpoint. Atlas returns this parameter only if you deployed a private endpoint to all regions to which you deployed this cluster's nodes.
               - `connection_strings.private_endpoint[#].connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
               - `connection_strings.private_endpoint[#].srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in DNS . Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don't need to: Append the seed list or Change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn't, use `connection_strings.private_endpoint[#].connection_string`
               - `connection_strings.private_endpoint[#].srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster support it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[#].srvConnectionString.
               - `connection_strings.private_endpoint[#].type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
               - `connection_strings.private_endpoint[#].endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[#].connection_string` or `connection_strings.private_endpoint[#].srv_connection_string`
               - `connection_strings.private_endpoint[#].endpoints[#].endpoint_id` - Unique identifier of the private endpoint.
               - `connection_strings.private_endpoint[#].endpoints[#].provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
               - `connection_strings.private_endpoint[#].endpoints[#].region` - Region to which you deployed the private endpoint.
        :param _builtins.str private_srv: [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        :param _builtins.str standard: Public mongodb:// connection string for this cluster.
        :param _builtins.str standard_srv: Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t  , use connectionStrings.standard.
        """
        pulumi.set(__self__, "private", private)
        pulumi.set(__self__, "private_endpoints", private_endpoints)
        pulumi.set(__self__, "private_srv", private_srv)
        pulumi.set(__self__, "standard", standard)
        pulumi.set(__self__, "standard_srv", standard_srv)

    @_builtins.property
    @pulumi.getter
    def private(self) -> _builtins.str:
        """
        [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        """
        return pulumi.get(self, "private")

    @_builtins.property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Sequence['outputs.GetAdvancedClusterConnectionStringsPrivateEndpointResult']:
        """
        Private endpoint connection strings. Each object describes the connection strings you can use to connect to this cluster through a private endpoint. Atlas returns this parameter only if you deployed a private endpoint to all regions to which you deployed this cluster's nodes.
        - `connection_strings.private_endpoint[#].connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
        - `connection_strings.private_endpoint[#].srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in DNS . Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don't need to: Append the seed list or Change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn't, use `connection_strings.private_endpoint[#].connection_string`
        - `connection_strings.private_endpoint[#].srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster support it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[#].srvConnectionString.
        - `connection_strings.private_endpoint[#].type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
        - `connection_strings.private_endpoint[#].endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[#].connection_string` or `connection_strings.private_endpoint[#].srv_connection_string`
        - `connection_strings.private_endpoint[#].endpoints[#].endpoint_id` - Unique identifier of the private endpoint.
        - `connection_strings.private_endpoint[#].endpoints[#].provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
        - `connection_strings.private_endpoint[#].endpoints[#].region` - Region to which you deployed the private endpoint.
        """
        return pulumi.get(self, "private_endpoints")

    @_builtins.property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> _builtins.str:
        """
        [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        """
        return pulumi.get(self, "private_srv")

    @_builtins.property
    @pulumi.getter
    def standard(self) -> _builtins.str:
        """
        Public mongodb:// connection string for this cluster.
        """
        return pulumi.get(self, "standard")

    @_builtins.property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> _builtins.str:
        """
        Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t  , use connectionStrings.standard.
        """
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class GetAdvancedClusterConnectionStringsPrivateEndpointResult(dict):
    def __init__(__self__, *,
                 connection_string: _builtins.str,
                 endpoints: Sequence['outputs.GetAdvancedClusterConnectionStringsPrivateEndpointEndpointResult'],
                 srv_connection_string: _builtins.str,
                 srv_shard_optimized_connection_string: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str connection_string: Private endpoint-aware connection string that uses the `mongodb://` protocol to connect to MongoDB Cloud through a private endpoint.
        :param Sequence['GetAdvancedClusterConnectionStringsPrivateEndpointEndpointArgs'] endpoints: List that contains the private endpoints through which you connect to MongoDB Cloud when you use **connectionStrings.privateEndpoint[n].connectionString** or **connectionStrings.privateEndpoint[n].srvConnectionString**.
        :param _builtins.str srv_connection_string: Private endpoint-aware connection string that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in the Domain Name System (DNS). This list synchronizes with the nodes in a cluster. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to append the seed list or change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application supports it. If it doesn't, use connectionStrings.privateEndpoint[n].connectionString.
        :param _builtins.str srv_shard_optimized_connection_string: Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster supports it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[n].srvConnectionString.
        :param _builtins.str type: MongoDB process type to which your application connects. Use `MONGOD` for replica sets and `MONGOS` for sharded clusters.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "srv_connection_string", srv_connection_string)
        pulumi.set(__self__, "srv_shard_optimized_connection_string", srv_shard_optimized_connection_string)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> _builtins.str:
        """
        Private endpoint-aware connection string that uses the `mongodb://` protocol to connect to MongoDB Cloud through a private endpoint.
        """
        return pulumi.get(self, "connection_string")

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> Sequence['outputs.GetAdvancedClusterConnectionStringsPrivateEndpointEndpointResult']:
        """
        List that contains the private endpoints through which you connect to MongoDB Cloud when you use **connectionStrings.privateEndpoint[n].connectionString** or **connectionStrings.privateEndpoint[n].srvConnectionString**.
        """
        return pulumi.get(self, "endpoints")

    @_builtins.property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> _builtins.str:
        """
        Private endpoint-aware connection string that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in the Domain Name System (DNS). This list synchronizes with the nodes in a cluster. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to append the seed list or change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application supports it. If it doesn't, use connectionStrings.privateEndpoint[n].connectionString.
        """
        return pulumi.get(self, "srv_connection_string")

    @_builtins.property
    @pulumi.getter(name="srvShardOptimizedConnectionString")
    def srv_shard_optimized_connection_string(self) -> _builtins.str:
        """
        Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster supports it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[n].srvConnectionString.
        """
        return pulumi.get(self, "srv_shard_optimized_connection_string")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        MongoDB process type to which your application connects. Use `MONGOD` for replica sets and `MONGOS` for sharded clusters.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAdvancedClusterConnectionStringsPrivateEndpointEndpointResult(dict):
    def __init__(__self__, *,
                 endpoint_id: _builtins.str,
                 provider_name: _builtins.str,
                 region: _builtins.str):
        """
        :param _builtins.str endpoint_id: Unique string that the cloud provider uses to identify the private endpoint.
        :param _builtins.str provider_name: Cloud service provider on which the servers are provisioned.
        :param _builtins.str region: Region where the private endpoint is deployed.
        """
        pulumi.set(__self__, "endpoint_id", endpoint_id)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> _builtins.str:
        """
        Unique string that the cloud provider uses to identify the private endpoint.
        """
        return pulumi.get(self, "endpoint_id")

    @_builtins.property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> _builtins.str:
        """
        Cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Region where the private endpoint is deployed.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetAdvancedClusterPinnedFcvResult(dict):
    def __init__(__self__, *,
                 expiration_date: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str expiration_date: Expiration date of the fixed FCV. This value is in the ISO 8601 timestamp format (e.g. "2024-12-04T16:25:00Z").
        :param _builtins.str version: Feature compatibility version of the cluster.
        """
        pulumi.set(__self__, "expiration_date", expiration_date)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> _builtins.str:
        """
        Expiration date of the fixed FCV. This value is in the ISO 8601 timestamp format (e.g. "2024-12-04T16:25:00Z").
        """
        return pulumi.get(self, "expiration_date")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Feature compatibility version of the cluster.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecResult(dict):
    def __init__(__self__, *,
                 container_id: Mapping[str, _builtins.str],
                 external_id: _builtins.str,
                 region_configs: Sequence['outputs.GetAdvancedClusterReplicationSpecRegionConfigResult'],
                 zone_id: _builtins.str,
                 zone_name: _builtins.str):
        """
        :param Mapping[str, _builtins.str] container_id: A key-value map of the Network Peering Container ID(s) for the configuration specified in `region_configs`. The Container ID is the id of the container either created programmatically by the user before any clusters existed in a project or when the first cluster in the region (AWS/Azure) or project (GCP) was created.  The syntax is `"providerName:regionName" = "containerId"`. Example `AWS:US_EAST_1" = "61e0797dde08fb498ca11a71`.
        :param _builtins.str external_id: Unique 24-hexadecimal digit string that identifies the replication object for a shard in a Cluster. This value corresponds to Shard ID displayed in the UI.
        :param Sequence['GetAdvancedClusterReplicationSpecRegionConfigArgs'] region_configs: Configuration for the hardware specifications for nodes set for a given region. Each `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below.
        :param _builtins.str zone_id: Unique 24-hexadecimal digit string that identifies the zone in a Global Cluster. If clusterType is GEOSHARDED, this value indicates the zone that the given shard belongs to and can be used to configure Global Cluster backup policies.
        :param _builtins.str zone_name: Name for the zone in a Global Cluster.
        """
        pulumi.set(__self__, "container_id", container_id)
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "region_configs", region_configs)
        pulumi.set(__self__, "zone_id", zone_id)
        pulumi.set(__self__, "zone_name", zone_name)

    @_builtins.property
    @pulumi.getter(name="containerId")
    def container_id(self) -> Mapping[str, _builtins.str]:
        """
        A key-value map of the Network Peering Container ID(s) for the configuration specified in `region_configs`. The Container ID is the id of the container either created programmatically by the user before any clusters existed in a project or when the first cluster in the region (AWS/Azure) or project (GCP) was created.  The syntax is `"providerName:regionName" = "containerId"`. Example `AWS:US_EAST_1" = "61e0797dde08fb498ca11a71`.
        """
        return pulumi.get(self, "container_id")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the replication object for a shard in a Cluster. This value corresponds to Shard ID displayed in the UI.
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="regionConfigs")
    def region_configs(self) -> Sequence['outputs.GetAdvancedClusterReplicationSpecRegionConfigResult']:
        """
        Configuration for the hardware specifications for nodes set for a given region. Each `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below.
        """
        return pulumi.get(self, "region_configs")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the zone in a Global Cluster. If clusterType is GEOSHARDED, this value indicates the zone that the given shard belongs to and can be used to configure Global Cluster backup policies.
        """
        return pulumi.get(self, "zone_id")

    @_builtins.property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> _builtins.str:
        """
        Name for the zone in a Global Cluster.
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecRegionConfigResult(dict):
    def __init__(__self__, *,
                 analytics_auto_scaling: 'outputs.GetAdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingResult',
                 analytics_specs: 'outputs.GetAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsResult',
                 auto_scaling: 'outputs.GetAdvancedClusterReplicationSpecRegionConfigAutoScalingResult',
                 backing_provider_name: _builtins.str,
                 effective_analytics_specs: 'outputs.GetAdvancedClusterReplicationSpecRegionConfigEffectiveAnalyticsSpecsResult',
                 effective_electable_specs: 'outputs.GetAdvancedClusterReplicationSpecRegionConfigEffectiveElectableSpecsResult',
                 effective_read_only_specs: 'outputs.GetAdvancedClusterReplicationSpecRegionConfigEffectiveReadOnlySpecsResult',
                 electable_specs: 'outputs.GetAdvancedClusterReplicationSpecRegionConfigElectableSpecsResult',
                 priority: _builtins.int,
                 provider_name: _builtins.str,
                 read_only_specs: 'outputs.GetAdvancedClusterReplicationSpecRegionConfigReadOnlySpecsResult',
                 region_name: _builtins.str):
        """
        :param 'GetAdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingArgs' analytics_auto_scaling: Configuration for the Collection of settings that configures analytics-auto-scaling information for the cluster. See below.
        :param 'GetAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgs' analytics_specs: Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. See below.
        :param 'GetAdvancedClusterReplicationSpecRegionConfigAutoScalingArgs' auto_scaling: Configuration for the Collection of settings that configures auto-scaling information for the cluster. See below.
        :param _builtins.str backing_provider_name: Cloud service provider on which you provision the host for a multi-tenant cluster.
        :param 'GetAdvancedClusterReplicationSpecRegionConfigEffectiveAnalyticsSpecsArgs' effective_analytics_specs: Effective hardware specifications for analytics nodes in the region, reflecting actual Atlas-managed values including auto-scaling changes. See below.
        :param 'GetAdvancedClusterReplicationSpecRegionConfigEffectiveElectableSpecsArgs' effective_electable_specs: Effective hardware specifications for electable nodes in the region, reflecting actual Atlas-managed values including auto-scaling changes. See below.
        :param 'GetAdvancedClusterReplicationSpecRegionConfigEffectiveReadOnlySpecsArgs' effective_read_only_specs: Effective hardware specifications for read-only nodes in the region, reflecting actual Atlas-managed values including auto-scaling changes. See below.
        :param 'GetAdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs' electable_specs: Hardware specifications for electable nodes in the region.
        :param _builtins.int priority: Election priority of the region.
        :param _builtins.str provider_name: Cloud service provider on which the servers are provisioned.
        :param 'GetAdvancedClusterReplicationSpecRegionConfigReadOnlySpecsArgs' read_only_specs: Hardware specifications for read-only nodes in the region. See below.
        :param _builtins.str region_name: Physical location of your MongoDB cluster.
        """
        pulumi.set(__self__, "analytics_auto_scaling", analytics_auto_scaling)
        pulumi.set(__self__, "analytics_specs", analytics_specs)
        pulumi.set(__self__, "auto_scaling", auto_scaling)
        pulumi.set(__self__, "backing_provider_name", backing_provider_name)
        pulumi.set(__self__, "effective_analytics_specs", effective_analytics_specs)
        pulumi.set(__self__, "effective_electable_specs", effective_electable_specs)
        pulumi.set(__self__, "effective_read_only_specs", effective_read_only_specs)
        pulumi.set(__self__, "electable_specs", electable_specs)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "read_only_specs", read_only_specs)
        pulumi.set(__self__, "region_name", region_name)

    @_builtins.property
    @pulumi.getter(name="analyticsAutoScaling")
    def analytics_auto_scaling(self) -> 'outputs.GetAdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingResult':
        """
        Configuration for the Collection of settings that configures analytics-auto-scaling information for the cluster. See below.
        """
        return pulumi.get(self, "analytics_auto_scaling")

    @_builtins.property
    @pulumi.getter(name="analyticsSpecs")
    def analytics_specs(self) -> 'outputs.GetAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsResult':
        """
        Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. See below.
        """
        return pulumi.get(self, "analytics_specs")

    @_builtins.property
    @pulumi.getter(name="autoScaling")
    def auto_scaling(self) -> 'outputs.GetAdvancedClusterReplicationSpecRegionConfigAutoScalingResult':
        """
        Configuration for the Collection of settings that configures auto-scaling information for the cluster. See below.
        """
        return pulumi.get(self, "auto_scaling")

    @_builtins.property
    @pulumi.getter(name="backingProviderName")
    def backing_provider_name(self) -> _builtins.str:
        """
        Cloud service provider on which you provision the host for a multi-tenant cluster.
        """
        return pulumi.get(self, "backing_provider_name")

    @_builtins.property
    @pulumi.getter(name="effectiveAnalyticsSpecs")
    def effective_analytics_specs(self) -> 'outputs.GetAdvancedClusterReplicationSpecRegionConfigEffectiveAnalyticsSpecsResult':
        """
        Effective hardware specifications for analytics nodes in the region, reflecting actual Atlas-managed values including auto-scaling changes. See below.
        """
        return pulumi.get(self, "effective_analytics_specs")

    @_builtins.property
    @pulumi.getter(name="effectiveElectableSpecs")
    def effective_electable_specs(self) -> 'outputs.GetAdvancedClusterReplicationSpecRegionConfigEffectiveElectableSpecsResult':
        """
        Effective hardware specifications for electable nodes in the region, reflecting actual Atlas-managed values including auto-scaling changes. See below.
        """
        return pulumi.get(self, "effective_electable_specs")

    @_builtins.property
    @pulumi.getter(name="effectiveReadOnlySpecs")
    def effective_read_only_specs(self) -> 'outputs.GetAdvancedClusterReplicationSpecRegionConfigEffectiveReadOnlySpecsResult':
        """
        Effective hardware specifications for read-only nodes in the region, reflecting actual Atlas-managed values including auto-scaling changes. See below.
        """
        return pulumi.get(self, "effective_read_only_specs")

    @_builtins.property
    @pulumi.getter(name="electableSpecs")
    def electable_specs(self) -> 'outputs.GetAdvancedClusterReplicationSpecRegionConfigElectableSpecsResult':
        """
        Hardware specifications for electable nodes in the region.
        """
        return pulumi.get(self, "electable_specs")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        Election priority of the region.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> _builtins.str:
        """
        Cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @_builtins.property
    @pulumi.getter(name="readOnlySpecs")
    def read_only_specs(self) -> 'outputs.GetAdvancedClusterReplicationSpecRegionConfigReadOnlySpecsResult':
        """
        Hardware specifications for read-only nodes in the region. See below.
        """
        return pulumi.get(self, "read_only_specs")

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> _builtins.str:
        """
        Physical location of your MongoDB cluster.
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingResult(dict):
    def __init__(__self__, *,
                 compute_enabled: _builtins.bool,
                 compute_max_instance_size: _builtins.str,
                 compute_min_instance_size: _builtins.str,
                 compute_scale_down_enabled: _builtins.bool,
                 disk_gb_enabled: _builtins.bool):
        """
        :param _builtins.bool compute_enabled: Flag that indicates whether instance size auto-scaling is enabled.
        :param _builtins.str compute_max_instance_size: Maximum instance size to which your cluster can automatically scale (such as M40). 
               #### Advanced Configuration
        :param _builtins.str compute_min_instance_size: Minimum instance size to which your cluster can automatically scale (such as M10).
        :param _builtins.bool compute_scale_down_enabled: Flag that indicates whether the instance size may scale down.
        :param _builtins.bool disk_gb_enabled: Flag that indicates whether this cluster enables disk auto-scaling.
        """
        pulumi.set(__self__, "compute_enabled", compute_enabled)
        pulumi.set(__self__, "compute_max_instance_size", compute_max_instance_size)
        pulumi.set(__self__, "compute_min_instance_size", compute_min_instance_size)
        pulumi.set(__self__, "compute_scale_down_enabled", compute_scale_down_enabled)
        pulumi.set(__self__, "disk_gb_enabled", disk_gb_enabled)

    @_builtins.property
    @pulumi.getter(name="computeEnabled")
    def compute_enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether instance size auto-scaling is enabled.
        """
        return pulumi.get(self, "compute_enabled")

    @_builtins.property
    @pulumi.getter(name="computeMaxInstanceSize")
    def compute_max_instance_size(self) -> _builtins.str:
        """
        Maximum instance size to which your cluster can automatically scale (such as M40). 
        #### Advanced Configuration
        """
        return pulumi.get(self, "compute_max_instance_size")

    @_builtins.property
    @pulumi.getter(name="computeMinInstanceSize")
    def compute_min_instance_size(self) -> _builtins.str:
        """
        Minimum instance size to which your cluster can automatically scale (such as M10).
        """
        return pulumi.get(self, "compute_min_instance_size")

    @_builtins.property
    @pulumi.getter(name="computeScaleDownEnabled")
    def compute_scale_down_enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether the instance size may scale down.
        """
        return pulumi.get(self, "compute_scale_down_enabled")

    @_builtins.property
    @pulumi.getter(name="diskGbEnabled")
    def disk_gb_enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether this cluster enables disk auto-scaling.
        """
        return pulumi.get(self, "disk_gb_enabled")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsResult(dict):
    def __init__(__self__, *,
                 disk_iops: _builtins.int,
                 disk_size_gb: _builtins.float,
                 ebs_volume_type: _builtins.str,
                 instance_size: _builtins.str,
                 node_count: _builtins.int):
        """
        :param _builtins.int disk_iops: Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        :param _builtins.float disk_size_gb: Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        :param _builtins.str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. 
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param _builtins.str instance_size: Hardware specification for the instance sizes in this region.
        :param _builtins.int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        pulumi.set(__self__, "disk_iops", disk_iops)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        pulumi.set(__self__, "instance_size", instance_size)
        pulumi.set(__self__, "node_count", node_count)

    @_builtins.property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> _builtins.int:
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        """
        return pulumi.get(self, "disk_iops")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> _builtins.float:
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> _builtins.str:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. 
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @_builtins.property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> _builtins.str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> _builtins.int:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecRegionConfigAutoScalingResult(dict):
    def __init__(__self__, *,
                 compute_enabled: _builtins.bool,
                 compute_max_instance_size: _builtins.str,
                 compute_min_instance_size: _builtins.str,
                 compute_scale_down_enabled: _builtins.bool,
                 disk_gb_enabled: _builtins.bool):
        """
        :param _builtins.bool compute_enabled: Flag that indicates whether instance size auto-scaling is enabled.
        :param _builtins.str compute_max_instance_size: Maximum instance size to which your cluster can automatically scale (such as M40). 
               #### Advanced Configuration
        :param _builtins.str compute_min_instance_size: Minimum instance size to which your cluster can automatically scale (such as M10).
        :param _builtins.bool compute_scale_down_enabled: Flag that indicates whether the instance size may scale down.
        :param _builtins.bool disk_gb_enabled: Flag that indicates whether this cluster enables disk auto-scaling.
        """
        pulumi.set(__self__, "compute_enabled", compute_enabled)
        pulumi.set(__self__, "compute_max_instance_size", compute_max_instance_size)
        pulumi.set(__self__, "compute_min_instance_size", compute_min_instance_size)
        pulumi.set(__self__, "compute_scale_down_enabled", compute_scale_down_enabled)
        pulumi.set(__self__, "disk_gb_enabled", disk_gb_enabled)

    @_builtins.property
    @pulumi.getter(name="computeEnabled")
    def compute_enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether instance size auto-scaling is enabled.
        """
        return pulumi.get(self, "compute_enabled")

    @_builtins.property
    @pulumi.getter(name="computeMaxInstanceSize")
    def compute_max_instance_size(self) -> _builtins.str:
        """
        Maximum instance size to which your cluster can automatically scale (such as M40). 
        #### Advanced Configuration
        """
        return pulumi.get(self, "compute_max_instance_size")

    @_builtins.property
    @pulumi.getter(name="computeMinInstanceSize")
    def compute_min_instance_size(self) -> _builtins.str:
        """
        Minimum instance size to which your cluster can automatically scale (such as M10).
        """
        return pulumi.get(self, "compute_min_instance_size")

    @_builtins.property
    @pulumi.getter(name="computeScaleDownEnabled")
    def compute_scale_down_enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether the instance size may scale down.
        """
        return pulumi.get(self, "compute_scale_down_enabled")

    @_builtins.property
    @pulumi.getter(name="diskGbEnabled")
    def disk_gb_enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether this cluster enables disk auto-scaling.
        """
        return pulumi.get(self, "disk_gb_enabled")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecRegionConfigEffectiveAnalyticsSpecsResult(dict):
    def __init__(__self__, *,
                 disk_iops: _builtins.int,
                 disk_size_gb: _builtins.float,
                 ebs_volume_type: _builtins.str,
                 instance_size: _builtins.str,
                 node_count: _builtins.int):
        """
        :param _builtins.int disk_iops: Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        :param _builtins.float disk_size_gb: Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        :param _builtins.str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. 
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param _builtins.str instance_size: Hardware specification for the instance sizes in this region.
        :param _builtins.int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        pulumi.set(__self__, "disk_iops", disk_iops)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        pulumi.set(__self__, "instance_size", instance_size)
        pulumi.set(__self__, "node_count", node_count)

    @_builtins.property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> _builtins.int:
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        """
        return pulumi.get(self, "disk_iops")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> _builtins.float:
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> _builtins.str:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. 
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @_builtins.property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> _builtins.str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> _builtins.int:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecRegionConfigEffectiveElectableSpecsResult(dict):
    def __init__(__self__, *,
                 disk_iops: _builtins.int,
                 disk_size_gb: _builtins.float,
                 ebs_volume_type: _builtins.str,
                 instance_size: _builtins.str,
                 node_count: _builtins.int):
        """
        :param _builtins.int disk_iops: Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        :param _builtins.float disk_size_gb: Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        :param _builtins.str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. 
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param _builtins.str instance_size: Hardware specification for the instance sizes in this region.
        :param _builtins.int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        pulumi.set(__self__, "disk_iops", disk_iops)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        pulumi.set(__self__, "instance_size", instance_size)
        pulumi.set(__self__, "node_count", node_count)

    @_builtins.property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> _builtins.int:
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        """
        return pulumi.get(self, "disk_iops")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> _builtins.float:
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> _builtins.str:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. 
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @_builtins.property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> _builtins.str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> _builtins.int:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecRegionConfigEffectiveReadOnlySpecsResult(dict):
    def __init__(__self__, *,
                 disk_iops: _builtins.int,
                 disk_size_gb: _builtins.float,
                 ebs_volume_type: _builtins.str,
                 instance_size: _builtins.str,
                 node_count: _builtins.int):
        """
        :param _builtins.int disk_iops: Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        :param _builtins.float disk_size_gb: Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        :param _builtins.str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. 
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param _builtins.str instance_size: Hardware specification for the instance sizes in this region.
        :param _builtins.int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        pulumi.set(__self__, "disk_iops", disk_iops)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        pulumi.set(__self__, "instance_size", instance_size)
        pulumi.set(__self__, "node_count", node_count)

    @_builtins.property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> _builtins.int:
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        """
        return pulumi.get(self, "disk_iops")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> _builtins.float:
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> _builtins.str:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. 
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @_builtins.property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> _builtins.str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> _builtins.int:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecRegionConfigElectableSpecsResult(dict):
    def __init__(__self__, *,
                 disk_iops: _builtins.int,
                 disk_size_gb: _builtins.float,
                 ebs_volume_type: _builtins.str,
                 instance_size: _builtins.str,
                 node_count: _builtins.int):
        """
        :param _builtins.int disk_iops: Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        :param _builtins.float disk_size_gb: Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        :param _builtins.str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. 
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param _builtins.str instance_size: Hardware specification for the instance sizes in this region.
        :param _builtins.int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        pulumi.set(__self__, "disk_iops", disk_iops)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        pulumi.set(__self__, "instance_size", instance_size)
        pulumi.set(__self__, "node_count", node_count)

    @_builtins.property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> _builtins.int:
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        """
        return pulumi.get(self, "disk_iops")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> _builtins.float:
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> _builtins.str:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. 
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @_builtins.property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> _builtins.str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> _builtins.int:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecRegionConfigReadOnlySpecsResult(dict):
    def __init__(__self__, *,
                 disk_iops: _builtins.int,
                 disk_size_gb: _builtins.float,
                 ebs_volume_type: _builtins.str,
                 instance_size: _builtins.str,
                 node_count: _builtins.int):
        """
        :param _builtins.int disk_iops: Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        :param _builtins.float disk_size_gb: Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        :param _builtins.str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. 
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param _builtins.str instance_size: Hardware specification for the instance sizes in this region.
        :param _builtins.int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        pulumi.set(__self__, "disk_iops", disk_iops)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        pulumi.set(__self__, "instance_size", instance_size)
        pulumi.set(__self__, "node_count", node_count)

    @_builtins.property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> _builtins.int:
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        """
        return pulumi.get(self, "disk_iops")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> _builtins.float:
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> _builtins.str:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. 
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @_builtins.property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> _builtins.str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> _builtins.int:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAdvancedClustersResultResult(dict):
    def __init__(__self__, *,
                 advanced_configuration: 'outputs.GetAdvancedClustersResultAdvancedConfigurationResult',
                 backup_enabled: _builtins.bool,
                 bi_connector_config: 'outputs.GetAdvancedClustersResultBiConnectorConfigResult',
                 cluster_id: _builtins.str,
                 cluster_type: _builtins.str,
                 config_server_management_mode: _builtins.str,
                 config_server_type: _builtins.str,
                 connection_strings: 'outputs.GetAdvancedClustersResultConnectionStringsResult',
                 create_date: _builtins.str,
                 encryption_at_rest_provider: _builtins.str,
                 global_cluster_self_managed_sharding: _builtins.bool,
                 labels: Mapping[str, _builtins.str],
                 mongo_db_major_version: _builtins.str,
                 mongo_db_version: _builtins.str,
                 name: _builtins.str,
                 paused: _builtins.bool,
                 pinned_fcv: 'outputs.GetAdvancedClustersResultPinnedFcvResult',
                 pit_enabled: _builtins.bool,
                 project_id: _builtins.str,
                 redact_client_log_data: _builtins.bool,
                 replica_set_scaling_strategy: _builtins.str,
                 replication_specs: Sequence['outputs.GetAdvancedClustersResultReplicationSpecResult'],
                 root_cert_type: _builtins.str,
                 state_name: _builtins.str,
                 tags: Mapping[str, _builtins.str],
                 termination_protection_enabled: _builtins.bool,
                 version_release_system: _builtins.str,
                 use_effective_fields: Optional[_builtins.bool] = None):
        """
        :param 'GetAdvancedClustersResultAdvancedConfigurationArgs' advanced_configuration: Get the advanced configuration options. See Advanced Configuration below for more details.
        :param _builtins.bool backup_enabled: Flag that indicates whether the cluster can perform backups. If set to `true`, the cluster can perform backups. You must set this value to `true` for NVMe clusters. Backup uses [Cloud Backups](https://docs.atlas.mongodb.com/backup/cloud-backup/overview/) for dedicated clusters and [Shared Cluster Backups](https://docs.atlas.mongodb.com/backup/shared-tier/overview/) for tenant clusters. If set to `false`, the cluster doesn't use backups.
        :param 'GetAdvancedClustersResultBiConnectorConfigArgs' bi_connector_config: Settings needed to configure the MongoDB Connector for Business Intelligence for this cluster.
        :param _builtins.str cluster_id: The cluster ID.
        :param _builtins.str cluster_type: Type of the cluster that you want to create.
        :param _builtins.str config_server_management_mode: Config Server Management Mode for creating or updating a sharded cluster. Valid values are `ATLAS_MANAGED` (default) and `FIXED_TO_DEDICATED`. When configured as `ATLAS_MANAGED`, Atlas may automatically switch the cluster's config server type for optimal performance and savings. When configured as `FIXED_TO_DEDICATED`, the cluster will always use a dedicated config server. To learn more, see the [Sharded Cluster Config Servers documentation](https://dochub.mongodb.org/docs/manual/core/sharded-cluster-config-servers/).
        :param _builtins.str config_server_type: Describes a sharded cluster's config server type. Valid values are `DEDICATED` and `EMBEDDED`. To learn more, see the [Sharded Cluster Config Servers documentation](https://dochub.mongodb.org/docs/manual/core/sharded-cluster-config-servers/).
        :param 'GetAdvancedClustersResultConnectionStringsArgs' connection_strings: Set of connection strings that your applications use to connect to this cluster. More information in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.
        :param _builtins.str create_date: Date and time when MongoDB Cloud created this cluster. This parameter expresses its value in ISO 8601 format in UTC.
        :param _builtins.str encryption_at_rest_provider: Possible values are AWS, GCP, AZURE or NONE.
        :param _builtins.bool global_cluster_self_managed_sharding: Flag that indicates if cluster uses Atlas-Managed Sharding (false) or Self-Managed Sharding (true).
        :param Mapping[str, _builtins.str] labels: Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.
        :param _builtins.str mongo_db_major_version: Version of the cluster to deploy.
        :param _builtins.str mongo_db_version: Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.
        :param _builtins.str name: Human-readable label that identifies this cluster.
        :param _builtins.bool paused: Flag that indicates whether the cluster is paused or not.
        :param 'GetAdvancedClustersResultPinnedFcvArgs' pinned_fcv: The pinned Feature Compatibility Version (FCV) with its associated expiration date. See below.
        :param _builtins.bool pit_enabled: Flag that indicates if the cluster uses Continuous Cloud Backup.
        :param _builtins.str project_id: The unique ID for the project to get the clusters.
        :param _builtins.bool redact_client_log_data: (Optional) Flag that enables or disables log redaction, see the [manual](https://www.mongodb.com/docs/manual/administration/monitoring/#log-redaction) for more information.
        :param _builtins.str replica_set_scaling_strategy: (Optional) Replica set scaling mode for your cluster.
        :param Sequence['GetAdvancedClustersResultReplicationSpecArgs'] replication_specs: List of settings that configure your cluster regions. This array has one object per shard representing node configurations in each shard. For replica sets there is only one object representing node configurations. See below
        :param _builtins.str root_cert_type: Certificate Authority that MongoDB Atlas clusters use.
        :param _builtins.str state_name: Current state of the cluster. The possible states are:
        :param Mapping[str, _builtins.str] tags: Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.
        :param _builtins.bool termination_protection_enabled: Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.
        :param _builtins.str version_release_system: Release cadence that Atlas uses for this cluster.
        :param _builtins.bool use_effective_fields: Controls how hardware specification fields are returned in the response. When set to true, the non-effective specs (`electable_specs`, `read_only_specs`, `analytics_specs`) fields return the hardware specifications that the client provided. When set to false (default), the non-effective specs fields show the **current** hardware specifications. Cluster auto-scaling is the primary cause for differences between initial and current hardware specifications. This attribute applies to dedicated clusters, not to tenant or flex clusters. **Note:** Effective specs (`effective_electable_specs`, `effective_read_only_specs`, `effective_analytics_specs`) are always returned for dedicated clusters regardless of the flag value and always report the **current** hardware specifications. See the resource documentation for Auto-Scaling with Effective Fields for more details.
        """
        pulumi.set(__self__, "advanced_configuration", advanced_configuration)
        pulumi.set(__self__, "backup_enabled", backup_enabled)
        pulumi.set(__self__, "bi_connector_config", bi_connector_config)
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "cluster_type", cluster_type)
        pulumi.set(__self__, "config_server_management_mode", config_server_management_mode)
        pulumi.set(__self__, "config_server_type", config_server_type)
        pulumi.set(__self__, "connection_strings", connection_strings)
        pulumi.set(__self__, "create_date", create_date)
        pulumi.set(__self__, "encryption_at_rest_provider", encryption_at_rest_provider)
        pulumi.set(__self__, "global_cluster_self_managed_sharding", global_cluster_self_managed_sharding)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "mongo_db_major_version", mongo_db_major_version)
        pulumi.set(__self__, "mongo_db_version", mongo_db_version)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "paused", paused)
        pulumi.set(__self__, "pinned_fcv", pinned_fcv)
        pulumi.set(__self__, "pit_enabled", pit_enabled)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "redact_client_log_data", redact_client_log_data)
        pulumi.set(__self__, "replica_set_scaling_strategy", replica_set_scaling_strategy)
        pulumi.set(__self__, "replication_specs", replication_specs)
        pulumi.set(__self__, "root_cert_type", root_cert_type)
        pulumi.set(__self__, "state_name", state_name)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "termination_protection_enabled", termination_protection_enabled)
        pulumi.set(__self__, "version_release_system", version_release_system)
        if use_effective_fields is not None:
            pulumi.set(__self__, "use_effective_fields", use_effective_fields)

    @_builtins.property
    @pulumi.getter(name="advancedConfiguration")
    def advanced_configuration(self) -> 'outputs.GetAdvancedClustersResultAdvancedConfigurationResult':
        """
        Get the advanced configuration options. See Advanced Configuration below for more details.
        """
        return pulumi.get(self, "advanced_configuration")

    @_builtins.property
    @pulumi.getter(name="backupEnabled")
    def backup_enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether the cluster can perform backups. If set to `true`, the cluster can perform backups. You must set this value to `true` for NVMe clusters. Backup uses [Cloud Backups](https://docs.atlas.mongodb.com/backup/cloud-backup/overview/) for dedicated clusters and [Shared Cluster Backups](https://docs.atlas.mongodb.com/backup/shared-tier/overview/) for tenant clusters. If set to `false`, the cluster doesn't use backups.
        """
        return pulumi.get(self, "backup_enabled")

    @_builtins.property
    @pulumi.getter(name="biConnectorConfig")
    def bi_connector_config(self) -> 'outputs.GetAdvancedClustersResultBiConnectorConfigResult':
        """
        Settings needed to configure the MongoDB Connector for Business Intelligence for this cluster.
        """
        return pulumi.get(self, "bi_connector_config")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> _builtins.str:
        """
        The cluster ID.
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> _builtins.str:
        """
        Type of the cluster that you want to create.
        """
        return pulumi.get(self, "cluster_type")

    @_builtins.property
    @pulumi.getter(name="configServerManagementMode")
    def config_server_management_mode(self) -> _builtins.str:
        """
        Config Server Management Mode for creating or updating a sharded cluster. Valid values are `ATLAS_MANAGED` (default) and `FIXED_TO_DEDICATED`. When configured as `ATLAS_MANAGED`, Atlas may automatically switch the cluster's config server type for optimal performance and savings. When configured as `FIXED_TO_DEDICATED`, the cluster will always use a dedicated config server. To learn more, see the [Sharded Cluster Config Servers documentation](https://dochub.mongodb.org/docs/manual/core/sharded-cluster-config-servers/).
        """
        return pulumi.get(self, "config_server_management_mode")

    @_builtins.property
    @pulumi.getter(name="configServerType")
    def config_server_type(self) -> _builtins.str:
        """
        Describes a sharded cluster's config server type. Valid values are `DEDICATED` and `EMBEDDED`. To learn more, see the [Sharded Cluster Config Servers documentation](https://dochub.mongodb.org/docs/manual/core/sharded-cluster-config-servers/).
        """
        return pulumi.get(self, "config_server_type")

    @_builtins.property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> 'outputs.GetAdvancedClustersResultConnectionStringsResult':
        """
        Set of connection strings that your applications use to connect to this cluster. More information in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.
        """
        return pulumi.get(self, "connection_strings")

    @_builtins.property
    @pulumi.getter(name="createDate")
    def create_date(self) -> _builtins.str:
        """
        Date and time when MongoDB Cloud created this cluster. This parameter expresses its value in ISO 8601 format in UTC.
        """
        return pulumi.get(self, "create_date")

    @_builtins.property
    @pulumi.getter(name="encryptionAtRestProvider")
    def encryption_at_rest_provider(self) -> _builtins.str:
        """
        Possible values are AWS, GCP, AZURE or NONE.
        """
        return pulumi.get(self, "encryption_at_rest_provider")

    @_builtins.property
    @pulumi.getter(name="globalClusterSelfManagedSharding")
    def global_cluster_self_managed_sharding(self) -> _builtins.bool:
        """
        Flag that indicates if cluster uses Atlas-Managed Sharding (false) or Self-Managed Sharding (true).
        """
        return pulumi.get(self, "global_cluster_self_managed_sharding")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="mongoDbMajorVersion")
    def mongo_db_major_version(self) -> _builtins.str:
        """
        Version of the cluster to deploy.
        """
        return pulumi.get(self, "mongo_db_major_version")

    @_builtins.property
    @pulumi.getter(name="mongoDbVersion")
    def mongo_db_version(self) -> _builtins.str:
        """
        Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.
        """
        return pulumi.get(self, "mongo_db_version")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Human-readable label that identifies this cluster.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def paused(self) -> _builtins.bool:
        """
        Flag that indicates whether the cluster is paused or not.
        """
        return pulumi.get(self, "paused")

    @_builtins.property
    @pulumi.getter(name="pinnedFcv")
    def pinned_fcv(self) -> 'outputs.GetAdvancedClustersResultPinnedFcvResult':
        """
        The pinned Feature Compatibility Version (FCV) with its associated expiration date. See below.
        """
        return pulumi.get(self, "pinned_fcv")

    @_builtins.property
    @pulumi.getter(name="pitEnabled")
    def pit_enabled(self) -> _builtins.bool:
        """
        Flag that indicates if the cluster uses Continuous Cloud Backup.
        """
        return pulumi.get(self, "pit_enabled")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The unique ID for the project to get the clusters.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="redactClientLogData")
    def redact_client_log_data(self) -> _builtins.bool:
        """
        (Optional) Flag that enables or disables log redaction, see the [manual](https://www.mongodb.com/docs/manual/administration/monitoring/#log-redaction) for more information.
        """
        return pulumi.get(self, "redact_client_log_data")

    @_builtins.property
    @pulumi.getter(name="replicaSetScalingStrategy")
    def replica_set_scaling_strategy(self) -> _builtins.str:
        """
        (Optional) Replica set scaling mode for your cluster.
        """
        return pulumi.get(self, "replica_set_scaling_strategy")

    @_builtins.property
    @pulumi.getter(name="replicationSpecs")
    def replication_specs(self) -> Sequence['outputs.GetAdvancedClustersResultReplicationSpecResult']:
        """
        List of settings that configure your cluster regions. This array has one object per shard representing node configurations in each shard. For replica sets there is only one object representing node configurations. See below
        """
        return pulumi.get(self, "replication_specs")

    @_builtins.property
    @pulumi.getter(name="rootCertType")
    def root_cert_type(self) -> _builtins.str:
        """
        Certificate Authority that MongoDB Atlas clusters use.
        """
        return pulumi.get(self, "root_cert_type")

    @_builtins.property
    @pulumi.getter(name="stateName")
    def state_name(self) -> _builtins.str:
        """
        Current state of the cluster. The possible states are:
        """
        return pulumi.get(self, "state_name")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="terminationProtectionEnabled")
    def termination_protection_enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.
        """
        return pulumi.get(self, "termination_protection_enabled")

    @_builtins.property
    @pulumi.getter(name="versionReleaseSystem")
    def version_release_system(self) -> _builtins.str:
        """
        Release cadence that Atlas uses for this cluster.
        """
        return pulumi.get(self, "version_release_system")

    @_builtins.property
    @pulumi.getter(name="useEffectiveFields")
    def use_effective_fields(self) -> Optional[_builtins.bool]:
        """
        Controls how hardware specification fields are returned in the response. When set to true, the non-effective specs (`electable_specs`, `read_only_specs`, `analytics_specs`) fields return the hardware specifications that the client provided. When set to false (default), the non-effective specs fields show the **current** hardware specifications. Cluster auto-scaling is the primary cause for differences between initial and current hardware specifications. This attribute applies to dedicated clusters, not to tenant or flex clusters. **Note:** Effective specs (`effective_electable_specs`, `effective_read_only_specs`, `effective_analytics_specs`) are always returned for dedicated clusters regardless of the flag value and always report the **current** hardware specifications. See the resource documentation for Auto-Scaling with Effective Fields for more details.
        """
        return pulumi.get(self, "use_effective_fields")


@pulumi.output_type
class GetAdvancedClustersResultAdvancedConfigurationResult(dict):
    def __init__(__self__, *,
                 change_stream_options_pre_and_post_images_expire_after_seconds: _builtins.int,
                 custom_openssl_cipher_config_tls12s: Sequence[_builtins.str],
                 custom_openssl_cipher_config_tls13s: Sequence[_builtins.str],
                 default_max_time_ms: _builtins.int,
                 default_write_concern: _builtins.str,
                 javascript_enabled: _builtins.bool,
                 minimum_enabled_tls_protocol: _builtins.str,
                 no_table_scan: _builtins.bool,
                 oplog_min_retention_hours: _builtins.float,
                 oplog_size_mb: _builtins.int,
                 sample_refresh_interval_bi_connector: _builtins.int,
                 sample_size_bi_connector: _builtins.int,
                 tls_cipher_config_mode: _builtins.str,
                 transaction_lifetime_limit_seconds: _builtins.int):
        """
        :param _builtins.int change_stream_options_pre_and_post_images_expire_after_seconds: (Optional) The minimum pre- and post-image retention time in seconds. This parameter is only supported for MongoDB version 6.0 and above. Defaults to `-1`(off).
        :param Sequence[_builtins.str] custom_openssl_cipher_config_tls12s: The custom OpenSSL cipher suite list for TLS 1.2. This field is only valid when `tls_cipher_config_mode` is set to `CUSTOM`.
        :param Sequence[_builtins.str] custom_openssl_cipher_config_tls13s: The custom OpenSSL cipher suite list for TLS 1.3. This field is only valid when `tls_cipher_config_mode` is set to `CUSTOM`.
        :param _builtins.int default_max_time_ms: Default time limit in milliseconds for individual read operations to complete. This option corresponds to the [defaultMaxTimeMS](https://www.mongodb.com/docs/upcoming/reference/cluster-parameters/defaultMaxTimeMS/) cluster parameter. This parameter is supported only for MongoDB version 8.0 and above.
        :param _builtins.str default_write_concern: [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 6.0 clusters default to [majority](https://docs.mongodb.com/manual/reference/write-concern/).
        :param _builtins.bool javascript_enabled: When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        :param _builtins.str minimum_enabled_tls_protocol: Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections. Valid values are:
               - TLS1_2
               - TLS1_3
        :param _builtins.bool no_table_scan: When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        :param _builtins.float oplog_min_retention_hours: Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        :param _builtins.int oplog_size_mb: The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        :param _builtins.int sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param _builtins.int sample_size_bi_connector: Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param _builtins.str tls_cipher_config_mode: The TLS cipher suite configuration mode. Valid values include `CUSTOM` or `DEFAULT`. The `DEFAULT` mode uses the default cipher suites. The `CUSTOM` mode allows you to specify custom cipher suites for both TLS 1.2 and TLS 1.3.
        :param _builtins.int transaction_lifetime_limit_seconds: (Optional) Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        pulumi.set(__self__, "change_stream_options_pre_and_post_images_expire_after_seconds", change_stream_options_pre_and_post_images_expire_after_seconds)
        pulumi.set(__self__, "custom_openssl_cipher_config_tls12s", custom_openssl_cipher_config_tls12s)
        pulumi.set(__self__, "custom_openssl_cipher_config_tls13s", custom_openssl_cipher_config_tls13s)
        pulumi.set(__self__, "default_max_time_ms", default_max_time_ms)
        pulumi.set(__self__, "default_write_concern", default_write_concern)
        pulumi.set(__self__, "javascript_enabled", javascript_enabled)
        pulumi.set(__self__, "minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        pulumi.set(__self__, "no_table_scan", no_table_scan)
        pulumi.set(__self__, "oplog_min_retention_hours", oplog_min_retention_hours)
        pulumi.set(__self__, "oplog_size_mb", oplog_size_mb)
        pulumi.set(__self__, "sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        pulumi.set(__self__, "sample_size_bi_connector", sample_size_bi_connector)
        pulumi.set(__self__, "tls_cipher_config_mode", tls_cipher_config_mode)
        pulumi.set(__self__, "transaction_lifetime_limit_seconds", transaction_lifetime_limit_seconds)

    @_builtins.property
    @pulumi.getter(name="changeStreamOptionsPreAndPostImagesExpireAfterSeconds")
    def change_stream_options_pre_and_post_images_expire_after_seconds(self) -> _builtins.int:
        """
        (Optional) The minimum pre- and post-image retention time in seconds. This parameter is only supported for MongoDB version 6.0 and above. Defaults to `-1`(off).
        """
        return pulumi.get(self, "change_stream_options_pre_and_post_images_expire_after_seconds")

    @_builtins.property
    @pulumi.getter(name="customOpensslCipherConfigTls12s")
    def custom_openssl_cipher_config_tls12s(self) -> Sequence[_builtins.str]:
        """
        The custom OpenSSL cipher suite list for TLS 1.2. This field is only valid when `tls_cipher_config_mode` is set to `CUSTOM`.
        """
        return pulumi.get(self, "custom_openssl_cipher_config_tls12s")

    @_builtins.property
    @pulumi.getter(name="customOpensslCipherConfigTls13s")
    def custom_openssl_cipher_config_tls13s(self) -> Sequence[_builtins.str]:
        """
        The custom OpenSSL cipher suite list for TLS 1.3. This field is only valid when `tls_cipher_config_mode` is set to `CUSTOM`.
        """
        return pulumi.get(self, "custom_openssl_cipher_config_tls13s")

    @_builtins.property
    @pulumi.getter(name="defaultMaxTimeMs")
    def default_max_time_ms(self) -> _builtins.int:
        """
        Default time limit in milliseconds for individual read operations to complete. This option corresponds to the [defaultMaxTimeMS](https://www.mongodb.com/docs/upcoming/reference/cluster-parameters/defaultMaxTimeMS/) cluster parameter. This parameter is supported only for MongoDB version 8.0 and above.
        """
        return pulumi.get(self, "default_max_time_ms")

    @_builtins.property
    @pulumi.getter(name="defaultWriteConcern")
    def default_write_concern(self) -> _builtins.str:
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 6.0 clusters default to [majority](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        return pulumi.get(self, "default_write_concern")

    @_builtins.property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> _builtins.bool:
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        return pulumi.get(self, "javascript_enabled")

    @_builtins.property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> _builtins.str:
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections. Valid values are:
        - TLS1_2
        - TLS1_3
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @_builtins.property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> _builtins.bool:
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        return pulumi.get(self, "no_table_scan")

    @_builtins.property
    @pulumi.getter(name="oplogMinRetentionHours")
    def oplog_min_retention_hours(self) -> _builtins.float:
        """
        Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        """
        return pulumi.get(self, "oplog_min_retention_hours")

    @_builtins.property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> _builtins.int:
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        return pulumi.get(self, "oplog_size_mb")

    @_builtins.property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> _builtins.int:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @_builtins.property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> _builtins.int:
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_size_bi_connector")

    @_builtins.property
    @pulumi.getter(name="tlsCipherConfigMode")
    def tls_cipher_config_mode(self) -> _builtins.str:
        """
        The TLS cipher suite configuration mode. Valid values include `CUSTOM` or `DEFAULT`. The `DEFAULT` mode uses the default cipher suites. The `CUSTOM` mode allows you to specify custom cipher suites for both TLS 1.2 and TLS 1.3.
        """
        return pulumi.get(self, "tls_cipher_config_mode")

    @_builtins.property
    @pulumi.getter(name="transactionLifetimeLimitSeconds")
    def transaction_lifetime_limit_seconds(self) -> _builtins.int:
        """
        (Optional) Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        return pulumi.get(self, "transaction_lifetime_limit_seconds")


@pulumi.output_type
class GetAdvancedClustersResultBiConnectorConfigResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 read_preference: _builtins.str):
        """
        :param _builtins.bool enabled: Specifies whether or not BI Connector for Atlas is enabled on the cluster.
        :param _builtins.str read_preference: Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "read_preference", read_preference)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Specifies whether or not BI Connector for Atlas is enabled on the cluster.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> _builtins.str:
        """
        Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        return pulumi.get(self, "read_preference")


@pulumi.output_type
class GetAdvancedClustersResultConnectionStringsResult(dict):
    def __init__(__self__, *,
                 private: _builtins.str,
                 private_endpoints: Sequence['outputs.GetAdvancedClustersResultConnectionStringsPrivateEndpointResult'],
                 private_srv: _builtins.str,
                 standard: _builtins.str,
                 standard_srv: _builtins.str):
        """
        :param _builtins.str private: [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        :param Sequence['GetAdvancedClustersResultConnectionStringsPrivateEndpointArgs'] private_endpoints: Private endpoint connection strings. Each object describes the connection strings you can use to connect to this cluster through a private endpoint. Atlas returns this parameter only if you deployed a private endpoint to all regions to which you deployed this cluster's nodes.
               - `connection_strings.private_endpoint[#].connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
               - `connection_strings.private_endpoint[#].srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in DNS . Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don't need to: Append the seed list or Change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn't, use `connection_strings.private_endpoint[#].connection_string`
               - `connection_strings.private_endpoint[#].srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster support it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[#].srvConnectionString.
               - `connection_strings.private_endpoint[#].type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
               - `connection_strings.private_endpoint[#].endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[#].connection_string` or `connection_strings.private_endpoint[#].srv_connection_string`
               - `connection_strings.private_endpoint[#].endpoints[#].endpoint_id` - Unique identifier of the private endpoint.
               - `connection_strings.private_endpoint[#].endpoints[#].provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
               - `connection_strings.private_endpoint[#].endpoints[#].region` - Region to which you deployed the private endpoint.
        :param _builtins.str private_srv: [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        :param _builtins.str standard: Public mongodb:// connection string for this cluster.
        :param _builtins.str standard_srv: Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t  , use connectionStrings.standard.
        """
        pulumi.set(__self__, "private", private)
        pulumi.set(__self__, "private_endpoints", private_endpoints)
        pulumi.set(__self__, "private_srv", private_srv)
        pulumi.set(__self__, "standard", standard)
        pulumi.set(__self__, "standard_srv", standard_srv)

    @_builtins.property
    @pulumi.getter
    def private(self) -> _builtins.str:
        """
        [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        """
        return pulumi.get(self, "private")

    @_builtins.property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Sequence['outputs.GetAdvancedClustersResultConnectionStringsPrivateEndpointResult']:
        """
        Private endpoint connection strings. Each object describes the connection strings you can use to connect to this cluster through a private endpoint. Atlas returns this parameter only if you deployed a private endpoint to all regions to which you deployed this cluster's nodes.
        - `connection_strings.private_endpoint[#].connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
        - `connection_strings.private_endpoint[#].srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in DNS . Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don't need to: Append the seed list or Change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn't, use `connection_strings.private_endpoint[#].connection_string`
        - `connection_strings.private_endpoint[#].srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster support it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[#].srvConnectionString.
        - `connection_strings.private_endpoint[#].type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
        - `connection_strings.private_endpoint[#].endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[#].connection_string` or `connection_strings.private_endpoint[#].srv_connection_string`
        - `connection_strings.private_endpoint[#].endpoints[#].endpoint_id` - Unique identifier of the private endpoint.
        - `connection_strings.private_endpoint[#].endpoints[#].provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
        - `connection_strings.private_endpoint[#].endpoints[#].region` - Region to which you deployed the private endpoint.
        """
        return pulumi.get(self, "private_endpoints")

    @_builtins.property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> _builtins.str:
        """
        [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        """
        return pulumi.get(self, "private_srv")

    @_builtins.property
    @pulumi.getter
    def standard(self) -> _builtins.str:
        """
        Public mongodb:// connection string for this cluster.
        """
        return pulumi.get(self, "standard")

    @_builtins.property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> _builtins.str:
        """
        Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t  , use connectionStrings.standard.
        """
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class GetAdvancedClustersResultConnectionStringsPrivateEndpointResult(dict):
    def __init__(__self__, *,
                 connection_string: _builtins.str,
                 endpoints: Sequence['outputs.GetAdvancedClustersResultConnectionStringsPrivateEndpointEndpointResult'],
                 srv_connection_string: _builtins.str,
                 srv_shard_optimized_connection_string: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str connection_string: Private endpoint-aware connection string that uses the `mongodb://` protocol to connect to MongoDB Cloud through a private endpoint.
        :param Sequence['GetAdvancedClustersResultConnectionStringsPrivateEndpointEndpointArgs'] endpoints: List that contains the private endpoints through which you connect to MongoDB Cloud when you use **connectionStrings.privateEndpoint[n].connectionString** or **connectionStrings.privateEndpoint[n].srvConnectionString**.
        :param _builtins.str srv_connection_string: Private endpoint-aware connection string that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in the Domain Name System (DNS). This list synchronizes with the nodes in a cluster. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to append the seed list or change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application supports it. If it doesn't, use connectionStrings.privateEndpoint[n].connectionString.
        :param _builtins.str srv_shard_optimized_connection_string: Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster supports it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[n].srvConnectionString.
        :param _builtins.str type: MongoDB process type to which your application connects. Use `MONGOD` for replica sets and `MONGOS` for sharded clusters.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "srv_connection_string", srv_connection_string)
        pulumi.set(__self__, "srv_shard_optimized_connection_string", srv_shard_optimized_connection_string)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> _builtins.str:
        """
        Private endpoint-aware connection string that uses the `mongodb://` protocol to connect to MongoDB Cloud through a private endpoint.
        """
        return pulumi.get(self, "connection_string")

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> Sequence['outputs.GetAdvancedClustersResultConnectionStringsPrivateEndpointEndpointResult']:
        """
        List that contains the private endpoints through which you connect to MongoDB Cloud when you use **connectionStrings.privateEndpoint[n].connectionString** or **connectionStrings.privateEndpoint[n].srvConnectionString**.
        """
        return pulumi.get(self, "endpoints")

    @_builtins.property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> _builtins.str:
        """
        Private endpoint-aware connection string that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in the Domain Name System (DNS). This list synchronizes with the nodes in a cluster. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to append the seed list or change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application supports it. If it doesn't, use connectionStrings.privateEndpoint[n].connectionString.
        """
        return pulumi.get(self, "srv_connection_string")

    @_builtins.property
    @pulumi.getter(name="srvShardOptimizedConnectionString")
    def srv_shard_optimized_connection_string(self) -> _builtins.str:
        """
        Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster supports it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[n].srvConnectionString.
        """
        return pulumi.get(self, "srv_shard_optimized_connection_string")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        MongoDB process type to which your application connects. Use `MONGOD` for replica sets and `MONGOS` for sharded clusters.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAdvancedClustersResultConnectionStringsPrivateEndpointEndpointResult(dict):
    def __init__(__self__, *,
                 endpoint_id: _builtins.str,
                 provider_name: _builtins.str,
                 region: _builtins.str):
        """
        :param _builtins.str endpoint_id: Unique string that the cloud provider uses to identify the private endpoint.
        :param _builtins.str provider_name: Cloud service provider on which the servers are provisioned.
        :param _builtins.str region: Region where the private endpoint is deployed.
        """
        pulumi.set(__self__, "endpoint_id", endpoint_id)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> _builtins.str:
        """
        Unique string that the cloud provider uses to identify the private endpoint.
        """
        return pulumi.get(self, "endpoint_id")

    @_builtins.property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> _builtins.str:
        """
        Cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Region where the private endpoint is deployed.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetAdvancedClustersResultPinnedFcvResult(dict):
    def __init__(__self__, *,
                 expiration_date: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str expiration_date: Expiration date of the fixed FCV. This value is in the ISO 8601 timestamp format (e.g. "2024-12-04T16:25:00Z").
        :param _builtins.str version: Feature compatibility version of the cluster.
        """
        pulumi.set(__self__, "expiration_date", expiration_date)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> _builtins.str:
        """
        Expiration date of the fixed FCV. This value is in the ISO 8601 timestamp format (e.g. "2024-12-04T16:25:00Z").
        """
        return pulumi.get(self, "expiration_date")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Feature compatibility version of the cluster.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecResult(dict):
    def __init__(__self__, *,
                 container_id: Mapping[str, _builtins.str],
                 external_id: _builtins.str,
                 region_configs: Sequence['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigResult'],
                 zone_id: _builtins.str,
                 zone_name: _builtins.str):
        """
        :param Mapping[str, _builtins.str] container_id: A key-value map of the Network Peering Container ID(s) for the configuration specified in `region_configs`. The Container ID is the id of the container either created programmatically by the user before any clusters existed in a project or when the first cluster in the region (AWS/Azure) or project (GCP) was created.  The syntax is `"providerName:regionName" = "containerId"`. Example `AWS:US_EAST_1" = "61e0797dde08fb498ca11a71`.
        :param _builtins.str external_id: Unique 24-hexadecimal digit string that identifies the replication object for a shard in a Cluster. This value corresponds to Shard ID displayed in the UI.
        :param Sequence['GetAdvancedClustersResultReplicationSpecRegionConfigArgs'] region_configs: Configuration for the hardware specifications for nodes set for a given region. Each `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below.
        :param _builtins.str zone_id: Unique 24-hexadecimal digit string that identifies the zone in a Global Cluster. If clusterType is GEOSHARDED, this value indicates the zone that the given shard belongs to and can be used to configure Global Cluster backup policies.
        :param _builtins.str zone_name: Name for the zone in a Global Cluster.
        """
        pulumi.set(__self__, "container_id", container_id)
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "region_configs", region_configs)
        pulumi.set(__self__, "zone_id", zone_id)
        pulumi.set(__self__, "zone_name", zone_name)

    @_builtins.property
    @pulumi.getter(name="containerId")
    def container_id(self) -> Mapping[str, _builtins.str]:
        """
        A key-value map of the Network Peering Container ID(s) for the configuration specified in `region_configs`. The Container ID is the id of the container either created programmatically by the user before any clusters existed in a project or when the first cluster in the region (AWS/Azure) or project (GCP) was created.  The syntax is `"providerName:regionName" = "containerId"`. Example `AWS:US_EAST_1" = "61e0797dde08fb498ca11a71`.
        """
        return pulumi.get(self, "container_id")

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the replication object for a shard in a Cluster. This value corresponds to Shard ID displayed in the UI.
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="regionConfigs")
    def region_configs(self) -> Sequence['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigResult']:
        """
        Configuration for the hardware specifications for nodes set for a given region. Each `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below.
        """
        return pulumi.get(self, "region_configs")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the zone in a Global Cluster. If clusterType is GEOSHARDED, this value indicates the zone that the given shard belongs to and can be used to configure Global Cluster backup policies.
        """
        return pulumi.get(self, "zone_id")

    @_builtins.property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> _builtins.str:
        """
        Name for the zone in a Global Cluster.
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecRegionConfigResult(dict):
    def __init__(__self__, *,
                 analytics_auto_scaling: 'outputs.GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsAutoScalingResult',
                 analytics_specs: 'outputs.GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecsResult',
                 auto_scaling: 'outputs.GetAdvancedClustersResultReplicationSpecRegionConfigAutoScalingResult',
                 backing_provider_name: _builtins.str,
                 effective_analytics_specs: 'outputs.GetAdvancedClustersResultReplicationSpecRegionConfigEffectiveAnalyticsSpecsResult',
                 effective_electable_specs: 'outputs.GetAdvancedClustersResultReplicationSpecRegionConfigEffectiveElectableSpecsResult',
                 effective_read_only_specs: 'outputs.GetAdvancedClustersResultReplicationSpecRegionConfigEffectiveReadOnlySpecsResult',
                 electable_specs: 'outputs.GetAdvancedClustersResultReplicationSpecRegionConfigElectableSpecsResult',
                 priority: _builtins.int,
                 provider_name: _builtins.str,
                 read_only_specs: 'outputs.GetAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecsResult',
                 region_name: _builtins.str):
        """
        :param 'GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsAutoScalingArgs' analytics_auto_scaling: Configuration for the Collection of settings that configures analytis-auto-scaling information for the cluster. See below.
        :param 'GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecsArgs' analytics_specs: Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. See below.
        :param 'GetAdvancedClustersResultReplicationSpecRegionConfigAutoScalingArgs' auto_scaling: Configuration for the Collection of settings that configures auto-scaling information for the cluster. See below.
        :param _builtins.str backing_provider_name: Cloud service provider on which you provision the host for a multi-tenant cluster.
        :param 'GetAdvancedClustersResultReplicationSpecRegionConfigEffectiveAnalyticsSpecsArgs' effective_analytics_specs: Effective hardware specifications for analytics nodes in the region, reflecting actual Atlas-managed values including auto-scaling changes. See below.
        :param 'GetAdvancedClustersResultReplicationSpecRegionConfigEffectiveElectableSpecsArgs' effective_electable_specs: Effective hardware specifications for electable nodes in the region, reflecting actual Atlas-managed values including auto-scaling changes. See below.
        :param 'GetAdvancedClustersResultReplicationSpecRegionConfigEffectiveReadOnlySpecsArgs' effective_read_only_specs: Effective hardware specifications for read-only nodes in the region, reflecting actual Atlas-managed values including auto-scaling changes. See below.
        :param 'GetAdvancedClustersResultReplicationSpecRegionConfigElectableSpecsArgs' electable_specs: Hardware specifications for electable nodes in the region.
        :param _builtins.int priority: Election priority of the region.
        :param _builtins.str provider_name: Cloud service provider on which the servers are provisioned.
        :param 'GetAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecsArgs' read_only_specs: Hardware specifications for read-only nodes in the region. See below.
        :param _builtins.str region_name: Physical location of your MongoDB cluster.
        """
        pulumi.set(__self__, "analytics_auto_scaling", analytics_auto_scaling)
        pulumi.set(__self__, "analytics_specs", analytics_specs)
        pulumi.set(__self__, "auto_scaling", auto_scaling)
        pulumi.set(__self__, "backing_provider_name", backing_provider_name)
        pulumi.set(__self__, "effective_analytics_specs", effective_analytics_specs)
        pulumi.set(__self__, "effective_electable_specs", effective_electable_specs)
        pulumi.set(__self__, "effective_read_only_specs", effective_read_only_specs)
        pulumi.set(__self__, "electable_specs", electable_specs)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "read_only_specs", read_only_specs)
        pulumi.set(__self__, "region_name", region_name)

    @_builtins.property
    @pulumi.getter(name="analyticsAutoScaling")
    def analytics_auto_scaling(self) -> 'outputs.GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsAutoScalingResult':
        """
        Configuration for the Collection of settings that configures analytis-auto-scaling information for the cluster. See below.
        """
        return pulumi.get(self, "analytics_auto_scaling")

    @_builtins.property
    @pulumi.getter(name="analyticsSpecs")
    def analytics_specs(self) -> 'outputs.GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecsResult':
        """
        Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. See below.
        """
        return pulumi.get(self, "analytics_specs")

    @_builtins.property
    @pulumi.getter(name="autoScaling")
    def auto_scaling(self) -> 'outputs.GetAdvancedClustersResultReplicationSpecRegionConfigAutoScalingResult':
        """
        Configuration for the Collection of settings that configures auto-scaling information for the cluster. See below.
        """
        return pulumi.get(self, "auto_scaling")

    @_builtins.property
    @pulumi.getter(name="backingProviderName")
    def backing_provider_name(self) -> _builtins.str:
        """
        Cloud service provider on which you provision the host for a multi-tenant cluster.
        """
        return pulumi.get(self, "backing_provider_name")

    @_builtins.property
    @pulumi.getter(name="effectiveAnalyticsSpecs")
    def effective_analytics_specs(self) -> 'outputs.GetAdvancedClustersResultReplicationSpecRegionConfigEffectiveAnalyticsSpecsResult':
        """
        Effective hardware specifications for analytics nodes in the region, reflecting actual Atlas-managed values including auto-scaling changes. See below.
        """
        return pulumi.get(self, "effective_analytics_specs")

    @_builtins.property
    @pulumi.getter(name="effectiveElectableSpecs")
    def effective_electable_specs(self) -> 'outputs.GetAdvancedClustersResultReplicationSpecRegionConfigEffectiveElectableSpecsResult':
        """
        Effective hardware specifications for electable nodes in the region, reflecting actual Atlas-managed values including auto-scaling changes. See below.
        """
        return pulumi.get(self, "effective_electable_specs")

    @_builtins.property
    @pulumi.getter(name="effectiveReadOnlySpecs")
    def effective_read_only_specs(self) -> 'outputs.GetAdvancedClustersResultReplicationSpecRegionConfigEffectiveReadOnlySpecsResult':
        """
        Effective hardware specifications for read-only nodes in the region, reflecting actual Atlas-managed values including auto-scaling changes. See below.
        """
        return pulumi.get(self, "effective_read_only_specs")

    @_builtins.property
    @pulumi.getter(name="electableSpecs")
    def electable_specs(self) -> 'outputs.GetAdvancedClustersResultReplicationSpecRegionConfigElectableSpecsResult':
        """
        Hardware specifications for electable nodes in the region.
        """
        return pulumi.get(self, "electable_specs")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        Election priority of the region.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> _builtins.str:
        """
        Cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @_builtins.property
    @pulumi.getter(name="readOnlySpecs")
    def read_only_specs(self) -> 'outputs.GetAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecsResult':
        """
        Hardware specifications for read-only nodes in the region. See below.
        """
        return pulumi.get(self, "read_only_specs")

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> _builtins.str:
        """
        Physical location of your MongoDB cluster.
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsAutoScalingResult(dict):
    def __init__(__self__, *,
                 compute_enabled: _builtins.bool,
                 compute_max_instance_size: _builtins.str,
                 compute_min_instance_size: _builtins.str,
                 compute_scale_down_enabled: _builtins.bool,
                 disk_gb_enabled: _builtins.bool):
        """
        :param _builtins.bool compute_enabled: Flag that indicates whether instance size auto-scaling is enabled.
        :param _builtins.str compute_max_instance_size: Maximum instance size to which your cluster can automatically scale (such as M40).
        :param _builtins.str compute_min_instance_size: Minimum instance size to which your cluster can automatically scale (such as M10).
        :param _builtins.bool compute_scale_down_enabled: Flag that indicates whether the instance size may scale down.
        :param _builtins.bool disk_gb_enabled: Flag that indicates whether this cluster enables disk auto-scaling.
        """
        pulumi.set(__self__, "compute_enabled", compute_enabled)
        pulumi.set(__self__, "compute_max_instance_size", compute_max_instance_size)
        pulumi.set(__self__, "compute_min_instance_size", compute_min_instance_size)
        pulumi.set(__self__, "compute_scale_down_enabled", compute_scale_down_enabled)
        pulumi.set(__self__, "disk_gb_enabled", disk_gb_enabled)

    @_builtins.property
    @pulumi.getter(name="computeEnabled")
    def compute_enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether instance size auto-scaling is enabled.
        """
        return pulumi.get(self, "compute_enabled")

    @_builtins.property
    @pulumi.getter(name="computeMaxInstanceSize")
    def compute_max_instance_size(self) -> _builtins.str:
        """
        Maximum instance size to which your cluster can automatically scale (such as M40).
        """
        return pulumi.get(self, "compute_max_instance_size")

    @_builtins.property
    @pulumi.getter(name="computeMinInstanceSize")
    def compute_min_instance_size(self) -> _builtins.str:
        """
        Minimum instance size to which your cluster can automatically scale (such as M10).
        """
        return pulumi.get(self, "compute_min_instance_size")

    @_builtins.property
    @pulumi.getter(name="computeScaleDownEnabled")
    def compute_scale_down_enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether the instance size may scale down.
        """
        return pulumi.get(self, "compute_scale_down_enabled")

    @_builtins.property
    @pulumi.getter(name="diskGbEnabled")
    def disk_gb_enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether this cluster enables disk auto-scaling.
        """
        return pulumi.get(self, "disk_gb_enabled")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecsResult(dict):
    def __init__(__self__, *,
                 disk_iops: _builtins.int,
                 disk_size_gb: _builtins.float,
                 ebs_volume_type: _builtins.str,
                 instance_size: _builtins.str,
                 node_count: _builtins.int):
        """
        :param _builtins.int disk_iops: Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        :param _builtins.float disk_size_gb: Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        :param _builtins.str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster.
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param _builtins.str instance_size: Hardware specification for the instance sizes in this region.
        :param _builtins.int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        pulumi.set(__self__, "disk_iops", disk_iops)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        pulumi.set(__self__, "instance_size", instance_size)
        pulumi.set(__self__, "node_count", node_count)

    @_builtins.property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> _builtins.int:
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        """
        return pulumi.get(self, "disk_iops")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> _builtins.float:
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> _builtins.str:
        """
        Type of storage you want to attach to your AWS-provisioned cluster.
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @_builtins.property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> _builtins.str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> _builtins.int:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecRegionConfigAutoScalingResult(dict):
    def __init__(__self__, *,
                 compute_enabled: _builtins.bool,
                 compute_max_instance_size: _builtins.str,
                 compute_min_instance_size: _builtins.str,
                 compute_scale_down_enabled: _builtins.bool,
                 disk_gb_enabled: _builtins.bool):
        """
        :param _builtins.bool compute_enabled: Flag that indicates whether instance size auto-scaling is enabled.
        :param _builtins.str compute_max_instance_size: Maximum instance size to which your cluster can automatically scale (such as M40).
        :param _builtins.str compute_min_instance_size: Minimum instance size to which your cluster can automatically scale (such as M10).
        :param _builtins.bool compute_scale_down_enabled: Flag that indicates whether the instance size may scale down.
        :param _builtins.bool disk_gb_enabled: Flag that indicates whether this cluster enables disk auto-scaling.
        """
        pulumi.set(__self__, "compute_enabled", compute_enabled)
        pulumi.set(__self__, "compute_max_instance_size", compute_max_instance_size)
        pulumi.set(__self__, "compute_min_instance_size", compute_min_instance_size)
        pulumi.set(__self__, "compute_scale_down_enabled", compute_scale_down_enabled)
        pulumi.set(__self__, "disk_gb_enabled", disk_gb_enabled)

    @_builtins.property
    @pulumi.getter(name="computeEnabled")
    def compute_enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether instance size auto-scaling is enabled.
        """
        return pulumi.get(self, "compute_enabled")

    @_builtins.property
    @pulumi.getter(name="computeMaxInstanceSize")
    def compute_max_instance_size(self) -> _builtins.str:
        """
        Maximum instance size to which your cluster can automatically scale (such as M40).
        """
        return pulumi.get(self, "compute_max_instance_size")

    @_builtins.property
    @pulumi.getter(name="computeMinInstanceSize")
    def compute_min_instance_size(self) -> _builtins.str:
        """
        Minimum instance size to which your cluster can automatically scale (such as M10).
        """
        return pulumi.get(self, "compute_min_instance_size")

    @_builtins.property
    @pulumi.getter(name="computeScaleDownEnabled")
    def compute_scale_down_enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether the instance size may scale down.
        """
        return pulumi.get(self, "compute_scale_down_enabled")

    @_builtins.property
    @pulumi.getter(name="diskGbEnabled")
    def disk_gb_enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether this cluster enables disk auto-scaling.
        """
        return pulumi.get(self, "disk_gb_enabled")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecRegionConfigEffectiveAnalyticsSpecsResult(dict):
    def __init__(__self__, *,
                 disk_iops: _builtins.int,
                 disk_size_gb: _builtins.float,
                 ebs_volume_type: _builtins.str,
                 instance_size: _builtins.str,
                 node_count: _builtins.int):
        """
        :param _builtins.int disk_iops: Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        :param _builtins.float disk_size_gb: Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        :param _builtins.str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster.
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param _builtins.str instance_size: Hardware specification for the instance sizes in this region.
        :param _builtins.int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        pulumi.set(__self__, "disk_iops", disk_iops)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        pulumi.set(__self__, "instance_size", instance_size)
        pulumi.set(__self__, "node_count", node_count)

    @_builtins.property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> _builtins.int:
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        """
        return pulumi.get(self, "disk_iops")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> _builtins.float:
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> _builtins.str:
        """
        Type of storage you want to attach to your AWS-provisioned cluster.
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @_builtins.property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> _builtins.str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> _builtins.int:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecRegionConfigEffectiveElectableSpecsResult(dict):
    def __init__(__self__, *,
                 disk_iops: _builtins.int,
                 disk_size_gb: _builtins.float,
                 ebs_volume_type: _builtins.str,
                 instance_size: _builtins.str,
                 node_count: _builtins.int):
        """
        :param _builtins.int disk_iops: Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        :param _builtins.float disk_size_gb: Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        :param _builtins.str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster.
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param _builtins.str instance_size: Hardware specification for the instance sizes in this region.
        :param _builtins.int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        pulumi.set(__self__, "disk_iops", disk_iops)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        pulumi.set(__self__, "instance_size", instance_size)
        pulumi.set(__self__, "node_count", node_count)

    @_builtins.property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> _builtins.int:
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        """
        return pulumi.get(self, "disk_iops")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> _builtins.float:
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> _builtins.str:
        """
        Type of storage you want to attach to your AWS-provisioned cluster.
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @_builtins.property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> _builtins.str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> _builtins.int:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecRegionConfigEffectiveReadOnlySpecsResult(dict):
    def __init__(__self__, *,
                 disk_iops: _builtins.int,
                 disk_size_gb: _builtins.float,
                 ebs_volume_type: _builtins.str,
                 instance_size: _builtins.str,
                 node_count: _builtins.int):
        """
        :param _builtins.int disk_iops: Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        :param _builtins.float disk_size_gb: Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        :param _builtins.str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster.
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param _builtins.str instance_size: Hardware specification for the instance sizes in this region.
        :param _builtins.int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        pulumi.set(__self__, "disk_iops", disk_iops)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        pulumi.set(__self__, "instance_size", instance_size)
        pulumi.set(__self__, "node_count", node_count)

    @_builtins.property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> _builtins.int:
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        """
        return pulumi.get(self, "disk_iops")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> _builtins.float:
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> _builtins.str:
        """
        Type of storage you want to attach to your AWS-provisioned cluster.
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @_builtins.property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> _builtins.str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> _builtins.int:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecRegionConfigElectableSpecsResult(dict):
    def __init__(__self__, *,
                 disk_iops: _builtins.int,
                 disk_size_gb: _builtins.float,
                 ebs_volume_type: _builtins.str,
                 instance_size: _builtins.str,
                 node_count: _builtins.int):
        """
        :param _builtins.int disk_iops: Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        :param _builtins.float disk_size_gb: Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        :param _builtins.str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster.
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param _builtins.str instance_size: Hardware specification for the instance sizes in this region.
        :param _builtins.int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        pulumi.set(__self__, "disk_iops", disk_iops)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        pulumi.set(__self__, "instance_size", instance_size)
        pulumi.set(__self__, "node_count", node_count)

    @_builtins.property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> _builtins.int:
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        """
        return pulumi.get(self, "disk_iops")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> _builtins.float:
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> _builtins.str:
        """
        Type of storage you want to attach to your AWS-provisioned cluster.
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @_builtins.property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> _builtins.str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> _builtins.int:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecsResult(dict):
    def __init__(__self__, *,
                 disk_iops: _builtins.int,
                 disk_size_gb: _builtins.float,
                 ebs_volume_type: _builtins.str,
                 instance_size: _builtins.str,
                 node_count: _builtins.int):
        """
        :param _builtins.int disk_iops: Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        :param _builtins.float disk_size_gb: Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        :param _builtins.str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster.
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param _builtins.str instance_size: Hardware specification for the instance sizes in this region.
        :param _builtins.int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        pulumi.set(__self__, "disk_iops", disk_iops)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        pulumi.set(__self__, "instance_size", instance_size)
        pulumi.set(__self__, "node_count", node_count)

    @_builtins.property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> _builtins.int:
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        """
        return pulumi.get(self, "disk_iops")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> _builtins.float:
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> _builtins.str:
        """
        Type of storage you want to attach to your AWS-provisioned cluster.
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @_builtins.property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> _builtins.str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> _builtins.int:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAlertConfigurationMatcherResult(dict):
    def __init__(__self__, *,
                 field_name: _builtins.str,
                 operator: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str field_name: Name of the field in the target object to match on.
        :param _builtins.str operator: The operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
               - `GREATER_THAN`
               - `LESS_THAN`
        :param _builtins.str value: Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
               - `PRIMARY`
               - `SECONDARY`
               - `STANDALONE`
               - `CONFIG`
               - `MONGOS`
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> _builtins.str:
        """
        Name of the field in the target object to match on.
        """
        return pulumi.get(self, "field_name")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        - `GREATER_THAN`
        - `LESS_THAN`
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
        - `PRIMARY`
        - `SECONDARY`
        - `STANDALONE`
        - `CONFIG`
        - `MONGOS`
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAlertConfigurationMetricThresholdConfigResult(dict):
    def __init__(__self__, *,
                 metric_name: _builtins.str,
                 mode: _builtins.str,
                 operator: _builtins.str,
                 threshold: _builtins.float,
                 units: _builtins.str):
        """
        :param _builtins.str metric_name: Name of the metric to check. The full list being quite large, please refer to atlas docs [here for general metrics](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types) and [here for serverless metrics](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-create-config/#serverless-measurements)
        :param _builtins.str mode: This must be set to AVERAGE. Atlas computes the current metric value as an average.
        :param _builtins.str operator: The operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
               - `GREATER_THAN`
               - `LESS_THAN`
        :param _builtins.float threshold: Threshold value outside of which an alert will be triggered.
        :param _builtins.str units: The units for the threshold value. Depends on the type of metric.
               Refer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "units", units)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        """
        Name of the metric to check. The full list being quite large, please refer to atlas docs [here for general metrics](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types) and [here for serverless metrics](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-create-config/#serverless-measurements)
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        This must be set to AVERAGE. Atlas computes the current metric value as an average.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        - `GREATER_THAN`
        - `LESS_THAN`
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> _builtins.float:
        """
        Threshold value outside of which an alert will be triggered.
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def units(self) -> _builtins.str:
        """
        The units for the threshold value. Depends on the type of metric.
        Refer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.
        """
        return pulumi.get(self, "units")


@pulumi.output_type
class GetAlertConfigurationNotificationResult(dict):
    def __init__(__self__, *,
                 api_token: _builtins.str,
                 channel_name: _builtins.str,
                 datadog_api_key: _builtins.str,
                 datadog_region: _builtins.str,
                 delay_min: _builtins.int,
                 email_address: _builtins.str,
                 email_enabled: _builtins.bool,
                 integration_id: _builtins.str,
                 interval_min: _builtins.int,
                 microsoft_teams_webhook_url: _builtins.str,
                 mobile_number: _builtins.str,
                 notifier_id: _builtins.str,
                 ops_genie_api_key: _builtins.str,
                 ops_genie_region: _builtins.str,
                 roles: Sequence[_builtins.str],
                 service_key: _builtins.str,
                 sms_enabled: _builtins.bool,
                 team_id: _builtins.str,
                 team_name: _builtins.str,
                 type_name: _builtins.str,
                 username: _builtins.str,
                 victor_ops_api_key: _builtins.str,
                 victor_ops_routing_key: _builtins.str,
                 webhook_secret: _builtins.str,
                 webhook_url: _builtins.str):
        """
        :param _builtins.str api_token: Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param _builtins.str channel_name: Slack channel name. Required for the SLACK notifications type.
        :param _builtins.str datadog_api_key: Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        :param _builtins.str datadog_region: Region that indicates which API URL to use. See the `datadogRegion` field in the `notifications` request parameter of [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/api/doc/atlas-admin-api-v2/operation/operation-createalertconfiguration) for more details. The default Datadog region is US.
        :param _builtins.int delay_min: Number of minutes to wait after an alert condition is detected before sending out the first notification.
        :param _builtins.str email_address: Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        :param _builtins.bool email_enabled: Flag indicating email notifications should be sent. Atlas returns this value if `type_name` is set  to `ORG`, `GROUP`, or `USER`.
        :param _builtins.str integration_id: The ID of the associated integration, the credentials of which to use for requests.
        :param _builtins.int interval_min: Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5.
        :param _builtins.str microsoft_teams_webhook_url: Microsoft Teams channel incoming webhook URL. Required for the `MICROSOFT_TEAMS` notifications type.
        :param _builtins.str mobile_number: Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        :param _builtins.str notifier_id: The notifier ID is a system-generated unique identifier assigned to each notification method. This is needed when updating third-party notifications without requiring explicit authentication credentials.
        :param _builtins.str ops_genie_api_key: Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param _builtins.str ops_genie_region: Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        :param Sequence[_builtins.str] roles: Atlas role in current Project or Organization. Atlas returns this value if you set `type_name` to `ORG` or `GROUP`.
        :param _builtins.str service_key: PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param _builtins.bool sms_enabled: Flag indicating text notifications should be sent. Atlas returns this value if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        :param _builtins.str team_id: Unique identifier of a team.
        :param _builtins.str team_name: Label for the team that receives this notification.
        :param _builtins.str type_name: Type of alert notification.
               Accepted values are:
               - `DATADOG`
               - `EMAIL`
               - `GROUP` (Project)
               - `OPS_GENIE`
               - `ORG`
               - `PAGER_DUTY`
               - `SLACK`
               - `SMS`
               - `TEAM`
               - `USER`
               - `VICTOR_OPS`
               - `WEBHOOK`
               - `MICROSOFT_TEAMS`
        :param _builtins.str username: Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        :param _builtins.str victor_ops_api_key: VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param _builtins.str victor_ops_routing_key: VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param _builtins.str webhook_secret: Authentication secret for the `WEBHOOK` notifications type.
        :param _builtins.str webhook_url: Target URL  for the `WEBHOOK` notifications type.
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "channel_name", channel_name)
        pulumi.set(__self__, "datadog_api_key", datadog_api_key)
        pulumi.set(__self__, "datadog_region", datadog_region)
        pulumi.set(__self__, "delay_min", delay_min)
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "email_enabled", email_enabled)
        pulumi.set(__self__, "integration_id", integration_id)
        pulumi.set(__self__, "interval_min", interval_min)
        pulumi.set(__self__, "microsoft_teams_webhook_url", microsoft_teams_webhook_url)
        pulumi.set(__self__, "mobile_number", mobile_number)
        pulumi.set(__self__, "notifier_id", notifier_id)
        pulumi.set(__self__, "ops_genie_api_key", ops_genie_api_key)
        pulumi.set(__self__, "ops_genie_region", ops_genie_region)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "service_key", service_key)
        pulumi.set(__self__, "sms_enabled", sms_enabled)
        pulumi.set(__self__, "team_id", team_id)
        pulumi.set(__self__, "team_name", team_name)
        pulumi.set(__self__, "type_name", type_name)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "victor_ops_api_key", victor_ops_api_key)
        pulumi.set(__self__, "victor_ops_routing_key", victor_ops_routing_key)
        pulumi.set(__self__, "webhook_secret", webhook_secret)
        pulumi.set(__self__, "webhook_url", webhook_url)

    @_builtins.property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> _builtins.str:
        """
        Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "api_token")

    @_builtins.property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> _builtins.str:
        """
        Slack channel name. Required for the SLACK notifications type.
        """
        return pulumi.get(self, "channel_name")

    @_builtins.property
    @pulumi.getter(name="datadogApiKey")
    def datadog_api_key(self) -> _builtins.str:
        """
        Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        """
        return pulumi.get(self, "datadog_api_key")

    @_builtins.property
    @pulumi.getter(name="datadogRegion")
    def datadog_region(self) -> _builtins.str:
        """
        Region that indicates which API URL to use. See the `datadogRegion` field in the `notifications` request parameter of [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/api/doc/atlas-admin-api-v2/operation/operation-createalertconfiguration) for more details. The default Datadog region is US.
        """
        return pulumi.get(self, "datadog_region")

    @_builtins.property
    @pulumi.getter(name="delayMin")
    def delay_min(self) -> _builtins.int:
        """
        Number of minutes to wait after an alert condition is detected before sending out the first notification.
        """
        return pulumi.get(self, "delay_min")

    @_builtins.property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> _builtins.str:
        """
        Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        """
        return pulumi.get(self, "email_address")

    @_builtins.property
    @pulumi.getter(name="emailEnabled")
    def email_enabled(self) -> _builtins.bool:
        """
        Flag indicating email notifications should be sent. Atlas returns this value if `type_name` is set  to `ORG`, `GROUP`, or `USER`.
        """
        return pulumi.get(self, "email_enabled")

    @_builtins.property
    @pulumi.getter(name="integrationId")
    def integration_id(self) -> _builtins.str:
        """
        The ID of the associated integration, the credentials of which to use for requests.
        """
        return pulumi.get(self, "integration_id")

    @_builtins.property
    @pulumi.getter(name="intervalMin")
    def interval_min(self) -> _builtins.int:
        """
        Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5.
        """
        return pulumi.get(self, "interval_min")

    @_builtins.property
    @pulumi.getter(name="microsoftTeamsWebhookUrl")
    def microsoft_teams_webhook_url(self) -> _builtins.str:
        """
        Microsoft Teams channel incoming webhook URL. Required for the `MICROSOFT_TEAMS` notifications type.
        """
        return pulumi.get(self, "microsoft_teams_webhook_url")

    @_builtins.property
    @pulumi.getter(name="mobileNumber")
    def mobile_number(self) -> _builtins.str:
        """
        Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        """
        return pulumi.get(self, "mobile_number")

    @_builtins.property
    @pulumi.getter(name="notifierId")
    def notifier_id(self) -> _builtins.str:
        """
        The notifier ID is a system-generated unique identifier assigned to each notification method. This is needed when updating third-party notifications without requiring explicit authentication credentials.
        """
        return pulumi.get(self, "notifier_id")

    @_builtins.property
    @pulumi.getter(name="opsGenieApiKey")
    def ops_genie_api_key(self) -> _builtins.str:
        """
        Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "ops_genie_api_key")

    @_builtins.property
    @pulumi.getter(name="opsGenieRegion")
    def ops_genie_region(self) -> _builtins.str:
        """
        Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        """
        return pulumi.get(self, "ops_genie_region")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Sequence[_builtins.str]:
        """
        Atlas role in current Project or Organization. Atlas returns this value if you set `type_name` to `ORG` or `GROUP`.
        """
        return pulumi.get(self, "roles")

    @_builtins.property
    @pulumi.getter(name="serviceKey")
    def service_key(self) -> _builtins.str:
        """
        PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "service_key")

    @_builtins.property
    @pulumi.getter(name="smsEnabled")
    def sms_enabled(self) -> _builtins.bool:
        """
        Flag indicating text notifications should be sent. Atlas returns this value if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        """
        return pulumi.get(self, "sms_enabled")

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> _builtins.str:
        """
        Unique identifier of a team.
        """
        return pulumi.get(self, "team_id")

    @_builtins.property
    @pulumi.getter(name="teamName")
    def team_name(self) -> _builtins.str:
        """
        Label for the team that receives this notification.
        """
        return pulumi.get(self, "team_name")

    @_builtins.property
    @pulumi.getter(name="typeName")
    def type_name(self) -> _builtins.str:
        """
        Type of alert notification.
        Accepted values are:
        - `DATADOG`
        - `EMAIL`
        - `GROUP` (Project)
        - `OPS_GENIE`
        - `ORG`
        - `PAGER_DUTY`
        - `SLACK`
        - `SMS`
        - `TEAM`
        - `USER`
        - `VICTOR_OPS`
        - `WEBHOOK`
        - `MICROSOFT_TEAMS`
        """
        return pulumi.get(self, "type_name")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="victorOpsApiKey")
    def victor_ops_api_key(self) -> _builtins.str:
        """
        VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "victor_ops_api_key")

    @_builtins.property
    @pulumi.getter(name="victorOpsRoutingKey")
    def victor_ops_routing_key(self) -> _builtins.str:
        """
        VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "victor_ops_routing_key")

    @_builtins.property
    @pulumi.getter(name="webhookSecret")
    def webhook_secret(self) -> _builtins.str:
        """
        Authentication secret for the `WEBHOOK` notifications type.
        """
        return pulumi.get(self, "webhook_secret")

    @_builtins.property
    @pulumi.getter(name="webhookUrl")
    def webhook_url(self) -> _builtins.str:
        """
        Target URL  for the `WEBHOOK` notifications type.
        """
        return pulumi.get(self, "webhook_url")


@pulumi.output_type
class GetAlertConfigurationOutputResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 value: _builtins.str,
                 label: Optional[_builtins.str] = None):
        """
        :param _builtins.str value: Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
               - `PRIMARY`
               - `SECONDARY`
               - `STANDALONE`
               - `CONFIG`
               - `MONGOS`
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
        - `PRIMARY`
        - `SECONDARY`
        - `STANDALONE`
        - `CONFIG`
        - `MONGOS`
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "label")


@pulumi.output_type
class GetAlertConfigurationThresholdConfigResult(dict):
    def __init__(__self__, *,
                 operator: _builtins.str,
                 threshold: _builtins.float,
                 units: _builtins.str):
        """
        :param _builtins.str operator: The operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
               - `GREATER_THAN`
               - `LESS_THAN`
        :param _builtins.float threshold: Threshold value outside of which an alert will be triggered.
        :param _builtins.str units: The units for the threshold value. Depends on the type of metric.
               Refer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "units", units)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        - `GREATER_THAN`
        - `LESS_THAN`
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> _builtins.float:
        """
        Threshold value outside of which an alert will be triggered.
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def units(self) -> _builtins.str:
        """
        The units for the threshold value. Depends on the type of metric.
        Refer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.
        """
        return pulumi.get(self, "units")


@pulumi.output_type
class GetAlertConfigurationsListOptionResult(dict):
    def __init__(__self__, *,
                 include_count: Optional[_builtins.bool] = None,
                 items_per_page: Optional[_builtins.int] = None,
                 page_num: Optional[_builtins.int] = None):
        if include_count is not None:
            pulumi.set(__self__, "include_count", include_count)
        if items_per_page is not None:
            pulumi.set(__self__, "items_per_page", items_per_page)
        if page_num is not None:
            pulumi.set(__self__, "page_num", page_num)

    @_builtins.property
    @pulumi.getter(name="includeCount")
    def include_count(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "include_count")

    @_builtins.property
    @pulumi.getter(name="itemsPerPage")
    def items_per_page(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "items_per_page")

    @_builtins.property
    @pulumi.getter(name="pageNum")
    def page_num(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "page_num")


@pulumi.output_type
class GetAlertConfigurationsResultResult(dict):
    def __init__(__self__, *,
                 alert_configuration_id: _builtins.str,
                 created: _builtins.str,
                 enabled: _builtins.bool,
                 event_type: _builtins.str,
                 id: _builtins.str,
                 matchers: Sequence['outputs.GetAlertConfigurationsResultMatcherResult'],
                 metric_threshold_configs: Sequence['outputs.GetAlertConfigurationsResultMetricThresholdConfigResult'],
                 notifications: Sequence['outputs.GetAlertConfigurationsResultNotificationResult'],
                 outputs: Sequence['outputs.GetAlertConfigurationsResultOutputResult'],
                 project_id: _builtins.str,
                 severity_override: _builtins.str,
                 threshold_configs: Sequence['outputs.GetAlertConfigurationsResultThresholdConfigResult'],
                 updated: _builtins.str):
        """
        :param _builtins.str alert_configuration_id: The ID of the alert configuration
        :param _builtins.str created: Timestamp in ISO 8601 date and time format in UTC when this alert configuration was created.
        :param _builtins.bool enabled: If set to true, the alert configuration is enabled. If enabled is not exported it is set to false.
        :param _builtins.str event_type: The type of event that will trigger an alert.
        :param Sequence['GetAlertConfigurationsResultMatcherArgs'] matchers: Rules to apply when matching an object against this alert configuration. See matchers.
        :param Sequence['GetAlertConfigurationsResultMetricThresholdConfigArgs'] metric_threshold_configs: The threshold that causes an alert to be triggered. Required if `event_type_name` : `OUTSIDE_METRIC_THRESHOLD` or `OUTSIDE_SERVERLESS_METRIC_THRESHOLD`. See metric threshold config.
        :param Sequence['GetAlertConfigurationsResultOutputArgs'] outputs: Requested output string format for the alert configuration
        :param _builtins.str project_id: The unique ID for the project to get the alert configurations.
        :param _builtins.str severity_override: Severity of the event.
        :param Sequence['GetAlertConfigurationsResultThresholdConfigArgs'] threshold_configs: Threshold that triggers an alert. Required if `event_type_name` is any value other than `OUTSIDE_METRIC_THRESHOLD` or `OUTSIDE_SERVERLESS_METRIC_THRESHOLD`. See threshold config.
        :param _builtins.str updated: Timestamp in ISO 8601 date and time format in UTC when this alert configuration was last updated.
        """
        pulumi.set(__self__, "alert_configuration_id", alert_configuration_id)
        pulumi.set(__self__, "created", created)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "matchers", matchers)
        pulumi.set(__self__, "metric_threshold_configs", metric_threshold_configs)
        pulumi.set(__self__, "notifications", notifications)
        pulumi.set(__self__, "outputs", outputs)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "severity_override", severity_override)
        pulumi.set(__self__, "threshold_configs", threshold_configs)
        pulumi.set(__self__, "updated", updated)

    @_builtins.property
    @pulumi.getter(name="alertConfigurationId")
    def alert_configuration_id(self) -> _builtins.str:
        """
        The ID of the alert configuration
        """
        return pulumi.get(self, "alert_configuration_id")

    @_builtins.property
    @pulumi.getter
    def created(self) -> _builtins.str:
        """
        Timestamp in ISO 8601 date and time format in UTC when this alert configuration was created.
        """
        return pulumi.get(self, "created")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        If set to true, the alert configuration is enabled. If enabled is not exported it is set to false.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="eventType")
    def event_type(self) -> _builtins.str:
        """
        The type of event that will trigger an alert.
        """
        return pulumi.get(self, "event_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def matchers(self) -> Sequence['outputs.GetAlertConfigurationsResultMatcherResult']:
        """
        Rules to apply when matching an object against this alert configuration. See matchers.
        """
        return pulumi.get(self, "matchers")

    @_builtins.property
    @pulumi.getter(name="metricThresholdConfigs")
    def metric_threshold_configs(self) -> Sequence['outputs.GetAlertConfigurationsResultMetricThresholdConfigResult']:
        """
        The threshold that causes an alert to be triggered. Required if `event_type_name` : `OUTSIDE_METRIC_THRESHOLD` or `OUTSIDE_SERVERLESS_METRIC_THRESHOLD`. See metric threshold config.
        """
        return pulumi.get(self, "metric_threshold_configs")

    @_builtins.property
    @pulumi.getter
    def notifications(self) -> Sequence['outputs.GetAlertConfigurationsResultNotificationResult']:
        return pulumi.get(self, "notifications")

    @_builtins.property
    @pulumi.getter
    def outputs(self) -> Sequence['outputs.GetAlertConfigurationsResultOutputResult']:
        """
        Requested output string format for the alert configuration
        """
        return pulumi.get(self, "outputs")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The unique ID for the project to get the alert configurations.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="severityOverride")
    def severity_override(self) -> _builtins.str:
        """
        Severity of the event.
        """
        return pulumi.get(self, "severity_override")

    @_builtins.property
    @pulumi.getter(name="thresholdConfigs")
    def threshold_configs(self) -> Sequence['outputs.GetAlertConfigurationsResultThresholdConfigResult']:
        """
        Threshold that triggers an alert. Required if `event_type_name` is any value other than `OUTSIDE_METRIC_THRESHOLD` or `OUTSIDE_SERVERLESS_METRIC_THRESHOLD`. See threshold config.
        """
        return pulumi.get(self, "threshold_configs")

    @_builtins.property
    @pulumi.getter
    def updated(self) -> _builtins.str:
        """
        Timestamp in ISO 8601 date and time format in UTC when this alert configuration was last updated.
        """
        return pulumi.get(self, "updated")


@pulumi.output_type
class GetAlertConfigurationsResultMatcherResult(dict):
    def __init__(__self__, *,
                 field_name: _builtins.str,
                 operator: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str field_name: Name of the field in the target object to match on.
        :param _builtins.str operator: The operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
               - `GREATER_THAN`
               - `LESS_THAN`
        :param _builtins.str value: Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
               - `PRIMARY`
               - `SECONDARY`
               - `STANDALONE`
               - `CONFIG`
               - `MONGOS`
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> _builtins.str:
        """
        Name of the field in the target object to match on.
        """
        return pulumi.get(self, "field_name")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        - `GREATER_THAN`
        - `LESS_THAN`
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
        - `PRIMARY`
        - `SECONDARY`
        - `STANDALONE`
        - `CONFIG`
        - `MONGOS`
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAlertConfigurationsResultMetricThresholdConfigResult(dict):
    def __init__(__self__, *,
                 metric_name: _builtins.str,
                 mode: _builtins.str,
                 operator: _builtins.str,
                 threshold: _builtins.float,
                 units: _builtins.str):
        """
        :param _builtins.str metric_name: Name of the metric to check. The full list being quite large, please refer to atlas docs [here for general metrics](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types) and [here for serverless metrics](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-create-config/#serverless-measurements)
        :param _builtins.str mode: This must be set to AVERAGE. Atlas computes the current metric value as an average.
        :param _builtins.str operator: The operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
               - `GREATER_THAN`
               - `LESS_THAN`
        :param _builtins.float threshold: Threshold value outside of which an alert will be triggered.
        :param _builtins.str units: The units for the threshold value. Depends on the type of metric.
               Refer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "units", units)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> _builtins.str:
        """
        Name of the metric to check. The full list being quite large, please refer to atlas docs [here for general metrics](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types) and [here for serverless metrics](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-create-config/#serverless-measurements)
        """
        return pulumi.get(self, "metric_name")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        """
        This must be set to AVERAGE. Atlas computes the current metric value as an average.
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        - `GREATER_THAN`
        - `LESS_THAN`
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> _builtins.float:
        """
        Threshold value outside of which an alert will be triggered.
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def units(self) -> _builtins.str:
        """
        The units for the threshold value. Depends on the type of metric.
        Refer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.
        """
        return pulumi.get(self, "units")


@pulumi.output_type
class GetAlertConfigurationsResultNotificationResult(dict):
    def __init__(__self__, *,
                 api_token: _builtins.str,
                 channel_name: _builtins.str,
                 datadog_api_key: _builtins.str,
                 datadog_region: _builtins.str,
                 delay_min: _builtins.int,
                 email_address: _builtins.str,
                 email_enabled: _builtins.bool,
                 integration_id: _builtins.str,
                 interval_min: _builtins.int,
                 microsoft_teams_webhook_url: _builtins.str,
                 mobile_number: _builtins.str,
                 notifier_id: _builtins.str,
                 ops_genie_api_key: _builtins.str,
                 ops_genie_region: _builtins.str,
                 roles: Sequence[_builtins.str],
                 service_key: _builtins.str,
                 sms_enabled: _builtins.bool,
                 team_id: _builtins.str,
                 team_name: _builtins.str,
                 type_name: _builtins.str,
                 username: _builtins.str,
                 victor_ops_api_key: _builtins.str,
                 victor_ops_routing_key: _builtins.str,
                 webhook_secret: _builtins.str,
                 webhook_url: _builtins.str):
        """
        :param _builtins.str api_token: Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param _builtins.str channel_name: Slack channel name. Required for the SLACK notifications type.
        :param _builtins.str datadog_api_key: Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        :param _builtins.str datadog_region: Region that indicates which API URL to use. See the `datadogRegion` field in the `notifications` request parameter of [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/api/doc/atlas-admin-api-v2/operation/operation-createalertconfiguration) for more details. The default Datadog region is US.
        :param _builtins.int delay_min: Number of minutes to wait after an alert condition is detected before sending out the first notification.
        :param _builtins.str email_address: Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        :param _builtins.bool email_enabled: Flag indicating email notifications should be sent. Atlas returns this value if `type_name` is set  to `ORG`, `GROUP`, or `USER`.
        :param _builtins.str integration_id: The ID of the associated integration, the credentials of which to use for requests.
        :param _builtins.int interval_min: Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5.
        :param _builtins.str microsoft_teams_webhook_url: Microsoft Teams channel incoming webhook URL. Required for the `MICROSOFT_TEAMS` notifications type.
        :param _builtins.str mobile_number: Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        :param _builtins.str notifier_id: The notifier ID is a system-generated unique identifier assigned to each notification method. This is needed when updating third-party notifications without requiring explicit authentication credentials.
        :param _builtins.str ops_genie_api_key: Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param _builtins.str ops_genie_region: Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        :param Sequence[_builtins.str] roles: Atlas role in current Project or Organization. Atlas returns this value if you set `type_name` to `ORG` or `GROUP`.
        :param _builtins.str service_key: PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param _builtins.bool sms_enabled: Flag indicating text notifications should be sent. Atlas returns this value if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        :param _builtins.str team_id: Unique identifier of a team.
        :param _builtins.str team_name: Label for the team that receives this notification.
        :param _builtins.str type_name: Type of alert notification.
               Accepted values are:
               - `DATADOG`
               - `EMAIL`
               - `GROUP` (Project)
               - `OPS_GENIE`
               - `ORG`
               - `PAGER_DUTY`
               - `SLACK`
               - `SMS`
               - `TEAM`
               - `USER`
               - `VICTOR_OPS`
               - `WEBHOOK`
               - `MICROSOFT_TEAMS`
        :param _builtins.str username: Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        :param _builtins.str victor_ops_api_key: VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param _builtins.str victor_ops_routing_key: VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param _builtins.str webhook_secret: Authentication secret for the `WEBHOOK` notifications type.
        :param _builtins.str webhook_url: Target URL  for the `WEBHOOK` notifications type.
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "channel_name", channel_name)
        pulumi.set(__self__, "datadog_api_key", datadog_api_key)
        pulumi.set(__self__, "datadog_region", datadog_region)
        pulumi.set(__self__, "delay_min", delay_min)
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "email_enabled", email_enabled)
        pulumi.set(__self__, "integration_id", integration_id)
        pulumi.set(__self__, "interval_min", interval_min)
        pulumi.set(__self__, "microsoft_teams_webhook_url", microsoft_teams_webhook_url)
        pulumi.set(__self__, "mobile_number", mobile_number)
        pulumi.set(__self__, "notifier_id", notifier_id)
        pulumi.set(__self__, "ops_genie_api_key", ops_genie_api_key)
        pulumi.set(__self__, "ops_genie_region", ops_genie_region)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "service_key", service_key)
        pulumi.set(__self__, "sms_enabled", sms_enabled)
        pulumi.set(__self__, "team_id", team_id)
        pulumi.set(__self__, "team_name", team_name)
        pulumi.set(__self__, "type_name", type_name)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "victor_ops_api_key", victor_ops_api_key)
        pulumi.set(__self__, "victor_ops_routing_key", victor_ops_routing_key)
        pulumi.set(__self__, "webhook_secret", webhook_secret)
        pulumi.set(__self__, "webhook_url", webhook_url)

    @_builtins.property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> _builtins.str:
        """
        Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "api_token")

    @_builtins.property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> _builtins.str:
        """
        Slack channel name. Required for the SLACK notifications type.
        """
        return pulumi.get(self, "channel_name")

    @_builtins.property
    @pulumi.getter(name="datadogApiKey")
    def datadog_api_key(self) -> _builtins.str:
        """
        Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        """
        return pulumi.get(self, "datadog_api_key")

    @_builtins.property
    @pulumi.getter(name="datadogRegion")
    def datadog_region(self) -> _builtins.str:
        """
        Region that indicates which API URL to use. See the `datadogRegion` field in the `notifications` request parameter of [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/api/doc/atlas-admin-api-v2/operation/operation-createalertconfiguration) for more details. The default Datadog region is US.
        """
        return pulumi.get(self, "datadog_region")

    @_builtins.property
    @pulumi.getter(name="delayMin")
    def delay_min(self) -> _builtins.int:
        """
        Number of minutes to wait after an alert condition is detected before sending out the first notification.
        """
        return pulumi.get(self, "delay_min")

    @_builtins.property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> _builtins.str:
        """
        Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        """
        return pulumi.get(self, "email_address")

    @_builtins.property
    @pulumi.getter(name="emailEnabled")
    def email_enabled(self) -> _builtins.bool:
        """
        Flag indicating email notifications should be sent. Atlas returns this value if `type_name` is set  to `ORG`, `GROUP`, or `USER`.
        """
        return pulumi.get(self, "email_enabled")

    @_builtins.property
    @pulumi.getter(name="integrationId")
    def integration_id(self) -> _builtins.str:
        """
        The ID of the associated integration, the credentials of which to use for requests.
        """
        return pulumi.get(self, "integration_id")

    @_builtins.property
    @pulumi.getter(name="intervalMin")
    def interval_min(self) -> _builtins.int:
        """
        Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5.
        """
        return pulumi.get(self, "interval_min")

    @_builtins.property
    @pulumi.getter(name="microsoftTeamsWebhookUrl")
    def microsoft_teams_webhook_url(self) -> _builtins.str:
        """
        Microsoft Teams channel incoming webhook URL. Required for the `MICROSOFT_TEAMS` notifications type.
        """
        return pulumi.get(self, "microsoft_teams_webhook_url")

    @_builtins.property
    @pulumi.getter(name="mobileNumber")
    def mobile_number(self) -> _builtins.str:
        """
        Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        """
        return pulumi.get(self, "mobile_number")

    @_builtins.property
    @pulumi.getter(name="notifierId")
    def notifier_id(self) -> _builtins.str:
        """
        The notifier ID is a system-generated unique identifier assigned to each notification method. This is needed when updating third-party notifications without requiring explicit authentication credentials.
        """
        return pulumi.get(self, "notifier_id")

    @_builtins.property
    @pulumi.getter(name="opsGenieApiKey")
    def ops_genie_api_key(self) -> _builtins.str:
        """
        Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "ops_genie_api_key")

    @_builtins.property
    @pulumi.getter(name="opsGenieRegion")
    def ops_genie_region(self) -> _builtins.str:
        """
        Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        """
        return pulumi.get(self, "ops_genie_region")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Sequence[_builtins.str]:
        """
        Atlas role in current Project or Organization. Atlas returns this value if you set `type_name` to `ORG` or `GROUP`.
        """
        return pulumi.get(self, "roles")

    @_builtins.property
    @pulumi.getter(name="serviceKey")
    def service_key(self) -> _builtins.str:
        """
        PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "service_key")

    @_builtins.property
    @pulumi.getter(name="smsEnabled")
    def sms_enabled(self) -> _builtins.bool:
        """
        Flag indicating text notifications should be sent. Atlas returns this value if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        """
        return pulumi.get(self, "sms_enabled")

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> _builtins.str:
        """
        Unique identifier of a team.
        """
        return pulumi.get(self, "team_id")

    @_builtins.property
    @pulumi.getter(name="teamName")
    def team_name(self) -> _builtins.str:
        """
        Label for the team that receives this notification.
        """
        return pulumi.get(self, "team_name")

    @_builtins.property
    @pulumi.getter(name="typeName")
    def type_name(self) -> _builtins.str:
        """
        Type of alert notification.
        Accepted values are:
        - `DATADOG`
        - `EMAIL`
        - `GROUP` (Project)
        - `OPS_GENIE`
        - `ORG`
        - `PAGER_DUTY`
        - `SLACK`
        - `SMS`
        - `TEAM`
        - `USER`
        - `VICTOR_OPS`
        - `WEBHOOK`
        - `MICROSOFT_TEAMS`
        """
        return pulumi.get(self, "type_name")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="victorOpsApiKey")
    def victor_ops_api_key(self) -> _builtins.str:
        """
        VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "victor_ops_api_key")

    @_builtins.property
    @pulumi.getter(name="victorOpsRoutingKey")
    def victor_ops_routing_key(self) -> _builtins.str:
        """
        VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "victor_ops_routing_key")

    @_builtins.property
    @pulumi.getter(name="webhookSecret")
    def webhook_secret(self) -> _builtins.str:
        """
        Authentication secret for the `WEBHOOK` notifications type.
        """
        return pulumi.get(self, "webhook_secret")

    @_builtins.property
    @pulumi.getter(name="webhookUrl")
    def webhook_url(self) -> _builtins.str:
        """
        Target URL  for the `WEBHOOK` notifications type.
        """
        return pulumi.get(self, "webhook_url")


@pulumi.output_type
class GetAlertConfigurationsResultOutputResult(dict):
    def __init__(__self__, *,
                 label: _builtins.str,
                 type: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str value: Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
               - `PRIMARY`
               - `SECONDARY`
               - `STANDALONE`
               - `CONFIG`
               - `MONGOS`
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def label(self) -> _builtins.str:
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
        - `PRIMARY`
        - `SECONDARY`
        - `STANDALONE`
        - `CONFIG`
        - `MONGOS`
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAlertConfigurationsResultThresholdConfigResult(dict):
    def __init__(__self__, *,
                 operator: _builtins.str,
                 threshold: _builtins.float,
                 units: _builtins.str):
        """
        :param _builtins.str operator: The operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
               - `GREATER_THAN`
               - `LESS_THAN`
        :param _builtins.float threshold: Threshold value outside of which an alert will be triggered.
        :param _builtins.str units: The units for the threshold value. Depends on the type of metric.
               Refer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "units", units)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        - `GREATER_THAN`
        - `LESS_THAN`
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> _builtins.float:
        """
        Threshold value outside of which an alert will be triggered.
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def units(self) -> _builtins.str:
        """
        The units for the threshold value. Depends on the type of metric.
        Refer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.
        """
        return pulumi.get(self, "units")


@pulumi.output_type
class GetApiKeyProjectAssignmentsResultResult(dict):
    def __init__(__self__, *,
                 api_key_id: _builtins.str,
                 project_id: _builtins.str,
                 roles: Sequence[_builtins.str]):
        """
        :param _builtins.str api_key_id: Unique 24-hexadecimal digit string that identifies this organization API key that you want to assign to one project.
        :param _builtins.str project_id: Unique 24-hexadecimal digit string that identifies your project. Use the /groups endpoint to retrieve all projects to which the authenticated user has access.
        :param Sequence[_builtins.str] roles: Human-readable label that identifies the collection of privileges that MongoDB Cloud grants a specific API key, MongoDB Cloud user, or MongoDB Cloud team. These roles include only the specific project-level roles.
        """
        pulumi.set(__self__, "api_key_id", api_key_id)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "roles", roles)

    @_builtins.property
    @pulumi.getter(name="apiKeyId")
    def api_key_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies this organization API key that you want to assign to one project.
        """
        return pulumi.get(self, "api_key_id")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies your project. Use the /groups endpoint to retrieve all projects to which the authenticated user has access.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Sequence[_builtins.str]:
        """
        Human-readable label that identifies the collection of privileges that MongoDB Cloud grants a specific API key, MongoDB Cloud user, or MongoDB Cloud team. These roles include only the specific project-level roles.
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class GetApiKeysResultResult(dict):
    def __init__(__self__, *,
                 api_key_id: _builtins.str,
                 description: _builtins.str,
                 public_key: _builtins.str,
                 role_names: Sequence[_builtins.str]):
        """
        :param _builtins.str api_key_id: Unique identifier for the API key you want to update. Use the /orgs/{ORG-ID}/apiKeys endpoint to retrieve all API keys to which the authenticated user has access for the specified organization.
        :param _builtins.str description: Description of this Organization API key.
        :param Sequence[_builtins.str] role_names: Name of the role. This resource returns all the roles the user has in Atlas.
               
               The following are valid roles:
               * `ORG_OWNER`
               * `ORG_GROUP_CREATOR`
               * `ORG_BILLING_ADMIN`
               * `ORG_READ_ONLY`
               * `ORG_MEMBER`
               
               See [MongoDB Atlas API - Return All Organization API Keys](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Programmatic-API-Keys/operation/listApiKeys) - Documentation for more information.
        """
        pulumi.set(__self__, "api_key_id", api_key_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "public_key", public_key)
        pulumi.set(__self__, "role_names", role_names)

    @_builtins.property
    @pulumi.getter(name="apiKeyId")
    def api_key_id(self) -> _builtins.str:
        """
        Unique identifier for the API key you want to update. Use the /orgs/{ORG-ID}/apiKeys endpoint to retrieve all API keys to which the authenticated user has access for the specified organization.
        """
        return pulumi.get(self, "api_key_id")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of this Organization API key.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> _builtins.str:
        return pulumi.get(self, "public_key")

    @_builtins.property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[_builtins.str]:
        """
        Name of the role. This resource returns all the roles the user has in Atlas.

        The following are valid roles:
        * `ORG_OWNER`
        * `ORG_GROUP_CREATOR`
        * `ORG_BILLING_ADMIN`
        * `ORG_READ_ONLY`
        * `ORG_MEMBER`

        See [MongoDB Atlas API - Return All Organization API Keys](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Programmatic-API-Keys/operation/listApiKeys) - Documentation for more information.
        """
        return pulumi.get(self, "role_names")


@pulumi.output_type
class GetAtlasUserLinkResult(dict):
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        return pulumi.get(self, "href")

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetAtlasUserRoleResult(dict):
    def __init__(__self__, *,
                 group_id: _builtins.str,
                 org_id: _builtins.str,
                 role_name: _builtins.str):
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "role_name", role_name)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.str:
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter(name="roleName")
    def role_name(self) -> _builtins.str:
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetAtlasUsersResultResult(dict):
    def __init__(__self__, *,
                 country: _builtins.str,
                 created_at: _builtins.str,
                 email_address: _builtins.str,
                 first_name: _builtins.str,
                 id: _builtins.str,
                 last_auth: _builtins.str,
                 last_name: _builtins.str,
                 links: Sequence['outputs.GetAtlasUsersResultLinkResult'],
                 mobile_number: _builtins.str,
                 roles: Sequence['outputs.GetAtlasUsersResultRoleResult'],
                 team_ids: Sequence[_builtins.str],
                 user_id: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str country: Two alphabet characters that identifies MongoDB Cloud user's geographic location. This parameter uses the ISO 3166-1a2 code format.
        :param _builtins.str created_at: Date and time when the current account is created. This value is in the ISO 8601 timestamp format in UTC.
        :param _builtins.str email_address: **(DEPRECATED)** Email address that belongs to the MongoDB Atlas user. This attribute is deprecated and will be removed in the next major release. Please transition to `data.mongodbatlas_organization.users.username`, `data.mongodbatlas_team.users.username` or `data.mongodbatlas_project.users.username` attributes. For more details, see Migration Guide: Migrate off deprecated `get_atlas_user` and `get_atlas_users`."
        :param _builtins.str first_name: First or given name that belongs to the MongoDB Atlas user.
        :param _builtins.str last_auth: Date and time when the current account last authenticated. This value is in the ISO 8601 timestamp format in UTC.
        :param _builtins.str last_name: Last name, family name, or surname that belongs to the MongoDB Atlas user.
        :param _builtins.str mobile_number: Mobile phone number that belongs to the MongoDB Atlas user.
        :param Sequence[_builtins.str] team_ids: List of unique 24-hexadecimal digit strings that identifies the teams to which this MongoDB Atlas user belongs.
               * `links.#.href` - Uniform Resource Locator (URL) that points another API resource to which this response has some relationship. This URL often begins with https://cloud.mongodb.com/api/atlas.
               * `links.#.rel` - Uniform Resource Locator (URL) that defines the semantic relationship between this resource and another API resource. This URL often begins with https://cloud.mongodb.com/api/atlas.
               * `roles.#.group_id` - Unique 24-hexadecimal digit string that identifies the project to which this role belongs. You can set a value for this parameter or orgId but not both in the same request.
               * `roles.#.org_id` - Unique 24-hexadecimal digit string that identifies the organization to which this role belongs. You can set a value for this parameter or groupId but not both in the same request.
               * `roles.#.role_name` - Human-readable label that identifies the collection of privileges that MongoDB Atlas grants a specific API key, user, or team. These roles include organization- and project-level roles. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#service-user-roles) describes the valid roles that can be assigned.
        :param _builtins.str user_id: Unique 24-hexadecimal digit string that identifies this user.
        :param _builtins.str username: Email address that belongs to the MongoDB Atlas user account. You cannot modify this address after creating the user.
        """
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_auth", last_auth)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "links", links)
        pulumi.set(__self__, "mobile_number", mobile_number)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "team_ids", team_ids)
        pulumi.set(__self__, "user_id", user_id)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def country(self) -> _builtins.str:
        """
        Two alphabet characters that identifies MongoDB Cloud user's geographic location. This parameter uses the ISO 3166-1a2 code format.
        """
        return pulumi.get(self, "country")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Date and time when the current account is created. This value is in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="emailAddress")
    @_utilities.deprecated("""This attribute is deprecated and will be removed in the next major release. Please transition to `data.mongodbatlas_organization.users.username, data.mongodbatlas_team.users.username or data.mongodbatlas_project.users.username attributes`. For more details, see https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/atlas-user-management.""")
    def email_address(self) -> _builtins.str:
        """
        **(DEPRECATED)** Email address that belongs to the MongoDB Atlas user. This attribute is deprecated and will be removed in the next major release. Please transition to `data.mongodbatlas_organization.users.username`, `data.mongodbatlas_team.users.username` or `data.mongodbatlas_project.users.username` attributes. For more details, see Migration Guide: Migrate off deprecated `get_atlas_user` and `get_atlas_users`."
        """
        return pulumi.get(self, "email_address")

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> _builtins.str:
        """
        First or given name that belongs to the MongoDB Atlas user.
        """
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lastAuth")
    def last_auth(self) -> _builtins.str:
        """
        Date and time when the current account last authenticated. This value is in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "last_auth")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> _builtins.str:
        """
        Last name, family name, or surname that belongs to the MongoDB Atlas user.
        """
        return pulumi.get(self, "last_name")

    @_builtins.property
    @pulumi.getter
    def links(self) -> Sequence['outputs.GetAtlasUsersResultLinkResult']:
        return pulumi.get(self, "links")

    @_builtins.property
    @pulumi.getter(name="mobileNumber")
    def mobile_number(self) -> _builtins.str:
        """
        Mobile phone number that belongs to the MongoDB Atlas user.
        """
        return pulumi.get(self, "mobile_number")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Sequence['outputs.GetAtlasUsersResultRoleResult']:
        return pulumi.get(self, "roles")

    @_builtins.property
    @pulumi.getter(name="teamIds")
    def team_ids(self) -> Sequence[_builtins.str]:
        """
        List of unique 24-hexadecimal digit strings that identifies the teams to which this MongoDB Atlas user belongs.
        * `links.#.href` - Uniform Resource Locator (URL) that points another API resource to which this response has some relationship. This URL often begins with https://cloud.mongodb.com/api/atlas.
        * `links.#.rel` - Uniform Resource Locator (URL) that defines the semantic relationship between this resource and another API resource. This URL often begins with https://cloud.mongodb.com/api/atlas.
        * `roles.#.group_id` - Unique 24-hexadecimal digit string that identifies the project to which this role belongs. You can set a value for this parameter or orgId but not both in the same request.
        * `roles.#.org_id` - Unique 24-hexadecimal digit string that identifies the organization to which this role belongs. You can set a value for this parameter or groupId but not both in the same request.
        * `roles.#.role_name` - Human-readable label that identifies the collection of privileges that MongoDB Atlas grants a specific API key, user, or team. These roles include organization- and project-level roles. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#service-user-roles) describes the valid roles that can be assigned.
        """
        return pulumi.get(self, "team_ids")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies this user.
        """
        return pulumi.get(self, "user_id")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Email address that belongs to the MongoDB Atlas user account. You cannot modify this address after creating the user.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetAtlasUsersResultLinkResult(dict):
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        return pulumi.get(self, "href")

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetAtlasUsersResultRoleResult(dict):
    def __init__(__self__, *,
                 group_id: _builtins.str,
                 org_id: _builtins.str,
                 role_name: _builtins.str):
        """
        :param _builtins.str org_id: Unique 24-hexadecimal digit string that identifies the organization whose users you want to return. Also needed when `team_id` attributes is defined.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "role_name", role_name)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.str:
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the organization whose users you want to return. Also needed when `team_id` attributes is defined.
        """
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter(name="roleName")
    def role_name(self) -> _builtins.str:
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetBackupCompliancePolicyOnDemandPolicyItemResult(dict):
    def __init__(__self__, *,
                 frequency_interval: _builtins.int,
                 frequency_type: _builtins.str,
                 id: _builtins.str,
                 retention_unit: _builtins.str,
                 retention_value: _builtins.int):
        """
        :param _builtins.int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param _builtins.str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param _builtins.str id: Unique identifier of the backup policy item.
        :param _builtins.str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param _builtins.int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @_builtins.property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> _builtins.int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @_builtins.property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> _builtins.str:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> _builtins.str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @_builtins.property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> _builtins.int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetBackupCompliancePolicyPolicyItemDailyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: _builtins.int,
                 frequency_type: _builtins.str,
                 id: _builtins.str,
                 retention_unit: _builtins.str,
                 retention_value: _builtins.int):
        """
        :param _builtins.int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param _builtins.str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param _builtins.str id: Unique identifier of the backup policy item.
        :param _builtins.str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param _builtins.int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @_builtins.property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> _builtins.int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @_builtins.property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> _builtins.str:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> _builtins.str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @_builtins.property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> _builtins.int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetBackupCompliancePolicyPolicyItemHourlyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: _builtins.int,
                 frequency_type: _builtins.str,
                 id: _builtins.str,
                 retention_unit: _builtins.str,
                 retention_value: _builtins.int):
        """
        :param _builtins.int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param _builtins.str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param _builtins.str id: Unique identifier of the backup policy item.
        :param _builtins.str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param _builtins.int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @_builtins.property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> _builtins.int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @_builtins.property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> _builtins.str:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> _builtins.str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @_builtins.property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> _builtins.int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetBackupCompliancePolicyPolicyItemMonthlyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: _builtins.int,
                 frequency_type: _builtins.str,
                 id: _builtins.str,
                 retention_unit: _builtins.str,
                 retention_value: _builtins.int):
        """
        :param _builtins.int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param _builtins.str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param _builtins.str id: Unique identifier of the backup policy item.
        :param _builtins.str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param _builtins.int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @_builtins.property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> _builtins.int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @_builtins.property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> _builtins.str:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> _builtins.str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @_builtins.property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> _builtins.int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetBackupCompliancePolicyPolicyItemWeeklyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: _builtins.int,
                 frequency_type: _builtins.str,
                 id: _builtins.str,
                 retention_unit: _builtins.str,
                 retention_value: _builtins.int):
        """
        :param _builtins.int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param _builtins.str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param _builtins.str id: Unique identifier of the backup policy item.
        :param _builtins.str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param _builtins.int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @_builtins.property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> _builtins.int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @_builtins.property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> _builtins.str:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> _builtins.str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @_builtins.property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> _builtins.int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetBackupCompliancePolicyPolicyItemYearlyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: _builtins.int,
                 frequency_type: _builtins.str,
                 id: _builtins.str,
                 retention_unit: _builtins.str,
                 retention_value: _builtins.int):
        """
        :param _builtins.int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param _builtins.str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param _builtins.str id: Unique identifier of the backup policy item.
        :param _builtins.str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param _builtins.int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @_builtins.property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> _builtins.int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @_builtins.property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> _builtins.str:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> _builtins.str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @_builtins.property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> _builtins.int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetCloudBackupScheduleCopySettingResult(dict):
    def __init__(__self__, *,
                 cloud_provider: _builtins.str,
                 frequencies: Sequence[_builtins.str],
                 region_name: _builtins.str,
                 should_copy_oplogs: _builtins.bool,
                 zone_id: _builtins.str):
        """
        :param _builtins.str cloud_provider: Human-readable label that identifies the cloud provider that stores the snapshot copy. i.e. "AWS" "AZURE" "GCP"
        :param Sequence[_builtins.str] frequencies: List that describes which types of snapshots to copy. i.e. "HOURLY" "DAILY" "WEEKLY" "MONTHLY" "YEARLY" "ON_DEMAND"
        :param _builtins.str region_name: Target region to copy snapshots belonging to replicationSpecId to. Please supply the 'Atlas Region' which can be found under https://www.mongodb.com/docs/atlas/reference/cloud-providers/ 'regions' link
        :param _builtins.bool should_copy_oplogs: Flag that indicates whether to copy the oplogs to the target region. You can use the oplogs to perform point-in-time restores.
        :param _builtins.str zone_id: Unique 24-hexadecimal digit string that identifies the zone in a cluster. For global clusters, there can be multiple zones to choose from. For sharded clusters and replica set clusters, there is only one zone in the cluster.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "frequencies", frequencies)
        pulumi.set(__self__, "region_name", region_name)
        pulumi.set(__self__, "should_copy_oplogs", should_copy_oplogs)
        pulumi.set(__self__, "zone_id", zone_id)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> _builtins.str:
        """
        Human-readable label that identifies the cloud provider that stores the snapshot copy. i.e. "AWS" "AZURE" "GCP"
        """
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter
    def frequencies(self) -> Sequence[_builtins.str]:
        """
        List that describes which types of snapshots to copy. i.e. "HOURLY" "DAILY" "WEEKLY" "MONTHLY" "YEARLY" "ON_DEMAND"
        """
        return pulumi.get(self, "frequencies")

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> _builtins.str:
        """
        Target region to copy snapshots belonging to replicationSpecId to. Please supply the 'Atlas Region' which can be found under https://www.mongodb.com/docs/atlas/reference/cloud-providers/ 'regions' link
        """
        return pulumi.get(self, "region_name")

    @_builtins.property
    @pulumi.getter(name="shouldCopyOplogs")
    def should_copy_oplogs(self) -> _builtins.bool:
        """
        Flag that indicates whether to copy the oplogs to the target region. You can use the oplogs to perform point-in-time restores.
        """
        return pulumi.get(self, "should_copy_oplogs")

    @_builtins.property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the zone in a cluster. For global clusters, there can be multiple zones to choose from. For sharded clusters and replica set clusters, there is only one zone in the cluster.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetCloudBackupScheduleExportResult(dict):
    def __init__(__self__, *,
                 export_bucket_id: _builtins.str,
                 frequency_type: _builtins.str):
        """
        :param _builtins.str export_bucket_id: Unique identifier of the CloudBackupSnapshotExportBucket export_bucket_id value.
        :param _builtins.str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        pulumi.set(__self__, "export_bucket_id", export_bucket_id)
        pulumi.set(__self__, "frequency_type", frequency_type)

    @_builtins.property
    @pulumi.getter(name="exportBucketId")
    def export_bucket_id(self) -> _builtins.str:
        """
        Unique identifier of the CloudBackupSnapshotExportBucket export_bucket_id value.
        """
        return pulumi.get(self, "export_bucket_id")

    @_builtins.property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> _builtins.str:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")


@pulumi.output_type
class GetCloudBackupSchedulePolicyItemDailyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: _builtins.int,
                 frequency_type: _builtins.str,
                 id: _builtins.str,
                 retention_unit: _builtins.str,
                 retention_value: _builtins.int):
        """
        :param _builtins.int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param _builtins.str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param _builtins.str id: Unique identifier of the backup policy item.
        :param _builtins.str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param _builtins.int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @_builtins.property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> _builtins.int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @_builtins.property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> _builtins.str:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> _builtins.str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @_builtins.property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> _builtins.int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetCloudBackupSchedulePolicyItemHourlyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: _builtins.int,
                 frequency_type: _builtins.str,
                 id: _builtins.str,
                 retention_unit: _builtins.str,
                 retention_value: _builtins.int):
        """
        :param _builtins.int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param _builtins.str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param _builtins.str id: Unique identifier of the backup policy item.
        :param _builtins.str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param _builtins.int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @_builtins.property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> _builtins.int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @_builtins.property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> _builtins.str:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> _builtins.str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @_builtins.property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> _builtins.int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetCloudBackupSchedulePolicyItemMonthlyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: _builtins.int,
                 frequency_type: _builtins.str,
                 id: _builtins.str,
                 retention_unit: _builtins.str,
                 retention_value: _builtins.int):
        """
        :param _builtins.int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param _builtins.str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param _builtins.str id: Unique identifier of the backup policy item.
        :param _builtins.str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param _builtins.int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @_builtins.property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> _builtins.int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @_builtins.property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> _builtins.str:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> _builtins.str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @_builtins.property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> _builtins.int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetCloudBackupSchedulePolicyItemWeeklyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: _builtins.int,
                 frequency_type: _builtins.str,
                 id: _builtins.str,
                 retention_unit: _builtins.str,
                 retention_value: _builtins.int):
        """
        :param _builtins.int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param _builtins.str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param _builtins.str id: Unique identifier of the backup policy item.
        :param _builtins.str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param _builtins.int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @_builtins.property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> _builtins.int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @_builtins.property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> _builtins.str:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> _builtins.str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @_builtins.property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> _builtins.int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetCloudBackupSchedulePolicyItemYearlyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: _builtins.int,
                 frequency_type: _builtins.str,
                 id: _builtins.str,
                 retention_unit: _builtins.str,
                 retention_value: _builtins.int):
        """
        :param _builtins.int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param _builtins.str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param _builtins.str id: Unique identifier of the backup policy item.
        :param _builtins.str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param _builtins.int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @_builtins.property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> _builtins.int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @_builtins.property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> _builtins.str:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> _builtins.str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @_builtins.property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> _builtins.int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetCloudBackupSnapshotExportBucketsResultResult(dict):
    def __init__(__self__, *,
                 bucket_name: _builtins.str,
                 cloud_provider: _builtins.str,
                 export_bucket_id: _builtins.str,
                 iam_role_id: _builtins.str,
                 role_id: _builtins.str,
                 service_url: _builtins.str,
                 tenant_id: _builtins.str):
        """
        :param _builtins.str bucket_name: Name of the bucket that the provided role ID is authorized to access.
        :param _builtins.str cloud_provider: Name of the provider of the cloud service where Atlas can access the S3 bucket.
        :param _builtins.str export_bucket_id: Unique identifier of the snapshot bucket id.
        :param _builtins.str iam_role_id: Unique identifier of the role that Atlas can use to access the bucket.
        :param _builtins.str role_id: Unique identifier of the Azure Service Principal that Atlas can use to access the Azure Blob Storage Container.
        :param _builtins.str service_url: URL that identifies the blob Endpoint of the Azure Blob Storage Account.
        :param _builtins.str tenant_id: UUID that identifies the Azure Active Directory Tenant ID.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "export_bucket_id", export_bucket_id)
        pulumi.set(__self__, "iam_role_id", iam_role_id)
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "service_url", service_url)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        """
        Name of the bucket that the provided role ID is authorized to access.
        """
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> _builtins.str:
        """
        Name of the provider of the cloud service where Atlas can access the S3 bucket.
        """
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter(name="exportBucketId")
    def export_bucket_id(self) -> _builtins.str:
        """
        Unique identifier of the snapshot bucket id.
        """
        return pulumi.get(self, "export_bucket_id")

    @_builtins.property
    @pulumi.getter(name="iamRoleId")
    def iam_role_id(self) -> _builtins.str:
        """
        Unique identifier of the role that Atlas can use to access the bucket.
        """
        return pulumi.get(self, "iam_role_id")

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> _builtins.str:
        """
        Unique identifier of the Azure Service Principal that Atlas can use to access the Azure Blob Storage Container.
        """
        return pulumi.get(self, "role_id")

    @_builtins.property
    @pulumi.getter(name="serviceUrl")
    def service_url(self) -> _builtins.str:
        """
        URL that identifies the blob Endpoint of the Azure Blob Storage Account.
        """
        return pulumi.get(self, "service_url")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    @_utilities.deprecated("""This parameter is deprecated.""")
    def tenant_id(self) -> _builtins.str:
        """
        UUID that identifies the Azure Active Directory Tenant ID.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetCloudBackupSnapshotExportJobComponentResult(dict):
    def __init__(__self__, *,
                 export_id: _builtins.str,
                 replica_set_name: _builtins.str):
        """
        :param _builtins.str export_id: _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        :param _builtins.str replica_set_name: _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
        pulumi.set(__self__, "export_id", export_id)
        pulumi.set(__self__, "replica_set_name", replica_set_name)

    @_builtins.property
    @pulumi.getter(name="exportId")
    def export_id(self) -> _builtins.str:
        """
        _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        """
        return pulumi.get(self, "export_id")

    @_builtins.property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> _builtins.str:
        """
        _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
        return pulumi.get(self, "replica_set_name")


@pulumi.output_type
class GetCloudBackupSnapshotExportJobCustomDataResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Custom data specified as key in the key and value pair.
        :param _builtins.str value: Value for the key specified using `key`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Custom data specified as key in the key and value pair.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value for the key specified using `key`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCloudBackupSnapshotExportJobsResultResult(dict):
    def __init__(__self__, *,
                 components: Sequence['outputs.GetCloudBackupSnapshotExportJobsResultComponentResult'],
                 created_at: _builtins.str,
                 custom_datas: Sequence['outputs.GetCloudBackupSnapshotExportJobsResultCustomDataResult'],
                 export_bucket_id: _builtins.str,
                 export_job_id: _builtins.str,
                 export_status_exported_collections: _builtins.int,
                 export_status_total_collections: _builtins.int,
                 finished_at: _builtins.str,
                 prefix: _builtins.str,
                 snapshot_id: _builtins.str,
                 state: _builtins.str):
        """
        :param Sequence['GetCloudBackupSnapshotExportJobsResultComponentArgs'] components: _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        :param _builtins.str created_at: Timestamp in ISO 8601 date and time format in UTC when the export job was created.
        :param Sequence['GetCloudBackupSnapshotExportJobsResultCustomDataArgs'] custom_datas: Custom data to include in the metadata file named `.complete` that Atlas uploads to the bucket when the export job finishes. Custom data can be specified as key and value pairs.
        :param _builtins.str export_bucket_id: Unique identifier of the AWS bucket to export the Cloud Backup snapshot to.
        :param _builtins.str export_job_id: Unique identifier of the export job.
               * `prefix ` - Full path on the cloud provider bucket to the folder where the snapshot is exported. The path is in the following format:`/exported_snapshots/{ORG-NAME}/{PROJECT-NAME}/{CLUSTER-NAME}/{SNAPSHOT-INITIATION-DATE}/{TIMESTAMP}`
        :param _builtins.str finished_at: Timestamp in ISO 8601 date and time format in UTC when the export job completes.
        :param _builtins.str snapshot_id: Unique identifier of the Cloud Backup snapshot to export.
        :param _builtins.str state: Status of the export job. Value can be one of the following:
               * `Queued` - indicates that the export job is queued
               * `InProgress` - indicates that the snapshot is being exported
               * `Successful` - indicates that the export job has completed successfully
               * `Failed` - indicates that the export job has failed
               * `Cancelled` - indicates that the export job has cancelled
        """
        pulumi.set(__self__, "components", components)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "custom_datas", custom_datas)
        pulumi.set(__self__, "export_bucket_id", export_bucket_id)
        pulumi.set(__self__, "export_job_id", export_job_id)
        pulumi.set(__self__, "export_status_exported_collections", export_status_exported_collections)
        pulumi.set(__self__, "export_status_total_collections", export_status_total_collections)
        pulumi.set(__self__, "finished_at", finished_at)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def components(self) -> Sequence['outputs.GetCloudBackupSnapshotExportJobsResultComponentResult']:
        """
        _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        """
        return pulumi.get(self, "components")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Timestamp in ISO 8601 date and time format in UTC when the export job was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="customDatas")
    def custom_datas(self) -> Sequence['outputs.GetCloudBackupSnapshotExportJobsResultCustomDataResult']:
        """
        Custom data to include in the metadata file named `.complete` that Atlas uploads to the bucket when the export job finishes. Custom data can be specified as key and value pairs.
        """
        return pulumi.get(self, "custom_datas")

    @_builtins.property
    @pulumi.getter(name="exportBucketId")
    def export_bucket_id(self) -> _builtins.str:
        """
        Unique identifier of the AWS bucket to export the Cloud Backup snapshot to.
        """
        return pulumi.get(self, "export_bucket_id")

    @_builtins.property
    @pulumi.getter(name="exportJobId")
    def export_job_id(self) -> _builtins.str:
        """
        Unique identifier of the export job.
        * `prefix ` - Full path on the cloud provider bucket to the folder where the snapshot is exported. The path is in the following format:`/exported_snapshots/{ORG-NAME}/{PROJECT-NAME}/{CLUSTER-NAME}/{SNAPSHOT-INITIATION-DATE}/{TIMESTAMP}`
        """
        return pulumi.get(self, "export_job_id")

    @_builtins.property
    @pulumi.getter(name="exportStatusExportedCollections")
    def export_status_exported_collections(self) -> _builtins.int:
        return pulumi.get(self, "export_status_exported_collections")

    @_builtins.property
    @pulumi.getter(name="exportStatusTotalCollections")
    def export_status_total_collections(self) -> _builtins.int:
        return pulumi.get(self, "export_status_total_collections")

    @_builtins.property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> _builtins.str:
        """
        Timestamp in ISO 8601 date and time format in UTC when the export job completes.
        """
        return pulumi.get(self, "finished_at")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> _builtins.str:
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> _builtins.str:
        """
        Unique identifier of the Cloud Backup snapshot to export.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        Status of the export job. Value can be one of the following:
        * `Queued` - indicates that the export job is queued
        * `InProgress` - indicates that the snapshot is being exported
        * `Successful` - indicates that the export job has completed successfully
        * `Failed` - indicates that the export job has failed
        * `Cancelled` - indicates that the export job has cancelled
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetCloudBackupSnapshotExportJobsResultComponentResult(dict):
    def __init__(__self__, *,
                 export_id: _builtins.str,
                 replica_set_name: _builtins.str):
        """
        :param _builtins.str export_id: _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        :param _builtins.str replica_set_name: _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
        pulumi.set(__self__, "export_id", export_id)
        pulumi.set(__self__, "replica_set_name", replica_set_name)

    @_builtins.property
    @pulumi.getter(name="exportId")
    def export_id(self) -> _builtins.str:
        """
        _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        """
        return pulumi.get(self, "export_id")

    @_builtins.property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> _builtins.str:
        """
        _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
        return pulumi.get(self, "replica_set_name")


@pulumi.output_type
class GetCloudBackupSnapshotExportJobsResultCustomDataResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Custom data specified as key in the key and value pair.
        :param _builtins.str value: Value for the key specified using `key`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Custom data specified as key in the key and value pair.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value for the key specified using `key`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCloudBackupSnapshotMemberResult(dict):
    def __init__(__self__, *,
                 cloud_provider: _builtins.str,
                 id: _builtins.str,
                 replica_set_name: _builtins.str):
        """
        :param _builtins.str cloud_provider: Cloud provider that stores this snapshot.
        :param _builtins.str id: Unique identifier for the sharded cluster snapshot.
        :param _builtins.str replica_set_name: Label given to a shard or config server from which Atlas took this snapshot.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "replica_set_name", replica_set_name)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> _builtins.str:
        """
        Cloud provider that stores this snapshot.
        """
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique identifier for the sharded cluster snapshot.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> _builtins.str:
        """
        Label given to a shard or config server from which Atlas took this snapshot.
        """
        return pulumi.get(self, "replica_set_name")


@pulumi.output_type
class GetCloudBackupSnapshotRestoreJobsResultResult(dict):
    def __init__(__self__, *,
                 cancelled: _builtins.bool,
                 delivery_type: _builtins.str,
                 delivery_urls: Sequence[_builtins.str],
                 expired: _builtins.bool,
                 expires_at: _builtins.str,
                 failed: _builtins.bool,
                 finished_at: _builtins.str,
                 id: _builtins.str,
                 oplog_inc: _builtins.int,
                 oplog_ts: _builtins.int,
                 point_in_time_utc_seconds: _builtins.int,
                 snapshot_id: _builtins.str,
                 target_cluster_name: _builtins.str,
                 target_project_id: _builtins.str,
                 timestamp: _builtins.str):
        """
        :param _builtins.bool cancelled: Indicates whether the restore job was canceled.
        :param _builtins.str delivery_type: Type of restore job to create. Possible values are: automated and download.
        :param Sequence[_builtins.str] delivery_urls: One or more URLs for the compressed snapshot files for manual download. Only visible if deliveryType is download.
        :param _builtins.bool expired: Indicates whether the restore job expired.
        :param _builtins.str expires_at: UTC ISO 8601 formatted point in time when the restore job expires.
        :param _builtins.bool failed: Indicates whether the restore job failed.
        :param _builtins.str finished_at: UTC ISO 8601 formatted point in time when the restore job completed.
        :param _builtins.str id: The unique identifier of the restore job.
        :param _builtins.str snapshot_id: Unique identifier of the source snapshot ID of the restore job.
        :param _builtins.str target_cluster_name: Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.
        :param _builtins.str target_project_id: Name of the target Atlas project of the restore job. Only visible if deliveryType is automated.
        :param _builtins.str timestamp: Timestamp in ISO 8601 date and time format in UTC when the snapshot associated to snapshotId was taken.
               * `oplogTs` - Timestamp in the number of seconds that have elapsed since the UNIX epoch.
               * `oplogInc` - Oplog operation number from which to you want to restore this snapshot.
               * `pointInTimeUTCSeconds` - Timestamp in the number of seconds that have elapsed since the UNIX epoch.
        """
        pulumi.set(__self__, "cancelled", cancelled)
        pulumi.set(__self__, "delivery_type", delivery_type)
        pulumi.set(__self__, "delivery_urls", delivery_urls)
        pulumi.set(__self__, "expired", expired)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "failed", failed)
        pulumi.set(__self__, "finished_at", finished_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "oplog_inc", oplog_inc)
        pulumi.set(__self__, "oplog_ts", oplog_ts)
        pulumi.set(__self__, "point_in_time_utc_seconds", point_in_time_utc_seconds)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "target_cluster_name", target_cluster_name)
        pulumi.set(__self__, "target_project_id", target_project_id)
        pulumi.set(__self__, "timestamp", timestamp)

    @_builtins.property
    @pulumi.getter
    def cancelled(self) -> _builtins.bool:
        """
        Indicates whether the restore job was canceled.
        """
        return pulumi.get(self, "cancelled")

    @_builtins.property
    @pulumi.getter(name="deliveryType")
    def delivery_type(self) -> _builtins.str:
        """
        Type of restore job to create. Possible values are: automated and download.
        """
        return pulumi.get(self, "delivery_type")

    @_builtins.property
    @pulumi.getter(name="deliveryUrls")
    def delivery_urls(self) -> Sequence[_builtins.str]:
        """
        One or more URLs for the compressed snapshot files for manual download. Only visible if deliveryType is download.
        """
        return pulumi.get(self, "delivery_urls")

    @_builtins.property
    @pulumi.getter
    def expired(self) -> _builtins.bool:
        """
        Indicates whether the restore job expired.
        """
        return pulumi.get(self, "expired")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> _builtins.str:
        """
        UTC ISO 8601 formatted point in time when the restore job expires.
        """
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter
    def failed(self) -> _builtins.bool:
        """
        Indicates whether the restore job failed.
        """
        return pulumi.get(self, "failed")

    @_builtins.property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> _builtins.str:
        """
        UTC ISO 8601 formatted point in time when the restore job completed.
        """
        return pulumi.get(self, "finished_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The unique identifier of the restore job.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="oplogInc")
    def oplog_inc(self) -> _builtins.int:
        return pulumi.get(self, "oplog_inc")

    @_builtins.property
    @pulumi.getter(name="oplogTs")
    def oplog_ts(self) -> _builtins.int:
        return pulumi.get(self, "oplog_ts")

    @_builtins.property
    @pulumi.getter(name="pointInTimeUtcSeconds")
    def point_in_time_utc_seconds(self) -> _builtins.int:
        return pulumi.get(self, "point_in_time_utc_seconds")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> _builtins.str:
        """
        Unique identifier of the source snapshot ID of the restore job.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter(name="targetClusterName")
    def target_cluster_name(self) -> _builtins.str:
        """
        Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.
        """
        return pulumi.get(self, "target_cluster_name")

    @_builtins.property
    @pulumi.getter(name="targetProjectId")
    def target_project_id(self) -> _builtins.str:
        """
        Name of the target Atlas project of the restore job. Only visible if deliveryType is automated.
        """
        return pulumi.get(self, "target_project_id")

    @_builtins.property
    @pulumi.getter
    def timestamp(self) -> _builtins.str:
        """
        Timestamp in ISO 8601 date and time format in UTC when the snapshot associated to snapshotId was taken.
        * `oplogTs` - Timestamp in the number of seconds that have elapsed since the UNIX epoch.
        * `oplogInc` - Oplog operation number from which to you want to restore this snapshot.
        * `pointInTimeUTCSeconds` - Timestamp in the number of seconds that have elapsed since the UNIX epoch.
        """
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class GetCloudBackupSnapshotsResultResult(dict):
    def __init__(__self__, *,
                 cloud_provider: _builtins.str,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 expires_at: _builtins.str,
                 id: _builtins.str,
                 master_key_uuid: _builtins.str,
                 members: Sequence['outputs.GetCloudBackupSnapshotsResultMemberResult'],
                 mongod_version: _builtins.str,
                 replica_set_name: _builtins.str,
                 snapshot_ids: Sequence[_builtins.str],
                 snapshot_type: _builtins.str,
                 status: _builtins.str,
                 storage_size_bytes: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.str cloud_provider: Cloud provider that stores this snapshot.
        :param _builtins.str created_at: UTC ISO 8601 formatted point in time when Atlas took the snapshot.
        :param _builtins.str description: UDescription of the snapshot. Only present for on-demand snapshots.
        :param _builtins.str expires_at: UTC ISO 8601 formatted point in time when Atlas will delete the snapshot.
        :param _builtins.str id: Unique identifier for the sharded cluster snapshot.
        :param _builtins.str master_key_uuid: Unique ID of the AWS KMS Customer Master Key used to encrypt the snapshot. Only visible for clusters using Encryption at Rest via Customer KMS.
        :param Sequence['GetCloudBackupSnapshotsResultMemberArgs'] members: Block of List of snapshots and the cloud provider where the snapshots are stored. See below
        :param _builtins.str mongod_version: Version of the MongoDB server.
        :param _builtins.str replica_set_name: Label given to a shard or config server from which Atlas took this snapshot.
        :param Sequence[_builtins.str] snapshot_ids: Unique identifiers of the snapshots created for the shards and config server for a sharded cluster.
        :param _builtins.str snapshot_type: Specified the type of snapshot. Valid values are onDemand and scheduled.
        :param _builtins.str status: Current status of the snapshot. One of the following values: queued, inProgress, completed, failed.
        :param _builtins.int storage_size_bytes: Specifies the size of the snapshot in bytes.
        :param _builtins.str type: Specifies the type of cluster: replicaSet or shardedCluster.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "master_key_uuid", master_key_uuid)
        pulumi.set(__self__, "members", members)
        pulumi.set(__self__, "mongod_version", mongod_version)
        pulumi.set(__self__, "replica_set_name", replica_set_name)
        pulumi.set(__self__, "snapshot_ids", snapshot_ids)
        pulumi.set(__self__, "snapshot_type", snapshot_type)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "storage_size_bytes", storage_size_bytes)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> _builtins.str:
        """
        Cloud provider that stores this snapshot.
        """
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        UTC ISO 8601 formatted point in time when Atlas took the snapshot.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        UDescription of the snapshot. Only present for on-demand snapshots.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> _builtins.str:
        """
        UTC ISO 8601 formatted point in time when Atlas will delete the snapshot.
        """
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique identifier for the sharded cluster snapshot.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="masterKeyUuid")
    def master_key_uuid(self) -> _builtins.str:
        """
        Unique ID of the AWS KMS Customer Master Key used to encrypt the snapshot. Only visible for clusters using Encryption at Rest via Customer KMS.
        """
        return pulumi.get(self, "master_key_uuid")

    @_builtins.property
    @pulumi.getter
    def members(self) -> Sequence['outputs.GetCloudBackupSnapshotsResultMemberResult']:
        """
        Block of List of snapshots and the cloud provider where the snapshots are stored. See below
        """
        return pulumi.get(self, "members")

    @_builtins.property
    @pulumi.getter(name="mongodVersion")
    def mongod_version(self) -> _builtins.str:
        """
        Version of the MongoDB server.
        """
        return pulumi.get(self, "mongod_version")

    @_builtins.property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> _builtins.str:
        """
        Label given to a shard or config server from which Atlas took this snapshot.
        """
        return pulumi.get(self, "replica_set_name")

    @_builtins.property
    @pulumi.getter(name="snapshotIds")
    def snapshot_ids(self) -> Sequence[_builtins.str]:
        """
        Unique identifiers of the snapshots created for the shards and config server for a sharded cluster.
        """
        return pulumi.get(self, "snapshot_ids")

    @_builtins.property
    @pulumi.getter(name="snapshotType")
    def snapshot_type(self) -> _builtins.str:
        """
        Specified the type of snapshot. Valid values are onDemand and scheduled.
        """
        return pulumi.get(self, "snapshot_type")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Current status of the snapshot. One of the following values: queued, inProgress, completed, failed.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="storageSizeBytes")
    def storage_size_bytes(self) -> _builtins.int:
        """
        Specifies the size of the snapshot in bytes.
        """
        return pulumi.get(self, "storage_size_bytes")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of cluster: replicaSet or shardedCluster.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetCloudBackupSnapshotsResultMemberResult(dict):
    def __init__(__self__, *,
                 cloud_provider: _builtins.str,
                 id: _builtins.str,
                 replica_set_name: _builtins.str):
        """
        :param _builtins.str cloud_provider: Cloud provider that stores this snapshot.
        :param _builtins.str id: Unique identifier for the sharded cluster snapshot.
        :param _builtins.str replica_set_name: Label given to a shard or config server from which Atlas took this snapshot.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "replica_set_name", replica_set_name)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> _builtins.str:
        """
        Cloud provider that stores this snapshot.
        """
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique identifier for the sharded cluster snapshot.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> _builtins.str:
        """
        Label given to a shard or config server from which Atlas took this snapshot.
        """
        return pulumi.get(self, "replica_set_name")


@pulumi.output_type
class GetCloudProviderAccessSetupAwsConfigResult(dict):
    def __init__(__self__, *,
                 atlas_assumed_role_external_id: _builtins.str,
                 atlas_aws_account_arn: _builtins.str):
        """
        :param _builtins.str atlas_assumed_role_external_id: Unique external ID Atlas uses when assuming the IAM role in your AWS account.
        :param _builtins.str atlas_aws_account_arn: ARN associated with the Atlas AWS account used to assume IAM roles in your AWS account.
        """
        pulumi.set(__self__, "atlas_assumed_role_external_id", atlas_assumed_role_external_id)
        pulumi.set(__self__, "atlas_aws_account_arn", atlas_aws_account_arn)

    @_builtins.property
    @pulumi.getter(name="atlasAssumedRoleExternalId")
    def atlas_assumed_role_external_id(self) -> _builtins.str:
        """
        Unique external ID Atlas uses when assuming the IAM role in your AWS account.
        """
        return pulumi.get(self, "atlas_assumed_role_external_id")

    @_builtins.property
    @pulumi.getter(name="atlasAwsAccountArn")
    def atlas_aws_account_arn(self) -> _builtins.str:
        """
        ARN associated with the Atlas AWS account used to assume IAM roles in your AWS account.
        """
        return pulumi.get(self, "atlas_aws_account_arn")


@pulumi.output_type
class GetCloudProviderAccessSetupAzureConfigResult(dict):
    def __init__(__self__, *,
                 atlas_azure_app_id: _builtins.str,
                 service_principal_id: _builtins.str,
                 tenant_id: _builtins.str):
        """
        :param _builtins.str atlas_azure_app_id: Azure Active Directory Application ID of Atlas.
        :param _builtins.str service_principal_id: UUID string that identifies the Azure Service Principal.
        :param _builtins.str tenant_id: UUID String that identifies the Azure Active Directory Tenant ID.
        """
        pulumi.set(__self__, "atlas_azure_app_id", atlas_azure_app_id)
        pulumi.set(__self__, "service_principal_id", service_principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="atlasAzureAppId")
    def atlas_azure_app_id(self) -> _builtins.str:
        """
        Azure Active Directory Application ID of Atlas.
        """
        return pulumi.get(self, "atlas_azure_app_id")

    @_builtins.property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> _builtins.str:
        """
        UUID string that identifies the Azure Service Principal.
        """
        return pulumi.get(self, "service_principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        UUID String that identifies the Azure Active Directory Tenant ID.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetCloudProviderAccessSetupGcpConfigResult(dict):
    def __init__(__self__, *,
                 service_account_for_atlas: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str service_account_for_atlas: The GCP service account email that Atlas uses.
        :param _builtins.str status: The status of the GCP cloud provider access setup. See [MongoDB Atlas API](https://www.mongodb.com/docs/api/doc/atlas-admin-api-v2/operation/operation-getgroupcloudprovideraccess#operation-getgroupcloudprovideraccess-200-body-application-vnd-atlas-2023-01-01-json-gcp-object-status).
        """
        pulumi.set(__self__, "service_account_for_atlas", service_account_for_atlas)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="serviceAccountForAtlas")
    def service_account_for_atlas(self) -> _builtins.str:
        """
        The GCP service account email that Atlas uses.
        """
        return pulumi.get(self, "service_account_for_atlas")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the GCP cloud provider access setup. See [MongoDB Atlas API](https://www.mongodb.com/docs/api/doc/atlas-admin-api-v2/operation/operation-getgroupcloudprovideraccess#operation-getgroupcloudprovideraccess-200-body-application-vnd-atlas-2023-01-01-json-gcp-object-status).
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetCloudUserOrgAssignmentRolesResult(dict):
    def __init__(__self__, *,
                 org_roles: Sequence[_builtins.str],
                 project_role_assignments: Sequence['outputs.GetCloudUserOrgAssignmentRolesProjectRoleAssignmentResult']):
        """
        :param Sequence[_builtins.str] org_roles: One or more organization level roles to assign the MongoDB Cloud user.
        :param Sequence['GetCloudUserOrgAssignmentRolesProjectRoleAssignmentArgs'] project_role_assignments: List of project level role assignments to assign the MongoDB Cloud user.
        """
        pulumi.set(__self__, "org_roles", org_roles)
        pulumi.set(__self__, "project_role_assignments", project_role_assignments)

    @_builtins.property
    @pulumi.getter(name="orgRoles")
    def org_roles(self) -> Sequence[_builtins.str]:
        """
        One or more organization level roles to assign the MongoDB Cloud user.
        """
        return pulumi.get(self, "org_roles")

    @_builtins.property
    @pulumi.getter(name="projectRoleAssignments")
    def project_role_assignments(self) -> Sequence['outputs.GetCloudUserOrgAssignmentRolesProjectRoleAssignmentResult']:
        """
        List of project level role assignments to assign the MongoDB Cloud user.
        """
        return pulumi.get(self, "project_role_assignments")


@pulumi.output_type
class GetCloudUserOrgAssignmentRolesProjectRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 project_id: _builtins.str,
                 project_roles: Sequence[_builtins.str]):
        """
        :param _builtins.str project_id: Unique 24-hexadecimal digit string that identifies the project to which these roles belong.
        :param Sequence[_builtins.str] project_roles: One or more project-level roles assigned to the MongoDB Cloud user.
        """
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "project_roles", project_roles)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the project to which these roles belong.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="projectRoles")
    def project_roles(self) -> Sequence[_builtins.str]:
        """
        One or more project-level roles assigned to the MongoDB Cloud user.
        """
        return pulumi.get(self, "project_roles")


@pulumi.output_type
class GetCloudUserTeamAssignmentRolesResult(dict):
    def __init__(__self__, *,
                 org_roles: Sequence[_builtins.str],
                 project_role_assignments: Sequence['outputs.GetCloudUserTeamAssignmentRolesProjectRoleAssignmentResult']):
        """
        :param Sequence[_builtins.str] org_roles: One or more organization level roles to assign the MongoDB Cloud user.
        :param Sequence['GetCloudUserTeamAssignmentRolesProjectRoleAssignmentArgs'] project_role_assignments: List of project level role assignments to assign the MongoDB Cloud user.
        """
        pulumi.set(__self__, "org_roles", org_roles)
        pulumi.set(__self__, "project_role_assignments", project_role_assignments)

    @_builtins.property
    @pulumi.getter(name="orgRoles")
    def org_roles(self) -> Sequence[_builtins.str]:
        """
        One or more organization level roles to assign the MongoDB Cloud user.
        """
        return pulumi.get(self, "org_roles")

    @_builtins.property
    @pulumi.getter(name="projectRoleAssignments")
    def project_role_assignments(self) -> Sequence['outputs.GetCloudUserTeamAssignmentRolesProjectRoleAssignmentResult']:
        """
        List of project level role assignments to assign the MongoDB Cloud user.
        """
        return pulumi.get(self, "project_role_assignments")


@pulumi.output_type
class GetCloudUserTeamAssignmentRolesProjectRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 project_id: _builtins.str,
                 project_roles: Sequence[_builtins.str]):
        """
        :param _builtins.str project_id: Unique 24-hexadecimal digit string that identifies the project to which these roles belong.
        :param Sequence[_builtins.str] project_roles: One or more project-level roles assigned to the MongoDB Cloud user.
        """
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "project_roles", project_roles)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the project to which these roles belong.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="projectRoles")
    def project_roles(self) -> Sequence[_builtins.str]:
        """
        One or more project-level roles assigned to the MongoDB Cloud user.
        """
        return pulumi.get(self, "project_roles")


@pulumi.output_type
class GetClusterAdvancedConfigurationResult(dict):
    def __init__(__self__, *,
                 change_stream_options_pre_and_post_images_expire_after_seconds: _builtins.int,
                 custom_openssl_cipher_config_tls12s: Sequence[_builtins.str],
                 default_max_time_ms: _builtins.int,
                 default_read_concern: _builtins.str,
                 default_write_concern: _builtins.str,
                 fail_index_key_too_long: _builtins.bool,
                 javascript_enabled: _builtins.bool,
                 minimum_enabled_tls_protocol: _builtins.str,
                 no_table_scan: _builtins.bool,
                 oplog_min_retention_hours: _builtins.float,
                 oplog_size_mb: _builtins.int,
                 sample_refresh_interval_bi_connector: _builtins.int,
                 sample_size_bi_connector: _builtins.int,
                 tls_cipher_config_mode: _builtins.str,
                 transaction_lifetime_limit_seconds: _builtins.int):
        """
        :param _builtins.int change_stream_options_pre_and_post_images_expire_after_seconds: (Optional) The minimum pre- and post-image retention time in seconds. This parameter is only supported for MongoDB version 6.0 and above. Defaults to `-1`(off).
        :param Sequence[_builtins.str] custom_openssl_cipher_config_tls12s: The custom OpenSSL cipher suite list for TLS 1.2. This field is only valid when `tls_cipher_config_mode` is set to `CUSTOM`.
        :param _builtins.str default_read_concern: [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. **(DEPRECATED)** MongoDB 6.0 and later clusters default to `local`. To use a custom read concern level, please refer to your driver documentation.
        :param _builtins.str default_write_concern: [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 6.0 clusters default to [majority](https://docs.mongodb.com/manual/reference/write-concern/).
        :param _builtins.bool fail_index_key_too_long: **(DEPRECATED)** When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        :param _builtins.bool javascript_enabled: When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        :param _builtins.str minimum_enabled_tls_protocol: Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections. Valid values are:
               - TLS1_2
               - TLS1_3
        :param _builtins.bool no_table_scan: When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        :param _builtins.float oplog_min_retention_hours: Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        :param _builtins.int oplog_size_mb: The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        :param _builtins.int sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param _builtins.int sample_size_bi_connector: Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param _builtins.str tls_cipher_config_mode: The TLS cipher suite configuration mode. Valid values include `CUSTOM` or `DEFAULT`. The `DEFAULT` mode uses the default cipher suites. The `CUSTOM` mode allows you to specify custom cipher suites for both TLS 1.2 and TLS 1.3.
        :param _builtins.int transaction_lifetime_limit_seconds: Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        pulumi.set(__self__, "change_stream_options_pre_and_post_images_expire_after_seconds", change_stream_options_pre_and_post_images_expire_after_seconds)
        pulumi.set(__self__, "custom_openssl_cipher_config_tls12s", custom_openssl_cipher_config_tls12s)
        pulumi.set(__self__, "default_max_time_ms", default_max_time_ms)
        pulumi.set(__self__, "default_read_concern", default_read_concern)
        pulumi.set(__self__, "default_write_concern", default_write_concern)
        pulumi.set(__self__, "fail_index_key_too_long", fail_index_key_too_long)
        pulumi.set(__self__, "javascript_enabled", javascript_enabled)
        pulumi.set(__self__, "minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        pulumi.set(__self__, "no_table_scan", no_table_scan)
        pulumi.set(__self__, "oplog_min_retention_hours", oplog_min_retention_hours)
        pulumi.set(__self__, "oplog_size_mb", oplog_size_mb)
        pulumi.set(__self__, "sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        pulumi.set(__self__, "sample_size_bi_connector", sample_size_bi_connector)
        pulumi.set(__self__, "tls_cipher_config_mode", tls_cipher_config_mode)
        pulumi.set(__self__, "transaction_lifetime_limit_seconds", transaction_lifetime_limit_seconds)

    @_builtins.property
    @pulumi.getter(name="changeStreamOptionsPreAndPostImagesExpireAfterSeconds")
    def change_stream_options_pre_and_post_images_expire_after_seconds(self) -> _builtins.int:
        """
        (Optional) The minimum pre- and post-image retention time in seconds. This parameter is only supported for MongoDB version 6.0 and above. Defaults to `-1`(off).
        """
        return pulumi.get(self, "change_stream_options_pre_and_post_images_expire_after_seconds")

    @_builtins.property
    @pulumi.getter(name="customOpensslCipherConfigTls12s")
    def custom_openssl_cipher_config_tls12s(self) -> Sequence[_builtins.str]:
        """
        The custom OpenSSL cipher suite list for TLS 1.2. This field is only valid when `tls_cipher_config_mode` is set to `CUSTOM`.
        """
        return pulumi.get(self, "custom_openssl_cipher_config_tls12s")

    @_builtins.property
    @pulumi.getter(name="defaultMaxTimeMs")
    def default_max_time_ms(self) -> _builtins.int:
        return pulumi.get(self, "default_max_time_ms")

    @_builtins.property
    @pulumi.getter(name="defaultReadConcern")
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide""")
    def default_read_concern(self) -> _builtins.str:
        """
        [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. **(DEPRECATED)** MongoDB 6.0 and later clusters default to `local`. To use a custom read concern level, please refer to your driver documentation.
        """
        return pulumi.get(self, "default_read_concern")

    @_builtins.property
    @pulumi.getter(name="defaultWriteConcern")
    def default_write_concern(self) -> _builtins.str:
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 6.0 clusters default to [majority](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        return pulumi.get(self, "default_write_concern")

    @_builtins.property
    @pulumi.getter(name="failIndexKeyTooLong")
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide""")
    def fail_index_key_too_long(self) -> _builtins.bool:
        """
        **(DEPRECATED)** When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        """
        return pulumi.get(self, "fail_index_key_too_long")

    @_builtins.property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> _builtins.bool:
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        return pulumi.get(self, "javascript_enabled")

    @_builtins.property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> _builtins.str:
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections. Valid values are:
        - TLS1_2
        - TLS1_3
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @_builtins.property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> _builtins.bool:
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        return pulumi.get(self, "no_table_scan")

    @_builtins.property
    @pulumi.getter(name="oplogMinRetentionHours")
    def oplog_min_retention_hours(self) -> _builtins.float:
        """
        Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        """
        return pulumi.get(self, "oplog_min_retention_hours")

    @_builtins.property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> _builtins.int:
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        return pulumi.get(self, "oplog_size_mb")

    @_builtins.property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> _builtins.int:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @_builtins.property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> _builtins.int:
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_size_bi_connector")

    @_builtins.property
    @pulumi.getter(name="tlsCipherConfigMode")
    def tls_cipher_config_mode(self) -> _builtins.str:
        """
        The TLS cipher suite configuration mode. Valid values include `CUSTOM` or `DEFAULT`. The `DEFAULT` mode uses the default cipher suites. The `CUSTOM` mode allows you to specify custom cipher suites for both TLS 1.2 and TLS 1.3.
        """
        return pulumi.get(self, "tls_cipher_config_mode")

    @_builtins.property
    @pulumi.getter(name="transactionLifetimeLimitSeconds")
    def transaction_lifetime_limit_seconds(self) -> _builtins.int:
        """
        Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        return pulumi.get(self, "transaction_lifetime_limit_seconds")


@pulumi.output_type
class GetClusterBiConnectorConfigResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 read_preference: _builtins.str):
        """
        :param _builtins.bool enabled: Indicates whether or not BI Connector for Atlas is enabled on the cluster.
        :param _builtins.str read_preference: Indicates the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "read_preference", read_preference)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Indicates whether or not BI Connector for Atlas is enabled on the cluster.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> _builtins.str:
        """
        Indicates the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        return pulumi.get(self, "read_preference")


@pulumi.output_type
class GetClusterConnectionStringResult(dict):
    def __init__(__self__, *,
                 aws_private_link: Mapping[str, _builtins.str],
                 aws_private_link_srv: Mapping[str, _builtins.str],
                 private: _builtins.str,
                 private_endpoints: Sequence['outputs.GetClusterConnectionStringPrivateEndpointResult'],
                 private_srv: _builtins.str,
                 standard: _builtins.str,
                 standard_srv: _builtins.str):
        pulumi.set(__self__, "aws_private_link", aws_private_link)
        pulumi.set(__self__, "aws_private_link_srv", aws_private_link_srv)
        pulumi.set(__self__, "private", private)
        pulumi.set(__self__, "private_endpoints", private_endpoints)
        pulumi.set(__self__, "private_srv", private_srv)
        pulumi.set(__self__, "standard", standard)
        pulumi.set(__self__, "standard_srv", standard_srv)

    @_builtins.property
    @pulumi.getter(name="awsPrivateLink")
    def aws_private_link(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "aws_private_link")

    @_builtins.property
    @pulumi.getter(name="awsPrivateLinkSrv")
    def aws_private_link_srv(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "aws_private_link_srv")

    @_builtins.property
    @pulumi.getter
    def private(self) -> _builtins.str:
        return pulumi.get(self, "private")

    @_builtins.property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Sequence['outputs.GetClusterConnectionStringPrivateEndpointResult']:
        return pulumi.get(self, "private_endpoints")

    @_builtins.property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> _builtins.str:
        return pulumi.get(self, "private_srv")

    @_builtins.property
    @pulumi.getter
    def standard(self) -> _builtins.str:
        return pulumi.get(self, "standard")

    @_builtins.property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> _builtins.str:
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class GetClusterConnectionStringPrivateEndpointResult(dict):
    def __init__(__self__, *,
                 connection_string: _builtins.str,
                 endpoints: Sequence['outputs.GetClusterConnectionStringPrivateEndpointEndpointResult'],
                 srv_connection_string: _builtins.str,
                 srv_shard_optimized_connection_string: _builtins.str,
                 type: _builtins.str):
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "srv_connection_string", srv_connection_string)
        pulumi.set(__self__, "srv_shard_optimized_connection_string", srv_shard_optimized_connection_string)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> _builtins.str:
        return pulumi.get(self, "connection_string")

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> Sequence['outputs.GetClusterConnectionStringPrivateEndpointEndpointResult']:
        return pulumi.get(self, "endpoints")

    @_builtins.property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> _builtins.str:
        return pulumi.get(self, "srv_connection_string")

    @_builtins.property
    @pulumi.getter(name="srvShardOptimizedConnectionString")
    def srv_shard_optimized_connection_string(self) -> _builtins.str:
        return pulumi.get(self, "srv_shard_optimized_connection_string")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetClusterConnectionStringPrivateEndpointEndpointResult(dict):
    def __init__(__self__, *,
                 endpoint_id: _builtins.str,
                 provider_name: _builtins.str,
                 region: _builtins.str):
        """
        :param _builtins.str provider_name: Indicates the cloud service provider on which the servers are provisioned.
        """
        pulumi.set(__self__, "endpoint_id", endpoint_id)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> _builtins.str:
        return pulumi.get(self, "endpoint_id")

    @_builtins.property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> _builtins.str:
        """
        Indicates the cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetClusterLabelResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: The key that you want to write.
        :param _builtins.str value: The value that you want to write.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterOutageSimulationOutageFilterResult(dict):
    def __init__(__self__, *,
                 cloud_provider: _builtins.str,
                 region_name: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str cloud_provider: The cloud provider of the region that undergoes the outage simulation. Following values are supported:
               * `AWS`
               * `GCP`
               * `AZURE`
        :param _builtins.str region_name: The Atlas name of the region undergoing an outage simulation.
        :param _builtins.str type: The type of cluster outage simulation. Following values are supported:
               * `REGION` (Simulates a cluster outage for a region)
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region_name", region_name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> _builtins.str:
        """
        The cloud provider of the region that undergoes the outage simulation. Following values are supported:
        * `AWS`
        * `GCP`
        * `AZURE`
        """
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> _builtins.str:
        """
        The Atlas name of the region undergoing an outage simulation.
        """
        return pulumi.get(self, "region_name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of cluster outage simulation. Following values are supported:
        * `REGION` (Simulates a cluster outage for a region)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetClusterPinnedFcvResult(dict):
    def __init__(__self__, *,
                 expiration_date: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str expiration_date: Expiration date of the fixed FCV. This value is in the ISO 8601 timestamp format (e.g. "2024-12-04T16:25:00Z").
        :param _builtins.str version: Feature compatibility version of the cluster.
        """
        pulumi.set(__self__, "expiration_date", expiration_date)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> _builtins.str:
        """
        Expiration date of the fixed FCV. This value is in the ISO 8601 timestamp format (e.g. "2024-12-04T16:25:00Z").
        """
        return pulumi.get(self, "expiration_date")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Feature compatibility version of the cluster.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetClusterReplicationSpecResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 num_shards: _builtins.int,
                 regions_configs: Sequence['outputs.GetClusterReplicationSpecRegionsConfigResult'],
                 zone_name: _builtins.str):
        """
        :param _builtins.str id: Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        :param _builtins.int num_shards: Number of shards to deploy in the specified zone.
        :param Sequence['GetClusterReplicationSpecRegionsConfigArgs'] regions_configs: Describes the physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        :param _builtins.str zone_name: Indicates the n ame for the zone in a Global Cluster.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "num_shards", num_shards)
        pulumi.set(__self__, "regions_configs", regions_configs)
        pulumi.set(__self__, "zone_name", zone_name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> _builtins.int:
        """
        Number of shards to deploy in the specified zone.
        """
        return pulumi.get(self, "num_shards")

    @_builtins.property
    @pulumi.getter(name="regionsConfigs")
    def regions_configs(self) -> Sequence['outputs.GetClusterReplicationSpecRegionsConfigResult']:
        """
        Describes the physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        """
        return pulumi.get(self, "regions_configs")

    @_builtins.property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> _builtins.str:
        """
        Indicates the n ame for the zone in a Global Cluster.
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class GetClusterReplicationSpecRegionsConfigResult(dict):
    def __init__(__self__, *,
                 analytics_nodes: _builtins.int,
                 electable_nodes: _builtins.int,
                 priority: _builtins.int,
                 read_only_nodes: _builtins.int,
                 region_name: _builtins.str):
        """
        :param _builtins.int analytics_nodes: Indicates the number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary.
        :param _builtins.int electable_nodes: Number of electable nodes for Atlas to deploy to the region.
        :param _builtins.int priority: Election priority of the region. For regions with only read-only nodes, set this value to 0.
        :param _builtins.int read_only_nodes: Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        :param _builtins.str region_name: Name for the region specified.
        """
        pulumi.set(__self__, "analytics_nodes", analytics_nodes)
        pulumi.set(__self__, "electable_nodes", electable_nodes)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "read_only_nodes", read_only_nodes)
        pulumi.set(__self__, "region_name", region_name)

    @_builtins.property
    @pulumi.getter(name="analyticsNodes")
    def analytics_nodes(self) -> _builtins.int:
        """
        Indicates the number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary.
        """
        return pulumi.get(self, "analytics_nodes")

    @_builtins.property
    @pulumi.getter(name="electableNodes")
    def electable_nodes(self) -> _builtins.int:
        """
        Number of electable nodes for Atlas to deploy to the region.
        """
        return pulumi.get(self, "electable_nodes")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        Election priority of the region. For regions with only read-only nodes, set this value to 0.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="readOnlyNodes")
    def read_only_nodes(self) -> _builtins.int:
        """
        Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        """
        return pulumi.get(self, "read_only_nodes")

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> _builtins.str:
        """
        Name for the region specified.
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class GetClusterSnapshotBackupPolicyResult(dict):
    def __init__(__self__, *,
                 cluster_id: _builtins.str,
                 cluster_name: _builtins.str,
                 next_snapshot: _builtins.str,
                 policies: Sequence['outputs.GetClusterSnapshotBackupPolicyPolicyResult'],
                 reference_hour_of_day: _builtins.int,
                 reference_minute_of_hour: _builtins.int,
                 restore_window_days: _builtins.int,
                 update_snapshots: _builtins.bool):
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "next_snapshot", next_snapshot)
        pulumi.set(__self__, "policies", policies)
        pulumi.set(__self__, "reference_hour_of_day", reference_hour_of_day)
        pulumi.set(__self__, "reference_minute_of_hour", reference_minute_of_hour)
        pulumi.set(__self__, "restore_window_days", restore_window_days)
        pulumi.set(__self__, "update_snapshots", update_snapshots)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> _builtins.str:
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> _builtins.str:
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="nextSnapshot")
    def next_snapshot(self) -> _builtins.str:
        return pulumi.get(self, "next_snapshot")

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Sequence['outputs.GetClusterSnapshotBackupPolicyPolicyResult']:
        return pulumi.get(self, "policies")

    @_builtins.property
    @pulumi.getter(name="referenceHourOfDay")
    def reference_hour_of_day(self) -> _builtins.int:
        return pulumi.get(self, "reference_hour_of_day")

    @_builtins.property
    @pulumi.getter(name="referenceMinuteOfHour")
    def reference_minute_of_hour(self) -> _builtins.int:
        return pulumi.get(self, "reference_minute_of_hour")

    @_builtins.property
    @pulumi.getter(name="restoreWindowDays")
    def restore_window_days(self) -> _builtins.int:
        return pulumi.get(self, "restore_window_days")

    @_builtins.property
    @pulumi.getter(name="updateSnapshots")
    def update_snapshots(self) -> _builtins.bool:
        return pulumi.get(self, "update_snapshots")


@pulumi.output_type
class GetClusterSnapshotBackupPolicyPolicyResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 policy_items: Sequence['outputs.GetClusterSnapshotBackupPolicyPolicyPolicyItemResult']):
        """
        :param _builtins.str id: Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "policy_items", policy_items)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="policyItems")
    def policy_items(self) -> Sequence['outputs.GetClusterSnapshotBackupPolicyPolicyPolicyItemResult']:
        return pulumi.get(self, "policy_items")


@pulumi.output_type
class GetClusterSnapshotBackupPolicyPolicyPolicyItemResult(dict):
    def __init__(__self__, *,
                 frequency_interval: _builtins.int,
                 frequency_type: _builtins.str,
                 id: _builtins.str,
                 retention_unit: _builtins.str,
                 retention_value: _builtins.int):
        """
        :param _builtins.str id: Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @_builtins.property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> _builtins.int:
        return pulumi.get(self, "frequency_interval")

    @_builtins.property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> _builtins.str:
        return pulumi.get(self, "frequency_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> _builtins.str:
        return pulumi.get(self, "retention_unit")

    @_builtins.property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> _builtins.int:
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetClusterTagResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: The key that you want to write.
        :param _builtins.str value: The value that you want to write.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClustersResultResult(dict):
    def __init__(__self__, *,
                 advanced_configurations: Sequence['outputs.GetClustersResultAdvancedConfigurationResult'],
                 auto_scaling_compute_enabled: _builtins.bool,
                 auto_scaling_compute_scale_down_enabled: _builtins.bool,
                 auto_scaling_disk_gb_enabled: _builtins.bool,
                 backing_provider_name: _builtins.str,
                 backup_enabled: _builtins.bool,
                 bi_connector_configs: Sequence['outputs.GetClustersResultBiConnectorConfigResult'],
                 cluster_type: _builtins.str,
                 connection_strings: Sequence['outputs.GetClustersResultConnectionStringResult'],
                 container_id: _builtins.str,
                 disk_size_gb: _builtins.float,
                 encryption_at_rest_provider: _builtins.str,
                 labels: Sequence['outputs.GetClustersResultLabelResult'],
                 mongo_db_major_version: _builtins.str,
                 mongo_db_version: _builtins.str,
                 mongo_uri: _builtins.str,
                 mongo_uri_updated: _builtins.str,
                 mongo_uri_with_options: _builtins.str,
                 name: _builtins.str,
                 num_shards: _builtins.int,
                 paused: _builtins.bool,
                 pinned_fcvs: Sequence['outputs.GetClustersResultPinnedFcvResult'],
                 pit_enabled: _builtins.bool,
                 provider_auto_scaling_compute_max_instance_size: _builtins.str,
                 provider_auto_scaling_compute_min_instance_size: _builtins.str,
                 provider_backup_enabled: _builtins.bool,
                 provider_disk_iops: _builtins.int,
                 provider_disk_type_name: _builtins.str,
                 provider_encrypt_ebs_volume: _builtins.bool,
                 provider_instance_size_name: _builtins.str,
                 provider_name: _builtins.str,
                 provider_region_name: _builtins.str,
                 provider_volume_type: _builtins.str,
                 redact_client_log_data: _builtins.bool,
                 replication_factor: _builtins.int,
                 replication_specs: Sequence['outputs.GetClustersResultReplicationSpecResult'],
                 snapshot_backup_policies: Sequence['outputs.GetClustersResultSnapshotBackupPolicyResult'],
                 srv_address: _builtins.str,
                 state_name: _builtins.str,
                 tags: Sequence['outputs.GetClustersResultTagResult'],
                 termination_protection_enabled: _builtins.bool,
                 version_release_system: _builtins.str):
        """
        :param Sequence['GetClustersResultAdvancedConfigurationArgs'] advanced_configurations: Get the advanced configuration options. See Advanced Configuration below for more details.
        :param _builtins.bool auto_scaling_compute_enabled: Specifies whether cluster tier auto-scaling is enabled. The default is false.
        :param _builtins.bool auto_scaling_compute_scale_down_enabled: * `auto_scaling_compute_scale_down_enabled` - Specifies whether cluster tier auto-down-scaling is enabled.
        :param _builtins.bool auto_scaling_disk_gb_enabled: Indicates whether disk auto-scaling is enabled.
        :param _builtins.str backing_provider_name: Indicates Cloud service provider on which the server for a multi-tenant cluster is provisioned.
        :param _builtins.bool backup_enabled: Legacy Option, Indicates whether Atlas continuous backups are enabled for the cluster.
        :param Sequence['GetClustersResultBiConnectorConfigArgs'] bi_connector_configs: Indicates BI Connector for Atlas configuration on this cluster. BI Connector for Atlas is only available for M10+ clusters. See BI Connector below for more details.
        :param _builtins.str cluster_type: Indicates the type of the cluster that you want to modify. You cannot convert a sharded cluster deployment to a replica set deployment.
        :param Sequence['GetClustersResultConnectionStringArgs'] connection_strings: Set of connection strings that your applications use to connect to this cluster. More information in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.
               - `connection_strings.#.standard` -   Public mongodb:// connection string for this cluster.
               - `connection_strings.#.standard_srv` - Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t, use connectionStrings.standard.
               - `connection_strings.#.private` -   [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
               - `connection_strings.#.private_srv` -  [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
               - `connection_strings.#.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
               - `connection_strings.#.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint.
               - `connection_strings.#.private_endpoint.#.srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint.
               - `connection_strings.#.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
               - `connection_strings.#.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.#.private_endpoint.#.connection_string` or `connection_strings.#.private_endpoint.#.srv_connection_string`
               - `connection_strings.#.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.
               - `connection_strings.#.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
               - `connection_strings.#.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.
        :param _builtins.str container_id: The Network Peering Container ID.
        :param _builtins.float disk_size_gb: Indicates the size in gigabytes of the server’s root volume (AWS/GCP Only).
        :param _builtins.str encryption_at_rest_provider: Indicates whether Encryption at Rest is enabled or disabled.
        :param Sequence['GetClustersResultLabelArgs'] labels: Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below. **DEPRECATED** Use `tags` instead.
        :param _builtins.str mongo_db_major_version: Indicates the version of the cluster to deploy.
        :param _builtins.str mongo_db_version: Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.
        :param _builtins.str mongo_uri: Base connection string for the cluster. Atlas only displays this field after the cluster is operational, not while it builds the cluster.
        :param _builtins.str mongo_uri_updated: Lists when the connection string was last updated. The connection string changes, for example, if you change a replica set to a sharded cluster.
        :param _builtins.str mongo_uri_with_options: Describes connection string for connecting to the Atlas cluster. Includes the replicaSet, ssl, and authSource query parameters in the connection string with values appropriate for the cluster.
        :param _builtins.str name: The name of the current plugin
        :param _builtins.int num_shards: Number of shards to deploy in the specified zone.
        :param _builtins.bool paused: Flag that indicates whether the cluster is paused or not.
        :param Sequence['GetClustersResultPinnedFcvArgs'] pinned_fcvs: The pinned Feature Compatibility Version (FCV) with its associated expiration date. See below.
        :param _builtins.bool pit_enabled: Flag that indicates if the cluster uses Continuous Cloud Backup.
        :param _builtins.str provider_auto_scaling_compute_max_instance_size: Maximum instance size to which your cluster can automatically scale.
        :param _builtins.str provider_auto_scaling_compute_min_instance_size: Minimum instance size to which your cluster can automatically scale.
        :param _builtins.bool provider_backup_enabled: Flag indicating if the cluster uses Cloud Backup Snapshots for backups. **DEPRECATED** Use `cloud_backup` instead.
        :param _builtins.int provider_disk_iops: Indicates the maximum input/output operations per second (IOPS) the system can perform. The possible values depend on the selected providerSettings.instanceSizeName and diskSizeGB.
        :param _builtins.str provider_disk_type_name: Describes Azure disk type of the server’s root volume (Azure Only).
        :param _builtins.bool provider_encrypt_ebs_volume: **(DEPRECATED)** Indicates whether the Amazon EBS encryption is enabled. This feature encrypts the server’s root volume for both data at rest within the volume and data moving between the volume and the instance. By default this attribute is always enabled, per deprecation process showing the real value at `provider_encrypt_ebs_volume_flag` computed attribute.
        :param _builtins.str provider_instance_size_name: Atlas provides different instance sizes, each with a default storage capacity and RAM size.
        :param _builtins.str provider_name: Indicates the cloud service provider on which the servers are provisioned.
        :param _builtins.str provider_region_name: Indicates Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases. Requires the Atlas Region name, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        :param _builtins.str provider_volume_type: Indicates the type of the volume. The possible values are: `STANDARD` and `PROVISIONED`.
               > **NOTE:** `STANDARD` is not available for NVME clusters.
        :param _builtins.bool redact_client_log_data: (Optional) Flag that enables or disables log redaction, see the [manual](https://www.mongodb.com/docs/manual/administration/monitoring/#log-redaction) for more information.
        :param _builtins.int replication_factor: (Deprecated) Number of replica set members. Each member keeps a copy of your databases, providing high availability and data redundancy. The possible values are 3, 5, or 7. The default value is 3.
        :param Sequence['GetClustersResultReplicationSpecArgs'] replication_specs: Configuration for cluster regions.  See Replication Spec below for more details.
        :param Sequence['GetClustersResultSnapshotBackupPolicyArgs'] snapshot_backup_policies: current snapshot schedule and retention settings for the cluster.
        :param _builtins.str srv_address: Connection string for connecting to the Atlas cluster. The +srv modifier forces the connection to use TLS/SSL. See the mongoURI for additional options.
        :param _builtins.str state_name: Indicates the current state of the cluster. The possible states are:
               - IDLE
               - CREATING
               - UPDATING
               - DELETING
               - DELETED
               - REPAIRING
        :param Sequence['GetClustersResultTagArgs'] tags: Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.
        :param _builtins.bool termination_protection_enabled: Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.
        :param _builtins.str version_release_system: Release cadence that Atlas uses for this cluster.
        """
        pulumi.set(__self__, "advanced_configurations", advanced_configurations)
        pulumi.set(__self__, "auto_scaling_compute_enabled", auto_scaling_compute_enabled)
        pulumi.set(__self__, "auto_scaling_compute_scale_down_enabled", auto_scaling_compute_scale_down_enabled)
        pulumi.set(__self__, "auto_scaling_disk_gb_enabled", auto_scaling_disk_gb_enabled)
        pulumi.set(__self__, "backing_provider_name", backing_provider_name)
        pulumi.set(__self__, "backup_enabled", backup_enabled)
        pulumi.set(__self__, "bi_connector_configs", bi_connector_configs)
        pulumi.set(__self__, "cluster_type", cluster_type)
        pulumi.set(__self__, "connection_strings", connection_strings)
        pulumi.set(__self__, "container_id", container_id)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "encryption_at_rest_provider", encryption_at_rest_provider)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "mongo_db_major_version", mongo_db_major_version)
        pulumi.set(__self__, "mongo_db_version", mongo_db_version)
        pulumi.set(__self__, "mongo_uri", mongo_uri)
        pulumi.set(__self__, "mongo_uri_updated", mongo_uri_updated)
        pulumi.set(__self__, "mongo_uri_with_options", mongo_uri_with_options)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "num_shards", num_shards)
        pulumi.set(__self__, "paused", paused)
        pulumi.set(__self__, "pinned_fcvs", pinned_fcvs)
        pulumi.set(__self__, "pit_enabled", pit_enabled)
        pulumi.set(__self__, "provider_auto_scaling_compute_max_instance_size", provider_auto_scaling_compute_max_instance_size)
        pulumi.set(__self__, "provider_auto_scaling_compute_min_instance_size", provider_auto_scaling_compute_min_instance_size)
        pulumi.set(__self__, "provider_backup_enabled", provider_backup_enabled)
        pulumi.set(__self__, "provider_disk_iops", provider_disk_iops)
        pulumi.set(__self__, "provider_disk_type_name", provider_disk_type_name)
        pulumi.set(__self__, "provider_encrypt_ebs_volume", provider_encrypt_ebs_volume)
        pulumi.set(__self__, "provider_instance_size_name", provider_instance_size_name)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "provider_region_name", provider_region_name)
        pulumi.set(__self__, "provider_volume_type", provider_volume_type)
        pulumi.set(__self__, "redact_client_log_data", redact_client_log_data)
        pulumi.set(__self__, "replication_factor", replication_factor)
        pulumi.set(__self__, "replication_specs", replication_specs)
        pulumi.set(__self__, "snapshot_backup_policies", snapshot_backup_policies)
        pulumi.set(__self__, "srv_address", srv_address)
        pulumi.set(__self__, "state_name", state_name)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "termination_protection_enabled", termination_protection_enabled)
        pulumi.set(__self__, "version_release_system", version_release_system)

    @_builtins.property
    @pulumi.getter(name="advancedConfigurations")
    def advanced_configurations(self) -> Sequence['outputs.GetClustersResultAdvancedConfigurationResult']:
        """
        Get the advanced configuration options. See Advanced Configuration below for more details.
        """
        return pulumi.get(self, "advanced_configurations")

    @_builtins.property
    @pulumi.getter(name="autoScalingComputeEnabled")
    def auto_scaling_compute_enabled(self) -> _builtins.bool:
        """
        Specifies whether cluster tier auto-scaling is enabled. The default is false.
        """
        return pulumi.get(self, "auto_scaling_compute_enabled")

    @_builtins.property
    @pulumi.getter(name="autoScalingComputeScaleDownEnabled")
    def auto_scaling_compute_scale_down_enabled(self) -> _builtins.bool:
        """
        * `auto_scaling_compute_scale_down_enabled` - Specifies whether cluster tier auto-down-scaling is enabled.
        """
        return pulumi.get(self, "auto_scaling_compute_scale_down_enabled")

    @_builtins.property
    @pulumi.getter(name="autoScalingDiskGbEnabled")
    def auto_scaling_disk_gb_enabled(self) -> _builtins.bool:
        """
        Indicates whether disk auto-scaling is enabled.
        """
        return pulumi.get(self, "auto_scaling_disk_gb_enabled")

    @_builtins.property
    @pulumi.getter(name="backingProviderName")
    def backing_provider_name(self) -> _builtins.str:
        """
        Indicates Cloud service provider on which the server for a multi-tenant cluster is provisioned.
        """
        return pulumi.get(self, "backing_provider_name")

    @_builtins.property
    @pulumi.getter(name="backupEnabled")
    def backup_enabled(self) -> _builtins.bool:
        """
        Legacy Option, Indicates whether Atlas continuous backups are enabled for the cluster.
        """
        return pulumi.get(self, "backup_enabled")

    @_builtins.property
    @pulumi.getter(name="biConnectorConfigs")
    def bi_connector_configs(self) -> Sequence['outputs.GetClustersResultBiConnectorConfigResult']:
        """
        Indicates BI Connector for Atlas configuration on this cluster. BI Connector for Atlas is only available for M10+ clusters. See BI Connector below for more details.
        """
        return pulumi.get(self, "bi_connector_configs")

    @_builtins.property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> _builtins.str:
        """
        Indicates the type of the cluster that you want to modify. You cannot convert a sharded cluster deployment to a replica set deployment.
        """
        return pulumi.get(self, "cluster_type")

    @_builtins.property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Sequence['outputs.GetClustersResultConnectionStringResult']:
        """
        Set of connection strings that your applications use to connect to this cluster. More information in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.
        - `connection_strings.#.standard` -   Public mongodb:// connection string for this cluster.
        - `connection_strings.#.standard_srv` - Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t, use connectionStrings.standard.
        - `connection_strings.#.private` -   [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        - `connection_strings.#.private_srv` -  [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        - `connection_strings.#.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
        - `connection_strings.#.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint.
        - `connection_strings.#.private_endpoint.#.srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint.
        - `connection_strings.#.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
        - `connection_strings.#.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.#.private_endpoint.#.connection_string` or `connection_strings.#.private_endpoint.#.srv_connection_string`
        - `connection_strings.#.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.
        - `connection_strings.#.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
        - `connection_strings.#.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.
        """
        return pulumi.get(self, "connection_strings")

    @_builtins.property
    @pulumi.getter(name="containerId")
    def container_id(self) -> _builtins.str:
        """
        The Network Peering Container ID.
        """
        return pulumi.get(self, "container_id")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> _builtins.float:
        """
        Indicates the size in gigabytes of the server’s root volume (AWS/GCP Only).
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="encryptionAtRestProvider")
    def encryption_at_rest_provider(self) -> _builtins.str:
        """
        Indicates whether Encryption at Rest is enabled or disabled.
        """
        return pulumi.get(self, "encryption_at_rest_provider")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetClustersResultLabelResult']:
        """
        Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below. **DEPRECATED** Use `tags` instead.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="mongoDbMajorVersion")
    def mongo_db_major_version(self) -> _builtins.str:
        """
        Indicates the version of the cluster to deploy.
        """
        return pulumi.get(self, "mongo_db_major_version")

    @_builtins.property
    @pulumi.getter(name="mongoDbVersion")
    def mongo_db_version(self) -> _builtins.str:
        """
        Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.
        """
        return pulumi.get(self, "mongo_db_version")

    @_builtins.property
    @pulumi.getter(name="mongoUri")
    def mongo_uri(self) -> _builtins.str:
        """
        Base connection string for the cluster. Atlas only displays this field after the cluster is operational, not while it builds the cluster.
        """
        return pulumi.get(self, "mongo_uri")

    @_builtins.property
    @pulumi.getter(name="mongoUriUpdated")
    def mongo_uri_updated(self) -> _builtins.str:
        """
        Lists when the connection string was last updated. The connection string changes, for example, if you change a replica set to a sharded cluster.
        """
        return pulumi.get(self, "mongo_uri_updated")

    @_builtins.property
    @pulumi.getter(name="mongoUriWithOptions")
    def mongo_uri_with_options(self) -> _builtins.str:
        """
        Describes connection string for connecting to the Atlas cluster. Includes the replicaSet, ssl, and authSource query parameters in the connection string with values appropriate for the cluster.
        """
        return pulumi.get(self, "mongo_uri_with_options")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the current plugin
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> _builtins.int:
        """
        Number of shards to deploy in the specified zone.
        """
        return pulumi.get(self, "num_shards")

    @_builtins.property
    @pulumi.getter
    def paused(self) -> _builtins.bool:
        """
        Flag that indicates whether the cluster is paused or not.
        """
        return pulumi.get(self, "paused")

    @_builtins.property
    @pulumi.getter(name="pinnedFcvs")
    def pinned_fcvs(self) -> Sequence['outputs.GetClustersResultPinnedFcvResult']:
        """
        The pinned Feature Compatibility Version (FCV) with its associated expiration date. See below.
        """
        return pulumi.get(self, "pinned_fcvs")

    @_builtins.property
    @pulumi.getter(name="pitEnabled")
    def pit_enabled(self) -> _builtins.bool:
        """
        Flag that indicates if the cluster uses Continuous Cloud Backup.
        """
        return pulumi.get(self, "pit_enabled")

    @_builtins.property
    @pulumi.getter(name="providerAutoScalingComputeMaxInstanceSize")
    def provider_auto_scaling_compute_max_instance_size(self) -> _builtins.str:
        """
        Maximum instance size to which your cluster can automatically scale.
        """
        return pulumi.get(self, "provider_auto_scaling_compute_max_instance_size")

    @_builtins.property
    @pulumi.getter(name="providerAutoScalingComputeMinInstanceSize")
    def provider_auto_scaling_compute_min_instance_size(self) -> _builtins.str:
        """
        Minimum instance size to which your cluster can automatically scale.
        """
        return pulumi.get(self, "provider_auto_scaling_compute_min_instance_size")

    @_builtins.property
    @pulumi.getter(name="providerBackupEnabled")
    def provider_backup_enabled(self) -> _builtins.bool:
        """
        Flag indicating if the cluster uses Cloud Backup Snapshots for backups. **DEPRECATED** Use `cloud_backup` instead.
        """
        return pulumi.get(self, "provider_backup_enabled")

    @_builtins.property
    @pulumi.getter(name="providerDiskIops")
    def provider_disk_iops(self) -> _builtins.int:
        """
        Indicates the maximum input/output operations per second (IOPS) the system can perform. The possible values depend on the selected providerSettings.instanceSizeName and diskSizeGB.
        """
        return pulumi.get(self, "provider_disk_iops")

    @_builtins.property
    @pulumi.getter(name="providerDiskTypeName")
    def provider_disk_type_name(self) -> _builtins.str:
        """
        Describes Azure disk type of the server’s root volume (Azure Only).
        """
        return pulumi.get(self, "provider_disk_type_name")

    @_builtins.property
    @pulumi.getter(name="providerEncryptEbsVolume")
    def provider_encrypt_ebs_volume(self) -> _builtins.bool:
        """
        **(DEPRECATED)** Indicates whether the Amazon EBS encryption is enabled. This feature encrypts the server’s root volume for both data at rest within the volume and data moving between the volume and the instance. By default this attribute is always enabled, per deprecation process showing the real value at `provider_encrypt_ebs_volume_flag` computed attribute.
        """
        return pulumi.get(self, "provider_encrypt_ebs_volume")

    @_builtins.property
    @pulumi.getter(name="providerInstanceSizeName")
    def provider_instance_size_name(self) -> _builtins.str:
        """
        Atlas provides different instance sizes, each with a default storage capacity and RAM size.
        """
        return pulumi.get(self, "provider_instance_size_name")

    @_builtins.property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> _builtins.str:
        """
        Indicates the cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @_builtins.property
    @pulumi.getter(name="providerRegionName")
    def provider_region_name(self) -> _builtins.str:
        """
        Indicates Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases. Requires the Atlas Region name, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        """
        return pulumi.get(self, "provider_region_name")

    @_builtins.property
    @pulumi.getter(name="providerVolumeType")
    def provider_volume_type(self) -> _builtins.str:
        """
        Indicates the type of the volume. The possible values are: `STANDARD` and `PROVISIONED`.
        > **NOTE:** `STANDARD` is not available for NVME clusters.
        """
        return pulumi.get(self, "provider_volume_type")

    @_builtins.property
    @pulumi.getter(name="redactClientLogData")
    def redact_client_log_data(self) -> _builtins.bool:
        """
        (Optional) Flag that enables or disables log redaction, see the [manual](https://www.mongodb.com/docs/manual/administration/monitoring/#log-redaction) for more information.
        """
        return pulumi.get(self, "redact_client_log_data")

    @_builtins.property
    @pulumi.getter(name="replicationFactor")
    def replication_factor(self) -> _builtins.int:
        """
        (Deprecated) Number of replica set members. Each member keeps a copy of your databases, providing high availability and data redundancy. The possible values are 3, 5, or 7. The default value is 3.
        """
        return pulumi.get(self, "replication_factor")

    @_builtins.property
    @pulumi.getter(name="replicationSpecs")
    def replication_specs(self) -> Sequence['outputs.GetClustersResultReplicationSpecResult']:
        """
        Configuration for cluster regions.  See Replication Spec below for more details.
        """
        return pulumi.get(self, "replication_specs")

    @_builtins.property
    @pulumi.getter(name="snapshotBackupPolicies")
    def snapshot_backup_policies(self) -> Sequence['outputs.GetClustersResultSnapshotBackupPolicyResult']:
        """
        current snapshot schedule and retention settings for the cluster.
        """
        return pulumi.get(self, "snapshot_backup_policies")

    @_builtins.property
    @pulumi.getter(name="srvAddress")
    def srv_address(self) -> _builtins.str:
        """
        Connection string for connecting to the Atlas cluster. The +srv modifier forces the connection to use TLS/SSL. See the mongoURI for additional options.
        """
        return pulumi.get(self, "srv_address")

    @_builtins.property
    @pulumi.getter(name="stateName")
    def state_name(self) -> _builtins.str:
        """
        Indicates the current state of the cluster. The possible states are:
        - IDLE
        - CREATING
        - UPDATING
        - DELETING
        - DELETED
        - REPAIRING
        """
        return pulumi.get(self, "state_name")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetClustersResultTagResult']:
        """
        Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="terminationProtectionEnabled")
    def termination_protection_enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.
        """
        return pulumi.get(self, "termination_protection_enabled")

    @_builtins.property
    @pulumi.getter(name="versionReleaseSystem")
    def version_release_system(self) -> _builtins.str:
        """
        Release cadence that Atlas uses for this cluster.
        """
        return pulumi.get(self, "version_release_system")


@pulumi.output_type
class GetClustersResultAdvancedConfigurationResult(dict):
    def __init__(__self__, *,
                 change_stream_options_pre_and_post_images_expire_after_seconds: _builtins.int,
                 custom_openssl_cipher_config_tls12s: Sequence[_builtins.str],
                 default_max_time_ms: _builtins.int,
                 default_read_concern: _builtins.str,
                 default_write_concern: _builtins.str,
                 fail_index_key_too_long: _builtins.bool,
                 javascript_enabled: _builtins.bool,
                 minimum_enabled_tls_protocol: _builtins.str,
                 no_table_scan: _builtins.bool,
                 oplog_min_retention_hours: _builtins.float,
                 oplog_size_mb: _builtins.int,
                 sample_refresh_interval_bi_connector: _builtins.int,
                 sample_size_bi_connector: _builtins.int,
                 tls_cipher_config_mode: _builtins.str,
                 transaction_lifetime_limit_seconds: _builtins.int):
        """
        :param _builtins.int change_stream_options_pre_and_post_images_expire_after_seconds: (Optional) The minimum pre- and post-image retention time in seconds. This parameter is only supported for MongoDB version 6.0 and above. Defaults to `-1`(off).
        :param Sequence[_builtins.str] custom_openssl_cipher_config_tls12s: The custom OpenSSL cipher suite list for TLS 1.2. This field is only valid when `tls_cipher_config_mode` is set to `CUSTOM`.
        :param _builtins.str default_read_concern: [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. **(DEPRECATED)** MongoDB 6.0 and later clusters default to `local`. To use a custom read concern level, please refer to your driver documentation.
        :param _builtins.str default_write_concern: [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 6.0 clusters default to [majority](https://docs.mongodb.com/manual/reference/write-concern/).
        :param _builtins.bool fail_index_key_too_long: **(DEPRECATED)** When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        :param _builtins.bool javascript_enabled: When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        :param _builtins.str minimum_enabled_tls_protocol: Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections. Valid values are:
               - TLS1_2
               - TLS1_3
        :param _builtins.bool no_table_scan: When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        :param _builtins.float oplog_min_retention_hours: Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        :param _builtins.int oplog_size_mb: The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        :param _builtins.int sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param _builtins.int sample_size_bi_connector: Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param _builtins.str tls_cipher_config_mode: The TLS cipher suite configuration mode. Valid values include `CUSTOM` or `DEFAULT`. The `DEFAULT` mode uses the default cipher suites. The `CUSTOM` mode allows you to specify custom cipher suites for both TLS 1.2 and TLS 1.3.
        """
        pulumi.set(__self__, "change_stream_options_pre_and_post_images_expire_after_seconds", change_stream_options_pre_and_post_images_expire_after_seconds)
        pulumi.set(__self__, "custom_openssl_cipher_config_tls12s", custom_openssl_cipher_config_tls12s)
        pulumi.set(__self__, "default_max_time_ms", default_max_time_ms)
        pulumi.set(__self__, "default_read_concern", default_read_concern)
        pulumi.set(__self__, "default_write_concern", default_write_concern)
        pulumi.set(__self__, "fail_index_key_too_long", fail_index_key_too_long)
        pulumi.set(__self__, "javascript_enabled", javascript_enabled)
        pulumi.set(__self__, "minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        pulumi.set(__self__, "no_table_scan", no_table_scan)
        pulumi.set(__self__, "oplog_min_retention_hours", oplog_min_retention_hours)
        pulumi.set(__self__, "oplog_size_mb", oplog_size_mb)
        pulumi.set(__self__, "sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        pulumi.set(__self__, "sample_size_bi_connector", sample_size_bi_connector)
        pulumi.set(__self__, "tls_cipher_config_mode", tls_cipher_config_mode)
        pulumi.set(__self__, "transaction_lifetime_limit_seconds", transaction_lifetime_limit_seconds)

    @_builtins.property
    @pulumi.getter(name="changeStreamOptionsPreAndPostImagesExpireAfterSeconds")
    def change_stream_options_pre_and_post_images_expire_after_seconds(self) -> _builtins.int:
        """
        (Optional) The minimum pre- and post-image retention time in seconds. This parameter is only supported for MongoDB version 6.0 and above. Defaults to `-1`(off).
        """
        return pulumi.get(self, "change_stream_options_pre_and_post_images_expire_after_seconds")

    @_builtins.property
    @pulumi.getter(name="customOpensslCipherConfigTls12s")
    def custom_openssl_cipher_config_tls12s(self) -> Sequence[_builtins.str]:
        """
        The custom OpenSSL cipher suite list for TLS 1.2. This field is only valid when `tls_cipher_config_mode` is set to `CUSTOM`.
        """
        return pulumi.get(self, "custom_openssl_cipher_config_tls12s")

    @_builtins.property
    @pulumi.getter(name="defaultMaxTimeMs")
    def default_max_time_ms(self) -> _builtins.int:
        return pulumi.get(self, "default_max_time_ms")

    @_builtins.property
    @pulumi.getter(name="defaultReadConcern")
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide""")
    def default_read_concern(self) -> _builtins.str:
        """
        [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. **(DEPRECATED)** MongoDB 6.0 and later clusters default to `local`. To use a custom read concern level, please refer to your driver documentation.
        """
        return pulumi.get(self, "default_read_concern")

    @_builtins.property
    @pulumi.getter(name="defaultWriteConcern")
    def default_write_concern(self) -> _builtins.str:
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 6.0 clusters default to [majority](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        return pulumi.get(self, "default_write_concern")

    @_builtins.property
    @pulumi.getter(name="failIndexKeyTooLong")
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide""")
    def fail_index_key_too_long(self) -> _builtins.bool:
        """
        **(DEPRECATED)** When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        """
        return pulumi.get(self, "fail_index_key_too_long")

    @_builtins.property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> _builtins.bool:
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        return pulumi.get(self, "javascript_enabled")

    @_builtins.property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> _builtins.str:
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections. Valid values are:
        - TLS1_2
        - TLS1_3
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @_builtins.property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> _builtins.bool:
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        return pulumi.get(self, "no_table_scan")

    @_builtins.property
    @pulumi.getter(name="oplogMinRetentionHours")
    def oplog_min_retention_hours(self) -> _builtins.float:
        """
        Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        """
        return pulumi.get(self, "oplog_min_retention_hours")

    @_builtins.property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> _builtins.int:
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        return pulumi.get(self, "oplog_size_mb")

    @_builtins.property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> _builtins.int:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @_builtins.property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> _builtins.int:
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_size_bi_connector")

    @_builtins.property
    @pulumi.getter(name="tlsCipherConfigMode")
    def tls_cipher_config_mode(self) -> _builtins.str:
        """
        The TLS cipher suite configuration mode. Valid values include `CUSTOM` or `DEFAULT`. The `DEFAULT` mode uses the default cipher suites. The `CUSTOM` mode allows you to specify custom cipher suites for both TLS 1.2 and TLS 1.3.
        """
        return pulumi.get(self, "tls_cipher_config_mode")

    @_builtins.property
    @pulumi.getter(name="transactionLifetimeLimitSeconds")
    def transaction_lifetime_limit_seconds(self) -> _builtins.int:
        return pulumi.get(self, "transaction_lifetime_limit_seconds")


@pulumi.output_type
class GetClustersResultBiConnectorConfigResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 read_preference: _builtins.str):
        """
        :param _builtins.bool enabled: Indicates whether or not BI Connector for Atlas is enabled on the cluster.
        :param _builtins.str read_preference: Indicates the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "read_preference", read_preference)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Indicates whether or not BI Connector for Atlas is enabled on the cluster.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> _builtins.str:
        """
        Indicates the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        return pulumi.get(self, "read_preference")


@pulumi.output_type
class GetClustersResultConnectionStringResult(dict):
    def __init__(__self__, *,
                 aws_private_link: Mapping[str, _builtins.str],
                 aws_private_link_srv: Mapping[str, _builtins.str],
                 private: _builtins.str,
                 private_endpoints: Sequence['outputs.GetClustersResultConnectionStringPrivateEndpointResult'],
                 private_srv: _builtins.str,
                 standard: _builtins.str,
                 standard_srv: _builtins.str):
        pulumi.set(__self__, "aws_private_link", aws_private_link)
        pulumi.set(__self__, "aws_private_link_srv", aws_private_link_srv)
        pulumi.set(__self__, "private", private)
        pulumi.set(__self__, "private_endpoints", private_endpoints)
        pulumi.set(__self__, "private_srv", private_srv)
        pulumi.set(__self__, "standard", standard)
        pulumi.set(__self__, "standard_srv", standard_srv)

    @_builtins.property
    @pulumi.getter(name="awsPrivateLink")
    def aws_private_link(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "aws_private_link")

    @_builtins.property
    @pulumi.getter(name="awsPrivateLinkSrv")
    def aws_private_link_srv(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "aws_private_link_srv")

    @_builtins.property
    @pulumi.getter
    def private(self) -> _builtins.str:
        return pulumi.get(self, "private")

    @_builtins.property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Sequence['outputs.GetClustersResultConnectionStringPrivateEndpointResult']:
        return pulumi.get(self, "private_endpoints")

    @_builtins.property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> _builtins.str:
        return pulumi.get(self, "private_srv")

    @_builtins.property
    @pulumi.getter
    def standard(self) -> _builtins.str:
        return pulumi.get(self, "standard")

    @_builtins.property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> _builtins.str:
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class GetClustersResultConnectionStringPrivateEndpointResult(dict):
    def __init__(__self__, *,
                 connection_string: _builtins.str,
                 endpoints: Sequence['outputs.GetClustersResultConnectionStringPrivateEndpointEndpointResult'],
                 srv_connection_string: _builtins.str,
                 srv_shard_optimized_connection_string: _builtins.str,
                 type: _builtins.str):
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "srv_connection_string", srv_connection_string)
        pulumi.set(__self__, "srv_shard_optimized_connection_string", srv_shard_optimized_connection_string)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> _builtins.str:
        return pulumi.get(self, "connection_string")

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> Sequence['outputs.GetClustersResultConnectionStringPrivateEndpointEndpointResult']:
        return pulumi.get(self, "endpoints")

    @_builtins.property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> _builtins.str:
        return pulumi.get(self, "srv_connection_string")

    @_builtins.property
    @pulumi.getter(name="srvShardOptimizedConnectionString")
    def srv_shard_optimized_connection_string(self) -> _builtins.str:
        return pulumi.get(self, "srv_shard_optimized_connection_string")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetClustersResultConnectionStringPrivateEndpointEndpointResult(dict):
    def __init__(__self__, *,
                 endpoint_id: _builtins.str,
                 provider_name: _builtins.str,
                 region: _builtins.str):
        """
        :param _builtins.str provider_name: Indicates the cloud service provider on which the servers are provisioned.
        """
        pulumi.set(__self__, "endpoint_id", endpoint_id)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> _builtins.str:
        return pulumi.get(self, "endpoint_id")

    @_builtins.property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> _builtins.str:
        """
        Indicates the cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetClustersResultLabelResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: The key that you want to write.
        :param _builtins.str value: The value that you want to write.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClustersResultPinnedFcvResult(dict):
    def __init__(__self__, *,
                 expiration_date: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str expiration_date: Expiration date of the fixed FCV. This value is in the ISO 8601 timestamp format (e.g. "2024-12-04T16:25:00Z").
        :param _builtins.str version: Feature compatibility version of the cluster.
        """
        pulumi.set(__self__, "expiration_date", expiration_date)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> _builtins.str:
        """
        Expiration date of the fixed FCV. This value is in the ISO 8601 timestamp format (e.g. "2024-12-04T16:25:00Z").
        """
        return pulumi.get(self, "expiration_date")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Feature compatibility version of the cluster.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetClustersResultReplicationSpecResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 num_shards: _builtins.int,
                 regions_configs: Sequence['outputs.GetClustersResultReplicationSpecRegionsConfigResult'],
                 zone_name: _builtins.str):
        """
        :param _builtins.str id: Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        :param _builtins.int num_shards: Number of shards to deploy in the specified zone.
        :param Sequence['GetClustersResultReplicationSpecRegionsConfigArgs'] regions_configs: Describes the physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        :param _builtins.str zone_name: Indicates the n ame for the zone in a Global Cluster.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "num_shards", num_shards)
        pulumi.set(__self__, "regions_configs", regions_configs)
        pulumi.set(__self__, "zone_name", zone_name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> _builtins.int:
        """
        Number of shards to deploy in the specified zone.
        """
        return pulumi.get(self, "num_shards")

    @_builtins.property
    @pulumi.getter(name="regionsConfigs")
    def regions_configs(self) -> Sequence['outputs.GetClustersResultReplicationSpecRegionsConfigResult']:
        """
        Describes the physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        """
        return pulumi.get(self, "regions_configs")

    @_builtins.property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> _builtins.str:
        """
        Indicates the n ame for the zone in a Global Cluster.
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class GetClustersResultReplicationSpecRegionsConfigResult(dict):
    def __init__(__self__, *,
                 analytics_nodes: _builtins.int,
                 electable_nodes: _builtins.int,
                 priority: _builtins.int,
                 read_only_nodes: _builtins.int,
                 region_name: _builtins.str):
        """
        :param _builtins.int analytics_nodes: Indicates the number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary.
        :param _builtins.int electable_nodes: Number of electable nodes for Atlas to deploy to the region.
        :param _builtins.int priority: Election priority of the region. For regions with only read-only nodes, set this value to 0.
        :param _builtins.int read_only_nodes: Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        :param _builtins.str region_name: Name for the region specified.
        """
        pulumi.set(__self__, "analytics_nodes", analytics_nodes)
        pulumi.set(__self__, "electable_nodes", electable_nodes)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "read_only_nodes", read_only_nodes)
        pulumi.set(__self__, "region_name", region_name)

    @_builtins.property
    @pulumi.getter(name="analyticsNodes")
    def analytics_nodes(self) -> _builtins.int:
        """
        Indicates the number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary.
        """
        return pulumi.get(self, "analytics_nodes")

    @_builtins.property
    @pulumi.getter(name="electableNodes")
    def electable_nodes(self) -> _builtins.int:
        """
        Number of electable nodes for Atlas to deploy to the region.
        """
        return pulumi.get(self, "electable_nodes")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        Election priority of the region. For regions with only read-only nodes, set this value to 0.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="readOnlyNodes")
    def read_only_nodes(self) -> _builtins.int:
        """
        Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        """
        return pulumi.get(self, "read_only_nodes")

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> _builtins.str:
        """
        Name for the region specified.
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class GetClustersResultSnapshotBackupPolicyResult(dict):
    def __init__(__self__, *,
                 cluster_id: _builtins.str,
                 cluster_name: _builtins.str,
                 next_snapshot: _builtins.str,
                 policies: Sequence['outputs.GetClustersResultSnapshotBackupPolicyPolicyResult'],
                 reference_hour_of_day: _builtins.int,
                 reference_minute_of_hour: _builtins.int,
                 restore_window_days: _builtins.int,
                 update_snapshots: _builtins.bool):
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "next_snapshot", next_snapshot)
        pulumi.set(__self__, "policies", policies)
        pulumi.set(__self__, "reference_hour_of_day", reference_hour_of_day)
        pulumi.set(__self__, "reference_minute_of_hour", reference_minute_of_hour)
        pulumi.set(__self__, "restore_window_days", restore_window_days)
        pulumi.set(__self__, "update_snapshots", update_snapshots)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> _builtins.str:
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> _builtins.str:
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="nextSnapshot")
    def next_snapshot(self) -> _builtins.str:
        return pulumi.get(self, "next_snapshot")

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Sequence['outputs.GetClustersResultSnapshotBackupPolicyPolicyResult']:
        return pulumi.get(self, "policies")

    @_builtins.property
    @pulumi.getter(name="referenceHourOfDay")
    def reference_hour_of_day(self) -> _builtins.int:
        return pulumi.get(self, "reference_hour_of_day")

    @_builtins.property
    @pulumi.getter(name="referenceMinuteOfHour")
    def reference_minute_of_hour(self) -> _builtins.int:
        return pulumi.get(self, "reference_minute_of_hour")

    @_builtins.property
    @pulumi.getter(name="restoreWindowDays")
    def restore_window_days(self) -> _builtins.int:
        return pulumi.get(self, "restore_window_days")

    @_builtins.property
    @pulumi.getter(name="updateSnapshots")
    def update_snapshots(self) -> _builtins.bool:
        return pulumi.get(self, "update_snapshots")


@pulumi.output_type
class GetClustersResultSnapshotBackupPolicyPolicyResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 policy_items: Sequence['outputs.GetClustersResultSnapshotBackupPolicyPolicyPolicyItemResult']):
        """
        :param _builtins.str id: Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "policy_items", policy_items)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="policyItems")
    def policy_items(self) -> Sequence['outputs.GetClustersResultSnapshotBackupPolicyPolicyPolicyItemResult']:
        return pulumi.get(self, "policy_items")


@pulumi.output_type
class GetClustersResultSnapshotBackupPolicyPolicyPolicyItemResult(dict):
    def __init__(__self__, *,
                 frequency_interval: _builtins.int,
                 frequency_type: _builtins.str,
                 id: _builtins.str,
                 retention_unit: _builtins.str,
                 retention_value: _builtins.int):
        """
        :param _builtins.str id: Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @_builtins.property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> _builtins.int:
        return pulumi.get(self, "frequency_interval")

    @_builtins.property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> _builtins.str:
        return pulumi.get(self, "frequency_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> _builtins.str:
        return pulumi.get(self, "retention_unit")

    @_builtins.property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> _builtins.int:
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetClustersResultTagResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: The key that you want to write.
        :param _builtins.str value: The value that you want to write.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetControlPlaneIpAddressesInboundResult(dict):
    def __init__(__self__, *,
                 aws: Mapping[str, Sequence[_builtins.str]],
                 azure: Mapping[str, Sequence[_builtins.str]],
                 gcp: Mapping[str, Sequence[_builtins.str]]):
        """
        :param Mapping[str, Sequence[_builtins.str]] aws: Control plane IP addresses in AWS. Each key identifies an Amazon Web Services (AWS) region. Each value identifies control plane IP addresses in the AWS region.
        :param Mapping[str, Sequence[_builtins.str]] azure: Control plane IP addresses in Azure. Each key identifies an Azure region. Each value identifies control plane IP addresses in the Azure region.
        :param Mapping[str, Sequence[_builtins.str]] gcp: Control plane IP addresses in GCP. Each key identifies a Google Cloud (GCP) region. Each value identifies control plane IP addresses in the GCP region.
        """
        pulumi.set(__self__, "aws", aws)
        pulumi.set(__self__, "azure", azure)
        pulumi.set(__self__, "gcp", gcp)

    @_builtins.property
    @pulumi.getter
    def aws(self) -> Mapping[str, Sequence[_builtins.str]]:
        """
        Control plane IP addresses in AWS. Each key identifies an Amazon Web Services (AWS) region. Each value identifies control plane IP addresses in the AWS region.
        """
        return pulumi.get(self, "aws")

    @_builtins.property
    @pulumi.getter
    def azure(self) -> Mapping[str, Sequence[_builtins.str]]:
        """
        Control plane IP addresses in Azure. Each key identifies an Azure region. Each value identifies control plane IP addresses in the Azure region.
        """
        return pulumi.get(self, "azure")

    @_builtins.property
    @pulumi.getter
    def gcp(self) -> Mapping[str, Sequence[_builtins.str]]:
        """
        Control plane IP addresses in GCP. Each key identifies a Google Cloud (GCP) region. Each value identifies control plane IP addresses in the GCP region.
        """
        return pulumi.get(self, "gcp")


@pulumi.output_type
class GetControlPlaneIpAddressesOutboundResult(dict):
    def __init__(__self__, *,
                 aws: Mapping[str, Sequence[_builtins.str]],
                 azure: Mapping[str, Sequence[_builtins.str]],
                 gcp: Mapping[str, Sequence[_builtins.str]]):
        """
        :param Mapping[str, Sequence[_builtins.str]] aws: Control plane IP addresses in AWS. Each key identifies an Amazon Web Services (AWS) region. Each value identifies control plane IP addresses in the AWS region.
        :param Mapping[str, Sequence[_builtins.str]] azure: Control plane IP addresses in Azure. Each key identifies an Azure region. Each value identifies control plane IP addresses in the Azure region.
        :param Mapping[str, Sequence[_builtins.str]] gcp: Control plane IP addresses in GCP. Each key identifies a Google Cloud (GCP) region. Each value identifies control plane IP addresses in the GCP region.
        """
        pulumi.set(__self__, "aws", aws)
        pulumi.set(__self__, "azure", azure)
        pulumi.set(__self__, "gcp", gcp)

    @_builtins.property
    @pulumi.getter
    def aws(self) -> Mapping[str, Sequence[_builtins.str]]:
        """
        Control plane IP addresses in AWS. Each key identifies an Amazon Web Services (AWS) region. Each value identifies control plane IP addresses in the AWS region.
        """
        return pulumi.get(self, "aws")

    @_builtins.property
    @pulumi.getter
    def azure(self) -> Mapping[str, Sequence[_builtins.str]]:
        """
        Control plane IP addresses in Azure. Each key identifies an Azure region. Each value identifies control plane IP addresses in the Azure region.
        """
        return pulumi.get(self, "azure")

    @_builtins.property
    @pulumi.getter
    def gcp(self) -> Mapping[str, Sequence[_builtins.str]]:
        """
        Control plane IP addresses in GCP. Each key identifies a Google Cloud (GCP) region. Each value identifies control plane IP addresses in the GCP region.
        """
        return pulumi.get(self, "gcp")


@pulumi.output_type
class GetCustomDbRoleActionResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 resources: Sequence['outputs.GetCustomDbRoleActionResourceResult']):
        """
        :param _builtins.str action: (Required) Name of the privilege action. For a complete list of actions available in the Atlas API, see Custom Role Actions.
        :param Sequence['GetCustomDbRoleActionResourceArgs'] resources: (Required) Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        (Required) Name of the privilege action. For a complete list of actions available in the Atlas API, see Custom Role Actions.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetCustomDbRoleActionResourceResult']:
        """
        (Required) Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetCustomDbRoleActionResourceResult(dict):
    def __init__(__self__, *,
                 cluster: _builtins.bool,
                 collection_name: _builtins.str,
                 database_name: _builtins.str):
        """
        :param _builtins.str database_name: (Required) Database on which the inherited role is granted.
        """
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "database_name", database_name)

    @_builtins.property
    @pulumi.getter
    def cluster(self) -> _builtins.bool:
        return pulumi.get(self, "cluster")

    @_builtins.property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> _builtins.str:
        return pulumi.get(self, "collection_name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        (Required) Database on which the inherited role is granted.
        """
        return pulumi.get(self, "database_name")


@pulumi.output_type
class GetCustomDbRoleInheritedRoleResult(dict):
    def __init__(__self__, *,
                 database_name: _builtins.str,
                 role_name: _builtins.str):
        """
        :param _builtins.str database_name: (Required) Database on which the inherited role is granted.
        :param _builtins.str role_name: Name of the custom role.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "role_name", role_name)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        (Required) Database on which the inherited role is granted.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="roleName")
    def role_name(self) -> _builtins.str:
        """
        Name of the custom role.
        """
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetCustomDbRolesResultResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetCustomDbRolesResultActionResult'],
                 inherited_roles: Sequence['outputs.GetCustomDbRolesResultInheritedRoleResult'],
                 role_name: _builtins.str):
        """
        :param _builtins.str role_name: (Required) Name of the inherited role. This can either be another custom role or a built-in role.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "inherited_roles", inherited_roles)
        pulumi.set(__self__, "role_name", role_name)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetCustomDbRolesResultActionResult']:
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter(name="inheritedRoles")
    def inherited_roles(self) -> Sequence['outputs.GetCustomDbRolesResultInheritedRoleResult']:
        return pulumi.get(self, "inherited_roles")

    @_builtins.property
    @pulumi.getter(name="roleName")
    def role_name(self) -> _builtins.str:
        """
        (Required) Name of the inherited role. This can either be another custom role or a built-in role.
        """
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetCustomDbRolesResultActionResult(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 resources: Sequence['outputs.GetCustomDbRolesResultActionResourceResult']):
        """
        :param _builtins.str action: (Required) Name of the privilege action. For a complete list of actions available in the Atlas API, see Custom Role Actions.
        :param Sequence['GetCustomDbRolesResultActionResourceArgs'] resources: (Required) Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        (Required) Name of the privilege action. For a complete list of actions available in the Atlas API, see Custom Role Actions.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetCustomDbRolesResultActionResourceResult']:
        """
        (Required) Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetCustomDbRolesResultActionResourceResult(dict):
    def __init__(__self__, *,
                 cluster: _builtins.bool,
                 collection_name: _builtins.str,
                 database_name: _builtins.str):
        """
        :param _builtins.str database_name: (Required) Database on which the inherited role is granted.
        """
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "database_name", database_name)

    @_builtins.property
    @pulumi.getter
    def cluster(self) -> _builtins.bool:
        return pulumi.get(self, "cluster")

    @_builtins.property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> _builtins.str:
        return pulumi.get(self, "collection_name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        (Required) Database on which the inherited role is granted.
        """
        return pulumi.get(self, "database_name")


@pulumi.output_type
class GetCustomDbRolesResultInheritedRoleResult(dict):
    def __init__(__self__, *,
                 database_name: _builtins.str,
                 role_name: _builtins.str):
        """
        :param _builtins.str database_name: (Required) Database on which the inherited role is granted.
        :param _builtins.str role_name: (Required) Name of the inherited role. This can either be another custom role or a built-in role.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "role_name", role_name)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        (Required) Database on which the inherited role is granted.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="roleName")
    def role_name(self) -> _builtins.str:
        """
        (Required) Name of the inherited role. This can either be another custom role or a built-in role.
        """
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetDatabaseUserLabelResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: The key that you want to write.
        :param _builtins.str value: The value that you want to write.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDatabaseUserRoleResult(dict):
    def __init__(__self__, *,
                 collection_name: _builtins.str,
                 database_name: _builtins.str,
                 role_name: _builtins.str):
        """
        :param _builtins.str collection_name: Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        :param _builtins.str database_name: Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.
        """
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "role_name", role_name)

    @_builtins.property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> _builtins.str:
        """
        Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        """
        return pulumi.get(self, "collection_name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="roleName")
    def role_name(self) -> _builtins.str:
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetDatabaseUserScopeResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str name: Name of the role to grant.
        :param _builtins.str type: Type of resource that the user has access to. See [Database User API](https://www.mongodb.com/docs/api/doc/atlas-admin-api-v2/operation/operation-createdatabaseuser) for the list of valid values.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the role to grant.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of resource that the user has access to. See [Database User API](https://www.mongodb.com/docs/api/doc/atlas-admin-api-v2/operation/operation-createdatabaseuser) for the list of valid values.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDatabaseUsersResultResult(dict):
    def __init__(__self__, *,
                 auth_database_name: _builtins.str,
                 aws_iam_type: _builtins.str,
                 description: _builtins.str,
                 id: _builtins.str,
                 labels: Sequence['outputs.GetDatabaseUsersResultLabelResult'],
                 ldap_auth_type: _builtins.str,
                 oidc_auth_type: _builtins.str,
                 project_id: _builtins.str,
                 roles: Sequence['outputs.GetDatabaseUsersResultRoleResult'],
                 scopes: Sequence['outputs.GetDatabaseUsersResultScopeResult'],
                 username: _builtins.str,
                 x509_type: _builtins.str):
        """
        :param _builtins.str auth_database_name: (Required) Database against which Atlas authenticates the user. A user must provide both a username and authentication database to log into MongoDB.
               Possible values include:
        :param _builtins.str aws_iam_type: The new database user authenticates with AWS IAM credentials. Default is `NONE`, `USER` means user has AWS IAM user credentials, `ROLE` - means user has credentials associated with an AWS IAM role.
        :param _builtins.str description: Description of this database user.
        :param _builtins.str id: Autogenerated Unique ID for this data source.
        :param _builtins.str ldap_auth_type: Method by which the provided username is authenticated. Default is `NONE`. Other valid values are: `USER`, `GROUP`.
        :param _builtins.str oidc_auth_type: (Optional) Human-readable label that indicates whether the new database user authenticates with OIDC (OpenID Connect) federated authentication. If no value is given, Atlas uses the default value of `NONE`. The accepted types are:
               * `NONE` -	The user does not use OIDC federated authentication.
               * `IDP_GROUP` - OIDC Workforce federated authentication group. To learn more about OIDC federated authentication, see [Set up Workforce Identity Federation with OIDC](https://www.mongodb.com/docs/atlas/security-oidc/).
               * `USER` - OIDC Workload federated authentication user. To learn more about OIDC federated authentication, see [Set up Workload Identity Federation with OIDC](https://www.mongodb.com/docs/atlas/security-oidc/).
        :param _builtins.str project_id: The unique ID for the project to get all database users.
        :param Sequence['GetDatabaseUsersResultRoleArgs'] roles: List of user’s roles and the databases / collections on which the roles apply. A role allows the user to perform particular actions on the specified database. A role on the admin database can include privileges that apply to the other databases as well. See Roles below for more details.
        :param Sequence['GetDatabaseUsersResultScopeArgs'] scopes: Array of clusters and Atlas Data Federation that this user has access to.
        :param _builtins.str username: Username for authenticating to MongoDB.
        :param _builtins.str x509_type: X.509 method by which the provided username is authenticated.
        """
        pulumi.set(__self__, "auth_database_name", auth_database_name)
        pulumi.set(__self__, "aws_iam_type", aws_iam_type)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "ldap_auth_type", ldap_auth_type)
        pulumi.set(__self__, "oidc_auth_type", oidc_auth_type)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "x509_type", x509_type)

    @_builtins.property
    @pulumi.getter(name="authDatabaseName")
    def auth_database_name(self) -> _builtins.str:
        """
        (Required) Database against which Atlas authenticates the user. A user must provide both a username and authentication database to log into MongoDB.
        Possible values include:
        """
        return pulumi.get(self, "auth_database_name")

    @_builtins.property
    @pulumi.getter(name="awsIamType")
    def aws_iam_type(self) -> _builtins.str:
        """
        The new database user authenticates with AWS IAM credentials. Default is `NONE`, `USER` means user has AWS IAM user credentials, `ROLE` - means user has credentials associated with an AWS IAM role.
        """
        return pulumi.get(self, "aws_iam_type")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of this database user.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Autogenerated Unique ID for this data source.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetDatabaseUsersResultLabelResult']:
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="ldapAuthType")
    def ldap_auth_type(self) -> _builtins.str:
        """
        Method by which the provided username is authenticated. Default is `NONE`. Other valid values are: `USER`, `GROUP`.
        """
        return pulumi.get(self, "ldap_auth_type")

    @_builtins.property
    @pulumi.getter(name="oidcAuthType")
    def oidc_auth_type(self) -> _builtins.str:
        """
        (Optional) Human-readable label that indicates whether the new database user authenticates with OIDC (OpenID Connect) federated authentication. If no value is given, Atlas uses the default value of `NONE`. The accepted types are:
        * `NONE` -	The user does not use OIDC federated authentication.
        * `IDP_GROUP` - OIDC Workforce federated authentication group. To learn more about OIDC federated authentication, see [Set up Workforce Identity Federation with OIDC](https://www.mongodb.com/docs/atlas/security-oidc/).
        * `USER` - OIDC Workload federated authentication user. To learn more about OIDC federated authentication, see [Set up Workload Identity Federation with OIDC](https://www.mongodb.com/docs/atlas/security-oidc/).
        """
        return pulumi.get(self, "oidc_auth_type")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The unique ID for the project to get all database users.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Sequence['outputs.GetDatabaseUsersResultRoleResult']:
        """
        List of user’s roles and the databases / collections on which the roles apply. A role allows the user to perform particular actions on the specified database. A role on the admin database can include privileges that apply to the other databases as well. See Roles below for more details.
        """
        return pulumi.get(self, "roles")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Sequence['outputs.GetDatabaseUsersResultScopeResult']:
        """
        Array of clusters and Atlas Data Federation that this user has access to.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Username for authenticating to MongoDB.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="x509Type")
    def x509_type(self) -> _builtins.str:
        """
        X.509 method by which the provided username is authenticated.
        """
        return pulumi.get(self, "x509_type")


@pulumi.output_type
class GetDatabaseUsersResultLabelResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: The key that you want to write.
        :param _builtins.str value: The value that you want to write.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDatabaseUsersResultRoleResult(dict):
    def __init__(__self__, *,
                 collection_name: _builtins.str,
                 database_name: _builtins.str,
                 role_name: _builtins.str):
        """
        :param _builtins.str collection_name: Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        :param _builtins.str database_name: Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.
        """
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "role_name", role_name)

    @_builtins.property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> _builtins.str:
        """
        Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        """
        return pulumi.get(self, "collection_name")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="roleName")
    def role_name(self) -> _builtins.str:
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetDatabaseUsersResultScopeResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str name: Name of the role to grant.
        :param _builtins.str type: Type of resource that the user has access to. See [Database User API](https://www.mongodb.com/docs/api/doc/atlas-admin-api-v2/operation/operation-createdatabaseuser) for the list of valid values.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the role to grant.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of resource that the user has access to. See [Database User API](https://www.mongodb.com/docs/api/doc/atlas-admin-api-v2/operation/operation-createdatabaseuser) for the list of valid values.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetEncryptionAtRestAwsKmsConfigResult(dict):
    def __init__(__self__, *,
                 access_key_id: _builtins.str,
                 customer_master_key_id: _builtins.str,
                 enabled: _builtins.bool,
                 region: _builtins.str,
                 require_private_networking: _builtins.bool,
                 role_id: _builtins.str,
                 secret_access_key: _builtins.str,
                 valid: _builtins.bool):
        """
        :param _builtins.str access_key_id: Unique alphanumeric string that identifies an Identity and Access Management (IAM) access key with permissions required to access your Amazon Web Services (AWS) Customer Master Key (CMK).
        :param _builtins.str customer_master_key_id: Unique alphanumeric string that identifies the Amazon Web Services (AWS) Customer Master Key (CMK) you used to encrypt and decrypt the MongoDB master keys.
        :param _builtins.bool enabled: Flag that indicates whether someone enabled encryption at rest for the specified project through Amazon Web Services (AWS) Key Management Service (KMS). To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        :param _builtins.str region: Physical location where MongoDB Atlas deploys your AWS-hosted MongoDB cluster nodes. The region you choose can affect network latency for clients accessing your databases. When MongoDB Atlas deploys a dedicated cluster, it checks if a VPC or VPC connection exists for that provider and region. If not, MongoDB Atlas creates them as part of the deployment. MongoDB Atlas assigns the VPC a CIDR block. To limit a new VPC peering connection to one CIDR block and region, create the connection first. Deploy the cluster after the connection starts.
        :param _builtins.bool require_private_networking: Enable connection to your Amazon Web Services (AWS) Key Management Service (KMS) over private networking.
        :param _builtins.str role_id: Unique 24-hexadecimal digit string that identifies an Amazon Web Services (AWS) Identity and Access Management (IAM) role. This IAM role has the permissions required to manage your AWS customer master key.
        :param _builtins.str secret_access_key: Human-readable label of the Identity and Access Management (IAM) secret access key with permissions required to access your Amazon Web Services (AWS) customer master key.
        :param _builtins.bool valid: Flag that indicates whether the Amazon Web Services (AWS) Key Management Service (KMS) encryption key can encrypt and decrypt data.
        """
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "customer_master_key_id", customer_master_key_id)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "require_private_networking", require_private_networking)
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "secret_access_key", secret_access_key)
        pulumi.set(__self__, "valid", valid)

    @_builtins.property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> _builtins.str:
        """
        Unique alphanumeric string that identifies an Identity and Access Management (IAM) access key with permissions required to access your Amazon Web Services (AWS) Customer Master Key (CMK).
        """
        return pulumi.get(self, "access_key_id")

    @_builtins.property
    @pulumi.getter(name="customerMasterKeyId")
    def customer_master_key_id(self) -> _builtins.str:
        """
        Unique alphanumeric string that identifies the Amazon Web Services (AWS) Customer Master Key (CMK) you used to encrypt and decrypt the MongoDB master keys.
        """
        return pulumi.get(self, "customer_master_key_id")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether someone enabled encryption at rest for the specified project through Amazon Web Services (AWS) Key Management Service (KMS). To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Physical location where MongoDB Atlas deploys your AWS-hosted MongoDB cluster nodes. The region you choose can affect network latency for clients accessing your databases. When MongoDB Atlas deploys a dedicated cluster, it checks if a VPC or VPC connection exists for that provider and region. If not, MongoDB Atlas creates them as part of the deployment. MongoDB Atlas assigns the VPC a CIDR block. To limit a new VPC peering connection to one CIDR block and region, create the connection first. Deploy the cluster after the connection starts.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="requirePrivateNetworking")
    def require_private_networking(self) -> _builtins.bool:
        """
        Enable connection to your Amazon Web Services (AWS) Key Management Service (KMS) over private networking.
        """
        return pulumi.get(self, "require_private_networking")

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies an Amazon Web Services (AWS) Identity and Access Management (IAM) role. This IAM role has the permissions required to manage your AWS customer master key.
        """
        return pulumi.get(self, "role_id")

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> _builtins.str:
        """
        Human-readable label of the Identity and Access Management (IAM) secret access key with permissions required to access your Amazon Web Services (AWS) customer master key.
        """
        return pulumi.get(self, "secret_access_key")

    @_builtins.property
    @pulumi.getter
    def valid(self) -> _builtins.bool:
        """
        Flag that indicates whether the Amazon Web Services (AWS) Key Management Service (KMS) encryption key can encrypt and decrypt data.
        """
        return pulumi.get(self, "valid")


@pulumi.output_type
class GetEncryptionAtRestAzureKeyVaultConfigResult(dict):
    def __init__(__self__, *,
                 azure_environment: _builtins.str,
                 client_id: _builtins.str,
                 enabled: _builtins.bool,
                 key_identifier: _builtins.str,
                 key_vault_name: _builtins.str,
                 require_private_networking: _builtins.bool,
                 resource_group_name: _builtins.str,
                 secret: _builtins.str,
                 subscription_id: _builtins.str,
                 tenant_id: _builtins.str,
                 valid: _builtins.bool):
        """
        :param _builtins.str azure_environment: Azure environment in which your account credentials reside.
        :param _builtins.str client_id: Unique 36-hexadecimal character string that identifies an Azure application associated with your Azure Active Directory tenant.
        :param _builtins.bool enabled: Flag that indicates whether someone enabled encryption at rest for the specified  project. To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        :param _builtins.str key_identifier: Web address with a unique key that identifies for your Azure Key Vault.
        :param _builtins.str key_vault_name: Unique string that identifies the Azure Key Vault that contains your key.
        :param _builtins.bool require_private_networking: Enable connection to your Azure Key Vault over private networking.
        :param _builtins.str resource_group_name: Name of the Azure resource group that contains your Azure Key Vault.
        :param _builtins.str secret: Private data that you need secured and that belongs to the specified Azure Key Vault (AKV) tenant (**azureKeyVault.tenantID**). This data can include any type of sensitive data such as passwords, database connection strings, API keys, and the like. AKV stores this information as encrypted binary data.
        :param _builtins.str subscription_id: Unique 36-hexadecimal character string that identifies your Azure subscription.
        :param _builtins.str tenant_id: Unique 36-hexadecimal character string that identifies the Azure Active Directory tenant within your Azure subscription.
        :param _builtins.bool valid: Flag that indicates whether the Azure encryption key can encrypt and decrypt data.
        """
        pulumi.set(__self__, "azure_environment", azure_environment)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "key_identifier", key_identifier)
        pulumi.set(__self__, "key_vault_name", key_vault_name)
        pulumi.set(__self__, "require_private_networking", require_private_networking)
        pulumi.set(__self__, "resource_group_name", resource_group_name)
        pulumi.set(__self__, "secret", secret)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "valid", valid)

    @_builtins.property
    @pulumi.getter(name="azureEnvironment")
    def azure_environment(self) -> _builtins.str:
        """
        Azure environment in which your account credentials reside.
        """
        return pulumi.get(self, "azure_environment")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        Unique 36-hexadecimal character string that identifies an Azure application associated with your Azure Active Directory tenant.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether someone enabled encryption at rest for the specified  project. To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="keyIdentifier")
    def key_identifier(self) -> _builtins.str:
        """
        Web address with a unique key that identifies for your Azure Key Vault.
        """
        return pulumi.get(self, "key_identifier")

    @_builtins.property
    @pulumi.getter(name="keyVaultName")
    def key_vault_name(self) -> _builtins.str:
        """
        Unique string that identifies the Azure Key Vault that contains your key.
        """
        return pulumi.get(self, "key_vault_name")

    @_builtins.property
    @pulumi.getter(name="requirePrivateNetworking")
    def require_private_networking(self) -> _builtins.bool:
        """
        Enable connection to your Azure Key Vault over private networking.
        """
        return pulumi.get(self, "require_private_networking")

    @_builtins.property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> _builtins.str:
        """
        Name of the Azure resource group that contains your Azure Key Vault.
        """
        return pulumi.get(self, "resource_group_name")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        Private data that you need secured and that belongs to the specified Azure Key Vault (AKV) tenant (**azureKeyVault.tenantID**). This data can include any type of sensitive data such as passwords, database connection strings, API keys, and the like. AKV stores this information as encrypted binary data.
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> _builtins.str:
        """
        Unique 36-hexadecimal character string that identifies your Azure subscription.
        """
        return pulumi.get(self, "subscription_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        Unique 36-hexadecimal character string that identifies the Azure Active Directory tenant within your Azure subscription.
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter
    def valid(self) -> _builtins.bool:
        """
        Flag that indicates whether the Azure encryption key can encrypt and decrypt data.
        """
        return pulumi.get(self, "valid")


@pulumi.output_type
class GetEncryptionAtRestGoogleCloudKmsConfigResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 key_version_resource_id: _builtins.str,
                 role_id: _builtins.str,
                 service_account_key: _builtins.str,
                 valid: _builtins.bool):
        """
        :param _builtins.bool enabled: Flag that indicates whether someone enabled encryption at rest for the specified  project. To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        :param _builtins.str key_version_resource_id: Resource path that displays the key version resource ID for your Google Cloud KMS.
        :param _builtins.str role_id: Unique 24-hexadecimal digit string that identifies the Google Cloud Provider Access Role that MongoDB Cloud uses to access the Google Cloud KMS.
        :param _builtins.str service_account_key: JavaScript Object Notation (JSON) object that contains the Google Cloud Key Management Service (KMS). Format the JSON as a string and not as an object.
        :param _builtins.bool valid: Flag that indicates whether the Google Cloud Key Management Service (KMS) encryption key can encrypt and decrypt data.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "key_version_resource_id", key_version_resource_id)
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "service_account_key", service_account_key)
        pulumi.set(__self__, "valid", valid)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether someone enabled encryption at rest for the specified  project. To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="keyVersionResourceId")
    def key_version_resource_id(self) -> _builtins.str:
        """
        Resource path that displays the key version resource ID for your Google Cloud KMS.
        """
        return pulumi.get(self, "key_version_resource_id")

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the Google Cloud Provider Access Role that MongoDB Cloud uses to access the Google Cloud KMS.
        """
        return pulumi.get(self, "role_id")

    @_builtins.property
    @pulumi.getter(name="serviceAccountKey")
    def service_account_key(self) -> _builtins.str:
        """
        JavaScript Object Notation (JSON) object that contains the Google Cloud Key Management Service (KMS). Format the JSON as a string and not as an object.
        """
        return pulumi.get(self, "service_account_key")

    @_builtins.property
    @pulumi.getter
    def valid(self) -> _builtins.bool:
        """
        Flag that indicates whether the Google Cloud Key Management Service (KMS) encryption key can encrypt and decrypt data.
        """
        return pulumi.get(self, "valid")


@pulumi.output_type
class GetEncryptionAtRestPrivateEndpointsResultResult(dict):
    def __init__(__self__, *,
                 cloud_provider: _builtins.str,
                 error_message: _builtins.str,
                 id: _builtins.str,
                 private_endpoint_connection_name: _builtins.str,
                 project_id: _builtins.str,
                 region_name: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str cloud_provider: Label that identifies the cloud provider for the Encryption At Rest private endpoint.
        :param _builtins.str error_message: Error message for failures associated with the Encryption At Rest private endpoint.
        :param _builtins.str id: Unique 24-hexadecimal digit string that identifies the Private Endpoint Service.
        :param _builtins.str private_endpoint_connection_name: Connection name of the Azure Private Endpoint.
        :param _builtins.str project_id: Unique 24-hexadecimal digit string that identifies your project.
        :param _builtins.str region_name: Cloud provider region in which the Encryption At Rest private endpoint is located.
        :param _builtins.str status: State of the Encryption At Rest private endpoint.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "error_message", error_message)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "private_endpoint_connection_name", private_endpoint_connection_name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "region_name", region_name)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> _builtins.str:
        """
        Label that identifies the cloud provider for the Encryption At Rest private endpoint.
        """
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> _builtins.str:
        """
        Error message for failures associated with the Encryption At Rest private endpoint.
        """
        return pulumi.get(self, "error_message")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the Private Endpoint Service.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="privateEndpointConnectionName")
    def private_endpoint_connection_name(self) -> _builtins.str:
        """
        Connection name of the Azure Private Endpoint.
        """
        return pulumi.get(self, "private_endpoint_connection_name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies your project.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> _builtins.str:
        """
        Cloud provider region in which the Encryption At Rest private endpoint is located.
        """
        return pulumi.get(self, "region_name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        State of the Encryption At Rest private endpoint.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetEventTriggerEventProcessorResult(dict):
    def __init__(__self__, *,
                 aws_eventbridges: Sequence['outputs.GetEventTriggerEventProcessorAwsEventbridgeResult']):
        pulumi.set(__self__, "aws_eventbridges", aws_eventbridges)

    @_builtins.property
    @pulumi.getter(name="awsEventbridges")
    def aws_eventbridges(self) -> Sequence['outputs.GetEventTriggerEventProcessorAwsEventbridgeResult']:
        return pulumi.get(self, "aws_eventbridges")


@pulumi.output_type
class GetEventTriggerEventProcessorAwsEventbridgeResult(dict):
    def __init__(__self__, *,
                 config_account_id: _builtins.str,
                 config_region: _builtins.str):
        """
        :param _builtins.str config_account_id: AWS Account ID.
        :param _builtins.str config_region: Region of AWS Account.
        """
        pulumi.set(__self__, "config_account_id", config_account_id)
        pulumi.set(__self__, "config_region", config_region)

    @_builtins.property
    @pulumi.getter(name="configAccountId")
    def config_account_id(self) -> _builtins.str:
        """
        AWS Account ID.
        """
        return pulumi.get(self, "config_account_id")

    @_builtins.property
    @pulumi.getter(name="configRegion")
    def config_region(self) -> _builtins.str:
        """
        Region of AWS Account.
        """
        return pulumi.get(self, "config_region")


@pulumi.output_type
class GetEventTriggersResultResult(dict):
    def __init__(__self__, *,
                 config_collection: _builtins.str,
                 config_database: _builtins.str,
                 config_full_document: _builtins.bool,
                 config_full_document_before: _builtins.bool,
                 config_match: _builtins.str,
                 config_operation_type: _builtins.str,
                 config_operation_types: Sequence[_builtins.str],
                 config_project: _builtins.str,
                 config_providers: Sequence[_builtins.str],
                 config_schedule: _builtins.str,
                 config_schedule_type: _builtins.str,
                 config_service_id: _builtins.str,
                 disabled: _builtins.bool,
                 event_processors: Sequence['outputs.GetEventTriggersResultEventProcessorResult'],
                 function_id: _builtins.str,
                 function_name: _builtins.str,
                 name: _builtins.str,
                 trigger_id: _builtins.str,
                 type: _builtins.str,
                 unordered: _builtins.bool):
        """
        :param _builtins.str config_collection: The name of the MongoDB collection that the trigger watches for change events.
        :param _builtins.str config_database: The name of the MongoDB database to watch.
        :param _builtins.bool config_full_document: If true, indicates that `UPDATE` change events should include the most current [majority-committed](https://docs.mongodb.com/manual/reference/read-concern-majority/) version of the modified document in the fullDocument field.
        :param _builtins.str config_match: A [$match](https://docs.mongodb.com/manual/reference/operator/aggregation/match/) expression document that MongoDB Realm includes in the underlying change stream pipeline for the trigger.
        :param _builtins.str config_operation_type: The [authentication operation type](https://docs.mongodb.com/realm/triggers/authentication-triggers/#std-label-authentication-event-operation-types) to listen for.
        :param Sequence[_builtins.str] config_operation_types: The [database event operation types](https://docs.mongodb.com/realm/triggers/database-triggers/#std-label-database-events) to listen for.
        :param _builtins.str config_project: A [$project](https://docs.mongodb.com/manual/reference/operator/aggregation/project/) expression document that Realm uses to filter the fields that appear in change event objects.
        :param Sequence[_builtins.str] config_providers: A list of one or more [authentication provider](https://docs.mongodb.com/realm/authentication/providers/) id values. The trigger will only listen for authentication events produced by these providers.
        :param _builtins.str config_schedule: A [cron expression](https://docs.mongodb.com/realm/triggers/cron-expressions/) that defines the trigger schedule.
        :param _builtins.str config_service_id: The ID of the MongoDB Service associated with the trigger.
        :param _builtins.bool disabled: Status of a trigger.
        :param Sequence['GetEventTriggersResultEventProcessorArgs'] event_processors: An object where each field name is an event processor ID and each value is an object that configures its corresponding event processor.
        :param _builtins.str function_id: The ID of the function associated with the trigger.
        :param _builtins.str function_name: The name of the function associated with the trigger.
        :param _builtins.str name: The name of the trigger.
        :param _builtins.str type: The type of the trigger. Possible Values: `DATABASE`, `AUTHENTICATION`
        :param _builtins.bool unordered: Sort order for `DATABASE` type.
        """
        pulumi.set(__self__, "config_collection", config_collection)
        pulumi.set(__self__, "config_database", config_database)
        pulumi.set(__self__, "config_full_document", config_full_document)
        pulumi.set(__self__, "config_full_document_before", config_full_document_before)
        pulumi.set(__self__, "config_match", config_match)
        pulumi.set(__self__, "config_operation_type", config_operation_type)
        pulumi.set(__self__, "config_operation_types", config_operation_types)
        pulumi.set(__self__, "config_project", config_project)
        pulumi.set(__self__, "config_providers", config_providers)
        pulumi.set(__self__, "config_schedule", config_schedule)
        pulumi.set(__self__, "config_schedule_type", config_schedule_type)
        pulumi.set(__self__, "config_service_id", config_service_id)
        pulumi.set(__self__, "disabled", disabled)
        pulumi.set(__self__, "event_processors", event_processors)
        pulumi.set(__self__, "function_id", function_id)
        pulumi.set(__self__, "function_name", function_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "trigger_id", trigger_id)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "unordered", unordered)

    @_builtins.property
    @pulumi.getter(name="configCollection")
    def config_collection(self) -> _builtins.str:
        """
        The name of the MongoDB collection that the trigger watches for change events.
        """
        return pulumi.get(self, "config_collection")

    @_builtins.property
    @pulumi.getter(name="configDatabase")
    def config_database(self) -> _builtins.str:
        """
        The name of the MongoDB database to watch.
        """
        return pulumi.get(self, "config_database")

    @_builtins.property
    @pulumi.getter(name="configFullDocument")
    def config_full_document(self) -> _builtins.bool:
        """
        If true, indicates that `UPDATE` change events should include the most current [majority-committed](https://docs.mongodb.com/manual/reference/read-concern-majority/) version of the modified document in the fullDocument field.
        """
        return pulumi.get(self, "config_full_document")

    @_builtins.property
    @pulumi.getter(name="configFullDocumentBefore")
    def config_full_document_before(self) -> _builtins.bool:
        return pulumi.get(self, "config_full_document_before")

    @_builtins.property
    @pulumi.getter(name="configMatch")
    def config_match(self) -> _builtins.str:
        """
        A [$match](https://docs.mongodb.com/manual/reference/operator/aggregation/match/) expression document that MongoDB Realm includes in the underlying change stream pipeline for the trigger.
        """
        return pulumi.get(self, "config_match")

    @_builtins.property
    @pulumi.getter(name="configOperationType")
    def config_operation_type(self) -> _builtins.str:
        """
        The [authentication operation type](https://docs.mongodb.com/realm/triggers/authentication-triggers/#std-label-authentication-event-operation-types) to listen for.
        """
        return pulumi.get(self, "config_operation_type")

    @_builtins.property
    @pulumi.getter(name="configOperationTypes")
    def config_operation_types(self) -> Sequence[_builtins.str]:
        """
        The [database event operation types](https://docs.mongodb.com/realm/triggers/database-triggers/#std-label-database-events) to listen for.
        """
        return pulumi.get(self, "config_operation_types")

    @_builtins.property
    @pulumi.getter(name="configProject")
    def config_project(self) -> _builtins.str:
        """
        A [$project](https://docs.mongodb.com/manual/reference/operator/aggregation/project/) expression document that Realm uses to filter the fields that appear in change event objects.
        """
        return pulumi.get(self, "config_project")

    @_builtins.property
    @pulumi.getter(name="configProviders")
    def config_providers(self) -> Sequence[_builtins.str]:
        """
        A list of one or more [authentication provider](https://docs.mongodb.com/realm/authentication/providers/) id values. The trigger will only listen for authentication events produced by these providers.
        """
        return pulumi.get(self, "config_providers")

    @_builtins.property
    @pulumi.getter(name="configSchedule")
    def config_schedule(self) -> _builtins.str:
        """
        A [cron expression](https://docs.mongodb.com/realm/triggers/cron-expressions/) that defines the trigger schedule.
        """
        return pulumi.get(self, "config_schedule")

    @_builtins.property
    @pulumi.getter(name="configScheduleType")
    def config_schedule_type(self) -> _builtins.str:
        return pulumi.get(self, "config_schedule_type")

    @_builtins.property
    @pulumi.getter(name="configServiceId")
    def config_service_id(self) -> _builtins.str:
        """
        The ID of the MongoDB Service associated with the trigger.
        """
        return pulumi.get(self, "config_service_id")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> _builtins.bool:
        """
        Status of a trigger.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="eventProcessors")
    def event_processors(self) -> Sequence['outputs.GetEventTriggersResultEventProcessorResult']:
        """
        An object where each field name is an event processor ID and each value is an object that configures its corresponding event processor.
        """
        return pulumi.get(self, "event_processors")

    @_builtins.property
    @pulumi.getter(name="functionId")
    def function_id(self) -> _builtins.str:
        """
        The ID of the function associated with the trigger.
        """
        return pulumi.get(self, "function_id")

    @_builtins.property
    @pulumi.getter(name="functionName")
    def function_name(self) -> _builtins.str:
        """
        The name of the function associated with the trigger.
        """
        return pulumi.get(self, "function_name")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the trigger.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="triggerId")
    def trigger_id(self) -> _builtins.str:
        return pulumi.get(self, "trigger_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the trigger. Possible Values: `DATABASE`, `AUTHENTICATION`
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def unordered(self) -> _builtins.bool:
        """
        Sort order for `DATABASE` type.
        """
        return pulumi.get(self, "unordered")


@pulumi.output_type
class GetEventTriggersResultEventProcessorResult(dict):
    def __init__(__self__, *,
                 aws_eventbridges: Sequence['outputs.GetEventTriggersResultEventProcessorAwsEventbridgeResult']):
        pulumi.set(__self__, "aws_eventbridges", aws_eventbridges)

    @_builtins.property
    @pulumi.getter(name="awsEventbridges")
    def aws_eventbridges(self) -> Sequence['outputs.GetEventTriggersResultEventProcessorAwsEventbridgeResult']:
        return pulumi.get(self, "aws_eventbridges")


@pulumi.output_type
class GetEventTriggersResultEventProcessorAwsEventbridgeResult(dict):
    def __init__(__self__, *,
                 config_account_id: _builtins.str,
                 config_region: _builtins.str):
        """
        :param _builtins.str config_account_id: AWS Account ID.
        :param _builtins.str config_region: Region of AWS Account.
        """
        pulumi.set(__self__, "config_account_id", config_account_id)
        pulumi.set(__self__, "config_region", config_region)

    @_builtins.property
    @pulumi.getter(name="configAccountId")
    def config_account_id(self) -> _builtins.str:
        """
        AWS Account ID.
        """
        return pulumi.get(self, "config_account_id")

    @_builtins.property
    @pulumi.getter(name="configRegion")
    def config_region(self) -> _builtins.str:
        """
        Region of AWS Account.
        """
        return pulumi.get(self, "config_region")


@pulumi.output_type
class GetFederatedDatabaseInstanceCloudProviderConfigResult(dict):
    def __init__(__self__, *,
                 aws: Sequence['outputs.GetFederatedDatabaseInstanceCloudProviderConfigAwResult'],
                 azures: Sequence['outputs.GetFederatedDatabaseInstanceCloudProviderConfigAzureResult']):
        pulumi.set(__self__, "aws", aws)
        pulumi.set(__self__, "azures", azures)

    @_builtins.property
    @pulumi.getter
    def aws(self) -> Sequence['outputs.GetFederatedDatabaseInstanceCloudProviderConfigAwResult']:
        return pulumi.get(self, "aws")

    @_builtins.property
    @pulumi.getter
    def azures(self) -> Sequence['outputs.GetFederatedDatabaseInstanceCloudProviderConfigAzureResult']:
        return pulumi.get(self, "azures")


@pulumi.output_type
class GetFederatedDatabaseInstanceCloudProviderConfigAwResult(dict):
    def __init__(__self__, *,
                 external_id: _builtins.str,
                 iam_assumed_role_arn: _builtins.str,
                 iam_user_arn: _builtins.str,
                 role_id: _builtins.str,
                 test_s3_bucket: Optional[_builtins.str] = None):
        """
        :param _builtins.str external_id: Unique identifier associated with the IAM Role that the Federated Database Instance assumes when accessing the data stores.
        :param _builtins.str iam_assumed_role_arn: Amazon Resource Name (ARN) of the IAM Role that the Federated Database Instance assumes when accessing S3 Bucket data stores. The IAM Role must support the following actions against each S3 bucket:
               * `s3:GetObject`
               * `s3:ListBucket`
               * `s3:GetObjectVersion`
        :param _builtins.str iam_user_arn: Amazon Resource Name (ARN) of the user that the Federated Database Instance assumes when accessing S3 Bucket data stores.
        :param _builtins.str role_id: Unique identifier of the role that the Federated Database Instance can use to access the data stores.
        """
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "iam_assumed_role_arn", iam_assumed_role_arn)
        pulumi.set(__self__, "iam_user_arn", iam_user_arn)
        pulumi.set(__self__, "role_id", role_id)
        if test_s3_bucket is not None:
            pulumi.set(__self__, "test_s3_bucket", test_s3_bucket)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> _builtins.str:
        """
        Unique identifier associated with the IAM Role that the Federated Database Instance assumes when accessing the data stores.
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="iamAssumedRoleArn")
    def iam_assumed_role_arn(self) -> _builtins.str:
        """
        Amazon Resource Name (ARN) of the IAM Role that the Federated Database Instance assumes when accessing S3 Bucket data stores. The IAM Role must support the following actions against each S3 bucket:
        * `s3:GetObject`
        * `s3:ListBucket`
        * `s3:GetObjectVersion`
        """
        return pulumi.get(self, "iam_assumed_role_arn")

    @_builtins.property
    @pulumi.getter(name="iamUserArn")
    def iam_user_arn(self) -> _builtins.str:
        """
        Amazon Resource Name (ARN) of the user that the Federated Database Instance assumes when accessing S3 Bucket data stores.
        """
        return pulumi.get(self, "iam_user_arn")

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> _builtins.str:
        """
        Unique identifier of the role that the Federated Database Instance can use to access the data stores.
        """
        return pulumi.get(self, "role_id")

    @_builtins.property
    @pulumi.getter(name="testS3Bucket")
    def test_s3_bucket(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "test_s3_bucket")


@pulumi.output_type
class GetFederatedDatabaseInstanceCloudProviderConfigAzureResult(dict):
    def __init__(__self__, *,
                 atlas_app_id: _builtins.str,
                 role_id: _builtins.str,
                 service_principal_id: _builtins.str,
                 tenant_id: _builtins.str):
        """
        :param _builtins.str role_id: Unique identifier of the role that the Federated Database Instance can use to access the data stores.
        :param _builtins.str service_principal_id: Unique identifier of the Azure service principal that the Federated Database instance uses to access Azure Blob Storage.
        :param _builtins.str tenant_id: Unique identifier of the Azure Active Directory tenant where the service principal resides.
        """
        pulumi.set(__self__, "atlas_app_id", atlas_app_id)
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "service_principal_id", service_principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="atlasAppId")
    def atlas_app_id(self) -> _builtins.str:
        return pulumi.get(self, "atlas_app_id")

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> _builtins.str:
        """
        Unique identifier of the role that the Federated Database Instance can use to access the data stores.
        """
        return pulumi.get(self, "role_id")

    @_builtins.property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> _builtins.str:
        """
        Unique identifier of the Azure service principal that the Federated Database instance uses to access Azure Blob Storage.
        """
        return pulumi.get(self, "service_principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        Unique identifier of the Azure Active Directory tenant where the service principal resides.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetFederatedDatabaseInstanceDataProcessRegionResult(dict):
    def __init__(__self__, *,
                 cloud_provider: _builtins.str,
                 region: _builtins.str):
        """
        :param _builtins.str cloud_provider: Name of the cloud service provider. Supported providers: `AWS`, `AZURE`.
        :param _builtins.str region: Name of the region to which the Federated Instance routes client connections for data processing.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> _builtins.str:
        """
        Name of the cloud service provider. Supported providers: `AWS`, `AZURE`.
        """
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Name of the region to which the Federated Instance routes client connections for data processing.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetFederatedDatabaseInstanceStorageDatabaseResult(dict):
    def __init__(__self__, *,
                 collections: Sequence['outputs.GetFederatedDatabaseInstanceStorageDatabaseCollectionResult'],
                 max_wildcard_collections: _builtins.int,
                 name: _builtins.str,
                 views: Sequence['outputs.GetFederatedDatabaseInstanceStorageDatabaseViewResult']):
        """
        :param _builtins.str name: Name of the Atlas Federated Database Instance.
        """
        pulumi.set(__self__, "collections", collections)
        pulumi.set(__self__, "max_wildcard_collections", max_wildcard_collections)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "views", views)

    @_builtins.property
    @pulumi.getter
    def collections(self) -> Sequence['outputs.GetFederatedDatabaseInstanceStorageDatabaseCollectionResult']:
        return pulumi.get(self, "collections")

    @_builtins.property
    @pulumi.getter(name="maxWildcardCollections")
    def max_wildcard_collections(self) -> _builtins.int:
        return pulumi.get(self, "max_wildcard_collections")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def views(self) -> Sequence['outputs.GetFederatedDatabaseInstanceStorageDatabaseViewResult']:
        return pulumi.get(self, "views")


@pulumi.output_type
class GetFederatedDatabaseInstanceStorageDatabaseCollectionResult(dict):
    def __init__(__self__, *,
                 data_sources: Sequence['outputs.GetFederatedDatabaseInstanceStorageDatabaseCollectionDataSourceResult'],
                 name: _builtins.str):
        """
        :param _builtins.str name: Name of the Atlas Federated Database Instance.
        """
        pulumi.set(__self__, "data_sources", data_sources)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Sequence['outputs.GetFederatedDatabaseInstanceStorageDatabaseCollectionDataSourceResult']:
        return pulumi.get(self, "data_sources")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetFederatedDatabaseInstanceStorageDatabaseCollectionDataSourceResult(dict):
    def __init__(__self__, *,
                 allow_insecure: _builtins.bool,
                 collection: _builtins.str,
                 collection_regex: _builtins.str,
                 database: _builtins.str,
                 database_regex: _builtins.str,
                 dataset_name: _builtins.str,
                 default_format: _builtins.str,
                 path: _builtins.str,
                 provenance_field_name: _builtins.str,
                 store_name: _builtins.str,
                 urls: Sequence[_builtins.str]):
        pulumi.set(__self__, "allow_insecure", allow_insecure)
        pulumi.set(__self__, "collection", collection)
        pulumi.set(__self__, "collection_regex", collection_regex)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "database_regex", database_regex)
        pulumi.set(__self__, "dataset_name", dataset_name)
        pulumi.set(__self__, "default_format", default_format)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "provenance_field_name", provenance_field_name)
        pulumi.set(__self__, "store_name", store_name)
        pulumi.set(__self__, "urls", urls)

    @_builtins.property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> _builtins.bool:
        return pulumi.get(self, "allow_insecure")

    @_builtins.property
    @pulumi.getter
    def collection(self) -> _builtins.str:
        return pulumi.get(self, "collection")

    @_builtins.property
    @pulumi.getter(name="collectionRegex")
    def collection_regex(self) -> _builtins.str:
        return pulumi.get(self, "collection_regex")

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="databaseRegex")
    def database_regex(self) -> _builtins.str:
        return pulumi.get(self, "database_regex")

    @_builtins.property
    @pulumi.getter(name="datasetName")
    def dataset_name(self) -> _builtins.str:
        return pulumi.get(self, "dataset_name")

    @_builtins.property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> _builtins.str:
        return pulumi.get(self, "default_format")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="provenanceFieldName")
    def provenance_field_name(self) -> _builtins.str:
        return pulumi.get(self, "provenance_field_name")

    @_builtins.property
    @pulumi.getter(name="storeName")
    def store_name(self) -> _builtins.str:
        return pulumi.get(self, "store_name")

    @_builtins.property
    @pulumi.getter
    def urls(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "urls")


@pulumi.output_type
class GetFederatedDatabaseInstanceStorageDatabaseViewResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 pipeline: _builtins.str,
                 source: _builtins.str):
        """
        :param _builtins.str name: Name of the Atlas Federated Database Instance.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pipeline", pipeline)
        pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def pipeline(self) -> _builtins.str:
        return pulumi.get(self, "pipeline")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        return pulumi.get(self, "source")


@pulumi.output_type
class GetFederatedDatabaseInstanceStorageStoreResult(dict):
    def __init__(__self__, *,
                 additional_storage_classes: Sequence[_builtins.str],
                 allow_insecure: _builtins.bool,
                 bucket: _builtins.str,
                 cluster_name: _builtins.str,
                 default_format: _builtins.str,
                 delimiter: _builtins.str,
                 include_tags: _builtins.bool,
                 name: _builtins.str,
                 prefix: _builtins.str,
                 project_id: _builtins.str,
                 provider: _builtins.str,
                 public: _builtins.str,
                 read_preferences: Sequence['outputs.GetFederatedDatabaseInstanceStorageStoreReadPreferenceResult'],
                 region: _builtins.str,
                 urls: Sequence[_builtins.str]):
        """
        :param _builtins.str name: Name of the Atlas Federated Database Instance.
        :param _builtins.str project_id: The unique ID for the project to create a Federated Database Instance.
        :param _builtins.str region: Name of the region to which the Federated Instance routes client connections for data processing.
        """
        pulumi.set(__self__, "additional_storage_classes", additional_storage_classes)
        pulumi.set(__self__, "allow_insecure", allow_insecure)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "default_format", default_format)
        pulumi.set(__self__, "delimiter", delimiter)
        pulumi.set(__self__, "include_tags", include_tags)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "public", public)
        pulumi.set(__self__, "read_preferences", read_preferences)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "urls", urls)

    @_builtins.property
    @pulumi.getter(name="additionalStorageClasses")
    def additional_storage_classes(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "additional_storage_classes")

    @_builtins.property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> _builtins.bool:
        return pulumi.get(self, "allow_insecure")

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> _builtins.str:
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> _builtins.str:
        return pulumi.get(self, "default_format")

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> _builtins.str:
        return pulumi.get(self, "delimiter")

    @_builtins.property
    @pulumi.getter(name="includeTags")
    def include_tags(self) -> _builtins.bool:
        return pulumi.get(self, "include_tags")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> _builtins.str:
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The unique ID for the project to create a Federated Database Instance.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> _builtins.str:
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def public(self) -> _builtins.str:
        return pulumi.get(self, "public")

    @_builtins.property
    @pulumi.getter(name="readPreferences")
    def read_preferences(self) -> Sequence['outputs.GetFederatedDatabaseInstanceStorageStoreReadPreferenceResult']:
        return pulumi.get(self, "read_preferences")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Name of the region to which the Federated Instance routes client connections for data processing.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def urls(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "urls")


@pulumi.output_type
class GetFederatedDatabaseInstanceStorageStoreReadPreferenceResult(dict):
    def __init__(__self__, *,
                 max_staleness_seconds: _builtins.int,
                 mode: _builtins.str,
                 tag_sets: Sequence['outputs.GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetResult']):
        pulumi.set(__self__, "max_staleness_seconds", max_staleness_seconds)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "tag_sets", tag_sets)

    @_builtins.property
    @pulumi.getter(name="maxStalenessSeconds")
    def max_staleness_seconds(self) -> _builtins.int:
        return pulumi.get(self, "max_staleness_seconds")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="tagSets")
    def tag_sets(self) -> Sequence['outputs.GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetResult']:
        return pulumi.get(self, "tag_sets")


@pulumi.output_type
class GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetResult(dict):
    def __init__(__self__, *,
                 tags: Sequence['outputs.GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTagResult']):
        pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTagResult']:
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTagResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: Name of the Atlas Federated Database Instance.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultResult(dict):
    def __init__(__self__, *,
                 cloud_provider_configs: Sequence['outputs.GetFederatedDatabaseInstancesResultCloudProviderConfigResult'],
                 data_process_regions: Sequence['outputs.GetFederatedDatabaseInstancesResultDataProcessRegionResult'],
                 hostnames: Sequence[_builtins.str],
                 name: _builtins.str,
                 project_id: _builtins.str,
                 state: _builtins.str,
                 storage_databases: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageDatabaseResult'],
                 storage_stores: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageStoreResult']):
        """
        :param Sequence[_builtins.str] hostnames: The list of hostnames assigned to the Federated Database Instance. Each string in the array is a hostname assigned to the Federated Database Instance.
        :param _builtins.str project_id: The unique ID for the project to create a Federated Database Instance.
        :param _builtins.str state: Current state of the Federated Database Instance:
               * `ACTIVE` - The Federated Database Instance is active and verified. You can query the data stores associated with the Federated Database Instance.
               * `DELETED` - The Federated Database Instance was deleted.
        :param Sequence['GetFederatedDatabaseInstancesResultStorageDatabaseArgs'] storage_databases: Configuration details for mapping each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [databases](https://www.mongodb.com/docs/atlas/data-federation/config/config-oa/#databases). An empty object indicates that the Federated Database Instance has no mapping configuration for any data store.
               * `storage_databases.#.name` - Name of the database to which the Federated Database Instance maps the data contained in the data store.
               * `storage_databases.#.collections` -     Array of objects where each object represents a collection and data sources that map to a [stores](https://www.mongodb.com/docs/atlas/data-federation/config/config-oa/#stores) data store.
               * `storage_databases.#.collections.#.name` - Name of the collection.
               * `storage_databases.#.collections.#.data_sources` -     Array of objects where each object represents a stores data store to map with the collection.
               * `storage_databases.#.collections.#.data_sources.#.store_name` -     Name of a data store to map to the `<collection>`. Must match the name of an object in the stores array.
               * `storage_databases.#.collections.#.data_sources.#.dataset_name` -     Human-readable label that identifies the dataset that Atlas generates for an ingestion pipeline run or Online Archive.
               * `storage_databases.#.collections.#.data_sources.#.default_format` - Default format that Federated Database assumes if it encounters a file without an extension while searching the storeName.
               * `storage_databases.#.collections.#.data_sources.#.path` - File path that controls how MongoDB Cloud searches for and parses files in the storeName before mapping them to a collection. Specify / to capture all files and folders from the prefix path.
               * `storage_databases.#.collections.#.data_sources.#.database` - Human-readable label that identifies the database, which contains the collection in the cluster.
               * `storage_databases.#.collections.#.data_sources.#.allow_insecure` - Flag that validates the scheme in the specified URLs. If true, allows insecure HTTP scheme, doesn't verify the server's certificate chain and hostname, and accepts any certificate with any hostname presented by the server. If false, allows secure HTTPS scheme only.
               * `storage_databases.#.collections.#.data_sources.#.database_regex` - Regex pattern to use for creating the wildcard database.
               * `storage_databases.#.collections.#.data_sources.#.collection` - Human-readable label that identifies the collection in the database.
               * `storage_databases.#.collections.#.data_sources.#.collection_regex` - Regex pattern to use for creating the wildcard (*) collection.
               * `storage_databases.#.collections.#.data_sources.#.provenance_field_name` - Name for the field that includes the provenance of the documents in the results.
               * `storage_databases.#.collections.#.data_sources.#.storeName` - Human-readable label that identifies the data store that MongoDB Cloud maps to the collection.
               * `storage_databases.#.collections.#.data_sources.#.urls` - URLs of the publicly accessible data files. You can't specify URLs that require authentication.
               * `storage_databases.#.views` -     Array of objects where each object represents an [aggregation pipeline](https://docs.mongodb.com/manual/core/aggregation-pipeline/#id1) on a collection. To learn more about views, see [Views](https://docs.mongodb.com/manual/core/views/).
               * `storage_databases.#.views.#.name` - Name of the view.
               * `storage_databases.#.views.#.source` -  Name of the source collection for the view.
               * `storage_databases.#.views.#.pipeline`- Aggregation pipeline stage(s) to apply to the source collection.
        :param Sequence['GetFederatedDatabaseInstancesResultStorageStoreArgs'] storage_stores: Each object in the array represents a data store. Federated Database uses the `storage.databases` configuration details to map data in each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [stores](https://www.mongodb.com/docs/atlas/data-federation/config/config-oa/#stores). An empty object indicates that the Federated Database Instance has no configured data stores.
               * `storage_stores.#.name` - Name of the data store.
               * `storage_stores.#.provider` - Defines where the data is stored.
               * `storage_stores.#.region` - Name of the AWS region in which the S3 bucket is hosted.
               * `storage_stores.#.bucket` - Name of the AWS S3 bucket.
               * `storage_stores.#.prefix` - Prefix the Federated Database Instance applies when searching for files in the S3 bucket.
               * `storage_stores.#.delimiter` - The delimiter that separates `storage_databases.#.collections.#.data_sources.#.path` segments in the data store.
               * `storage_stores.#.include_tags` - Determines whether or not to use S3 tags on the files in the given path as additional partition attributes.
               * `storage_stores.#.cluster_name` - Human-readable label of the MongoDB Cloud cluster on which the store is based.
               * `storage_stores.#.allow_insecure` - Flag that validates the scheme in the specified URLs.
               * `storage_stores.#.public` - Flag that indicates whether the bucket is public.
               * `storage_stores.#.default_format` - Default format that Atlas Data Federation assumes if it encounters a file without an extension while searching the storeName.
               * `storage_stores.#.urls` - Comma-separated list of publicly accessible HTTP URLs where data is stored.
               * `storage_stores.#.read_preference` - MongoDB Cloud cluster read preference, which describes how to route read requests to the cluster.
               * `storage_stores.#.read_preference.maxStalenessSeconds` - Maximum replication lag, or staleness, for reads from secondaries.
               * `storage_stores.#.read_preference.mode` - Read preference mode that specifies to which replica set member to route the read requests.
               * `storage_stores.#.read_preference.tag_sets` - List that contains tag sets or tag specification documents.
               * `storage_stores.#.read_preference.tags` - List of all tags within a tag set
               * `storage_stores.#.read_preference.tags.name` - Human-readable label of the tag.
               * `storage_stores.#.read_preference.tags.value` - Value of the tag.
        """
        pulumi.set(__self__, "cloud_provider_configs", cloud_provider_configs)
        pulumi.set(__self__, "data_process_regions", data_process_regions)
        pulumi.set(__self__, "hostnames", hostnames)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "storage_databases", storage_databases)
        pulumi.set(__self__, "storage_stores", storage_stores)

    @_builtins.property
    @pulumi.getter(name="cloudProviderConfigs")
    def cloud_provider_configs(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultCloudProviderConfigResult']:
        return pulumi.get(self, "cloud_provider_configs")

    @_builtins.property
    @pulumi.getter(name="dataProcessRegions")
    def data_process_regions(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultDataProcessRegionResult']:
        return pulumi.get(self, "data_process_regions")

    @_builtins.property
    @pulumi.getter
    def hostnames(self) -> Sequence[_builtins.str]:
        """
        The list of hostnames assigned to the Federated Database Instance. Each string in the array is a hostname assigned to the Federated Database Instance.
        """
        return pulumi.get(self, "hostnames")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The unique ID for the project to create a Federated Database Instance.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        Current state of the Federated Database Instance:
        * `ACTIVE` - The Federated Database Instance is active and verified. You can query the data stores associated with the Federated Database Instance.
        * `DELETED` - The Federated Database Instance was deleted.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="storageDatabases")
    def storage_databases(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultStorageDatabaseResult']:
        """
        Configuration details for mapping each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [databases](https://www.mongodb.com/docs/atlas/data-federation/config/config-oa/#databases). An empty object indicates that the Federated Database Instance has no mapping configuration for any data store.
        * `storage_databases.#.name` - Name of the database to which the Federated Database Instance maps the data contained in the data store.
        * `storage_databases.#.collections` -     Array of objects where each object represents a collection and data sources that map to a [stores](https://www.mongodb.com/docs/atlas/data-federation/config/config-oa/#stores) data store.
        * `storage_databases.#.collections.#.name` - Name of the collection.
        * `storage_databases.#.collections.#.data_sources` -     Array of objects where each object represents a stores data store to map with the collection.
        * `storage_databases.#.collections.#.data_sources.#.store_name` -     Name of a data store to map to the `<collection>`. Must match the name of an object in the stores array.
        * `storage_databases.#.collections.#.data_sources.#.dataset_name` -     Human-readable label that identifies the dataset that Atlas generates for an ingestion pipeline run or Online Archive.
        * `storage_databases.#.collections.#.data_sources.#.default_format` - Default format that Federated Database assumes if it encounters a file without an extension while searching the storeName.
        * `storage_databases.#.collections.#.data_sources.#.path` - File path that controls how MongoDB Cloud searches for and parses files in the storeName before mapping them to a collection. Specify / to capture all files and folders from the prefix path.
        * `storage_databases.#.collections.#.data_sources.#.database` - Human-readable label that identifies the database, which contains the collection in the cluster.
        * `storage_databases.#.collections.#.data_sources.#.allow_insecure` - Flag that validates the scheme in the specified URLs. If true, allows insecure HTTP scheme, doesn't verify the server's certificate chain and hostname, and accepts any certificate with any hostname presented by the server. If false, allows secure HTTPS scheme only.
        * `storage_databases.#.collections.#.data_sources.#.database_regex` - Regex pattern to use for creating the wildcard database.
        * `storage_databases.#.collections.#.data_sources.#.collection` - Human-readable label that identifies the collection in the database.
        * `storage_databases.#.collections.#.data_sources.#.collection_regex` - Regex pattern to use for creating the wildcard (*) collection.
        * `storage_databases.#.collections.#.data_sources.#.provenance_field_name` - Name for the field that includes the provenance of the documents in the results.
        * `storage_databases.#.collections.#.data_sources.#.storeName` - Human-readable label that identifies the data store that MongoDB Cloud maps to the collection.
        * `storage_databases.#.collections.#.data_sources.#.urls` - URLs of the publicly accessible data files. You can't specify URLs that require authentication.
        * `storage_databases.#.views` -     Array of objects where each object represents an [aggregation pipeline](https://docs.mongodb.com/manual/core/aggregation-pipeline/#id1) on a collection. To learn more about views, see [Views](https://docs.mongodb.com/manual/core/views/).
        * `storage_databases.#.views.#.name` - Name of the view.
        * `storage_databases.#.views.#.source` -  Name of the source collection for the view.
        * `storage_databases.#.views.#.pipeline`- Aggregation pipeline stage(s) to apply to the source collection.
        """
        return pulumi.get(self, "storage_databases")

    @_builtins.property
    @pulumi.getter(name="storageStores")
    def storage_stores(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultStorageStoreResult']:
        """
        Each object in the array represents a data store. Federated Database uses the `storage.databases` configuration details to map data in each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [stores](https://www.mongodb.com/docs/atlas/data-federation/config/config-oa/#stores). An empty object indicates that the Federated Database Instance has no configured data stores.
        * `storage_stores.#.name` - Name of the data store.
        * `storage_stores.#.provider` - Defines where the data is stored.
        * `storage_stores.#.region` - Name of the AWS region in which the S3 bucket is hosted.
        * `storage_stores.#.bucket` - Name of the AWS S3 bucket.
        * `storage_stores.#.prefix` - Prefix the Federated Database Instance applies when searching for files in the S3 bucket.
        * `storage_stores.#.delimiter` - The delimiter that separates `storage_databases.#.collections.#.data_sources.#.path` segments in the data store.
        * `storage_stores.#.include_tags` - Determines whether or not to use S3 tags on the files in the given path as additional partition attributes.
        * `storage_stores.#.cluster_name` - Human-readable label of the MongoDB Cloud cluster on which the store is based.
        * `storage_stores.#.allow_insecure` - Flag that validates the scheme in the specified URLs.
        * `storage_stores.#.public` - Flag that indicates whether the bucket is public.
        * `storage_stores.#.default_format` - Default format that Atlas Data Federation assumes if it encounters a file without an extension while searching the storeName.
        * `storage_stores.#.urls` - Comma-separated list of publicly accessible HTTP URLs where data is stored.
        * `storage_stores.#.read_preference` - MongoDB Cloud cluster read preference, which describes how to route read requests to the cluster.
        * `storage_stores.#.read_preference.maxStalenessSeconds` - Maximum replication lag, or staleness, for reads from secondaries.
        * `storage_stores.#.read_preference.mode` - Read preference mode that specifies to which replica set member to route the read requests.
        * `storage_stores.#.read_preference.tag_sets` - List that contains tag sets or tag specification documents.
        * `storage_stores.#.read_preference.tags` - List of all tags within a tag set
        * `storage_stores.#.read_preference.tags.name` - Human-readable label of the tag.
        * `storage_stores.#.read_preference.tags.value` - Value of the tag.
        """
        return pulumi.get(self, "storage_stores")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultCloudProviderConfigResult(dict):
    def __init__(__self__, *,
                 aws: Sequence['outputs.GetFederatedDatabaseInstancesResultCloudProviderConfigAwResult'],
                 azures: Sequence['outputs.GetFederatedDatabaseInstancesResultCloudProviderConfigAzureResult']):
        pulumi.set(__self__, "aws", aws)
        pulumi.set(__self__, "azures", azures)

    @_builtins.property
    @pulumi.getter
    def aws(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultCloudProviderConfigAwResult']:
        return pulumi.get(self, "aws")

    @_builtins.property
    @pulumi.getter
    def azures(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultCloudProviderConfigAzureResult']:
        return pulumi.get(self, "azures")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultCloudProviderConfigAwResult(dict):
    def __init__(__self__, *,
                 external_id: _builtins.str,
                 iam_assumed_role_arn: _builtins.str,
                 iam_user_arn: _builtins.str,
                 role_id: _builtins.str,
                 test_s3_bucket: Optional[_builtins.str] = None):
        """
        :param _builtins.str external_id: Unique identifier associated with the IAM Role that the Federated Database Instance assumes when accessing the data stores.
        :param _builtins.str iam_assumed_role_arn: Amazon Resource Name (ARN) of the IAM Role that the Federated Database Instance assumes when accessing S3 Bucket data stores. The IAM Role must support the following actions against each S3 bucket:
               * `s3:GetObject`
               * `s3:ListBucket`
               * `s3:GetObjectVersion`
        :param _builtins.str iam_user_arn: Amazon Resource Name (ARN) of the user that the Federated Database Instance assumes when accessing S3 Bucket data stores.
        :param _builtins.str role_id: Unique identifier of the role that the Federated Database Instance can use to access the data stores.
        """
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "iam_assumed_role_arn", iam_assumed_role_arn)
        pulumi.set(__self__, "iam_user_arn", iam_user_arn)
        pulumi.set(__self__, "role_id", role_id)
        if test_s3_bucket is not None:
            pulumi.set(__self__, "test_s3_bucket", test_s3_bucket)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> _builtins.str:
        """
        Unique identifier associated with the IAM Role that the Federated Database Instance assumes when accessing the data stores.
        """
        return pulumi.get(self, "external_id")

    @_builtins.property
    @pulumi.getter(name="iamAssumedRoleArn")
    def iam_assumed_role_arn(self) -> _builtins.str:
        """
        Amazon Resource Name (ARN) of the IAM Role that the Federated Database Instance assumes when accessing S3 Bucket data stores. The IAM Role must support the following actions against each S3 bucket:
        * `s3:GetObject`
        * `s3:ListBucket`
        * `s3:GetObjectVersion`
        """
        return pulumi.get(self, "iam_assumed_role_arn")

    @_builtins.property
    @pulumi.getter(name="iamUserArn")
    def iam_user_arn(self) -> _builtins.str:
        """
        Amazon Resource Name (ARN) of the user that the Federated Database Instance assumes when accessing S3 Bucket data stores.
        """
        return pulumi.get(self, "iam_user_arn")

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> _builtins.str:
        """
        Unique identifier of the role that the Federated Database Instance can use to access the data stores.
        """
        return pulumi.get(self, "role_id")

    @_builtins.property
    @pulumi.getter(name="testS3Bucket")
    def test_s3_bucket(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "test_s3_bucket")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultCloudProviderConfigAzureResult(dict):
    def __init__(__self__, *,
                 atlas_app_id: _builtins.str,
                 role_id: _builtins.str,
                 service_principal_id: _builtins.str,
                 tenant_id: _builtins.str):
        """
        :param _builtins.str role_id: Unique identifier of the role that the Federated Database Instance can use to access the data stores.
        :param _builtins.str service_principal_id: Unique identifier of the Azure service principal that the Federated Database instance uses to access Azure Blob Storage.
        :param _builtins.str tenant_id: Unique identifier of the Azure Active Directory tenant where the service principal resides.
        """
        pulumi.set(__self__, "atlas_app_id", atlas_app_id)
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "service_principal_id", service_principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="atlasAppId")
    def atlas_app_id(self) -> _builtins.str:
        return pulumi.get(self, "atlas_app_id")

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> _builtins.str:
        """
        Unique identifier of the role that the Federated Database Instance can use to access the data stores.
        """
        return pulumi.get(self, "role_id")

    @_builtins.property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> _builtins.str:
        """
        Unique identifier of the Azure service principal that the Federated Database instance uses to access Azure Blob Storage.
        """
        return pulumi.get(self, "service_principal_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        Unique identifier of the Azure Active Directory tenant where the service principal resides.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultDataProcessRegionResult(dict):
    def __init__(__self__, *,
                 cloud_provider: _builtins.str,
                 region: _builtins.str):
        """
        :param _builtins.str cloud_provider: Name of the cloud service provider. Supported providers: `AWS`, `AZURE`.
        :param _builtins.str region: Name of the region to which the Federated Instance routes client connections for data processing.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> _builtins.str:
        """
        Name of the cloud service provider. Supported providers: `AWS`, `AZURE`.
        """
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Name of the region to which the Federated Instance routes client connections for data processing.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultStorageDatabaseResult(dict):
    def __init__(__self__, *,
                 collections: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageDatabaseCollectionResult'],
                 max_wildcard_collections: _builtins.int,
                 name: _builtins.str,
                 views: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageDatabaseViewResult']):
        pulumi.set(__self__, "collections", collections)
        pulumi.set(__self__, "max_wildcard_collections", max_wildcard_collections)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "views", views)

    @_builtins.property
    @pulumi.getter
    def collections(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultStorageDatabaseCollectionResult']:
        return pulumi.get(self, "collections")

    @_builtins.property
    @pulumi.getter(name="maxWildcardCollections")
    def max_wildcard_collections(self) -> _builtins.int:
        return pulumi.get(self, "max_wildcard_collections")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def views(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultStorageDatabaseViewResult']:
        return pulumi.get(self, "views")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultStorageDatabaseCollectionResult(dict):
    def __init__(__self__, *,
                 data_sources: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageDatabaseCollectionDataSourceResult'],
                 name: _builtins.str):
        pulumi.set(__self__, "data_sources", data_sources)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultStorageDatabaseCollectionDataSourceResult']:
        return pulumi.get(self, "data_sources")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultStorageDatabaseCollectionDataSourceResult(dict):
    def __init__(__self__, *,
                 allow_insecure: _builtins.bool,
                 collection: _builtins.str,
                 collection_regex: _builtins.str,
                 database: _builtins.str,
                 database_regex: _builtins.str,
                 dataset_name: _builtins.str,
                 default_format: _builtins.str,
                 path: _builtins.str,
                 provenance_field_name: _builtins.str,
                 store_name: _builtins.str,
                 urls: Sequence[_builtins.str]):
        pulumi.set(__self__, "allow_insecure", allow_insecure)
        pulumi.set(__self__, "collection", collection)
        pulumi.set(__self__, "collection_regex", collection_regex)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "database_regex", database_regex)
        pulumi.set(__self__, "dataset_name", dataset_name)
        pulumi.set(__self__, "default_format", default_format)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "provenance_field_name", provenance_field_name)
        pulumi.set(__self__, "store_name", store_name)
        pulumi.set(__self__, "urls", urls)

    @_builtins.property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> _builtins.bool:
        return pulumi.get(self, "allow_insecure")

    @_builtins.property
    @pulumi.getter
    def collection(self) -> _builtins.str:
        return pulumi.get(self, "collection")

    @_builtins.property
    @pulumi.getter(name="collectionRegex")
    def collection_regex(self) -> _builtins.str:
        return pulumi.get(self, "collection_regex")

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="databaseRegex")
    def database_regex(self) -> _builtins.str:
        return pulumi.get(self, "database_regex")

    @_builtins.property
    @pulumi.getter(name="datasetName")
    def dataset_name(self) -> _builtins.str:
        return pulumi.get(self, "dataset_name")

    @_builtins.property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> _builtins.str:
        return pulumi.get(self, "default_format")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="provenanceFieldName")
    def provenance_field_name(self) -> _builtins.str:
        return pulumi.get(self, "provenance_field_name")

    @_builtins.property
    @pulumi.getter(name="storeName")
    def store_name(self) -> _builtins.str:
        return pulumi.get(self, "store_name")

    @_builtins.property
    @pulumi.getter
    def urls(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "urls")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultStorageDatabaseViewResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 pipeline: _builtins.str,
                 source: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pipeline", pipeline)
        pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def pipeline(self) -> _builtins.str:
        return pulumi.get(self, "pipeline")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        return pulumi.get(self, "source")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultStorageStoreResult(dict):
    def __init__(__self__, *,
                 additional_storage_classes: Sequence[_builtins.str],
                 allow_insecure: _builtins.bool,
                 bucket: _builtins.str,
                 cluster_name: _builtins.str,
                 default_format: _builtins.str,
                 delimiter: _builtins.str,
                 include_tags: _builtins.bool,
                 name: _builtins.str,
                 prefix: _builtins.str,
                 project_id: _builtins.str,
                 provider: _builtins.str,
                 public: _builtins.str,
                 read_preferences: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceResult'],
                 region: _builtins.str,
                 urls: Sequence[_builtins.str]):
        """
        :param _builtins.str project_id: The unique ID for the project to create a Federated Database Instance.
        :param _builtins.str region: Name of the region to which the Federated Instance routes client connections for data processing.
        """
        pulumi.set(__self__, "additional_storage_classes", additional_storage_classes)
        pulumi.set(__self__, "allow_insecure", allow_insecure)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "default_format", default_format)
        pulumi.set(__self__, "delimiter", delimiter)
        pulumi.set(__self__, "include_tags", include_tags)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "public", public)
        pulumi.set(__self__, "read_preferences", read_preferences)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "urls", urls)

    @_builtins.property
    @pulumi.getter(name="additionalStorageClasses")
    def additional_storage_classes(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "additional_storage_classes")

    @_builtins.property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> _builtins.bool:
        return pulumi.get(self, "allow_insecure")

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> _builtins.str:
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> _builtins.str:
        return pulumi.get(self, "default_format")

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> _builtins.str:
        return pulumi.get(self, "delimiter")

    @_builtins.property
    @pulumi.getter(name="includeTags")
    def include_tags(self) -> _builtins.bool:
        return pulumi.get(self, "include_tags")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> _builtins.str:
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The unique ID for the project to create a Federated Database Instance.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> _builtins.str:
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def public(self) -> _builtins.str:
        return pulumi.get(self, "public")

    @_builtins.property
    @pulumi.getter(name="readPreferences")
    def read_preferences(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceResult']:
        return pulumi.get(self, "read_preferences")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Name of the region to which the Federated Instance routes client connections for data processing.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def urls(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "urls")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceResult(dict):
    def __init__(__self__, *,
                 max_staleness_seconds: _builtins.int,
                 mode: _builtins.str,
                 tag_sets: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetResult']):
        pulumi.set(__self__, "max_staleness_seconds", max_staleness_seconds)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "tag_sets", tag_sets)

    @_builtins.property
    @pulumi.getter(name="maxStalenessSeconds")
    def max_staleness_seconds(self) -> _builtins.int:
        return pulumi.get(self, "max_staleness_seconds")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="tagSets")
    def tag_sets(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetResult']:
        return pulumi.get(self, "tag_sets")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetResult(dict):
    def __init__(__self__, *,
                 tags: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetTagResult']):
        pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetTagResult']:
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetTagResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetFederatedQueryLimitsResultResult(dict):
    def __init__(__self__, *,
                 current_usage: _builtins.int,
                 default_limit: _builtins.int,
                 last_modified_date: _builtins.str,
                 limit_name: _builtins.str,
                 maximum_limit: _builtins.int,
                 overrun_policy: _builtins.str,
                 project_id: _builtins.str,
                 tenant_name: _builtins.str,
                 value: _builtins.int):
        """
        :param _builtins.int current_usage: Amount that indicates the current usage of the limit.
        :param _builtins.int default_limit: Default value of the limit.
               * `lastModifiedDate` - Only used for Data Federation limits. Timestamp that indicates when this usage limit was last modified. This field uses the ISO 8601 timestamp format in UTC.
               * `maximumLimit` - Maximum value of the limit.
        :param _builtins.str project_id: The unique ID for the project to create a Federated Database Instance.
        :param _builtins.str tenant_name: Name of the Atlas Federated Database Instance.
        """
        pulumi.set(__self__, "current_usage", current_usage)
        pulumi.set(__self__, "default_limit", default_limit)
        pulumi.set(__self__, "last_modified_date", last_modified_date)
        pulumi.set(__self__, "limit_name", limit_name)
        pulumi.set(__self__, "maximum_limit", maximum_limit)
        pulumi.set(__self__, "overrun_policy", overrun_policy)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "tenant_name", tenant_name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="currentUsage")
    def current_usage(self) -> _builtins.int:
        """
        Amount that indicates the current usage of the limit.
        """
        return pulumi.get(self, "current_usage")

    @_builtins.property
    @pulumi.getter(name="defaultLimit")
    def default_limit(self) -> _builtins.int:
        """
        Default value of the limit.
        * `lastModifiedDate` - Only used for Data Federation limits. Timestamp that indicates when this usage limit was last modified. This field uses the ISO 8601 timestamp format in UTC.
        * `maximumLimit` - Maximum value of the limit.
        """
        return pulumi.get(self, "default_limit")

    @_builtins.property
    @pulumi.getter(name="lastModifiedDate")
    def last_modified_date(self) -> _builtins.str:
        return pulumi.get(self, "last_modified_date")

    @_builtins.property
    @pulumi.getter(name="limitName")
    def limit_name(self) -> _builtins.str:
        return pulumi.get(self, "limit_name")

    @_builtins.property
    @pulumi.getter(name="maximumLimit")
    def maximum_limit(self) -> _builtins.int:
        return pulumi.get(self, "maximum_limit")

    @_builtins.property
    @pulumi.getter(name="overrunPolicy")
    def overrun_policy(self) -> _builtins.str:
        return pulumi.get(self, "overrun_policy")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The unique ID for the project to create a Federated Database Instance.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="tenantName")
    def tenant_name(self) -> _builtins.str:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "tenant_name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetFederatedSettingsIdentityProviderAssociatedOrgResult(dict):
    def __init__(__self__, *,
                 domain_allow_lists: Sequence[_builtins.str],
                 domain_restriction_enabled: _builtins.bool,
                 identity_provider_id: _builtins.str,
                 org_id: _builtins.str,
                 post_auth_role_grants: Sequence[_builtins.str],
                 role_mappings: Sequence['outputs.GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingResult'],
                 user_conflicts: Sequence['outputs.GetFederatedSettingsIdentityProviderAssociatedOrgUserConflictResult']):
        """
        :param Sequence[_builtins.str] domain_allow_lists: List that contains the approved domains from which organization users can log in.
        :param _builtins.bool domain_restriction_enabled: Flag that indicates whether domain restriction is enabled for the connected organization.
        :param _builtins.str identity_provider_id: Unique 24-hexadecimal digit string that identifies the IdP.
        :param _builtins.str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param Sequence[_builtins.str] post_auth_role_grants: List that contains the default roles granted to users who authenticate through the IdP in a connected organization. If you provide a postAuthRoleGrants field in the request, the array that you provide replaces the current postAuthRoleGrants.
        """
        pulumi.set(__self__, "domain_allow_lists", domain_allow_lists)
        pulumi.set(__self__, "domain_restriction_enabled", domain_restriction_enabled)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "post_auth_role_grants", post_auth_role_grants)
        pulumi.set(__self__, "role_mappings", role_mappings)
        pulumi.set(__self__, "user_conflicts", user_conflicts)

    @_builtins.property
    @pulumi.getter(name="domainAllowLists")
    def domain_allow_lists(self) -> Sequence[_builtins.str]:
        """
        List that contains the approved domains from which organization users can log in.
        """
        return pulumi.get(self, "domain_allow_lists")

    @_builtins.property
    @pulumi.getter(name="domainRestrictionEnabled")
    def domain_restriction_enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether domain restriction is enabled for the connected organization.
        """
        return pulumi.get(self, "domain_restriction_enabled")

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the IdP.
        """
        return pulumi.get(self, "identity_provider_id")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter(name="postAuthRoleGrants")
    def post_auth_role_grants(self) -> Sequence[_builtins.str]:
        """
        List that contains the default roles granted to users who authenticate through the IdP in a connected organization. If you provide a postAuthRoleGrants field in the request, the array that you provide replaces the current postAuthRoleGrants.
        """
        return pulumi.get(self, "post_auth_role_grants")

    @_builtins.property
    @pulumi.getter(name="roleMappings")
    def role_mappings(self) -> Sequence['outputs.GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingResult']:
        return pulumi.get(self, "role_mappings")

    @_builtins.property
    @pulumi.getter(name="userConflicts")
    def user_conflicts(self) -> Sequence['outputs.GetFederatedSettingsIdentityProviderAssociatedOrgUserConflictResult']:
        return pulumi.get(self, "user_conflicts")


@pulumi.output_type
class GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingResult(dict):
    def __init__(__self__, *,
                 external_group_name: _builtins.str,
                 id: _builtins.str,
                 role_assignments: Sequence['outputs.GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignmentResult']):
        """
        :param _builtins.str external_group_name: Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        :param _builtins.str id: Unique 24-hexadecimal digit string that identifies this role mapping.
        :param Sequence['GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignmentArgs'] role_assignments: Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        pulumi.set(__self__, "external_group_name", external_group_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "role_assignments", role_assignments)

    @_builtins.property
    @pulumi.getter(name="externalGroupName")
    def external_group_name(self) -> _builtins.str:
        """
        Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        """
        return pulumi.get(self, "external_group_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies this role mapping.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="roleAssignments")
    def role_assignments(self) -> Sequence['outputs.GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignmentResult']:
        """
        Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        return pulumi.get(self, "role_assignments")


@pulumi.output_type
class GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 group_id: _builtins.str,
                 org_id: _builtins.str,
                 role: _builtins.str):
        """
        :param _builtins.str group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param _builtins.str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param _builtins.str role: Specifies the Role that is attached to the Role Mapping.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.str:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        Specifies the Role that is attached to the Role Mapping.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetFederatedSettingsIdentityProviderAssociatedOrgUserConflictResult(dict):
    def __init__(__self__, *,
                 email_address: _builtins.str,
                 federation_settings_id: _builtins.str,
                 first_name: _builtins.str,
                 last_name: _builtins.str,
                 user_id: _builtins.str):
        """
        :param _builtins.str email_address: Email address of the the user that conflicts with selected domains.
        :param _builtins.str federation_settings_id: Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        :param _builtins.str first_name: First name of the the user that conflicts with selected domains.
        :param _builtins.str last_name: Last name of the the user that conflicts with selected domains.
        :param _builtins.str user_id: Name of the Atlas user that conflicts with selected domains.
        """
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "federation_settings_id", federation_settings_id)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> _builtins.str:
        """
        Email address of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "email_address")

    @_builtins.property
    @pulumi.getter(name="federationSettingsId")
    def federation_settings_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        """
        return pulumi.get(self, "federation_settings_id")

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> _builtins.str:
        """
        First name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> _builtins.str:
        """
        Last name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "last_name")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> _builtins.str:
        """
        Name of the Atlas user that conflicts with selected domains.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetFederatedSettingsIdentityProviderPemFileInfoResult(dict):
    def __init__(__self__, *,
                 certificates: Sequence['outputs.GetFederatedSettingsIdentityProviderPemFileInfoCertificateResult'],
                 file_name: _builtins.str):
        """
        :param _builtins.str file_name: Filename of certificate
        """
        pulumi.set(__self__, "certificates", certificates)
        pulumi.set(__self__, "file_name", file_name)

    @_builtins.property
    @pulumi.getter
    def certificates(self) -> Sequence['outputs.GetFederatedSettingsIdentityProviderPemFileInfoCertificateResult']:
        return pulumi.get(self, "certificates")

    @_builtins.property
    @pulumi.getter(name="fileName")
    def file_name(self) -> _builtins.str:
        """
        Filename of certificate
        """
        return pulumi.get(self, "file_name")


@pulumi.output_type
class GetFederatedSettingsIdentityProviderPemFileInfoCertificateResult(dict):
    def __init__(__self__, *,
                 not_after: _builtins.str,
                 not_before: _builtins.str):
        """
        :param _builtins.str not_after: Expiration  Date.
        :param _builtins.str not_before: Start Date.
        """
        pulumi.set(__self__, "not_after", not_after)
        pulumi.set(__self__, "not_before", not_before)

    @_builtins.property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> _builtins.str:
        """
        Expiration  Date.
        """
        return pulumi.get(self, "not_after")

    @_builtins.property
    @pulumi.getter(name="notBefore")
    def not_before(self) -> _builtins.str:
        """
        Start Date.
        """
        return pulumi.get(self, "not_before")


@pulumi.output_type
class GetFederatedSettingsIdentityProvidersResultResult(dict):
    def __init__(__self__, *,
                 acs_url: _builtins.str,
                 associated_domains: Sequence[_builtins.str],
                 associated_orgs: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgResult'],
                 audience: _builtins.str,
                 audience_uri: _builtins.str,
                 authorization_type: _builtins.str,
                 client_id: _builtins.str,
                 description: _builtins.str,
                 display_name: _builtins.str,
                 groups_claim: _builtins.str,
                 idp_id: _builtins.str,
                 idp_type: _builtins.str,
                 issuer_uri: _builtins.str,
                 okta_idp_id: _builtins.str,
                 pem_file_infos: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultPemFileInfoResult'],
                 protocol: _builtins.str,
                 request_binding: _builtins.str,
                 requested_scopes: Sequence[_builtins.str],
                 response_signature_algorithm: _builtins.str,
                 sso_debug_enabled: _builtins.bool,
                 sso_url: _builtins.str,
                 status: _builtins.str,
                 user_claim: _builtins.str):
        """
        :param _builtins.str acs_url: Assertion consumer service URL to which the IdP sends the SAML response.
        :param Sequence[_builtins.str] associated_domains: List that contains the configured domains from which users can log in for this IdP.
        :param Sequence['GetFederatedSettingsIdentityProvidersResultAssociatedOrgArgs'] associated_orgs: List that contains the configured domains from which users can log in for this IdP.
        :param _builtins.str audience: Identifier of the intended recipient of the token.
        :param _builtins.str audience_uri: Identifier for the intended audience of the SAML Assertion.
        :param _builtins.str authorization_type: Indicates whether authorization is granted based on group membership or user ID. Valid values are `GROUP` or `USER`.
        :param _builtins.str client_id: Client identifier that is assigned to an application by the Identity Provider.
        :param _builtins.str description: The description of the identity provider.
        :param _builtins.str display_name: Human-readable label that identifies the IdP.
        :param _builtins.str groups_claim: Identifier of the claim which contains IdP Group IDs in the token.
        :param _builtins.str idp_id: Unique 24-hexadecimal digit string that identifies the IdP.
        :param _builtins.str idp_type: Type of the identity provider. Valid values are `WORKFORCE` or `WORKLOAD`.
        :param _builtins.str issuer_uri: Identifier for the issuer of the SAML Assertion.
        :param _builtins.str protocol: The protocol of the identity provider
        :param _builtins.str request_binding: SAML Authentication Request Protocol binding used to send the AuthNRequest. Atlas supports the following binding values:
               - HTTP POST
               - HTTP REDIRECT
        :param Sequence[_builtins.str] requested_scopes: Scopes that MongoDB applications will request from the authorization endpoint.
        :param _builtins.str response_signature_algorithm: Algorithm used to encrypt the IdP signature. Atlas supports the following signature algorithm values:
               - SHA-1
               - SHA-256
        :param _builtins.bool sso_debug_enabled: Flag that indicates whether the IdP has enabled Bypass SAML Mode. Enabling this mode generates a URL that allows you bypass SAML and login to your organizations at any point. You can authenticate with this special URL only when Bypass Mode is enabled. Set this parameter to true during testing. This keeps you from getting locked out of MongoDB.
        :param _builtins.str sso_url: URL of the receiver of the SAML AuthNRequest.
        :param _builtins.str status: Label that indicates whether the identity provider is active. The IdP is Inactive until you map at least one domain to the IdP.
        :param _builtins.str user_claim: Identifier of the claim which contains the user ID in the token.
        """
        pulumi.set(__self__, "acs_url", acs_url)
        pulumi.set(__self__, "associated_domains", associated_domains)
        pulumi.set(__self__, "associated_orgs", associated_orgs)
        pulumi.set(__self__, "audience", audience)
        pulumi.set(__self__, "audience_uri", audience_uri)
        pulumi.set(__self__, "authorization_type", authorization_type)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "groups_claim", groups_claim)
        pulumi.set(__self__, "idp_id", idp_id)
        pulumi.set(__self__, "idp_type", idp_type)
        pulumi.set(__self__, "issuer_uri", issuer_uri)
        pulumi.set(__self__, "okta_idp_id", okta_idp_id)
        pulumi.set(__self__, "pem_file_infos", pem_file_infos)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "request_binding", request_binding)
        pulumi.set(__self__, "requested_scopes", requested_scopes)
        pulumi.set(__self__, "response_signature_algorithm", response_signature_algorithm)
        pulumi.set(__self__, "sso_debug_enabled", sso_debug_enabled)
        pulumi.set(__self__, "sso_url", sso_url)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "user_claim", user_claim)

    @_builtins.property
    @pulumi.getter(name="acsUrl")
    def acs_url(self) -> _builtins.str:
        """
        Assertion consumer service URL to which the IdP sends the SAML response.
        """
        return pulumi.get(self, "acs_url")

    @_builtins.property
    @pulumi.getter(name="associatedDomains")
    def associated_domains(self) -> Sequence[_builtins.str]:
        """
        List that contains the configured domains from which users can log in for this IdP.
        """
        return pulumi.get(self, "associated_domains")

    @_builtins.property
    @pulumi.getter(name="associatedOrgs")
    def associated_orgs(self) -> Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgResult']:
        """
        List that contains the configured domains from which users can log in for this IdP.
        """
        return pulumi.get(self, "associated_orgs")

    @_builtins.property
    @pulumi.getter
    def audience(self) -> _builtins.str:
        """
        Identifier of the intended recipient of the token.
        """
        return pulumi.get(self, "audience")

    @_builtins.property
    @pulumi.getter(name="audienceUri")
    def audience_uri(self) -> _builtins.str:
        """
        Identifier for the intended audience of the SAML Assertion.
        """
        return pulumi.get(self, "audience_uri")

    @_builtins.property
    @pulumi.getter(name="authorizationType")
    def authorization_type(self) -> _builtins.str:
        """
        Indicates whether authorization is granted based on group membership or user ID. Valid values are `GROUP` or `USER`.
        """
        return pulumi.get(self, "authorization_type")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        Client identifier that is assigned to an application by the Identity Provider.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the identity provider.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        Human-readable label that identifies the IdP.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="groupsClaim")
    def groups_claim(self) -> _builtins.str:
        """
        Identifier of the claim which contains IdP Group IDs in the token.
        """
        return pulumi.get(self, "groups_claim")

    @_builtins.property
    @pulumi.getter(name="idpId")
    def idp_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the IdP.
        """
        return pulumi.get(self, "idp_id")

    @_builtins.property
    @pulumi.getter(name="idpType")
    def idp_type(self) -> _builtins.str:
        """
        Type of the identity provider. Valid values are `WORKFORCE` or `WORKLOAD`.
        """
        return pulumi.get(self, "idp_type")

    @_builtins.property
    @pulumi.getter(name="issuerUri")
    def issuer_uri(self) -> _builtins.str:
        """
        Identifier for the issuer of the SAML Assertion.
        """
        return pulumi.get(self, "issuer_uri")

    @_builtins.property
    @pulumi.getter(name="oktaIdpId")
    def okta_idp_id(self) -> _builtins.str:
        return pulumi.get(self, "okta_idp_id")

    @_builtins.property
    @pulumi.getter(name="pemFileInfos")
    def pem_file_infos(self) -> Sequence['outputs.GetFederatedSettingsIdentityProvidersResultPemFileInfoResult']:
        return pulumi.get(self, "pem_file_infos")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The protocol of the identity provider
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="requestBinding")
    def request_binding(self) -> _builtins.str:
        """
        SAML Authentication Request Protocol binding used to send the AuthNRequest. Atlas supports the following binding values:
        - HTTP POST
        - HTTP REDIRECT
        """
        return pulumi.get(self, "request_binding")

    @_builtins.property
    @pulumi.getter(name="requestedScopes")
    def requested_scopes(self) -> Sequence[_builtins.str]:
        """
        Scopes that MongoDB applications will request from the authorization endpoint.
        """
        return pulumi.get(self, "requested_scopes")

    @_builtins.property
    @pulumi.getter(name="responseSignatureAlgorithm")
    def response_signature_algorithm(self) -> _builtins.str:
        """
        Algorithm used to encrypt the IdP signature. Atlas supports the following signature algorithm values:
        - SHA-1
        - SHA-256
        """
        return pulumi.get(self, "response_signature_algorithm")

    @_builtins.property
    @pulumi.getter(name="ssoDebugEnabled")
    def sso_debug_enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether the IdP has enabled Bypass SAML Mode. Enabling this mode generates a URL that allows you bypass SAML and login to your organizations at any point. You can authenticate with this special URL only when Bypass Mode is enabled. Set this parameter to true during testing. This keeps you from getting locked out of MongoDB.
        """
        return pulumi.get(self, "sso_debug_enabled")

    @_builtins.property
    @pulumi.getter(name="ssoUrl")
    def sso_url(self) -> _builtins.str:
        """
        URL of the receiver of the SAML AuthNRequest.
        """
        return pulumi.get(self, "sso_url")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Label that indicates whether the identity provider is active. The IdP is Inactive until you map at least one domain to the IdP.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="userClaim")
    def user_claim(self) -> _builtins.str:
        """
        Identifier of the claim which contains the user ID in the token.
        """
        return pulumi.get(self, "user_claim")


@pulumi.output_type
class GetFederatedSettingsIdentityProvidersResultAssociatedOrgResult(dict):
    def __init__(__self__, *,
                 domain_allow_lists: Sequence[_builtins.str],
                 domain_restriction_enabled: _builtins.bool,
                 identity_provider_id: _builtins.str,
                 org_id: _builtins.str,
                 post_auth_role_grants: Sequence[_builtins.str],
                 role_mappings: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingResult'],
                 user_conflicts: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgUserConflictResult']):
        """
        :param Sequence[_builtins.str] domain_allow_lists: List that contains the approved domains from which organization users can log in.
        :param _builtins.bool domain_restriction_enabled: Flag that indicates whether domain restriction is enabled for the connected organization.
        :param _builtins.str identity_provider_id: Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        :param _builtins.str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param Sequence[_builtins.str] post_auth_role_grants: List that contains the default roles granted to users who authenticate through the IdP in a connected organization. If you provide a postAuthRoleGrants field in the request, the array that you provide replaces the current postAuthRoleGrants.
        """
        pulumi.set(__self__, "domain_allow_lists", domain_allow_lists)
        pulumi.set(__self__, "domain_restriction_enabled", domain_restriction_enabled)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "post_auth_role_grants", post_auth_role_grants)
        pulumi.set(__self__, "role_mappings", role_mappings)
        pulumi.set(__self__, "user_conflicts", user_conflicts)

    @_builtins.property
    @pulumi.getter(name="domainAllowLists")
    def domain_allow_lists(self) -> Sequence[_builtins.str]:
        """
        List that contains the approved domains from which organization users can log in.
        """
        return pulumi.get(self, "domain_allow_lists")

    @_builtins.property
    @pulumi.getter(name="domainRestrictionEnabled")
    def domain_restriction_enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether domain restriction is enabled for the connected organization.
        """
        return pulumi.get(self, "domain_restriction_enabled")

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        """
        return pulumi.get(self, "identity_provider_id")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter(name="postAuthRoleGrants")
    def post_auth_role_grants(self) -> Sequence[_builtins.str]:
        """
        List that contains the default roles granted to users who authenticate through the IdP in a connected organization. If you provide a postAuthRoleGrants field in the request, the array that you provide replaces the current postAuthRoleGrants.
        """
        return pulumi.get(self, "post_auth_role_grants")

    @_builtins.property
    @pulumi.getter(name="roleMappings")
    def role_mappings(self) -> Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingResult']:
        return pulumi.get(self, "role_mappings")

    @_builtins.property
    @pulumi.getter(name="userConflicts")
    def user_conflicts(self) -> Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgUserConflictResult']:
        return pulumi.get(self, "user_conflicts")


@pulumi.output_type
class GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingResult(dict):
    def __init__(__self__, *,
                 external_group_name: _builtins.str,
                 id: _builtins.str,
                 role_assignments: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignmentResult']):
        """
        :param _builtins.str external_group_name: Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        :param _builtins.str id: Unique 24-hexadecimal digit string that identifies this role mapping.
        :param Sequence['GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignmentArgs'] role_assignments: Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        pulumi.set(__self__, "external_group_name", external_group_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "role_assignments", role_assignments)

    @_builtins.property
    @pulumi.getter(name="externalGroupName")
    def external_group_name(self) -> _builtins.str:
        """
        Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        """
        return pulumi.get(self, "external_group_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies this role mapping.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="roleAssignments")
    def role_assignments(self) -> Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignmentResult']:
        """
        Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        return pulumi.get(self, "role_assignments")


@pulumi.output_type
class GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 group_id: _builtins.str,
                 org_id: _builtins.str,
                 role: _builtins.str):
        """
        :param _builtins.str group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param _builtins.str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param _builtins.str role: Specifies the Role that is attached to the Role Mapping.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.str:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        Specifies the Role that is attached to the Role Mapping.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetFederatedSettingsIdentityProvidersResultAssociatedOrgUserConflictResult(dict):
    def __init__(__self__, *,
                 email_address: _builtins.str,
                 federation_settings_id: _builtins.str,
                 first_name: _builtins.str,
                 last_name: _builtins.str,
                 user_id: _builtins.str):
        """
        :param _builtins.str email_address: Email address of the the user that conflicts with selected domains.
        :param _builtins.str federation_settings_id: Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        :param _builtins.str first_name: First name of the the user that conflicts with selected domains.
        :param _builtins.str last_name: Last name of the the user that conflicts with selected domains.
        :param _builtins.str user_id: Name of the Atlas user that conflicts with selected domains.
        """
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "federation_settings_id", federation_settings_id)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> _builtins.str:
        """
        Email address of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "email_address")

    @_builtins.property
    @pulumi.getter(name="federationSettingsId")
    def federation_settings_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        """
        return pulumi.get(self, "federation_settings_id")

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> _builtins.str:
        """
        First name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> _builtins.str:
        """
        Last name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "last_name")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> _builtins.str:
        """
        Name of the Atlas user that conflicts with selected domains.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetFederatedSettingsIdentityProvidersResultPemFileInfoResult(dict):
    def __init__(__self__, *,
                 certificates: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultPemFileInfoCertificateResult'],
                 file_name: _builtins.str):
        """
        :param _builtins.str file_name: Filename of certificate
        """
        pulumi.set(__self__, "certificates", certificates)
        pulumi.set(__self__, "file_name", file_name)

    @_builtins.property
    @pulumi.getter
    def certificates(self) -> Sequence['outputs.GetFederatedSettingsIdentityProvidersResultPemFileInfoCertificateResult']:
        return pulumi.get(self, "certificates")

    @_builtins.property
    @pulumi.getter(name="fileName")
    def file_name(self) -> _builtins.str:
        """
        Filename of certificate
        """
        return pulumi.get(self, "file_name")


@pulumi.output_type
class GetFederatedSettingsIdentityProvidersResultPemFileInfoCertificateResult(dict):
    def __init__(__self__, *,
                 not_after: _builtins.str,
                 not_before: _builtins.str):
        """
        :param _builtins.str not_after: Expiration  Date.
        :param _builtins.str not_before: Start Date.
        """
        pulumi.set(__self__, "not_after", not_after)
        pulumi.set(__self__, "not_before", not_before)

    @_builtins.property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> _builtins.str:
        """
        Expiration  Date.
        """
        return pulumi.get(self, "not_after")

    @_builtins.property
    @pulumi.getter(name="notBefore")
    def not_before(self) -> _builtins.str:
        """
        Start Date.
        """
        return pulumi.get(self, "not_before")


@pulumi.output_type
class GetFederatedSettingsOrgConfigRoleMappingResult(dict):
    def __init__(__self__, *,
                 external_group_name: _builtins.str,
                 id: _builtins.str,
                 role_assignments: Sequence['outputs.GetFederatedSettingsOrgConfigRoleMappingRoleAssignmentResult']):
        """
        :param _builtins.str external_group_name: Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        :param _builtins.str id: Unique 24-hexadecimal digit string that identifies this role mapping.
        :param Sequence['GetFederatedSettingsOrgConfigRoleMappingRoleAssignmentArgs'] role_assignments: Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        pulumi.set(__self__, "external_group_name", external_group_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "role_assignments", role_assignments)

    @_builtins.property
    @pulumi.getter(name="externalGroupName")
    def external_group_name(self) -> _builtins.str:
        """
        Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        """
        return pulumi.get(self, "external_group_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies this role mapping.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="roleAssignments")
    def role_assignments(self) -> Sequence['outputs.GetFederatedSettingsOrgConfigRoleMappingRoleAssignmentResult']:
        """
        Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        return pulumi.get(self, "role_assignments")


@pulumi.output_type
class GetFederatedSettingsOrgConfigRoleMappingRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 group_id: _builtins.str,
                 org_id: _builtins.str,
                 role: _builtins.str):
        """
        :param _builtins.str group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param _builtins.str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param _builtins.str role: Specifies the Role that is attached to the Role Mapping.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.str:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        Specifies the Role that is attached to the Role Mapping.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetFederatedSettingsOrgConfigUserConflictResult(dict):
    def __init__(__self__, *,
                 email_address: _builtins.str,
                 federation_settings_id: _builtins.str,
                 first_name: _builtins.str,
                 last_name: _builtins.str,
                 user_id: _builtins.str):
        """
        :param _builtins.str email_address: Email address of the the user that conflicts with selected domains.
        :param _builtins.str federation_settings_id: Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        :param _builtins.str first_name: First name of the the user that conflicts with selected domains.
        :param _builtins.str last_name: Last name of the the user that conflicts with selected domains.
        :param _builtins.str user_id: Name of the Atlas user that conflicts with selected domains.
        """
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "federation_settings_id", federation_settings_id)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> _builtins.str:
        """
        Email address of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "email_address")

    @_builtins.property
    @pulumi.getter(name="federationSettingsId")
    def federation_settings_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        """
        return pulumi.get(self, "federation_settings_id")

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> _builtins.str:
        """
        First name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> _builtins.str:
        """
        Last name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "last_name")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> _builtins.str:
        """
        Name of the Atlas user that conflicts with selected domains.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetFederatedSettingsOrgConfigsResultResult(dict):
    def __init__(__self__, *,
                 data_access_identity_provider_ids: Sequence[_builtins.str],
                 domain_allow_lists: Sequence[_builtins.str],
                 domain_restriction_enabled: _builtins.bool,
                 identity_provider_id: _builtins.str,
                 org_id: _builtins.str,
                 post_auth_role_grants: Sequence[_builtins.str],
                 role_mappings: Sequence['outputs.GetFederatedSettingsOrgConfigsResultRoleMappingResult'],
                 user_conflicts: Sequence['outputs.GetFederatedSettingsOrgConfigsResultUserConflictResult']):
        """
        :param Sequence[_builtins.str] data_access_identity_provider_ids: The collection of unique ids representing the identity providers that can be used for data access in this organization.
        :param Sequence[_builtins.str] domain_allow_lists: List that contains the approved domains from which organization users can log in.
        :param _builtins.bool domain_restriction_enabled: Flag that indicates whether domain restriction is enabled for the connected organization.
        :param _builtins.str identity_provider_id: Legacy 20-hexadecimal digit string that identifies the SAML access identity provider that this connected org config is associated with. This id can be found in two ways:
               1. Within the Federation Management UI in Atlas in the Identity Providers tab by clicking the info icon in the IdP ID row of a configured SAML identity provider
               2. `okta_idp_id` on the `FederatedSettingsIdentityProvider` resource
        :param _builtins.str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param Sequence[_builtins.str] post_auth_role_grants: List that contains the default roles granted to users who authenticate through the IdP in a connected organization.
        :param Sequence['GetFederatedSettingsOrgConfigsResultRoleMappingArgs'] role_mappings: Role mappings that are configured in this organization. See below
        :param Sequence['GetFederatedSettingsOrgConfigsResultUserConflictArgs'] user_conflicts: List that contains the users who have an email address that doesn't match any domain on the allowed list. See below
        """
        pulumi.set(__self__, "data_access_identity_provider_ids", data_access_identity_provider_ids)
        pulumi.set(__self__, "domain_allow_lists", domain_allow_lists)
        pulumi.set(__self__, "domain_restriction_enabled", domain_restriction_enabled)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "post_auth_role_grants", post_auth_role_grants)
        pulumi.set(__self__, "role_mappings", role_mappings)
        pulumi.set(__self__, "user_conflicts", user_conflicts)

    @_builtins.property
    @pulumi.getter(name="dataAccessIdentityProviderIds")
    def data_access_identity_provider_ids(self) -> Sequence[_builtins.str]:
        """
        The collection of unique ids representing the identity providers that can be used for data access in this organization.
        """
        return pulumi.get(self, "data_access_identity_provider_ids")

    @_builtins.property
    @pulumi.getter(name="domainAllowLists")
    def domain_allow_lists(self) -> Sequence[_builtins.str]:
        """
        List that contains the approved domains from which organization users can log in.
        """
        return pulumi.get(self, "domain_allow_lists")

    @_builtins.property
    @pulumi.getter(name="domainRestrictionEnabled")
    def domain_restriction_enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether domain restriction is enabled for the connected organization.
        """
        return pulumi.get(self, "domain_restriction_enabled")

    @_builtins.property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> _builtins.str:
        """
        Legacy 20-hexadecimal digit string that identifies the SAML access identity provider that this connected org config is associated with. This id can be found in two ways:
        1. Within the Federation Management UI in Atlas in the Identity Providers tab by clicking the info icon in the IdP ID row of a configured SAML identity provider
        2. `okta_idp_id` on the `FederatedSettingsIdentityProvider` resource
        """
        return pulumi.get(self, "identity_provider_id")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter(name="postAuthRoleGrants")
    def post_auth_role_grants(self) -> Sequence[_builtins.str]:
        """
        List that contains the default roles granted to users who authenticate through the IdP in a connected organization.
        """
        return pulumi.get(self, "post_auth_role_grants")

    @_builtins.property
    @pulumi.getter(name="roleMappings")
    def role_mappings(self) -> Sequence['outputs.GetFederatedSettingsOrgConfigsResultRoleMappingResult']:
        """
        Role mappings that are configured in this organization. See below
        """
        return pulumi.get(self, "role_mappings")

    @_builtins.property
    @pulumi.getter(name="userConflicts")
    def user_conflicts(self) -> Sequence['outputs.GetFederatedSettingsOrgConfigsResultUserConflictResult']:
        """
        List that contains the users who have an email address that doesn't match any domain on the allowed list. See below
        """
        return pulumi.get(self, "user_conflicts")


@pulumi.output_type
class GetFederatedSettingsOrgConfigsResultRoleMappingResult(dict):
    def __init__(__self__, *,
                 external_group_name: _builtins.str,
                 id: _builtins.str,
                 role_assignments: Sequence['outputs.GetFederatedSettingsOrgConfigsResultRoleMappingRoleAssignmentResult']):
        """
        :param _builtins.str external_group_name: Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        :param _builtins.str id: Unique 24-hexadecimal digit string that identifies this role mapping.
        :param Sequence['GetFederatedSettingsOrgConfigsResultRoleMappingRoleAssignmentArgs'] role_assignments: Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        pulumi.set(__self__, "external_group_name", external_group_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "role_assignments", role_assignments)

    @_builtins.property
    @pulumi.getter(name="externalGroupName")
    def external_group_name(self) -> _builtins.str:
        """
        Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        """
        return pulumi.get(self, "external_group_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies this role mapping.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="roleAssignments")
    def role_assignments(self) -> Sequence['outputs.GetFederatedSettingsOrgConfigsResultRoleMappingRoleAssignmentResult']:
        """
        Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        return pulumi.get(self, "role_assignments")


@pulumi.output_type
class GetFederatedSettingsOrgConfigsResultRoleMappingRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 group_id: _builtins.str,
                 org_id: _builtins.str,
                 role: _builtins.str):
        """
        :param _builtins.str group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param _builtins.str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param _builtins.str role: Specifies the Role that is attached to the Role Mapping.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.str:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        Specifies the Role that is attached to the Role Mapping.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetFederatedSettingsOrgConfigsResultUserConflictResult(dict):
    def __init__(__self__, *,
                 email_address: _builtins.str,
                 federation_settings_id: _builtins.str,
                 first_name: _builtins.str,
                 last_name: _builtins.str,
                 user_id: _builtins.str):
        """
        :param _builtins.str email_address: Email address of the the user that conflicts with selected domains.
        :param _builtins.str federation_settings_id: Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        :param _builtins.str first_name: First name of the the user that conflicts with selected domains.
        :param _builtins.str last_name: Last name of the the user that conflicts with selected domains.
        :param _builtins.str user_id: Name of the Atlas user that conflicts with selected domains.
        """
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "federation_settings_id", federation_settings_id)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> _builtins.str:
        """
        Email address of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "email_address")

    @_builtins.property
    @pulumi.getter(name="federationSettingsId")
    def federation_settings_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        """
        return pulumi.get(self, "federation_settings_id")

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> _builtins.str:
        """
        First name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> _builtins.str:
        """
        Last name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "last_name")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> _builtins.str:
        """
        Name of the Atlas user that conflicts with selected domains.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetFederatedSettingsOrgRoleMappingRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 group_id: _builtins.str,
                 org_id: _builtins.str,
                 role: _builtins.str):
        """
        :param _builtins.str group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param _builtins.str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param _builtins.str role: Specifies the Role that is attached to the Role Mapping.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.str:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        Specifies the Role that is attached to the Role Mapping.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetFederatedSettingsOrgRoleMappingsResultResult(dict):
    def __init__(__self__, *,
                 external_group_name: _builtins.str,
                 id: _builtins.str,
                 role_assignments: Sequence['outputs.GetFederatedSettingsOrgRoleMappingsResultRoleAssignmentResult']):
        """
        :param _builtins.str external_group_name: Unique label that identifies the identity provider group to which this role mapping applies.
        :param _builtins.str id: Unique 24-hexadecimal digit string that identifies this role mapping.
        :param Sequence['GetFederatedSettingsOrgRoleMappingsResultRoleAssignmentArgs'] role_assignments: Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        pulumi.set(__self__, "external_group_name", external_group_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "role_assignments", role_assignments)

    @_builtins.property
    @pulumi.getter(name="externalGroupName")
    def external_group_name(self) -> _builtins.str:
        """
        Unique label that identifies the identity provider group to which this role mapping applies.
        """
        return pulumi.get(self, "external_group_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies this role mapping.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="roleAssignments")
    def role_assignments(self) -> Sequence['outputs.GetFederatedSettingsOrgRoleMappingsResultRoleAssignmentResult']:
        """
        Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        return pulumi.get(self, "role_assignments")


@pulumi.output_type
class GetFederatedSettingsOrgRoleMappingsResultRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 group_id: _builtins.str,
                 org_id: _builtins.str,
                 role: _builtins.str):
        """
        :param _builtins.str group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param _builtins.str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param _builtins.str role: Specifies the Role that is attached to the Role Mapping.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.str:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        Specifies the Role that is attached to the Role Mapping.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetFlexClusterBackupSettingsResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: Flag that indicates whether backups are performed for this flex cluster. Backup uses [flex cluster backups](https://www.mongodb.com/docs/atlas/backup/cloud-backup/flex-cluster-backup/).
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether backups are performed for this flex cluster. Backup uses [flex cluster backups](https://www.mongodb.com/docs/atlas/backup/cloud-backup/flex-cluster-backup/).
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetFlexClusterConnectionStringsResult(dict):
    def __init__(__self__, *,
                 standard: _builtins.str,
                 standard_srv: _builtins.str):
        """
        :param _builtins.str standard: Public connection string that you can use to connect to this cluster. This connection string uses the mongodb:// protocol.
        :param _builtins.str standard_srv: Public connection string that you can use to connect to this flex cluster. This connection string uses the `mongodb+srv://` protocol.
        """
        pulumi.set(__self__, "standard", standard)
        pulumi.set(__self__, "standard_srv", standard_srv)

    @_builtins.property
    @pulumi.getter
    def standard(self) -> _builtins.str:
        """
        Public connection string that you can use to connect to this cluster. This connection string uses the mongodb:// protocol.
        """
        return pulumi.get(self, "standard")

    @_builtins.property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> _builtins.str:
        """
        Public connection string that you can use to connect to this flex cluster. This connection string uses the `mongodb+srv://` protocol.
        """
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class GetFlexClusterProviderSettingsResult(dict):
    def __init__(__self__, *,
                 backing_provider_name: _builtins.str,
                 disk_size_gb: _builtins.float,
                 provider_name: _builtins.str,
                 region_name: _builtins.str):
        """
        :param _builtins.str backing_provider_name: Cloud service provider on which MongoDB Cloud provisioned the flex cluster.
        :param _builtins.float disk_size_gb: Storage capacity available to the flex cluster expressed in gigabytes.
        :param _builtins.str provider_name: Human-readable label that identifies the cloud service provider.
        :param _builtins.str region_name: Human-readable label that identifies the geographic location of your MongoDB flex cluster. The region you choose can affect network latency for clients accessing your databases. For a complete list of region names, see [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/#std-label-amazon-aws), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), and [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        """
        pulumi.set(__self__, "backing_provider_name", backing_provider_name)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "region_name", region_name)

    @_builtins.property
    @pulumi.getter(name="backingProviderName")
    def backing_provider_name(self) -> _builtins.str:
        """
        Cloud service provider on which MongoDB Cloud provisioned the flex cluster.
        """
        return pulumi.get(self, "backing_provider_name")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> _builtins.float:
        """
        Storage capacity available to the flex cluster expressed in gigabytes.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> _builtins.str:
        """
        Human-readable label that identifies the cloud service provider.
        """
        return pulumi.get(self, "provider_name")

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> _builtins.str:
        """
        Human-readable label that identifies the geographic location of your MongoDB flex cluster. The region you choose can affect network latency for clients accessing your databases. For a complete list of region names, see [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/#std-label-amazon-aws), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), and [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class GetFlexClustersResultResult(dict):
    def __init__(__self__, *,
                 backup_settings: 'outputs.GetFlexClustersResultBackupSettingsResult',
                 cluster_type: _builtins.str,
                 connection_strings: 'outputs.GetFlexClustersResultConnectionStringsResult',
                 create_date: _builtins.str,
                 id: _builtins.str,
                 mongo_db_version: _builtins.str,
                 name: _builtins.str,
                 project_id: _builtins.str,
                 provider_settings: 'outputs.GetFlexClustersResultProviderSettingsResult',
                 state_name: _builtins.str,
                 tags: Mapping[str, _builtins.str],
                 termination_protection_enabled: _builtins.bool,
                 version_release_system: _builtins.str):
        """
        :param 'GetFlexClustersResultBackupSettingsArgs' backup_settings: Flex backup configuration
        :param _builtins.str cluster_type: Flex cluster topology.
        :param 'GetFlexClustersResultConnectionStringsArgs' connection_strings: Collection of Uniform Resource Locators that point to the MongoDB database.
        :param _builtins.str create_date: Date and time when MongoDB Cloud created this instance. This parameter expresses its value in ISO 8601 format in UTC.
        :param _builtins.str id: Unique 24-hexadecimal digit string that identifies the instance.
        :param _builtins.str mongo_db_version: Version of MongoDB that the instance runs.
        :param _builtins.str name: Human-readable label that identifies the instance.
        :param _builtins.str project_id: Unique 24-hexadecimal character string that identifies the project.
        :param 'GetFlexClustersResultProviderSettingsArgs' provider_settings: Group of cloud provider settings that configure the provisioned MongoDB flex cluster.
        :param _builtins.str state_name: Human-readable label that indicates the current operating condition of this instance.
        :param Mapping[str, _builtins.str] tags: Map that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the instance.
        :param _builtins.bool termination_protection_enabled: Flag that indicates whether termination protection is enabled on the cluster. If set to `true`, MongoDB Cloud won't delete the cluster. If set to `false`, MongoDB Cloud will delete the cluster.
        :param _builtins.str version_release_system: Method by which the cluster maintains the MongoDB versions.
        """
        pulumi.set(__self__, "backup_settings", backup_settings)
        pulumi.set(__self__, "cluster_type", cluster_type)
        pulumi.set(__self__, "connection_strings", connection_strings)
        pulumi.set(__self__, "create_date", create_date)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "mongo_db_version", mongo_db_version)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "provider_settings", provider_settings)
        pulumi.set(__self__, "state_name", state_name)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "termination_protection_enabled", termination_protection_enabled)
        pulumi.set(__self__, "version_release_system", version_release_system)

    @_builtins.property
    @pulumi.getter(name="backupSettings")
    def backup_settings(self) -> 'outputs.GetFlexClustersResultBackupSettingsResult':
        """
        Flex backup configuration
        """
        return pulumi.get(self, "backup_settings")

    @_builtins.property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> _builtins.str:
        """
        Flex cluster topology.
        """
        return pulumi.get(self, "cluster_type")

    @_builtins.property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> 'outputs.GetFlexClustersResultConnectionStringsResult':
        """
        Collection of Uniform Resource Locators that point to the MongoDB database.
        """
        return pulumi.get(self, "connection_strings")

    @_builtins.property
    @pulumi.getter(name="createDate")
    def create_date(self) -> _builtins.str:
        """
        Date and time when MongoDB Cloud created this instance. This parameter expresses its value in ISO 8601 format in UTC.
        """
        return pulumi.get(self, "create_date")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the instance.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="mongoDbVersion")
    def mongo_db_version(self) -> _builtins.str:
        """
        Version of MongoDB that the instance runs.
        """
        return pulumi.get(self, "mongo_db_version")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Human-readable label that identifies the instance.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal character string that identifies the project.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="providerSettings")
    def provider_settings(self) -> 'outputs.GetFlexClustersResultProviderSettingsResult':
        """
        Group of cloud provider settings that configure the provisioned MongoDB flex cluster.
        """
        return pulumi.get(self, "provider_settings")

    @_builtins.property
    @pulumi.getter(name="stateName")
    def state_name(self) -> _builtins.str:
        """
        Human-readable label that indicates the current operating condition of this instance.
        """
        return pulumi.get(self, "state_name")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        Map that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the instance.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="terminationProtectionEnabled")
    def termination_protection_enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether termination protection is enabled on the cluster. If set to `true`, MongoDB Cloud won't delete the cluster. If set to `false`, MongoDB Cloud will delete the cluster.
        """
        return pulumi.get(self, "termination_protection_enabled")

    @_builtins.property
    @pulumi.getter(name="versionReleaseSystem")
    def version_release_system(self) -> _builtins.str:
        """
        Method by which the cluster maintains the MongoDB versions.
        """
        return pulumi.get(self, "version_release_system")


@pulumi.output_type
class GetFlexClustersResultBackupSettingsResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: Flag that indicates whether backups are performed for this flex cluster. Backup uses [flex cluster backups](https://www.mongodb.com/docs/atlas/backup/cloud-backup/flex-cluster-backup/).
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether backups are performed for this flex cluster. Backup uses [flex cluster backups](https://www.mongodb.com/docs/atlas/backup/cloud-backup/flex-cluster-backup/).
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetFlexClustersResultConnectionStringsResult(dict):
    def __init__(__self__, *,
                 standard: _builtins.str,
                 standard_srv: _builtins.str):
        """
        :param _builtins.str standard: Public connection string that you can use to connect to this cluster. This connection string uses the mongodb:// protocol.
        :param _builtins.str standard_srv: Public connection string that you can use to connect to this flex cluster. This connection string uses the `mongodb+srv://` protocol.
        """
        pulumi.set(__self__, "standard", standard)
        pulumi.set(__self__, "standard_srv", standard_srv)

    @_builtins.property
    @pulumi.getter
    def standard(self) -> _builtins.str:
        """
        Public connection string that you can use to connect to this cluster. This connection string uses the mongodb:// protocol.
        """
        return pulumi.get(self, "standard")

    @_builtins.property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> _builtins.str:
        """
        Public connection string that you can use to connect to this flex cluster. This connection string uses the `mongodb+srv://` protocol.
        """
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class GetFlexClustersResultProviderSettingsResult(dict):
    def __init__(__self__, *,
                 backing_provider_name: _builtins.str,
                 disk_size_gb: _builtins.float,
                 provider_name: _builtins.str,
                 region_name: _builtins.str):
        """
        :param _builtins.str backing_provider_name: Cloud service provider on which MongoDB Cloud provisioned the flex cluster.
        :param _builtins.float disk_size_gb: Storage capacity available to the flex cluster expressed in gigabytes.
        :param _builtins.str provider_name: Human-readable label that identifies the cloud service provider.
        :param _builtins.str region_name: Human-readable label that identifies the geographic location of your MongoDB flex cluster. The region you choose can affect network latency for clients accessing your databases. For a complete list of region names, see [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/#std-label-amazon-aws), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), and [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        """
        pulumi.set(__self__, "backing_provider_name", backing_provider_name)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "region_name", region_name)

    @_builtins.property
    @pulumi.getter(name="backingProviderName")
    def backing_provider_name(self) -> _builtins.str:
        """
        Cloud service provider on which MongoDB Cloud provisioned the flex cluster.
        """
        return pulumi.get(self, "backing_provider_name")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> _builtins.float:
        """
        Storage capacity available to the flex cluster expressed in gigabytes.
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> _builtins.str:
        """
        Human-readable label that identifies the cloud service provider.
        """
        return pulumi.get(self, "provider_name")

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> _builtins.str:
        """
        Human-readable label that identifies the geographic location of your MongoDB flex cluster. The region you choose can affect network latency for clients accessing your databases. For a complete list of region names, see [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/#std-label-amazon-aws), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), and [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class GetFlexRestoreJobsResultResult(dict):
    def __init__(__self__, *,
                 delivery_type: _builtins.str,
                 expiration_date: _builtins.str,
                 name: _builtins.str,
                 project_id: _builtins.str,
                 restore_finished_date: _builtins.str,
                 restore_job_id: _builtins.str,
                 restore_scheduled_date: _builtins.str,
                 snapshot_finished_date: _builtins.str,
                 snapshot_id: _builtins.str,
                 snapshot_url: _builtins.str,
                 status: _builtins.str,
                 target_deployment_item_name: _builtins.str,
                 target_project_id: _builtins.str):
        """
        :param _builtins.str delivery_type: Means by which this resource returns the snapshot to the requesting MongoDB Cloud user.
        :param _builtins.str expiration_date: Date and time when the download link no longer works. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str name: Human-readable label that identifies the flex cluster whose snapshot you want to restore.
        :param _builtins.str project_id: Unique 24-hexadecimal digit string that identifies your project. Use the /groups endpoint to retrieve all projects to which the authenticated user has access.
        :param _builtins.str restore_finished_date: Date and time when MongoDB Cloud completed writing this snapshot. MongoDB Cloud changes the status of the restore job to `CLOSED`. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str restore_job_id: Unique 24-hexadecimal digit string that identifies the restore job.
        :param _builtins.str restore_scheduled_date: Date and time when MongoDB Cloud will restore this snapshot. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str snapshot_finished_date: Date and time when MongoDB Cloud completed writing this snapshot. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str snapshot_id: Unique 24-hexadecimal digit string that identifies the snapshot to restore.
        :param _builtins.str snapshot_url: Internet address from which you can download the compressed snapshot files. The resource returns this parameter when  `"deliveryType" : "DOWNLOAD"`.
        :param _builtins.str status: Phase of the restore workflow for this job at the time this resource made this request.
        :param _builtins.str target_deployment_item_name: Human-readable label that identifies the instance or cluster on the target project to which you want to restore the snapshot. You can restore the snapshot to another flex cluster or dedicated cluster tier.
        :param _builtins.str target_project_id: Unique 24-hexadecimal digit string that identifies the project that contains the instance or cluster to which you want to restore the snapshot.
        """
        pulumi.set(__self__, "delivery_type", delivery_type)
        pulumi.set(__self__, "expiration_date", expiration_date)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "restore_finished_date", restore_finished_date)
        pulumi.set(__self__, "restore_job_id", restore_job_id)
        pulumi.set(__self__, "restore_scheduled_date", restore_scheduled_date)
        pulumi.set(__self__, "snapshot_finished_date", snapshot_finished_date)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "snapshot_url", snapshot_url)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "target_deployment_item_name", target_deployment_item_name)
        pulumi.set(__self__, "target_project_id", target_project_id)

    @_builtins.property
    @pulumi.getter(name="deliveryType")
    def delivery_type(self) -> _builtins.str:
        """
        Means by which this resource returns the snapshot to the requesting MongoDB Cloud user.
        """
        return pulumi.get(self, "delivery_type")

    @_builtins.property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> _builtins.str:
        """
        Date and time when the download link no longer works. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "expiration_date")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Human-readable label that identifies the flex cluster whose snapshot you want to restore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies your project. Use the /groups endpoint to retrieve all projects to which the authenticated user has access.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="restoreFinishedDate")
    def restore_finished_date(self) -> _builtins.str:
        """
        Date and time when MongoDB Cloud completed writing this snapshot. MongoDB Cloud changes the status of the restore job to `CLOSED`. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "restore_finished_date")

    @_builtins.property
    @pulumi.getter(name="restoreJobId")
    def restore_job_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the restore job.
        """
        return pulumi.get(self, "restore_job_id")

    @_builtins.property
    @pulumi.getter(name="restoreScheduledDate")
    def restore_scheduled_date(self) -> _builtins.str:
        """
        Date and time when MongoDB Cloud will restore this snapshot. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "restore_scheduled_date")

    @_builtins.property
    @pulumi.getter(name="snapshotFinishedDate")
    def snapshot_finished_date(self) -> _builtins.str:
        """
        Date and time when MongoDB Cloud completed writing this snapshot. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "snapshot_finished_date")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the snapshot to restore.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter(name="snapshotUrl")
    def snapshot_url(self) -> _builtins.str:
        """
        Internet address from which you can download the compressed snapshot files. The resource returns this parameter when  `"deliveryType" : "DOWNLOAD"`.
        """
        return pulumi.get(self, "snapshot_url")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Phase of the restore workflow for this job at the time this resource made this request.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="targetDeploymentItemName")
    def target_deployment_item_name(self) -> _builtins.str:
        """
        Human-readable label that identifies the instance or cluster on the target project to which you want to restore the snapshot. You can restore the snapshot to another flex cluster or dedicated cluster tier.
        """
        return pulumi.get(self, "target_deployment_item_name")

    @_builtins.property
    @pulumi.getter(name="targetProjectId")
    def target_project_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the project that contains the instance or cluster to which you want to restore the snapshot.
        """
        return pulumi.get(self, "target_project_id")


@pulumi.output_type
class GetFlexSnapshotsResultResult(dict):
    def __init__(__self__, *,
                 expiration: _builtins.str,
                 finish_time: _builtins.str,
                 mongo_db_version: _builtins.str,
                 name: _builtins.str,
                 project_id: _builtins.str,
                 scheduled_time: _builtins.str,
                 snapshot_id: _builtins.str,
                 start_time: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str expiration: Date and time when the download link no longer works. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str finish_time: Date and time when MongoDB Cloud completed writing this snapshot. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str mongo_db_version: MongoDB host version that the snapshot runs.
        :param _builtins.str name: Human-readable label that identifies the flex cluster whose snapshot you want to restore.
        :param _builtins.str project_id: Unique 24-hexadecimal digit string that identifies your project. Use the /groups endpoint to retrieve all projects to which the authenticated user has access.
        :param _builtins.str scheduled_time: Date and time when MongoDB Cloud will take the snapshot. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str snapshot_id: Unique 24-hexadecimal digit string that identifies the snapshot to restore.
        :param _builtins.str start_time: Date and time when MongoDB Cloud began taking the snapshot. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str status: Phase of the restore workflow for this job at the time this resource made this request.
        """
        pulumi.set(__self__, "expiration", expiration)
        pulumi.set(__self__, "finish_time", finish_time)
        pulumi.set(__self__, "mongo_db_version", mongo_db_version)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "scheduled_time", scheduled_time)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def expiration(self) -> _builtins.str:
        """
        Date and time when the download link no longer works. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "expiration")

    @_builtins.property
    @pulumi.getter(name="finishTime")
    def finish_time(self) -> _builtins.str:
        """
        Date and time when MongoDB Cloud completed writing this snapshot. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "finish_time")

    @_builtins.property
    @pulumi.getter(name="mongoDbVersion")
    def mongo_db_version(self) -> _builtins.str:
        """
        MongoDB host version that the snapshot runs.
        """
        return pulumi.get(self, "mongo_db_version")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Human-readable label that identifies the flex cluster whose snapshot you want to restore.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies your project. Use the /groups endpoint to retrieve all projects to which the authenticated user has access.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="scheduledTime")
    def scheduled_time(self) -> _builtins.str:
        """
        Date and time when MongoDB Cloud will take the snapshot. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "scheduled_time")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the snapshot to restore.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        Date and time when MongoDB Cloud began taking the snapshot. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Phase of the restore workflow for this job at the time this resource made this request.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetGlobalClusterConfigManagedNamespaceResult(dict):
    def __init__(__self__, *,
                 collection: _builtins.str,
                 custom_shard_key: _builtins.str,
                 db: _builtins.str,
                 is_custom_shard_key_hashed: _builtins.bool,
                 is_shard_key_unique: _builtins.bool):
        """
        :param _builtins.str collection: (Required) The name of the collection associated with the managed namespace.
        :param _builtins.str custom_shard_key: (Required)	The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        :param _builtins.str db: (Required) The name of the database containing the collection.
        :param _builtins.bool is_custom_shard_key_hashed: Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.
        :param _builtins.bool is_shard_key_unique: Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).
        """
        pulumi.set(__self__, "collection", collection)
        pulumi.set(__self__, "custom_shard_key", custom_shard_key)
        pulumi.set(__self__, "db", db)
        pulumi.set(__self__, "is_custom_shard_key_hashed", is_custom_shard_key_hashed)
        pulumi.set(__self__, "is_shard_key_unique", is_shard_key_unique)

    @_builtins.property
    @pulumi.getter
    def collection(self) -> _builtins.str:
        """
        (Required) The name of the collection associated with the managed namespace.
        """
        return pulumi.get(self, "collection")

    @_builtins.property
    @pulumi.getter(name="customShardKey")
    def custom_shard_key(self) -> _builtins.str:
        """
        (Required)	The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        """
        return pulumi.get(self, "custom_shard_key")

    @_builtins.property
    @pulumi.getter
    def db(self) -> _builtins.str:
        """
        (Required) The name of the database containing the collection.
        """
        return pulumi.get(self, "db")

    @_builtins.property
    @pulumi.getter(name="isCustomShardKeyHashed")
    def is_custom_shard_key_hashed(self) -> _builtins.bool:
        """
        Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.
        """
        return pulumi.get(self, "is_custom_shard_key_hashed")

    @_builtins.property
    @pulumi.getter(name="isShardKeyUnique")
    def is_shard_key_unique(self) -> _builtins.bool:
        """
        Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).
        """
        return pulumi.get(self, "is_shard_key_unique")


@pulumi.output_type
class GetLdapConfigurationUserToDnMappingResult(dict):
    def __init__(__self__, *,
                 ldap_query: _builtins.str,
                 match: _builtins.str,
                 substitution: _builtins.str):
        """
        :param _builtins.str ldap_query: An LDAP query formatting template that inserts the LDAP name matched by the `match` regular expression into an LDAP query URI as specified by RFC 4515 and RFC 4516.
        :param _builtins.str match: A regular expression to match against a provided LDAP username.
        :param _builtins.str substitution: An LDAP Distinguished Name (DN) formatting template that converts the LDAP name matched by the `match` regular expression into an LDAP Distinguished Name.
        """
        pulumi.set(__self__, "ldap_query", ldap_query)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "substitution", substitution)

    @_builtins.property
    @pulumi.getter(name="ldapQuery")
    def ldap_query(self) -> _builtins.str:
        """
        An LDAP query formatting template that inserts the LDAP name matched by the `match` regular expression into an LDAP query URI as specified by RFC 4515 and RFC 4516.
        """
        return pulumi.get(self, "ldap_query")

    @_builtins.property
    @pulumi.getter
    def match(self) -> _builtins.str:
        """
        A regular expression to match against a provided LDAP username.
        """
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter
    def substitution(self) -> _builtins.str:
        """
        An LDAP Distinguished Name (DN) formatting template that converts the LDAP name matched by the `match` regular expression into an LDAP Distinguished Name.
        """
        return pulumi.get(self, "substitution")


@pulumi.output_type
class GetLdapVerifyLinkResult(dict):
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        return pulumi.get(self, "href")

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetLdapVerifyValidationResult(dict):
    def __init__(__self__, *,
                 status: _builtins.str,
                 validation_type: _builtins.str):
        """
        :param _builtins.str status: The current status of the LDAP over TLS/SSL configuration.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "validation_type", validation_type)

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The current status of the LDAP over TLS/SSL configuration.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="validationType")
    def validation_type(self) -> _builtins.str:
        return pulumi.get(self, "validation_type")


@pulumi.output_type
class GetMaintenanceWindowProtectedHourResult(dict):
    def __init__(__self__, *,
                 end_hour_of_day: _builtins.int,
                 start_hour_of_day: _builtins.int):
        """
        :param _builtins.int end_hour_of_day: Zero-based integer that represents the end hour of the day for the protected hours window.
        :param _builtins.int start_hour_of_day: Zero-based integer that represents the beginning hour of the day for the protected hours window.
        """
        pulumi.set(__self__, "end_hour_of_day", end_hour_of_day)
        pulumi.set(__self__, "start_hour_of_day", start_hour_of_day)

    @_builtins.property
    @pulumi.getter(name="endHourOfDay")
    def end_hour_of_day(self) -> _builtins.int:
        """
        Zero-based integer that represents the end hour of the day for the protected hours window.
        """
        return pulumi.get(self, "end_hour_of_day")

    @_builtins.property
    @pulumi.getter(name="startHourOfDay")
    def start_hour_of_day(self) -> _builtins.int:
        """
        Zero-based integer that represents the beginning hour of the day for the protected hours window.
        """
        return pulumi.get(self, "start_hour_of_day")


@pulumi.output_type
class GetNetworkContainersResultResult(dict):
    def __init__(__self__, *,
                 atlas_cidr_block: _builtins.str,
                 azure_subscription_id: _builtins.str,
                 gcp_project_id: _builtins.str,
                 id: _builtins.str,
                 network_name: _builtins.str,
                 provider_name: _builtins.str,
                 provisioned: _builtins.bool,
                 region: _builtins.str,
                 region_name: _builtins.str,
                 regions: Sequence[_builtins.str],
                 vnet_name: _builtins.str,
                 vpc_id: _builtins.str):
        """
        :param _builtins.str atlas_cidr_block: CIDR block that Atlas uses for your clusters. Atlas uses the specified CIDR block for all other Network Peering connections created in the project. The Atlas CIDR block must be at least a /24 and at most a /21 in one of the following [private networks](https://tools.ietf.org/html/rfc1918.html#section-3).
        :param _builtins.str azure_subscription_id: Unique identifer of the Azure subscription in which the VNet resides.
        :param _builtins.str gcp_project_id: Unique identifier of the GCP project in which the Network Peering connection resides.
        :param _builtins.str id: The Network Peering Container ID.
        :param _builtins.str network_name: Name of the Network Peering connection in the Atlas project.
        :param _builtins.str provider_name: Cloud provider for this Network peering container. Accepted values are AWS, GCP, and Azure.
        :param _builtins.bool provisioned: Indicates whether the project has Network Peering connections deployed in the container.
        :param _builtins.str region: The Atlas Azure region name for where this container exists.
        :param _builtins.str region_name: The Atlas AWS region name for where this container exists.
        :param Sequence[_builtins.str] regions: Atlas GCP regions where the container resides.
        :param _builtins.str vnet_name: The name of the Azure VNet. This value is null until you provision an Azure VNet in the container.
        :param _builtins.str vpc_id: Unique identifier of the project’s VPC.
        """
        pulumi.set(__self__, "atlas_cidr_block", atlas_cidr_block)
        pulumi.set(__self__, "azure_subscription_id", azure_subscription_id)
        pulumi.set(__self__, "gcp_project_id", gcp_project_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "network_name", network_name)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "provisioned", provisioned)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "region_name", region_name)
        pulumi.set(__self__, "regions", regions)
        pulumi.set(__self__, "vnet_name", vnet_name)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="atlasCidrBlock")
    def atlas_cidr_block(self) -> _builtins.str:
        """
        CIDR block that Atlas uses for your clusters. Atlas uses the specified CIDR block for all other Network Peering connections created in the project. The Atlas CIDR block must be at least a /24 and at most a /21 in one of the following [private networks](https://tools.ietf.org/html/rfc1918.html#section-3).
        """
        return pulumi.get(self, "atlas_cidr_block")

    @_builtins.property
    @pulumi.getter(name="azureSubscriptionId")
    def azure_subscription_id(self) -> _builtins.str:
        """
        Unique identifer of the Azure subscription in which the VNet resides.
        """
        return pulumi.get(self, "azure_subscription_id")

    @_builtins.property
    @pulumi.getter(name="gcpProjectId")
    def gcp_project_id(self) -> _builtins.str:
        """
        Unique identifier of the GCP project in which the Network Peering connection resides.
        """
        return pulumi.get(self, "gcp_project_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The Network Peering Container ID.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="networkName")
    def network_name(self) -> _builtins.str:
        """
        Name of the Network Peering connection in the Atlas project.
        """
        return pulumi.get(self, "network_name")

    @_builtins.property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> _builtins.str:
        """
        Cloud provider for this Network peering container. Accepted values are AWS, GCP, and Azure.
        """
        return pulumi.get(self, "provider_name")

    @_builtins.property
    @pulumi.getter
    def provisioned(self) -> _builtins.bool:
        """
        Indicates whether the project has Network Peering connections deployed in the container.
        """
        return pulumi.get(self, "provisioned")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The Atlas Azure region name for where this container exists.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> _builtins.str:
        """
        The Atlas AWS region name for where this container exists.
        """
        return pulumi.get(self, "region_name")

    @_builtins.property
    @pulumi.getter
    def regions(self) -> Sequence[_builtins.str]:
        """
        Atlas GCP regions where the container resides.
        """
        return pulumi.get(self, "regions")

    @_builtins.property
    @pulumi.getter(name="vnetName")
    def vnet_name(self) -> _builtins.str:
        """
        The name of the Azure VNet. This value is null until you provision an Azure VNet in the container.
        """
        return pulumi.get(self, "vnet_name")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        Unique identifier of the project’s VPC.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetNetworkPeeringsResultResult(dict):
    def __init__(__self__, *,
                 accepter_region_name: _builtins.str,
                 atlas_cidr_block: _builtins.str,
                 aws_account_id: _builtins.str,
                 azure_directory_id: _builtins.str,
                 azure_subscription_id: _builtins.str,
                 connection_id: _builtins.str,
                 container_id: _builtins.str,
                 error_message: _builtins.str,
                 error_state: _builtins.str,
                 error_state_name: _builtins.str,
                 gcp_project_id: _builtins.str,
                 network_name: _builtins.str,
                 peering_id: _builtins.str,
                 provider_name: _builtins.str,
                 resource_group_name: _builtins.str,
                 route_table_cidr_block: _builtins.str,
                 status: _builtins.str,
                 status_name: _builtins.str,
                 vnet_name: _builtins.str,
                 vpc_id: _builtins.str):
        """
        :param _builtins.str accepter_region_name: Specifies the region where the peer VPC resides. For complete lists of supported regions, see [Amazon Web Services](https://docs.atlas.mongodb.com/reference/amazon-aws/).
        :param _builtins.str aws_account_id: Account ID of the owner of the peer VPC.
        :param _builtins.str azure_directory_id: Unique identifier for an Azure AD directory.
        :param _builtins.str azure_subscription_id: Unique identifer of the Azure subscription in which the VNet resides.
        :param _builtins.str connection_id: Unique identifier for the peering connection.
        :param _builtins.str error_message: When `"status" : "FAILED"`, Atlas provides a description of the error.
        :param _builtins.str error_state: Description of the Atlas error when `status` is `Failed`, Otherwise, Atlas returns `null`.
        :param _builtins.str error_state_name: Error state, if any. The VPC peering connection error state value can be one of the following: `REJECTED`, `EXPIRED`, `INVALID_ARGUMENT`.
        :param _builtins.str gcp_project_id: GCP project ID of the owner of the network peer.
        :param _builtins.str network_name: Name of the network peer to which Atlas connects.
        :param _builtins.str peering_id: Atlas assigned unique ID for the peering connection.
        :param _builtins.str provider_name: Cloud provider for this VPC peering connection. If omitted, Atlas sets this parameter to AWS. (Possible Values `AWS`, `AZURE`, `GCP`).
        :param _builtins.str resource_group_name: Name of your Azure resource group.
        :param _builtins.str route_table_cidr_block: Peer VPC CIDR block or subnet.
        :param _builtins.str status: Status of the Atlas network peering connection: `ADDING_PEER`, `AVAILABLE`, `FAILED`, `DELETING`, `WAITING_FOR_USER`.
        :param _builtins.str status_name: The VPC peering connection status value can be one of the following: `INITIATING`, `PENDING_ACCEPTANCE`, `FAILED`, `FINALIZING`, `AVAILABLE`, `TERMINATING`.
        :param _builtins.str vnet_name: Name of your Azure VNet.
        :param _builtins.str vpc_id: Unique identifier of the peer VPC.
        """
        pulumi.set(__self__, "accepter_region_name", accepter_region_name)
        pulumi.set(__self__, "atlas_cidr_block", atlas_cidr_block)
        pulumi.set(__self__, "aws_account_id", aws_account_id)
        pulumi.set(__self__, "azure_directory_id", azure_directory_id)
        pulumi.set(__self__, "azure_subscription_id", azure_subscription_id)
        pulumi.set(__self__, "connection_id", connection_id)
        pulumi.set(__self__, "container_id", container_id)
        pulumi.set(__self__, "error_message", error_message)
        pulumi.set(__self__, "error_state", error_state)
        pulumi.set(__self__, "error_state_name", error_state_name)
        pulumi.set(__self__, "gcp_project_id", gcp_project_id)
        pulumi.set(__self__, "network_name", network_name)
        pulumi.set(__self__, "peering_id", peering_id)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)
        pulumi.set(__self__, "route_table_cidr_block", route_table_cidr_block)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_name", status_name)
        pulumi.set(__self__, "vnet_name", vnet_name)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="accepterRegionName")
    def accepter_region_name(self) -> _builtins.str:
        """
        Specifies the region where the peer VPC resides. For complete lists of supported regions, see [Amazon Web Services](https://docs.atlas.mongodb.com/reference/amazon-aws/).
        """
        return pulumi.get(self, "accepter_region_name")

    @_builtins.property
    @pulumi.getter(name="atlasCidrBlock")
    def atlas_cidr_block(self) -> _builtins.str:
        return pulumi.get(self, "atlas_cidr_block")

    @_builtins.property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> _builtins.str:
        """
        Account ID of the owner of the peer VPC.
        """
        return pulumi.get(self, "aws_account_id")

    @_builtins.property
    @pulumi.getter(name="azureDirectoryId")
    def azure_directory_id(self) -> _builtins.str:
        """
        Unique identifier for an Azure AD directory.
        """
        return pulumi.get(self, "azure_directory_id")

    @_builtins.property
    @pulumi.getter(name="azureSubscriptionId")
    def azure_subscription_id(self) -> _builtins.str:
        """
        Unique identifer of the Azure subscription in which the VNet resides.
        """
        return pulumi.get(self, "azure_subscription_id")

    @_builtins.property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> _builtins.str:
        """
        Unique identifier for the peering connection.
        """
        return pulumi.get(self, "connection_id")

    @_builtins.property
    @pulumi.getter(name="containerId")
    def container_id(self) -> _builtins.str:
        return pulumi.get(self, "container_id")

    @_builtins.property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> _builtins.str:
        """
        When `"status" : "FAILED"`, Atlas provides a description of the error.
        """
        return pulumi.get(self, "error_message")

    @_builtins.property
    @pulumi.getter(name="errorState")
    def error_state(self) -> _builtins.str:
        """
        Description of the Atlas error when `status` is `Failed`, Otherwise, Atlas returns `null`.
        """
        return pulumi.get(self, "error_state")

    @_builtins.property
    @pulumi.getter(name="errorStateName")
    def error_state_name(self) -> _builtins.str:
        """
        Error state, if any. The VPC peering connection error state value can be one of the following: `REJECTED`, `EXPIRED`, `INVALID_ARGUMENT`.
        """
        return pulumi.get(self, "error_state_name")

    @_builtins.property
    @pulumi.getter(name="gcpProjectId")
    def gcp_project_id(self) -> _builtins.str:
        """
        GCP project ID of the owner of the network peer.
        """
        return pulumi.get(self, "gcp_project_id")

    @_builtins.property
    @pulumi.getter(name="networkName")
    def network_name(self) -> _builtins.str:
        """
        Name of the network peer to which Atlas connects.
        """
        return pulumi.get(self, "network_name")

    @_builtins.property
    @pulumi.getter(name="peeringId")
    def peering_id(self) -> _builtins.str:
        """
        Atlas assigned unique ID for the peering connection.
        """
        return pulumi.get(self, "peering_id")

    @_builtins.property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> _builtins.str:
        """
        Cloud provider for this VPC peering connection. If omitted, Atlas sets this parameter to AWS. (Possible Values `AWS`, `AZURE`, `GCP`).
        """
        return pulumi.get(self, "provider_name")

    @_builtins.property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> _builtins.str:
        """
        Name of your Azure resource group.
        """
        return pulumi.get(self, "resource_group_name")

    @_builtins.property
    @pulumi.getter(name="routeTableCidrBlock")
    def route_table_cidr_block(self) -> _builtins.str:
        """
        Peer VPC CIDR block or subnet.
        """
        return pulumi.get(self, "route_table_cidr_block")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Status of the Atlas network peering connection: `ADDING_PEER`, `AVAILABLE`, `FAILED`, `DELETING`, `WAITING_FOR_USER`.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="statusName")
    def status_name(self) -> _builtins.str:
        """
        The VPC peering connection status value can be one of the following: `INITIATING`, `PENDING_ACCEPTANCE`, `FAILED`, `FINALIZING`, `AVAILABLE`, `TERMINATING`.
        """
        return pulumi.get(self, "status_name")

    @_builtins.property
    @pulumi.getter(name="vnetName")
    def vnet_name(self) -> _builtins.str:
        """
        Name of your Azure VNet.
        """
        return pulumi.get(self, "vnet_name")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        Unique identifier of the peer VPC.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetOnlineArchiveCriteriaResult(dict):
    def __init__(__self__, *,
                 date_field: _builtins.str,
                 date_format: _builtins.str,
                 expire_after_days: _builtins.int,
                 query: _builtins.str,
                 type: _builtins.str):
        pulumi.set(__self__, "date_field", date_field)
        pulumi.set(__self__, "date_format", date_format)
        pulumi.set(__self__, "expire_after_days", expire_after_days)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="dateField")
    def date_field(self) -> _builtins.str:
        return pulumi.get(self, "date_field")

    @_builtins.property
    @pulumi.getter(name="dateFormat")
    def date_format(self) -> _builtins.str:
        return pulumi.get(self, "date_format")

    @_builtins.property
    @pulumi.getter(name="expireAfterDays")
    def expire_after_days(self) -> _builtins.int:
        return pulumi.get(self, "expire_after_days")

    @_builtins.property
    @pulumi.getter
    def query(self) -> _builtins.str:
        return pulumi.get(self, "query")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetOnlineArchiveDataExpirationRuleResult(dict):
    def __init__(__self__, *,
                 expire_after_days: _builtins.int):
        pulumi.set(__self__, "expire_after_days", expire_after_days)

    @_builtins.property
    @pulumi.getter(name="expireAfterDays")
    def expire_after_days(self) -> _builtins.int:
        return pulumi.get(self, "expire_after_days")


@pulumi.output_type
class GetOnlineArchiveDataProcessRegionResult(dict):
    def __init__(__self__, *,
                 cloud_provider: _builtins.str,
                 region: _builtins.str):
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> _builtins.str:
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetOnlineArchivePartitionFieldResult(dict):
    def __init__(__self__, *,
                 field_name: _builtins.str,
                 field_type: _builtins.str,
                 order: _builtins.int):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "field_type", field_type)
        pulumi.set(__self__, "order", order)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> _builtins.str:
        return pulumi.get(self, "field_name")

    @_builtins.property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> _builtins.str:
        return pulumi.get(self, "field_type")

    @_builtins.property
    @pulumi.getter
    def order(self) -> _builtins.int:
        return pulumi.get(self, "order")


@pulumi.output_type
class GetOnlineArchiveScheduleResult(dict):
    def __init__(__self__, *,
                 end_hour: _builtins.int,
                 end_minute: _builtins.int,
                 start_hour: _builtins.int,
                 start_minute: _builtins.int,
                 type: _builtins.str,
                 day_of_month: Optional[_builtins.int] = None,
                 day_of_week: Optional[_builtins.int] = None):
        pulumi.set(__self__, "end_hour", end_hour)
        pulumi.set(__self__, "end_minute", end_minute)
        pulumi.set(__self__, "start_hour", start_hour)
        pulumi.set(__self__, "start_minute", start_minute)
        pulumi.set(__self__, "type", type)
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)

    @_builtins.property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> _builtins.int:
        return pulumi.get(self, "end_hour")

    @_builtins.property
    @pulumi.getter(name="endMinute")
    def end_minute(self) -> _builtins.int:
        return pulumi.get(self, "end_minute")

    @_builtins.property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> _builtins.int:
        return pulumi.get(self, "start_hour")

    @_builtins.property
    @pulumi.getter(name="startMinute")
    def start_minute(self) -> _builtins.int:
        return pulumi.get(self, "start_minute")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "day_of_month")

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "day_of_week")


@pulumi.output_type
class GetOnlineArchivesResultResult(dict):
    def __init__(__self__, *,
                 archive_id: _builtins.str,
                 cluster_name: _builtins.str,
                 coll_name: _builtins.str,
                 collection_type: _builtins.str,
                 criterias: Sequence['outputs.GetOnlineArchivesResultCriteriaResult'],
                 data_expiration_rules: Sequence['outputs.GetOnlineArchivesResultDataExpirationRuleResult'],
                 data_process_regions: Sequence['outputs.GetOnlineArchivesResultDataProcessRegionResult'],
                 db_name: _builtins.str,
                 partition_fields: Sequence['outputs.GetOnlineArchivesResultPartitionFieldResult'],
                 paused: _builtins.bool,
                 project_id: _builtins.str,
                 schedules: Sequence['outputs.GetOnlineArchivesResultScheduleResult'],
                 state: _builtins.str):
        """
        :param _builtins.str cluster_name: Name of the cluster that contains the collection.
               
               # Attributes Reference
               
               In addition to all arguments above, the following attributes are exported:
        :param _builtins.str project_id: The unique ID for the project.
        """
        pulumi.set(__self__, "archive_id", archive_id)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "coll_name", coll_name)
        pulumi.set(__self__, "collection_type", collection_type)
        pulumi.set(__self__, "criterias", criterias)
        pulumi.set(__self__, "data_expiration_rules", data_expiration_rules)
        pulumi.set(__self__, "data_process_regions", data_process_regions)
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "partition_fields", partition_fields)
        pulumi.set(__self__, "paused", paused)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "schedules", schedules)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="archiveId")
    def archive_id(self) -> _builtins.str:
        return pulumi.get(self, "archive_id")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> _builtins.str:
        """
        Name of the cluster that contains the collection.

        # Attributes Reference

        In addition to all arguments above, the following attributes are exported:
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="collName")
    def coll_name(self) -> _builtins.str:
        return pulumi.get(self, "coll_name")

    @_builtins.property
    @pulumi.getter(name="collectionType")
    def collection_type(self) -> _builtins.str:
        return pulumi.get(self, "collection_type")

    @_builtins.property
    @pulumi.getter
    def criterias(self) -> Sequence['outputs.GetOnlineArchivesResultCriteriaResult']:
        return pulumi.get(self, "criterias")

    @_builtins.property
    @pulumi.getter(name="dataExpirationRules")
    def data_expiration_rules(self) -> Sequence['outputs.GetOnlineArchivesResultDataExpirationRuleResult']:
        return pulumi.get(self, "data_expiration_rules")

    @_builtins.property
    @pulumi.getter(name="dataProcessRegions")
    def data_process_regions(self) -> Sequence['outputs.GetOnlineArchivesResultDataProcessRegionResult']:
        return pulumi.get(self, "data_process_regions")

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> _builtins.str:
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="partitionFields")
    def partition_fields(self) -> Sequence['outputs.GetOnlineArchivesResultPartitionFieldResult']:
        return pulumi.get(self, "partition_fields")

    @_builtins.property
    @pulumi.getter
    def paused(self) -> _builtins.bool:
        return pulumi.get(self, "paused")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The unique ID for the project.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.GetOnlineArchivesResultScheduleResult']:
        return pulumi.get(self, "schedules")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")


@pulumi.output_type
class GetOnlineArchivesResultCriteriaResult(dict):
    def __init__(__self__, *,
                 date_field: _builtins.str,
                 date_format: _builtins.str,
                 expire_after_days: _builtins.int,
                 query: _builtins.str,
                 type: _builtins.str):
        pulumi.set(__self__, "date_field", date_field)
        pulumi.set(__self__, "date_format", date_format)
        pulumi.set(__self__, "expire_after_days", expire_after_days)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="dateField")
    def date_field(self) -> _builtins.str:
        return pulumi.get(self, "date_field")

    @_builtins.property
    @pulumi.getter(name="dateFormat")
    def date_format(self) -> _builtins.str:
        return pulumi.get(self, "date_format")

    @_builtins.property
    @pulumi.getter(name="expireAfterDays")
    def expire_after_days(self) -> _builtins.int:
        return pulumi.get(self, "expire_after_days")

    @_builtins.property
    @pulumi.getter
    def query(self) -> _builtins.str:
        return pulumi.get(self, "query")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetOnlineArchivesResultDataExpirationRuleResult(dict):
    def __init__(__self__, *,
                 expire_after_days: _builtins.int):
        pulumi.set(__self__, "expire_after_days", expire_after_days)

    @_builtins.property
    @pulumi.getter(name="expireAfterDays")
    def expire_after_days(self) -> _builtins.int:
        return pulumi.get(self, "expire_after_days")


@pulumi.output_type
class GetOnlineArchivesResultDataProcessRegionResult(dict):
    def __init__(__self__, *,
                 cloud_provider: _builtins.str,
                 region: _builtins.str):
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> _builtins.str:
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetOnlineArchivesResultPartitionFieldResult(dict):
    def __init__(__self__, *,
                 field_name: _builtins.str,
                 field_type: _builtins.str,
                 order: _builtins.int):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "field_type", field_type)
        pulumi.set(__self__, "order", order)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> _builtins.str:
        return pulumi.get(self, "field_name")

    @_builtins.property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> _builtins.str:
        return pulumi.get(self, "field_type")

    @_builtins.property
    @pulumi.getter
    def order(self) -> _builtins.int:
        return pulumi.get(self, "order")


@pulumi.output_type
class GetOnlineArchivesResultScheduleResult(dict):
    def __init__(__self__, *,
                 end_hour: _builtins.int,
                 end_minute: _builtins.int,
                 start_hour: _builtins.int,
                 start_minute: _builtins.int,
                 type: _builtins.str,
                 day_of_month: Optional[_builtins.int] = None,
                 day_of_week: Optional[_builtins.int] = None):
        pulumi.set(__self__, "end_hour", end_hour)
        pulumi.set(__self__, "end_minute", end_minute)
        pulumi.set(__self__, "start_hour", start_hour)
        pulumi.set(__self__, "start_minute", start_minute)
        pulumi.set(__self__, "type", type)
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)

    @_builtins.property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> _builtins.int:
        return pulumi.get(self, "end_hour")

    @_builtins.property
    @pulumi.getter(name="endMinute")
    def end_minute(self) -> _builtins.int:
        return pulumi.get(self, "end_minute")

    @_builtins.property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> _builtins.int:
        return pulumi.get(self, "start_hour")

    @_builtins.property
    @pulumi.getter(name="startMinute")
    def start_minute(self) -> _builtins.int:
        return pulumi.get(self, "start_minute")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "day_of_month")

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "day_of_week")


@pulumi.output_type
class GetOrganizationLinkResult(dict):
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        return pulumi.get(self, "href")

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetOrganizationUserResult(dict):
    def __init__(__self__, *,
                 country: _builtins.str,
                 created_at: _builtins.str,
                 first_name: _builtins.str,
                 id: _builtins.str,
                 invitation_created_at: _builtins.str,
                 invitation_expires_at: _builtins.str,
                 inviter_username: _builtins.str,
                 last_auth: _builtins.str,
                 last_name: _builtins.str,
                 mobile_number: _builtins.str,
                 org_membership_status: _builtins.str,
                 roles: Sequence['outputs.GetOrganizationUserRoleResult'],
                 team_ids: Sequence[_builtins.str],
                 username: _builtins.str):
        """
        :param _builtins.str country: Two-character alphabetical string that identifies the MongoDB Cloud user's geographic location. This parameter uses the ISO 3166-1a2 code format.
        :param _builtins.str created_at: Date and time when MongoDB Cloud created the current account. This value is in the ISO 8601 timestamp format in UTC.
        :param _builtins.str first_name: First or given name that belongs to the MongoDB Cloud user.
        :param _builtins.str id: Unique 24-hexadecimal digit string that identifies the MongoDB Cloud user.
        :param _builtins.str invitation_created_at: Date and time when MongoDB Cloud sent the invitation. MongoDB Cloud represents this timestamp in ISO 8601 format in UTC.
        :param _builtins.str invitation_expires_at: Date and time when the invitation from MongoDB Cloud expires. MongoDB Cloud represents this timestamp in ISO 8601 format in UTC.
        :param _builtins.str inviter_username: Username of the MongoDB Cloud user who sent the invitation to join the organization.
        :param _builtins.str last_auth: Date and time when the current account last authenticated. This value is in the ISO 8601 timestamp format in UTC.
        :param _builtins.str last_name: Last name, family name, or surname that belongs to the MongoDB Cloud user.
        :param _builtins.str mobile_number: Mobile phone number that belongs to the MongoDB Cloud user.
        :param _builtins.str org_membership_status: String enum that indicates whether the MongoDB Cloud user has a pending invitation to join the organization or they are already active in the organization.
        :param Sequence['GetOrganizationUserRoleArgs'] roles: Organization- and project-level roles assigned to one MongoDB Cloud user within one organization.
        :param Sequence[_builtins.str] team_ids: List of unique 24-hexadecimal digit strings that identifies the teams to which this MongoDB Cloud user belongs.
        :param _builtins.str username: Email address that represents the username of the MongoDB Cloud user.
        """
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "invitation_created_at", invitation_created_at)
        pulumi.set(__self__, "invitation_expires_at", invitation_expires_at)
        pulumi.set(__self__, "inviter_username", inviter_username)
        pulumi.set(__self__, "last_auth", last_auth)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "mobile_number", mobile_number)
        pulumi.set(__self__, "org_membership_status", org_membership_status)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "team_ids", team_ids)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def country(self) -> _builtins.str:
        """
        Two-character alphabetical string that identifies the MongoDB Cloud user's geographic location. This parameter uses the ISO 3166-1a2 code format.
        """
        return pulumi.get(self, "country")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Date and time when MongoDB Cloud created the current account. This value is in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> _builtins.str:
        """
        First or given name that belongs to the MongoDB Cloud user.
        """
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the MongoDB Cloud user.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="invitationCreatedAt")
    def invitation_created_at(self) -> _builtins.str:
        """
        Date and time when MongoDB Cloud sent the invitation. MongoDB Cloud represents this timestamp in ISO 8601 format in UTC.
        """
        return pulumi.get(self, "invitation_created_at")

    @_builtins.property
    @pulumi.getter(name="invitationExpiresAt")
    def invitation_expires_at(self) -> _builtins.str:
        """
        Date and time when the invitation from MongoDB Cloud expires. MongoDB Cloud represents this timestamp in ISO 8601 format in UTC.
        """
        return pulumi.get(self, "invitation_expires_at")

    @_builtins.property
    @pulumi.getter(name="inviterUsername")
    def inviter_username(self) -> _builtins.str:
        """
        Username of the MongoDB Cloud user who sent the invitation to join the organization.
        """
        return pulumi.get(self, "inviter_username")

    @_builtins.property
    @pulumi.getter(name="lastAuth")
    def last_auth(self) -> _builtins.str:
        """
        Date and time when the current account last authenticated. This value is in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "last_auth")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> _builtins.str:
        """
        Last name, family name, or surname that belongs to the MongoDB Cloud user.
        """
        return pulumi.get(self, "last_name")

    @_builtins.property
    @pulumi.getter(name="mobileNumber")
    def mobile_number(self) -> _builtins.str:
        """
        Mobile phone number that belongs to the MongoDB Cloud user.
        """
        return pulumi.get(self, "mobile_number")

    @_builtins.property
    @pulumi.getter(name="orgMembershipStatus")
    def org_membership_status(self) -> _builtins.str:
        """
        String enum that indicates whether the MongoDB Cloud user has a pending invitation to join the organization or they are already active in the organization.
        """
        return pulumi.get(self, "org_membership_status")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Sequence['outputs.GetOrganizationUserRoleResult']:
        """
        Organization- and project-level roles assigned to one MongoDB Cloud user within one organization.
        """
        return pulumi.get(self, "roles")

    @_builtins.property
    @pulumi.getter(name="teamIds")
    def team_ids(self) -> Sequence[_builtins.str]:
        """
        List of unique 24-hexadecimal digit strings that identifies the teams to which this MongoDB Cloud user belongs.
        """
        return pulumi.get(self, "team_ids")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Email address that represents the username of the MongoDB Cloud user.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetOrganizationUserRoleResult(dict):
    def __init__(__self__, *,
                 org_roles: Sequence[_builtins.str],
                 project_role_assignments: Sequence['outputs.GetOrganizationUserRoleProjectRoleAssignmentResult']):
        pulumi.set(__self__, "org_roles", org_roles)
        pulumi.set(__self__, "project_role_assignments", project_role_assignments)

    @_builtins.property
    @pulumi.getter(name="orgRoles")
    def org_roles(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "org_roles")

    @_builtins.property
    @pulumi.getter(name="projectRoleAssignments")
    def project_role_assignments(self) -> Sequence['outputs.GetOrganizationUserRoleProjectRoleAssignmentResult']:
        return pulumi.get(self, "project_role_assignments")


@pulumi.output_type
class GetOrganizationUserRoleProjectRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 project_id: _builtins.str,
                 project_roles: Sequence[_builtins.str]):
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "project_roles", project_roles)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="projectRoles")
    def project_roles(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "project_roles")


@pulumi.output_type
class GetOrganizationsResultResult(dict):
    def __init__(__self__, *,
                 api_access_list_required: _builtins.bool,
                 gen_ai_features_enabled: _builtins.bool,
                 id: _builtins.str,
                 is_deleted: _builtins.bool,
                 links: Sequence['outputs.GetOrganizationsResultLinkResult'],
                 multi_factor_auth_required: _builtins.bool,
                 name: _builtins.str,
                 restrict_employee_access: _builtins.bool,
                 security_contact: _builtins.str,
                 skip_default_alerts_settings: _builtins.bool,
                 users: Sequence['outputs.GetOrganizationsResultUserResult']):
        """
        :param _builtins.bool api_access_list_required: Flag that indicates whether to require API operations to originate from an IP Address added to the API access list for the specified organization.
        :param _builtins.bool gen_ai_features_enabled: Flag that indicates whether this organization has access to generative AI features. This setting only applies to Atlas Commercial and defaults to `true`. With this setting on, Project Owners may be able to enable or disable individual AI features at the project level. To learn more, see https://www.mongodb.com/docs/generative-ai-faq/.
        :param _builtins.str id: Autogenerated Unique ID for this data source.
        :param _builtins.bool is_deleted: Flag that indicates whether this organization has been deleted.
        :param _builtins.bool multi_factor_auth_required: Flag that indicates whether to require users to set up Multi-Factor Authentication (MFA) before accessing the specified organization. To learn more, see: https://www.mongodb.com/docs/atlas/security-multi-factor-authentication/.
        :param _builtins.str name: Human-readable label that identifies the organization.
        :param _builtins.bool restrict_employee_access: Flag that indicates whether to block MongoDB Support from accessing Atlas infrastructure for any deployment in the specified organization without explicit permission. Once this setting is turned on, you can grant MongoDB Support a 24-hour bypass access to the Atlas deployment to resolve support issues. To learn more, see: https://www.mongodb.com/docs/atlas/security-restrict-support-access/.
        :param _builtins.str security_contact: String that specifies a single email address for the specified organization to receive security-related notifications. Specifying a security contact does not grant them authorization or access to Atlas for security decisions or approvals.
        :param Sequence['GetOrganizationsResultUserArgs'] users: Returns list of all pending and active MongoDB Cloud users associated with the specified organization.
        """
        pulumi.set(__self__, "api_access_list_required", api_access_list_required)
        pulumi.set(__self__, "gen_ai_features_enabled", gen_ai_features_enabled)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_deleted", is_deleted)
        pulumi.set(__self__, "links", links)
        pulumi.set(__self__, "multi_factor_auth_required", multi_factor_auth_required)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "restrict_employee_access", restrict_employee_access)
        pulumi.set(__self__, "security_contact", security_contact)
        pulumi.set(__self__, "skip_default_alerts_settings", skip_default_alerts_settings)
        pulumi.set(__self__, "users", users)

    @_builtins.property
    @pulumi.getter(name="apiAccessListRequired")
    def api_access_list_required(self) -> _builtins.bool:
        """
        Flag that indicates whether to require API operations to originate from an IP Address added to the API access list for the specified organization.
        """
        return pulumi.get(self, "api_access_list_required")

    @_builtins.property
    @pulumi.getter(name="genAiFeaturesEnabled")
    def gen_ai_features_enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether this organization has access to generative AI features. This setting only applies to Atlas Commercial and defaults to `true`. With this setting on, Project Owners may be able to enable or disable individual AI features at the project level. To learn more, see https://www.mongodb.com/docs/generative-ai-faq/.
        """
        return pulumi.get(self, "gen_ai_features_enabled")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Autogenerated Unique ID for this data source.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isDeleted")
    def is_deleted(self) -> _builtins.bool:
        """
        Flag that indicates whether this organization has been deleted.
        """
        return pulumi.get(self, "is_deleted")

    @_builtins.property
    @pulumi.getter
    def links(self) -> Sequence['outputs.GetOrganizationsResultLinkResult']:
        return pulumi.get(self, "links")

    @_builtins.property
    @pulumi.getter(name="multiFactorAuthRequired")
    def multi_factor_auth_required(self) -> _builtins.bool:
        """
        Flag that indicates whether to require users to set up Multi-Factor Authentication (MFA) before accessing the specified organization. To learn more, see: https://www.mongodb.com/docs/atlas/security-multi-factor-authentication/.
        """
        return pulumi.get(self, "multi_factor_auth_required")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Human-readable label that identifies the organization.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="restrictEmployeeAccess")
    def restrict_employee_access(self) -> _builtins.bool:
        """
        Flag that indicates whether to block MongoDB Support from accessing Atlas infrastructure for any deployment in the specified organization without explicit permission. Once this setting is turned on, you can grant MongoDB Support a 24-hour bypass access to the Atlas deployment to resolve support issues. To learn more, see: https://www.mongodb.com/docs/atlas/security-restrict-support-access/.
        """
        return pulumi.get(self, "restrict_employee_access")

    @_builtins.property
    @pulumi.getter(name="securityContact")
    def security_contact(self) -> _builtins.str:
        """
        String that specifies a single email address for the specified organization to receive security-related notifications. Specifying a security contact does not grant them authorization or access to Atlas for security decisions or approvals.
        """
        return pulumi.get(self, "security_contact")

    @_builtins.property
    @pulumi.getter(name="skipDefaultAlertsSettings")
    def skip_default_alerts_settings(self) -> _builtins.bool:
        return pulumi.get(self, "skip_default_alerts_settings")

    @_builtins.property
    @pulumi.getter
    def users(self) -> Sequence['outputs.GetOrganizationsResultUserResult']:
        """
        Returns list of all pending and active MongoDB Cloud users associated with the specified organization.
        """
        return pulumi.get(self, "users")


@pulumi.output_type
class GetOrganizationsResultLinkResult(dict):
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        return pulumi.get(self, "href")

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetOrganizationsResultUserResult(dict):
    def __init__(__self__, *,
                 country: _builtins.str,
                 created_at: _builtins.str,
                 first_name: _builtins.str,
                 id: _builtins.str,
                 invitation_created_at: _builtins.str,
                 invitation_expires_at: _builtins.str,
                 inviter_username: _builtins.str,
                 last_auth: _builtins.str,
                 last_name: _builtins.str,
                 mobile_number: _builtins.str,
                 org_membership_status: _builtins.str,
                 roles: Sequence['outputs.GetOrganizationsResultUserRoleResult'],
                 team_ids: Sequence[_builtins.str],
                 username: _builtins.str):
        """
        :param _builtins.str country: Two-character alphabetical string that identifies the MongoDB Cloud user's geographic location. This parameter uses the ISO 3166-1a2 code format.
        :param _builtins.str created_at: Date and time when MongoDB Cloud created the current account. This value is in the ISO 8601 timestamp format in UTC.
        :param _builtins.str first_name: First or given name that belongs to the MongoDB Cloud user.
        :param _builtins.str id: Unique 24-hexadecimal digit string that identifies the MongoDB Cloud user.
        :param _builtins.str invitation_created_at: Date and time when MongoDB Cloud sent the invitation. MongoDB Cloud represents this timestamp in ISO 8601 format in UTC.
        :param _builtins.str invitation_expires_at: Date and time when the invitation from MongoDB Cloud expires. MongoDB Cloud represents this timestamp in ISO 8601 format in UTC.
        :param _builtins.str inviter_username: Username of the MongoDB Cloud user who sent the invitation to join the organization.
        :param _builtins.str last_auth: Date and time when the current account last authenticated. This value is in the ISO 8601 timestamp format in UTC.
        :param _builtins.str last_name: Last name, family name, or surname that belongs to the MongoDB Cloud user.
        :param _builtins.str org_membership_status: String enum that indicates whether the MongoDB Cloud user has a pending invitation to join the organization or they are already active in the organization.
        :param Sequence['GetOrganizationsResultUserRoleArgs'] roles: Organization- and project-level roles assigned to one MongoDB Cloud user within one organization.
               * `teamIds` - List of unique 24-hexadecimal digit strings that identifies the teams to which this MongoDB Cloud user belongs.
        :param _builtins.str username: Email address that represents the username of the MongoDB Cloud user.
        """
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "invitation_created_at", invitation_created_at)
        pulumi.set(__self__, "invitation_expires_at", invitation_expires_at)
        pulumi.set(__self__, "inviter_username", inviter_username)
        pulumi.set(__self__, "last_auth", last_auth)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "mobile_number", mobile_number)
        pulumi.set(__self__, "org_membership_status", org_membership_status)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "team_ids", team_ids)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def country(self) -> _builtins.str:
        """
        Two-character alphabetical string that identifies the MongoDB Cloud user's geographic location. This parameter uses the ISO 3166-1a2 code format.
        """
        return pulumi.get(self, "country")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Date and time when MongoDB Cloud created the current account. This value is in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> _builtins.str:
        """
        First or given name that belongs to the MongoDB Cloud user.
        """
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the MongoDB Cloud user.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="invitationCreatedAt")
    def invitation_created_at(self) -> _builtins.str:
        """
        Date and time when MongoDB Cloud sent the invitation. MongoDB Cloud represents this timestamp in ISO 8601 format in UTC.
        """
        return pulumi.get(self, "invitation_created_at")

    @_builtins.property
    @pulumi.getter(name="invitationExpiresAt")
    def invitation_expires_at(self) -> _builtins.str:
        """
        Date and time when the invitation from MongoDB Cloud expires. MongoDB Cloud represents this timestamp in ISO 8601 format in UTC.
        """
        return pulumi.get(self, "invitation_expires_at")

    @_builtins.property
    @pulumi.getter(name="inviterUsername")
    def inviter_username(self) -> _builtins.str:
        """
        Username of the MongoDB Cloud user who sent the invitation to join the organization.
        """
        return pulumi.get(self, "inviter_username")

    @_builtins.property
    @pulumi.getter(name="lastAuth")
    def last_auth(self) -> _builtins.str:
        """
        Date and time when the current account last authenticated. This value is in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "last_auth")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> _builtins.str:
        """
        Last name, family name, or surname that belongs to the MongoDB Cloud user.
        """
        return pulumi.get(self, "last_name")

    @_builtins.property
    @pulumi.getter(name="mobileNumber")
    def mobile_number(self) -> _builtins.str:
        return pulumi.get(self, "mobile_number")

    @_builtins.property
    @pulumi.getter(name="orgMembershipStatus")
    def org_membership_status(self) -> _builtins.str:
        """
        String enum that indicates whether the MongoDB Cloud user has a pending invitation to join the organization or they are already active in the organization.
        """
        return pulumi.get(self, "org_membership_status")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Sequence['outputs.GetOrganizationsResultUserRoleResult']:
        """
        Organization- and project-level roles assigned to one MongoDB Cloud user within one organization.
        * `teamIds` - List of unique 24-hexadecimal digit strings that identifies the teams to which this MongoDB Cloud user belongs.
        """
        return pulumi.get(self, "roles")

    @_builtins.property
    @pulumi.getter(name="teamIds")
    def team_ids(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "team_ids")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Email address that represents the username of the MongoDB Cloud user.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetOrganizationsResultUserRoleResult(dict):
    def __init__(__self__, *,
                 org_roles: Sequence[_builtins.str],
                 project_role_assignments: Sequence['outputs.GetOrganizationsResultUserRoleProjectRoleAssignmentResult']):
        pulumi.set(__self__, "org_roles", org_roles)
        pulumi.set(__self__, "project_role_assignments", project_role_assignments)

    @_builtins.property
    @pulumi.getter(name="orgRoles")
    def org_roles(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "org_roles")

    @_builtins.property
    @pulumi.getter(name="projectRoleAssignments")
    def project_role_assignments(self) -> Sequence['outputs.GetOrganizationsResultUserRoleProjectRoleAssignmentResult']:
        return pulumi.get(self, "project_role_assignments")


@pulumi.output_type
class GetOrganizationsResultUserRoleProjectRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 project_id: _builtins.str,
                 project_roles: Sequence[_builtins.str]):
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "project_roles", project_roles)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="projectRoles")
    def project_roles(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "project_roles")


@pulumi.output_type
class GetPrivateLinkEndpointServiceEndpointResult(dict):
    def __init__(__self__, *,
                 endpoint_name: _builtins.str,
                 ip_address: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str endpoint_name: Forwarding rule that corresponds to the endpoint you created in GCP.
        :param _builtins.str ip_address: Private IP address of the network endpoint group you created in GCP.
        :param _builtins.str status: Status of the endpoint. Atlas returns one of the [values shown above](https://docs.atlas.mongodb.com/reference/api/private-endpoints-endpoint-create-one/#std-label-ref-status-field).
        """
        pulumi.set(__self__, "endpoint_name", endpoint_name)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="endpointName")
    def endpoint_name(self) -> _builtins.str:
        """
        Forwarding rule that corresponds to the endpoint you created in GCP.
        """
        return pulumi.get(self, "endpoint_name")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> _builtins.str:
        """
        Private IP address of the network endpoint group you created in GCP.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Status of the endpoint. Atlas returns one of the [values shown above](https://docs.atlas.mongodb.com/reference/api/private-endpoints-endpoint-create-one/#std-label-ref-status-field).
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetPrivatelinkEndpointServiceDataFederationOnlineArchivesResultResult(dict):
    def __init__(__self__, *,
                 comment: _builtins.str,
                 customer_endpoint_dns_name: _builtins.str,
                 endpoint_id: _builtins.str,
                 provider_name: _builtins.str,
                 region: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str comment: Human-readable string to associate with this private endpoint.
        :param _builtins.str customer_endpoint_dns_name: (Optional) Human-readable label to identify VPC endpoint DNS name.
        :param _builtins.str endpoint_id: Unique 22-character alphanumeric string that identifies the private endpoint. See [Atlas Data Federation supports Amazon Web Services private endpoints using the AWS PrivateLink feature](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation/operation/createDataFederationPrivateEndpoint).
        :param _builtins.str provider_name: Human-readable label that identifies the cloud service provider.
        :param _builtins.str region: Human-readable label to identify the region of VPC endpoint.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        :param _builtins.str type: Human-readable label that identifies the resource type associated with this private endpoint.
        """
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "customer_endpoint_dns_name", customer_endpoint_dns_name)
        pulumi.set(__self__, "endpoint_id", endpoint_id)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> _builtins.str:
        """
        Human-readable string to associate with this private endpoint.
        """
        return pulumi.get(self, "comment")

    @_builtins.property
    @pulumi.getter(name="customerEndpointDnsName")
    def customer_endpoint_dns_name(self) -> _builtins.str:
        """
        (Optional) Human-readable label to identify VPC endpoint DNS name.
        """
        return pulumi.get(self, "customer_endpoint_dns_name")

    @_builtins.property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> _builtins.str:
        """
        Unique 22-character alphanumeric string that identifies the private endpoint. See [Atlas Data Federation supports Amazon Web Services private endpoints using the AWS PrivateLink feature](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation/operation/createDataFederationPrivateEndpoint).
        """
        return pulumi.get(self, "endpoint_id")

    @_builtins.property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> _builtins.str:
        """
        Human-readable label that identifies the cloud service provider.
        """
        return pulumi.get(self, "provider_name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Human-readable label to identify the region of VPC endpoint.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Human-readable label that identifies the resource type associated with this private endpoint.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetProjectApiKeyProjectAssignmentResult(dict):
    def __init__(__self__, *,
                 project_id: _builtins.str,
                 role_names: Sequence[_builtins.str]):
        """
        :param _builtins.str project_id: The unique ID for the project.
        :param Sequence[_builtins.str] role_names: List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project. You must specify an array even if you are only associating a single role with the Programmatic API key. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) describes the valid roles that can be assigned.
        """
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "role_names", role_names)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The unique ID for the project.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[_builtins.str]:
        """
        List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project. You must specify an array even if you are only associating a single role with the Programmatic API key. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) describes the valid roles that can be assigned.
        """
        return pulumi.get(self, "role_names")


@pulumi.output_type
class GetProjectApiKeysResultResult(dict):
    def __init__(__self__, *,
                 api_key_id: _builtins.str,
                 description: _builtins.str,
                 private_key: _builtins.str,
                 public_key: _builtins.str,
                 project_assignments: Optional[Sequence['outputs.GetProjectApiKeysResultProjectAssignmentResult']] = None):
        """
        :param _builtins.str api_key_id: Unique identifier for the API key you want to update. Use the /orgs/{ORG-ID}/apiKeys endpoint to retrieve all API keys to which the authenticated user has access for the specified organization.
        :param _builtins.str description: Description of this Project API key.
        """
        pulumi.set(__self__, "api_key_id", api_key_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "public_key", public_key)
        if project_assignments is not None:
            pulumi.set(__self__, "project_assignments", project_assignments)

    @_builtins.property
    @pulumi.getter(name="apiKeyId")
    def api_key_id(self) -> _builtins.str:
        """
        Unique identifier for the API key you want to update. Use the /orgs/{ORG-ID}/apiKeys endpoint to retrieve all API keys to which the authenticated user has access for the specified organization.
        """
        return pulumi.get(self, "api_key_id")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of this Project API key.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> _builtins.str:
        return pulumi.get(self, "private_key")

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> _builtins.str:
        return pulumi.get(self, "public_key")

    @_builtins.property
    @pulumi.getter(name="projectAssignments")
    def project_assignments(self) -> Optional[Sequence['outputs.GetProjectApiKeysResultProjectAssignmentResult']]:
        return pulumi.get(self, "project_assignments")


@pulumi.output_type
class GetProjectApiKeysResultProjectAssignmentResult(dict):
    def __init__(__self__, *,
                 project_id: _builtins.str,
                 role_names: Sequence[_builtins.str]):
        """
        :param _builtins.str project_id: The unique ID for the project.
        :param Sequence[_builtins.str] role_names: List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project. You must specify an array even if you are only associating a single role with the Programmatic API key. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) describes the valid roles that can be assigned.
        """
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "role_names", role_names)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The unique ID for the project.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[_builtins.str]:
        """
        List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project. You must specify an array even if you are only associating a single role with the Programmatic API key. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) describes the valid roles that can be assigned.
        """
        return pulumi.get(self, "role_names")


@pulumi.output_type
class GetProjectIpAddressesResult(dict):
    def __init__(__self__, *,
                 services: 'outputs.GetProjectIpAddressesServicesResult'):
        pulumi.set(__self__, "services", services)

    @_builtins.property
    @pulumi.getter
    def services(self) -> 'outputs.GetProjectIpAddressesServicesResult':
        return pulumi.get(self, "services")


@pulumi.output_type
class GetProjectIpAddressesServicesResult(dict):
    def __init__(__self__, *,
                 clusters: Sequence['outputs.GetProjectIpAddressesServicesClusterResult']):
        """
        :param Sequence['GetProjectIpAddressesServicesClusterArgs'] clusters: IP addresses of clusters.
        """
        pulumi.set(__self__, "clusters", clusters)

    @_builtins.property
    @pulumi.getter
    def clusters(self) -> Sequence['outputs.GetProjectIpAddressesServicesClusterResult']:
        """
        IP addresses of clusters.
        """
        return pulumi.get(self, "clusters")


@pulumi.output_type
class GetProjectIpAddressesServicesClusterResult(dict):
    def __init__(__self__, *,
                 cluster_name: _builtins.str,
                 future_inbounds: Sequence[_builtins.str],
                 future_outbounds: Sequence[_builtins.str],
                 inbounds: Sequence[_builtins.str],
                 outbounds: Sequence[_builtins.str]):
        """
        :param _builtins.str cluster_name: Human-readable label that identifies the cluster.
        :param Sequence[_builtins.str] future_inbounds: List of future inbound IP addresses associated with the cluster. If your network allows outbound HTTP requests only to specific IP addresses, you must allow access to the following IP addresses so that your application can connect to your Atlas cluster.
        :param Sequence[_builtins.str] future_outbounds: List of future outbound IP addresses associated with the cluster. If your network allows inbound HTTP requests only from specific IP addresses, you must allow access from the following IP addresses so that your Atlas cluster can communicate with your webhooks and KMS.
        :param Sequence[_builtins.str] inbounds: List of inbound IP addresses associated with the cluster. If your network allows outbound HTTP requests only to specific IP addresses, you must allow access to the following IP addresses so that your application can connect to your Atlas cluster.
        :param Sequence[_builtins.str] outbounds: List of outbound IP addresses associated with the cluster. If your network allows inbound HTTP requests only from specific IP addresses, you must allow access from the following IP addresses so that your Atlas cluster can communicate with your webhooks and KMS.
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "future_inbounds", future_inbounds)
        pulumi.set(__self__, "future_outbounds", future_outbounds)
        pulumi.set(__self__, "inbounds", inbounds)
        pulumi.set(__self__, "outbounds", outbounds)

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> _builtins.str:
        """
        Human-readable label that identifies the cluster.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="futureInbounds")
    def future_inbounds(self) -> Sequence[_builtins.str]:
        """
        List of future inbound IP addresses associated with the cluster. If your network allows outbound HTTP requests only to specific IP addresses, you must allow access to the following IP addresses so that your application can connect to your Atlas cluster.
        """
        return pulumi.get(self, "future_inbounds")

    @_builtins.property
    @pulumi.getter(name="futureOutbounds")
    def future_outbounds(self) -> Sequence[_builtins.str]:
        """
        List of future outbound IP addresses associated with the cluster. If your network allows inbound HTTP requests only from specific IP addresses, you must allow access from the following IP addresses so that your Atlas cluster can communicate with your webhooks and KMS.
        """
        return pulumi.get(self, "future_outbounds")

    @_builtins.property
    @pulumi.getter
    def inbounds(self) -> Sequence[_builtins.str]:
        """
        List of inbound IP addresses associated with the cluster. If your network allows outbound HTTP requests only to specific IP addresses, you must allow access to the following IP addresses so that your application can connect to your Atlas cluster.
        """
        return pulumi.get(self, "inbounds")

    @_builtins.property
    @pulumi.getter
    def outbounds(self) -> Sequence[_builtins.str]:
        """
        List of outbound IP addresses associated with the cluster. If your network allows inbound HTTP requests only from specific IP addresses, you must allow access from the following IP addresses so that your Atlas cluster can communicate with your webhooks and KMS.
        """
        return pulumi.get(self, "outbounds")


@pulumi.output_type
class GetProjectLimitResult(dict):
    def __init__(__self__, *,
                 current_usage: _builtins.int,
                 default_limit: _builtins.int,
                 maximum_limit: _builtins.int,
                 name: _builtins.str,
                 value: _builtins.int):
        """
        :param _builtins.int current_usage: Amount that indicates the current usage of the limit.
        :param _builtins.int default_limit: Default value of the limit.
        :param _builtins.int maximum_limit: Maximum value of the limit.
        :param _builtins.str name: The unique ID for the project.
               
               > **IMPORTANT:** Either `project_id` or `name` must be configurated.
        :param _builtins.int value: Amount the limit is set to.
        """
        pulumi.set(__self__, "current_usage", current_usage)
        pulumi.set(__self__, "default_limit", default_limit)
        pulumi.set(__self__, "maximum_limit", maximum_limit)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="currentUsage")
    def current_usage(self) -> _builtins.int:
        """
        Amount that indicates the current usage of the limit.
        """
        return pulumi.get(self, "current_usage")

    @_builtins.property
    @pulumi.getter(name="defaultLimit")
    def default_limit(self) -> _builtins.int:
        """
        Default value of the limit.
        """
        return pulumi.get(self, "default_limit")

    @_builtins.property
    @pulumi.getter(name="maximumLimit")
    def maximum_limit(self) -> _builtins.int:
        """
        Maximum value of the limit.
        """
        return pulumi.get(self, "maximum_limit")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The unique ID for the project.

        > **IMPORTANT:** Either `project_id` or `name` must be configurated.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        """
        Amount the limit is set to.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetProjectServiceAccountAccessListEntriesResultResult(dict):
    def __init__(__self__, *,
                 cidr_block: _builtins.str,
                 client_id: _builtins.str,
                 created_at: _builtins.str,
                 ip_address: _builtins.str,
                 last_used_address: _builtins.str,
                 last_used_at: _builtins.str,
                 project_id: _builtins.str,
                 request_count: _builtins.int):
        """
        :param _builtins.str cidr_block: Range of IP addresses in CIDR notation to be added to the access list. You can set a value for this parameter or **ip_address**, but not for both.
        :param _builtins.str client_id: The Client ID of the Service Account.
        :param _builtins.str created_at: Date the entry was added to the access list. This attribute expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str ip_address: IP address to be added to the access list. You can set a value for this parameter or **cidr_block**, but not for both.
        :param _builtins.str last_used_address: Network address that issued the most recent request to the API.
        :param _builtins.str last_used_at: Date when the API received the most recent request that originated from this network address.
        :param _builtins.str project_id: Unique 24-hexadecimal digit string that identifies the project.
        :param _builtins.int request_count: The number of requests that has originated from this network address.
        """
        pulumi.set(__self__, "cidr_block", cidr_block)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "last_used_address", last_used_address)
        pulumi.set(__self__, "last_used_at", last_used_at)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "request_count", request_count)

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> _builtins.str:
        """
        Range of IP addresses in CIDR notation to be added to the access list. You can set a value for this parameter or **ip_address**, but not for both.
        """
        return pulumi.get(self, "cidr_block")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The Client ID of the Service Account.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Date the entry was added to the access list. This attribute expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> _builtins.str:
        """
        IP address to be added to the access list. You can set a value for this parameter or **cidr_block**, but not for both.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter(name="lastUsedAddress")
    def last_used_address(self) -> _builtins.str:
        """
        Network address that issued the most recent request to the API.
        """
        return pulumi.get(self, "last_used_address")

    @_builtins.property
    @pulumi.getter(name="lastUsedAt")
    def last_used_at(self) -> _builtins.str:
        """
        Date when the API received the most recent request that originated from this network address.
        """
        return pulumi.get(self, "last_used_at")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the project.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="requestCount")
    def request_count(self) -> _builtins.int:
        """
        The number of requests that has originated from this network address.
        """
        return pulumi.get(self, "request_count")


@pulumi.output_type
class GetProjectServiceAccountSecretResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 expires_at: _builtins.str,
                 last_used_at: _builtins.str,
                 masked_secret_value: _builtins.str,
                 secret_id: _builtins.str):
        """
        :param _builtins.str created_at: The date that the secret was created on. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str expires_at: The date for the expiration of the secret. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str last_used_at: The last time the secret was used. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str masked_secret_value: The masked Service Account secret.
        :param _builtins.str secret_id: Unique 24-hexadecimal digit string that identifies the secret.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "last_used_at", last_used_at)
        pulumi.set(__self__, "masked_secret_value", masked_secret_value)
        pulumi.set(__self__, "secret_id", secret_id)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The date that the secret was created on. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> _builtins.str:
        """
        The date for the expiration of the secret. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter(name="lastUsedAt")
    def last_used_at(self) -> _builtins.str:
        """
        The last time the secret was used. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "last_used_at")

    @_builtins.property
    @pulumi.getter(name="maskedSecretValue")
    def masked_secret_value(self) -> _builtins.str:
        """
        The masked Service Account secret.
        """
        return pulumi.get(self, "masked_secret_value")

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the secret.
        """
        return pulumi.get(self, "secret_id")


@pulumi.output_type
class GetProjectServiceAccountsResultResult(dict):
    def __init__(__self__, *,
                 client_id: _builtins.str,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 name: _builtins.str,
                 roles: Sequence[_builtins.str],
                 secrets: Sequence['outputs.GetProjectServiceAccountsResultSecretResult']):
        """
        :param _builtins.str client_id: The Client ID of the Service Account.
        :param _builtins.str created_at: The date that the Service Account was created on. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str description: Human readable description for the Service Account.
        :param _builtins.str name: Human-readable name for the Service Account.
        :param Sequence[_builtins.str] roles: A list of Project roles associated with the Service Account.
        :param Sequence['GetProjectServiceAccountsResultSecretArgs'] secrets: A list of secrets associated with the specified Service Account.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The Client ID of the Service Account.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The date that the Service Account was created on. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Human readable description for the Service Account.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Human-readable name for the Service Account.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Sequence[_builtins.str]:
        """
        A list of Project roles associated with the Service Account.
        """
        return pulumi.get(self, "roles")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Sequence['outputs.GetProjectServiceAccountsResultSecretResult']:
        """
        A list of secrets associated with the specified Service Account.
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class GetProjectServiceAccountsResultSecretResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 expires_at: _builtins.str,
                 last_used_at: _builtins.str,
                 masked_secret_value: _builtins.str,
                 secret_id: _builtins.str):
        """
        :param _builtins.str created_at: The date that the secret was created on. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str expires_at: The date for the expiration of the secret. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str last_used_at: The last time the secret was used. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str masked_secret_value: The masked Service Account secret.
        :param _builtins.str secret_id: Unique 24-hexadecimal digit string that identifies the secret.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "last_used_at", last_used_at)
        pulumi.set(__self__, "masked_secret_value", masked_secret_value)
        pulumi.set(__self__, "secret_id", secret_id)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The date that the secret was created on. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> _builtins.str:
        """
        The date for the expiration of the secret. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter(name="lastUsedAt")
    def last_used_at(self) -> _builtins.str:
        """
        The last time the secret was used. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "last_used_at")

    @_builtins.property
    @pulumi.getter(name="maskedSecretValue")
    def masked_secret_value(self) -> _builtins.str:
        """
        The masked Service Account secret.
        """
        return pulumi.get(self, "masked_secret_value")

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the secret.
        """
        return pulumi.get(self, "secret_id")


@pulumi.output_type
class GetProjectTeamResult(dict):
    def __init__(__self__, *,
                 role_names: Sequence[_builtins.str],
                 team_id: _builtins.str):
        """
        :param Sequence[_builtins.str] role_names: Each string in the array represents a project role assigned to the team. Every user associated with the team inherits these roles. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles a user can have.
        :param _builtins.str team_id: The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
        """
        pulumi.set(__self__, "role_names", role_names)
        pulumi.set(__self__, "team_id", team_id)

    @_builtins.property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[_builtins.str]:
        """
        Each string in the array represents a project role assigned to the team. Every user associated with the team inherits these roles. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles a user can have.
        """
        return pulumi.get(self, "role_names")

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> _builtins.str:
        """
        The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
        """
        return pulumi.get(self, "team_id")


@pulumi.output_type
class GetProjectUserResult(dict):
    def __init__(__self__, *,
                 country: _builtins.str,
                 created_at: _builtins.str,
                 first_name: _builtins.str,
                 id: _builtins.str,
                 invitation_created_at: _builtins.str,
                 invitation_expires_at: _builtins.str,
                 inviter_username: _builtins.str,
                 last_auth: _builtins.str,
                 last_name: _builtins.str,
                 mobile_number: _builtins.str,
                 org_membership_status: _builtins.str,
                 roles: Sequence[_builtins.str],
                 username: _builtins.str):
        """
        :param _builtins.str country: Two-character alphabetical string that identifies the MongoDB Cloud user's geographic location. This parameter uses the ISO 3166-1a2 code format.
               * `createdAt`- Date and time when MongoDB Cloud created the current account. This value is in the ISO 8601 timestamp format in UTC.
               * `firstName`- First or given name that belongs to the MongoDB Cloud user.
               * `lastAuth` - Date and time when the current account last authenticated. This value is in the ISO 8601 timestamp format in UTC.
               * `lastName`- Last name, family name, or surname that belongs to the MongoDB Cloud user.
               * `mobileNumber` - Mobile phone number that belongs to the MongoDB Cloud user.
        :param _builtins.str id: Unique 24-hexadecimal digit string that identifies the MongoDB Cloud user.
               * `orgMembershipStatus`- String enum that indicates whether the MongoDB Cloud user has a pending invitation to join the organization or they are already active in the organization.
        :param Sequence[_builtins.str] roles: One or more project-level roles assigned to the MongoDB Cloud user.
        :param _builtins.str username: Email address that represents the username of the MongoDB Cloud user.
        """
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "invitation_created_at", invitation_created_at)
        pulumi.set(__self__, "invitation_expires_at", invitation_expires_at)
        pulumi.set(__self__, "inviter_username", inviter_username)
        pulumi.set(__self__, "last_auth", last_auth)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "mobile_number", mobile_number)
        pulumi.set(__self__, "org_membership_status", org_membership_status)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def country(self) -> _builtins.str:
        """
        Two-character alphabetical string that identifies the MongoDB Cloud user's geographic location. This parameter uses the ISO 3166-1a2 code format.
        * `createdAt`- Date and time when MongoDB Cloud created the current account. This value is in the ISO 8601 timestamp format in UTC.
        * `firstName`- First or given name that belongs to the MongoDB Cloud user.
        * `lastAuth` - Date and time when the current account last authenticated. This value is in the ISO 8601 timestamp format in UTC.
        * `lastName`- Last name, family name, or surname that belongs to the MongoDB Cloud user.
        * `mobileNumber` - Mobile phone number that belongs to the MongoDB Cloud user.
        """
        return pulumi.get(self, "country")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> _builtins.str:
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the MongoDB Cloud user.
        * `orgMembershipStatus`- String enum that indicates whether the MongoDB Cloud user has a pending invitation to join the organization or they are already active in the organization.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="invitationCreatedAt")
    def invitation_created_at(self) -> _builtins.str:
        return pulumi.get(self, "invitation_created_at")

    @_builtins.property
    @pulumi.getter(name="invitationExpiresAt")
    def invitation_expires_at(self) -> _builtins.str:
        return pulumi.get(self, "invitation_expires_at")

    @_builtins.property
    @pulumi.getter(name="inviterUsername")
    def inviter_username(self) -> _builtins.str:
        return pulumi.get(self, "inviter_username")

    @_builtins.property
    @pulumi.getter(name="lastAuth")
    def last_auth(self) -> _builtins.str:
        return pulumi.get(self, "last_auth")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> _builtins.str:
        return pulumi.get(self, "last_name")

    @_builtins.property
    @pulumi.getter(name="mobileNumber")
    def mobile_number(self) -> _builtins.str:
        return pulumi.get(self, "mobile_number")

    @_builtins.property
    @pulumi.getter(name="orgMembershipStatus")
    def org_membership_status(self) -> _builtins.str:
        return pulumi.get(self, "org_membership_status")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Sequence[_builtins.str]:
        """
        One or more project-level roles assigned to the MongoDB Cloud user.
        """
        return pulumi.get(self, "roles")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Email address that represents the username of the MongoDB Cloud user.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetProjectsResultResult(dict):
    def __init__(__self__, *,
                 cluster_count: _builtins.int,
                 created: _builtins.str,
                 id: _builtins.str,
                 ip_addresses: 'outputs.GetProjectsResultIpAddressesResult',
                 is_collect_database_specifics_statistics_enabled: _builtins.bool,
                 is_data_explorer_enabled: _builtins.bool,
                 is_extended_storage_sizes_enabled: _builtins.bool,
                 is_performance_advisor_enabled: _builtins.bool,
                 is_realtime_performance_panel_enabled: _builtins.bool,
                 is_schema_advisor_enabled: _builtins.bool,
                 is_slow_operation_thresholding_enabled: _builtins.bool,
                 limits: Sequence['outputs.GetProjectsResultLimitResult'],
                 org_id: _builtins.str,
                 region_usage_restrictions: _builtins.str,
                 tags: Mapping[str, _builtins.str],
                 teams: Sequence['outputs.GetProjectsResultTeamResult'],
                 users: Sequence['outputs.GetProjectsResultUserResult'],
                 name: Optional[_builtins.str] = None,
                 project_id: Optional[_builtins.str] = None):
        """
        :param _builtins.int cluster_count: The number of Atlas clusters deployed in the project.
        :param _builtins.str created: The ISO-8601-formatted timestamp of when Atlas created the project.
        :param _builtins.str id: Autogenerated Unique ID for this data source.
        :param 'GetProjectsResultIpAddressesArgs' ip_addresses: IP addresses in a project categorized by services. See IP Addresses. **WARNING:** This attribute is deprecated, use the `get_project_ip_addresses` data source instead.
        :param _builtins.bool is_collect_database_specifics_statistics_enabled: Flag that indicates whether to enable statistics in [cluster metrics](https://www.mongodb.com/docs/atlas/monitor-cluster-metrics/) collection for the project.
        :param _builtins.bool is_data_explorer_enabled: Flag that indicates whether to enable Data Explorer for the project. If enabled, you can query your database with an easy to use interface.
        :param _builtins.bool is_extended_storage_sizes_enabled: Flag that indicates whether to enable extended storage sizes for the specified project.
        :param _builtins.bool is_performance_advisor_enabled: Flag that indicates whether to enable Performance Advisor and Profiler for the project. If enabled, you can analyze database logs to recommend performance improvements.
        :param _builtins.bool is_realtime_performance_panel_enabled: Flag that indicates whether to enable Real Time Performance Panel for the project. If enabled, you can see real time metrics from your MongoDB database.
        :param _builtins.bool is_schema_advisor_enabled: Flag that indicates whether to enable Schema Advisor for the project. If enabled, you receive customized recommendations to optimize your data model and enhance performance. Disable this setting to disable schema suggestions in the [Performance Advisor](https://www.mongodb.com/docs/atlas/performance-advisor/#std-label-performance-advisor) and the [Data Explorer](https://www.mongodb.com/docs/atlas/atlas-ui/#std-label-atlas-ui).
        :param _builtins.bool is_slow_operation_thresholding_enabled: Flag that enables MongoDB Cloud to use its slow operation threshold for the specified project. The threshold determines which operations the Performance Advisor and Query Profiler considers slow. When enabled, MongoDB Cloud uses the average execution time for operations on your cluster to determine slow-running queries. As a result, the threshold is more pertinent to your cluster workload. The slow operation threshold is enabled by default for dedicated clusters (M10+). When disabled, MongoDB Cloud considers any operation that takes longer than 100 milliseconds to be slow. **Note**: To use this attribute, the requesting API Key must have the Project Owner role, if not it will show a warning and will return `false`. If you are not using this field, you don't need to take any action.
        :param Sequence['GetProjectsResultLimitArgs'] limits: The limits for the specified project. See Limits.
        :param _builtins.str org_id: The ID of the organization you want to create the project within.
        :param _builtins.str region_usage_restrictions: If GOV_REGIONS_ONLY the project can be used for government regions only, otherwise defaults to standard regions. For more information see [MongoDB Atlas for Government](https://www.mongodb.com/docs/atlas/government/api/#creating-a-project).
        :param Mapping[str, _builtins.str] tags: Map that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the project. To learn more, see [Resource Tags](https://www.mongodb.com/docs/atlas/tags/)
        :param Sequence['GetProjectsResultTeamArgs'] teams: **(DEPRECATED)** Returns all teams to which the authenticated user has access in the project. See Teams.
        :param Sequence['GetProjectsResultUserArgs'] users: Returns list of all pending and active MongoDB Cloud users associated with the specified project.
        :param _builtins.str project_id: Unique 24-hexadecimal digit string that identifies the MongoDB Cloud project.
        """
        pulumi.set(__self__, "cluster_count", cluster_count)
        pulumi.set(__self__, "created", created)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip_addresses", ip_addresses)
        pulumi.set(__self__, "is_collect_database_specifics_statistics_enabled", is_collect_database_specifics_statistics_enabled)
        pulumi.set(__self__, "is_data_explorer_enabled", is_data_explorer_enabled)
        pulumi.set(__self__, "is_extended_storage_sizes_enabled", is_extended_storage_sizes_enabled)
        pulumi.set(__self__, "is_performance_advisor_enabled", is_performance_advisor_enabled)
        pulumi.set(__self__, "is_realtime_performance_panel_enabled", is_realtime_performance_panel_enabled)
        pulumi.set(__self__, "is_schema_advisor_enabled", is_schema_advisor_enabled)
        pulumi.set(__self__, "is_slow_operation_thresholding_enabled", is_slow_operation_thresholding_enabled)
        pulumi.set(__self__, "limits", limits)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "region_usage_restrictions", region_usage_restrictions)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "teams", teams)
        pulumi.set(__self__, "users", users)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter(name="clusterCount")
    def cluster_count(self) -> _builtins.int:
        """
        The number of Atlas clusters deployed in the project.
        """
        return pulumi.get(self, "cluster_count")

    @_builtins.property
    @pulumi.getter
    def created(self) -> _builtins.str:
        """
        The ISO-8601-formatted timestamp of when Atlas created the project.
        """
        return pulumi.get(self, "created")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Autogenerated Unique ID for this data source.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    @_utilities.deprecated("""This parameter is deprecated. Please transition to get_project_ip_addresses data source.""")
    def ip_addresses(self) -> 'outputs.GetProjectsResultIpAddressesResult':
        """
        IP addresses in a project categorized by services. See IP Addresses. **WARNING:** This attribute is deprecated, use the `get_project_ip_addresses` data source instead.
        """
        return pulumi.get(self, "ip_addresses")

    @_builtins.property
    @pulumi.getter(name="isCollectDatabaseSpecificsStatisticsEnabled")
    def is_collect_database_specifics_statistics_enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether to enable statistics in [cluster metrics](https://www.mongodb.com/docs/atlas/monitor-cluster-metrics/) collection for the project.
        """
        return pulumi.get(self, "is_collect_database_specifics_statistics_enabled")

    @_builtins.property
    @pulumi.getter(name="isDataExplorerEnabled")
    def is_data_explorer_enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether to enable Data Explorer for the project. If enabled, you can query your database with an easy to use interface.
        """
        return pulumi.get(self, "is_data_explorer_enabled")

    @_builtins.property
    @pulumi.getter(name="isExtendedStorageSizesEnabled")
    def is_extended_storage_sizes_enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether to enable extended storage sizes for the specified project.
        """
        return pulumi.get(self, "is_extended_storage_sizes_enabled")

    @_builtins.property
    @pulumi.getter(name="isPerformanceAdvisorEnabled")
    def is_performance_advisor_enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether to enable Performance Advisor and Profiler for the project. If enabled, you can analyze database logs to recommend performance improvements.
        """
        return pulumi.get(self, "is_performance_advisor_enabled")

    @_builtins.property
    @pulumi.getter(name="isRealtimePerformancePanelEnabled")
    def is_realtime_performance_panel_enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether to enable Real Time Performance Panel for the project. If enabled, you can see real time metrics from your MongoDB database.
        """
        return pulumi.get(self, "is_realtime_performance_panel_enabled")

    @_builtins.property
    @pulumi.getter(name="isSchemaAdvisorEnabled")
    def is_schema_advisor_enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether to enable Schema Advisor for the project. If enabled, you receive customized recommendations to optimize your data model and enhance performance. Disable this setting to disable schema suggestions in the [Performance Advisor](https://www.mongodb.com/docs/atlas/performance-advisor/#std-label-performance-advisor) and the [Data Explorer](https://www.mongodb.com/docs/atlas/atlas-ui/#std-label-atlas-ui).
        """
        return pulumi.get(self, "is_schema_advisor_enabled")

    @_builtins.property
    @pulumi.getter(name="isSlowOperationThresholdingEnabled")
    @_utilities.deprecated("""This parameter is deprecated.""")
    def is_slow_operation_thresholding_enabled(self) -> _builtins.bool:
        """
        Flag that enables MongoDB Cloud to use its slow operation threshold for the specified project. The threshold determines which operations the Performance Advisor and Query Profiler considers slow. When enabled, MongoDB Cloud uses the average execution time for operations on your cluster to determine slow-running queries. As a result, the threshold is more pertinent to your cluster workload. The slow operation threshold is enabled by default for dedicated clusters (M10+). When disabled, MongoDB Cloud considers any operation that takes longer than 100 milliseconds to be slow. **Note**: To use this attribute, the requesting API Key must have the Project Owner role, if not it will show a warning and will return `false`. If you are not using this field, you don't need to take any action.
        """
        return pulumi.get(self, "is_slow_operation_thresholding_enabled")

    @_builtins.property
    @pulumi.getter
    def limits(self) -> Sequence['outputs.GetProjectsResultLimitResult']:
        """
        The limits for the specified project. See Limits.
        """
        return pulumi.get(self, "limits")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        """
        The ID of the organization you want to create the project within.
        """
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter(name="regionUsageRestrictions")
    def region_usage_restrictions(self) -> _builtins.str:
        """
        If GOV_REGIONS_ONLY the project can be used for government regions only, otherwise defaults to standard regions. For more information see [MongoDB Atlas for Government](https://www.mongodb.com/docs/atlas/government/api/#creating-a-project).
        """
        return pulumi.get(self, "region_usage_restrictions")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        Map that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the project. To learn more, see [Resource Tags](https://www.mongodb.com/docs/atlas/tags/)
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""This parameter is deprecated and will be removed in the next major release. Please transition to `TeamProjectAssignment`. For more details, see https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/atlas-user-management.""")
    def teams(self) -> Sequence['outputs.GetProjectsResultTeamResult']:
        """
        **(DEPRECATED)** Returns all teams to which the authenticated user has access in the project. See Teams.
        """
        return pulumi.get(self, "teams")

    @_builtins.property
    @pulumi.getter
    def users(self) -> Sequence['outputs.GetProjectsResultUserResult']:
        """
        Returns list of all pending and active MongoDB Cloud users associated with the specified project.
        """
        return pulumi.get(self, "users")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        Unique 24-hexadecimal digit string that identifies the MongoDB Cloud project.
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class GetProjectsResultIpAddressesResult(dict):
    def __init__(__self__, *,
                 services: 'outputs.GetProjectsResultIpAddressesServicesResult'):
        pulumi.set(__self__, "services", services)

    @_builtins.property
    @pulumi.getter
    def services(self) -> 'outputs.GetProjectsResultIpAddressesServicesResult':
        return pulumi.get(self, "services")


@pulumi.output_type
class GetProjectsResultIpAddressesServicesResult(dict):
    def __init__(__self__, *,
                 clusters: Sequence['outputs.GetProjectsResultIpAddressesServicesClusterResult']):
        pulumi.set(__self__, "clusters", clusters)

    @_builtins.property
    @pulumi.getter
    def clusters(self) -> Sequence['outputs.GetProjectsResultIpAddressesServicesClusterResult']:
        return pulumi.get(self, "clusters")


@pulumi.output_type
class GetProjectsResultIpAddressesServicesClusterResult(dict):
    def __init__(__self__, *,
                 cluster_name: _builtins.str,
                 inbounds: Sequence[_builtins.str],
                 outbounds: Sequence[_builtins.str]):
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "inbounds", inbounds)
        pulumi.set(__self__, "outbounds", outbounds)

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> _builtins.str:
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter
    def inbounds(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "inbounds")

    @_builtins.property
    @pulumi.getter
    def outbounds(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "outbounds")


@pulumi.output_type
class GetProjectsResultLimitResult(dict):
    def __init__(__self__, *,
                 current_usage: _builtins.int,
                 default_limit: _builtins.int,
                 maximum_limit: _builtins.int,
                 name: _builtins.str,
                 value: _builtins.int):
        """
        :param _builtins.int current_usage: Amount that indicates the current usage of the limit.
        :param _builtins.int default_limit: Default value of the limit.
        :param _builtins.int maximum_limit: Maximum value of the limit.
        :param _builtins.str name: Human-readable label that identifies this project limit.
        :param _builtins.int value: Amount the limit is set to.
        """
        pulumi.set(__self__, "current_usage", current_usage)
        pulumi.set(__self__, "default_limit", default_limit)
        pulumi.set(__self__, "maximum_limit", maximum_limit)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="currentUsage")
    def current_usage(self) -> _builtins.int:
        """
        Amount that indicates the current usage of the limit.
        """
        return pulumi.get(self, "current_usage")

    @_builtins.property
    @pulumi.getter(name="defaultLimit")
    def default_limit(self) -> _builtins.int:
        """
        Default value of the limit.
        """
        return pulumi.get(self, "default_limit")

    @_builtins.property
    @pulumi.getter(name="maximumLimit")
    def maximum_limit(self) -> _builtins.int:
        """
        Maximum value of the limit.
        """
        return pulumi.get(self, "maximum_limit")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Human-readable label that identifies this project limit.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        """
        Amount the limit is set to.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetProjectsResultTeamResult(dict):
    def __init__(__self__, *,
                 role_names: Sequence[_builtins.str],
                 team_id: _builtins.str):
        """
        :param Sequence[_builtins.str] role_names: Each string in the array represents a project role assigned to the team. Every user associated with the team inherits these roles. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles a user can have.
        :param _builtins.str team_id: The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
        """
        pulumi.set(__self__, "role_names", role_names)
        pulumi.set(__self__, "team_id", team_id)

    @_builtins.property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[_builtins.str]:
        """
        Each string in the array represents a project role assigned to the team. Every user associated with the team inherits these roles. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles a user can have.
        """
        return pulumi.get(self, "role_names")

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> _builtins.str:
        """
        The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
        """
        return pulumi.get(self, "team_id")


@pulumi.output_type
class GetProjectsResultUserResult(dict):
    def __init__(__self__, *,
                 country: _builtins.str,
                 created_at: _builtins.str,
                 first_name: _builtins.str,
                 id: _builtins.str,
                 invitation_created_at: _builtins.str,
                 invitation_expires_at: _builtins.str,
                 inviter_username: _builtins.str,
                 last_auth: _builtins.str,
                 last_name: _builtins.str,
                 mobile_number: _builtins.str,
                 org_membership_status: _builtins.str,
                 roles: Sequence[_builtins.str],
                 username: _builtins.str):
        """
        :param _builtins.str country: Two-character alphabetical string that identifies the MongoDB Cloud user's geographic location. This parameter uses the ISO 3166-1a2 code format.
               * `createdAt`- Date and time when MongoDB Cloud created the current account. This value is in the ISO 8601 timestamp format in UTC.
               * `firstName`- First or given name that belongs to the MongoDB Cloud user.
               * `lastAuth` - Date and time when the current account last authenticated. This value is in the ISO 8601 timestamp format in UTC.
               * `lastName`- Last name, family name, or surname that belongs to the MongoDB Cloud user.
               * `mobileNumber` - Mobile phone number that belongs to the MongoDB Cloud user.
               
               > **NOTE:** - Does not return pending users invited via the deprecated [Invite One MongoDB Cloud User to Join One Project](https://www.mongodb.com/docs/api/doc/atlas-admin-api-v2/operation/operation-createprojectinvitation) endpoint or pending invitations created using `ProjectInvitation` resource.
               
               See [MongoDB Atlas API - Projects](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Projects) Documentation for more information.
        :param _builtins.str id: Unique 24-hexadecimal digit string that identifies the MongoDB Cloud user.
               * `orgMembershipStatus`- String enum that indicates whether the MongoDB Cloud user has a pending invitation to join the organization or they are already active in the organization.
        :param Sequence[_builtins.str] roles: One or more project-level roles assigned to the MongoDB Cloud user.
        :param _builtins.str username: Email address that represents the username of the MongoDB Cloud user.
        """
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "invitation_created_at", invitation_created_at)
        pulumi.set(__self__, "invitation_expires_at", invitation_expires_at)
        pulumi.set(__self__, "inviter_username", inviter_username)
        pulumi.set(__self__, "last_auth", last_auth)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "mobile_number", mobile_number)
        pulumi.set(__self__, "org_membership_status", org_membership_status)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def country(self) -> _builtins.str:
        """
        Two-character alphabetical string that identifies the MongoDB Cloud user's geographic location. This parameter uses the ISO 3166-1a2 code format.
        * `createdAt`- Date and time when MongoDB Cloud created the current account. This value is in the ISO 8601 timestamp format in UTC.
        * `firstName`- First or given name that belongs to the MongoDB Cloud user.
        * `lastAuth` - Date and time when the current account last authenticated. This value is in the ISO 8601 timestamp format in UTC.
        * `lastName`- Last name, family name, or surname that belongs to the MongoDB Cloud user.
        * `mobileNumber` - Mobile phone number that belongs to the MongoDB Cloud user.

        > **NOTE:** - Does not return pending users invited via the deprecated [Invite One MongoDB Cloud User to Join One Project](https://www.mongodb.com/docs/api/doc/atlas-admin-api-v2/operation/operation-createprojectinvitation) endpoint or pending invitations created using `ProjectInvitation` resource.

        See [MongoDB Atlas API - Projects](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Projects) Documentation for more information.
        """
        return pulumi.get(self, "country")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> _builtins.str:
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the MongoDB Cloud user.
        * `orgMembershipStatus`- String enum that indicates whether the MongoDB Cloud user has a pending invitation to join the organization or they are already active in the organization.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="invitationCreatedAt")
    def invitation_created_at(self) -> _builtins.str:
        return pulumi.get(self, "invitation_created_at")

    @_builtins.property
    @pulumi.getter(name="invitationExpiresAt")
    def invitation_expires_at(self) -> _builtins.str:
        return pulumi.get(self, "invitation_expires_at")

    @_builtins.property
    @pulumi.getter(name="inviterUsername")
    def inviter_username(self) -> _builtins.str:
        return pulumi.get(self, "inviter_username")

    @_builtins.property
    @pulumi.getter(name="lastAuth")
    def last_auth(self) -> _builtins.str:
        return pulumi.get(self, "last_auth")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> _builtins.str:
        return pulumi.get(self, "last_name")

    @_builtins.property
    @pulumi.getter(name="mobileNumber")
    def mobile_number(self) -> _builtins.str:
        return pulumi.get(self, "mobile_number")

    @_builtins.property
    @pulumi.getter(name="orgMembershipStatus")
    def org_membership_status(self) -> _builtins.str:
        return pulumi.get(self, "org_membership_status")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Sequence[_builtins.str]:
        """
        One or more project-level roles assigned to the MongoDB Cloud user.
        """
        return pulumi.get(self, "roles")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Email address that represents the username of the MongoDB Cloud user.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourcePoliciesResourcePolicyResult(dict):
    def __init__(__self__, *,
                 created_by_user: 'outputs.GetResourcePoliciesResourcePolicyCreatedByUserResult',
                 created_date: _builtins.str,
                 description: _builtins.str,
                 id: _builtins.str,
                 last_updated_by_user: 'outputs.GetResourcePoliciesResourcePolicyLastUpdatedByUserResult',
                 last_updated_date: _builtins.str,
                 name: _builtins.str,
                 org_id: _builtins.str,
                 policies: Sequence['outputs.GetResourcePoliciesResourcePolicyPolicyResult'],
                 version: _builtins.str):
        """
        :param 'GetResourcePoliciesResourcePolicyCreatedByUserArgs' created_by_user: The user that last updated the Atlas resource policy.
        :param _builtins.str created_date: Date and time in UTC when the Atlas resource policy was created.
        :param _builtins.str description: Description of the Atlas resource policy.
        :param _builtins.str id: Unique 24-hexadecimal digit string that identifies an Atlas resource policy.
        :param 'GetResourcePoliciesResourcePolicyLastUpdatedByUserArgs' last_updated_by_user: The user that last updated the Atlas resource policy.
        :param _builtins.str last_updated_date: Date and time in UTC when the Atlas resource policy was last updated.
        :param _builtins.str name: Human-readable label that describes the Atlas resource policy.
        :param _builtins.str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects. Use the /orgs endpoint to retrieve all organizations to which the authenticated user has access.
        :param Sequence['GetResourcePoliciesResourcePolicyPolicyArgs'] policies: List of policies that make up the Atlas resource policy.
        :param _builtins.str version: A string that identifies the version of the Atlas resource policy.
        """
        pulumi.set(__self__, "created_by_user", created_by_user)
        pulumi.set(__self__, "created_date", created_date)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_updated_by_user", last_updated_by_user)
        pulumi.set(__self__, "last_updated_date", last_updated_date)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "policies", policies)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="createdByUser")
    def created_by_user(self) -> 'outputs.GetResourcePoliciesResourcePolicyCreatedByUserResult':
        """
        The user that last updated the Atlas resource policy.
        """
        return pulumi.get(self, "created_by_user")

    @_builtins.property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> _builtins.str:
        """
        Date and time in UTC when the Atlas resource policy was created.
        """
        return pulumi.get(self, "created_date")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the Atlas resource policy.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies an Atlas resource policy.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lastUpdatedByUser")
    def last_updated_by_user(self) -> 'outputs.GetResourcePoliciesResourcePolicyLastUpdatedByUserResult':
        """
        The user that last updated the Atlas resource policy.
        """
        return pulumi.get(self, "last_updated_by_user")

    @_builtins.property
    @pulumi.getter(name="lastUpdatedDate")
    def last_updated_date(self) -> _builtins.str:
        """
        Date and time in UTC when the Atlas resource policy was last updated.
        """
        return pulumi.get(self, "last_updated_date")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Human-readable label that describes the Atlas resource policy.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects. Use the /orgs endpoint to retrieve all organizations to which the authenticated user has access.
        """
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Sequence['outputs.GetResourcePoliciesResourcePolicyPolicyResult']:
        """
        List of policies that make up the Atlas resource policy.
        """
        return pulumi.get(self, "policies")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        A string that identifies the version of the Atlas resource policy.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetResourcePoliciesResourcePolicyCreatedByUserResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str id: Unique 24-hexadecimal character string that identifies a user.
        :param _builtins.str name: Human-readable label that describes a user.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal character string that identifies a user.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Human-readable label that describes a user.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetResourcePoliciesResourcePolicyLastUpdatedByUserResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str id: Unique 24-hexadecimal character string that identifies a user.
        :param _builtins.str name: Human-readable label that describes a user.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal character string that identifies a user.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Human-readable label that describes a user.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetResourcePoliciesResourcePolicyPolicyResult(dict):
    def __init__(__self__, *,
                 body: _builtins.str,
                 id: _builtins.str):
        """
        :param _builtins.str body: A string that defines the permissions for the policy. The syntax used is the Cedar Policy language.
        :param _builtins.str id: Unique 24-hexadecimal character string that identifies the policy.
        """
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def body(self) -> _builtins.str:
        """
        A string that defines the permissions for the policy. The syntax used is the Cedar Policy language.
        """
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal character string that identifies the policy.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetResourcePoliciesResultResult(dict):
    def __init__(__self__, *,
                 created_by_user: 'outputs.GetResourcePoliciesResultCreatedByUserResult',
                 created_date: _builtins.str,
                 description: _builtins.str,
                 id: _builtins.str,
                 last_updated_by_user: 'outputs.GetResourcePoliciesResultLastUpdatedByUserResult',
                 last_updated_date: _builtins.str,
                 name: _builtins.str,
                 org_id: _builtins.str,
                 policies: Sequence['outputs.GetResourcePoliciesResultPolicyResult'],
                 version: _builtins.str):
        """
        :param 'GetResourcePoliciesResultCreatedByUserArgs' created_by_user: The user that last updated the Atlas resource policy.
        :param _builtins.str created_date: Date and time in UTC when the Atlas resource policy was created.
        :param _builtins.str description: Description of the Atlas resource policy.
        :param _builtins.str id: Unique 24-hexadecimal digit string that identifies an Atlas resource policy.
        :param 'GetResourcePoliciesResultLastUpdatedByUserArgs' last_updated_by_user: The user that last updated the Atlas resource policy.
        :param _builtins.str last_updated_date: Date and time in UTC when the Atlas resource policy was last updated.
        :param _builtins.str name: Human-readable label that describes the Atlas resource policy.
        :param _builtins.str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects. Use the /orgs endpoint to retrieve all organizations to which the authenticated user has access.
        :param Sequence['GetResourcePoliciesResultPolicyArgs'] policies: List of policies that make up the Atlas resource policy.
        :param _builtins.str version: A string that identifies the version of the Atlas resource policy.
        """
        pulumi.set(__self__, "created_by_user", created_by_user)
        pulumi.set(__self__, "created_date", created_date)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_updated_by_user", last_updated_by_user)
        pulumi.set(__self__, "last_updated_date", last_updated_date)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "policies", policies)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="createdByUser")
    def created_by_user(self) -> 'outputs.GetResourcePoliciesResultCreatedByUserResult':
        """
        The user that last updated the Atlas resource policy.
        """
        return pulumi.get(self, "created_by_user")

    @_builtins.property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> _builtins.str:
        """
        Date and time in UTC when the Atlas resource policy was created.
        """
        return pulumi.get(self, "created_date")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the Atlas resource policy.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies an Atlas resource policy.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lastUpdatedByUser")
    def last_updated_by_user(self) -> 'outputs.GetResourcePoliciesResultLastUpdatedByUserResult':
        """
        The user that last updated the Atlas resource policy.
        """
        return pulumi.get(self, "last_updated_by_user")

    @_builtins.property
    @pulumi.getter(name="lastUpdatedDate")
    def last_updated_date(self) -> _builtins.str:
        """
        Date and time in UTC when the Atlas resource policy was last updated.
        """
        return pulumi.get(self, "last_updated_date")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Human-readable label that describes the Atlas resource policy.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects. Use the /orgs endpoint to retrieve all organizations to which the authenticated user has access.
        """
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Sequence['outputs.GetResourcePoliciesResultPolicyResult']:
        """
        List of policies that make up the Atlas resource policy.
        """
        return pulumi.get(self, "policies")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        A string that identifies the version of the Atlas resource policy.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetResourcePoliciesResultCreatedByUserResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str id: Unique 24-hexadecimal character string that identifies a user.
        :param _builtins.str name: Human-readable label that describes a user.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal character string that identifies a user.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Human-readable label that describes a user.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetResourcePoliciesResultLastUpdatedByUserResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str id: Unique 24-hexadecimal character string that identifies a user.
        :param _builtins.str name: Human-readable label that describes a user.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal character string that identifies a user.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Human-readable label that describes a user.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetResourcePoliciesResultPolicyResult(dict):
    def __init__(__self__, *,
                 body: _builtins.str,
                 id: _builtins.str):
        """
        :param _builtins.str body: A string that defines the permissions for the policy. The syntax used is the Cedar Policy language.
        :param _builtins.str id: Unique 24-hexadecimal character string that identifies the policy.
        """
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def body(self) -> _builtins.str:
        """
        A string that defines the permissions for the policy. The syntax used is the Cedar Policy language.
        """
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal character string that identifies the policy.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetResourcePolicyCreatedByUserResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str id: Unique 24-hexadecimal character string that identifies a user.
        :param _builtins.str name: Human-readable label that describes a user.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal character string that identifies a user.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Human-readable label that describes a user.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetResourcePolicyLastUpdatedByUserResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str id: Unique 24-hexadecimal character string that identifies a user.
        :param _builtins.str name: Human-readable label that describes a user.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal character string that identifies a user.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Human-readable label that describes a user.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetResourcePolicyPolicyResult(dict):
    def __init__(__self__, *,
                 body: _builtins.str,
                 id: _builtins.str):
        """
        :param _builtins.str body: A string that defines the permissions for the policy. The syntax used is the Cedar Policy language.
        :param _builtins.str id: Unique 24-hexadecimal character string that identifies the policy.
        """
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def body(self) -> _builtins.str:
        """
        A string that defines the permissions for the policy. The syntax used is the Cedar Policy language.
        """
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal character string that identifies the policy.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetSearchDeploymentSpecResult(dict):
    def __init__(__self__, *,
                 instance_size: _builtins.str,
                 node_count: _builtins.int):
        """
        :param _builtins.str instance_size: Hardware specification for the search node instance sizes. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Atlas-Search/operation/createAtlasSearchDeployment) describes the valid values. More details can also be found in the [Search Node Documentation](https://www.mongodb.com/docs/atlas/cluster-config/multi-cloud-distribution/#search-tier).
        :param _builtins.int node_count: Number of search nodes in the cluster.
        """
        pulumi.set(__self__, "instance_size", instance_size)
        pulumi.set(__self__, "node_count", node_count)

    @_builtins.property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> _builtins.str:
        """
        Hardware specification for the search node instance sizes. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Atlas-Search/operation/createAtlasSearchDeployment) describes the valid values. More details can also be found in the [Search Node Documentation](https://www.mongodb.com/docs/atlas/cluster-config/multi-cloud-distribution/#search-tier).
        """
        return pulumi.get(self, "instance_size")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> _builtins.int:
        """
        Number of search nodes in the cluster.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetSearchIndexSynonymResult(dict):
    def __init__(__self__, *,
                 analyzer: _builtins.str,
                 name: _builtins.str,
                 source_collection: _builtins.str):
        """
        :param _builtins.str analyzer: [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.
        :param _builtins.str name: Type set name.
        """
        pulumi.set(__self__, "analyzer", analyzer)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source_collection", source_collection)

    @_builtins.property
    @pulumi.getter
    def analyzer(self) -> _builtins.str:
        """
        [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.
        """
        return pulumi.get(self, "analyzer")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Type set name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="sourceCollection")
    def source_collection(self) -> _builtins.str:
        return pulumi.get(self, "source_collection")


@pulumi.output_type
class GetSearchIndexTypeSetResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 types: _builtins.str):
        """
        :param _builtins.str name: Type set name.
        :param _builtins.str types: JSON array string describing the types for the set.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "types", types)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Type set name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def types(self) -> _builtins.str:
        """
        JSON array string describing the types for the set.
        """
        return pulumi.get(self, "types")


@pulumi.output_type
class GetSearchIndexesResultResult(dict):
    def __init__(__self__, *,
                 analyzer: _builtins.str,
                 analyzers: _builtins.str,
                 cluster_name: _builtins.str,
                 collection_name: _builtins.str,
                 database: _builtins.str,
                 fields: _builtins.str,
                 index_id: _builtins.str,
                 mappings_dynamic: _builtins.bool,
                 mappings_dynamic_config: _builtins.str,
                 mappings_fields: _builtins.str,
                 name: _builtins.str,
                 num_partitions: _builtins.int,
                 project_id: _builtins.str,
                 search_analyzer: _builtins.str,
                 status: _builtins.str,
                 stored_source: _builtins.str,
                 synonyms: Sequence['outputs.GetSearchIndexesResultSynonymResult'],
                 type: _builtins.str,
                 type_sets: Sequence['outputs.GetSearchIndexesResultTypeSetResult']):
        """
        :param _builtins.str analyzer: [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.
        :param _builtins.str analyzers: [Custom analyzers](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-custom-analyzers) to use in this index (this is an array of objects).
        :param _builtins.str cluster_name: Name of the cluster containing the collection with one or more Atlas Search indexes.
        :param _builtins.str collection_name: Name of the collection with one or more Atlas Search indexes.
        :param _builtins.str database: (Required) Name of the database the collection is in.
        :param _builtins.str index_id: The unique identifier of the Atlas Search index.
        :param _builtins.bool mappings_dynamic: Flag indicating whether the index uses dynamic or static mappings. Mutually exclusive with `mappings_dynamic_config`.
        :param _builtins.str mappings_dynamic_config: JSON object for `mappings.dynamic` when Atlas returns an object (Please see the documentation for [dynamic and static mappings](https://www.mongodb.com/docs/atlas/atlas-search/index-definitions/#field-mapping-examples)). Mutually exclusive with `mappings_dynamic`.
        :param _builtins.str mappings_fields: Object containing one or more field specifications.
        :param _builtins.str name: Type set name.
        :param _builtins.int num_partitions: Number of index partitions.
        :param _builtins.str project_id: Unique identifier for the [project](https://docs.atlas.mongodb.com/organizations-projects/#std-label-projects) that contains the specified cluster.
        :param _builtins.str search_analyzer: [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when searching the index.
        :param _builtins.str status: Current status of the index.
        :param _builtins.str stored_source: String that can be "true" (store all fields), "false" (default, don't store any field), or a JSON string that contains the list of fields to store (include) or not store (exclude) on Atlas Search. To learn more, see [Stored Source Fields](https://www.mongodb.com/docs/atlas/atlas-search/stored-source-definition/).
        :param Sequence['GetSearchIndexesResultSynonymArgs'] synonyms: Synonyms mapping definition to use in this index.
               * `synonyms.#.name` - Name of the [synonym mapping definition](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-ref).
               * `synonyms.#.source_collection` - Name of the source MongoDB collection for the synonyms.
               * `synonyms.#.analyzer` - Name of the [analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use with this synonym mapping.
        :param Sequence['GetSearchIndexesResultTypeSetArgs'] type_sets: Set of type set definitions (when present). Each item includes:
        """
        pulumi.set(__self__, "analyzer", analyzer)
        pulumi.set(__self__, "analyzers", analyzers)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "fields", fields)
        pulumi.set(__self__, "index_id", index_id)
        pulumi.set(__self__, "mappings_dynamic", mappings_dynamic)
        pulumi.set(__self__, "mappings_dynamic_config", mappings_dynamic_config)
        pulumi.set(__self__, "mappings_fields", mappings_fields)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "num_partitions", num_partitions)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "search_analyzer", search_analyzer)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "stored_source", stored_source)
        pulumi.set(__self__, "synonyms", synonyms)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "type_sets", type_sets)

    @_builtins.property
    @pulumi.getter
    def analyzer(self) -> _builtins.str:
        """
        [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.
        """
        return pulumi.get(self, "analyzer")

    @_builtins.property
    @pulumi.getter
    def analyzers(self) -> _builtins.str:
        """
        [Custom analyzers](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-custom-analyzers) to use in this index (this is an array of objects).
        """
        return pulumi.get(self, "analyzers")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> _builtins.str:
        """
        Name of the cluster containing the collection with one or more Atlas Search indexes.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> _builtins.str:
        """
        Name of the collection with one or more Atlas Search indexes.
        """
        return pulumi.get(self, "collection_name")

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        (Required) Name of the database the collection is in.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def fields(self) -> _builtins.str:
        return pulumi.get(self, "fields")

    @_builtins.property
    @pulumi.getter(name="indexId")
    def index_id(self) -> _builtins.str:
        """
        The unique identifier of the Atlas Search index.
        """
        return pulumi.get(self, "index_id")

    @_builtins.property
    @pulumi.getter(name="mappingsDynamic")
    def mappings_dynamic(self) -> _builtins.bool:
        """
        Flag indicating whether the index uses dynamic or static mappings. Mutually exclusive with `mappings_dynamic_config`.
        """
        return pulumi.get(self, "mappings_dynamic")

    @_builtins.property
    @pulumi.getter(name="mappingsDynamicConfig")
    def mappings_dynamic_config(self) -> _builtins.str:
        """
        JSON object for `mappings.dynamic` when Atlas returns an object (Please see the documentation for [dynamic and static mappings](https://www.mongodb.com/docs/atlas/atlas-search/index-definitions/#field-mapping-examples)). Mutually exclusive with `mappings_dynamic`.
        """
        return pulumi.get(self, "mappings_dynamic_config")

    @_builtins.property
    @pulumi.getter(name="mappingsFields")
    def mappings_fields(self) -> _builtins.str:
        """
        Object containing one or more field specifications.
        """
        return pulumi.get(self, "mappings_fields")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Type set name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="numPartitions")
    def num_partitions(self) -> _builtins.int:
        """
        Number of index partitions.
        """
        return pulumi.get(self, "num_partitions")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Unique identifier for the [project](https://docs.atlas.mongodb.com/organizations-projects/#std-label-projects) that contains the specified cluster.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="searchAnalyzer")
    def search_analyzer(self) -> _builtins.str:
        """
        [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when searching the index.
        """
        return pulumi.get(self, "search_analyzer")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Current status of the index.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="storedSource")
    def stored_source(self) -> _builtins.str:
        """
        String that can be "true" (store all fields), "false" (default, don't store any field), or a JSON string that contains the list of fields to store (include) or not store (exclude) on Atlas Search. To learn more, see [Stored Source Fields](https://www.mongodb.com/docs/atlas/atlas-search/stored-source-definition/).
        """
        return pulumi.get(self, "stored_source")

    @_builtins.property
    @pulumi.getter
    def synonyms(self) -> Sequence['outputs.GetSearchIndexesResultSynonymResult']:
        """
        Synonyms mapping definition to use in this index.
        * `synonyms.#.name` - Name of the [synonym mapping definition](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-ref).
        * `synonyms.#.source_collection` - Name of the source MongoDB collection for the synonyms.
        * `synonyms.#.analyzer` - Name of the [analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use with this synonym mapping.
        """
        return pulumi.get(self, "synonyms")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="typeSets")
    def type_sets(self) -> Sequence['outputs.GetSearchIndexesResultTypeSetResult']:
        """
        Set of type set definitions (when present). Each item includes:
        """
        return pulumi.get(self, "type_sets")


@pulumi.output_type
class GetSearchIndexesResultSynonymResult(dict):
    def __init__(__self__, *,
                 analyzer: _builtins.str,
                 name: _builtins.str,
                 source_collection: _builtins.str):
        """
        :param _builtins.str analyzer: [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.
        :param _builtins.str name: Type set name.
        """
        pulumi.set(__self__, "analyzer", analyzer)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source_collection", source_collection)

    @_builtins.property
    @pulumi.getter
    def analyzer(self) -> _builtins.str:
        """
        [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.
        """
        return pulumi.get(self, "analyzer")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Type set name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="sourceCollection")
    def source_collection(self) -> _builtins.str:
        return pulumi.get(self, "source_collection")


@pulumi.output_type
class GetSearchIndexesResultTypeSetResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 types: _builtins.str):
        """
        :param _builtins.str name: Type set name.
        :param _builtins.str types: JSON array string describing the types for the set.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "types", types)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Type set name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def types(self) -> _builtins.str:
        """
        JSON array string describing the types for the set.
        """
        return pulumi.get(self, "types")


@pulumi.output_type
class GetServerlessInstanceLinkResult(dict):
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        return pulumi.get(self, "href")

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetServerlessInstanceTagResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Constant that defines the set of the tag.
        :param _builtins.str value: Variable that belongs to the set of the tag.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Constant that defines the set of the tag.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Variable that belongs to the set of the tag.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetServerlessInstancesResultResult(dict):
    def __init__(__self__, *,
                 auto_indexing: _builtins.bool,
                 connection_strings_private_endpoint_srvs: Sequence[_builtins.str],
                 connection_strings_standard_srv: _builtins.str,
                 continuous_backup_enabled: _builtins.bool,
                 create_date: _builtins.str,
                 id: _builtins.str,
                 links: Sequence['outputs.GetServerlessInstancesResultLinkResult'],
                 mongo_db_version: _builtins.str,
                 name: _builtins.str,
                 project_id: _builtins.str,
                 provider_settings_backing_provider_name: _builtins.str,
                 provider_settings_provider_name: _builtins.str,
                 provider_settings_region_name: _builtins.str,
                 state_name: _builtins.str,
                 tags: Sequence['outputs.GetServerlessInstancesResultTagResult'],
                 termination_protection_enabled: _builtins.bool):
        """
        :param _builtins.bool auto_indexing: (Deprecated) Flag that indicates whether the serverless instance uses [Serverless Auto Indexing](https://www.mongodb.com/docs/atlas/performance-advisor/auto-index-serverless/).
        :param _builtins.str connection_strings_standard_srv: Public `mongodb+srv://` connection string that you can use to connect to this serverless instance.
        :param _builtins.bool continuous_backup_enabled: (Deprecated) Flag that indicates whether the serverless instance uses Serverless Continuous Backup.
        :param _builtins.str id: Unique 24-hexadecimal digit string that identifies the serverless instance.
        :param _builtins.str mongo_db_version: Version of MongoDB that the serverless instance runs, in `<major version>`.`<minor version>` format.
        :param _builtins.str name: (Required) Human-readable label that identifies your serverless instance.
        :param _builtins.str project_id: Unique identifier for the [project](https://docs.atlas.mongodb.com/organizations-projects/#std-label-projects) that contains the specified cluster.
        :param _builtins.str provider_settings_backing_provider_name: Cloud service provider on which MongoDB Cloud provisioned the serverless instance.
        :param _builtins.str provider_settings_provider_name: Cloud service provider that applies to the provisioned the serverless instance.
        :param _builtins.str provider_settings_region_name: Human-readable label that identifies the physical location of your MongoDB serverless instance. The region you choose can affect network latency for clients accessing your databases.
        :param _builtins.str state_name: Stage of deployment of this serverless instance when the resource made its request.
        :param Sequence['GetServerlessInstancesResultTagArgs'] tags: Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.
        :param _builtins.bool termination_protection_enabled: Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.
        """
        pulumi.set(__self__, "auto_indexing", auto_indexing)
        pulumi.set(__self__, "connection_strings_private_endpoint_srvs", connection_strings_private_endpoint_srvs)
        pulumi.set(__self__, "connection_strings_standard_srv", connection_strings_standard_srv)
        pulumi.set(__self__, "continuous_backup_enabled", continuous_backup_enabled)
        pulumi.set(__self__, "create_date", create_date)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "links", links)
        pulumi.set(__self__, "mongo_db_version", mongo_db_version)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "provider_settings_backing_provider_name", provider_settings_backing_provider_name)
        pulumi.set(__self__, "provider_settings_provider_name", provider_settings_provider_name)
        pulumi.set(__self__, "provider_settings_region_name", provider_settings_region_name)
        pulumi.set(__self__, "state_name", state_name)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "termination_protection_enabled", termination_protection_enabled)

    @_builtins.property
    @pulumi.getter(name="autoIndexing")
    @_utilities.deprecated("""This parameter is deprecated and will be removed in March 2025. For more details see https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/serverless-shared-migration-guide.""")
    def auto_indexing(self) -> _builtins.bool:
        """
        (Deprecated) Flag that indicates whether the serverless instance uses [Serverless Auto Indexing](https://www.mongodb.com/docs/atlas/performance-advisor/auto-index-serverless/).
        """
        return pulumi.get(self, "auto_indexing")

    @_builtins.property
    @pulumi.getter(name="connectionStringsPrivateEndpointSrvs")
    def connection_strings_private_endpoint_srvs(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "connection_strings_private_endpoint_srvs")

    @_builtins.property
    @pulumi.getter(name="connectionStringsStandardSrv")
    def connection_strings_standard_srv(self) -> _builtins.str:
        """
        Public `mongodb+srv://` connection string that you can use to connect to this serverless instance.
        """
        return pulumi.get(self, "connection_strings_standard_srv")

    @_builtins.property
    @pulumi.getter(name="continuousBackupEnabled")
    @_utilities.deprecated("""This parameter is deprecated and will be removed in March 2025. For more details see https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/serverless-shared-migration-guide.""")
    def continuous_backup_enabled(self) -> _builtins.bool:
        """
        (Deprecated) Flag that indicates whether the serverless instance uses Serverless Continuous Backup.
        """
        return pulumi.get(self, "continuous_backup_enabled")

    @_builtins.property
    @pulumi.getter(name="createDate")
    def create_date(self) -> _builtins.str:
        return pulumi.get(self, "create_date")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the serverless instance.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def links(self) -> Sequence['outputs.GetServerlessInstancesResultLinkResult']:
        return pulumi.get(self, "links")

    @_builtins.property
    @pulumi.getter(name="mongoDbVersion")
    def mongo_db_version(self) -> _builtins.str:
        """
        Version of MongoDB that the serverless instance runs, in `<major version>`.`<minor version>` format.
        """
        return pulumi.get(self, "mongo_db_version")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (Required) Human-readable label that identifies your serverless instance.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Unique identifier for the [project](https://docs.atlas.mongodb.com/organizations-projects/#std-label-projects) that contains the specified cluster.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="providerSettingsBackingProviderName")
    def provider_settings_backing_provider_name(self) -> _builtins.str:
        """
        Cloud service provider on which MongoDB Cloud provisioned the serverless instance.
        """
        return pulumi.get(self, "provider_settings_backing_provider_name")

    @_builtins.property
    @pulumi.getter(name="providerSettingsProviderName")
    def provider_settings_provider_name(self) -> _builtins.str:
        """
        Cloud service provider that applies to the provisioned the serverless instance.
        """
        return pulumi.get(self, "provider_settings_provider_name")

    @_builtins.property
    @pulumi.getter(name="providerSettingsRegionName")
    def provider_settings_region_name(self) -> _builtins.str:
        """
        Human-readable label that identifies the physical location of your MongoDB serverless instance. The region you choose can affect network latency for clients accessing your databases.
        """
        return pulumi.get(self, "provider_settings_region_name")

    @_builtins.property
    @pulumi.getter(name="stateName")
    def state_name(self) -> _builtins.str:
        """
        Stage of deployment of this serverless instance when the resource made its request.
        """
        return pulumi.get(self, "state_name")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetServerlessInstancesResultTagResult']:
        """
        Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="terminationProtectionEnabled")
    def termination_protection_enabled(self) -> _builtins.bool:
        """
        Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.
        """
        return pulumi.get(self, "termination_protection_enabled")


@pulumi.output_type
class GetServerlessInstancesResultLinkResult(dict):
    def __init__(__self__, *,
                 href: _builtins.str,
                 rel: _builtins.str):
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @_builtins.property
    @pulumi.getter
    def href(self) -> _builtins.str:
        return pulumi.get(self, "href")

    @_builtins.property
    @pulumi.getter
    def rel(self) -> _builtins.str:
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetServerlessInstancesResultTagResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Constant that defines the set of the tag.
        :param _builtins.str value: Variable that belongs to the set of the tag.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Constant that defines the set of the tag.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Variable that belongs to the set of the tag.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetServiceAccountAccessListEntriesResultResult(dict):
    def __init__(__self__, *,
                 cidr_block: _builtins.str,
                 client_id: _builtins.str,
                 created_at: _builtins.str,
                 ip_address: _builtins.str,
                 last_used_address: _builtins.str,
                 last_used_at: _builtins.str,
                 org_id: _builtins.str,
                 request_count: _builtins.int):
        """
        :param _builtins.str cidr_block: Range of IP addresses in CIDR notation to be added to the access list. You can set a value for this parameter or **ip_address**, but not for both.
        :param _builtins.str client_id: The Client ID of the Service Account.
        :param _builtins.str created_at: Date the entry was added to the access list. This attribute expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str ip_address: IP address to be added to the access list. You can set a value for this parameter or **cidr_block**, but not for both.
        :param _builtins.str last_used_address: Network address that issued the most recent request to the API.
        :param _builtins.str last_used_at: Date when the API received the most recent request that originated from this network address.
        :param _builtins.str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param _builtins.int request_count: The number of requests that has originated from this network address.
        """
        pulumi.set(__self__, "cidr_block", cidr_block)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "last_used_address", last_used_address)
        pulumi.set(__self__, "last_used_at", last_used_at)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "request_count", request_count)

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> _builtins.str:
        """
        Range of IP addresses in CIDR notation to be added to the access list. You can set a value for this parameter or **ip_address**, but not for both.
        """
        return pulumi.get(self, "cidr_block")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The Client ID of the Service Account.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Date the entry was added to the access list. This attribute expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> _builtins.str:
        """
        IP address to be added to the access list. You can set a value for this parameter or **cidr_block**, but not for both.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter(name="lastUsedAddress")
    def last_used_address(self) -> _builtins.str:
        """
        Network address that issued the most recent request to the API.
        """
        return pulumi.get(self, "last_used_address")

    @_builtins.property
    @pulumi.getter(name="lastUsedAt")
    def last_used_at(self) -> _builtins.str:
        """
        Date when the API received the most recent request that originated from this network address.
        """
        return pulumi.get(self, "last_used_at")

    @_builtins.property
    @pulumi.getter(name="orgId")
    def org_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @_builtins.property
    @pulumi.getter(name="requestCount")
    def request_count(self) -> _builtins.int:
        """
        The number of requests that has originated from this network address.
        """
        return pulumi.get(self, "request_count")


@pulumi.output_type
class GetServiceAccountProjectAssignmentsResultResult(dict):
    def __init__(__self__, *,
                 project_id: _builtins.str):
        """
        :param _builtins.str project_id: Unique 24-hexadecimal digit string that identifies your project.
        """
        pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies your project.
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class GetServiceAccountSecretResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 expires_at: _builtins.str,
                 last_used_at: _builtins.str,
                 masked_secret_value: _builtins.str,
                 secret_id: _builtins.str):
        """
        :param _builtins.str created_at: The date that the secret was created on. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str expires_at: The date for the expiration of the secret. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str last_used_at: The last time the secret was used. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str masked_secret_value: The masked Service Account secret.
        :param _builtins.str secret_id: Unique 24-hexadecimal digit string that identifies the secret.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "last_used_at", last_used_at)
        pulumi.set(__self__, "masked_secret_value", masked_secret_value)
        pulumi.set(__self__, "secret_id", secret_id)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The date that the secret was created on. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> _builtins.str:
        """
        The date for the expiration of the secret. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter(name="lastUsedAt")
    def last_used_at(self) -> _builtins.str:
        """
        The last time the secret was used. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "last_used_at")

    @_builtins.property
    @pulumi.getter(name="maskedSecretValue")
    def masked_secret_value(self) -> _builtins.str:
        """
        The masked Service Account secret.
        """
        return pulumi.get(self, "masked_secret_value")

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the secret.
        """
        return pulumi.get(self, "secret_id")


@pulumi.output_type
class GetServiceAccountsResultResult(dict):
    def __init__(__self__, *,
                 client_id: _builtins.str,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 name: _builtins.str,
                 roles: Sequence[_builtins.str],
                 secrets: Sequence['outputs.GetServiceAccountsResultSecretResult']):
        """
        :param _builtins.str client_id: The Client ID of the Service Account.
        :param _builtins.str created_at: The date that the Service Account was created on. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str description: Human readable description for the Service Account.
        :param _builtins.str name: Human-readable name for the Service Account.
        :param Sequence[_builtins.str] roles: A list of Organization roles associated with the Service Account.
        :param Sequence['GetServiceAccountsResultSecretArgs'] secrets: A list of secrets associated with the specified Service Account.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The Client ID of the Service Account.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The date that the Service Account was created on. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Human readable description for the Service Account.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Human-readable name for the Service Account.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Sequence[_builtins.str]:
        """
        A list of Organization roles associated with the Service Account.
        """
        return pulumi.get(self, "roles")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Sequence['outputs.GetServiceAccountsResultSecretResult']:
        """
        A list of secrets associated with the specified Service Account.
        """
        return pulumi.get(self, "secrets")


@pulumi.output_type
class GetServiceAccountsResultSecretResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 expires_at: _builtins.str,
                 last_used_at: _builtins.str,
                 masked_secret_value: _builtins.str,
                 secret_id: _builtins.str):
        """
        :param _builtins.str created_at: The date that the secret was created on. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str expires_at: The date for the expiration of the secret. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str last_used_at: The last time the secret was used. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        :param _builtins.str masked_secret_value: The masked Service Account secret.
        :param _builtins.str secret_id: Unique 24-hexadecimal digit string that identifies the secret.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "last_used_at", last_used_at)
        pulumi.set(__self__, "masked_secret_value", masked_secret_value)
        pulumi.set(__self__, "secret_id", secret_id)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The date that the secret was created on. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> _builtins.str:
        """
        The date for the expiration of the secret. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter(name="lastUsedAt")
    def last_used_at(self) -> _builtins.str:
        """
        The last time the secret was used. This parameter expresses its value in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "last_used_at")

    @_builtins.property
    @pulumi.getter(name="maskedSecretValue")
    def masked_secret_value(self) -> _builtins.str:
        """
        The masked Service Account secret.
        """
        return pulumi.get(self, "masked_secret_value")

    @_builtins.property
    @pulumi.getter(name="secretId")
    def secret_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the secret.
        """
        return pulumi.get(self, "secret_id")


@pulumi.output_type
class GetSharedTierRestoreJobsResultResult(dict):
    def __init__(__self__, *,
                 delivery_type: _builtins.str,
                 expiration_date: _builtins.str,
                 job_id: _builtins.str,
                 restore_finished_date: _builtins.str,
                 restore_scheduled_date: _builtins.str,
                 snapshot_finished_date: _builtins.str,
                 snapshot_id: _builtins.str,
                 snapshot_url: _builtins.str,
                 status: _builtins.str,
                 target_deployment_item_name: _builtins.str,
                 target_project_id: _builtins.str):
        pulumi.set(__self__, "delivery_type", delivery_type)
        pulumi.set(__self__, "expiration_date", expiration_date)
        pulumi.set(__self__, "job_id", job_id)
        pulumi.set(__self__, "restore_finished_date", restore_finished_date)
        pulumi.set(__self__, "restore_scheduled_date", restore_scheduled_date)
        pulumi.set(__self__, "snapshot_finished_date", snapshot_finished_date)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "snapshot_url", snapshot_url)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "target_deployment_item_name", target_deployment_item_name)
        pulumi.set(__self__, "target_project_id", target_project_id)

    @_builtins.property
    @pulumi.getter(name="deliveryType")
    def delivery_type(self) -> _builtins.str:
        return pulumi.get(self, "delivery_type")

    @_builtins.property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> _builtins.str:
        return pulumi.get(self, "expiration_date")

    @_builtins.property
    @pulumi.getter(name="jobId")
    def job_id(self) -> _builtins.str:
        return pulumi.get(self, "job_id")

    @_builtins.property
    @pulumi.getter(name="restoreFinishedDate")
    def restore_finished_date(self) -> _builtins.str:
        return pulumi.get(self, "restore_finished_date")

    @_builtins.property
    @pulumi.getter(name="restoreScheduledDate")
    def restore_scheduled_date(self) -> _builtins.str:
        return pulumi.get(self, "restore_scheduled_date")

    @_builtins.property
    @pulumi.getter(name="snapshotFinishedDate")
    def snapshot_finished_date(self) -> _builtins.str:
        return pulumi.get(self, "snapshot_finished_date")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> _builtins.str:
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter(name="snapshotUrl")
    def snapshot_url(self) -> _builtins.str:
        return pulumi.get(self, "snapshot_url")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="targetDeploymentItemName")
    def target_deployment_item_name(self) -> _builtins.str:
        return pulumi.get(self, "target_deployment_item_name")

    @_builtins.property
    @pulumi.getter(name="targetProjectId")
    def target_project_id(self) -> _builtins.str:
        return pulumi.get(self, "target_project_id")


@pulumi.output_type
class GetSharedTierSnapshotsResultResult(dict):
    def __init__(__self__, *,
                 expiration: _builtins.str,
                 finish_time: _builtins.str,
                 mongo_db_version: _builtins.str,
                 scheduled_time: _builtins.str,
                 snapshot_id: _builtins.str,
                 start_time: _builtins.str,
                 status: _builtins.str):
        pulumi.set(__self__, "expiration", expiration)
        pulumi.set(__self__, "finish_time", finish_time)
        pulumi.set(__self__, "mongo_db_version", mongo_db_version)
        pulumi.set(__self__, "scheduled_time", scheduled_time)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def expiration(self) -> _builtins.str:
        return pulumi.get(self, "expiration")

    @_builtins.property
    @pulumi.getter(name="finishTime")
    def finish_time(self) -> _builtins.str:
        return pulumi.get(self, "finish_time")

    @_builtins.property
    @pulumi.getter(name="mongoDbVersion")
    def mongo_db_version(self) -> _builtins.str:
        return pulumi.get(self, "mongo_db_version")

    @_builtins.property
    @pulumi.getter(name="scheduledTime")
    def scheduled_time(self) -> _builtins.str:
        return pulumi.get(self, "scheduled_time")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> _builtins.str:
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetStreamConnectionAuthenticationResult(dict):
    def __init__(__self__, *,
                 client_id: _builtins.str,
                 client_secret: _builtins.str,
                 mechanism: _builtins.str,
                 method: _builtins.str,
                 password: _builtins.str,
                 sasl_oauthbearer_extensions: _builtins.str,
                 scope: _builtins.str,
                 token_endpoint_url: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str client_id: Public identifier for the Kafka client.
        :param _builtins.str client_secret: Secret known only to the Kafka client and the authorization server.
        :param _builtins.str mechanism: Method of authentication. Value can be `PLAIN`, `SCRAM-256`, `SCRAM-512`, or `OAUTHBEARER`.
        :param _builtins.str method: SASL OAUTHBEARER authentication method. Value must be OIDC.
        :param _builtins.str password: Password for the Schema Registry. Required when `type` is `USER_INFO`.
        :param _builtins.str sasl_oauthbearer_extensions: Additional information to provide to the Kafka broker.
        :param _builtins.str scope: Scope of the access request to the broker specified by the Kafka clients.
        :param _builtins.str token_endpoint_url: OAUTH issuer (IdP provider) token endpoint HTTP(S) URI used to retrieve the token.
        :param _builtins.str username: Username for the Schema Registry. Required when `type` is `USER_INFO`.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "mechanism", mechanism)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "sasl_oauthbearer_extensions", sasl_oauthbearer_extensions)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "token_endpoint_url", token_endpoint_url)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        Public identifier for the Kafka client.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> _builtins.str:
        """
        Secret known only to the Kafka client and the authorization server.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter
    def mechanism(self) -> _builtins.str:
        """
        Method of authentication. Value can be `PLAIN`, `SCRAM-256`, `SCRAM-512`, or `OAUTHBEARER`.
        """
        return pulumi.get(self, "mechanism")

    @_builtins.property
    @pulumi.getter
    def method(self) -> _builtins.str:
        """
        SASL OAUTHBEARER authentication method. Value must be OIDC.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        Password for the Schema Registry. Required when `type` is `USER_INFO`.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="saslOauthbearerExtensions")
    def sasl_oauthbearer_extensions(self) -> _builtins.str:
        """
        Additional information to provide to the Kafka broker.
        """
        return pulumi.get(self, "sasl_oauthbearer_extensions")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> _builtins.str:
        """
        Scope of the access request to the broker specified by the Kafka clients.
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter(name="tokenEndpointUrl")
    def token_endpoint_url(self) -> _builtins.str:
        """
        OAUTH issuer (IdP provider) token endpoint HTTP(S) URI used to retrieve the token.
        """
        return pulumi.get(self, "token_endpoint_url")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Username for the Schema Registry. Required when `type` is `USER_INFO`.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetStreamConnectionAwsResult(dict):
    def __init__(__self__, *,
                 role_arn: _builtins.str):
        """
        :param _builtins.str role_arn: Amazon Resource Name (ARN) that identifies the Amazon Web Services (AWS) Identity and Access Management (IAM) role that MongoDB Cloud assumes when it accesses resources in your AWS account.
        """
        pulumi.set(__self__, "role_arn", role_arn)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        """
        Amazon Resource Name (ARN) that identifies the Amazon Web Services (AWS) Identity and Access Management (IAM) role that MongoDB Cloud assumes when it accesses resources in your AWS account.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class GetStreamConnectionDbRoleToExecuteResult(dict):
    def __init__(__self__, *,
                 role: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str role: The name of the role to use. Can be a built in role or a custom role.
        :param _builtins.str type: Authentication type discriminator. Specifies the authentication mechanism for Confluent Schema Registry. Valid values are `USER_INFO` or `SASL_INHERIT`.
               * `USER_INFO` - Uses username and password authentication for Confluent Schema Registry.
               * `SASL_INHERIT` - Inherits the authentication configuration from Kafka for the Confluent Schema Registry.
        """
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The name of the role to use. Can be a built in role or a custom role.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Authentication type discriminator. Specifies the authentication mechanism for Confluent Schema Registry. Valid values are `USER_INFO` or `SASL_INHERIT`.
        * `USER_INFO` - Uses username and password authentication for Confluent Schema Registry.
        * `SASL_INHERIT` - Inherits the authentication configuration from Kafka for the Confluent Schema Registry.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetStreamConnectionNetworkingResult(dict):
    def __init__(__self__, *,
                 access: 'outputs.GetStreamConnectionNetworkingAccessResult'):
        """
        :param 'GetStreamConnectionNetworkingAccessArgs' access: Information about the networking access. See access.
        """
        pulumi.set(__self__, "access", access)

    @_builtins.property
    @pulumi.getter
    def access(self) -> 'outputs.GetStreamConnectionNetworkingAccessResult':
        """
        Information about the networking access. See access.
        """
        return pulumi.get(self, "access")


@pulumi.output_type
class GetStreamConnectionNetworkingAccessResult(dict):
    def __init__(__self__, *,
                 connection_id: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str connection_id: Id of the Private Link connection when type is `PRIVATE_LINK`.
        :param _builtins.str type: Authentication type discriminator. Specifies the authentication mechanism for Confluent Schema Registry. Valid values are `USER_INFO` or `SASL_INHERIT`.
               * `USER_INFO` - Uses username and password authentication for Confluent Schema Registry.
               * `SASL_INHERIT` - Inherits the authentication configuration from Kafka for the Confluent Schema Registry.
        """
        pulumi.set(__self__, "connection_id", connection_id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> _builtins.str:
        """
        Id of the Private Link connection when type is `PRIVATE_LINK`.
        """
        return pulumi.get(self, "connection_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Authentication type discriminator. Specifies the authentication mechanism for Confluent Schema Registry. Valid values are `USER_INFO` or `SASL_INHERIT`.
        * `USER_INFO` - Uses username and password authentication for Confluent Schema Registry.
        * `SASL_INHERIT` - Inherits the authentication configuration from Kafka for the Confluent Schema Registry.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetStreamConnectionSchemaRegistryAuthenticationResult(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 type: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str password: Password for the Schema Registry. Required when `type` is `USER_INFO`.
        :param _builtins.str type: Authentication type discriminator. Specifies the authentication mechanism for Confluent Schema Registry. Valid values are `USER_INFO` or `SASL_INHERIT`.
               * `USER_INFO` - Uses username and password authentication for Confluent Schema Registry.
               * `SASL_INHERIT` - Inherits the authentication configuration from Kafka for the Confluent Schema Registry.
        :param _builtins.str username: Username for the Schema Registry. Required when `type` is `USER_INFO`.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        Password for the Schema Registry. Required when `type` is `USER_INFO`.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Authentication type discriminator. Specifies the authentication mechanism for Confluent Schema Registry. Valid values are `USER_INFO` or `SASL_INHERIT`.
        * `USER_INFO` - Uses username and password authentication for Confluent Schema Registry.
        * `SASL_INHERIT` - Inherits the authentication configuration from Kafka for the Confluent Schema Registry.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Username for the Schema Registry. Required when `type` is `USER_INFO`.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetStreamConnectionSecurityResult(dict):
    def __init__(__self__, *,
                 broker_public_certificate: _builtins.str,
                 protocol: _builtins.str):
        """
        :param _builtins.str broker_public_certificate: A trusted, public x509 certificate for connecting to Kafka over SSL. String value of the certificate must be defined in the attribute.
        :param _builtins.str protocol: Describes the transport type. Can be either `SASL_PLAINTEXT` or `SASL_SSL`.
        """
        pulumi.set(__self__, "broker_public_certificate", broker_public_certificate)
        pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="brokerPublicCertificate")
    def broker_public_certificate(self) -> _builtins.str:
        """
        A trusted, public x509 certificate for connecting to Kafka over SSL. String value of the certificate must be defined in the attribute.
        """
        return pulumi.get(self, "broker_public_certificate")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        Describes the transport type. Can be either `SASL_PLAINTEXT` or `SASL_SSL`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetStreamConnectionsResultResult(dict):
    def __init__(__self__, *,
                 authentication: 'outputs.GetStreamConnectionsResultAuthenticationResult',
                 aws: 'outputs.GetStreamConnectionsResultAwsResult',
                 bootstrap_servers: _builtins.str,
                 cluster_name: _builtins.str,
                 cluster_project_id: _builtins.str,
                 config: Mapping[str, _builtins.str],
                 connection_name: _builtins.str,
                 db_role_to_execute: 'outputs.GetStreamConnectionsResultDbRoleToExecuteResult',
                 headers: Mapping[str, _builtins.str],
                 id: _builtins.str,
                 instance_name: _builtins.str,
                 networking: 'outputs.GetStreamConnectionsResultNetworkingResult',
                 project_id: _builtins.str,
                 schema_registry_authentication: 'outputs.GetStreamConnectionsResultSchemaRegistryAuthenticationResult',
                 schema_registry_provider: _builtins.str,
                 schema_registry_urls: Sequence[_builtins.str],
                 security: 'outputs.GetStreamConnectionsResultSecurityResult',
                 type: _builtins.str,
                 url: _builtins.str,
                 workspace_name: _builtins.str):
        """
        :param 'GetStreamConnectionsResultAuthenticationArgs' authentication: User credentials required to connect to a Kafka cluster. Includes the authentication type, as well as the parameters for that authentication mode. See authentication.
        :param 'GetStreamConnectionsResultAwsArgs' aws: The configuration for AWS Lambda connection. See AWS
        :param _builtins.str bootstrap_servers: Comma separated list of server addresses.
        :param _builtins.str cluster_name: Name of the cluster configured for this connection.
        :param Mapping[str, _builtins.str] config: A map of Kafka key-value pairs for optional configuration. This is a flat object, and keys can have '.' characters.
        :param _builtins.str connection_name: Label that identifies the stream connection. In the case of the Sample type, this is the name of the sample source.
        :param 'GetStreamConnectionsResultDbRoleToExecuteArgs' db_role_to_execute: The name of a Built in or Custom DB Role to connect to an Atlas Cluster. See DBRoleToExecute.
        :param Mapping[str, _builtins.str] headers: A map of key-value pairs for optional headers.
        :param _builtins.str instance_name: Label that identifies the stream processing workspace. Attribute is deprecated and will be removed in following major versions in favor of `workspace_name`.
        :param 'GetStreamConnectionsResultNetworkingArgs' networking: Networking Access Type can either be `PUBLIC` (default) or `VPC`. See networking.
        :param _builtins.str project_id: Unique 24-hexadecimal digit string that identifies your project.
        :param 'GetStreamConnectionsResultSchemaRegistryAuthenticationArgs' schema_registry_authentication: Authentication configuration for Schema Registry. See Schema Registry Authentication.
        :param _builtins.str schema_registry_provider: The Schema Registry provider. Must be set to `CONFLUENT`.
        :param Sequence[_builtins.str] schema_registry_urls: List of Schema Registry endpoint URLs used by this connection. Each URL must use the http or https scheme and specify a valid host and optional port.
        :param 'GetStreamConnectionsResultSecurityArgs' security: Properties for the secure transport connection to Kafka. For SASL_SSL, this can include the trusted certificate to use. See security.
        :param _builtins.str type: Authentication type discriminator. Specifies the authentication mechanism for Confluent Schema Registry. Valid values are `USER_INFO` or `SASL_INHERIT`.
               * `USER_INFO` - Uses username and password authentication for Confluent Schema Registry.
               * `SASL_INHERIT` - Inherits the authentication configuration from Kafka for the Confluent Schema Registry.
        :param _builtins.str url: URL of the HTTPs endpoint that will be used for creating a connection.
        :param _builtins.str workspace_name: Label that identifies the stream processing workspace. Conflicts with `instance_name`.
               
               > **NOTE:** Either `workspace_name` or `instance_name` must be provided, but not both. These fields are functionally identical and `workspace_name` is an alias for `instance_name`. `workspace_name` should be used instead of `instance_name`.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "aws", aws)
        pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "cluster_project_id", cluster_project_id)
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "connection_name", connection_name)
        pulumi.set(__self__, "db_role_to_execute", db_role_to_execute)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "instance_name", instance_name)
        pulumi.set(__self__, "networking", networking)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "schema_registry_authentication", schema_registry_authentication)
        pulumi.set(__self__, "schema_registry_provider", schema_registry_provider)
        pulumi.set(__self__, "schema_registry_urls", schema_registry_urls)
        pulumi.set(__self__, "security", security)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "workspace_name", workspace_name)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> 'outputs.GetStreamConnectionsResultAuthenticationResult':
        """
        User credentials required to connect to a Kafka cluster. Includes the authentication type, as well as the parameters for that authentication mode. See authentication.
        """
        return pulumi.get(self, "authentication")

    @_builtins.property
    @pulumi.getter
    def aws(self) -> 'outputs.GetStreamConnectionsResultAwsResult':
        """
        The configuration for AWS Lambda connection. See AWS
        """
        return pulumi.get(self, "aws")

    @_builtins.property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> _builtins.str:
        """
        Comma separated list of server addresses.
        """
        return pulumi.get(self, "bootstrap_servers")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> _builtins.str:
        """
        Name of the cluster configured for this connection.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="clusterProjectId")
    def cluster_project_id(self) -> _builtins.str:
        return pulumi.get(self, "cluster_project_id")

    @_builtins.property
    @pulumi.getter
    def config(self) -> Mapping[str, _builtins.str]:
        """
        A map of Kafka key-value pairs for optional configuration. This is a flat object, and keys can have '.' characters.
        """
        return pulumi.get(self, "config")

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> _builtins.str:
        """
        Label that identifies the stream connection. In the case of the Sample type, this is the name of the sample source.
        """
        return pulumi.get(self, "connection_name")

    @_builtins.property
    @pulumi.getter(name="dbRoleToExecute")
    def db_role_to_execute(self) -> 'outputs.GetStreamConnectionsResultDbRoleToExecuteResult':
        """
        The name of a Built in or Custom DB Role to connect to an Atlas Cluster. See DBRoleToExecute.
        """
        return pulumi.get(self, "db_role_to_execute")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Mapping[str, _builtins.str]:
        """
        A map of key-value pairs for optional headers.
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="instanceName")
    @_utilities.deprecated("""This parameter is deprecated. Please transition to workspace_name.""")
    def instance_name(self) -> _builtins.str:
        """
        Label that identifies the stream processing workspace. Attribute is deprecated and will be removed in following major versions in favor of `workspace_name`.
        """
        return pulumi.get(self, "instance_name")

    @_builtins.property
    @pulumi.getter
    def networking(self) -> 'outputs.GetStreamConnectionsResultNetworkingResult':
        """
        Networking Access Type can either be `PUBLIC` (default) or `VPC`. See networking.
        """
        return pulumi.get(self, "networking")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies your project.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="schemaRegistryAuthentication")
    def schema_registry_authentication(self) -> 'outputs.GetStreamConnectionsResultSchemaRegistryAuthenticationResult':
        """
        Authentication configuration for Schema Registry. See Schema Registry Authentication.
        """
        return pulumi.get(self, "schema_registry_authentication")

    @_builtins.property
    @pulumi.getter(name="schemaRegistryProvider")
    def schema_registry_provider(self) -> _builtins.str:
        """
        The Schema Registry provider. Must be set to `CONFLUENT`.
        """
        return pulumi.get(self, "schema_registry_provider")

    @_builtins.property
    @pulumi.getter(name="schemaRegistryUrls")
    def schema_registry_urls(self) -> Sequence[_builtins.str]:
        """
        List of Schema Registry endpoint URLs used by this connection. Each URL must use the http or https scheme and specify a valid host and optional port.
        """
        return pulumi.get(self, "schema_registry_urls")

    @_builtins.property
    @pulumi.getter
    def security(self) -> 'outputs.GetStreamConnectionsResultSecurityResult':
        """
        Properties for the secure transport connection to Kafka. For SASL_SSL, this can include the trusted certificate to use. See security.
        """
        return pulumi.get(self, "security")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Authentication type discriminator. Specifies the authentication mechanism for Confluent Schema Registry. Valid values are `USER_INFO` or `SASL_INHERIT`.
        * `USER_INFO` - Uses username and password authentication for Confluent Schema Registry.
        * `SASL_INHERIT` - Inherits the authentication configuration from Kafka for the Confluent Schema Registry.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        URL of the HTTPs endpoint that will be used for creating a connection.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="workspaceName")
    def workspace_name(self) -> _builtins.str:
        """
        Label that identifies the stream processing workspace. Conflicts with `instance_name`.

        > **NOTE:** Either `workspace_name` or `instance_name` must be provided, but not both. These fields are functionally identical and `workspace_name` is an alias for `instance_name`. `workspace_name` should be used instead of `instance_name`.
        """
        return pulumi.get(self, "workspace_name")


@pulumi.output_type
class GetStreamConnectionsResultAuthenticationResult(dict):
    def __init__(__self__, *,
                 client_id: _builtins.str,
                 client_secret: _builtins.str,
                 mechanism: _builtins.str,
                 method: _builtins.str,
                 password: _builtins.str,
                 sasl_oauthbearer_extensions: _builtins.str,
                 scope: _builtins.str,
                 token_endpoint_url: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str client_id: Public identifier for the Kafka client.
        :param _builtins.str client_secret: Secret known only to the Kafka client and the authorization server.
        :param _builtins.str mechanism: Method of authentication. Value can be `PLAIN`, `SCRAM-256`, `SCRAM-512`, or `OAUTHBEARER`.
        :param _builtins.str method: SASL OAUTHBEARER authentication method. Value must be OIDC.
        :param _builtins.str password: Password for the Schema Registry. Required when `type` is `USER_INFO`.
        :param _builtins.str sasl_oauthbearer_extensions: Additional information to provide to the Kafka broker.
        :param _builtins.str scope: Scope of the access request to the broker specified by the Kafka clients.
        :param _builtins.str token_endpoint_url: OAUTH issuer (IdP provider) token endpoint HTTP(S) URI used to retrieve the token.
        :param _builtins.str username: Username for the Schema Registry. Required when `type` is `USER_INFO`.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "mechanism", mechanism)
        pulumi.set(__self__, "method", method)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "sasl_oauthbearer_extensions", sasl_oauthbearer_extensions)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "token_endpoint_url", token_endpoint_url)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        Public identifier for the Kafka client.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> _builtins.str:
        """
        Secret known only to the Kafka client and the authorization server.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter
    def mechanism(self) -> _builtins.str:
        """
        Method of authentication. Value can be `PLAIN`, `SCRAM-256`, `SCRAM-512`, or `OAUTHBEARER`.
        """
        return pulumi.get(self, "mechanism")

    @_builtins.property
    @pulumi.getter
    def method(self) -> _builtins.str:
        """
        SASL OAUTHBEARER authentication method. Value must be OIDC.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        Password for the Schema Registry. Required when `type` is `USER_INFO`.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="saslOauthbearerExtensions")
    def sasl_oauthbearer_extensions(self) -> _builtins.str:
        """
        Additional information to provide to the Kafka broker.
        """
        return pulumi.get(self, "sasl_oauthbearer_extensions")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> _builtins.str:
        """
        Scope of the access request to the broker specified by the Kafka clients.
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter(name="tokenEndpointUrl")
    def token_endpoint_url(self) -> _builtins.str:
        """
        OAUTH issuer (IdP provider) token endpoint HTTP(S) URI used to retrieve the token.
        """
        return pulumi.get(self, "token_endpoint_url")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Username for the Schema Registry. Required when `type` is `USER_INFO`.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetStreamConnectionsResultAwsResult(dict):
    def __init__(__self__, *,
                 role_arn: _builtins.str):
        """
        :param _builtins.str role_arn: Amazon Resource Name (ARN) that identifies the Amazon Web Services (AWS) Identity and Access Management (IAM) role that MongoDB Cloud assumes when it accesses resources in your AWS account.
        """
        pulumi.set(__self__, "role_arn", role_arn)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        """
        Amazon Resource Name (ARN) that identifies the Amazon Web Services (AWS) Identity and Access Management (IAM) role that MongoDB Cloud assumes when it accesses resources in your AWS account.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class GetStreamConnectionsResultDbRoleToExecuteResult(dict):
    def __init__(__self__, *,
                 role: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str role: The name of the role to use. Can be a built in role or a custom role.
        :param _builtins.str type: Authentication type discriminator. Specifies the authentication mechanism for Confluent Schema Registry. Valid values are `USER_INFO` or `SASL_INHERIT`.
               * `USER_INFO` - Uses username and password authentication for Confluent Schema Registry.
               * `SASL_INHERIT` - Inherits the authentication configuration from Kafka for the Confluent Schema Registry.
        """
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The name of the role to use. Can be a built in role or a custom role.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Authentication type discriminator. Specifies the authentication mechanism for Confluent Schema Registry. Valid values are `USER_INFO` or `SASL_INHERIT`.
        * `USER_INFO` - Uses username and password authentication for Confluent Schema Registry.
        * `SASL_INHERIT` - Inherits the authentication configuration from Kafka for the Confluent Schema Registry.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetStreamConnectionsResultNetworkingResult(dict):
    def __init__(__self__, *,
                 access: 'outputs.GetStreamConnectionsResultNetworkingAccessResult'):
        """
        :param 'GetStreamConnectionsResultNetworkingAccessArgs' access: Information about the networking access. See access.
        """
        pulumi.set(__self__, "access", access)

    @_builtins.property
    @pulumi.getter
    def access(self) -> 'outputs.GetStreamConnectionsResultNetworkingAccessResult':
        """
        Information about the networking access. See access.
        """
        return pulumi.get(self, "access")


@pulumi.output_type
class GetStreamConnectionsResultNetworkingAccessResult(dict):
    def __init__(__self__, *,
                 connection_id: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str connection_id: Id of the Private Link connection when type is `PRIVATE_LINK`.
        :param _builtins.str type: Authentication type discriminator. Specifies the authentication mechanism for Confluent Schema Registry. Valid values are `USER_INFO` or `SASL_INHERIT`.
               * `USER_INFO` - Uses username and password authentication for Confluent Schema Registry.
               * `SASL_INHERIT` - Inherits the authentication configuration from Kafka for the Confluent Schema Registry.
        """
        pulumi.set(__self__, "connection_id", connection_id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> _builtins.str:
        """
        Id of the Private Link connection when type is `PRIVATE_LINK`.
        """
        return pulumi.get(self, "connection_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Authentication type discriminator. Specifies the authentication mechanism for Confluent Schema Registry. Valid values are `USER_INFO` or `SASL_INHERIT`.
        * `USER_INFO` - Uses username and password authentication for Confluent Schema Registry.
        * `SASL_INHERIT` - Inherits the authentication configuration from Kafka for the Confluent Schema Registry.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetStreamConnectionsResultSchemaRegistryAuthenticationResult(dict):
    def __init__(__self__, *,
                 password: _builtins.str,
                 type: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str password: Password for the Schema Registry. Required when `type` is `USER_INFO`.
        :param _builtins.str type: Authentication type discriminator. Specifies the authentication mechanism for Confluent Schema Registry. Valid values are `USER_INFO` or `SASL_INHERIT`.
               * `USER_INFO` - Uses username and password authentication for Confluent Schema Registry.
               * `SASL_INHERIT` - Inherits the authentication configuration from Kafka for the Confluent Schema Registry.
        :param _builtins.str username: Username for the Schema Registry. Required when `type` is `USER_INFO`.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        Password for the Schema Registry. Required when `type` is `USER_INFO`.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Authentication type discriminator. Specifies the authentication mechanism for Confluent Schema Registry. Valid values are `USER_INFO` or `SASL_INHERIT`.
        * `USER_INFO` - Uses username and password authentication for Confluent Schema Registry.
        * `SASL_INHERIT` - Inherits the authentication configuration from Kafka for the Confluent Schema Registry.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Username for the Schema Registry. Required when `type` is `USER_INFO`.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetStreamConnectionsResultSecurityResult(dict):
    def __init__(__self__, *,
                 broker_public_certificate: _builtins.str,
                 protocol: _builtins.str):
        """
        :param _builtins.str broker_public_certificate: A trusted, public x509 certificate for connecting to Kafka over SSL. String value of the certificate must be defined in the attribute.
        :param _builtins.str protocol: Describes the transport type. Can be either `SASL_PLAINTEXT` or `SASL_SSL`.
        """
        pulumi.set(__self__, "broker_public_certificate", broker_public_certificate)
        pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="brokerPublicCertificate")
    def broker_public_certificate(self) -> _builtins.str:
        """
        A trusted, public x509 certificate for connecting to Kafka over SSL. String value of the certificate must be defined in the attribute.
        """
        return pulumi.get(self, "broker_public_certificate")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        Describes the transport type. Can be either `SASL_PLAINTEXT` or `SASL_SSL`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetStreamInstanceDataProcessRegionResult(dict):
    def __init__(__self__, *,
                 cloud_provider: _builtins.str,
                 region: _builtins.str):
        """
        :param _builtins.str cloud_provider: Label that identifies the cloud service provider where MongoDB Cloud performs stream processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        :param _builtins.str region: Name of the cloud provider region hosting Atlas Stream Processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> _builtins.str:
        """
        Label that identifies the cloud service provider where MongoDB Cloud performs stream processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Name of the cloud provider region hosting Atlas Stream Processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetStreamInstanceStreamConfigResult(dict):
    def __init__(__self__, *,
                 max_tier_size: _builtins.str,
                 tier: _builtins.str):
        """
        :param _builtins.str tier: Selected tier for the Stream Instance. Configures Memory / VCPU allowances. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        pulumi.set(__self__, "max_tier_size", max_tier_size)
        pulumi.set(__self__, "tier", tier)

    @_builtins.property
    @pulumi.getter(name="maxTierSize")
    def max_tier_size(self) -> _builtins.str:
        return pulumi.get(self, "max_tier_size")

    @_builtins.property
    @pulumi.getter
    def tier(self) -> _builtins.str:
        """
        Selected tier for the Stream Instance. Configures Memory / VCPU allowances. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class GetStreamInstancesResultResult(dict):
    def __init__(__self__, *,
                 data_process_region: 'outputs.GetStreamInstancesResultDataProcessRegionResult',
                 hostnames: Sequence[_builtins.str],
                 id: _builtins.str,
                 instance_name: _builtins.str,
                 project_id: _builtins.str,
                 stream_config: 'outputs.GetStreamInstancesResultStreamConfigResult'):
        """
        :param 'GetStreamInstancesResultDataProcessRegionArgs' data_process_region: Defines the cloud service provider and region where MongoDB Cloud performs stream processing. See data process region.
        :param Sequence[_builtins.str] hostnames: List that contains the hostnames assigned to the stream instance.
        :param _builtins.str instance_name: Human-readable label that identifies the stream instance.
        :param _builtins.str project_id: Unique 24-hexadecimal digit string that identifies your project.
        :param 'GetStreamInstancesResultStreamConfigArgs' stream_config: Defines the configuration options for an Atlas Stream Processing Instance. See stream config
        """
        pulumi.set(__self__, "data_process_region", data_process_region)
        pulumi.set(__self__, "hostnames", hostnames)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "instance_name", instance_name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "stream_config", stream_config)

    @_builtins.property
    @pulumi.getter(name="dataProcessRegion")
    def data_process_region(self) -> 'outputs.GetStreamInstancesResultDataProcessRegionResult':
        """
        Defines the cloud service provider and region where MongoDB Cloud performs stream processing. See data process region.
        """
        return pulumi.get(self, "data_process_region")

    @_builtins.property
    @pulumi.getter
    def hostnames(self) -> Sequence[_builtins.str]:
        """
        List that contains the hostnames assigned to the stream instance.
        """
        return pulumi.get(self, "hostnames")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> _builtins.str:
        """
        Human-readable label that identifies the stream instance.
        """
        return pulumi.get(self, "instance_name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies your project.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="streamConfig")
    def stream_config(self) -> 'outputs.GetStreamInstancesResultStreamConfigResult':
        """
        Defines the configuration options for an Atlas Stream Processing Instance. See stream config
        """
        return pulumi.get(self, "stream_config")


@pulumi.output_type
class GetStreamInstancesResultDataProcessRegionResult(dict):
    def __init__(__self__, *,
                 cloud_provider: _builtins.str,
                 region: _builtins.str):
        """
        :param _builtins.str cloud_provider: Label that identifies the cloud service provider where MongoDB Cloud performs stream processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        :param _builtins.str region: Name of the cloud provider region hosting Atlas Stream Processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> _builtins.str:
        """
        Label that identifies the cloud service provider where MongoDB Cloud performs stream processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Name of the cloud provider region hosting Atlas Stream Processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetStreamInstancesResultStreamConfigResult(dict):
    def __init__(__self__, *,
                 max_tier_size: _builtins.str,
                 tier: _builtins.str):
        """
        :param _builtins.str tier: Selected tier for the Stream Instance. Configures Memory / VCPU allowances. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        pulumi.set(__self__, "max_tier_size", max_tier_size)
        pulumi.set(__self__, "tier", tier)

    @_builtins.property
    @pulumi.getter(name="maxTierSize")
    def max_tier_size(self) -> _builtins.str:
        return pulumi.get(self, "max_tier_size")

    @_builtins.property
    @pulumi.getter
    def tier(self) -> _builtins.str:
        """
        Selected tier for the Stream Instance. Configures Memory / VCPU allowances. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class GetStreamPrivatelinkEndpointsResultResult(dict):
    def __init__(__self__, *,
                 arn: _builtins.str,
                 dns_domain: _builtins.str,
                 dns_sub_domains: Sequence[_builtins.str],
                 error_message: _builtins.str,
                 id: _builtins.str,
                 interface_endpoint_id: _builtins.str,
                 interface_endpoint_name: _builtins.str,
                 project_id: _builtins.str,
                 provider_account_id: _builtins.str,
                 provider_name: _builtins.str,
                 region: _builtins.str,
                 service_attachment_uris: Sequence[_builtins.str],
                 service_endpoint_id: _builtins.str,
                 state: _builtins.str,
                 vendor: _builtins.str):
        """
        :param _builtins.str arn: Amazon Resource Name (ARN). Required for AWS Provider and MSK vendor.
        :param _builtins.str dns_domain: The domain hostname. Required for the following provider and vendor combinations:
               				
               	* AWS provider with CONFLUENT vendor.
               
               	* AZURE provider with EVENTHUB or CONFLUENT vendor.
        :param Sequence[_builtins.str] dns_sub_domains: Sub-Domain name of Confluent cluster. These are typically your availability zones. Required for AWS Provider and CONFLUENT vendor. If your AWS CONFLUENT cluster doesn't use subdomains, you must set this to the empty array [].
        :param _builtins.str error_message: Error message if the connection is in a failed state.
        :param _builtins.str id: The ID of the Private Link connection.
        :param _builtins.str interface_endpoint_id: Interface endpoint ID that is created from the specified service endpoint ID.
        :param _builtins.str interface_endpoint_name: Name of interface endpoint that is created from the specified service endpoint ID.
        :param _builtins.str project_id: Unique 24-hexadecimal digit string that identifies your project. Use the /groups endpoint to retrieve all projects to which the authenticated user has access.<br>**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group or project id remains the same. The resource and corresponding endpoints use the term groups.
        :param _builtins.str provider_account_id: Account ID from the cloud provider.
        :param _builtins.str provider_name: Provider where the endpoint is deployed. Valid values are AWS, AZURE, and GCP.
        :param _builtins.str region: The region of the Provider’s cluster. See [AZURE](https://www.mongodb.com/docs/atlas/reference/microsoft-azure/#stream-processing-instances) and [AWS](https://www.mongodb.com/docs/atlas/reference/amazon-aws/#stream-processing-instances) supported regions. When the vendor is `CONFLUENT`, this is the domain name of Confluent cluster. When the vendor is `MSK`, this is computed by the API from the provided `arn`.
        :param Sequence[_builtins.str] service_attachment_uris: List of GCP service attachment URIs for Confluent vendor. Required for GCP provider with CONFLUENT vendor.
        :param _builtins.str service_endpoint_id: For AZURE EVENTHUB, this is the [namespace endpoint ID](https://learn.microsoft.com/en-us/rest/api/eventhub/namespaces/get). For AWS CONFLUENT cluster, this is the [VPC Endpoint service name](https://docs.confluent.io/cloud/current/networking/private-links/aws-privatelink.html).
        :param _builtins.str state: Status of the connection.
        :param _builtins.str vendor: Vendor that manages the endpoint. The following are the vendor values per provider:
               
               	* **AWS**: MSK, CONFLUENT, and S3
               
               	* **Azure**: EVENTHUB and CONFLUENT
               
               	* **GCP**: CONFLUENT
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "dns_domain", dns_domain)
        pulumi.set(__self__, "dns_sub_domains", dns_sub_domains)
        pulumi.set(__self__, "error_message", error_message)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "interface_endpoint_id", interface_endpoint_id)
        pulumi.set(__self__, "interface_endpoint_name", interface_endpoint_name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "provider_account_id", provider_account_id)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "service_attachment_uris", service_attachment_uris)
        pulumi.set(__self__, "service_endpoint_id", service_endpoint_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "vendor", vendor)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        Amazon Resource Name (ARN). Required for AWS Provider and MSK vendor.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="dnsDomain")
    def dns_domain(self) -> _builtins.str:
        """
        The domain hostname. Required for the following provider and vendor combinations:
        				
        	* AWS provider with CONFLUENT vendor.

        	* AZURE provider with EVENTHUB or CONFLUENT vendor.
        """
        return pulumi.get(self, "dns_domain")

    @_builtins.property
    @pulumi.getter(name="dnsSubDomains")
    def dns_sub_domains(self) -> Sequence[_builtins.str]:
        """
        Sub-Domain name of Confluent cluster. These are typically your availability zones. Required for AWS Provider and CONFLUENT vendor. If your AWS CONFLUENT cluster doesn't use subdomains, you must set this to the empty array [].
        """
        return pulumi.get(self, "dns_sub_domains")

    @_builtins.property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> _builtins.str:
        """
        Error message if the connection is in a failed state.
        """
        return pulumi.get(self, "error_message")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the Private Link connection.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="interfaceEndpointId")
    def interface_endpoint_id(self) -> _builtins.str:
        """
        Interface endpoint ID that is created from the specified service endpoint ID.
        """
        return pulumi.get(self, "interface_endpoint_id")

    @_builtins.property
    @pulumi.getter(name="interfaceEndpointName")
    def interface_endpoint_name(self) -> _builtins.str:
        """
        Name of interface endpoint that is created from the specified service endpoint ID.
        """
        return pulumi.get(self, "interface_endpoint_name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies your project. Use the /groups endpoint to retrieve all projects to which the authenticated user has access.<br>**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group or project id remains the same. The resource and corresponding endpoints use the term groups.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="providerAccountId")
    def provider_account_id(self) -> _builtins.str:
        """
        Account ID from the cloud provider.
        """
        return pulumi.get(self, "provider_account_id")

    @_builtins.property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> _builtins.str:
        """
        Provider where the endpoint is deployed. Valid values are AWS, AZURE, and GCP.
        """
        return pulumi.get(self, "provider_name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The region of the Provider’s cluster. See [AZURE](https://www.mongodb.com/docs/atlas/reference/microsoft-azure/#stream-processing-instances) and [AWS](https://www.mongodb.com/docs/atlas/reference/amazon-aws/#stream-processing-instances) supported regions. When the vendor is `CONFLUENT`, this is the domain name of Confluent cluster. When the vendor is `MSK`, this is computed by the API from the provided `arn`.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="serviceAttachmentUris")
    def service_attachment_uris(self) -> Sequence[_builtins.str]:
        """
        List of GCP service attachment URIs for Confluent vendor. Required for GCP provider with CONFLUENT vendor.
        """
        return pulumi.get(self, "service_attachment_uris")

    @_builtins.property
    @pulumi.getter(name="serviceEndpointId")
    def service_endpoint_id(self) -> _builtins.str:
        """
        For AZURE EVENTHUB, this is the [namespace endpoint ID](https://learn.microsoft.com/en-us/rest/api/eventhub/namespaces/get). For AWS CONFLUENT cluster, this is the [VPC Endpoint service name](https://docs.confluent.io/cloud/current/networking/private-links/aws-privatelink.html).
        """
        return pulumi.get(self, "service_endpoint_id")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        Status of the connection.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def vendor(self) -> _builtins.str:
        """
        Vendor that manages the endpoint. The following are the vendor values per provider:

        	* **AWS**: MSK, CONFLUENT, and S3

        	* **Azure**: EVENTHUB and CONFLUENT

        	* **GCP**: CONFLUENT
        """
        return pulumi.get(self, "vendor")


@pulumi.output_type
class GetStreamProcessorOptionsResult(dict):
    def __init__(__self__, *,
                 dlq: 'outputs.GetStreamProcessorOptionsDlqResult'):
        """
        :param 'GetStreamProcessorOptionsDlqArgs' dlq: Dead letter queue for the stream processor. Refer to the [MongoDB Atlas Docs](https://www.mongodb.com/docs/atlas/reference/glossary/#std-term-dead-letter-queue) for more information.
        """
        pulumi.set(__self__, "dlq", dlq)

    @_builtins.property
    @pulumi.getter
    def dlq(self) -> 'outputs.GetStreamProcessorOptionsDlqResult':
        """
        Dead letter queue for the stream processor. Refer to the [MongoDB Atlas Docs](https://www.mongodb.com/docs/atlas/reference/glossary/#std-term-dead-letter-queue) for more information.
        """
        return pulumi.get(self, "dlq")


@pulumi.output_type
class GetStreamProcessorOptionsDlqResult(dict):
    def __init__(__self__, *,
                 coll: _builtins.str,
                 connection_name: _builtins.str,
                 db: _builtins.str):
        """
        :param _builtins.str coll: Name of the collection to use for the DLQ.
        :param _builtins.str connection_name: Name of the connection to write DLQ messages to. Must be an Atlas connection.
        :param _builtins.str db: Name of the database to use for the DLQ.
        """
        pulumi.set(__self__, "coll", coll)
        pulumi.set(__self__, "connection_name", connection_name)
        pulumi.set(__self__, "db", db)

    @_builtins.property
    @pulumi.getter
    def coll(self) -> _builtins.str:
        """
        Name of the collection to use for the DLQ.
        """
        return pulumi.get(self, "coll")

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> _builtins.str:
        """
        Name of the connection to write DLQ messages to. Must be an Atlas connection.
        """
        return pulumi.get(self, "connection_name")

    @_builtins.property
    @pulumi.getter
    def db(self) -> _builtins.str:
        """
        Name of the database to use for the DLQ.
        """
        return pulumi.get(self, "db")


@pulumi.output_type
class GetStreamProcessorsResultResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 instance_name: _builtins.str,
                 options: 'outputs.GetStreamProcessorsResultOptionsResult',
                 pipeline: _builtins.str,
                 processor_name: _builtins.str,
                 project_id: _builtins.str,
                 state: _builtins.str,
                 stats: _builtins.str,
                 tier: _builtins.str,
                 workspace_name: _builtins.str):
        """
        :param _builtins.str id: Unique 24-hexadecimal character string that identifies the stream processor.
        :param _builtins.str instance_name: Label that identifies the stream processing workspace.
        :param 'GetStreamProcessorsResultOptionsArgs' options: Optional configuration for the stream processor.
        :param _builtins.str pipeline: Stream aggregation pipeline you want to apply to your streaming data. [MongoDB Atlas Docs](https://www.mongodb.com/docs/atlas/atlas-stream-processing/stream-aggregation/#std-label-stream-aggregation) contain more information. Using jsonencode is recommended when setting this attribute. For more details see the [Aggregation Pipelines Documentation](https://www.mongodb.com/docs/atlas/atlas-stream-processing/stream-aggregation/)
        :param _builtins.str processor_name: Label that identifies the stream processor.
        :param _builtins.str project_id: Unique 24-hexadecimal digit string that identifies your project. Use the /groups endpoint to retrieve all projects to which the authenticated user has access.
        :param _builtins.str state: The state of the stream processor. Commonly occurring states are 'CREATED', 'STARTED', 'STOPPED' and 'FAILED'. Used to start or stop the Stream Processor. Valid values are `CREATED`, `STARTED` or `STOPPED`. When a Stream Processor is created without specifying the state, it will default to `CREATED` state. When a Stream Processor is updated without specifying the state, it will default to the Previous state. 
               
               **NOTE** When a Stream Processor is updated without specifying the state, it is stopped and then restored to previous state upon update completion.
        :param _builtins.str stats: The stats associated with the stream processor. Refer to the [MongoDB Atlas Docs](https://www.mongodb.com/docs/atlas/atlas-stream-processing/manage-stream-processor/#view-statistics-of-a-stream-processor) for more information.
        :param _builtins.str tier: Selected tier to start a stream processor on rather than defaulting to the workspace setting. Configures Memory / VCPU allowances. Valid options are SP2, SP5, SP10, SP30, and SP50.
        :param _builtins.str workspace_name: Label that identifies the stream processing workspace.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "instance_name", instance_name)
        pulumi.set(__self__, "options", options)
        pulumi.set(__self__, "pipeline", pipeline)
        pulumi.set(__self__, "processor_name", processor_name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "stats", stats)
        pulumi.set(__self__, "tier", tier)
        pulumi.set(__self__, "workspace_name", workspace_name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal character string that identifies the stream processor.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="instanceName")
    @_utilities.deprecated("""This parameter is deprecated. Please transition to workspace_name.""")
    def instance_name(self) -> _builtins.str:
        """
        Label that identifies the stream processing workspace.
        """
        return pulumi.get(self, "instance_name")

    @_builtins.property
    @pulumi.getter
    def options(self) -> 'outputs.GetStreamProcessorsResultOptionsResult':
        """
        Optional configuration for the stream processor.
        """
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def pipeline(self) -> _builtins.str:
        """
        Stream aggregation pipeline you want to apply to your streaming data. [MongoDB Atlas Docs](https://www.mongodb.com/docs/atlas/atlas-stream-processing/stream-aggregation/#std-label-stream-aggregation) contain more information. Using jsonencode is recommended when setting this attribute. For more details see the [Aggregation Pipelines Documentation](https://www.mongodb.com/docs/atlas/atlas-stream-processing/stream-aggregation/)
        """
        return pulumi.get(self, "pipeline")

    @_builtins.property
    @pulumi.getter(name="processorName")
    def processor_name(self) -> _builtins.str:
        """
        Label that identifies the stream processor.
        """
        return pulumi.get(self, "processor_name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies your project. Use the /groups endpoint to retrieve all projects to which the authenticated user has access.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        The state of the stream processor. Commonly occurring states are 'CREATED', 'STARTED', 'STOPPED' and 'FAILED'. Used to start or stop the Stream Processor. Valid values are `CREATED`, `STARTED` or `STOPPED`. When a Stream Processor is created without specifying the state, it will default to `CREATED` state. When a Stream Processor is updated without specifying the state, it will default to the Previous state. 

        **NOTE** When a Stream Processor is updated without specifying the state, it is stopped and then restored to previous state upon update completion.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def stats(self) -> _builtins.str:
        """
        The stats associated with the stream processor. Refer to the [MongoDB Atlas Docs](https://www.mongodb.com/docs/atlas/atlas-stream-processing/manage-stream-processor/#view-statistics-of-a-stream-processor) for more information.
        """
        return pulumi.get(self, "stats")

    @_builtins.property
    @pulumi.getter
    def tier(self) -> _builtins.str:
        """
        Selected tier to start a stream processor on rather than defaulting to the workspace setting. Configures Memory / VCPU allowances. Valid options are SP2, SP5, SP10, SP30, and SP50.
        """
        return pulumi.get(self, "tier")

    @_builtins.property
    @pulumi.getter(name="workspaceName")
    def workspace_name(self) -> _builtins.str:
        """
        Label that identifies the stream processing workspace.
        """
        return pulumi.get(self, "workspace_name")


@pulumi.output_type
class GetStreamProcessorsResultOptionsResult(dict):
    def __init__(__self__, *,
                 dlq: 'outputs.GetStreamProcessorsResultOptionsDlqResult'):
        """
        :param 'GetStreamProcessorsResultOptionsDlqArgs' dlq: Dead letter queue for the stream processor. Refer to the [MongoDB Atlas Docs](https://www.mongodb.com/docs/atlas/reference/glossary/#std-term-dead-letter-queue) for more information.
        """
        pulumi.set(__self__, "dlq", dlq)

    @_builtins.property
    @pulumi.getter
    def dlq(self) -> 'outputs.GetStreamProcessorsResultOptionsDlqResult':
        """
        Dead letter queue for the stream processor. Refer to the [MongoDB Atlas Docs](https://www.mongodb.com/docs/atlas/reference/glossary/#std-term-dead-letter-queue) for more information.
        """
        return pulumi.get(self, "dlq")


@pulumi.output_type
class GetStreamProcessorsResultOptionsDlqResult(dict):
    def __init__(__self__, *,
                 coll: _builtins.str,
                 connection_name: _builtins.str,
                 db: _builtins.str):
        """
        :param _builtins.str coll: Name of the collection to use for the DLQ.
        :param _builtins.str connection_name: Name of the connection to write DLQ messages to. Must be an Atlas connection.
        :param _builtins.str db: Name of the database to use for the DLQ.
        """
        pulumi.set(__self__, "coll", coll)
        pulumi.set(__self__, "connection_name", connection_name)
        pulumi.set(__self__, "db", db)

    @_builtins.property
    @pulumi.getter
    def coll(self) -> _builtins.str:
        """
        Name of the collection to use for the DLQ.
        """
        return pulumi.get(self, "coll")

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> _builtins.str:
        """
        Name of the connection to write DLQ messages to. Must be an Atlas connection.
        """
        return pulumi.get(self, "connection_name")

    @_builtins.property
    @pulumi.getter
    def db(self) -> _builtins.str:
        """
        Name of the database to use for the DLQ.
        """
        return pulumi.get(self, "db")


@pulumi.output_type
class GetStreamWorkspaceDataProcessRegionResult(dict):
    def __init__(__self__, *,
                 cloud_provider: _builtins.str,
                 region: _builtins.str):
        """
        :param _builtins.str cloud_provider: Label that identifies the cloud service provider where MongoDB Cloud performs stream processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/creategroupstreamworkspace) describes the valid values.
        :param _builtins.str region: Name of the cloud provider region hosting Atlas Stream Processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/creategroupstreamworkspace) describes the valid values.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> _builtins.str:
        """
        Label that identifies the cloud service provider where MongoDB Cloud performs stream processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/creategroupstreamworkspace) describes the valid values.
        """
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Name of the cloud provider region hosting Atlas Stream Processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/creategroupstreamworkspace) describes the valid values.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetStreamWorkspaceStreamConfigResult(dict):
    def __init__(__self__, *,
                 max_tier_size: _builtins.str,
                 tier: _builtins.str):
        """
        :param _builtins.str tier: Selected tier for the Stream Instance. Configures Memory / VCPU allowances. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/creategroupstreamworkspace) describes the valid values.
        """
        pulumi.set(__self__, "max_tier_size", max_tier_size)
        pulumi.set(__self__, "tier", tier)

    @_builtins.property
    @pulumi.getter(name="maxTierSize")
    def max_tier_size(self) -> _builtins.str:
        return pulumi.get(self, "max_tier_size")

    @_builtins.property
    @pulumi.getter
    def tier(self) -> _builtins.str:
        """
        Selected tier for the Stream Instance. Configures Memory / VCPU allowances. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/creategroupstreamworkspace) describes the valid values.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class GetStreamWorkspacesResultResult(dict):
    def __init__(__self__, *,
                 data_process_region: 'outputs.GetStreamWorkspacesResultDataProcessRegionResult',
                 hostnames: Sequence[_builtins.str],
                 id: _builtins.str,
                 project_id: _builtins.str,
                 stream_config: 'outputs.GetStreamWorkspacesResultStreamConfigResult',
                 workspace_name: _builtins.str):
        """
        :param 'GetStreamWorkspacesResultDataProcessRegionArgs' data_process_region: Defines the cloud service provider and region where MongoDB Cloud performs stream processing. See data process region.
        :param Sequence[_builtins.str] hostnames: List that contains the hostnames assigned to the stream workspace.
        :param _builtins.str project_id: Unique 24-hexadecimal digit string that identifies your project.
        :param 'GetStreamWorkspacesResultStreamConfigArgs' stream_config: Defines the configuration options for an Atlas Stream Processing Instance. See stream config
        :param _builtins.str workspace_name: Label that identifies the stream workspace.
        """
        pulumi.set(__self__, "data_process_region", data_process_region)
        pulumi.set(__self__, "hostnames", hostnames)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "stream_config", stream_config)
        pulumi.set(__self__, "workspace_name", workspace_name)

    @_builtins.property
    @pulumi.getter(name="dataProcessRegion")
    def data_process_region(self) -> 'outputs.GetStreamWorkspacesResultDataProcessRegionResult':
        """
        Defines the cloud service provider and region where MongoDB Cloud performs stream processing. See data process region.
        """
        return pulumi.get(self, "data_process_region")

    @_builtins.property
    @pulumi.getter
    def hostnames(self) -> Sequence[_builtins.str]:
        """
        List that contains the hostnames assigned to the stream workspace.
        """
        return pulumi.get(self, "hostnames")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies your project.
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="streamConfig")
    def stream_config(self) -> 'outputs.GetStreamWorkspacesResultStreamConfigResult':
        """
        Defines the configuration options for an Atlas Stream Processing Instance. See stream config
        """
        return pulumi.get(self, "stream_config")

    @_builtins.property
    @pulumi.getter(name="workspaceName")
    def workspace_name(self) -> _builtins.str:
        """
        Label that identifies the stream workspace.
        """
        return pulumi.get(self, "workspace_name")


@pulumi.output_type
class GetStreamWorkspacesResultDataProcessRegionResult(dict):
    def __init__(__self__, *,
                 cloud_provider: _builtins.str,
                 region: _builtins.str):
        """
        :param _builtins.str cloud_provider: Label that identifies the cloud service provider where MongoDB Cloud performs stream processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/creategroupstreamworkspace) describes the valid values.
        :param _builtins.str region: Name of the cloud provider region hosting Atlas Stream Processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/creategroupstreamworkspace) describes the valid values.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> _builtins.str:
        """
        Label that identifies the cloud service provider where MongoDB Cloud performs stream processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/creategroupstreamworkspace) describes the valid values.
        """
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Name of the cloud provider region hosting Atlas Stream Processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/creategroupstreamworkspace) describes the valid values.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetStreamWorkspacesResultStreamConfigResult(dict):
    def __init__(__self__, *,
                 max_tier_size: _builtins.str,
                 tier: _builtins.str):
        """
        :param _builtins.str tier: Selected tier for the Stream Workspace. Configures Memory / VCPU allowances. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/creategroupstreamworkspace) describes the valid values.
        """
        pulumi.set(__self__, "max_tier_size", max_tier_size)
        pulumi.set(__self__, "tier", tier)

    @_builtins.property
    @pulumi.getter(name="maxTierSize")
    def max_tier_size(self) -> _builtins.str:
        return pulumi.get(self, "max_tier_size")

    @_builtins.property
    @pulumi.getter
    def tier(self) -> _builtins.str:
        """
        Selected tier for the Stream Workspace. Configures Memory / VCPU allowances. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/creategroupstreamworkspace) describes the valid values.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class GetTeamUserResult(dict):
    def __init__(__self__, *,
                 country: _builtins.str,
                 created_at: _builtins.str,
                 first_name: _builtins.str,
                 id: _builtins.str,
                 invitation_created_at: _builtins.str,
                 invitation_expires_at: _builtins.str,
                 inviter_username: _builtins.str,
                 last_auth: _builtins.str,
                 last_name: _builtins.str,
                 mobile_number: _builtins.str,
                 org_membership_status: _builtins.str,
                 roles: Sequence['outputs.GetTeamUserRoleResult'],
                 team_ids: Sequence[_builtins.str],
                 username: _builtins.str):
        """
        :param _builtins.str country: Two-character alphabetical string that identifies the MongoDB Cloud user's geographic location. This parameter uses the ISO 3166-1a2 code format.
        :param _builtins.str created_at: Date and time when MongoDB Cloud created the current account. This value is in the ISO 8601 timestamp format in UTC.
        :param _builtins.str first_name: First or given name that belongs to the MongoDB Cloud user.
        :param _builtins.str id: Unique 24-hexadecimal digit string that identifies the MongoDB Cloud user.
        :param _builtins.str invitation_created_at: Date and time when MongoDB Cloud sent the invitation. MongoDB Cloud represents this timestamp in ISO 8601 format in UTC.
        :param _builtins.str invitation_expires_at: Date and time when the invitation from MongoDB Cloud expires. MongoDB Cloud represents this timestamp in ISO 8601 format in UTC.
        :param _builtins.str inviter_username: Username of the MongoDB Cloud user who sent the invitation to join the organization.
        :param _builtins.str last_auth: Date and time when the current account last authenticated. This value is in the ISO 8601 timestamp format in UTC.
        :param _builtins.str last_name: Last name, family name, or surname that belongs to the MongoDB Cloud user.
        :param _builtins.str mobile_number: Mobile phone number that belongs to the MongoDB Cloud user.
        :param _builtins.str org_membership_status: String enum that indicates whether the MongoDB Cloud user has a pending invitation to join the organization or are already active in the organization.
        :param Sequence['GetTeamUserRoleArgs'] roles: Organization and project-level roles assigned to one MongoDB Cloud user within one organization.
        :param Sequence[_builtins.str] team_ids: List of unique 24-hexadecimal digit strings that identifies the teams to which this MongoDB Cloud user belongs.
        :param _builtins.str username: Email address that represents the username of the MongoDB Cloud user.
        """
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "invitation_created_at", invitation_created_at)
        pulumi.set(__self__, "invitation_expires_at", invitation_expires_at)
        pulumi.set(__self__, "inviter_username", inviter_username)
        pulumi.set(__self__, "last_auth", last_auth)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "mobile_number", mobile_number)
        pulumi.set(__self__, "org_membership_status", org_membership_status)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "team_ids", team_ids)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def country(self) -> _builtins.str:
        """
        Two-character alphabetical string that identifies the MongoDB Cloud user's geographic location. This parameter uses the ISO 3166-1a2 code format.
        """
        return pulumi.get(self, "country")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Date and time when MongoDB Cloud created the current account. This value is in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> _builtins.str:
        """
        First or given name that belongs to the MongoDB Cloud user.
        """
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique 24-hexadecimal digit string that identifies the MongoDB Cloud user.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="invitationCreatedAt")
    def invitation_created_at(self) -> _builtins.str:
        """
        Date and time when MongoDB Cloud sent the invitation. MongoDB Cloud represents this timestamp in ISO 8601 format in UTC.
        """
        return pulumi.get(self, "invitation_created_at")

    @_builtins.property
    @pulumi.getter(name="invitationExpiresAt")
    def invitation_expires_at(self) -> _builtins.str:
        """
        Date and time when the invitation from MongoDB Cloud expires. MongoDB Cloud represents this timestamp in ISO 8601 format in UTC.
        """
        return pulumi.get(self, "invitation_expires_at")

    @_builtins.property
    @pulumi.getter(name="inviterUsername")
    def inviter_username(self) -> _builtins.str:
        """
        Username of the MongoDB Cloud user who sent the invitation to join the organization.
        """
        return pulumi.get(self, "inviter_username")

    @_builtins.property
    @pulumi.getter(name="lastAuth")
    def last_auth(self) -> _builtins.str:
        """
        Date and time when the current account last authenticated. This value is in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "last_auth")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> _builtins.str:
        """
        Last name, family name, or surname that belongs to the MongoDB Cloud user.
        """
        return pulumi.get(self, "last_name")

    @_builtins.property
    @pulumi.getter(name="mobileNumber")
    def mobile_number(self) -> _builtins.str:
        """
        Mobile phone number that belongs to the MongoDB Cloud user.
        """
        return pulumi.get(self, "mobile_number")

    @_builtins.property
    @pulumi.getter(name="orgMembershipStatus")
    def org_membership_status(self) -> _builtins.str:
        """
        String enum that indicates whether the MongoDB Cloud user has a pending invitation to join the organization or are already active in the organization.
        """
        return pulumi.get(self, "org_membership_status")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Sequence['outputs.GetTeamUserRoleResult']:
        """
        Organization and project-level roles assigned to one MongoDB Cloud user within one organization.
        """
        return pulumi.get(self, "roles")

    @_builtins.property
    @pulumi.getter(name="teamIds")
    def team_ids(self) -> Sequence[_builtins.str]:
        """
        List of unique 24-hexadecimal digit strings that identifies the teams to which this MongoDB Cloud user belongs.
        """
        return pulumi.get(self, "team_ids")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Email address that represents the username of the MongoDB Cloud user.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetTeamUserRoleResult(dict):
    def __init__(__self__, *,
                 org_roles: Sequence[_builtins.str],
                 project_role_assignments: Sequence['outputs.GetTeamUserRoleProjectRoleAssignmentResult']):
        pulumi.set(__self__, "org_roles", org_roles)
        pulumi.set(__self__, "project_role_assignments", project_role_assignments)

    @_builtins.property
    @pulumi.getter(name="orgRoles")
    def org_roles(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "org_roles")

    @_builtins.property
    @pulumi.getter(name="projectRoleAssignments")
    def project_role_assignments(self) -> Sequence['outputs.GetTeamUserRoleProjectRoleAssignmentResult']:
        return pulumi.get(self, "project_role_assignments")


@pulumi.output_type
class GetTeamUserRoleProjectRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 project_id: _builtins.str,
                 project_roles: Sequence[_builtins.str]):
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "project_roles", project_roles)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="projectRoles")
    def project_roles(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "project_roles")


@pulumi.output_type
class GetThirdPartyIntegrationsResultResult(dict):
    def __init__(__self__, *,
                 account_id: _builtins.str,
                 api_key: _builtins.str,
                 channel_name: _builtins.str,
                 enabled: _builtins.bool,
                 id: _builtins.str,
                 microsoft_teams_webhook_url: _builtins.str,
                 project_id: _builtins.str,
                 region: _builtins.str,
                 routing_key: _builtins.str,
                 secret: _builtins.str,
                 send_collection_latency_metrics: _builtins.bool,
                 send_database_metrics: _builtins.bool,
                 send_user_provided_resource_tags: _builtins.bool,
                 service_discovery: _builtins.str,
                 service_key: _builtins.str,
                 team_name: _builtins.str,
                 type: _builtins.str,
                 url: _builtins.str,
                 user_name: _builtins.str):
        """
        :param _builtins.str api_key: Your API Key.
        :param _builtins.bool enabled: Whether your cluster has Prometheus enabled.
        :param _builtins.str id: Unique identifier of the integration.
        :param _builtins.str microsoft_teams_webhook_url: Your Microsoft Teams incoming webhook URL.
               * `PROMETHEUS`
        :param _builtins.str project_id: The unique ID for the project to get all Third-Party service integrations
        :param _builtins.str region: Two-letter code that indicates which API URL to use. See the `region` response field of [MongoDB API Third-Party Service Integration documentation](https://www.mongodb.com/docs/api/doc/atlas-admin-api-v2/operation/operation-getthirdpartyintegration) for more details. Opsgenie will use US by default.
               * `VICTOR_OPS`
        :param _builtins.str routing_key: An optional field for your Routing Key.
               * `WEBHOOK`
        :param _builtins.str secret: An optional field for your webhook secret.
               * `MICROSOFT_TEAMS`
        :param _builtins.bool send_collection_latency_metrics: Toggle sending collection latency metrics that includes database names and collection names and latency metrics on reads, writes, commands, and transactions.
        :param _builtins.bool send_database_metrics: Toggle sending database metrics that includes database names and metrics on the number of collections, storage size, and index size.
        :param _builtins.bool send_user_provided_resource_tags: Toggle sending user provided group and cluster resource tags with the datadog metrics.
               * `OPS_GENIE`
        :param _builtins.str service_discovery: Indicates which service discovery method is used, either file or http.
        :param _builtins.str service_key: Your Service Key.
               * `DATADOG`
        :param _builtins.str type: Thirt-Party service integration type.
        :param _builtins.str url: Your webhook URL.
        :param _builtins.str user_name: Your Prometheus username.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "channel_name", channel_name)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "microsoft_teams_webhook_url", microsoft_teams_webhook_url)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "routing_key", routing_key)
        pulumi.set(__self__, "secret", secret)
        pulumi.set(__self__, "send_collection_latency_metrics", send_collection_latency_metrics)
        pulumi.set(__self__, "send_database_metrics", send_database_metrics)
        pulumi.set(__self__, "send_user_provided_resource_tags", send_user_provided_resource_tags)
        pulumi.set(__self__, "service_discovery", service_discovery)
        pulumi.set(__self__, "service_key", service_key)
        pulumi.set(__self__, "team_name", team_name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "user_name", user_name)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> _builtins.str:
        return pulumi.get(self, "account_id")

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        Your API Key.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> _builtins.str:
        return pulumi.get(self, "channel_name")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Whether your cluster has Prometheus enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique identifier of the integration.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="microsoftTeamsWebhookUrl")
    def microsoft_teams_webhook_url(self) -> _builtins.str:
        """
        Your Microsoft Teams incoming webhook URL.
        * `PROMETHEUS`
        """
        return pulumi.get(self, "microsoft_teams_webhook_url")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The unique ID for the project to get all Third-Party service integrations
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Two-letter code that indicates which API URL to use. See the `region` response field of [MongoDB API Third-Party Service Integration documentation](https://www.mongodb.com/docs/api/doc/atlas-admin-api-v2/operation/operation-getthirdpartyintegration) for more details. Opsgenie will use US by default.
        * `VICTOR_OPS`
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="routingKey")
    def routing_key(self) -> _builtins.str:
        """
        An optional field for your Routing Key.
        * `WEBHOOK`
        """
        return pulumi.get(self, "routing_key")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> _builtins.str:
        """
        An optional field for your webhook secret.
        * `MICROSOFT_TEAMS`
        """
        return pulumi.get(self, "secret")

    @_builtins.property
    @pulumi.getter(name="sendCollectionLatencyMetrics")
    def send_collection_latency_metrics(self) -> _builtins.bool:
        """
        Toggle sending collection latency metrics that includes database names and collection names and latency metrics on reads, writes, commands, and transactions.
        """
        return pulumi.get(self, "send_collection_latency_metrics")

    @_builtins.property
    @pulumi.getter(name="sendDatabaseMetrics")
    def send_database_metrics(self) -> _builtins.bool:
        """
        Toggle sending database metrics that includes database names and metrics on the number of collections, storage size, and index size.
        """
        return pulumi.get(self, "send_database_metrics")

    @_builtins.property
    @pulumi.getter(name="sendUserProvidedResourceTags")
    def send_user_provided_resource_tags(self) -> _builtins.bool:
        """
        Toggle sending user provided group and cluster resource tags with the datadog metrics.
        * `OPS_GENIE`
        """
        return pulumi.get(self, "send_user_provided_resource_tags")

    @_builtins.property
    @pulumi.getter(name="serviceDiscovery")
    def service_discovery(self) -> _builtins.str:
        """
        Indicates which service discovery method is used, either file or http.
        """
        return pulumi.get(self, "service_discovery")

    @_builtins.property
    @pulumi.getter(name="serviceKey")
    def service_key(self) -> _builtins.str:
        """
        Your Service Key.
        * `DATADOG`
        """
        return pulumi.get(self, "service_key")

    @_builtins.property
    @pulumi.getter(name="teamName")
    def team_name(self) -> _builtins.str:
        return pulumi.get(self, "team_name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Thirt-Party service integration type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Your webhook URL.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="userName")
    def user_name(self) -> _builtins.str:
        """
        Your Prometheus username.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetX509AuthenticationDatabaseUserCertificateResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 group_id: _builtins.str,
                 id: _builtins.int,
                 not_after: _builtins.str,
                 subject: _builtins.str):
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "not_after", not_after)
        pulumi.set(__self__, "subject", subject)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.str:
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> _builtins.str:
        return pulumi.get(self, "not_after")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> _builtins.str:
        return pulumi.get(self, "subject")


