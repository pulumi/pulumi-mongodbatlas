# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'AdvancedClusterAdvancedConfiguration',
    'AdvancedClusterBiConnectorConfig',
    'AdvancedClusterConnectionString',
    'AdvancedClusterConnectionStringPrivateEndpoint',
    'AdvancedClusterConnectionStringPrivateEndpointEndpoint',
    'AdvancedClusterLabel',
    'AdvancedClusterReplicationSpec',
    'AdvancedClusterReplicationSpecRegionConfig',
    'AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling',
    'AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs',
    'AdvancedClusterReplicationSpecRegionConfigAutoScaling',
    'AdvancedClusterReplicationSpecRegionConfigElectableSpecs',
    'AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs',
    'AdvancedClusterTag',
    'AlertConfigurationMatcher',
    'AlertConfigurationMetricThresholdConfig',
    'AlertConfigurationNotification',
    'AlertConfigurationThresholdConfig',
    'BackupCompliancePolicyOnDemandPolicyItem',
    'BackupCompliancePolicyPolicyItemDaily',
    'BackupCompliancePolicyPolicyItemHourly',
    'BackupCompliancePolicyPolicyItemMonthly',
    'BackupCompliancePolicyPolicyItemWeekly',
    'BackupCompliancePolicyPolicyItemYearly',
    'CloudBackupScheduleCopySetting',
    'CloudBackupScheduleExport',
    'CloudBackupSchedulePolicyItemDaily',
    'CloudBackupSchedulePolicyItemHourly',
    'CloudBackupSchedulePolicyItemMonthly',
    'CloudBackupSchedulePolicyItemWeekly',
    'CloudBackupSchedulePolicyItemYearly',
    'CloudBackupSnapshotExportJobComponent',
    'CloudBackupSnapshotExportJobCustomData',
    'CloudBackupSnapshotMember',
    'CloudBackupSnapshotRestoreJobDeliveryTypeConfig',
    'CloudProviderAccessAuthorizationAws',
    'CloudProviderAccessAuthorizationAzure',
    'CloudProviderAccessAuthorizationFeatureUsage',
    'CloudProviderAccessSetupAwsConfig',
    'CloudProviderAccessSetupAzureConfig',
    'ClusterAdvancedConfiguration',
    'ClusterBiConnectorConfig',
    'ClusterConnectionString',
    'ClusterConnectionStringPrivateEndpoint',
    'ClusterConnectionStringPrivateEndpointEndpoint',
    'ClusterLabel',
    'ClusterOutageSimulationOutageFilter',
    'ClusterReplicationSpec',
    'ClusterReplicationSpecRegionsConfig',
    'ClusterSnapshotBackupPolicy',
    'ClusterSnapshotBackupPolicyPolicy',
    'ClusterSnapshotBackupPolicyPolicyPolicyItem',
    'ClusterTag',
    'CustomDbRoleAction',
    'CustomDbRoleActionResource',
    'CustomDbRoleInheritedRole',
    'DataLakePipelineIngestionSchedule',
    'DataLakePipelineSink',
    'DataLakePipelineSinkPartitionField',
    'DataLakePipelineSnapshot',
    'DataLakePipelineSource',
    'DataLakePipelineTransformation',
    'DatabaseUserLabel',
    'DatabaseUserRole',
    'DatabaseUserScope',
    'EncryptionAtRestAwsKmsConfig',
    'EncryptionAtRestAzureKeyVaultConfig',
    'EncryptionAtRestGoogleCloudKmsConfig',
    'EventTriggerEventProcessors',
    'EventTriggerEventProcessorsAwsEventbridge',
    'FederatedDatabaseInstanceCloudProviderConfig',
    'FederatedDatabaseInstanceCloudProviderConfigAws',
    'FederatedDatabaseInstanceDataProcessRegion',
    'FederatedDatabaseInstanceStorageDatabase',
    'FederatedDatabaseInstanceStorageDatabaseCollection',
    'FederatedDatabaseInstanceStorageDatabaseCollectionDataSource',
    'FederatedDatabaseInstanceStorageDatabaseView',
    'FederatedDatabaseInstanceStorageStore',
    'FederatedDatabaseInstanceStorageStoreReadPreference',
    'FederatedDatabaseInstanceStorageStoreReadPreferenceTagSet',
    'FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTag',
    'FederatedSettingsOrgConfigUserConflict',
    'FederatedSettingsOrgRoleMappingRoleAssignment',
    'GlobalClusterConfigCustomZoneMapping',
    'GlobalClusterConfigManagedNamespace',
    'LdapConfigurationUserToDnMapping',
    'LdapVerifyLink',
    'LdapVerifyValidation',
    'OnlineArchiveCriteria',
    'OnlineArchiveDataExpirationRule',
    'OnlineArchiveDataProcessRegion',
    'OnlineArchivePartitionField',
    'OnlineArchiveSchedule',
    'PrivateLinkEndpointServiceEndpoint',
    'ProjectApiKeyProjectAssignment',
    'ProjectIpAccessListTimeouts',
    'ProjectIpAddresses',
    'ProjectIpAddressesServices',
    'ProjectIpAddressesServicesCluster',
    'ProjectLimit',
    'ProjectTeam',
    'PushBasedLogExportTimeouts',
    'SearchDeploymentSpec',
    'SearchDeploymentTimeouts',
    'SearchIndexSynonym',
    'ServerlessInstanceLink',
    'ServerlessInstanceTag',
    'StreamConnectionAuthentication',
    'StreamConnectionDbRoleToExecute',
    'StreamConnectionSecurity',
    'StreamInstanceDataProcessRegion',
    'StreamInstanceStreamConfig',
    'StreamProcessorOptions',
    'StreamProcessorOptionsDlq',
    'X509AuthenticationDatabaseUserCertificate',
    'Get509AuthenticationDatabaseUserCertificateResult',
    'GetAccessListApiKeysResultResult',
    'GetAdvancedClusterAdvancedConfigurationResult',
    'GetAdvancedClusterBiConnectorConfigResult',
    'GetAdvancedClusterConnectionStringResult',
    'GetAdvancedClusterConnectionStringPrivateEndpointResult',
    'GetAdvancedClusterConnectionStringPrivateEndpointEndpointResult',
    'GetAdvancedClusterLabelResult',
    'GetAdvancedClusterReplicationSpecResult',
    'GetAdvancedClusterReplicationSpecRegionConfigResult',
    'GetAdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingResult',
    'GetAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsResult',
    'GetAdvancedClusterReplicationSpecRegionConfigAutoScalingResult',
    'GetAdvancedClusterReplicationSpecRegionConfigElectableSpecsResult',
    'GetAdvancedClusterReplicationSpecRegionConfigReadOnlySpecsResult',
    'GetAdvancedClusterTagResult',
    'GetAdvancedClustersResultResult',
    'GetAdvancedClustersResultAdvancedConfigurationResult',
    'GetAdvancedClustersResultBiConnectorConfigResult',
    'GetAdvancedClustersResultConnectionStringResult',
    'GetAdvancedClustersResultConnectionStringPrivateEndpointResult',
    'GetAdvancedClustersResultConnectionStringPrivateEndpointEndpointResult',
    'GetAdvancedClustersResultLabelResult',
    'GetAdvancedClustersResultReplicationSpecResult',
    'GetAdvancedClustersResultReplicationSpecRegionConfigResult',
    'GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsAutoScalingResult',
    'GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecsResult',
    'GetAdvancedClustersResultReplicationSpecRegionConfigAutoScalingResult',
    'GetAdvancedClustersResultReplicationSpecRegionConfigElectableSpecsResult',
    'GetAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecsResult',
    'GetAdvancedClustersResultTagResult',
    'GetAlertConfigurationMatcherResult',
    'GetAlertConfigurationMetricThresholdConfigResult',
    'GetAlertConfigurationNotificationResult',
    'GetAlertConfigurationOutputResult',
    'GetAlertConfigurationThresholdConfigResult',
    'GetAlertConfigurationsListOptionResult',
    'GetAlertConfigurationsResultResult',
    'GetAlertConfigurationsResultMatcherResult',
    'GetAlertConfigurationsResultMetricThresholdConfigResult',
    'GetAlertConfigurationsResultNotificationResult',
    'GetAlertConfigurationsResultOutputResult',
    'GetAlertConfigurationsResultThresholdConfigResult',
    'GetApiKeysResultResult',
    'GetAtlasUserLinkResult',
    'GetAtlasUserRoleResult',
    'GetAtlasUsersResultResult',
    'GetAtlasUsersResultLinkResult',
    'GetAtlasUsersResultRoleResult',
    'GetBackupCompliancePolicyOnDemandPolicyItemResult',
    'GetBackupCompliancePolicyPolicyItemDailyResult',
    'GetBackupCompliancePolicyPolicyItemHourlyResult',
    'GetBackupCompliancePolicyPolicyItemMonthlyResult',
    'GetBackupCompliancePolicyPolicyItemWeeklyResult',
    'GetBackupCompliancePolicyPolicyItemYearlyResult',
    'GetCloudBackupScheduleCopySettingResult',
    'GetCloudBackupScheduleExportResult',
    'GetCloudBackupSchedulePolicyItemDailyResult',
    'GetCloudBackupSchedulePolicyItemHourlyResult',
    'GetCloudBackupSchedulePolicyItemMonthlyResult',
    'GetCloudBackupSchedulePolicyItemWeeklyResult',
    'GetCloudBackupSchedulePolicyItemYearlyResult',
    'GetCloudBackupSnapshotExportBucketsResultResult',
    'GetCloudBackupSnapshotExportJobComponentResult',
    'GetCloudBackupSnapshotExportJobCustomDataResult',
    'GetCloudBackupSnapshotExportJobsResultResult',
    'GetCloudBackupSnapshotExportJobsResultComponentResult',
    'GetCloudBackupSnapshotExportJobsResultCustomDataResult',
    'GetCloudBackupSnapshotMemberResult',
    'GetCloudBackupSnapshotRestoreJobsResultResult',
    'GetCloudBackupSnapshotsResultResult',
    'GetCloudBackupSnapshotsResultMemberResult',
    'GetCloudProviderAccessSetupAwsConfigResult',
    'GetCloudProviderAccessSetupAzureConfigResult',
    'GetClusterAdvancedConfigurationResult',
    'GetClusterBiConnectorConfigResult',
    'GetClusterConnectionStringResult',
    'GetClusterConnectionStringPrivateEndpointResult',
    'GetClusterConnectionStringPrivateEndpointEndpointResult',
    'GetClusterLabelResult',
    'GetClusterOutageSimulationOutageFilterResult',
    'GetClusterReplicationSpecResult',
    'GetClusterReplicationSpecRegionsConfigResult',
    'GetClusterSnapshotBackupPolicyResult',
    'GetClusterSnapshotBackupPolicyPolicyResult',
    'GetClusterSnapshotBackupPolicyPolicyPolicyItemResult',
    'GetClusterTagResult',
    'GetClustersResultResult',
    'GetClustersResultAdvancedConfigurationResult',
    'GetClustersResultBiConnectorConfigResult',
    'GetClustersResultConnectionStringResult',
    'GetClustersResultConnectionStringPrivateEndpointResult',
    'GetClustersResultConnectionStringPrivateEndpointEndpointResult',
    'GetClustersResultLabelResult',
    'GetClustersResultReplicationSpecResult',
    'GetClustersResultReplicationSpecRegionsConfigResult',
    'GetClustersResultSnapshotBackupPolicyResult',
    'GetClustersResultSnapshotBackupPolicyPolicyResult',
    'GetClustersResultSnapshotBackupPolicyPolicyPolicyItemResult',
    'GetClustersResultTagResult',
    'GetControlPlaneIpAddressesInboundResult',
    'GetControlPlaneIpAddressesOutboundResult',
    'GetCustomDbRoleActionResult',
    'GetCustomDbRoleActionResourceResult',
    'GetCustomDbRoleInheritedRoleResult',
    'GetCustomDbRolesResultResult',
    'GetCustomDbRolesResultActionResult',
    'GetCustomDbRolesResultActionResourceResult',
    'GetCustomDbRolesResultInheritedRoleResult',
    'GetDataLakePipelineIngestionScheduleResult',
    'GetDataLakePipelineRunStatResult',
    'GetDataLakePipelineRunsResultResult',
    'GetDataLakePipelineRunsResultStatResult',
    'GetDataLakePipelineSinkResult',
    'GetDataLakePipelineSinkPartitionFieldResult',
    'GetDataLakePipelineSnapshotResult',
    'GetDataLakePipelineSourceResult',
    'GetDataLakePipelineTransformationResult',
    'GetDataLakePipelinesResultResult',
    'GetDataLakePipelinesResultSinkResult',
    'GetDataLakePipelinesResultSinkPartitionFieldResult',
    'GetDataLakePipelinesResultSourceResult',
    'GetDataLakePipelinesResultTransformationResult',
    'GetDatabaseUserLabelResult',
    'GetDatabaseUserRoleResult',
    'GetDatabaseUserScopeResult',
    'GetDatabaseUsersResultResult',
    'GetDatabaseUsersResultLabelResult',
    'GetDatabaseUsersResultRoleResult',
    'GetDatabaseUsersResultScopeResult',
    'GetEncryptionAtRestAwsKmsConfigResult',
    'GetEncryptionAtRestAzureKeyVaultConfigResult',
    'GetEncryptionAtRestGoogleCloudKmsConfigResult',
    'GetEncryptionAtRestPrivateEndpointsResultResult',
    'GetEventTriggerEventProcessorResult',
    'GetEventTriggerEventProcessorAwsEventbridgeResult',
    'GetEventTriggersResultResult',
    'GetEventTriggersResultEventProcessorResult',
    'GetEventTriggersResultEventProcessorAwsEventbridgeResult',
    'GetFederatedDatabaseInstanceCloudProviderConfigResult',
    'GetFederatedDatabaseInstanceCloudProviderConfigAwsResult',
    'GetFederatedDatabaseInstanceDataProcessRegionResult',
    'GetFederatedDatabaseInstanceStorageDatabaseResult',
    'GetFederatedDatabaseInstanceStorageDatabaseCollectionResult',
    'GetFederatedDatabaseInstanceStorageDatabaseCollectionDataSourceResult',
    'GetFederatedDatabaseInstanceStorageDatabaseViewResult',
    'GetFederatedDatabaseInstanceStorageStoreResult',
    'GetFederatedDatabaseInstanceStorageStoreReadPreferenceResult',
    'GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetResult',
    'GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTagResult',
    'GetFederatedDatabaseInstancesResultResult',
    'GetFederatedDatabaseInstancesResultCloudProviderConfigResult',
    'GetFederatedDatabaseInstancesResultCloudProviderConfigAwsResult',
    'GetFederatedDatabaseInstancesResultDataProcessRegionResult',
    'GetFederatedDatabaseInstancesResultStorageDatabaseResult',
    'GetFederatedDatabaseInstancesResultStorageDatabaseCollectionResult',
    'GetFederatedDatabaseInstancesResultStorageDatabaseCollectionDataSourceResult',
    'GetFederatedDatabaseInstancesResultStorageDatabaseViewResult',
    'GetFederatedDatabaseInstancesResultStorageStoreResult',
    'GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceResult',
    'GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetResult',
    'GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetTagResult',
    'GetFederatedQueryLimitsResultResult',
    'GetFederatedSettingsIdentityProviderAssociatedOrgResult',
    'GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingResult',
    'GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignmentResult',
    'GetFederatedSettingsIdentityProviderAssociatedOrgUserConflictResult',
    'GetFederatedSettingsIdentityProviderPemFileInfoResult',
    'GetFederatedSettingsIdentityProviderPemFileInfoCertificateResult',
    'GetFederatedSettingsIdentityProvidersResultResult',
    'GetFederatedSettingsIdentityProvidersResultAssociatedOrgResult',
    'GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingResult',
    'GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignmentResult',
    'GetFederatedSettingsIdentityProvidersResultAssociatedOrgUserConflictResult',
    'GetFederatedSettingsIdentityProvidersResultPemFileInfoResult',
    'GetFederatedSettingsIdentityProvidersResultPemFileInfoCertificateResult',
    'GetFederatedSettingsOrgConfigRoleMappingResult',
    'GetFederatedSettingsOrgConfigRoleMappingRoleAssignmentResult',
    'GetFederatedSettingsOrgConfigUserConflictResult',
    'GetFederatedSettingsOrgConfigsResultResult',
    'GetFederatedSettingsOrgConfigsResultRoleMappingResult',
    'GetFederatedSettingsOrgConfigsResultRoleMappingRoleAssignmentResult',
    'GetFederatedSettingsOrgConfigsResultUserConflictResult',
    'GetFederatedSettingsOrgRoleMappingRoleAssignmentResult',
    'GetFederatedSettingsOrgRoleMappingsResultResult',
    'GetFederatedSettingsOrgRoleMappingsResultRoleAssignmentResult',
    'GetGlobalClusterConfigManagedNamespaceResult',
    'GetLdapConfigurationUserToDnMappingResult',
    'GetLdapVerifyLinkResult',
    'GetLdapVerifyValidationResult',
    'GetNetworkContainersResultResult',
    'GetNetworkPeeringsResultResult',
    'GetOnlineArchiveCriteriaResult',
    'GetOnlineArchiveDataExpirationRuleResult',
    'GetOnlineArchiveDataProcessRegionResult',
    'GetOnlineArchivePartitionFieldResult',
    'GetOnlineArchiveScheduleResult',
    'GetOnlineArchivesResultResult',
    'GetOnlineArchivesResultCriteriaResult',
    'GetOnlineArchivesResultDataExpirationRuleResult',
    'GetOnlineArchivesResultDataProcessRegionResult',
    'GetOnlineArchivesResultPartitionFieldResult',
    'GetOnlineArchivesResultScheduleResult',
    'GetOrganizationLinkResult',
    'GetOrganizationsResultResult',
    'GetOrganizationsResultLinkResult',
    'GetPrivateLinkEndpointServiceEndpointResult',
    'GetPrivatelinkEndpointServiceDataFederationOnlineArchivesResultResult',
    'GetPrivatelinkEndpointsServiceServerlessResultResult',
    'GetProjectApiKeyProjectAssignmentResult',
    'GetProjectApiKeysResultResult',
    'GetProjectApiKeysResultProjectAssignmentResult',
    'GetProjectIpAddressesResult',
    'GetProjectIpAddressesServicesResult',
    'GetProjectIpAddressesServicesClusterResult',
    'GetProjectLimitResult',
    'GetProjectTeamResult',
    'GetProjectsResultResult',
    'GetProjectsResultIpAddressesResult',
    'GetProjectsResultIpAddressesServicesResult',
    'GetProjectsResultIpAddressesServicesClusterResult',
    'GetProjectsResultLimitResult',
    'GetProjectsResultTeamResult',
    'GetSearchDeploymentSpecResult',
    'GetSearchIndexSynonymResult',
    'GetSearchIndexesResultResult',
    'GetSearchIndexesResultSynonymResult',
    'GetServerlessInstanceLinkResult',
    'GetServerlessInstanceTagResult',
    'GetServerlessInstancesResultResult',
    'GetServerlessInstancesResultLinkResult',
    'GetServerlessInstancesResultTagResult',
    'GetSharedTierRestoreJobsResultResult',
    'GetSharedTierSnapshotsResultResult',
    'GetStreamConnectionAuthenticationResult',
    'GetStreamConnectionDbRoleToExecuteResult',
    'GetStreamConnectionSecurityResult',
    'GetStreamConnectionsResultResult',
    'GetStreamConnectionsResultAuthenticationResult',
    'GetStreamConnectionsResultDbRoleToExecuteResult',
    'GetStreamConnectionsResultSecurityResult',
    'GetStreamInstanceDataProcessRegionResult',
    'GetStreamInstanceStreamConfigResult',
    'GetStreamInstancesResultResult',
    'GetStreamInstancesResultDataProcessRegionResult',
    'GetStreamInstancesResultStreamConfigResult',
    'GetStreamProcessorOptionsResult',
    'GetStreamProcessorOptionsDlqResult',
    'GetStreamProcessorsResultResult',
    'GetStreamProcessorsResultOptionsResult',
    'GetStreamProcessorsResultOptionsDlqResult',
    'GetThirdPartyIntegrationsResultResult',
    'GetX509AuthenticationDatabaseUserCertificateResult',
]

@pulumi.output_type
class AdvancedClusterAdvancedConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "changeStreamOptionsPreAndPostImagesExpireAfterSeconds":
            suggest = "change_stream_options_pre_and_post_images_expire_after_seconds"
        elif key == "defaultReadConcern":
            suggest = "default_read_concern"
        elif key == "defaultWriteConcern":
            suggest = "default_write_concern"
        elif key == "failIndexKeyTooLong":
            suggest = "fail_index_key_too_long"
        elif key == "javascriptEnabled":
            suggest = "javascript_enabled"
        elif key == "minimumEnabledTlsProtocol":
            suggest = "minimum_enabled_tls_protocol"
        elif key == "noTableScan":
            suggest = "no_table_scan"
        elif key == "oplogMinRetentionHours":
            suggest = "oplog_min_retention_hours"
        elif key == "oplogSizeMb":
            suggest = "oplog_size_mb"
        elif key == "sampleRefreshIntervalBiConnector":
            suggest = "sample_refresh_interval_bi_connector"
        elif key == "sampleSizeBiConnector":
            suggest = "sample_size_bi_connector"
        elif key == "transactionLifetimeLimitSeconds":
            suggest = "transaction_lifetime_limit_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterAdvancedConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterAdvancedConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterAdvancedConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 change_stream_options_pre_and_post_images_expire_after_seconds: Optional[int] = None,
                 default_read_concern: Optional[str] = None,
                 default_write_concern: Optional[str] = None,
                 fail_index_key_too_long: Optional[bool] = None,
                 javascript_enabled: Optional[bool] = None,
                 minimum_enabled_tls_protocol: Optional[str] = None,
                 no_table_scan: Optional[bool] = None,
                 oplog_min_retention_hours: Optional[float] = None,
                 oplog_size_mb: Optional[int] = None,
                 sample_refresh_interval_bi_connector: Optional[int] = None,
                 sample_size_bi_connector: Optional[int] = None,
                 transaction_lifetime_limit_seconds: Optional[int] = None):
        """
        :param int change_stream_options_pre_and_post_images_expire_after_seconds: The minimum pre- and post-image retention time in seconds. This option corresponds to the `changeStreamOptions.preAndPostImages.expireAfterSeconds` cluster parameter. Defaults to `-1`(off). This setting controls the retention policy of change stream pre- and post-images. Pre- and post-images are the versions of a document before and after document modification, respectively. `expireAfterSeconds` controls how long MongoDB retains pre- and post-images. When set to -1 (off), MongoDB uses the default retention policy: pre- and post-images are retained until the corresponding change stream events are removed from the oplog. To set the minimum pre- and post-image retention time, specify an integer value greater than zero. Setting this too low could increase the risk of interrupting Realm sync or triggers processing. This parameter is only supported for MongoDB version 6.0 and above.
        :param str default_read_concern: [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/). **(DEPRECATED)** MongoDB 5.0 and later clusters default to `local`. To use a custom read concern level, please refer to your driver documentation.
        :param str default_write_concern: [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        :param bool fail_index_key_too_long: When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them. **(DEPRECATED)** This parameter has been removed as of [MongoDB 4.4](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.failIndexKeyTooLong).
        :param bool javascript_enabled: When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        :param str minimum_enabled_tls_protocol: Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
               
               - TLS1_0
               - TLS1_1
               - TLS1_2
        :param bool no_table_scan: When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        :param float oplog_min_retention_hours: Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
               * **Note**  A minimum oplog retention is required when seeking to change a cluster's class to Local NVMe SSD. To learn more and for latest guidance see [`oplogMinRetentionHours`](https://www.mongodb.com/docs/manual/core/replica-set-oplog/#std-label-replica-set-minimum-oplog-size)
        :param int oplog_size_mb: The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        :param int sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param int sample_size_bi_connector: Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param int transaction_lifetime_limit_seconds: Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        if change_stream_options_pre_and_post_images_expire_after_seconds is not None:
            pulumi.set(__self__, "change_stream_options_pre_and_post_images_expire_after_seconds", change_stream_options_pre_and_post_images_expire_after_seconds)
        if default_read_concern is not None:
            pulumi.set(__self__, "default_read_concern", default_read_concern)
        if default_write_concern is not None:
            pulumi.set(__self__, "default_write_concern", default_write_concern)
        if fail_index_key_too_long is not None:
            pulumi.set(__self__, "fail_index_key_too_long", fail_index_key_too_long)
        if javascript_enabled is not None:
            pulumi.set(__self__, "javascript_enabled", javascript_enabled)
        if minimum_enabled_tls_protocol is not None:
            pulumi.set(__self__, "minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        if no_table_scan is not None:
            pulumi.set(__self__, "no_table_scan", no_table_scan)
        if oplog_min_retention_hours is not None:
            pulumi.set(__self__, "oplog_min_retention_hours", oplog_min_retention_hours)
        if oplog_size_mb is not None:
            pulumi.set(__self__, "oplog_size_mb", oplog_size_mb)
        if sample_refresh_interval_bi_connector is not None:
            pulumi.set(__self__, "sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        if sample_size_bi_connector is not None:
            pulumi.set(__self__, "sample_size_bi_connector", sample_size_bi_connector)
        if transaction_lifetime_limit_seconds is not None:
            pulumi.set(__self__, "transaction_lifetime_limit_seconds", transaction_lifetime_limit_seconds)

    @property
    @pulumi.getter(name="changeStreamOptionsPreAndPostImagesExpireAfterSeconds")
    def change_stream_options_pre_and_post_images_expire_after_seconds(self) -> Optional[int]:
        """
        The minimum pre- and post-image retention time in seconds. This option corresponds to the `changeStreamOptions.preAndPostImages.expireAfterSeconds` cluster parameter. Defaults to `-1`(off). This setting controls the retention policy of change stream pre- and post-images. Pre- and post-images are the versions of a document before and after document modification, respectively. `expireAfterSeconds` controls how long MongoDB retains pre- and post-images. When set to -1 (off), MongoDB uses the default retention policy: pre- and post-images are retained until the corresponding change stream events are removed from the oplog. To set the minimum pre- and post-image retention time, specify an integer value greater than zero. Setting this too low could increase the risk of interrupting Realm sync or triggers processing. This parameter is only supported for MongoDB version 6.0 and above.
        """
        return pulumi.get(self, "change_stream_options_pre_and_post_images_expire_after_seconds")

    @property
    @pulumi.getter(name="defaultReadConcern")
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
    def default_read_concern(self) -> Optional[str]:
        """
        [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/). **(DEPRECATED)** MongoDB 5.0 and later clusters default to `local`. To use a custom read concern level, please refer to your driver documentation.
        """
        return pulumi.get(self, "default_read_concern")

    @property
    @pulumi.getter(name="defaultWriteConcern")
    def default_write_concern(self) -> Optional[str]:
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        return pulumi.get(self, "default_write_concern")

    @property
    @pulumi.getter(name="failIndexKeyTooLong")
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
    def fail_index_key_too_long(self) -> Optional[bool]:
        """
        When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them. **(DEPRECATED)** This parameter has been removed as of [MongoDB 4.4](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.failIndexKeyTooLong).
        """
        return pulumi.get(self, "fail_index_key_too_long")

    @property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> Optional[bool]:
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        return pulumi.get(self, "javascript_enabled")

    @property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> Optional[str]:
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:

        - TLS1_0
        - TLS1_1
        - TLS1_2
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> Optional[bool]:
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        return pulumi.get(self, "no_table_scan")

    @property
    @pulumi.getter(name="oplogMinRetentionHours")
    def oplog_min_retention_hours(self) -> Optional[float]:
        """
        Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        * **Note**  A minimum oplog retention is required when seeking to change a cluster's class to Local NVMe SSD. To learn more and for latest guidance see [`oplogMinRetentionHours`](https://www.mongodb.com/docs/manual/core/replica-set-oplog/#std-label-replica-set-minimum-oplog-size)
        """
        return pulumi.get(self, "oplog_min_retention_hours")

    @property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> Optional[int]:
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        return pulumi.get(self, "oplog_size_mb")

    @property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> Optional[int]:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> Optional[int]:
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_size_bi_connector")

    @property
    @pulumi.getter(name="transactionLifetimeLimitSeconds")
    def transaction_lifetime_limit_seconds(self) -> Optional[int]:
        """
        Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        return pulumi.get(self, "transaction_lifetime_limit_seconds")


@pulumi.output_type
class AdvancedClusterBiConnectorConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readPreference":
            suggest = "read_preference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterBiConnectorConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterBiConnectorConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterBiConnectorConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 read_preference: Optional[str] = None):
        """
        :param bool enabled: Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
               *
               - Set to `true` to enable BI Connector for Atlas.
               - Set to `false` to disable BI Connector for Atlas.
        :param str read_preference: Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
               
               - Set to "primary" to have BI Connector for Atlas read from the primary.
               
               - Set to "secondary" to have BI Connector for Atlas read from a secondary member. Default if there are no analytics nodes in the cluster.
               
               - Set to "analytics" to have BI Connector for Atlas read from an analytics node. Default if the cluster contains analytics nodes.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if read_preference is not None:
            pulumi.set(__self__, "read_preference", read_preference)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
        *
        - Set to `true` to enable BI Connector for Atlas.
        - Set to `false` to disable BI Connector for Atlas.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> Optional[str]:
        """
        Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).

        - Set to "primary" to have BI Connector for Atlas read from the primary.

        - Set to "secondary" to have BI Connector for Atlas read from a secondary member. Default if there are no analytics nodes in the cluster.

        - Set to "analytics" to have BI Connector for Atlas read from an analytics node. Default if the cluster contains analytics nodes.
        """
        return pulumi.get(self, "read_preference")


@pulumi.output_type
class AdvancedClusterConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateEndpoints":
            suggest = "private_endpoints"
        elif key == "privateSrv":
            suggest = "private_srv"
        elif key == "standardSrv":
            suggest = "standard_srv"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private: Optional[str] = None,
                 private_endpoints: Optional[Sequence['outputs.AdvancedClusterConnectionStringPrivateEndpoint']] = None,
                 private_srv: Optional[str] = None,
                 standard: Optional[str] = None,
                 standard_srv: Optional[str] = None):
        """
        :param str private: [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        :param Sequence['AdvancedClusterConnectionStringPrivateEndpointArgs'] private_endpoints: Private endpoint connection strings. Each object describes the connection strings you can use to connect to this cluster through a private endpoint. Atlas returns this parameter only if you deployed a private endpoint to all regions to which you deployed this cluster's nodes.
               - `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
               - `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in DNS . Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don't need to: Append the seed list or Change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn't, use `connection_strings.private_endpoint[n].connection_string`
               - `connection_strings.private_endpoint.#.srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster supports it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[n].srvConnectionString.
               - `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
               - `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`
               - `connection_strings.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.
               - `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
               - `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.
        :param str private_srv: [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        :param str standard: Public mongodb:// connection string for this cluster.
        :param str standard_srv: Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t  , use connectionStrings.standard.
        """
        if private is not None:
            pulumi.set(__self__, "private", private)
        if private_endpoints is not None:
            pulumi.set(__self__, "private_endpoints", private_endpoints)
        if private_srv is not None:
            pulumi.set(__self__, "private_srv", private_srv)
        if standard is not None:
            pulumi.set(__self__, "standard", standard)
        if standard_srv is not None:
            pulumi.set(__self__, "standard_srv", standard_srv)

    @property
    @pulumi.getter
    def private(self) -> Optional[str]:
        """
        [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        """
        return pulumi.get(self, "private")

    @property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Optional[Sequence['outputs.AdvancedClusterConnectionStringPrivateEndpoint']]:
        """
        Private endpoint connection strings. Each object describes the connection strings you can use to connect to this cluster through a private endpoint. Atlas returns this parameter only if you deployed a private endpoint to all regions to which you deployed this cluster's nodes.
        - `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
        - `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in DNS . Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don't need to: Append the seed list or Change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn't, use `connection_strings.private_endpoint[n].connection_string`
        - `connection_strings.private_endpoint.#.srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster supports it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[n].srvConnectionString.
        - `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
        - `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`
        - `connection_strings.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.
        - `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
        - `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.
        """
        return pulumi.get(self, "private_endpoints")

    @property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> Optional[str]:
        """
        [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        """
        return pulumi.get(self, "private_srv")

    @property
    @pulumi.getter
    def standard(self) -> Optional[str]:
        """
        Public mongodb:// connection string for this cluster.
        """
        return pulumi.get(self, "standard")

    @property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> Optional[str]:
        """
        Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t  , use connectionStrings.standard.
        """
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class AdvancedClusterConnectionStringPrivateEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionString":
            suggest = "connection_string"
        elif key == "srvConnectionString":
            suggest = "srv_connection_string"
        elif key == "srvShardOptimizedConnectionString":
            suggest = "srv_shard_optimized_connection_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterConnectionStringPrivateEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterConnectionStringPrivateEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterConnectionStringPrivateEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_string: Optional[str] = None,
                 endpoints: Optional[Sequence['outputs.AdvancedClusterConnectionStringPrivateEndpointEndpoint']] = None,
                 srv_connection_string: Optional[str] = None,
                 srv_shard_optimized_connection_string: Optional[str] = None,
                 type: Optional[str] = None):
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if srv_connection_string is not None:
            pulumi.set(__self__, "srv_connection_string", srv_connection_string)
        if srv_shard_optimized_connection_string is not None:
            pulumi.set(__self__, "srv_shard_optimized_connection_string", srv_shard_optimized_connection_string)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[str]:
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence['outputs.AdvancedClusterConnectionStringPrivateEndpointEndpoint']]:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> Optional[str]:
        return pulumi.get(self, "srv_connection_string")

    @property
    @pulumi.getter(name="srvShardOptimizedConnectionString")
    def srv_shard_optimized_connection_string(self) -> Optional[str]:
        return pulumi.get(self, "srv_shard_optimized_connection_string")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class AdvancedClusterConnectionStringPrivateEndpointEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointId":
            suggest = "endpoint_id"
        elif key == "providerName":
            suggest = "provider_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterConnectionStringPrivateEndpointEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterConnectionStringPrivateEndpointEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterConnectionStringPrivateEndpointEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_id: Optional[str] = None,
                 provider_name: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str provider_name: Cloud service provider on which the servers are provisioned.
               The possible values are:
               
               - `AWS` - Amazon AWS
               - `GCP` - Google Cloud Platform
               - `AZURE` - Microsoft Azure
               - `TENANT` - M0, M2 or M5 multi-tenant cluster. Use `replication_specs.#.region_configs.#.backing_provider_name` to set the cloud service provider.
        """
        if endpoint_id is not None:
            pulumi.set(__self__, "endpoint_id", endpoint_id)
        if provider_name is not None:
            pulumi.set(__self__, "provider_name", provider_name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[str]:
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> Optional[str]:
        """
        Cloud service provider on which the servers are provisioned.
        The possible values are:

        - `AWS` - Amazon AWS
        - `GCP` - Google Cloud Platform
        - `AZURE` - Microsoft Azure
        - `TENANT` - M0, M2 or M5 multi-tenant cluster. Use `replication_specs.#.region_configs.#.backing_provider_name` to set the cloud service provider.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class AdvancedClusterLabel(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
               
               > **NOTE:** MongoDB Atlas doesn't display your labels.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value that you want to write.

        > **NOTE:** MongoDB Atlas doesn't display your labels.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AdvancedClusterReplicationSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionConfigs":
            suggest = "region_configs"
        elif key == "containerId":
            suggest = "container_id"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "numShards":
            suggest = "num_shards"
        elif key == "zoneId":
            suggest = "zone_id"
        elif key == "zoneName":
            suggest = "zone_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterReplicationSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterReplicationSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterReplicationSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region_configs: Sequence['outputs.AdvancedClusterReplicationSpecRegionConfig'],
                 container_id: Optional[Mapping[str, str]] = None,
                 external_id: Optional[str] = None,
                 id: Optional[str] = None,
                 num_shards: Optional[int] = None,
                 zone_id: Optional[str] = None,
                 zone_name: Optional[str] = None):
        """
        :param Sequence['AdvancedClusterReplicationSpecRegionConfigArgs'] region_configs: Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below
        :param str external_id: Unique 24-hexadecimal digit string that identifies the replication object for a shard in a Cluster. This value corresponds to Shard ID displayed in the UI. When using old sharding configuration (replication spec with `num_shards` greater than 1) this value is not populated.
        :param str id: **(DEPRECATED)** Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        :param int num_shards: Provide this value if you set a `cluster_type` of SHARDED or GEOSHARDED. Omit this value if you selected a `cluster_type` of REPLICASET. This API resource accepts 1 through 50, inclusive. This parameter defaults to 1. If you specify a `num_shards` value of 1 and a `cluster_type` of SHARDED, Atlas deploys a single-shard [sharded cluster](https://docs.atlas.mongodb.com/reference/glossary/#std-term-sharded-cluster). Don't create a sharded cluster with a single shard for production environments. Single-shard sharded clusters don't provide the same benefits as multi-shard configurations.
               If you are upgrading a replica set to a sharded cluster, you cannot increase the number of shards in the same update request. You should wait until after the cluster has completed upgrading to sharded and you have reconnected all application clients to the MongoDB router before adding additional shards. Otherwise, your data might become inconsistent once MongoDB Cloud begins distributing data across shards. To learn more, see [Convert a replica set to a sharded cluster documentation](https://www.mongodb.com/docs/atlas/scale-cluster/#convert-a-replica-set-to-a-sharded-cluster) and [Convert a replica set to a sharded cluster tutorial](https://www.mongodb.com/docs/upcoming/tutorial/convert-replica-set-to-replicated-shard-cluster). **(DEPRECATED)** To learn more, see the 1.18.0 Upgrade Guide.
        :param str zone_id: Unique 24-hexadecimal digit string that identifies the zone in a Global Cluster. If clusterType is GEOSHARDED, this value indicates the zone that the given shard belongs to and can be used to configure Global Cluster backup policies.
        :param str zone_name: Name for the zone in a Global Cluster.
        """
        pulumi.set(__self__, "region_configs", region_configs)
        if container_id is not None:
            pulumi.set(__self__, "container_id", container_id)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if num_shards is not None:
            pulumi.set(__self__, "num_shards", num_shards)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)
        if zone_name is not None:
            pulumi.set(__self__, "zone_name", zone_name)

    @property
    @pulumi.getter(name="regionConfigs")
    def region_configs(self) -> Sequence['outputs.AdvancedClusterReplicationSpecRegionConfig']:
        """
        Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below
        """
        return pulumi.get(self, "region_configs")

    @property
    @pulumi.getter(name="containerId")
    def container_id(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "container_id")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        """
        Unique 24-hexadecimal digit string that identifies the replication object for a shard in a Cluster. This value corresponds to Shard ID displayed in the UI. When using old sharding configuration (replication spec with `num_shards` greater than 1) this value is not populated.
        """
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
    def id(self) -> Optional[str]:
        """
        **(DEPRECATED)** Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="numShards")
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
    def num_shards(self) -> Optional[int]:
        """
        Provide this value if you set a `cluster_type` of SHARDED or GEOSHARDED. Omit this value if you selected a `cluster_type` of REPLICASET. This API resource accepts 1 through 50, inclusive. This parameter defaults to 1. If you specify a `num_shards` value of 1 and a `cluster_type` of SHARDED, Atlas deploys a single-shard [sharded cluster](https://docs.atlas.mongodb.com/reference/glossary/#std-term-sharded-cluster). Don't create a sharded cluster with a single shard for production environments. Single-shard sharded clusters don't provide the same benefits as multi-shard configurations.
        If you are upgrading a replica set to a sharded cluster, you cannot increase the number of shards in the same update request. You should wait until after the cluster has completed upgrading to sharded and you have reconnected all application clients to the MongoDB router before adding additional shards. Otherwise, your data might become inconsistent once MongoDB Cloud begins distributing data across shards. To learn more, see [Convert a replica set to a sharded cluster documentation](https://www.mongodb.com/docs/atlas/scale-cluster/#convert-a-replica-set-to-a-sharded-cluster) and [Convert a replica set to a sharded cluster tutorial](https://www.mongodb.com/docs/upcoming/tutorial/convert-replica-set-to-replicated-shard-cluster). **(DEPRECATED)** To learn more, see the 1.18.0 Upgrade Guide.
        """
        return pulumi.get(self, "num_shards")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        """
        Unique 24-hexadecimal digit string that identifies the zone in a Global Cluster. If clusterType is GEOSHARDED, this value indicates the zone that the given shard belongs to and can be used to configure Global Cluster backup policies.
        """
        return pulumi.get(self, "zone_id")

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> Optional[str]:
        """
        Name for the zone in a Global Cluster.
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class AdvancedClusterReplicationSpecRegionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "providerName":
            suggest = "provider_name"
        elif key == "regionName":
            suggest = "region_name"
        elif key == "analyticsAutoScaling":
            suggest = "analytics_auto_scaling"
        elif key == "analyticsSpecs":
            suggest = "analytics_specs"
        elif key == "autoScaling":
            suggest = "auto_scaling"
        elif key == "backingProviderName":
            suggest = "backing_provider_name"
        elif key == "electableSpecs":
            suggest = "electable_specs"
        elif key == "readOnlySpecs":
            suggest = "read_only_specs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterReplicationSpecRegionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterReplicationSpecRegionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterReplicationSpecRegionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 priority: int,
                 provider_name: str,
                 region_name: str,
                 analytics_auto_scaling: Optional['outputs.AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling'] = None,
                 analytics_specs: Optional['outputs.AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs'] = None,
                 auto_scaling: Optional['outputs.AdvancedClusterReplicationSpecRegionConfigAutoScaling'] = None,
                 backing_provider_name: Optional[str] = None,
                 electable_specs: Optional['outputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecs'] = None,
                 read_only_specs: Optional['outputs.AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs'] = None):
        """
        :param int priority: Election priority of the region. For regions with only read-only nodes, set this value to 0.
               * If you have multiple `region_configs` objects (your cluster is multi-region or multi-cloud), they must have priorities in descending order. The highest priority is 7.
               * If your region has set `region_configs.#.electable_specs.0.node_count` to 1 or higher, it must have a priority of exactly one (1) less than another region in the `replication_specs.#.region_configs.#` array. The highest-priority region must have a priority of 7. The lowest possible priority is 1.
        :param str provider_name: Cloud service provider on which the servers are provisioned.
               The possible values are:
               
               - `AWS` - Amazon AWS
               - `GCP` - Google Cloud Platform
               - `AZURE` - Microsoft Azure
               - `TENANT` - M0, M2 or M5 multi-tenant cluster. Use `replication_specs.#.region_configs.#.backing_provider_name` to set the cloud service provider.
        :param str region_name: Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        :param 'AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingArgs' analytics_auto_scaling: Configuration for the Collection of settings that configures analytics-auto-scaling information for the cluster. The values for the `analytics_auto_scaling` parameter must be the same for all `region_configs` in all `replication_specs`. See below
        :param 'AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgs' analytics_specs: Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. Analytics nodes handle analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only and can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary). If you don't specify this parameter, no analytics nodes deploy to this region. See below
        :param 'AdvancedClusterReplicationSpecRegionConfigAutoScalingArgs' auto_scaling: Configuration for the Collection of settings that configures auto-scaling information for the cluster. The values for the `auto_scaling` parameter must be the same for all `region_configs` in all `replication_specs`. See below
        :param str backing_provider_name: Cloud service provider on which you provision the host for a multi-tenant cluster. Use this only when a `provider_name` is `TENANT` and `instance_size` of a specs is `M2` or `M5`.
        :param 'AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs' electable_specs: Hardware specifications for electable nodes in the region. Electable nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you do not specify this option, no electable nodes are deployed to the region. See below
        :param 'AdvancedClusterReplicationSpecRegionConfigReadOnlySpecsArgs' read_only_specs: Hardware specifications for read-only nodes in the region. Read-only nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you don't specify this parameter, no read-only nodes are deployed to the region. See below
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "region_name", region_name)
        if analytics_auto_scaling is not None:
            pulumi.set(__self__, "analytics_auto_scaling", analytics_auto_scaling)
        if analytics_specs is not None:
            pulumi.set(__self__, "analytics_specs", analytics_specs)
        if auto_scaling is not None:
            pulumi.set(__self__, "auto_scaling", auto_scaling)
        if backing_provider_name is not None:
            pulumi.set(__self__, "backing_provider_name", backing_provider_name)
        if electable_specs is not None:
            pulumi.set(__self__, "electable_specs", electable_specs)
        if read_only_specs is not None:
            pulumi.set(__self__, "read_only_specs", read_only_specs)

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Election priority of the region. For regions with only read-only nodes, set this value to 0.
        * If you have multiple `region_configs` objects (your cluster is multi-region or multi-cloud), they must have priorities in descending order. The highest priority is 7.
        * If your region has set `region_configs.#.electable_specs.0.node_count` to 1 or higher, it must have a priority of exactly one (1) less than another region in the `replication_specs.#.region_configs.#` array. The highest-priority region must have a priority of 7. The lowest possible priority is 1.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Cloud service provider on which the servers are provisioned.
        The possible values are:

        - `AWS` - Amazon AWS
        - `GCP` - Google Cloud Platform
        - `AZURE` - Microsoft Azure
        - `TENANT` - M0, M2 or M5 multi-tenant cluster. Use `replication_specs.#.region_configs.#.backing_provider_name` to set the cloud service provider.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter(name="analyticsAutoScaling")
    def analytics_auto_scaling(self) -> Optional['outputs.AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling']:
        """
        Configuration for the Collection of settings that configures analytics-auto-scaling information for the cluster. The values for the `analytics_auto_scaling` parameter must be the same for all `region_configs` in all `replication_specs`. See below
        """
        return pulumi.get(self, "analytics_auto_scaling")

    @property
    @pulumi.getter(name="analyticsSpecs")
    def analytics_specs(self) -> Optional['outputs.AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs']:
        """
        Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. Analytics nodes handle analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only and can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary). If you don't specify this parameter, no analytics nodes deploy to this region. See below
        """
        return pulumi.get(self, "analytics_specs")

    @property
    @pulumi.getter(name="autoScaling")
    def auto_scaling(self) -> Optional['outputs.AdvancedClusterReplicationSpecRegionConfigAutoScaling']:
        """
        Configuration for the Collection of settings that configures auto-scaling information for the cluster. The values for the `auto_scaling` parameter must be the same for all `region_configs` in all `replication_specs`. See below
        """
        return pulumi.get(self, "auto_scaling")

    @property
    @pulumi.getter(name="backingProviderName")
    def backing_provider_name(self) -> Optional[str]:
        """
        Cloud service provider on which you provision the host for a multi-tenant cluster. Use this only when a `provider_name` is `TENANT` and `instance_size` of a specs is `M2` or `M5`.
        """
        return pulumi.get(self, "backing_provider_name")

    @property
    @pulumi.getter(name="electableSpecs")
    def electable_specs(self) -> Optional['outputs.AdvancedClusterReplicationSpecRegionConfigElectableSpecs']:
        """
        Hardware specifications for electable nodes in the region. Electable nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you do not specify this option, no electable nodes are deployed to the region. See below
        """
        return pulumi.get(self, "electable_specs")

    @property
    @pulumi.getter(name="readOnlySpecs")
    def read_only_specs(self) -> Optional['outputs.AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs']:
        """
        Hardware specifications for read-only nodes in the region. Read-only nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you don't specify this parameter, no read-only nodes are deployed to the region. See below
        """
        return pulumi.get(self, "read_only_specs")


@pulumi.output_type
class AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeEnabled":
            suggest = "compute_enabled"
        elif key == "computeMaxInstanceSize":
            suggest = "compute_max_instance_size"
        elif key == "computeMinInstanceSize":
            suggest = "compute_min_instance_size"
        elif key == "computeScaleDownEnabled":
            suggest = "compute_scale_down_enabled"
        elif key == "diskGbEnabled":
            suggest = "disk_gb_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_enabled: Optional[bool] = None,
                 compute_max_instance_size: Optional[str] = None,
                 compute_min_instance_size: Optional[str] = None,
                 compute_scale_down_enabled: Optional[bool] = None,
                 disk_gb_enabled: Optional[bool] = None):
        """
        :param str compute_max_instance_size: Maximum instance size to which your cluster can automatically scale (such as M40). Atlas requires this parameter if `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_enabled` is true.
        :param str compute_min_instance_size: Minimum instance size to which your cluster can automatically scale (such as M10). Atlas requires this parameter if `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_scale_down_enabled` is true.
        :param bool compute_scale_down_enabled: Flag that indicates whether the instance size may scale down. Atlas requires this parameter if `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_enabled` : true. If you enable this option, specify a value for `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_min_instance_size`.
        :param bool disk_gb_enabled: Flag that indicates whether this cluster enables disk auto-scaling. This parameter defaults to false.
        """
        if compute_enabled is not None:
            pulumi.set(__self__, "compute_enabled", compute_enabled)
        if compute_max_instance_size is not None:
            pulumi.set(__self__, "compute_max_instance_size", compute_max_instance_size)
        if compute_min_instance_size is not None:
            pulumi.set(__self__, "compute_min_instance_size", compute_min_instance_size)
        if compute_scale_down_enabled is not None:
            pulumi.set(__self__, "compute_scale_down_enabled", compute_scale_down_enabled)
        if disk_gb_enabled is not None:
            pulumi.set(__self__, "disk_gb_enabled", disk_gb_enabled)

    @property
    @pulumi.getter(name="computeEnabled")
    def compute_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "compute_enabled")

    @property
    @pulumi.getter(name="computeMaxInstanceSize")
    def compute_max_instance_size(self) -> Optional[str]:
        """
        Maximum instance size to which your cluster can automatically scale (such as M40). Atlas requires this parameter if `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_enabled` is true.
        """
        return pulumi.get(self, "compute_max_instance_size")

    @property
    @pulumi.getter(name="computeMinInstanceSize")
    def compute_min_instance_size(self) -> Optional[str]:
        """
        Minimum instance size to which your cluster can automatically scale (such as M10). Atlas requires this parameter if `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_scale_down_enabled` is true.
        """
        return pulumi.get(self, "compute_min_instance_size")

    @property
    @pulumi.getter(name="computeScaleDownEnabled")
    def compute_scale_down_enabled(self) -> Optional[bool]:
        """
        Flag that indicates whether the instance size may scale down. Atlas requires this parameter if `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_enabled` : true. If you enable this option, specify a value for `replication_specs.#.region_configs.#.analytics_auto_scaling.0.compute_min_instance_size`.
        """
        return pulumi.get(self, "compute_scale_down_enabled")

    @property
    @pulumi.getter(name="diskGbEnabled")
    def disk_gb_enabled(self) -> Optional[bool]:
        """
        Flag that indicates whether this cluster enables disk auto-scaling. This parameter defaults to false.
        """
        return pulumi.get(self, "disk_gb_enabled")


@pulumi.output_type
class AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceSize":
            suggest = "instance_size"
        elif key == "diskIops":
            suggest = "disk_iops"
        elif key == "diskSizeGb":
            suggest = "disk_size_gb"
        elif key == "ebsVolumeType":
            suggest = "ebs_volume_type"
        elif key == "nodeCount":
            suggest = "node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_size: str,
                 disk_iops: Optional[int] = None,
                 disk_size_gb: Optional[float] = None,
                 ebs_volume_type: Optional[str] = None,
                 node_count: Optional[int] = None):
        """
        :param str instance_size: Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size. Electable nodes and read-only nodes (known as "base nodes") within a single shard must use the same instance size. Analytics nodes can scale independently from base nodes within a shard. Both base nodes and analytics nodes can scale independently from their equivalents in other shards.
        :param int disk_iops: Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. Define this attribute only if you selected AWS as your cloud service provider, `instance_size` is set to "M30" or greater (not including "Mxx_NVME" tiers), and `ebs_volume_type` is "PROVISIONED". You can't set this attribute for a multi-cloud cluster.
        :param float disk_size_gb: Storage capacity that the host's root volume possesses expressed in gigabytes. This value must be equal for all shards and node types. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier. **Note:** Using `disk_size_gb` with Standard IOPS could lead to errors and configuration issues. Therefore, it should be used only with the Provisioned IOPS volume type. When using Provisioned IOPS, the disk_size_gb parameter specifies the storage capacity, but the IOPS are set independently. Ensuring that `disk_size_gb` is used exclusively with Provisioned IOPS will help avoid these issues.
        :param str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        pulumi.set(__self__, "instance_size", instance_size)
        if disk_iops is not None:
            pulumi.set(__self__, "disk_iops", disk_iops)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size. Electable nodes and read-only nodes (known as "base nodes") within a single shard must use the same instance size. Analytics nodes can scale independently from base nodes within a shard. Both base nodes and analytics nodes can scale independently from their equivalents in other shards.
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[int]:
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. Define this attribute only if you selected AWS as your cloud service provider, `instance_size` is set to "M30" or greater (not including "Mxx_NVME" tiers), and `ebs_volume_type` is "PROVISIONED". You can't set this attribute for a multi-cloud cluster.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[float]:
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. This value must be equal for all shards and node types. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier. **Note:** Using `disk_size_gb` with Standard IOPS could lead to errors and configuration issues. Therefore, it should be used only with the Provisioned IOPS volume type. When using Provisioned IOPS, the disk_size_gb parameter specifies the storage capacity, but the IOPS are set independently. Ensuring that `disk_size_gb` is used exclusively with Provisioned IOPS will help avoid these issues.
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class AdvancedClusterReplicationSpecRegionConfigAutoScaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeEnabled":
            suggest = "compute_enabled"
        elif key == "computeMaxInstanceSize":
            suggest = "compute_max_instance_size"
        elif key == "computeMinInstanceSize":
            suggest = "compute_min_instance_size"
        elif key == "computeScaleDownEnabled":
            suggest = "compute_scale_down_enabled"
        elif key == "diskGbEnabled":
            suggest = "disk_gb_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterReplicationSpecRegionConfigAutoScaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterReplicationSpecRegionConfigAutoScaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterReplicationSpecRegionConfigAutoScaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_enabled: Optional[bool] = None,
                 compute_max_instance_size: Optional[str] = None,
                 compute_min_instance_size: Optional[str] = None,
                 compute_scale_down_enabled: Optional[bool] = None,
                 disk_gb_enabled: Optional[bool] = None):
        """
        :param str compute_max_instance_size: Maximum instance size to which your cluster can automatically scale (such as M40). Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_enabled` is true.
        :param str compute_min_instance_size: Minimum instance size to which your cluster can automatically scale (such as M10). Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_scale_down_enabled` is true.
        :param bool compute_scale_down_enabled: Flag that indicates whether the instance size may scale down. Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_enabled` : true. If you enable this option, specify a value for `replication_specs.#.region_configs.#.auto_scaling.0.compute_min_instance_size`.
        """
        if compute_enabled is not None:
            pulumi.set(__self__, "compute_enabled", compute_enabled)
        if compute_max_instance_size is not None:
            pulumi.set(__self__, "compute_max_instance_size", compute_max_instance_size)
        if compute_min_instance_size is not None:
            pulumi.set(__self__, "compute_min_instance_size", compute_min_instance_size)
        if compute_scale_down_enabled is not None:
            pulumi.set(__self__, "compute_scale_down_enabled", compute_scale_down_enabled)
        if disk_gb_enabled is not None:
            pulumi.set(__self__, "disk_gb_enabled", disk_gb_enabled)

    @property
    @pulumi.getter(name="computeEnabled")
    def compute_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "compute_enabled")

    @property
    @pulumi.getter(name="computeMaxInstanceSize")
    def compute_max_instance_size(self) -> Optional[str]:
        """
        Maximum instance size to which your cluster can automatically scale (such as M40). Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_enabled` is true.
        """
        return pulumi.get(self, "compute_max_instance_size")

    @property
    @pulumi.getter(name="computeMinInstanceSize")
    def compute_min_instance_size(self) -> Optional[str]:
        """
        Minimum instance size to which your cluster can automatically scale (such as M10). Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_scale_down_enabled` is true.
        """
        return pulumi.get(self, "compute_min_instance_size")

    @property
    @pulumi.getter(name="computeScaleDownEnabled")
    def compute_scale_down_enabled(self) -> Optional[bool]:
        """
        Flag that indicates whether the instance size may scale down. Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_enabled` : true. If you enable this option, specify a value for `replication_specs.#.region_configs.#.auto_scaling.0.compute_min_instance_size`.
        """
        return pulumi.get(self, "compute_scale_down_enabled")

    @property
    @pulumi.getter(name="diskGbEnabled")
    def disk_gb_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "disk_gb_enabled")


@pulumi.output_type
class AdvancedClusterReplicationSpecRegionConfigElectableSpecs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceSize":
            suggest = "instance_size"
        elif key == "diskIops":
            suggest = "disk_iops"
        elif key == "diskSizeGb":
            suggest = "disk_size_gb"
        elif key == "ebsVolumeType":
            suggest = "ebs_volume_type"
        elif key == "nodeCount":
            suggest = "node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterReplicationSpecRegionConfigElectableSpecs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterReplicationSpecRegionConfigElectableSpecs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterReplicationSpecRegionConfigElectableSpecs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_size: str,
                 disk_iops: Optional[int] = None,
                 disk_size_gb: Optional[float] = None,
                 ebs_volume_type: Optional[str] = None,
                 node_count: Optional[int] = None):
        """
        :param str instance_size: Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size. Electable nodes and read-only nodes (known as "base nodes") within a single shard must use the same instance size. Analytics nodes can scale independently from base nodes within a shard. Both base nodes and analytics nodes can scale independently from their equivalents in other shards.
        :param int disk_iops: Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. Define this attribute only if you selected AWS as your cloud service provider, `instance_size` is set to "M30" or greater (not including "Mxx_NVME" tiers), and `ebs_volume_type` is "PROVISIONED". You can't set this attribute for a multi-cloud cluster.
        :param float disk_size_gb: Storage capacity that the host's root volume possesses expressed in gigabytes. This value must be equal for all shards and node types. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier. **Note:** Using `disk_size_gb` with Standard IOPS could lead to errors and configuration issues. Therefore, it should be used only with the Provisioned IOPS volume type. When using Provisioned IOPS, the disk_size_gb parameter specifies the storage capacity, but the IOPS are set independently. Ensuring that `disk_size_gb` is used exclusively with Provisioned IOPS will help avoid these issues.
        :param str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        pulumi.set(__self__, "instance_size", instance_size)
        if disk_iops is not None:
            pulumi.set(__self__, "disk_iops", disk_iops)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size. Electable nodes and read-only nodes (known as "base nodes") within a single shard must use the same instance size. Analytics nodes can scale independently from base nodes within a shard. Both base nodes and analytics nodes can scale independently from their equivalents in other shards.
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[int]:
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. Define this attribute only if you selected AWS as your cloud service provider, `instance_size` is set to "M30" or greater (not including "Mxx_NVME" tiers), and `ebs_volume_type` is "PROVISIONED". You can't set this attribute for a multi-cloud cluster.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[float]:
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. This value must be equal for all shards and node types. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier. **Note:** Using `disk_size_gb` with Standard IOPS could lead to errors and configuration issues. Therefore, it should be used only with the Provisioned IOPS volume type. When using Provisioned IOPS, the disk_size_gb parameter specifies the storage capacity, but the IOPS are set independently. Ensuring that `disk_size_gb` is used exclusively with Provisioned IOPS will help avoid these issues.
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceSize":
            suggest = "instance_size"
        elif key == "diskIops":
            suggest = "disk_iops"
        elif key == "diskSizeGb":
            suggest = "disk_size_gb"
        elif key == "ebsVolumeType":
            suggest = "ebs_volume_type"
        elif key == "nodeCount":
            suggest = "node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AdvancedClusterReplicationSpecRegionConfigReadOnlySpecs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_size: str,
                 disk_iops: Optional[int] = None,
                 disk_size_gb: Optional[float] = None,
                 ebs_volume_type: Optional[str] = None,
                 node_count: Optional[int] = None):
        """
        :param str instance_size: Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size. Electable nodes and read-only nodes (known as "base nodes") within a single shard must use the same instance size. Analytics nodes can scale independently from base nodes within a shard. Both base nodes and analytics nodes can scale independently from their equivalents in other shards.
        :param int disk_iops: Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. Define this attribute only if you selected AWS as your cloud service provider, `instance_size` is set to "M30" or greater (not including "Mxx_NVME" tiers), and `ebs_volume_type` is "PROVISIONED". You can't set this attribute for a multi-cloud cluster. This parameter defaults to the cluster tier's standard IOPS value.
        :param float disk_size_gb: Storage capacity that the host's root volume possesses expressed in gigabytes. This value must be equal for all shards and node types. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier. **Note:** Using `disk_size_gb` with Standard IOPS could lead to errors and configuration issues. Therefore, it should be used only with the Provisioned IOPS volume type. When using Provisioned IOPS, the disk_size_gb parameter specifies the storage capacity, but the IOPS are set independently. Ensuring that `disk_size_gb` is used exclusively with Provisioned IOPS will help avoid these issues.
        :param str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        pulumi.set(__self__, "instance_size", instance_size)
        if disk_iops is not None:
            pulumi.set(__self__, "disk_iops", disk_iops)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size. Electable nodes and read-only nodes (known as "base nodes") within a single shard must use the same instance size. Analytics nodes can scale independently from base nodes within a shard. Both base nodes and analytics nodes can scale independently from their equivalents in other shards.
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[int]:
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. Define this attribute only if you selected AWS as your cloud service provider, `instance_size` is set to "M30" or greater (not including "Mxx_NVME" tiers), and `ebs_volume_type` is "PROVISIONED". You can't set this attribute for a multi-cloud cluster. This parameter defaults to the cluster tier's standard IOPS value.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[float]:
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. This value must be equal for all shards and node types. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier. **Note:** Using `disk_size_gb` with Standard IOPS could lead to errors and configuration issues. Therefore, it should be used only with the Provisioned IOPS volume type. When using Provisioned IOPS, the disk_size_gb parameter specifies the storage capacity, but the IOPS are set independently. Ensuring that `disk_size_gb` is used exclusively with Provisioned IOPS will help avoid these issues.
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[str]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class AdvancedClusterTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Constant that defines the set of the tag.
        :param str value: Variable that belongs to the set of the tag.
               
               To learn more, see [Resource Tags](https://dochub.mongodb.org/core/add-cluster-tag-atlas).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Constant that defines the set of the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Variable that belongs to the set of the tag.

        To learn more, see [Resource Tags](https://dochub.mongodb.org/core/add-cluster-tag-atlas).
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AlertConfigurationMatcher(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertConfigurationMatcher. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertConfigurationMatcher.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertConfigurationMatcher.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: str,
                 operator: str,
                 value: str):
        """
        :param str field_name: Name of the field in the target object to match on.
               
               | Host alerts         | Replica set alerts  |  Sharded cluster alerts |
               |:----------           |:-------------       |:------                 |
               | `TYPE_NAME`         | `REPLICA_SET_NAME`  | `CLUSTER_NAME`          |
               | `HOSTNAME`          | `SHARD_NAME`        | `SHARD_NAME`            |
               | `PORT`              | `CLUSTER_NAME`      |                         |
               | `HOSTNAME_AND_PORT` |                     |                         |
               | `REPLICA_SET_NAME`  |                     |                         |
               
               
               
               All other types of alerts do not support matchers.
        :param str value: Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
               - `PRIMARY`
               - `SECONDARY`
               - `STANDALONE`
               - `CONFIG`
               - `MONGOS`
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        """
        Name of the field in the target object to match on.

        | Host alerts         | Replica set alerts  |  Sharded cluster alerts |
        |:----------           |:-------------       |:------                 |
        | `TYPE_NAME`         | `REPLICA_SET_NAME`  | `CLUSTER_NAME`          |
        | `HOSTNAME`          | `SHARD_NAME`        | `SHARD_NAME`            |
        | `PORT`              | `CLUSTER_NAME`      |                         |
        | `HOSTNAME_AND_PORT` |                     |                         |
        | `REPLICA_SET_NAME`  |                     |                         |



        All other types of alerts do not support matchers.
        """
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
        - `PRIMARY`
        - `SECONDARY`
        - `STANDALONE`
        - `CONFIG`
        - `MONGOS`
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AlertConfigurationMetricThresholdConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertConfigurationMetricThresholdConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertConfigurationMetricThresholdConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertConfigurationMetricThresholdConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: str,
                 mode: Optional[str] = None,
                 operator: Optional[str] = None,
                 threshold: Optional[float] = None,
                 units: Optional[str] = None):
        """
        :param str metric_name: Name of the metric to check. The full list being quite large, please refer to atlas docs [here for general metrics](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types) and [here for serverless metrics](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-create-config/#serverless-measurements)
        :param str mode: This must be set to AVERAGE. Atlas computes the current metric value as an average.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if units is not None:
            pulumi.set(__self__, "units", units)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        Name of the metric to check. The full list being quite large, please refer to atlas docs [here for general metrics](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types) and [here for serverless metrics](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-create-config/#serverless-measurements)
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        This must be set to AVERAGE. Atlas computes the current metric value as an average.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def units(self) -> Optional[str]:
        return pulumi.get(self, "units")


@pulumi.output_type
class AlertConfigurationNotification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeName":
            suggest = "type_name"
        elif key == "apiToken":
            suggest = "api_token"
        elif key == "channelName":
            suggest = "channel_name"
        elif key == "datadogApiKey":
            suggest = "datadog_api_key"
        elif key == "datadogRegion":
            suggest = "datadog_region"
        elif key == "delayMin":
            suggest = "delay_min"
        elif key == "emailAddress":
            suggest = "email_address"
        elif key == "emailEnabled":
            suggest = "email_enabled"
        elif key == "integrationId":
            suggest = "integration_id"
        elif key == "intervalMin":
            suggest = "interval_min"
        elif key == "microsoftTeamsWebhookUrl":
            suggest = "microsoft_teams_webhook_url"
        elif key == "mobileNumber":
            suggest = "mobile_number"
        elif key == "notifierId":
            suggest = "notifier_id"
        elif key == "opsGenieApiKey":
            suggest = "ops_genie_api_key"
        elif key == "opsGenieRegion":
            suggest = "ops_genie_region"
        elif key == "serviceKey":
            suggest = "service_key"
        elif key == "smsEnabled":
            suggest = "sms_enabled"
        elif key == "teamId":
            suggest = "team_id"
        elif key == "teamName":
            suggest = "team_name"
        elif key == "victorOpsApiKey":
            suggest = "victor_ops_api_key"
        elif key == "victorOpsRoutingKey":
            suggest = "victor_ops_routing_key"
        elif key == "webhookSecret":
            suggest = "webhook_secret"
        elif key == "webhookUrl":
            suggest = "webhook_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertConfigurationNotification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertConfigurationNotification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertConfigurationNotification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type_name: str,
                 api_token: Optional[str] = None,
                 channel_name: Optional[str] = None,
                 datadog_api_key: Optional[str] = None,
                 datadog_region: Optional[str] = None,
                 delay_min: Optional[int] = None,
                 email_address: Optional[str] = None,
                 email_enabled: Optional[bool] = None,
                 integration_id: Optional[str] = None,
                 interval_min: Optional[int] = None,
                 microsoft_teams_webhook_url: Optional[str] = None,
                 mobile_number: Optional[str] = None,
                 notifier_id: Optional[str] = None,
                 ops_genie_api_key: Optional[str] = None,
                 ops_genie_region: Optional[str] = None,
                 roles: Optional[Sequence[str]] = None,
                 service_key: Optional[str] = None,
                 sms_enabled: Optional[bool] = None,
                 team_id: Optional[str] = None,
                 team_name: Optional[str] = None,
                 username: Optional[str] = None,
                 victor_ops_api_key: Optional[str] = None,
                 victor_ops_routing_key: Optional[str] = None,
                 webhook_secret: Optional[str] = None,
                 webhook_url: Optional[str] = None):
        """
        :param str type_name: Type of alert notification.
               Accepted values are:
               - `DATADOG`
               - `EMAIL`
               - `GROUP` (Project)
               - `OPS_GENIE`
               - `ORG`
               - `PAGER_DUTY`
               - `SLACK`
               - `SMS`
               - `TEAM`
               - `USER`
               - `VICTOR_OPS`
               - `WEBHOOK`
               - `MICROSOFT_TEAMS`
        :param str api_token: Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param str channel_name: Slack channel name. Required for the SLACK notifications type.
        :param str datadog_api_key: Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        :param str datadog_region: Region that indicates which API URL to use. See the `datadogRegion` field in the `notifications` request parameter of [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Alert-Configurations/operation/createAlertConfiguration) for more details. The default Datadog region is US.
        :param int delay_min: Number of minutes to wait after an alert condition is detected before sending out the first notification.
        :param str email_address: Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        :param bool email_enabled: Flag indicating email notifications should be sent. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        :param str integration_id: The ID of the associated integration, the credentials of which to use for requests.
        :param int interval_min: Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5. **NOTE** `PAGER_DUTY`, `VICTOR_OPS`, and `OPS_GENIE` notifications do not return this value. The notification interval must be configured and managed within each external service.
        :param str microsoft_teams_webhook_url: Microsoft Teams Webhook Uniform Resource Locator (URL) that MongoDB Cloud needs to send this notification via Microsoft Teams. Required if `type_name` is `MICROSOFT_TEAMS`. If the URL later becomes invalid, MongoDB Cloud sends an email to the project owners. If the key remains invalid, MongoDB Cloud removes it.
        :param str mobile_number: Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        :param str notifier_id: The notifier ID is a system-generated unique identifier assigned to each notification method. This is needed when updating third-party notifications without requiring explicit authentication credentials.
        :param str ops_genie_api_key: Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param str ops_genie_region: Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        :param Sequence[str] roles: Optional. One or more roles that receive the configured alert. If you include this field, Atlas sends alerts only to users assigned the roles you specify in the array. If you omit this field, Atlas sends alerts to users assigned any role. This parameter is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
               Accepted values are:
               
               | Project roles                   | Organization roles  |
               |:----------                      |:-----------         |
               | `GROUP_CLUSTER_MANAGER`         | `ORG_OWNER`         |
               | `GROUP_DATA_ACCESS_ADMIN`       | `ORG_MEMBER`        |
               | `GROUP_DATA_ACCESS_READ_ONLY`   | `ORG_GROUP_CREATOR` |
               | `GROUP_DATA_ACCESS_READ_WRITE`  | `ORG_BILLING_ADMIN` |
               | `GROUP_OWNER`                   | `ORG_READ_ONLY`     |
               | `GROUP_READ_ONLY`               |                     |
        :param str service_key: PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param bool sms_enabled: Flag indicating if text message notifications should be sent to this user's mobile phone. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        :param str team_id: Unique identifier of a team.
        :param str team_name: Label for the team that receives this notification.
        :param str username: Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        :param str victor_ops_api_key: VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param str victor_ops_routing_key: VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param str webhook_secret: Optional authentication secret for the `WEBHOOK` notifications type.
        :param str webhook_url: Target URL  for the `WEBHOOK` notifications type.
        """
        pulumi.set(__self__, "type_name", type_name)
        if api_token is not None:
            pulumi.set(__self__, "api_token", api_token)
        if channel_name is not None:
            pulumi.set(__self__, "channel_name", channel_name)
        if datadog_api_key is not None:
            pulumi.set(__self__, "datadog_api_key", datadog_api_key)
        if datadog_region is not None:
            pulumi.set(__self__, "datadog_region", datadog_region)
        if delay_min is not None:
            pulumi.set(__self__, "delay_min", delay_min)
        if email_address is not None:
            pulumi.set(__self__, "email_address", email_address)
        if email_enabled is not None:
            pulumi.set(__self__, "email_enabled", email_enabled)
        if integration_id is not None:
            pulumi.set(__self__, "integration_id", integration_id)
        if interval_min is not None:
            pulumi.set(__self__, "interval_min", interval_min)
        if microsoft_teams_webhook_url is not None:
            pulumi.set(__self__, "microsoft_teams_webhook_url", microsoft_teams_webhook_url)
        if mobile_number is not None:
            pulumi.set(__self__, "mobile_number", mobile_number)
        if notifier_id is not None:
            pulumi.set(__self__, "notifier_id", notifier_id)
        if ops_genie_api_key is not None:
            pulumi.set(__self__, "ops_genie_api_key", ops_genie_api_key)
        if ops_genie_region is not None:
            pulumi.set(__self__, "ops_genie_region", ops_genie_region)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)
        if service_key is not None:
            pulumi.set(__self__, "service_key", service_key)
        if sms_enabled is not None:
            pulumi.set(__self__, "sms_enabled", sms_enabled)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)
        if team_name is not None:
            pulumi.set(__self__, "team_name", team_name)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if victor_ops_api_key is not None:
            pulumi.set(__self__, "victor_ops_api_key", victor_ops_api_key)
        if victor_ops_routing_key is not None:
            pulumi.set(__self__, "victor_ops_routing_key", victor_ops_routing_key)
        if webhook_secret is not None:
            pulumi.set(__self__, "webhook_secret", webhook_secret)
        if webhook_url is not None:
            pulumi.set(__self__, "webhook_url", webhook_url)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        """
        Type of alert notification.
        Accepted values are:
        - `DATADOG`
        - `EMAIL`
        - `GROUP` (Project)
        - `OPS_GENIE`
        - `ORG`
        - `PAGER_DUTY`
        - `SLACK`
        - `SMS`
        - `TEAM`
        - `USER`
        - `VICTOR_OPS`
        - `WEBHOOK`
        - `MICROSOFT_TEAMS`
        """
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional[str]:
        """
        Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> Optional[str]:
        """
        Slack channel name. Required for the SLACK notifications type.
        """
        return pulumi.get(self, "channel_name")

    @property
    @pulumi.getter(name="datadogApiKey")
    def datadog_api_key(self) -> Optional[str]:
        """
        Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        """
        return pulumi.get(self, "datadog_api_key")

    @property
    @pulumi.getter(name="datadogRegion")
    def datadog_region(self) -> Optional[str]:
        """
        Region that indicates which API URL to use. See the `datadogRegion` field in the `notifications` request parameter of [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Alert-Configurations/operation/createAlertConfiguration) for more details. The default Datadog region is US.
        """
        return pulumi.get(self, "datadog_region")

    @property
    @pulumi.getter(name="delayMin")
    def delay_min(self) -> Optional[int]:
        """
        Number of minutes to wait after an alert condition is detected before sending out the first notification.
        """
        return pulumi.get(self, "delay_min")

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> Optional[str]:
        """
        Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter(name="emailEnabled")
    def email_enabled(self) -> Optional[bool]:
        """
        Flag indicating email notifications should be sent. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        """
        return pulumi.get(self, "email_enabled")

    @property
    @pulumi.getter(name="integrationId")
    def integration_id(self) -> Optional[str]:
        """
        The ID of the associated integration, the credentials of which to use for requests.
        """
        return pulumi.get(self, "integration_id")

    @property
    @pulumi.getter(name="intervalMin")
    def interval_min(self) -> Optional[int]:
        """
        Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5. **NOTE** `PAGER_DUTY`, `VICTOR_OPS`, and `OPS_GENIE` notifications do not return this value. The notification interval must be configured and managed within each external service.
        """
        return pulumi.get(self, "interval_min")

    @property
    @pulumi.getter(name="microsoftTeamsWebhookUrl")
    def microsoft_teams_webhook_url(self) -> Optional[str]:
        """
        Microsoft Teams Webhook Uniform Resource Locator (URL) that MongoDB Cloud needs to send this notification via Microsoft Teams. Required if `type_name` is `MICROSOFT_TEAMS`. If the URL later becomes invalid, MongoDB Cloud sends an email to the project owners. If the key remains invalid, MongoDB Cloud removes it.
        """
        return pulumi.get(self, "microsoft_teams_webhook_url")

    @property
    @pulumi.getter(name="mobileNumber")
    def mobile_number(self) -> Optional[str]:
        """
        Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        """
        return pulumi.get(self, "mobile_number")

    @property
    @pulumi.getter(name="notifierId")
    def notifier_id(self) -> Optional[str]:
        """
        The notifier ID is a system-generated unique identifier assigned to each notification method. This is needed when updating third-party notifications without requiring explicit authentication credentials.
        """
        return pulumi.get(self, "notifier_id")

    @property
    @pulumi.getter(name="opsGenieApiKey")
    def ops_genie_api_key(self) -> Optional[str]:
        """
        Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "ops_genie_api_key")

    @property
    @pulumi.getter(name="opsGenieRegion")
    def ops_genie_region(self) -> Optional[str]:
        """
        Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        """
        return pulumi.get(self, "ops_genie_region")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        """
        Optional. One or more roles that receive the configured alert. If you include this field, Atlas sends alerts only to users assigned the roles you specify in the array. If you omit this field, Atlas sends alerts to users assigned any role. This parameter is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        Accepted values are:

        | Project roles                   | Organization roles  |
        |:----------                      |:-----------         |
        | `GROUP_CLUSTER_MANAGER`         | `ORG_OWNER`         |
        | `GROUP_DATA_ACCESS_ADMIN`       | `ORG_MEMBER`        |
        | `GROUP_DATA_ACCESS_READ_ONLY`   | `ORG_GROUP_CREATOR` |
        | `GROUP_DATA_ACCESS_READ_WRITE`  | `ORG_BILLING_ADMIN` |
        | `GROUP_OWNER`                   | `ORG_READ_ONLY`     |
        | `GROUP_READ_ONLY`               |                     |
        """
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter(name="serviceKey")
    def service_key(self) -> Optional[str]:
        """
        PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "service_key")

    @property
    @pulumi.getter(name="smsEnabled")
    def sms_enabled(self) -> Optional[bool]:
        """
        Flag indicating if text message notifications should be sent to this user's mobile phone. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        """
        return pulumi.get(self, "sms_enabled")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[str]:
        """
        Unique identifier of a team.
        """
        return pulumi.get(self, "team_id")

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> Optional[str]:
        """
        Label for the team that receives this notification.
        """
        return pulumi.get(self, "team_name")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="victorOpsApiKey")
    def victor_ops_api_key(self) -> Optional[str]:
        """
        VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "victor_ops_api_key")

    @property
    @pulumi.getter(name="victorOpsRoutingKey")
    def victor_ops_routing_key(self) -> Optional[str]:
        """
        VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "victor_ops_routing_key")

    @property
    @pulumi.getter(name="webhookSecret")
    def webhook_secret(self) -> Optional[str]:
        """
        Optional authentication secret for the `WEBHOOK` notifications type.
        """
        return pulumi.get(self, "webhook_secret")

    @property
    @pulumi.getter(name="webhookUrl")
    def webhook_url(self) -> Optional[str]:
        """
        Target URL  for the `WEBHOOK` notifications type.
        """
        return pulumi.get(self, "webhook_url")


@pulumi.output_type
class AlertConfigurationThresholdConfig(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 threshold: Optional[float] = None,
                 units: Optional[str] = None):
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if units is not None:
            pulumi.set(__self__, "units", units)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def units(self) -> Optional[str]:
        return pulumi.get(self, "units")


@pulumi.output_type
class BackupCompliancePolicyOnDemandPolicyItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupCompliancePolicyOnDemandPolicyItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupCompliancePolicyOnDemandPolicyItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupCompliancePolicyOnDemandPolicyItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 retention_unit: str,
                 retention_value: int,
                 frequency_type: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        :param str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class BackupCompliancePolicyPolicyItemDaily(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupCompliancePolicyPolicyItemDaily. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupCompliancePolicyPolicyItemDaily.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupCompliancePolicyPolicyItemDaily.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 retention_unit: str,
                 retention_value: int,
                 frequency_type: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        :param str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class BackupCompliancePolicyPolicyItemHourly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupCompliancePolicyPolicyItemHourly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupCompliancePolicyPolicyItemHourly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupCompliancePolicyPolicyItemHourly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 retention_unit: str,
                 retention_value: int,
                 frequency_type: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        :param str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class BackupCompliancePolicyPolicyItemMonthly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupCompliancePolicyPolicyItemMonthly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupCompliancePolicyPolicyItemMonthly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupCompliancePolicyPolicyItemMonthly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 retention_unit: str,
                 retention_value: int,
                 frequency_type: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        :param str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class BackupCompliancePolicyPolicyItemWeekly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupCompliancePolicyPolicyItemWeekly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupCompliancePolicyPolicyItemWeekly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupCompliancePolicyPolicyItemWeekly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 retention_unit: str,
                 retention_value: int,
                 frequency_type: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        :param str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class BackupCompliancePolicyPolicyItemYearly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BackupCompliancePolicyPolicyItemYearly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BackupCompliancePolicyPolicyItemYearly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BackupCompliancePolicyPolicyItemYearly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 retention_unit: str,
                 retention_value: int,
                 frequency_type: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        :param str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class CloudBackupScheduleCopySetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudProvider":
            suggest = "cloud_provider"
        elif key == "regionName":
            suggest = "region_name"
        elif key == "replicationSpecId":
            suggest = "replication_spec_id"
        elif key == "shouldCopyOplogs":
            suggest = "should_copy_oplogs"
        elif key == "zoneId":
            suggest = "zone_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupScheduleCopySetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupScheduleCopySetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupScheduleCopySetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_provider: Optional[str] = None,
                 frequencies: Optional[Sequence[str]] = None,
                 region_name: Optional[str] = None,
                 replication_spec_id: Optional[str] = None,
                 should_copy_oplogs: Optional[bool] = None,
                 zone_id: Optional[str] = None):
        """
        :param str cloud_provider: Human-readable label that identifies the cloud provider that stores the snapshot copy. i.e. "AWS" "AZURE" "GCP"
        :param Sequence[str] frequencies: List that describes which types of snapshots to copy. i.e. "HOURLY" "DAILY" "WEEKLY" "MONTHLY" "ON_DEMAND"
        :param str region_name: Target region to copy snapshots belonging to replicationSpecId to. Please supply the 'Atlas Region' which can be found under https://www.mongodb.com/docs/atlas/reference/cloud-providers/ 'regions' link
        :param str replication_spec_id: Unique 24-hexadecimal digit string that identifies the replication object for a zone in a cluster. For global clusters, there can be multiple zones to choose from. For sharded clusters and replica set clusters, there is only one zone in the cluster. To find the Replication Spec Id, consult the replicationSpecs array returned from [Return One Multi-Cloud Cluster in One Project](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Clusters/operation/getCluster). **(DEPRECATED)** Use `zone_id` instead. To learn more, see the 1.18.0 upgrade guide.
        :param bool should_copy_oplogs: Flag that indicates whether to copy the oplogs to the target region. You can use the oplogs to perform point-in-time restores.
        :param str zone_id: Unique 24-hexadecimal digit string that identifies the zone in a cluster. For global clusters, there can be multiple zones to choose from. For sharded clusters and replica set clusters, there is only one zone in the cluster. To find appropriate value for `zone_id`, do a GET request to Return One Cluster from One Project and consult the replicationSpecs array Return One Cluster From One Project. Alternately, use `AdvancedCluster` data source or resource and reference `replication_specs.#.zone_id`.
        """
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if frequencies is not None:
            pulumi.set(__self__, "frequencies", frequencies)
        if region_name is not None:
            pulumi.set(__self__, "region_name", region_name)
        if replication_spec_id is not None:
            pulumi.set(__self__, "replication_spec_id", replication_spec_id)
        if should_copy_oplogs is not None:
            pulumi.set(__self__, "should_copy_oplogs", should_copy_oplogs)
        if zone_id is not None:
            pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[str]:
        """
        Human-readable label that identifies the cloud provider that stores the snapshot copy. i.e. "AWS" "AZURE" "GCP"
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def frequencies(self) -> Optional[Sequence[str]]:
        """
        List that describes which types of snapshots to copy. i.e. "HOURLY" "DAILY" "WEEKLY" "MONTHLY" "ON_DEMAND"
        """
        return pulumi.get(self, "frequencies")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> Optional[str]:
        """
        Target region to copy snapshots belonging to replicationSpecId to. Please supply the 'Atlas Region' which can be found under https://www.mongodb.com/docs/atlas/reference/cloud-providers/ 'regions' link
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter(name="replicationSpecId")
    @_utilities.deprecated("""This parameter is deprecated. Please transition to `copy_settings.#.zone_id`. To learn more, see our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
    def replication_spec_id(self) -> Optional[str]:
        """
        Unique 24-hexadecimal digit string that identifies the replication object for a zone in a cluster. For global clusters, there can be multiple zones to choose from. For sharded clusters and replica set clusters, there is only one zone in the cluster. To find the Replication Spec Id, consult the replicationSpecs array returned from [Return One Multi-Cloud Cluster in One Project](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Clusters/operation/getCluster). **(DEPRECATED)** Use `zone_id` instead. To learn more, see the 1.18.0 upgrade guide.
        """
        return pulumi.get(self, "replication_spec_id")

    @property
    @pulumi.getter(name="shouldCopyOplogs")
    def should_copy_oplogs(self) -> Optional[bool]:
        """
        Flag that indicates whether to copy the oplogs to the target region. You can use the oplogs to perform point-in-time restores.
        """
        return pulumi.get(self, "should_copy_oplogs")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> Optional[str]:
        """
        Unique 24-hexadecimal digit string that identifies the zone in a cluster. For global clusters, there can be multiple zones to choose from. For sharded clusters and replica set clusters, there is only one zone in the cluster. To find appropriate value for `zone_id`, do a GET request to Return One Cluster from One Project and consult the replicationSpecs array Return One Cluster From One Project. Alternately, use `AdvancedCluster` data source or resource and reference `replication_specs.#.zone_id`.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class CloudBackupScheduleExport(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportBucketId":
            suggest = "export_bucket_id"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupScheduleExport. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupScheduleExport.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupScheduleExport.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_bucket_id: Optional[str] = None,
                 frequency_type: Optional[str] = None):
        """
        :param str export_bucket_id: Unique identifier of the CloudBackupSnapshotExportBucket export_bucket_id value.
        :param str frequency_type: Frequency associated with the export snapshot item.
        """
        if export_bucket_id is not None:
            pulumi.set(__self__, "export_bucket_id", export_bucket_id)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)

    @property
    @pulumi.getter(name="exportBucketId")
    def export_bucket_id(self) -> Optional[str]:
        """
        Unique identifier of the CloudBackupSnapshotExportBucket export_bucket_id value.
        """
        return pulumi.get(self, "export_bucket_id")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        """
        Frequency associated with the export snapshot item.
        """
        return pulumi.get(self, "frequency_type")


@pulumi.output_type
class CloudBackupSchedulePolicyItemDaily(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSchedulePolicyItemDaily. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSchedulePolicyItemDaily.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSchedulePolicyItemDaily.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 retention_unit: str,
                 retention_value: int,
                 frequency_type: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (daily in this case). The only supported value for daily policies is `1` day.
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param int retention_value: Value to associate with `retention_unit`.  Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the hourly policy item specifies a retention of two days, the daily retention policy must specify two days or greater.
        :param str frequency_type: Frequency associated with the backup policy item. For daily policies, the frequency type is defined as `daily`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (daily in this case). The only supported value for daily policies is `1` day.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`.  Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the hourly policy item specifies a retention of two days, the daily retention policy must specify two days or greater.
        """
        return pulumi.get(self, "retention_value")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        """
        Frequency associated with the backup policy item. For daily policies, the frequency type is defined as `daily`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class CloudBackupSchedulePolicyItemHourly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSchedulePolicyItemHourly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSchedulePolicyItemHourly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSchedulePolicyItemHourly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 retention_unit: str,
                 retention_value: int,
                 frequency_type: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (hourly in this case). The supported values for hourly policies are `1`, `2`, `4`, `6`, `8` or `12` hours. Note that `12` hours is the only accepted value for NVMe clusters.
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param int retention_value: Value to associate with `retention_unit`.
        :param str frequency_type: Frequency associated with the backup policy item. For hourly policies, the frequency type is defined as `hourly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (hourly in this case). The supported values for hourly policies are `1`, `2`, `4`, `6`, `8` or `12` hours. Note that `12` hours is the only accepted value for NVMe clusters.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`.
        """
        return pulumi.get(self, "retention_value")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        """
        Frequency associated with the backup policy item. For hourly policies, the frequency type is defined as `hourly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class CloudBackupSchedulePolicyItemMonthly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSchedulePolicyItemMonthly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSchedulePolicyItemMonthly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSchedulePolicyItemMonthly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 retention_unit: str,
                 retention_value: int,
                 frequency_type: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param int retention_value: Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        :param str frequency_type: Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (monthly in this case). The supported values for weekly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Monthly policy must have retention days of at least 31 days or 5 weeks or 1 month. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the weekly policy item specifies a retention of two weeks, the montly retention policy must specify two weeks or greater.
        """
        return pulumi.get(self, "retention_value")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        """
        Frequency associated with the backup policy item. For monthly policies, the frequency type is defined as `monthly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class CloudBackupSchedulePolicyItemWeekly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSchedulePolicyItemWeekly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSchedulePolicyItemWeekly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSchedulePolicyItemWeekly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 retention_unit: str,
                 retention_value: int,
                 frequency_type: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (weekly in this case). The supported values for weekly policies are `1` through `7`, where `1` represents Monday and `7` represents Sunday.
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param int retention_value: Value to associate with `retention_unit`. Weekly policy must have retention of at least 7 days or 1 week. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the daily policy item specifies a retention of two weeks, the weekly retention policy must specify two weeks or greater.
        :param str frequency_type: Frequency associated with the backup policy item. For weekly policies, the frequency type is defined as `weekly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (weekly in this case). The supported values for weekly policies are `1` through `7`, where `1` represents Monday and `7` represents Sunday.
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Weekly policy must have retention of at least 7 days or 1 week. Note that for less frequent policy items, Atlas requires that you specify a retention period greater than or equal to the retention period specified for more frequent policy items. For example: If the daily policy item specifies a retention of two weeks, the weekly retention policy must specify two weeks or greater.
        """
        return pulumi.get(self, "retention_value")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        """
        Frequency associated with the backup policy item. For weekly policies, the frequency type is defined as `weekly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class CloudBackupSchedulePolicyItemYearly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"
        elif key == "frequencyType":
            suggest = "frequency_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSchedulePolicyItemYearly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSchedulePolicyItemYearly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSchedulePolicyItemYearly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: int,
                 retention_unit: str,
                 retention_value: int,
                 frequency_type: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        :param str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class CloudBackupSnapshotExportJobComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportId":
            suggest = "export_id"
        elif key == "replicaSetName":
            suggest = "replica_set_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSnapshotExportJobComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSnapshotExportJobComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSnapshotExportJobComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_id: Optional[str] = None,
                 replica_set_name: Optional[str] = None):
        """
        :param str export_id: _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        :param str replica_set_name: _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
        if export_id is not None:
            pulumi.set(__self__, "export_id", export_id)
        if replica_set_name is not None:
            pulumi.set(__self__, "replica_set_name", replica_set_name)

    @property
    @pulumi.getter(name="exportId")
    def export_id(self) -> Optional[str]:
        """
        _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        """
        return pulumi.get(self, "export_id")

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> Optional[str]:
        """
        _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
        return pulumi.get(self, "replica_set_name")


@pulumi.output_type
class CloudBackupSnapshotExportJobCustomData(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Required if you want to include custom data using `custom_data` in the metadata file uploaded to the bucket. Key to include in the metadata file that Atlas uploads to the bucket when the export job finishes.
        :param str value: Required if you specify `key`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Required if you want to include custom data using `custom_data` in the metadata file uploaded to the bucket. Key to include in the metadata file that Atlas uploads to the bucket when the export job finishes.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Required if you specify `key`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CloudBackupSnapshotMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudProvider":
            suggest = "cloud_provider"
        elif key == "replicaSetName":
            suggest = "replica_set_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSnapshotMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSnapshotMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSnapshotMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_provider: Optional[str] = None,
                 id: Optional[str] = None,
                 replica_set_name: Optional[str] = None):
        """
        :param str cloud_provider: Cloud provider that stores this snapshot.
        :param str id: Unique identifier for the sharded cluster snapshot.
        :param str replica_set_name: Label given to a shard or config server from which Atlas took this snapshot.
        """
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if replica_set_name is not None:
            pulumi.set(__self__, "replica_set_name", replica_set_name)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[str]:
        """
        Cloud provider that stores this snapshot.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier for the sharded cluster snapshot.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> Optional[str]:
        """
        Label given to a shard or config server from which Atlas took this snapshot.
        """
        return pulumi.get(self, "replica_set_name")


@pulumi.output_type
class CloudBackupSnapshotRestoreJobDeliveryTypeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oplogInc":
            suggest = "oplog_inc"
        elif key == "oplogTs":
            suggest = "oplog_ts"
        elif key == "pointInTime":
            suggest = "point_in_time"
        elif key == "pointInTimeUtcSeconds":
            suggest = "point_in_time_utc_seconds"
        elif key == "targetClusterName":
            suggest = "target_cluster_name"
        elif key == "targetProjectId":
            suggest = "target_project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudBackupSnapshotRestoreJobDeliveryTypeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudBackupSnapshotRestoreJobDeliveryTypeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudBackupSnapshotRestoreJobDeliveryTypeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automated: Optional[bool] = None,
                 download: Optional[bool] = None,
                 oplog_inc: Optional[int] = None,
                 oplog_ts: Optional[int] = None,
                 point_in_time: Optional[bool] = None,
                 point_in_time_utc_seconds: Optional[int] = None,
                 target_cluster_name: Optional[str] = None,
                 target_project_id: Optional[str] = None):
        """
        :param str target_cluster_name: Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.
        :param str target_project_id: Name of the target Atlas project of the restore job. Only visible if deliveryType is automated.
        """
        if automated is not None:
            pulumi.set(__self__, "automated", automated)
        if download is not None:
            pulumi.set(__self__, "download", download)
        if oplog_inc is not None:
            pulumi.set(__self__, "oplog_inc", oplog_inc)
        if oplog_ts is not None:
            pulumi.set(__self__, "oplog_ts", oplog_ts)
        if point_in_time is not None:
            pulumi.set(__self__, "point_in_time", point_in_time)
        if point_in_time_utc_seconds is not None:
            pulumi.set(__self__, "point_in_time_utc_seconds", point_in_time_utc_seconds)
        if target_cluster_name is not None:
            pulumi.set(__self__, "target_cluster_name", target_cluster_name)
        if target_project_id is not None:
            pulumi.set(__self__, "target_project_id", target_project_id)

    @property
    @pulumi.getter
    def automated(self) -> Optional[bool]:
        return pulumi.get(self, "automated")

    @property
    @pulumi.getter
    def download(self) -> Optional[bool]:
        return pulumi.get(self, "download")

    @property
    @pulumi.getter(name="oplogInc")
    def oplog_inc(self) -> Optional[int]:
        return pulumi.get(self, "oplog_inc")

    @property
    @pulumi.getter(name="oplogTs")
    def oplog_ts(self) -> Optional[int]:
        return pulumi.get(self, "oplog_ts")

    @property
    @pulumi.getter(name="pointInTime")
    def point_in_time(self) -> Optional[bool]:
        return pulumi.get(self, "point_in_time")

    @property
    @pulumi.getter(name="pointInTimeUtcSeconds")
    def point_in_time_utc_seconds(self) -> Optional[int]:
        return pulumi.get(self, "point_in_time_utc_seconds")

    @property
    @pulumi.getter(name="targetClusterName")
    def target_cluster_name(self) -> Optional[str]:
        """
        Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.
        """
        return pulumi.get(self, "target_cluster_name")

    @property
    @pulumi.getter(name="targetProjectId")
    def target_project_id(self) -> Optional[str]:
        """
        Name of the target Atlas project of the restore job. Only visible if deliveryType is automated.
        """
        return pulumi.get(self, "target_project_id")


@pulumi.output_type
class CloudProviderAccessAuthorizationAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iamAssumedRoleArn":
            suggest = "iam_assumed_role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudProviderAccessAuthorizationAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudProviderAccessAuthorizationAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudProviderAccessAuthorizationAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iam_assumed_role_arn: str):
        pulumi.set(__self__, "iam_assumed_role_arn", iam_assumed_role_arn)

    @property
    @pulumi.getter(name="iamAssumedRoleArn")
    def iam_assumed_role_arn(self) -> str:
        return pulumi.get(self, "iam_assumed_role_arn")


@pulumi.output_type
class CloudProviderAccessAuthorizationAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "atlasAzureAppId":
            suggest = "atlas_azure_app_id"
        elif key == "servicePrincipalId":
            suggest = "service_principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudProviderAccessAuthorizationAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudProviderAccessAuthorizationAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudProviderAccessAuthorizationAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 atlas_azure_app_id: str,
                 service_principal_id: str,
                 tenant_id: str):
        pulumi.set(__self__, "atlas_azure_app_id", atlas_azure_app_id)
        pulumi.set(__self__, "service_principal_id", service_principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="atlasAzureAppId")
    def atlas_azure_app_id(self) -> str:
        return pulumi.get(self, "atlas_azure_app_id")

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> str:
        return pulumi.get(self, "service_principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class CloudProviderAccessAuthorizationFeatureUsage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "featureId":
            suggest = "feature_id"
        elif key == "featureType":
            suggest = "feature_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudProviderAccessAuthorizationFeatureUsage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudProviderAccessAuthorizationFeatureUsage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudProviderAccessAuthorizationFeatureUsage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 feature_id: Optional[Mapping[str, str]] = None,
                 feature_type: Optional[str] = None):
        if feature_id is not None:
            pulumi.set(__self__, "feature_id", feature_id)
        if feature_type is not None:
            pulumi.set(__self__, "feature_type", feature_type)

    @property
    @pulumi.getter(name="featureId")
    def feature_id(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "feature_id")

    @property
    @pulumi.getter(name="featureType")
    def feature_type(self) -> Optional[str]:
        return pulumi.get(self, "feature_type")


@pulumi.output_type
class CloudProviderAccessSetupAwsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "atlasAssumedRoleExternalId":
            suggest = "atlas_assumed_role_external_id"
        elif key == "atlasAwsAccountArn":
            suggest = "atlas_aws_account_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudProviderAccessSetupAwsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudProviderAccessSetupAwsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudProviderAccessSetupAwsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 atlas_assumed_role_external_id: Optional[str] = None,
                 atlas_aws_account_arn: Optional[str] = None):
        if atlas_assumed_role_external_id is not None:
            pulumi.set(__self__, "atlas_assumed_role_external_id", atlas_assumed_role_external_id)
        if atlas_aws_account_arn is not None:
            pulumi.set(__self__, "atlas_aws_account_arn", atlas_aws_account_arn)

    @property
    @pulumi.getter(name="atlasAssumedRoleExternalId")
    def atlas_assumed_role_external_id(self) -> Optional[str]:
        return pulumi.get(self, "atlas_assumed_role_external_id")

    @property
    @pulumi.getter(name="atlasAwsAccountArn")
    def atlas_aws_account_arn(self) -> Optional[str]:
        return pulumi.get(self, "atlas_aws_account_arn")


@pulumi.output_type
class CloudProviderAccessSetupAzureConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "atlasAzureAppId":
            suggest = "atlas_azure_app_id"
        elif key == "servicePrincipalId":
            suggest = "service_principal_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudProviderAccessSetupAzureConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudProviderAccessSetupAzureConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudProviderAccessSetupAzureConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 atlas_azure_app_id: str,
                 service_principal_id: str,
                 tenant_id: str):
        pulumi.set(__self__, "atlas_azure_app_id", atlas_azure_app_id)
        pulumi.set(__self__, "service_principal_id", service_principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="atlasAzureAppId")
    def atlas_azure_app_id(self) -> str:
        return pulumi.get(self, "atlas_azure_app_id")

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> str:
        return pulumi.get(self, "service_principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class ClusterAdvancedConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "changeStreamOptionsPreAndPostImagesExpireAfterSeconds":
            suggest = "change_stream_options_pre_and_post_images_expire_after_seconds"
        elif key == "defaultReadConcern":
            suggest = "default_read_concern"
        elif key == "defaultWriteConcern":
            suggest = "default_write_concern"
        elif key == "failIndexKeyTooLong":
            suggest = "fail_index_key_too_long"
        elif key == "javascriptEnabled":
            suggest = "javascript_enabled"
        elif key == "minimumEnabledTlsProtocol":
            suggest = "minimum_enabled_tls_protocol"
        elif key == "noTableScan":
            suggest = "no_table_scan"
        elif key == "oplogMinRetentionHours":
            suggest = "oplog_min_retention_hours"
        elif key == "oplogSizeMb":
            suggest = "oplog_size_mb"
        elif key == "sampleRefreshIntervalBiConnector":
            suggest = "sample_refresh_interval_bi_connector"
        elif key == "sampleSizeBiConnector":
            suggest = "sample_size_bi_connector"
        elif key == "transactionLifetimeLimitSeconds":
            suggest = "transaction_lifetime_limit_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAdvancedConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAdvancedConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAdvancedConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 change_stream_options_pre_and_post_images_expire_after_seconds: Optional[int] = None,
                 default_read_concern: Optional[str] = None,
                 default_write_concern: Optional[str] = None,
                 fail_index_key_too_long: Optional[bool] = None,
                 javascript_enabled: Optional[bool] = None,
                 minimum_enabled_tls_protocol: Optional[str] = None,
                 no_table_scan: Optional[bool] = None,
                 oplog_min_retention_hours: Optional[float] = None,
                 oplog_size_mb: Optional[int] = None,
                 sample_refresh_interval_bi_connector: Optional[int] = None,
                 sample_size_bi_connector: Optional[int] = None,
                 transaction_lifetime_limit_seconds: Optional[int] = None):
        """
        :param int change_stream_options_pre_and_post_images_expire_after_seconds: The minimum pre- and post-image retention time in seconds. This option corresponds to the `changeStreamOptions.preAndPostImages.expireAfterSeconds` cluster parameter. Defaults to `-1`(off). This setting controls the retention policy of change stream pre- and post-images. Pre- and post-images are the versions of a document before and after document modification, respectively.`expireAfterSeconds` controls how long MongoDB retains pre- and post-images. When set to -1 (off), MongoDB uses the default retention policy: pre- and post-images are retained until the corresponding change stream events are removed from the oplog. To set the minimum pre- and post-image retention time, specify an integer value greater than zero. Setting this too low could increase the risk of interrupting Realm sync or triggers processing. This parameter is only supported for MongoDB version 6.0 and above.
        :param str default_read_concern: [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        :param str default_write_concern: [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        :param bool fail_index_key_too_long: When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        :param bool javascript_enabled: When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        :param str minimum_enabled_tls_protocol: Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
               
               - TLS1_0
               - TLS1_1
               - TLS1_2
        :param bool no_table_scan: When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        :param float oplog_min_retention_hours: Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
               * **Note**  A minimum oplog retention is required when seeking to change a cluster's class to Local NVMe SSD. To learn more and for latest guidance see  [`oplogMinRetentionHours`](https://www.mongodb.com/docs/manual/core/replica-set-oplog/#std-label-replica-set-minimum-oplog-size)
        :param int oplog_size_mb: The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        :param int sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param int sample_size_bi_connector: Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param int transaction_lifetime_limit_seconds: Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        if change_stream_options_pre_and_post_images_expire_after_seconds is not None:
            pulumi.set(__self__, "change_stream_options_pre_and_post_images_expire_after_seconds", change_stream_options_pre_and_post_images_expire_after_seconds)
        if default_read_concern is not None:
            pulumi.set(__self__, "default_read_concern", default_read_concern)
        if default_write_concern is not None:
            pulumi.set(__self__, "default_write_concern", default_write_concern)
        if fail_index_key_too_long is not None:
            pulumi.set(__self__, "fail_index_key_too_long", fail_index_key_too_long)
        if javascript_enabled is not None:
            pulumi.set(__self__, "javascript_enabled", javascript_enabled)
        if minimum_enabled_tls_protocol is not None:
            pulumi.set(__self__, "minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        if no_table_scan is not None:
            pulumi.set(__self__, "no_table_scan", no_table_scan)
        if oplog_min_retention_hours is not None:
            pulumi.set(__self__, "oplog_min_retention_hours", oplog_min_retention_hours)
        if oplog_size_mb is not None:
            pulumi.set(__self__, "oplog_size_mb", oplog_size_mb)
        if sample_refresh_interval_bi_connector is not None:
            pulumi.set(__self__, "sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        if sample_size_bi_connector is not None:
            pulumi.set(__self__, "sample_size_bi_connector", sample_size_bi_connector)
        if transaction_lifetime_limit_seconds is not None:
            pulumi.set(__self__, "transaction_lifetime_limit_seconds", transaction_lifetime_limit_seconds)

    @property
    @pulumi.getter(name="changeStreamOptionsPreAndPostImagesExpireAfterSeconds")
    def change_stream_options_pre_and_post_images_expire_after_seconds(self) -> Optional[int]:
        """
        The minimum pre- and post-image retention time in seconds. This option corresponds to the `changeStreamOptions.preAndPostImages.expireAfterSeconds` cluster parameter. Defaults to `-1`(off). This setting controls the retention policy of change stream pre- and post-images. Pre- and post-images are the versions of a document before and after document modification, respectively.`expireAfterSeconds` controls how long MongoDB retains pre- and post-images. When set to -1 (off), MongoDB uses the default retention policy: pre- and post-images are retained until the corresponding change stream events are removed from the oplog. To set the minimum pre- and post-image retention time, specify an integer value greater than zero. Setting this too low could increase the risk of interrupting Realm sync or triggers processing. This parameter is only supported for MongoDB version 6.0 and above.
        """
        return pulumi.get(self, "change_stream_options_pre_and_post_images_expire_after_seconds")

    @property
    @pulumi.getter(name="defaultReadConcern")
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
    def default_read_concern(self) -> Optional[str]:
        """
        [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        """
        return pulumi.get(self, "default_read_concern")

    @property
    @pulumi.getter(name="defaultWriteConcern")
    def default_write_concern(self) -> Optional[str]:
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        return pulumi.get(self, "default_write_concern")

    @property
    @pulumi.getter(name="failIndexKeyTooLong")
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
    def fail_index_key_too_long(self) -> Optional[bool]:
        """
        When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        """
        return pulumi.get(self, "fail_index_key_too_long")

    @property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> Optional[bool]:
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        return pulumi.get(self, "javascript_enabled")

    @property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> Optional[str]:
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:

        - TLS1_0
        - TLS1_1
        - TLS1_2
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> Optional[bool]:
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        return pulumi.get(self, "no_table_scan")

    @property
    @pulumi.getter(name="oplogMinRetentionHours")
    def oplog_min_retention_hours(self) -> Optional[float]:
        """
        Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        * **Note**  A minimum oplog retention is required when seeking to change a cluster's class to Local NVMe SSD. To learn more and for latest guidance see  [`oplogMinRetentionHours`](https://www.mongodb.com/docs/manual/core/replica-set-oplog/#std-label-replica-set-minimum-oplog-size)
        """
        return pulumi.get(self, "oplog_min_retention_hours")

    @property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> Optional[int]:
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        return pulumi.get(self, "oplog_size_mb")

    @property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> Optional[int]:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> Optional[int]:
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_size_bi_connector")

    @property
    @pulumi.getter(name="transactionLifetimeLimitSeconds")
    def transaction_lifetime_limit_seconds(self) -> Optional[int]:
        """
        Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        return pulumi.get(self, "transaction_lifetime_limit_seconds")


@pulumi.output_type
class ClusterBiConnectorConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "readPreference":
            suggest = "read_preference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterBiConnectorConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterBiConnectorConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterBiConnectorConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 read_preference: Optional[str] = None):
        """
        :param bool enabled: Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
               *
               - Set to `true` to enable BI Connector for Atlas.
               - Set to `false` to disable BI Connector for Atlas.
        :param str read_preference: Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
               
               - Set to "primary" to have BI Connector for Atlas read from the primary.
               
               - Set to "secondary" to have BI Connector for Atlas read from a secondary member. Default if there are no analytics nodes in the cluster.
               
               - Set to "analytics" to have BI Connector for Atlas read from an analytics node. Default if the cluster contains analytics nodes.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if read_preference is not None:
            pulumi.set(__self__, "read_preference", read_preference)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
        *
        - Set to `true` to enable BI Connector for Atlas.
        - Set to `false` to disable BI Connector for Atlas.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> Optional[str]:
        """
        Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).

        - Set to "primary" to have BI Connector for Atlas read from the primary.

        - Set to "secondary" to have BI Connector for Atlas read from a secondary member. Default if there are no analytics nodes in the cluster.

        - Set to "analytics" to have BI Connector for Atlas read from an analytics node. Default if the cluster contains analytics nodes.
        """
        return pulumi.get(self, "read_preference")


@pulumi.output_type
class ClusterConnectionString(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateEndpoints":
            suggest = "private_endpoints"
        elif key == "privateSrv":
            suggest = "private_srv"
        elif key == "standardSrv":
            suggest = "standard_srv"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterConnectionString. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterConnectionString.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterConnectionString.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private: Optional[str] = None,
                 private_endpoints: Optional[Sequence['outputs.ClusterConnectionStringPrivateEndpoint']] = None,
                 private_srv: Optional[str] = None,
                 standard: Optional[str] = None,
                 standard_srv: Optional[str] = None):
        """
        :param str private: [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        :param Sequence['ClusterConnectionStringPrivateEndpointArgs'] private_endpoints: Private endpoint connection strings. Each object describes the connection strings you can use to connect to this cluster through a private endpoint. Atlas returns this parameter only if you deployed a private endpoint to all regions to which you deployed this cluster's nodes.
               - `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
               - `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in DNS . Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don't need to: Append the seed list or Change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn't, use `connection_strings.private_endpoint[n].connection_string`
               - `connection_strings.private_endpoint.#.srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster supports it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[n].srvConnectionString.
               - `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
               - `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`
               - `connection_strings.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.
               - `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
               - `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.
        :param str private_srv: [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        :param str standard: Public mongodb:// connection string for this cluster.
        :param str standard_srv: Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t  , use connectionStrings.standard.
        """
        if private is not None:
            pulumi.set(__self__, "private", private)
        if private_endpoints is not None:
            pulumi.set(__self__, "private_endpoints", private_endpoints)
        if private_srv is not None:
            pulumi.set(__self__, "private_srv", private_srv)
        if standard is not None:
            pulumi.set(__self__, "standard", standard)
        if standard_srv is not None:
            pulumi.set(__self__, "standard_srv", standard_srv)

    @property
    @pulumi.getter
    def private(self) -> Optional[str]:
        """
        [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        """
        return pulumi.get(self, "private")

    @property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Optional[Sequence['outputs.ClusterConnectionStringPrivateEndpoint']]:
        """
        Private endpoint connection strings. Each object describes the connection strings you can use to connect to this cluster through a private endpoint. Atlas returns this parameter only if you deployed a private endpoint to all regions to which you deployed this cluster's nodes.
        - `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
        - `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in DNS . Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don't need to: Append the seed list or Change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn't, use `connection_strings.private_endpoint[n].connection_string`
        - `connection_strings.private_endpoint.#.srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster supports it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[n].srvConnectionString.
        - `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
        - `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`
        - `connection_strings.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.
        - `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
        - `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.
        """
        return pulumi.get(self, "private_endpoints")

    @property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> Optional[str]:
        """
        [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        """
        return pulumi.get(self, "private_srv")

    @property
    @pulumi.getter
    def standard(self) -> Optional[str]:
        """
        Public mongodb:// connection string for this cluster.
        """
        return pulumi.get(self, "standard")

    @property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> Optional[str]:
        """
        Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t  , use connectionStrings.standard.
        """
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class ClusterConnectionStringPrivateEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionString":
            suggest = "connection_string"
        elif key == "srvConnectionString":
            suggest = "srv_connection_string"
        elif key == "srvShardOptimizedConnectionString":
            suggest = "srv_shard_optimized_connection_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterConnectionStringPrivateEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterConnectionStringPrivateEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterConnectionStringPrivateEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_string: Optional[str] = None,
                 endpoints: Optional[Sequence['outputs.ClusterConnectionStringPrivateEndpointEndpoint']] = None,
                 srv_connection_string: Optional[str] = None,
                 srv_shard_optimized_connection_string: Optional[str] = None,
                 type: Optional[str] = None):
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if srv_connection_string is not None:
            pulumi.set(__self__, "srv_connection_string", srv_connection_string)
        if srv_shard_optimized_connection_string is not None:
            pulumi.set(__self__, "srv_shard_optimized_connection_string", srv_shard_optimized_connection_string)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[str]:
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence['outputs.ClusterConnectionStringPrivateEndpointEndpoint']]:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> Optional[str]:
        return pulumi.get(self, "srv_connection_string")

    @property
    @pulumi.getter(name="srvShardOptimizedConnectionString")
    def srv_shard_optimized_connection_string(self) -> Optional[str]:
        return pulumi.get(self, "srv_shard_optimized_connection_string")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class ClusterConnectionStringPrivateEndpointEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointId":
            suggest = "endpoint_id"
        elif key == "providerName":
            suggest = "provider_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterConnectionStringPrivateEndpointEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterConnectionStringPrivateEndpointEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterConnectionStringPrivateEndpointEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_id: Optional[str] = None,
                 provider_name: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str provider_name: Cloud service provider on which the servers are provisioned.
               
               The possible values are:
               
               - `AWS` - Amazon AWS
               - `GCP` - Google Cloud Platform
               - `AZURE` - Microsoft Azure
               - `TENANT` - A multi-tenant deployment on one of the supported cloud service providers. Only valid when providerSettings.instanceSizeName is either M2 or M5.
        """
        if endpoint_id is not None:
            pulumi.set(__self__, "endpoint_id", endpoint_id)
        if provider_name is not None:
            pulumi.set(__self__, "provider_name", provider_name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[str]:
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> Optional[str]:
        """
        Cloud service provider on which the servers are provisioned.

        The possible values are:

        - `AWS` - Amazon AWS
        - `GCP` - Google Cloud Platform
        - `AZURE` - Microsoft Azure
        - `TENANT` - A multi-tenant deployment on one of the supported cloud service providers. Only valid when providerSettings.instanceSizeName is either M2 or M5.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class ClusterLabel(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
               
               > **NOTE:** MongoDB Atlas doesn't display your labels.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value that you want to write.

        > **NOTE:** MongoDB Atlas doesn't display your labels.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterOutageSimulationOutageFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudProvider":
            suggest = "cloud_provider"
        elif key == "regionName":
            suggest = "region_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterOutageSimulationOutageFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterOutageSimulationOutageFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterOutageSimulationOutageFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_provider: str,
                 region_name: str,
                 type: Optional[str] = None):
        """
        :param str cloud_provider: The cloud provider of the region that undergoes the outage simulation. Following values are supported:
               * `AWS`
               * `GCP`
               * `AZURE`
        :param str region_name: The Atlas name of the region to undergo an outage simulation.
        :param str type: The type of cluster outage simulation. Following values are supported:
               * `REGION` - Simulates a cluster outage for a region
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region_name", region_name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        The cloud provider of the region that undergoes the outage simulation. Following values are supported:
        * `AWS`
        * `GCP`
        * `AZURE`
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        The Atlas name of the region to undergo an outage simulation.
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of cluster outage simulation. Following values are supported:
        * `REGION` - Simulates a cluster outage for a region
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ClusterReplicationSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numShards":
            suggest = "num_shards"
        elif key == "regionsConfigs":
            suggest = "regions_configs"
        elif key == "zoneName":
            suggest = "zone_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterReplicationSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterReplicationSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterReplicationSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 num_shards: int,
                 id: Optional[str] = None,
                 regions_configs: Optional[Sequence['outputs.ClusterReplicationSpecRegionsConfig']] = None,
                 zone_name: Optional[str] = None):
        """
        :param int num_shards: Selects whether the cluster is a replica set or a sharded cluster. If you use the replicationSpecs parameter, you must set num_shards.
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        :param Sequence['ClusterReplicationSpecRegionsConfigArgs'] regions_configs: Physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        :param str zone_name: Name for the zone in a Global Cluster.
               
               
               **Region Config**
        """
        pulumi.set(__self__, "num_shards", num_shards)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if regions_configs is not None:
            pulumi.set(__self__, "regions_configs", regions_configs)
        if zone_name is not None:
            pulumi.set(__self__, "zone_name", zone_name)

    @property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> int:
        """
        Selects whether the cluster is a replica set or a sharded cluster. If you use the replicationSpecs parameter, you must set num_shards.
        """
        return pulumi.get(self, "num_shards")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="regionsConfigs")
    def regions_configs(self) -> Optional[Sequence['outputs.ClusterReplicationSpecRegionsConfig']]:
        """
        Physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        """
        return pulumi.get(self, "regions_configs")

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> Optional[str]:
        """
        Name for the zone in a Global Cluster.


        **Region Config**
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class ClusterReplicationSpecRegionsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionName":
            suggest = "region_name"
        elif key == "analyticsNodes":
            suggest = "analytics_nodes"
        elif key == "electableNodes":
            suggest = "electable_nodes"
        elif key == "readOnlyNodes":
            suggest = "read_only_nodes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterReplicationSpecRegionsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterReplicationSpecRegionsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterReplicationSpecRegionsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region_name: str,
                 analytics_nodes: Optional[int] = None,
                 electable_nodes: Optional[int] = None,
                 priority: Optional[int] = None,
                 read_only_nodes: Optional[int] = None):
        """
        :param str region_name: Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        :param int analytics_nodes: The number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary. If you do not specify this option, no analytics nodes are deployed to the region.
        :param int electable_nodes: Number of electable nodes for Atlas to deploy to the region. Electable nodes can become the primary and can facilitate local reads.
               * The total number of electableNodes across all replication spec regions  must total 3, 5, or 7.
               * Specify 0 if you do not want any electable nodes in the region.
               * You cannot create electable nodes in a region if `priority` is 0.
        :param int priority: Election priority of the region. For regions with only read-only nodes, set this value to 0.
               * For regions where `electable_nodes` is at least 1, each region must have a priority of exactly one (1) less than the previous region. The first region must have a priority of 7. The lowest possible priority is 1.
               * The priority 7 region identifies the Preferred Region of the cluster. Atlas places the primary node in the Preferred Region. Priorities 1 through 7 are exclusive - no more than one region per cluster can be assigned a given priority.
               * Example: If you have three regions, their priorities would be 7, 6, and 5 respectively. If you added two more regions for supporting electable nodes, the priorities of those regions would be 4 and 3 respectively.
        :param int read_only_nodes: Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        """
        pulumi.set(__self__, "region_name", region_name)
        if analytics_nodes is not None:
            pulumi.set(__self__, "analytics_nodes", analytics_nodes)
        if electable_nodes is not None:
            pulumi.set(__self__, "electable_nodes", electable_nodes)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if read_only_nodes is not None:
            pulumi.set(__self__, "read_only_nodes", read_only_nodes)

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter(name="analyticsNodes")
    def analytics_nodes(self) -> Optional[int]:
        """
        The number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary. If you do not specify this option, no analytics nodes are deployed to the region.
        """
        return pulumi.get(self, "analytics_nodes")

    @property
    @pulumi.getter(name="electableNodes")
    def electable_nodes(self) -> Optional[int]:
        """
        Number of electable nodes for Atlas to deploy to the region. Electable nodes can become the primary and can facilitate local reads.
        * The total number of electableNodes across all replication spec regions  must total 3, 5, or 7.
        * Specify 0 if you do not want any electable nodes in the region.
        * You cannot create electable nodes in a region if `priority` is 0.
        """
        return pulumi.get(self, "electable_nodes")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Election priority of the region. For regions with only read-only nodes, set this value to 0.
        * For regions where `electable_nodes` is at least 1, each region must have a priority of exactly one (1) less than the previous region. The first region must have a priority of 7. The lowest possible priority is 1.
        * The priority 7 region identifies the Preferred Region of the cluster. Atlas places the primary node in the Preferred Region. Priorities 1 through 7 are exclusive - no more than one region per cluster can be assigned a given priority.
        * Example: If you have three regions, their priorities would be 7, 6, and 5 respectively. If you added two more regions for supporting electable nodes, the priorities of those regions would be 4 and 3 respectively.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="readOnlyNodes")
    def read_only_nodes(self) -> Optional[int]:
        """
        Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        """
        return pulumi.get(self, "read_only_nodes")


@pulumi.output_type
class ClusterSnapshotBackupPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterId":
            suggest = "cluster_id"
        elif key == "clusterName":
            suggest = "cluster_name"
        elif key == "nextSnapshot":
            suggest = "next_snapshot"
        elif key == "referenceHourOfDay":
            suggest = "reference_hour_of_day"
        elif key == "referenceMinuteOfHour":
            suggest = "reference_minute_of_hour"
        elif key == "restoreWindowDays":
            suggest = "restore_window_days"
        elif key == "updateSnapshots":
            suggest = "update_snapshots"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSnapshotBackupPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSnapshotBackupPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSnapshotBackupPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_id: Optional[str] = None,
                 cluster_name: Optional[str] = None,
                 next_snapshot: Optional[str] = None,
                 policies: Optional[Sequence['outputs.ClusterSnapshotBackupPolicyPolicy']] = None,
                 reference_hour_of_day: Optional[int] = None,
                 reference_minute_of_hour: Optional[int] = None,
                 restore_window_days: Optional[int] = None,
                 update_snapshots: Optional[bool] = None):
        """
        :param str cluster_id: The cluster ID.
        """
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if next_snapshot is not None:
            pulumi.set(__self__, "next_snapshot", next_snapshot)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if reference_hour_of_day is not None:
            pulumi.set(__self__, "reference_hour_of_day", reference_hour_of_day)
        if reference_minute_of_hour is not None:
            pulumi.set(__self__, "reference_minute_of_hour", reference_minute_of_hour)
        if restore_window_days is not None:
            pulumi.set(__self__, "restore_window_days", restore_window_days)
        if update_snapshots is not None:
            pulumi.set(__self__, "update_snapshots", update_snapshots)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[str]:
        """
        The cluster ID.
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="nextSnapshot")
    def next_snapshot(self) -> Optional[str]:
        return pulumi.get(self, "next_snapshot")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence['outputs.ClusterSnapshotBackupPolicyPolicy']]:
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="referenceHourOfDay")
    def reference_hour_of_day(self) -> Optional[int]:
        return pulumi.get(self, "reference_hour_of_day")

    @property
    @pulumi.getter(name="referenceMinuteOfHour")
    def reference_minute_of_hour(self) -> Optional[int]:
        return pulumi.get(self, "reference_minute_of_hour")

    @property
    @pulumi.getter(name="restoreWindowDays")
    def restore_window_days(self) -> Optional[int]:
        return pulumi.get(self, "restore_window_days")

    @property
    @pulumi.getter(name="updateSnapshots")
    def update_snapshots(self) -> Optional[bool]:
        return pulumi.get(self, "update_snapshots")


@pulumi.output_type
class ClusterSnapshotBackupPolicyPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyItems":
            suggest = "policy_items"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSnapshotBackupPolicyPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSnapshotBackupPolicyPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSnapshotBackupPolicyPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[str] = None,
                 policy_items: Optional[Sequence['outputs.ClusterSnapshotBackupPolicyPolicyPolicyItem']] = None):
        """
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if policy_items is not None:
            pulumi.set(__self__, "policy_items", policy_items)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="policyItems")
    def policy_items(self) -> Optional[Sequence['outputs.ClusterSnapshotBackupPolicyPolicyPolicyItem']]:
        return pulumi.get(self, "policy_items")


@pulumi.output_type
class ClusterSnapshotBackupPolicyPolicyPolicyItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "frequencyType":
            suggest = "frequency_type"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSnapshotBackupPolicyPolicyPolicyItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSnapshotBackupPolicyPolicyPolicyItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSnapshotBackupPolicyPolicyPolicyItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: Optional[int] = None,
                 frequency_type: Optional[str] = None,
                 id: Optional[str] = None,
                 retention_unit: Optional[str] = None,
                 retention_value: Optional[int] = None):
        """
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        if frequency_interval is not None:
            pulumi.set(__self__, "frequency_interval", frequency_interval)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if retention_unit is not None:
            pulumi.set(__self__, "retention_unit", retention_unit)
        if retention_value is not None:
            pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> Optional[int]:
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> Optional[str]:
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> Optional[int]:
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class ClusterTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Constant that defines the set of the tag.
        :param str value: Variable that belongs to the set of the tag.
               
               To learn more, see [Resource Tags](https://dochub.mongodb.org/core/add-cluster-tag-atlas).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Constant that defines the set of the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Variable that belongs to the set of the tag.

        To learn more, see [Resource Tags](https://dochub.mongodb.org/core/add-cluster-tag-atlas).
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomDbRoleAction(dict):
    def __init__(__self__, *,
                 action: str,
                 resources: Sequence['outputs.CustomDbRoleActionResource']):
        """
        :param str action: Name of the privilege action. For a complete list of actions available in the Atlas API, see [Custom Role Actions](https://docs.atlas.mongodb.com/reference/api/custom-role-actions)
               > **Note**: The privilege actions available to the Custom Roles API resource represent a subset of the privilege actions available in the Atlas Custom Roles UI.
        :param Sequence['CustomDbRoleActionResourceArgs'] resources: Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
               
               * `resources.#.collection_name` - (Optional) Collection on which the action is granted. If this value is an empty string, the action is granted on all collections within the database specified in the actions.resources.db field.
               
               > **NOTE** This field is mutually exclusive with the `actions.resources.cluster` field.
               
               * `resources.#.database_name`	Database on which the action is granted.
               
               > **NOTE** This field is mutually exclusive with the `actions.resources.cluster` field.
               
               * `resources.#.cluster`	(Optional) Set to true to indicate that the action is granted on the cluster resource.
               
               > **NOTE** This field is mutually exclusive with the `actions.resources.collection` and `actions.resources.db fields`.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Name of the privilege action. For a complete list of actions available in the Atlas API, see [Custom Role Actions](https://docs.atlas.mongodb.com/reference/api/custom-role-actions)
        > **Note**: The privilege actions available to the Custom Roles API resource represent a subset of the privilege actions available in the Atlas Custom Roles UI.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.CustomDbRoleActionResource']:
        """
        Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.

        * `resources.#.collection_name` - (Optional) Collection on which the action is granted. If this value is an empty string, the action is granted on all collections within the database specified in the actions.resources.db field.

        > **NOTE** This field is mutually exclusive with the `actions.resources.cluster` field.

        * `resources.#.database_name`	Database on which the action is granted.

        > **NOTE** This field is mutually exclusive with the `actions.resources.cluster` field.

        * `resources.#.cluster`	(Optional) Set to true to indicate that the action is granted on the cluster resource.

        > **NOTE** This field is mutually exclusive with the `actions.resources.collection` and `actions.resources.db fields`.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class CustomDbRoleActionResource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collectionName":
            suggest = "collection_name"
        elif key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomDbRoleActionResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomDbRoleActionResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomDbRoleActionResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster: Optional[bool] = None,
                 collection_name: Optional[str] = None,
                 database_name: Optional[str] = None):
        """
        :param str database_name: Database on which the inherited role is granted.
               
               > **NOTE** This value should be admin for all roles except read and readWrite.
        """
        if cluster is not None:
            pulumi.set(__self__, "cluster", cluster)
        if collection_name is not None:
            pulumi.set(__self__, "collection_name", collection_name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)

    @property
    @pulumi.getter
    def cluster(self) -> Optional[bool]:
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[str]:
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        Database on which the inherited role is granted.

        > **NOTE** This value should be admin for all roles except read and readWrite.
        """
        return pulumi.get(self, "database_name")


@pulumi.output_type
class CustomDbRoleInheritedRole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "roleName":
            suggest = "role_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CustomDbRoleInheritedRole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CustomDbRoleInheritedRole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CustomDbRoleInheritedRole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 role_name: str):
        """
        :param str database_name: Database on which the inherited role is granted.
               
               > **NOTE** This value should be admin for all roles except read and readWrite.
        :param str role_name: Name of the inherited role. This can either be another custom role or a built-in role.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Database on which the inherited role is granted.

        > **NOTE** This value should be admin for all roles except read and readWrite.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        """
        Name of the inherited role. This can either be another custom role or a built-in role.
        """
        return pulumi.get(self, "role_name")


@pulumi.output_type
class DataLakePipelineIngestionSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "frequencyInterval":
            suggest = "frequency_interval"
        elif key == "frequencyType":
            suggest = "frequency_type"
        elif key == "retentionUnit":
            suggest = "retention_unit"
        elif key == "retentionValue":
            suggest = "retention_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakePipelineIngestionSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakePipelineIngestionSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakePipelineIngestionSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 frequency_interval: Optional[int] = None,
                 frequency_type: Optional[str] = None,
                 id: Optional[str] = None,
                 retention_unit: Optional[str] = None,
                 retention_value: Optional[int] = None):
        """
        :param str id: Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.
        """
        if frequency_interval is not None:
            pulumi.set(__self__, "frequency_interval", frequency_interval)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if retention_unit is not None:
            pulumi.set(__self__, "retention_unit", retention_unit)
        if retention_value is not None:
            pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> Optional[int]:
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> Optional[str]:
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> Optional[int]:
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class DataLakePipelineSink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "partitionFields":
            suggest = "partition_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakePipelineSink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakePipelineSink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakePipelineSink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 partition_fields: Optional[Sequence['outputs.DataLakePipelineSinkPartitionField']] = None,
                 provider: Optional[str] = None,
                 region: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param Sequence['DataLakePipelineSinkPartitionFieldArgs'] partition_fields: Ordered fields used to physically organize data in the destination.
               * `partition_fields.#.field_name` - Human-readable label that identifies the field name used to partition data.
               * `partition_fields.#.order` - Sequence in which MongoDB Atlas slices the collection data to create partitions. The resource expresses this sequence starting with zero.
        :param str provider: Target cloud provider for this Data Lake Pipeline.
        :param str region: Target cloud provider region for this Data Lake Pipeline. [Supported cloud provider regions](https://www.mongodb.com/docs/datalake/limitations).
        :param str type: Type of ingestion source of this Data Lake Pipeline.
        """
        if partition_fields is not None:
            pulumi.set(__self__, "partition_fields", partition_fields)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="partitionFields")
    def partition_fields(self) -> Optional[Sequence['outputs.DataLakePipelineSinkPartitionField']]:
        """
        Ordered fields used to physically organize data in the destination.
        * `partition_fields.#.field_name` - Human-readable label that identifies the field name used to partition data.
        * `partition_fields.#.order` - Sequence in which MongoDB Atlas slices the collection data to create partitions. The resource expresses this sequence starting with zero.
        """
        return pulumi.get(self, "partition_fields")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        """
        Target cloud provider for this Data Lake Pipeline.
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Target cloud provider region for this Data Lake Pipeline. [Supported cloud provider regions](https://www.mongodb.com/docs/datalake/limitations).
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DataLakePipelineSinkPartitionField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakePipelineSinkPartitionField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakePipelineSinkPartitionField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakePipelineSinkPartitionField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: str,
                 order: int):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def order(self) -> int:
        return pulumi.get(self, "order")


@pulumi.output_type
class DataLakePipelineSnapshot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyRegion":
            suggest = "copy_region"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "expiresAt":
            suggest = "expires_at"
        elif key == "frequencyYype":
            suggest = "frequency_yype"
        elif key == "masterKey":
            suggest = "master_key"
        elif key == "mongodVersion":
            suggest = "mongod_version"
        elif key == "replicaSetName":
            suggest = "replica_set_name"
        elif key == "snapshotType":
            suggest = "snapshot_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakePipelineSnapshot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakePipelineSnapshot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakePipelineSnapshot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_region: Optional[str] = None,
                 created_at: Optional[str] = None,
                 expires_at: Optional[str] = None,
                 frequency_yype: Optional[str] = None,
                 id: Optional[str] = None,
                 master_key: Optional[str] = None,
                 mongod_version: Optional[str] = None,
                 policies: Optional[Sequence[str]] = None,
                 provider: Optional[str] = None,
                 replica_set_name: Optional[str] = None,
                 size: Optional[int] = None,
                 snapshot_type: Optional[str] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.
        :param str provider: Target cloud provider for this Data Lake Pipeline.
        :param str type: Type of ingestion source of this Data Lake Pipeline.
        """
        if copy_region is not None:
            pulumi.set(__self__, "copy_region", copy_region)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if frequency_yype is not None:
            pulumi.set(__self__, "frequency_yype", frequency_yype)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if master_key is not None:
            pulumi.set(__self__, "master_key", master_key)
        if mongod_version is not None:
            pulumi.set(__self__, "mongod_version", mongod_version)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if replica_set_name is not None:
            pulumi.set(__self__, "replica_set_name", replica_set_name)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if snapshot_type is not None:
            pulumi.set(__self__, "snapshot_type", snapshot_type)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="copyRegion")
    def copy_region(self) -> Optional[str]:
        return pulumi.get(self, "copy_region")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[str]:
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter(name="frequencyYype")
    def frequency_yype(self) -> Optional[str]:
        return pulumi.get(self, "frequency_yype")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="masterKey")
    def master_key(self) -> Optional[str]:
        return pulumi.get(self, "master_key")

    @property
    @pulumi.getter(name="mongodVersion")
    def mongod_version(self) -> Optional[str]:
        return pulumi.get(self, "mongod_version")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        """
        Target cloud provider for this Data Lake Pipeline.
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> Optional[str]:
        return pulumi.get(self, "replica_set_name")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="snapshotType")
    def snapshot_type(self) -> Optional[str]:
        return pulumi.get(self, "snapshot_type")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DataLakePipelineSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"
        elif key == "collectionName":
            suggest = "collection_name"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "policyItemId":
            suggest = "policy_item_id"
        elif key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataLakePipelineSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataLakePipelineSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataLakePipelineSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_name: Optional[str] = None,
                 collection_name: Optional[str] = None,
                 database_name: Optional[str] = None,
                 policy_item_id: Optional[str] = None,
                 project_id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str cluster_name: Human-readable name that identifies the cluster.
        :param str collection_name: Human-readable name that identifies the collection.
        :param str database_name: Human-readable name that identifies the database.
        :param str project_id: The unique ID for the project to create a data lake pipeline.
        :param str type: Type of ingestion source of this Data Lake Pipeline.
        """
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if collection_name is not None:
            pulumi.set(__self__, "collection_name", collection_name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if policy_item_id is not None:
            pulumi.set(__self__, "policy_item_id", policy_item_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        """
        Human-readable name that identifies the cluster.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[str]:
        """
        Human-readable name that identifies the collection.
        """
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        Human-readable name that identifies the database.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="policyItemId")
    def policy_item_id(self) -> Optional[str]:
        return pulumi.get(self, "policy_item_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        """
        The unique ID for the project to create a data lake pipeline.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DataLakePipelineTransformation(dict):
    def __init__(__self__, *,
                 field: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str type: Type of ingestion source of this Data Lake Pipeline.
        """
        if field is not None:
            pulumi.set(__self__, "field", field)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def field(self) -> Optional[str]:
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DatabaseUserLabel(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DatabaseUserRole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "roleName":
            suggest = "role_name"
        elif key == "collectionName":
            suggest = "collection_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseUserRole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseUserRole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseUserRole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 role_name: str,
                 collection_name: Optional[str] = None):
        """
        :param str database_name: Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases. This field should be set to `admin` for a custom MongoDB role.
        :param str role_name: Name of the role to grant. See [Create a Database User](https://docs.atlas.mongodb.com/reference/api/database-users-create-a-user/) `roles.roleName` for valid values and restrictions.
        :param str collection_name: Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "role_name", role_name)
        if collection_name is not None:
            pulumi.set(__self__, "collection_name", collection_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases. This field should be set to `admin` for a custom MongoDB role.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        """
        Name of the role to grant. See [Create a Database User](https://docs.atlas.mongodb.com/reference/api/database-users-create-a-user/) `roles.roleName` for valid values and restrictions.
        """
        return pulumi.get(self, "role_name")

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[str]:
        """
        Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        """
        return pulumi.get(self, "collection_name")


@pulumi.output_type
class DatabaseUserScope(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: Name of the cluster or Atlas Data Lake that the user has access to.
        :param str type: Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the cluster or Atlas Data Lake that the user has access to.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class EncryptionAtRestAwsKmsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKeyId":
            suggest = "access_key_id"
        elif key == "customerMasterKeyId":
            suggest = "customer_master_key_id"
        elif key == "roleId":
            suggest = "role_id"
        elif key == "secretAccessKey":
            suggest = "secret_access_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionAtRestAwsKmsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionAtRestAwsKmsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionAtRestAwsKmsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key_id: Optional[str] = None,
                 customer_master_key_id: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 region: Optional[str] = None,
                 role_id: Optional[str] = None,
                 secret_access_key: Optional[str] = None,
                 valid: Optional[bool] = None):
        """
        :param str access_key_id: Unique alphanumeric string that identifies an Identity and Access Management (IAM) access key with permissions required to access your Amazon Web Services (AWS) Customer Master Key (CMK).
        :param str customer_master_key_id: Unique alphanumeric string that identifies the Amazon Web Services (AWS) Customer Master Key (CMK) you used to encrypt and decrypt the MongoDB master keys.
        :param bool enabled: Flag that indicates whether someone enabled encryption at rest for the specified project through Amazon Web Services (AWS) Key Management Service (KMS). To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        :param str region: Physical location where MongoDB Atlas deploys your AWS-hosted MongoDB cluster nodes. The region you choose can affect network latency for clients accessing your databases. When MongoDB Cloud deploys a dedicated cluster, it checks if a VPC or VPC connection exists for that provider and region. If not, MongoDB Atlas creates them as part of the deployment. MongoDB Atlas assigns the VPC a CIDR block. To limit a new VPC peering connection to one CIDR block and region, create the connection first. Deploy the cluster after the connection starts.
        :param str role_id: Unique 24-hexadecimal digit string that identifies an Amazon Web Services (AWS) Identity and Access Management (IAM) role. This IAM role has the permissions required to manage your AWS customer master key.
        :param str secret_access_key: Human-readable label of the Identity and Access Management (IAM) secret access key with permissions required to access your Amazon Web Services (AWS) customer master key.
        :param bool valid: Flag that indicates whether the Amazon Web Services (AWS) Key Management Service (KMS) encryption key can encrypt and decrypt data.
        """
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if customer_master_key_id is not None:
            pulumi.set(__self__, "customer_master_key_id", customer_master_key_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_id is not None:
            pulumi.set(__self__, "role_id", role_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)
        if valid is not None:
            pulumi.set(__self__, "valid", valid)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[str]:
        """
        Unique alphanumeric string that identifies an Identity and Access Management (IAM) access key with permissions required to access your Amazon Web Services (AWS) Customer Master Key (CMK).
        """
        return pulumi.get(self, "access_key_id")

    @property
    @pulumi.getter(name="customerMasterKeyId")
    def customer_master_key_id(self) -> Optional[str]:
        """
        Unique alphanumeric string that identifies the Amazon Web Services (AWS) Customer Master Key (CMK) you used to encrypt and decrypt the MongoDB master keys.
        """
        return pulumi.get(self, "customer_master_key_id")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Flag that indicates whether someone enabled encryption at rest for the specified project through Amazon Web Services (AWS) Key Management Service (KMS). To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Physical location where MongoDB Atlas deploys your AWS-hosted MongoDB cluster nodes. The region you choose can affect network latency for clients accessing your databases. When MongoDB Cloud deploys a dedicated cluster, it checks if a VPC or VPC connection exists for that provider and region. If not, MongoDB Atlas creates them as part of the deployment. MongoDB Atlas assigns the VPC a CIDR block. To limit a new VPC peering connection to one CIDR block and region, create the connection first. Deploy the cluster after the connection starts.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[str]:
        """
        Unique 24-hexadecimal digit string that identifies an Amazon Web Services (AWS) Identity and Access Management (IAM) role. This IAM role has the permissions required to manage your AWS customer master key.
        """
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[str]:
        """
        Human-readable label of the Identity and Access Management (IAM) secret access key with permissions required to access your Amazon Web Services (AWS) customer master key.
        """
        return pulumi.get(self, "secret_access_key")

    @property
    @pulumi.getter
    def valid(self) -> Optional[bool]:
        """
        Flag that indicates whether the Amazon Web Services (AWS) Key Management Service (KMS) encryption key can encrypt and decrypt data.
        """
        return pulumi.get(self, "valid")


@pulumi.output_type
class EncryptionAtRestAzureKeyVaultConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureEnvironment":
            suggest = "azure_environment"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "keyIdentifier":
            suggest = "key_identifier"
        elif key == "keyVaultName":
            suggest = "key_vault_name"
        elif key == "requirePrivateNetworking":
            suggest = "require_private_networking"
        elif key == "resourceGroupName":
            suggest = "resource_group_name"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionAtRestAzureKeyVaultConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionAtRestAzureKeyVaultConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionAtRestAzureKeyVaultConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_environment: Optional[str] = None,
                 client_id: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 key_identifier: Optional[str] = None,
                 key_vault_name: Optional[str] = None,
                 require_private_networking: Optional[bool] = None,
                 resource_group_name: Optional[str] = None,
                 secret: Optional[str] = None,
                 subscription_id: Optional[str] = None,
                 tenant_id: Optional[str] = None,
                 valid: Optional[bool] = None):
        """
        :param str azure_environment: Azure environment in which your account credentials reside.
        :param str client_id: Unique 36-hexadecimal character string that identifies an Azure application associated with your Azure Active Directory tenant.
        :param bool enabled: Flag that indicates whether someone enabled encryption at rest for the specified  project. To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        :param str key_identifier: Web address with a unique key that identifies for your Azure Key Vault.
        :param str key_vault_name: Unique string that identifies the Azure Key Vault that contains your key.
        :param bool require_private_networking: Enable connection to your Azure Key Vault over private networking.
        :param str resource_group_name: Name of the Azure resource group that contains your Azure Key Vault.
        :param str secret: Private data that you need secured and that belongs to the specified Azure Key Vault (AKV) tenant (**azureKeyVault.tenantID**). This data can include any type of sensitive data such as passwords, database connection strings, API keys, and the like. AKV stores this information as encrypted binary data.
        :param str subscription_id: Unique 36-hexadecimal character string that identifies your Azure subscription.
        :param str tenant_id: Unique 36-hexadecimal character string that identifies the Azure Active Directory tenant within your Azure subscription.
        :param bool valid: Flag that indicates whether the Azure encryption key can encrypt and decrypt data.
        """
        if azure_environment is not None:
            pulumi.set(__self__, "azure_environment", azure_environment)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if key_identifier is not None:
            pulumi.set(__self__, "key_identifier", key_identifier)
        if key_vault_name is not None:
            pulumi.set(__self__, "key_vault_name", key_vault_name)
        if require_private_networking is not None:
            pulumi.set(__self__, "require_private_networking", require_private_networking)
        if resource_group_name is not None:
            pulumi.set(__self__, "resource_group_name", resource_group_name)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if valid is not None:
            pulumi.set(__self__, "valid", valid)

    @property
    @pulumi.getter(name="azureEnvironment")
    def azure_environment(self) -> Optional[str]:
        """
        Azure environment in which your account credentials reside.
        """
        return pulumi.get(self, "azure_environment")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        Unique 36-hexadecimal character string that identifies an Azure application associated with your Azure Active Directory tenant.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Flag that indicates whether someone enabled encryption at rest for the specified  project. To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="keyIdentifier")
    def key_identifier(self) -> Optional[str]:
        """
        Web address with a unique key that identifies for your Azure Key Vault.
        """
        return pulumi.get(self, "key_identifier")

    @property
    @pulumi.getter(name="keyVaultName")
    def key_vault_name(self) -> Optional[str]:
        """
        Unique string that identifies the Azure Key Vault that contains your key.
        """
        return pulumi.get(self, "key_vault_name")

    @property
    @pulumi.getter(name="requirePrivateNetworking")
    def require_private_networking(self) -> Optional[bool]:
        """
        Enable connection to your Azure Key Vault over private networking.
        """
        return pulumi.get(self, "require_private_networking")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[str]:
        """
        Name of the Azure resource group that contains your Azure Key Vault.
        """
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        Private data that you need secured and that belongs to the specified Azure Key Vault (AKV) tenant (**azureKeyVault.tenantID**). This data can include any type of sensitive data such as passwords, database connection strings, API keys, and the like. AKV stores this information as encrypted binary data.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[str]:
        """
        Unique 36-hexadecimal character string that identifies your Azure subscription.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        Unique 36-hexadecimal character string that identifies the Azure Active Directory tenant within your Azure subscription.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def valid(self) -> Optional[bool]:
        """
        Flag that indicates whether the Azure encryption key can encrypt and decrypt data.
        """
        return pulumi.get(self, "valid")


@pulumi.output_type
class EncryptionAtRestGoogleCloudKmsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyVersionResourceId":
            suggest = "key_version_resource_id"
        elif key == "serviceAccountKey":
            suggest = "service_account_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EncryptionAtRestGoogleCloudKmsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EncryptionAtRestGoogleCloudKmsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EncryptionAtRestGoogleCloudKmsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 key_version_resource_id: Optional[str] = None,
                 service_account_key: Optional[str] = None,
                 valid: Optional[bool] = None):
        """
        :param bool enabled: Flag that indicates whether someone enabled encryption at rest for the specified  project. To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        :param str key_version_resource_id: Resource path that displays the key version resource ID for your Google Cloud KMS.
        :param str service_account_key: JavaScript Object Notation (JSON) object that contains the Google Cloud Key Management Service (KMS). Format the JSON as a string and not as an object.
        :param bool valid: Flag that indicates whether the Google Cloud Key Management Service (KMS) encryption key can encrypt and decrypt data.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if key_version_resource_id is not None:
            pulumi.set(__self__, "key_version_resource_id", key_version_resource_id)
        if service_account_key is not None:
            pulumi.set(__self__, "service_account_key", service_account_key)
        if valid is not None:
            pulumi.set(__self__, "valid", valid)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Flag that indicates whether someone enabled encryption at rest for the specified  project. To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="keyVersionResourceId")
    def key_version_resource_id(self) -> Optional[str]:
        """
        Resource path that displays the key version resource ID for your Google Cloud KMS.
        """
        return pulumi.get(self, "key_version_resource_id")

    @property
    @pulumi.getter(name="serviceAccountKey")
    def service_account_key(self) -> Optional[str]:
        """
        JavaScript Object Notation (JSON) object that contains the Google Cloud Key Management Service (KMS). Format the JSON as a string and not as an object.
        """
        return pulumi.get(self, "service_account_key")

    @property
    @pulumi.getter
    def valid(self) -> Optional[bool]:
        """
        Flag that indicates whether the Google Cloud Key Management Service (KMS) encryption key can encrypt and decrypt data.
        """
        return pulumi.get(self, "valid")


@pulumi.output_type
class EventTriggerEventProcessors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsEventbridge":
            suggest = "aws_eventbridge"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventTriggerEventProcessors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventTriggerEventProcessors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventTriggerEventProcessors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_eventbridge: Optional['outputs.EventTriggerEventProcessorsAwsEventbridge'] = None):
        if aws_eventbridge is not None:
            pulumi.set(__self__, "aws_eventbridge", aws_eventbridge)

    @property
    @pulumi.getter(name="awsEventbridge")
    def aws_eventbridge(self) -> Optional['outputs.EventTriggerEventProcessorsAwsEventbridge']:
        return pulumi.get(self, "aws_eventbridge")


@pulumi.output_type
class EventTriggerEventProcessorsAwsEventbridge(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configAccountId":
            suggest = "config_account_id"
        elif key == "configRegion":
            suggest = "config_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventTriggerEventProcessorsAwsEventbridge. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventTriggerEventProcessorsAwsEventbridge.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventTriggerEventProcessorsAwsEventbridge.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_account_id: Optional[str] = None,
                 config_region: Optional[str] = None):
        if config_account_id is not None:
            pulumi.set(__self__, "config_account_id", config_account_id)
        if config_region is not None:
            pulumi.set(__self__, "config_region", config_region)

    @property
    @pulumi.getter(name="configAccountId")
    def config_account_id(self) -> Optional[str]:
        return pulumi.get(self, "config_account_id")

    @property
    @pulumi.getter(name="configRegion")
    def config_region(self) -> Optional[str]:
        return pulumi.get(self, "config_region")


@pulumi.output_type
class FederatedDatabaseInstanceCloudProviderConfig(dict):
    def __init__(__self__, *,
                 aws: 'outputs.FederatedDatabaseInstanceCloudProviderConfigAws'):
        """
        :param 'FederatedDatabaseInstanceCloudProviderConfigAwsArgs' aws: Name of the cloud service that hosts the data lake's data stores.
        """
        pulumi.set(__self__, "aws", aws)

    @property
    @pulumi.getter
    def aws(self) -> 'outputs.FederatedDatabaseInstanceCloudProviderConfigAws':
        """
        Name of the cloud service that hosts the data lake's data stores.
        """
        return pulumi.get(self, "aws")


@pulumi.output_type
class FederatedDatabaseInstanceCloudProviderConfigAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleId":
            suggest = "role_id"
        elif key == "testS3Bucket":
            suggest = "test_s3_bucket"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "iamAssumedRoleArn":
            suggest = "iam_assumed_role_arn"
        elif key == "iamUserArn":
            suggest = "iam_user_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedDatabaseInstanceCloudProviderConfigAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedDatabaseInstanceCloudProviderConfigAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedDatabaseInstanceCloudProviderConfigAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_id: str,
                 test_s3_bucket: str,
                 external_id: Optional[str] = None,
                 iam_assumed_role_arn: Optional[str] = None,
                 iam_user_arn: Optional[str] = None):
        """
        :param str external_id: Unique identifier associated with the IAM Role that the Federated Database Instance assumes when accessing the data stores.
        :param str iam_assumed_role_arn: Amazon Resource Name (ARN) of the IAM Role that the Federated Database Instance assumes when accessing S3 Bucket data stores. The IAM Role must support the following actions against each S3 bucket:
               * `s3:GetObject`
               * `s3:ListBucket`
               * `s3:GetObjectVersion`
        :param str iam_user_arn: Amazon Resource Name (ARN) of the user that the Federated Database Instance assumes when accessing S3 Bucket data stores.
        """
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "test_s3_bucket", test_s3_bucket)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if iam_assumed_role_arn is not None:
            pulumi.set(__self__, "iam_assumed_role_arn", iam_assumed_role_arn)
        if iam_user_arn is not None:
            pulumi.set(__self__, "iam_user_arn", iam_user_arn)

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> str:
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="testS3Bucket")
    def test_s3_bucket(self) -> str:
        return pulumi.get(self, "test_s3_bucket")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        """
        Unique identifier associated with the IAM Role that the Federated Database Instance assumes when accessing the data stores.
        """
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="iamAssumedRoleArn")
    def iam_assumed_role_arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN) of the IAM Role that the Federated Database Instance assumes when accessing S3 Bucket data stores. The IAM Role must support the following actions against each S3 bucket:
        * `s3:GetObject`
        * `s3:ListBucket`
        * `s3:GetObjectVersion`
        """
        return pulumi.get(self, "iam_assumed_role_arn")

    @property
    @pulumi.getter(name="iamUserArn")
    def iam_user_arn(self) -> Optional[str]:
        """
        Amazon Resource Name (ARN) of the user that the Federated Database Instance assumes when accessing S3 Bucket data stores.
        """
        return pulumi.get(self, "iam_user_arn")


@pulumi.output_type
class FederatedDatabaseInstanceDataProcessRegion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudProvider":
            suggest = "cloud_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedDatabaseInstanceDataProcessRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedDatabaseInstanceDataProcessRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedDatabaseInstanceDataProcessRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_provider: str,
                 region: str):
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class FederatedDatabaseInstanceStorageDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxWildcardCollections":
            suggest = "max_wildcard_collections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedDatabaseInstanceStorageDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedDatabaseInstanceStorageDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedDatabaseInstanceStorageDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collections: Optional[Sequence['outputs.FederatedDatabaseInstanceStorageDatabaseCollection']] = None,
                 max_wildcard_collections: Optional[int] = None,
                 name: Optional[str] = None,
                 views: Optional[Sequence['outputs.FederatedDatabaseInstanceStorageDatabaseView']] = None):
        """
        :param str name: Name of the Atlas Federated Database Instance.
        """
        if collections is not None:
            pulumi.set(__self__, "collections", collections)
        if max_wildcard_collections is not None:
            pulumi.set(__self__, "max_wildcard_collections", max_wildcard_collections)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if views is not None:
            pulumi.set(__self__, "views", views)

    @property
    @pulumi.getter
    def collections(self) -> Optional[Sequence['outputs.FederatedDatabaseInstanceStorageDatabaseCollection']]:
        return pulumi.get(self, "collections")

    @property
    @pulumi.getter(name="maxWildcardCollections")
    def max_wildcard_collections(self) -> Optional[int]:
        return pulumi.get(self, "max_wildcard_collections")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def views(self) -> Optional[Sequence['outputs.FederatedDatabaseInstanceStorageDatabaseView']]:
        return pulumi.get(self, "views")


@pulumi.output_type
class FederatedDatabaseInstanceStorageDatabaseCollection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSources":
            suggest = "data_sources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedDatabaseInstanceStorageDatabaseCollection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedDatabaseInstanceStorageDatabaseCollection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedDatabaseInstanceStorageDatabaseCollection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_sources: Optional[Sequence['outputs.FederatedDatabaseInstanceStorageDatabaseCollectionDataSource']] = None,
                 name: Optional[str] = None):
        """
        :param str name: Name of the Atlas Federated Database Instance.
        """
        if data_sources is not None:
            pulumi.set(__self__, "data_sources", data_sources)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Optional[Sequence['outputs.FederatedDatabaseInstanceStorageDatabaseCollectionDataSource']]:
        return pulumi.get(self, "data_sources")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class FederatedDatabaseInstanceStorageDatabaseCollectionDataSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowInsecure":
            suggest = "allow_insecure"
        elif key == "collectionRegex":
            suggest = "collection_regex"
        elif key == "databaseRegex":
            suggest = "database_regex"
        elif key == "datasetName":
            suggest = "dataset_name"
        elif key == "defaultFormat":
            suggest = "default_format"
        elif key == "provenanceFieldName":
            suggest = "provenance_field_name"
        elif key == "storeName":
            suggest = "store_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedDatabaseInstanceStorageDatabaseCollectionDataSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedDatabaseInstanceStorageDatabaseCollectionDataSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedDatabaseInstanceStorageDatabaseCollectionDataSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_insecure: Optional[bool] = None,
                 collection: Optional[str] = None,
                 collection_regex: Optional[str] = None,
                 database: Optional[str] = None,
                 database_regex: Optional[str] = None,
                 dataset_name: Optional[str] = None,
                 default_format: Optional[str] = None,
                 path: Optional[str] = None,
                 provenance_field_name: Optional[str] = None,
                 store_name: Optional[str] = None,
                 urls: Optional[Sequence[str]] = None):
        if allow_insecure is not None:
            pulumi.set(__self__, "allow_insecure", allow_insecure)
        if collection is not None:
            pulumi.set(__self__, "collection", collection)
        if collection_regex is not None:
            pulumi.set(__self__, "collection_regex", collection_regex)
        if database is not None:
            pulumi.set(__self__, "database", database)
        if database_regex is not None:
            pulumi.set(__self__, "database_regex", database_regex)
        if dataset_name is not None:
            pulumi.set(__self__, "dataset_name", dataset_name)
        if default_format is not None:
            pulumi.set(__self__, "default_format", default_format)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if provenance_field_name is not None:
            pulumi.set(__self__, "provenance_field_name", provenance_field_name)
        if store_name is not None:
            pulumi.set(__self__, "store_name", store_name)
        if urls is not None:
            pulumi.set(__self__, "urls", urls)

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> Optional[bool]:
        return pulumi.get(self, "allow_insecure")

    @property
    @pulumi.getter
    def collection(self) -> Optional[str]:
        return pulumi.get(self, "collection")

    @property
    @pulumi.getter(name="collectionRegex")
    def collection_regex(self) -> Optional[str]:
        return pulumi.get(self, "collection_regex")

    @property
    @pulumi.getter
    def database(self) -> Optional[str]:
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="databaseRegex")
    def database_regex(self) -> Optional[str]:
        return pulumi.get(self, "database_regex")

    @property
    @pulumi.getter(name="datasetName")
    def dataset_name(self) -> Optional[str]:
        return pulumi.get(self, "dataset_name")

    @property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> Optional[str]:
        return pulumi.get(self, "default_format")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="provenanceFieldName")
    def provenance_field_name(self) -> Optional[str]:
        return pulumi.get(self, "provenance_field_name")

    @property
    @pulumi.getter(name="storeName")
    def store_name(self) -> Optional[str]:
        return pulumi.get(self, "store_name")

    @property
    @pulumi.getter
    def urls(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "urls")


@pulumi.output_type
class FederatedDatabaseInstanceStorageDatabaseView(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 pipeline: Optional[str] = None,
                 source: Optional[str] = None):
        """
        :param str name: Name of the Atlas Federated Database Instance.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if pipeline is not None:
            pulumi.set(__self__, "pipeline", pipeline)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def pipeline(self) -> Optional[str]:
        return pulumi.get(self, "pipeline")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        return pulumi.get(self, "source")


@pulumi.output_type
class FederatedDatabaseInstanceStorageStore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalStorageClasses":
            suggest = "additional_storage_classes"
        elif key == "allowInsecure":
            suggest = "allow_insecure"
        elif key == "clusterName":
            suggest = "cluster_name"
        elif key == "defaultFormat":
            suggest = "default_format"
        elif key == "includeTags":
            suggest = "include_tags"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "readPreference":
            suggest = "read_preference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedDatabaseInstanceStorageStore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedDatabaseInstanceStorageStore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedDatabaseInstanceStorageStore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_storage_classes: Optional[Sequence[str]] = None,
                 allow_insecure: Optional[bool] = None,
                 bucket: Optional[str] = None,
                 cluster_name: Optional[str] = None,
                 default_format: Optional[str] = None,
                 delimiter: Optional[str] = None,
                 include_tags: Optional[bool] = None,
                 name: Optional[str] = None,
                 prefix: Optional[str] = None,
                 project_id: Optional[str] = None,
                 provider: Optional[str] = None,
                 public: Optional[str] = None,
                 read_preference: Optional['outputs.FederatedDatabaseInstanceStorageStoreReadPreference'] = None,
                 region: Optional[str] = None,
                 urls: Optional[Sequence[str]] = None):
        """
        :param str name: Name of the Atlas Federated Database Instance.
        :param str project_id: The unique ID for the project to create a Federated Database Instance.
        """
        if additional_storage_classes is not None:
            pulumi.set(__self__, "additional_storage_classes", additional_storage_classes)
        if allow_insecure is not None:
            pulumi.set(__self__, "allow_insecure", allow_insecure)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if default_format is not None:
            pulumi.set(__self__, "default_format", default_format)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if include_tags is not None:
            pulumi.set(__self__, "include_tags", include_tags)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if public is not None:
            pulumi.set(__self__, "public", public)
        if read_preference is not None:
            pulumi.set(__self__, "read_preference", read_preference)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if urls is not None:
            pulumi.set(__self__, "urls", urls)

    @property
    @pulumi.getter(name="additionalStorageClasses")
    def additional_storage_classes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "additional_storage_classes")

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> Optional[bool]:
        return pulumi.get(self, "allow_insecure")

    @property
    @pulumi.getter
    def bucket(self) -> Optional[str]:
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> Optional[str]:
        return pulumi.get(self, "default_format")

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[str]:
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="includeTags")
    def include_tags(self) -> Optional[bool]:
        return pulumi.get(self, "include_tags")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        """
        The unique ID for the project to create a Federated Database Instance.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def provider(self) -> Optional[str]:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def public(self) -> Optional[str]:
        return pulumi.get(self, "public")

    @property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> Optional['outputs.FederatedDatabaseInstanceStorageStoreReadPreference']:
        return pulumi.get(self, "read_preference")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def urls(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "urls")


@pulumi.output_type
class FederatedDatabaseInstanceStorageStoreReadPreference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxStalenessSeconds":
            suggest = "max_staleness_seconds"
        elif key == "tagSets":
            suggest = "tag_sets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedDatabaseInstanceStorageStoreReadPreference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedDatabaseInstanceStorageStoreReadPreference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedDatabaseInstanceStorageStoreReadPreference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_staleness_seconds: Optional[int] = None,
                 mode: Optional[str] = None,
                 tag_sets: Optional[Sequence['outputs.FederatedDatabaseInstanceStorageStoreReadPreferenceTagSet']] = None):
        if max_staleness_seconds is not None:
            pulumi.set(__self__, "max_staleness_seconds", max_staleness_seconds)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if tag_sets is not None:
            pulumi.set(__self__, "tag_sets", tag_sets)

    @property
    @pulumi.getter(name="maxStalenessSeconds")
    def max_staleness_seconds(self) -> Optional[int]:
        return pulumi.get(self, "max_staleness_seconds")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="tagSets")
    def tag_sets(self) -> Optional[Sequence['outputs.FederatedDatabaseInstanceStorageStoreReadPreferenceTagSet']]:
        return pulumi.get(self, "tag_sets")


@pulumi.output_type
class FederatedDatabaseInstanceStorageStoreReadPreferenceTagSet(dict):
    def __init__(__self__, *,
                 tags: Sequence['outputs.FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTag']):
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTag']:
        return pulumi.get(self, "tags")


@pulumi.output_type
class FederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTag(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: Name of the Atlas Federated Database Instance.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class FederatedSettingsOrgConfigUserConflict(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emailAddress":
            suggest = "email_address"
        elif key == "federationSettingsId":
            suggest = "federation_settings_id"
        elif key == "firstName":
            suggest = "first_name"
        elif key == "lastName":
            suggest = "last_name"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedSettingsOrgConfigUserConflict. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedSettingsOrgConfigUserConflict.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedSettingsOrgConfigUserConflict.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email_address: Optional[str] = None,
                 federation_settings_id: Optional[str] = None,
                 first_name: Optional[str] = None,
                 last_name: Optional[str] = None,
                 user_id: Optional[str] = None):
        """
        :param str email_address: Email address of the the user that conflicts with selected domains.
        :param str federation_settings_id: Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        :param str first_name: First name of the the user that conflicts with selected domains.
        :param str last_name: Last name of the the user that conflicts with selected domains.
        :param str user_id: Name of the Atlas user that conflicts with selected domains.
        """
        if email_address is not None:
            pulumi.set(__self__, "email_address", email_address)
        if federation_settings_id is not None:
            pulumi.set(__self__, "federation_settings_id", federation_settings_id)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> Optional[str]:
        """
        Email address of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter(name="federationSettingsId")
    def federation_settings_id(self) -> Optional[str]:
        """
        Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        """
        return pulumi.get(self, "federation_settings_id")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[str]:
        """
        First name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[str]:
        """
        Last name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[str]:
        """
        Name of the Atlas user that conflicts with selected domains.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class FederatedSettingsOrgRoleMappingRoleAssignment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupId":
            suggest = "group_id"
        elif key == "orgId":
            suggest = "org_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FederatedSettingsOrgRoleMappingRoleAssignment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FederatedSettingsOrgRoleMappingRoleAssignment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FederatedSettingsOrgRoleMappingRoleAssignment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_id: Optional[str] = None,
                 org_id: Optional[str] = None,
                 roles: Optional[Sequence[str]] = None):
        """
        :param str group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param Sequence[str] roles: Specifies the Roles that are attached to the Role Mapping. Available role IDs can be found on [the User Roles
               Reference](https://www.mongodb.com/docs/atlas/reference/user-roles/).
        """
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[str]:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        """
        Specifies the Roles that are attached to the Role Mapping. Available role IDs can be found on [the User Roles
        Reference](https://www.mongodb.com/docs/atlas/reference/user-roles/).
        """
        return pulumi.get(self, "roles")


@pulumi.output_type
class GlobalClusterConfigCustomZoneMapping(dict):
    def __init__(__self__, *,
                 location: Optional[str] = None,
                 zone: Optional[str] = None):
        """
        :param str location: The ISO location code to which you want to map a zone in your Global Cluster. You can find a list of all supported location codes [here](https://cloud.mongodb.com/static/atlas/country_iso_codes.txt).
        :param str zone: The name of the zone in your Global Cluster that you want to map to location.
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        The ISO location code to which you want to map a zone in your Global Cluster. You can find a list of all supported location codes [here](https://cloud.mongodb.com/static/atlas/country_iso_codes.txt).
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        """
        The name of the zone in your Global Cluster that you want to map to location.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GlobalClusterConfigManagedNamespace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customShardKey":
            suggest = "custom_shard_key"
        elif key == "isCustomShardKeyHashed":
            suggest = "is_custom_shard_key_hashed"
        elif key == "isShardKeyUnique":
            suggest = "is_shard_key_unique"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalClusterConfigManagedNamespace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalClusterConfigManagedNamespace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalClusterConfigManagedNamespace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collection: str,
                 custom_shard_key: str,
                 db: str,
                 is_custom_shard_key_hashed: Optional[bool] = None,
                 is_shard_key_unique: Optional[bool] = None):
        """
        :param str collection: The name of the collection associated with the managed namespace.
        :param str custom_shard_key: The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        :param str db: The name of the database containing the collection.
        :param bool is_custom_shard_key_hashed: Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.
        :param bool is_shard_key_unique: Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).
        """
        pulumi.set(__self__, "collection", collection)
        pulumi.set(__self__, "custom_shard_key", custom_shard_key)
        pulumi.set(__self__, "db", db)
        if is_custom_shard_key_hashed is not None:
            pulumi.set(__self__, "is_custom_shard_key_hashed", is_custom_shard_key_hashed)
        if is_shard_key_unique is not None:
            pulumi.set(__self__, "is_shard_key_unique", is_shard_key_unique)

    @property
    @pulumi.getter
    def collection(self) -> str:
        """
        The name of the collection associated with the managed namespace.
        """
        return pulumi.get(self, "collection")

    @property
    @pulumi.getter(name="customShardKey")
    def custom_shard_key(self) -> str:
        """
        The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        """
        return pulumi.get(self, "custom_shard_key")

    @property
    @pulumi.getter
    def db(self) -> str:
        """
        The name of the database containing the collection.
        """
        return pulumi.get(self, "db")

    @property
    @pulumi.getter(name="isCustomShardKeyHashed")
    def is_custom_shard_key_hashed(self) -> Optional[bool]:
        """
        Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.
        """
        return pulumi.get(self, "is_custom_shard_key_hashed")

    @property
    @pulumi.getter(name="isShardKeyUnique")
    def is_shard_key_unique(self) -> Optional[bool]:
        """
        Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).
        """
        return pulumi.get(self, "is_shard_key_unique")


@pulumi.output_type
class LdapConfigurationUserToDnMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ldapQuery":
            suggest = "ldap_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LdapConfigurationUserToDnMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LdapConfigurationUserToDnMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LdapConfigurationUserToDnMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ldap_query: Optional[str] = None,
                 match: Optional[str] = None,
                 substitution: Optional[str] = None):
        if ldap_query is not None:
            pulumi.set(__self__, "ldap_query", ldap_query)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if substitution is not None:
            pulumi.set(__self__, "substitution", substitution)

    @property
    @pulumi.getter(name="ldapQuery")
    def ldap_query(self) -> Optional[str]:
        return pulumi.get(self, "ldap_query")

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def substitution(self) -> Optional[str]:
        return pulumi.get(self, "substitution")


@pulumi.output_type
class LdapVerifyLink(dict):
    def __init__(__self__, *,
                 href: Optional[str] = None,
                 rel: Optional[str] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[str]:
        return pulumi.get(self, "href")

    @property
    @pulumi.getter
    def rel(self) -> Optional[str]:
        return pulumi.get(self, "rel")


@pulumi.output_type
class LdapVerifyValidation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "validationType":
            suggest = "validation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LdapVerifyValidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LdapVerifyValidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LdapVerifyValidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 status: Optional[str] = None,
                 validation_type: Optional[str] = None):
        """
        :param str status: The current status of the LDAP over TLS/SSL configuration. One of the following values: `PENDING`, `SUCCESS`, and `FAILED`.
        """
        if status is not None:
            pulumi.set(__self__, "status", status)
        if validation_type is not None:
            pulumi.set(__self__, "validation_type", validation_type)

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The current status of the LDAP over TLS/SSL configuration. One of the following values: `PENDING`, `SUCCESS`, and `FAILED`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="validationType")
    def validation_type(self) -> Optional[str]:
        return pulumi.get(self, "validation_type")


@pulumi.output_type
class OnlineArchiveCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dateField":
            suggest = "date_field"
        elif key == "dateFormat":
            suggest = "date_format"
        elif key == "expireAfterDays":
            suggest = "expire_after_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineArchiveCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineArchiveCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineArchiveCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 date_field: Optional[str] = None,
                 date_format: Optional[str] = None,
                 expire_after_days: Optional[int] = None,
                 query: Optional[str] = None):
        """
        :param str type: Type of criteria (DATE, CUSTOM)
               
               The following fields are required for criteria type `DATE`
        :param str date_field: Indexed database parameter that stores the date that determines when data moves to the online archive. MongoDB Cloud archives the data when the current date exceeds the date in this database parameter plus the number of days specified through the expireAfterDays parameter.
        :param str date_format: Syntax used to write the date after which data moves to the online archive. Date can be expressed as ISO 8601 or Epoch timestamps. The Epoch timestamp can be expressed as nanoseconds, milliseconds, or seconds. You must set `type` to `DATE` if `collectionType` is `TIMESERIES`. Valid values:  ISODATE (default), EPOCH_SECONDS, EPOCH_MILLIS, EPOCH_NANOSECONDS.
        :param int expire_after_days: Number of days after the value in the criteria.dateField when MongoDB Cloud archives data in the specified cluster.
               
               **_NOTE: if `DATE` is selected, the `partition_fields.field_name` must be completed with the `date_field` value_**
               
               The only field required for criteria type `CUSTOM`
        :param str query: JSON query to use to select documents for archiving. Atlas uses the specified query with the db.collection.find(query) command. The empty document {} to return all documents is not supported.
        """
        pulumi.set(__self__, "type", type)
        if date_field is not None:
            pulumi.set(__self__, "date_field", date_field)
        if date_format is not None:
            pulumi.set(__self__, "date_format", date_format)
        if expire_after_days is not None:
            pulumi.set(__self__, "expire_after_days", expire_after_days)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of criteria (DATE, CUSTOM)

        The following fields are required for criteria type `DATE`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="dateField")
    def date_field(self) -> Optional[str]:
        """
        Indexed database parameter that stores the date that determines when data moves to the online archive. MongoDB Cloud archives the data when the current date exceeds the date in this database parameter plus the number of days specified through the expireAfterDays parameter.
        """
        return pulumi.get(self, "date_field")

    @property
    @pulumi.getter(name="dateFormat")
    def date_format(self) -> Optional[str]:
        """
        Syntax used to write the date after which data moves to the online archive. Date can be expressed as ISO 8601 or Epoch timestamps. The Epoch timestamp can be expressed as nanoseconds, milliseconds, or seconds. You must set `type` to `DATE` if `collectionType` is `TIMESERIES`. Valid values:  ISODATE (default), EPOCH_SECONDS, EPOCH_MILLIS, EPOCH_NANOSECONDS.
        """
        return pulumi.get(self, "date_format")

    @property
    @pulumi.getter(name="expireAfterDays")
    def expire_after_days(self) -> Optional[int]:
        """
        Number of days after the value in the criteria.dateField when MongoDB Cloud archives data in the specified cluster.

        **_NOTE: if `DATE` is selected, the `partition_fields.field_name` must be completed with the `date_field` value_**

        The only field required for criteria type `CUSTOM`
        """
        return pulumi.get(self, "expire_after_days")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        JSON query to use to select documents for archiving. Atlas uses the specified query with the db.collection.find(query) command. The empty document {} to return all documents is not supported.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class OnlineArchiveDataExpirationRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expireAfterDays":
            suggest = "expire_after_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineArchiveDataExpirationRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineArchiveDataExpirationRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineArchiveDataExpirationRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expire_after_days: int):
        """
        :param int expire_after_days: Number of days used in the date criteria for nominating documents for deletion. Value must be between 7 and 9215.
        """
        pulumi.set(__self__, "expire_after_days", expire_after_days)

    @property
    @pulumi.getter(name="expireAfterDays")
    def expire_after_days(self) -> int:
        """
        Number of days used in the date criteria for nominating documents for deletion. Value must be between 7 and 9215.
        """
        return pulumi.get(self, "expire_after_days")


@pulumi.output_type
class OnlineArchiveDataProcessRegion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudProvider":
            suggest = "cloud_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineArchiveDataProcessRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineArchiveDataProcessRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineArchiveDataProcessRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_provider: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str cloud_provider: Human-readable label that identifies the Cloud service provider where you wish to store your archived data. `AZURE` may be selected only if Azure is the Cloud service provider for the cluster and no AWS online archive has been created for the cluster.
        :param str region: Human-readable label that identifies the geographic location of the region where you wish to store your archived data. For allowed values, see [MongoDB Atlas API documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Online-Archive/operation/createOnlineArchive)
        """
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[str]:
        """
        Human-readable label that identifies the Cloud service provider where you wish to store your archived data. `AZURE` may be selected only if Azure is the Cloud service provider for the cluster and no AWS online archive has been created for the cluster.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Human-readable label that identifies the geographic location of the region where you wish to store your archived data. For allowed values, see [MongoDB Atlas API documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Online-Archive/operation/createOnlineArchive)
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class OnlineArchivePartitionField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "fieldType":
            suggest = "field_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineArchivePartitionField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineArchivePartitionField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineArchivePartitionField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: str,
                 order: int,
                 field_type: Optional[str] = None):
        """
        :param str field_name: Human-readable label that identifies the parameter that MongoDB Cloud uses to partition data. To specify a nested parameter, use the dot notation.
        :param int order: Sequence in which MongoDB Cloud slices the collection data to create partitions. The resource expresses this sequence starting with zero. The value of the `criteria.dateField` parameter defaults as the first item in the partition sequence.
        :param str field_type: Data type of the parameter that that MongoDB Cloud uses to partition data. Partition parameters of type UUID must be of binary subtype 4. MongoDB Cloud skips partition parameters of type UUID with subtype 3. Valid values: `date`, `int`, `long`, `objectId`, `string`, `uuid`.
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "order", order)
        if field_type is not None:
            pulumi.set(__self__, "field_type", field_type)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        """
        Human-readable label that identifies the parameter that MongoDB Cloud uses to partition data. To specify a nested parameter, use the dot notation.
        """
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def order(self) -> int:
        """
        Sequence in which MongoDB Cloud slices the collection data to create partitions. The resource expresses this sequence starting with zero. The value of the `criteria.dateField` parameter defaults as the first item in the partition sequence.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> Optional[str]:
        """
        Data type of the parameter that that MongoDB Cloud uses to partition data. Partition parameters of type UUID must be of binary subtype 4. MongoDB Cloud skips partition parameters of type UUID with subtype 3. Valid values: `date`, `int`, `long`, `objectId`, `string`, `uuid`.
        """
        return pulumi.get(self, "field_type")


@pulumi.output_type
class OnlineArchiveSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfMonth":
            suggest = "day_of_month"
        elif key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "endHour":
            suggest = "end_hour"
        elif key == "endMinute":
            suggest = "end_minute"
        elif key == "startHour":
            suggest = "start_hour"
        elif key == "startMinute":
            suggest = "start_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OnlineArchiveSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OnlineArchiveSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OnlineArchiveSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 day_of_month: Optional[int] = None,
                 day_of_week: Optional[int] = None,
                 end_hour: Optional[int] = None,
                 end_minute: Optional[int] = None,
                 start_hour: Optional[int] = None,
                 start_minute: Optional[int] = None):
        """
        :param str type: Type of schedule (``DAILY`, `MONTHLY`, `WEEKLY`).
        :param int day_of_month: Day of the month when the scheduled archive starts. This field should be provided only when schedule `type` is `MONTHLY`.
        :param int day_of_week: Day of the week when the scheduled archive starts. The week starts with Monday (1) and ends with Sunday (7). This field should be provided only when schedule `type` is `WEEKLY`.
        :param int end_hour: Hour of the day when the scheduled window to run one online archive ends.
        :param int end_minute: Minute of the hour when the scheduled window to run one online archive ends.
        :param int start_hour: Hour of the day when the when the scheduled window to run one online archive starts.
        :param int start_minute: Minute of the hour when the scheduled window to run one online archive starts.
        """
        pulumi.set(__self__, "type", type)
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)
        if end_hour is not None:
            pulumi.set(__self__, "end_hour", end_hour)
        if end_minute is not None:
            pulumi.set(__self__, "end_minute", end_minute)
        if start_hour is not None:
            pulumi.set(__self__, "start_hour", start_hour)
        if start_minute is not None:
            pulumi.set(__self__, "start_minute", start_minute)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of schedule (``DAILY`, `MONTHLY`, `WEEKLY`).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[int]:
        """
        Day of the month when the scheduled archive starts. This field should be provided only when schedule `type` is `MONTHLY`.
        """
        return pulumi.get(self, "day_of_month")

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[int]:
        """
        Day of the week when the scheduled archive starts. The week starts with Monday (1) and ends with Sunday (7). This field should be provided only when schedule `type` is `WEEKLY`.
        """
        return pulumi.get(self, "day_of_week")

    @property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> Optional[int]:
        """
        Hour of the day when the scheduled window to run one online archive ends.
        """
        return pulumi.get(self, "end_hour")

    @property
    @pulumi.getter(name="endMinute")
    def end_minute(self) -> Optional[int]:
        """
        Minute of the hour when the scheduled window to run one online archive ends.
        """
        return pulumi.get(self, "end_minute")

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> Optional[int]:
        """
        Hour of the day when the when the scheduled window to run one online archive starts.
        """
        return pulumi.get(self, "start_hour")

    @property
    @pulumi.getter(name="startMinute")
    def start_minute(self) -> Optional[int]:
        """
        Minute of the hour when the scheduled window to run one online archive starts.
        """
        return pulumi.get(self, "start_minute")


@pulumi.output_type
class PrivateLinkEndpointServiceEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointName":
            suggest = "endpoint_name"
        elif key == "ipAddress":
            suggest = "ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateLinkEndpointServiceEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateLinkEndpointServiceEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateLinkEndpointServiceEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_name: Optional[str] = None,
                 ip_address: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str endpoint_name: Forwarding rule that corresponds to the endpoint you created in GCP.
        :param str ip_address: Private IP address of the endpoint you created in GCP.
        :param str status: Status of the endpoint. Atlas returns one of the [values shown above](https://docs.atlas.mongodb.com/reference/api/private-endpoints-endpoint-create-one/#std-label-ref-status-field).
        """
        if endpoint_name is not None:
            pulumi.set(__self__, "endpoint_name", endpoint_name)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="endpointName")
    def endpoint_name(self) -> Optional[str]:
        """
        Forwarding rule that corresponds to the endpoint you created in GCP.
        """
        return pulumi.get(self, "endpoint_name")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        Private IP address of the endpoint you created in GCP.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Status of the endpoint. Atlas returns one of the [values shown above](https://docs.atlas.mongodb.com/reference/api/private-endpoints-endpoint-create-one/#std-label-ref-status-field).
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ProjectApiKeyProjectAssignment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"
        elif key == "roleNames":
            suggest = "role_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectApiKeyProjectAssignment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectApiKeyProjectAssignment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectApiKeyProjectAssignment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_id: str,
                 role_names: Sequence[str]):
        """
        :param str project_id: Project ID to assign to Access Key
        :param Sequence[str] role_names: List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project. You must specify an array even if you are only associating a single role with the Programmatic API key. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) describes the valid roles that can be assigned.
        """
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "role_names", role_names)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Project ID to assign to Access Key
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[str]:
        """
        List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project. You must specify an array even if you are only associating a single role with the Programmatic API key. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) describes the valid roles that can be assigned.
        """
        return pulumi.get(self, "role_names")


@pulumi.output_type
class ProjectIpAccessListTimeouts(dict):
    def __init__(__self__, *,
                 delete: Optional[str] = None,
                 read: Optional[str] = None):
        """
        :param str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param str read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)

    @property
    @pulumi.getter
    def delete(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def read(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")


@pulumi.output_type
class ProjectIpAddresses(dict):
    def __init__(__self__, *,
                 services: Optional['outputs.ProjectIpAddressesServices'] = None):
        if services is not None:
            pulumi.set(__self__, "services", services)

    @property
    @pulumi.getter
    def services(self) -> Optional['outputs.ProjectIpAddressesServices']:
        return pulumi.get(self, "services")


@pulumi.output_type
class ProjectIpAddressesServices(dict):
    def __init__(__self__, *,
                 clusters: Optional[Sequence['outputs.ProjectIpAddressesServicesCluster']] = None):
        if clusters is not None:
            pulumi.set(__self__, "clusters", clusters)

    @property
    @pulumi.getter
    def clusters(self) -> Optional[Sequence['outputs.ProjectIpAddressesServicesCluster']]:
        return pulumi.get(self, "clusters")


@pulumi.output_type
class ProjectIpAddressesServicesCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectIpAddressesServicesCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectIpAddressesServicesCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectIpAddressesServicesCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_name: Optional[str] = None,
                 inbounds: Optional[Sequence[str]] = None,
                 outbounds: Optional[Sequence[str]] = None):
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if inbounds is not None:
            pulumi.set(__self__, "inbounds", inbounds)
        if outbounds is not None:
            pulumi.set(__self__, "outbounds", outbounds)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter
    def inbounds(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "inbounds")

    @property
    @pulumi.getter
    def outbounds(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "outbounds")


@pulumi.output_type
class ProjectLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "currentUsage":
            suggest = "current_usage"
        elif key == "defaultLimit":
            suggest = "default_limit"
        elif key == "maximumLimit":
            suggest = "maximum_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 value: int,
                 current_usage: Optional[int] = None,
                 default_limit: Optional[int] = None,
                 maximum_limit: Optional[int] = None):
        """
        :param str name: Human-readable label that identifies this project limit. See [Project Limit Documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Projects/operation/setProjectLimit) under `limitName` parameter to find all the limits that can be defined.
        :param int value: Amount to set the limit to. Use the [Project Limit Documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Projects/operation/setProjectLimit) under `limitName` parameter to verify the override limits.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if current_usage is not None:
            pulumi.set(__self__, "current_usage", current_usage)
        if default_limit is not None:
            pulumi.set(__self__, "default_limit", default_limit)
        if maximum_limit is not None:
            pulumi.set(__self__, "maximum_limit", maximum_limit)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Human-readable label that identifies this project limit. See [Project Limit Documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Projects/operation/setProjectLimit) under `limitName` parameter to find all the limits that can be defined.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Amount to set the limit to. Use the [Project Limit Documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Projects/operation/setProjectLimit) under `limitName` parameter to verify the override limits.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="currentUsage")
    def current_usage(self) -> Optional[int]:
        return pulumi.get(self, "current_usage")

    @property
    @pulumi.getter(name="defaultLimit")
    def default_limit(self) -> Optional[int]:
        return pulumi.get(self, "default_limit")

    @property
    @pulumi.getter(name="maximumLimit")
    def maximum_limit(self) -> Optional[int]:
        return pulumi.get(self, "maximum_limit")


@pulumi.output_type
class ProjectTeam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleNames":
            suggest = "role_names"
        elif key == "teamId":
            suggest = "team_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectTeam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectTeam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectTeam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_names: Sequence[str],
                 team_id: str):
        """
        :param Sequence[str] role_names: Each string in the array represents a project role you want to assign to the team. Every user associated with the team inherits these roles. You must specify an array even if you are only associating a single role with the team. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles a user can have.
               
               > **NOTE:** Project created by API Keys must belong to an existing organization.
        :param str team_id: The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
        """
        pulumi.set(__self__, "role_names", role_names)
        pulumi.set(__self__, "team_id", team_id)

    @property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[str]:
        """
        Each string in the array represents a project role you want to assign to the team. Every user associated with the team inherits these roles. You must specify an array even if you are only associating a single role with the team. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles a user can have.

        > **NOTE:** Project created by API Keys must belong to an existing organization.
        """
        return pulumi.get(self, "role_names")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> str:
        """
        The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
        """
        return pulumi.get(self, "team_id")


@pulumi.output_type
class PushBasedLogExportTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[str] = None,
                 delete: Optional[str] = None,
                 update: Optional[str] = None):
        """
        :param str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def update(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class SearchDeploymentSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceSize":
            suggest = "instance_size"
        elif key == "nodeCount":
            suggest = "node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SearchDeploymentSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SearchDeploymentSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SearchDeploymentSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_size: str,
                 node_count: int):
        """
        :param str instance_size: Hardware specification for the search node instance sizes. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Atlas-Search/operation/createAtlasSearchDeployment) describes the valid values. More details can also be found in the [Search Node Documentation](https://www.mongodb.com/docs/atlas/cluster-config/multi-cloud-distribution/#search-tier).
        :param int node_count: Number of search nodes in the cluster.
        """
        pulumi.set(__self__, "instance_size", instance_size)
        pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the search node instance sizes. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Atlas-Search/operation/createAtlasSearchDeployment) describes the valid values. More details can also be found in the [Search Node Documentation](https://www.mongodb.com/docs/atlas/cluster-config/multi-cloud-distribution/#search-tier).
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> int:
        """
        Number of search nodes in the cluster.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class SearchDeploymentTimeouts(dict):
    def __init__(__self__, *,
                 create: Optional[str] = None,
                 delete: Optional[str] = None,
                 update: Optional[str] = None):
        """
        :param str create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param str delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param str update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @property
    @pulumi.getter
    def create(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @property
    @pulumi.getter
    def delete(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter
    def update(self) -> Optional[str]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")


@pulumi.output_type
class SearchIndexSynonym(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceCollection":
            suggest = "source_collection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SearchIndexSynonym. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SearchIndexSynonym.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SearchIndexSynonym.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 analyzer: str,
                 name: str,
                 source_collection: str):
        """
        :param str analyzer: [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index. Defaults to [lucene.standard](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/standard/#std-label-ref-standard-analyzer)
        :param str name: The name of the search index you want to create.
        :param str source_collection: (Required) Name of the source MongoDB collection for the synonyms. Documents in this collection must be in the format described in the [Synonyms Source Collection Documents](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-coll-spec).
        """
        pulumi.set(__self__, "analyzer", analyzer)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source_collection", source_collection)

    @property
    @pulumi.getter
    def analyzer(self) -> str:
        """
        [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index. Defaults to [lucene.standard](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/standard/#std-label-ref-standard-analyzer)
        """
        return pulumi.get(self, "analyzer")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the search index you want to create.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sourceCollection")
    def source_collection(self) -> str:
        """
        (Required) Name of the source MongoDB collection for the synonyms. Documents in this collection must be in the format described in the [Synonyms Source Collection Documents](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-coll-spec).
        """
        return pulumi.get(self, "source_collection")


@pulumi.output_type
class ServerlessInstanceLink(dict):
    def __init__(__self__, *,
                 href: Optional[str] = None,
                 rel: Optional[str] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[str]:
        return pulumi.get(self, "href")

    @property
    @pulumi.getter
    def rel(self) -> Optional[str]:
        return pulumi.get(self, "rel")


@pulumi.output_type
class ServerlessInstanceTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Constant that defines the set of the tag.
        :param str value: Variable that belongs to the set of the tag.
               
               To learn more, see [Resource Tags](https://dochub.mongodb.org/core/add-cluster-tag-atlas).
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Constant that defines the set of the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Variable that belongs to the set of the tag.

        To learn more, see [Resource Tags](https://dochub.mongodb.org/core/add-cluster-tag-atlas).
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class StreamConnectionAuthentication(dict):
    def __init__(__self__, *,
                 mechanism: Optional[str] = None,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str mechanism: Style of authentication. Can be one of `PLAIN`, `SCRAM-256`, or `SCRAM-512`.
        :param str password: Password of the account to connect to the Kafka cluster.
        :param str username: Username of the account to connect to the Kafka cluster.
        """
        if mechanism is not None:
            pulumi.set(__self__, "mechanism", mechanism)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def mechanism(self) -> Optional[str]:
        """
        Style of authentication. Can be one of `PLAIN`, `SCRAM-256`, or `SCRAM-512`.
        """
        return pulumi.get(self, "mechanism")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password of the account to connect to the Kafka cluster.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username of the account to connect to the Kafka cluster.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class StreamConnectionDbRoleToExecute(dict):
    def __init__(__self__, *,
                 role: str,
                 type: str):
        """
        :param str role: The name of the role to use. Value can be  `atlasAdmin`, `readWriteAnyDatabase`, or `readAnyDatabase` if `type` is set to `BUILT_IN`, or the name of a user-defined role if `type` is set to `CUSTOM`.
        :param str type: Type of connection. Can be either `Cluster`, `Kafka` or `Sample`.
        """
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        The name of the role to use. Value can be  `atlasAdmin`, `readWriteAnyDatabase`, or `readAnyDatabase` if `type` is set to `BUILT_IN`, or the name of a user-defined role if `type` is set to `CUSTOM`.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of connection. Can be either `Cluster`, `Kafka` or `Sample`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class StreamConnectionSecurity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "brokerPublicCertificate":
            suggest = "broker_public_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamConnectionSecurity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamConnectionSecurity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamConnectionSecurity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 broker_public_certificate: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        :param str broker_public_certificate: A trusted, public x509 certificate for connecting to Kafka over SSL. String value of the certificate must be defined in the attribute.
        :param str protocol: Describes the transport type. Can be either `PLAINTEXT` or `SSL`.
        """
        if broker_public_certificate is not None:
            pulumi.set(__self__, "broker_public_certificate", broker_public_certificate)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="brokerPublicCertificate")
    def broker_public_certificate(self) -> Optional[str]:
        """
        A trusted, public x509 certificate for connecting to Kafka over SSL. String value of the certificate must be defined in the attribute.
        """
        return pulumi.get(self, "broker_public_certificate")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Describes the transport type. Can be either `PLAINTEXT` or `SSL`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class StreamInstanceDataProcessRegion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudProvider":
            suggest = "cloud_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamInstanceDataProcessRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamInstanceDataProcessRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamInstanceDataProcessRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_provider: str,
                 region: str):
        """
        :param str cloud_provider: Label that identifies the cloud service provider where MongoDB Cloud performs stream processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        :param str region: Name of the cloud provider region hosting Atlas Stream Processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        Label that identifies the cloud service provider where MongoDB Cloud performs stream processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Name of the cloud provider region hosting Atlas Stream Processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class StreamInstanceStreamConfig(dict):
    def __init__(__self__, *,
                 tier: Optional[str] = None):
        """
        :param str tier: Selected tier for the Stream Instance. Configures Memory / VCPU allowances. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        if tier is not None:
            pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def tier(self) -> Optional[str]:
        """
        Selected tier for the Stream Instance. Configures Memory / VCPU allowances. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class StreamProcessorOptions(dict):
    def __init__(__self__, *,
                 dlq: 'outputs.StreamProcessorOptionsDlq'):
        """
        :param 'StreamProcessorOptionsDlqArgs' dlq: Dead letter queue for the stream processor. Refer to the [MongoDB Atlas Docs](https://www.mongodb.com/docs/atlas/reference/glossary/#std-term-dead-letter-queue) for more information.
        """
        pulumi.set(__self__, "dlq", dlq)

    @property
    @pulumi.getter
    def dlq(self) -> 'outputs.StreamProcessorOptionsDlq':
        """
        Dead letter queue for the stream processor. Refer to the [MongoDB Atlas Docs](https://www.mongodb.com/docs/atlas/reference/glossary/#std-term-dead-letter-queue) for more information.
        """
        return pulumi.get(self, "dlq")


@pulumi.output_type
class StreamProcessorOptionsDlq(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionName":
            suggest = "connection_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamProcessorOptionsDlq. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamProcessorOptionsDlq.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamProcessorOptionsDlq.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 coll: str,
                 connection_name: str,
                 db: str):
        """
        :param str coll: Name of the collection to use for the DLQ.
        :param str connection_name: Name of the connection to write DLQ messages to. Must be an Atlas connection.
        :param str db: Name of the database to use for the DLQ.
        """
        pulumi.set(__self__, "coll", coll)
        pulumi.set(__self__, "connection_name", connection_name)
        pulumi.set(__self__, "db", db)

    @property
    @pulumi.getter
    def coll(self) -> str:
        """
        Name of the collection to use for the DLQ.
        """
        return pulumi.get(self, "coll")

    @property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> str:
        """
        Name of the connection to write DLQ messages to. Must be an Atlas connection.
        """
        return pulumi.get(self, "connection_name")

    @property
    @pulumi.getter
    def db(self) -> str:
        """
        Name of the database to use for the DLQ.
        """
        return pulumi.get(self, "db")


@pulumi.output_type
class X509AuthenticationDatabaseUserCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "notAfter":
            suggest = "not_after"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in X509AuthenticationDatabaseUserCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        X509AuthenticationDatabaseUserCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        X509AuthenticationDatabaseUserCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 group_id: Optional[str] = None,
                 id: Optional[int] = None,
                 not_after: Optional[str] = None,
                 subject: Optional[str] = None):
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if not_after is not None:
            pulumi.set(__self__, "not_after", not_after)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> Optional[str]:
        return pulumi.get(self, "not_after")

    @property
    @pulumi.getter
    def subject(self) -> Optional[str]:
        return pulumi.get(self, "subject")


@pulumi.output_type
class Get509AuthenticationDatabaseUserCertificateResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 group_id: str,
                 id: int,
                 not_after: str,
                 subject: str):
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "not_after", not_after)
        pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> str:
        return pulumi.get(self, "not_after")

    @property
    @pulumi.getter
    def subject(self) -> str:
        return pulumi.get(self, "subject")


@pulumi.output_type
class GetAccessListApiKeysResultResult(dict):
    def __init__(__self__, *,
                 access_count: int,
                 cidr_block: str,
                 created: str,
                 ip_address: str,
                 last_used: str,
                 last_used_address: str):
        """
        :param str cidr_block: Range of IP addresses in CIDR notation to be added to the access list.
        :param str ip_address: Single IP address to be added to the access list.
        """
        pulumi.set(__self__, "access_count", access_count)
        pulumi.set(__self__, "cidr_block", cidr_block)
        pulumi.set(__self__, "created", created)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "last_used", last_used)
        pulumi.set(__self__, "last_used_address", last_used_address)

    @property
    @pulumi.getter(name="accessCount")
    def access_count(self) -> int:
        return pulumi.get(self, "access_count")

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> str:
        """
        Range of IP addresses in CIDR notation to be added to the access list.
        """
        return pulumi.get(self, "cidr_block")

    @property
    @pulumi.getter
    def created(self) -> str:
        return pulumi.get(self, "created")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        Single IP address to be added to the access list.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="lastUsed")
    def last_used(self) -> str:
        return pulumi.get(self, "last_used")

    @property
    @pulumi.getter(name="lastUsedAddress")
    def last_used_address(self) -> str:
        return pulumi.get(self, "last_used_address")


@pulumi.output_type
class GetAdvancedClusterAdvancedConfigurationResult(dict):
    def __init__(__self__, *,
                 change_stream_options_pre_and_post_images_expire_after_seconds: int,
                 default_read_concern: str,
                 default_write_concern: str,
                 fail_index_key_too_long: bool,
                 javascript_enabled: bool,
                 minimum_enabled_tls_protocol: str,
                 no_table_scan: bool,
                 oplog_min_retention_hours: float,
                 oplog_size_mb: int,
                 sample_refresh_interval_bi_connector: int,
                 sample_size_bi_connector: int,
                 transaction_lifetime_limit_seconds: int):
        """
        :param int change_stream_options_pre_and_post_images_expire_after_seconds: (Optional) The minimum pre- and post-image retention time in seconds This parameter is only supported for MongoDB version 6.0 and above. Defaults to `-1`(off).
        :param str default_read_concern: [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/). **(DEPRECATED.)** MongoDB 5.0 and later clusters default to `local`. To use a custom read concern level, please refer to your driver documentation.
        :param str default_write_concern: [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        :param bool fail_index_key_too_long: When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them. **(DEPRECATED.)** This parameter has been removed as of [MongoDB 4.4](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.failIndexKeyTooLong).
        :param bool javascript_enabled: When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        :param str minimum_enabled_tls_protocol: Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        :param bool no_table_scan: When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        :param float oplog_min_retention_hours: Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        :param int oplog_size_mb: The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        :param int sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param int sample_size_bi_connector: Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param int transaction_lifetime_limit_seconds: Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        pulumi.set(__self__, "change_stream_options_pre_and_post_images_expire_after_seconds", change_stream_options_pre_and_post_images_expire_after_seconds)
        pulumi.set(__self__, "default_read_concern", default_read_concern)
        pulumi.set(__self__, "default_write_concern", default_write_concern)
        pulumi.set(__self__, "fail_index_key_too_long", fail_index_key_too_long)
        pulumi.set(__self__, "javascript_enabled", javascript_enabled)
        pulumi.set(__self__, "minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        pulumi.set(__self__, "no_table_scan", no_table_scan)
        pulumi.set(__self__, "oplog_min_retention_hours", oplog_min_retention_hours)
        pulumi.set(__self__, "oplog_size_mb", oplog_size_mb)
        pulumi.set(__self__, "sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        pulumi.set(__self__, "sample_size_bi_connector", sample_size_bi_connector)
        pulumi.set(__self__, "transaction_lifetime_limit_seconds", transaction_lifetime_limit_seconds)

    @property
    @pulumi.getter(name="changeStreamOptionsPreAndPostImagesExpireAfterSeconds")
    def change_stream_options_pre_and_post_images_expire_after_seconds(self) -> int:
        """
        (Optional) The minimum pre- and post-image retention time in seconds This parameter is only supported for MongoDB version 6.0 and above. Defaults to `-1`(off).
        """
        return pulumi.get(self, "change_stream_options_pre_and_post_images_expire_after_seconds")

    @property
    @pulumi.getter(name="defaultReadConcern")
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
    def default_read_concern(self) -> str:
        """
        [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/). **(DEPRECATED.)** MongoDB 5.0 and later clusters default to `local`. To use a custom read concern level, please refer to your driver documentation.
        """
        return pulumi.get(self, "default_read_concern")

    @property
    @pulumi.getter(name="defaultWriteConcern")
    def default_write_concern(self) -> str:
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        return pulumi.get(self, "default_write_concern")

    @property
    @pulumi.getter(name="failIndexKeyTooLong")
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
    def fail_index_key_too_long(self) -> bool:
        """
        When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them. **(DEPRECATED.)** This parameter has been removed as of [MongoDB 4.4](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.failIndexKeyTooLong).
        """
        return pulumi.get(self, "fail_index_key_too_long")

    @property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> bool:
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        return pulumi.get(self, "javascript_enabled")

    @property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> str:
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> bool:
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        return pulumi.get(self, "no_table_scan")

    @property
    @pulumi.getter(name="oplogMinRetentionHours")
    def oplog_min_retention_hours(self) -> float:
        """
        Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        """
        return pulumi.get(self, "oplog_min_retention_hours")

    @property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> int:
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        return pulumi.get(self, "oplog_size_mb")

    @property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> int:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> int:
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_size_bi_connector")

    @property
    @pulumi.getter(name="transactionLifetimeLimitSeconds")
    def transaction_lifetime_limit_seconds(self) -> int:
        """
        Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        return pulumi.get(self, "transaction_lifetime_limit_seconds")


@pulumi.output_type
class GetAdvancedClusterBiConnectorConfigResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 read_preference: str):
        """
        :param bool enabled: Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
        :param str read_preference: Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "read_preference", read_preference)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> str:
        """
        Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        return pulumi.get(self, "read_preference")


@pulumi.output_type
class GetAdvancedClusterConnectionStringResult(dict):
    def __init__(__self__, *,
                 private: str,
                 private_endpoints: Sequence['outputs.GetAdvancedClusterConnectionStringPrivateEndpointResult'],
                 private_srv: str,
                 standard: str,
                 standard_srv: str):
        """
        :param str private: [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        :param Sequence['GetAdvancedClusterConnectionStringPrivateEndpointArgs'] private_endpoints: Private endpoint connection strings. Each object describes the connection strings you can use to connect to this cluster through a private endpoint. Atlas returns this parameter only if you deployed a private endpoint to all regions to which you deployed this cluster's nodes.
               - `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
               - `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in DNS . Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don't need to: Append the seed list or Change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn't, use `connection_strings.private_endpoint[n].connection_string`
               - `connection_strings.private_endpoint.#.srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster supports it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[n].srvConnectionString.
               - `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
               - `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`
               - `connection_strings.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.
               - `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
               - `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.
        :param str private_srv: [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        :param str standard: Public mongodb:// connection string for this cluster.
        :param str standard_srv: Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t  , use connectionStrings.standard.
        """
        pulumi.set(__self__, "private", private)
        pulumi.set(__self__, "private_endpoints", private_endpoints)
        pulumi.set(__self__, "private_srv", private_srv)
        pulumi.set(__self__, "standard", standard)
        pulumi.set(__self__, "standard_srv", standard_srv)

    @property
    @pulumi.getter
    def private(self) -> str:
        """
        [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        """
        return pulumi.get(self, "private")

    @property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Sequence['outputs.GetAdvancedClusterConnectionStringPrivateEndpointResult']:
        """
        Private endpoint connection strings. Each object describes the connection strings you can use to connect to this cluster through a private endpoint. Atlas returns this parameter only if you deployed a private endpoint to all regions to which you deployed this cluster's nodes.
        - `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
        - `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in DNS . Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don't need to: Append the seed list or Change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn't, use `connection_strings.private_endpoint[n].connection_string`
        - `connection_strings.private_endpoint.#.srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster supports it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[n].srvConnectionString.
        - `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
        - `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`
        - `connection_strings.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.
        - `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
        - `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.
        """
        return pulumi.get(self, "private_endpoints")

    @property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> str:
        """
        [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        """
        return pulumi.get(self, "private_srv")

    @property
    @pulumi.getter
    def standard(self) -> str:
        """
        Public mongodb:// connection string for this cluster.
        """
        return pulumi.get(self, "standard")

    @property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> str:
        """
        Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t  , use connectionStrings.standard.
        """
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class GetAdvancedClusterConnectionStringPrivateEndpointResult(dict):
    def __init__(__self__, *,
                 connection_string: str,
                 endpoints: Sequence['outputs.GetAdvancedClusterConnectionStringPrivateEndpointEndpointResult'],
                 srv_connection_string: str,
                 srv_shard_optimized_connection_string: str,
                 type: str):
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "srv_connection_string", srv_connection_string)
        pulumi.set(__self__, "srv_shard_optimized_connection_string", srv_shard_optimized_connection_string)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> str:
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def endpoints(self) -> Sequence['outputs.GetAdvancedClusterConnectionStringPrivateEndpointEndpointResult']:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> str:
        return pulumi.get(self, "srv_connection_string")

    @property
    @pulumi.getter(name="srvShardOptimizedConnectionString")
    def srv_shard_optimized_connection_string(self) -> str:
        return pulumi.get(self, "srv_shard_optimized_connection_string")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAdvancedClusterConnectionStringPrivateEndpointEndpointResult(dict):
    def __init__(__self__, *,
                 endpoint_id: str,
                 provider_name: str,
                 region: str):
        """
        :param str provider_name: Cloud service provider on which the servers are provisioned.
        """
        pulumi.set(__self__, "endpoint_id", endpoint_id)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> str:
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetAdvancedClusterLabelResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecResult(dict):
    def __init__(__self__, *,
                 container_id: Mapping[str, str],
                 external_id: str,
                 id: str,
                 num_shards: int,
                 region_configs: Sequence['outputs.GetAdvancedClusterReplicationSpecRegionConfigResult'],
                 zone_id: str,
                 zone_name: str):
        """
        :param Mapping[str, str] container_id: A key-value map of the Network Peering Container ID(s) for the configuration specified in `region_configs`. The Container ID is the id of the container either created programmatically by the user before any clusters existed in a project or when the first cluster in the region (AWS/Azure) or project (GCP) was created.  The syntax is `"providerName:regionName" = "containerId"`. Example `AWS:US_EAST_1" = "61e0797dde08fb498ca11a71`.
        :param str external_id: Unique 24-hexadecimal digit string that identifies the replication object for a shard in a Cluster. This value corresponds to Shard ID displayed in the UI. When using old sharding configuration (replication spec with `num_shards` greater than 1) this value is not populated.
        :param int num_shards: Provide this value if you set a `cluster_type` of `SHARDED` or `GEOSHARDED`. **(DEPRECATED.)** To learn more, see the Migration Guide.
        :param Sequence['GetAdvancedClusterReplicationSpecRegionConfigArgs'] region_configs: Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below
        :param str zone_id: Unique 24-hexadecimal digit string that identifies the zone in a Global Cluster. If clusterType is GEOSHARDED, this value indicates the zone that the given shard belongs to and can be used to configure Global Cluster backup policies.
        :param str zone_name: Name for the zone in a Global Cluster.
        """
        pulumi.set(__self__, "container_id", container_id)
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "num_shards", num_shards)
        pulumi.set(__self__, "region_configs", region_configs)
        pulumi.set(__self__, "zone_id", zone_id)
        pulumi.set(__self__, "zone_name", zone_name)

    @property
    @pulumi.getter(name="containerId")
    def container_id(self) -> Mapping[str, str]:
        """
        A key-value map of the Network Peering Container ID(s) for the configuration specified in `region_configs`. The Container ID is the id of the container either created programmatically by the user before any clusters existed in a project or when the first cluster in the region (AWS/Azure) or project (GCP) was created.  The syntax is `"providerName:regionName" = "containerId"`. Example `AWS:US_EAST_1" = "61e0797dde08fb498ca11a71`.
        """
        return pulumi.get(self, "container_id")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the replication object for a shard in a Cluster. This value corresponds to Shard ID displayed in the UI. When using old sharding configuration (replication spec with `num_shards` greater than 1) this value is not populated.
        """
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="numShards")
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
    def num_shards(self) -> int:
        """
        Provide this value if you set a `cluster_type` of `SHARDED` or `GEOSHARDED`. **(DEPRECATED.)** To learn more, see the Migration Guide.
        """
        return pulumi.get(self, "num_shards")

    @property
    @pulumi.getter(name="regionConfigs")
    def region_configs(self) -> Sequence['outputs.GetAdvancedClusterReplicationSpecRegionConfigResult']:
        """
        Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below
        """
        return pulumi.get(self, "region_configs")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the zone in a Global Cluster. If clusterType is GEOSHARDED, this value indicates the zone that the given shard belongs to and can be used to configure Global Cluster backup policies.
        """
        return pulumi.get(self, "zone_id")

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> str:
        """
        Name for the zone in a Global Cluster.
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecRegionConfigResult(dict):
    def __init__(__self__, *,
                 analytics_auto_scalings: Sequence['outputs.GetAdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingResult'],
                 analytics_specs: 'outputs.GetAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsResult',
                 auto_scalings: Sequence['outputs.GetAdvancedClusterReplicationSpecRegionConfigAutoScalingResult'],
                 backing_provider_name: str,
                 electable_specs: 'outputs.GetAdvancedClusterReplicationSpecRegionConfigElectableSpecsResult',
                 priority: int,
                 provider_name: str,
                 read_only_specs: 'outputs.GetAdvancedClusterReplicationSpecRegionConfigReadOnlySpecsResult',
                 region_name: str):
        """
        :param Sequence['GetAdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingArgs'] analytics_auto_scalings: Configuration for the Collection of settings that configures analytics-auto-scaling information for the cluster. See below
        :param 'GetAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgs' analytics_specs: Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. See below
        :param Sequence['GetAdvancedClusterReplicationSpecRegionConfigAutoScalingArgs'] auto_scalings: Configuration for the Collection of settings that configures auto-scaling information for the cluster. See below
        :param str backing_provider_name: Cloud service provider on which you provision the host for a multi-tenant cluster.
        :param 'GetAdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs' electable_specs: Hardware specifications for electable nodes in the region.
        :param int priority: Election priority of the region.
        :param str provider_name: Cloud service provider on which the servers are provisioned.
        :param 'GetAdvancedClusterReplicationSpecRegionConfigReadOnlySpecsArgs' read_only_specs: Hardware specifications for read-only nodes in the region. See below
        :param str region_name: Physical location of your MongoDB cluster.
        """
        pulumi.set(__self__, "analytics_auto_scalings", analytics_auto_scalings)
        pulumi.set(__self__, "analytics_specs", analytics_specs)
        pulumi.set(__self__, "auto_scalings", auto_scalings)
        pulumi.set(__self__, "backing_provider_name", backing_provider_name)
        pulumi.set(__self__, "electable_specs", electable_specs)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "read_only_specs", read_only_specs)
        pulumi.set(__self__, "region_name", region_name)

    @property
    @pulumi.getter(name="analyticsAutoScalings")
    def analytics_auto_scalings(self) -> Sequence['outputs.GetAdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingResult']:
        """
        Configuration for the Collection of settings that configures analytics-auto-scaling information for the cluster. See below
        """
        return pulumi.get(self, "analytics_auto_scalings")

    @property
    @pulumi.getter(name="analyticsSpecs")
    def analytics_specs(self) -> 'outputs.GetAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsResult':
        """
        Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. See below
        """
        return pulumi.get(self, "analytics_specs")

    @property
    @pulumi.getter(name="autoScalings")
    def auto_scalings(self) -> Sequence['outputs.GetAdvancedClusterReplicationSpecRegionConfigAutoScalingResult']:
        """
        Configuration for the Collection of settings that configures auto-scaling information for the cluster. See below
        """
        return pulumi.get(self, "auto_scalings")

    @property
    @pulumi.getter(name="backingProviderName")
    def backing_provider_name(self) -> str:
        """
        Cloud service provider on which you provision the host for a multi-tenant cluster.
        """
        return pulumi.get(self, "backing_provider_name")

    @property
    @pulumi.getter(name="electableSpecs")
    def electable_specs(self) -> 'outputs.GetAdvancedClusterReplicationSpecRegionConfigElectableSpecsResult':
        """
        Hardware specifications for electable nodes in the region.
        """
        return pulumi.get(self, "electable_specs")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Election priority of the region.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter(name="readOnlySpecs")
    def read_only_specs(self) -> 'outputs.GetAdvancedClusterReplicationSpecRegionConfigReadOnlySpecsResult':
        """
        Hardware specifications for read-only nodes in the region. See below
        """
        return pulumi.get(self, "read_only_specs")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        Physical location of your MongoDB cluster.
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecRegionConfigAnalyticsAutoScalingResult(dict):
    def __init__(__self__, *,
                 compute_enabled: bool,
                 compute_max_instance_size: str,
                 compute_min_instance_size: str,
                 compute_scale_down_enabled: bool,
                 disk_gb_enabled: bool):
        """
        :param bool compute_enabled: Flag that indicates whether instance size auto-scaling is enabled.
        :param str compute_max_instance_size: Maximum instance size to which your cluster can automatically scale (such as M40). 
               #### Advanced Configuration
        :param str compute_min_instance_size: Minimum instance size to which your cluster can automatically scale (such as M10).
        :param bool compute_scale_down_enabled: Flag that indicates whether the instance size may scale down.
        :param bool disk_gb_enabled: Flag that indicates whether this cluster enables disk auto-scaling.
        """
        pulumi.set(__self__, "compute_enabled", compute_enabled)
        pulumi.set(__self__, "compute_max_instance_size", compute_max_instance_size)
        pulumi.set(__self__, "compute_min_instance_size", compute_min_instance_size)
        pulumi.set(__self__, "compute_scale_down_enabled", compute_scale_down_enabled)
        pulumi.set(__self__, "disk_gb_enabled", disk_gb_enabled)

    @property
    @pulumi.getter(name="computeEnabled")
    def compute_enabled(self) -> bool:
        """
        Flag that indicates whether instance size auto-scaling is enabled.
        """
        return pulumi.get(self, "compute_enabled")

    @property
    @pulumi.getter(name="computeMaxInstanceSize")
    def compute_max_instance_size(self) -> str:
        """
        Maximum instance size to which your cluster can automatically scale (such as M40). 
        #### Advanced Configuration
        """
        return pulumi.get(self, "compute_max_instance_size")

    @property
    @pulumi.getter(name="computeMinInstanceSize")
    def compute_min_instance_size(self) -> str:
        """
        Minimum instance size to which your cluster can automatically scale (such as M10).
        """
        return pulumi.get(self, "compute_min_instance_size")

    @property
    @pulumi.getter(name="computeScaleDownEnabled")
    def compute_scale_down_enabled(self) -> bool:
        """
        Flag that indicates whether the instance size may scale down.
        """
        return pulumi.get(self, "compute_scale_down_enabled")

    @property
    @pulumi.getter(name="diskGbEnabled")
    def disk_gb_enabled(self) -> bool:
        """
        Flag that indicates whether this cluster enables disk auto-scaling.
        """
        return pulumi.get(self, "disk_gb_enabled")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsResult(dict):
    def __init__(__self__, *,
                 disk_iops: int,
                 disk_size_gb: float,
                 ebs_volume_type: str,
                 instance_size: str,
                 node_count: Optional[int] = None):
        """
        :param int disk_iops: Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        :param float disk_size_gb: Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        :param str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. 
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param str instance_size: Hardware specification for the instance sizes in this region.
        :param int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        pulumi.set(__self__, "disk_iops", disk_iops)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        pulumi.set(__self__, "instance_size", instance_size)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> int:
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> float:
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> str:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. 
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecRegionConfigAutoScalingResult(dict):
    def __init__(__self__, *,
                 compute_enabled: bool,
                 compute_max_instance_size: str,
                 compute_min_instance_size: str,
                 compute_scale_down_enabled: bool,
                 disk_gb_enabled: bool):
        """
        :param bool compute_enabled: Flag that indicates whether instance size auto-scaling is enabled.
        :param str compute_max_instance_size: Maximum instance size to which your cluster can automatically scale (such as M40). 
               #### Advanced Configuration
        :param str compute_min_instance_size: Minimum instance size to which your cluster can automatically scale (such as M10).
        :param bool compute_scale_down_enabled: Flag that indicates whether the instance size may scale down.
        :param bool disk_gb_enabled: Flag that indicates whether this cluster enables disk auto-scaling.
        """
        pulumi.set(__self__, "compute_enabled", compute_enabled)
        pulumi.set(__self__, "compute_max_instance_size", compute_max_instance_size)
        pulumi.set(__self__, "compute_min_instance_size", compute_min_instance_size)
        pulumi.set(__self__, "compute_scale_down_enabled", compute_scale_down_enabled)
        pulumi.set(__self__, "disk_gb_enabled", disk_gb_enabled)

    @property
    @pulumi.getter(name="computeEnabled")
    def compute_enabled(self) -> bool:
        """
        Flag that indicates whether instance size auto-scaling is enabled.
        """
        return pulumi.get(self, "compute_enabled")

    @property
    @pulumi.getter(name="computeMaxInstanceSize")
    def compute_max_instance_size(self) -> str:
        """
        Maximum instance size to which your cluster can automatically scale (such as M40). 
        #### Advanced Configuration
        """
        return pulumi.get(self, "compute_max_instance_size")

    @property
    @pulumi.getter(name="computeMinInstanceSize")
    def compute_min_instance_size(self) -> str:
        """
        Minimum instance size to which your cluster can automatically scale (such as M10).
        """
        return pulumi.get(self, "compute_min_instance_size")

    @property
    @pulumi.getter(name="computeScaleDownEnabled")
    def compute_scale_down_enabled(self) -> bool:
        """
        Flag that indicates whether the instance size may scale down.
        """
        return pulumi.get(self, "compute_scale_down_enabled")

    @property
    @pulumi.getter(name="diskGbEnabled")
    def disk_gb_enabled(self) -> bool:
        """
        Flag that indicates whether this cluster enables disk auto-scaling.
        """
        return pulumi.get(self, "disk_gb_enabled")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecRegionConfigElectableSpecsResult(dict):
    def __init__(__self__, *,
                 disk_iops: int,
                 disk_size_gb: float,
                 ebs_volume_type: str,
                 instance_size: str,
                 node_count: Optional[int] = None):
        """
        :param int disk_iops: Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        :param float disk_size_gb: Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        :param str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. 
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param str instance_size: Hardware specification for the instance sizes in this region.
        :param int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        pulumi.set(__self__, "disk_iops", disk_iops)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        pulumi.set(__self__, "instance_size", instance_size)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> int:
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> float:
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> str:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. 
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAdvancedClusterReplicationSpecRegionConfigReadOnlySpecsResult(dict):
    def __init__(__self__, *,
                 disk_iops: int,
                 disk_size_gb: float,
                 ebs_volume_type: str,
                 instance_size: str,
                 node_count: Optional[int] = None):
        """
        :param int disk_iops: Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        :param float disk_size_gb: Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        :param str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. 
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param str instance_size: Hardware specification for the instance sizes in this region.
        :param int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        pulumi.set(__self__, "disk_iops", disk_iops)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        pulumi.set(__self__, "instance_size", instance_size)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> int:
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> float:
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> str:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. 
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAdvancedClusterTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAdvancedClustersResultResult(dict):
    def __init__(__self__, *,
                 advanced_configurations: Sequence['outputs.GetAdvancedClustersResultAdvancedConfigurationResult'],
                 backup_enabled: bool,
                 bi_connector_configs: Sequence['outputs.GetAdvancedClustersResultBiConnectorConfigResult'],
                 cluster_type: str,
                 config_server_management_mode: str,
                 config_server_type: str,
                 connection_strings: Sequence['outputs.GetAdvancedClustersResultConnectionStringResult'],
                 create_date: str,
                 disk_size_gb: float,
                 encryption_at_rest_provider: str,
                 global_cluster_self_managed_sharding: bool,
                 labels: Sequence['outputs.GetAdvancedClustersResultLabelResult'],
                 mongo_db_major_version: str,
                 mongo_db_version: str,
                 name: str,
                 paused: bool,
                 pit_enabled: bool,
                 redact_client_log_data: bool,
                 replica_set_scaling_strategy: str,
                 replication_specs: Sequence['outputs.GetAdvancedClustersResultReplicationSpecResult'],
                 root_cert_type: str,
                 state_name: str,
                 tags: Sequence['outputs.GetAdvancedClustersResultTagResult'],
                 termination_protection_enabled: bool,
                 version_release_system: str):
        """
        :param Sequence['GetAdvancedClustersResultAdvancedConfigurationArgs'] advanced_configurations: Get the advanced configuration options. See Advanced Configuration below for more details.
        :param Sequence['GetAdvancedClustersResultBiConnectorConfigArgs'] bi_connector_configs: Configuration settings applied to BI Connector for Atlas on this cluster. See below. **NOTE** Prior version of provider had parameter as `bi_connector`
        :param str cluster_type: Type of the cluster that you want to create.
        :param str config_server_management_mode: Config Server Management Mode for creating or updating a sharded cluster. Valid values are `ATLAS_MANAGED` (default) and `FIXED_TO_DEDICATED`. When configured as `ATLAS_MANAGED`, Atlas may automatically switch the cluster's config server type for optimal performance and savings. When configured as `FIXED_TO_DEDICATED`, the cluster will always use a dedicated config server. To learn more, see the [Sharded Cluster Config Servers documentation](https://dochub.mongodb.org/docs/manual/core/sharded-cluster-config-servers/).
        :param str config_server_type: Describes a sharded cluster's config server type. Valid values are `DEDICATED` and `EMBEDDED`. To learn more, see the [Sharded Cluster Config Servers documentation](https://dochub.mongodb.org/docs/manual/core/sharded-cluster-config-servers/).
        :param Sequence['GetAdvancedClustersResultConnectionStringArgs'] connection_strings: Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.
        :param float disk_size_gb: Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        :param str encryption_at_rest_provider: Possible values are AWS, GCP, AZURE or NONE.
        :param bool global_cluster_self_managed_sharding: Flag that indicates if cluster uses Atlas-Managed Sharding (false) or Self-Managed Sharding (true).
        :param Sequence['GetAdvancedClustersResultLabelArgs'] labels: Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.
        :param str mongo_db_major_version: Version of the cluster to deploy.
        :param str mongo_db_version: Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.
        :param bool paused: Flag that indicates whether the cluster is paused or not.
        :param bool pit_enabled: Flag that indicates if the cluster uses Continuous Cloud Backup.
        :param bool redact_client_log_data: (Optional) Flag that enables or disables log redaction, see the [manual](https://www.mongodb.com/docs/manual/administration/monitoring/#log-redaction) for more info.
        :param str replica_set_scaling_strategy: (Optional) Replica set scaling mode for your cluster.
        :param Sequence['GetAdvancedClustersResultReplicationSpecArgs'] replication_specs: List of settings that configure your cluster regions. If `use_replication_spec_per_shard = true`, this array has one object per shard representing node configurations in each shard. For replica sets there is only one object representing node configurations. See below
        :param str root_cert_type: Certificate Authority that MongoDB Atlas clusters use.
        :param str state_name: Current state of the cluster. The possible states are:
        :param Sequence['GetAdvancedClustersResultTagArgs'] tags: Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.
        :param bool termination_protection_enabled: Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.
        :param str version_release_system: Release cadence that Atlas uses for this cluster.
        """
        pulumi.set(__self__, "advanced_configurations", advanced_configurations)
        pulumi.set(__self__, "backup_enabled", backup_enabled)
        pulumi.set(__self__, "bi_connector_configs", bi_connector_configs)
        pulumi.set(__self__, "cluster_type", cluster_type)
        pulumi.set(__self__, "config_server_management_mode", config_server_management_mode)
        pulumi.set(__self__, "config_server_type", config_server_type)
        pulumi.set(__self__, "connection_strings", connection_strings)
        pulumi.set(__self__, "create_date", create_date)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "encryption_at_rest_provider", encryption_at_rest_provider)
        pulumi.set(__self__, "global_cluster_self_managed_sharding", global_cluster_self_managed_sharding)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "mongo_db_major_version", mongo_db_major_version)
        pulumi.set(__self__, "mongo_db_version", mongo_db_version)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "paused", paused)
        pulumi.set(__self__, "pit_enabled", pit_enabled)
        pulumi.set(__self__, "redact_client_log_data", redact_client_log_data)
        pulumi.set(__self__, "replica_set_scaling_strategy", replica_set_scaling_strategy)
        pulumi.set(__self__, "replication_specs", replication_specs)
        pulumi.set(__self__, "root_cert_type", root_cert_type)
        pulumi.set(__self__, "state_name", state_name)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "termination_protection_enabled", termination_protection_enabled)
        pulumi.set(__self__, "version_release_system", version_release_system)

    @property
    @pulumi.getter(name="advancedConfigurations")
    def advanced_configurations(self) -> Sequence['outputs.GetAdvancedClustersResultAdvancedConfigurationResult']:
        """
        Get the advanced configuration options. See Advanced Configuration below for more details.
        """
        return pulumi.get(self, "advanced_configurations")

    @property
    @pulumi.getter(name="backupEnabled")
    def backup_enabled(self) -> bool:
        return pulumi.get(self, "backup_enabled")

    @property
    @pulumi.getter(name="biConnectorConfigs")
    def bi_connector_configs(self) -> Sequence['outputs.GetAdvancedClustersResultBiConnectorConfigResult']:
        """
        Configuration settings applied to BI Connector for Atlas on this cluster. See below. **NOTE** Prior version of provider had parameter as `bi_connector`
        """
        return pulumi.get(self, "bi_connector_configs")

    @property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> str:
        """
        Type of the cluster that you want to create.
        """
        return pulumi.get(self, "cluster_type")

    @property
    @pulumi.getter(name="configServerManagementMode")
    def config_server_management_mode(self) -> str:
        """
        Config Server Management Mode for creating or updating a sharded cluster. Valid values are `ATLAS_MANAGED` (default) and `FIXED_TO_DEDICATED`. When configured as `ATLAS_MANAGED`, Atlas may automatically switch the cluster's config server type for optimal performance and savings. When configured as `FIXED_TO_DEDICATED`, the cluster will always use a dedicated config server. To learn more, see the [Sharded Cluster Config Servers documentation](https://dochub.mongodb.org/docs/manual/core/sharded-cluster-config-servers/).
        """
        return pulumi.get(self, "config_server_management_mode")

    @property
    @pulumi.getter(name="configServerType")
    def config_server_type(self) -> str:
        """
        Describes a sharded cluster's config server type. Valid values are `DEDICATED` and `EMBEDDED`. To learn more, see the [Sharded Cluster Config Servers documentation](https://dochub.mongodb.org/docs/manual/core/sharded-cluster-config-servers/).
        """
        return pulumi.get(self, "config_server_type")

    @property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Sequence['outputs.GetAdvancedClustersResultConnectionStringResult']:
        """
        Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.
        """
        return pulumi.get(self, "connection_strings")

    @property
    @pulumi.getter(name="createDate")
    def create_date(self) -> str:
        return pulumi.get(self, "create_date")

    @property
    @pulumi.getter(name="diskSizeGb")
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
    def disk_size_gb(self) -> float:
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter(name="encryptionAtRestProvider")
    def encryption_at_rest_provider(self) -> str:
        """
        Possible values are AWS, GCP, AZURE or NONE.
        """
        return pulumi.get(self, "encryption_at_rest_provider")

    @property
    @pulumi.getter(name="globalClusterSelfManagedSharding")
    def global_cluster_self_managed_sharding(self) -> bool:
        """
        Flag that indicates if cluster uses Atlas-Managed Sharding (false) or Self-Managed Sharding (true).
        """
        return pulumi.get(self, "global_cluster_self_managed_sharding")

    @property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetAdvancedClustersResultLabelResult']:
        """
        Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="mongoDbMajorVersion")
    def mongo_db_major_version(self) -> str:
        """
        Version of the cluster to deploy.
        """
        return pulumi.get(self, "mongo_db_major_version")

    @property
    @pulumi.getter(name="mongoDbVersion")
    def mongo_db_version(self) -> str:
        """
        Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.
        """
        return pulumi.get(self, "mongo_db_version")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def paused(self) -> bool:
        """
        Flag that indicates whether the cluster is paused or not.
        """
        return pulumi.get(self, "paused")

    @property
    @pulumi.getter(name="pitEnabled")
    def pit_enabled(self) -> bool:
        """
        Flag that indicates if the cluster uses Continuous Cloud Backup.
        """
        return pulumi.get(self, "pit_enabled")

    @property
    @pulumi.getter(name="redactClientLogData")
    def redact_client_log_data(self) -> bool:
        """
        (Optional) Flag that enables or disables log redaction, see the [manual](https://www.mongodb.com/docs/manual/administration/monitoring/#log-redaction) for more info.
        """
        return pulumi.get(self, "redact_client_log_data")

    @property
    @pulumi.getter(name="replicaSetScalingStrategy")
    def replica_set_scaling_strategy(self) -> str:
        """
        (Optional) Replica set scaling mode for your cluster.
        """
        return pulumi.get(self, "replica_set_scaling_strategy")

    @property
    @pulumi.getter(name="replicationSpecs")
    def replication_specs(self) -> Sequence['outputs.GetAdvancedClustersResultReplicationSpecResult']:
        """
        List of settings that configure your cluster regions. If `use_replication_spec_per_shard = true`, this array has one object per shard representing node configurations in each shard. For replica sets there is only one object representing node configurations. See below
        """
        return pulumi.get(self, "replication_specs")

    @property
    @pulumi.getter(name="rootCertType")
    def root_cert_type(self) -> str:
        """
        Certificate Authority that MongoDB Atlas clusters use.
        """
        return pulumi.get(self, "root_cert_type")

    @property
    @pulumi.getter(name="stateName")
    def state_name(self) -> str:
        """
        Current state of the cluster. The possible states are:
        """
        return pulumi.get(self, "state_name")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetAdvancedClustersResultTagResult']:
        """
        Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="terminationProtectionEnabled")
    def termination_protection_enabled(self) -> bool:
        """
        Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.
        """
        return pulumi.get(self, "termination_protection_enabled")

    @property
    @pulumi.getter(name="versionReleaseSystem")
    def version_release_system(self) -> str:
        """
        Release cadence that Atlas uses for this cluster.
        """
        return pulumi.get(self, "version_release_system")


@pulumi.output_type
class GetAdvancedClustersResultAdvancedConfigurationResult(dict):
    def __init__(__self__, *,
                 change_stream_options_pre_and_post_images_expire_after_seconds: int,
                 default_read_concern: str,
                 default_write_concern: str,
                 fail_index_key_too_long: bool,
                 javascript_enabled: bool,
                 minimum_enabled_tls_protocol: str,
                 no_table_scan: bool,
                 oplog_min_retention_hours: float,
                 oplog_size_mb: int,
                 sample_refresh_interval_bi_connector: int,
                 sample_size_bi_connector: int,
                 transaction_lifetime_limit_seconds: int):
        """
        :param int change_stream_options_pre_and_post_images_expire_after_seconds: (Optional) The minimum pre- and post-image retention time in seconds. This parameter is only supported for MongoDB version 6.0 and above. Defaults to `-1`(off).
        :param str default_read_concern: [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/). **(DEPRECATED.)** MongoDB 5.0 and later clusters default to `local`. To use a custom read concern level, please refer to your driver documentation.
        :param str default_write_concern: [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        :param bool fail_index_key_too_long: When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them. **(DEPRECATED.)** This parameter has been removed as of [MongoDB 4.4](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.failIndexKeyTooLong).
        :param bool javascript_enabled: When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        :param str minimum_enabled_tls_protocol: Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        :param bool no_table_scan: When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        :param float oplog_min_retention_hours: Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        :param int oplog_size_mb: The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        :param int sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param int sample_size_bi_connector: Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param int transaction_lifetime_limit_seconds: (Optional) Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        pulumi.set(__self__, "change_stream_options_pre_and_post_images_expire_after_seconds", change_stream_options_pre_and_post_images_expire_after_seconds)
        pulumi.set(__self__, "default_read_concern", default_read_concern)
        pulumi.set(__self__, "default_write_concern", default_write_concern)
        pulumi.set(__self__, "fail_index_key_too_long", fail_index_key_too_long)
        pulumi.set(__self__, "javascript_enabled", javascript_enabled)
        pulumi.set(__self__, "minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        pulumi.set(__self__, "no_table_scan", no_table_scan)
        pulumi.set(__self__, "oplog_min_retention_hours", oplog_min_retention_hours)
        pulumi.set(__self__, "oplog_size_mb", oplog_size_mb)
        pulumi.set(__self__, "sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        pulumi.set(__self__, "sample_size_bi_connector", sample_size_bi_connector)
        pulumi.set(__self__, "transaction_lifetime_limit_seconds", transaction_lifetime_limit_seconds)

    @property
    @pulumi.getter(name="changeStreamOptionsPreAndPostImagesExpireAfterSeconds")
    def change_stream_options_pre_and_post_images_expire_after_seconds(self) -> int:
        """
        (Optional) The minimum pre- and post-image retention time in seconds. This parameter is only supported for MongoDB version 6.0 and above. Defaults to `-1`(off).
        """
        return pulumi.get(self, "change_stream_options_pre_and_post_images_expire_after_seconds")

    @property
    @pulumi.getter(name="defaultReadConcern")
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
    def default_read_concern(self) -> str:
        """
        [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/). **(DEPRECATED.)** MongoDB 5.0 and later clusters default to `local`. To use a custom read concern level, please refer to your driver documentation.
        """
        return pulumi.get(self, "default_read_concern")

    @property
    @pulumi.getter(name="defaultWriteConcern")
    def default_write_concern(self) -> str:
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        return pulumi.get(self, "default_write_concern")

    @property
    @pulumi.getter(name="failIndexKeyTooLong")
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
    def fail_index_key_too_long(self) -> bool:
        """
        When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them. **(DEPRECATED.)** This parameter has been removed as of [MongoDB 4.4](https://www.mongodb.com/docs/manual/reference/parameters/#mongodb-parameter-param.failIndexKeyTooLong).
        """
        return pulumi.get(self, "fail_index_key_too_long")

    @property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> bool:
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        return pulumi.get(self, "javascript_enabled")

    @property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> str:
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> bool:
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        return pulumi.get(self, "no_table_scan")

    @property
    @pulumi.getter(name="oplogMinRetentionHours")
    def oplog_min_retention_hours(self) -> float:
        """
        Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        """
        return pulumi.get(self, "oplog_min_retention_hours")

    @property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> int:
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        return pulumi.get(self, "oplog_size_mb")

    @property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> int:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> int:
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_size_bi_connector")

    @property
    @pulumi.getter(name="transactionLifetimeLimitSeconds")
    def transaction_lifetime_limit_seconds(self) -> int:
        """
        (Optional) Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        return pulumi.get(self, "transaction_lifetime_limit_seconds")


@pulumi.output_type
class GetAdvancedClustersResultBiConnectorConfigResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 read_preference: str):
        """
        :param bool enabled: Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
        :param str read_preference: Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "read_preference", read_preference)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> str:
        """
        Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        return pulumi.get(self, "read_preference")


@pulumi.output_type
class GetAdvancedClustersResultConnectionStringResult(dict):
    def __init__(__self__, *,
                 private: str,
                 private_endpoints: Sequence['outputs.GetAdvancedClustersResultConnectionStringPrivateEndpointResult'],
                 private_srv: str,
                 standard: str,
                 standard_srv: str):
        """
        :param str private: [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        :param Sequence['GetAdvancedClustersResultConnectionStringPrivateEndpointArgs'] private_endpoints: Private endpoint connection strings. Each object describes the connection strings you can use to connect to this cluster through a private endpoint. Atlas returns this parameter only if you deployed a private endpoint to all regions to which you deployed this cluster's nodes.
               - `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
               - `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in DNS . Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don't need to: Append the seed list or Change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn't, use `connection_strings.private_endpoint[n].connection_string`
               - `connection_strings.private_endpoint.#.srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster supports it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[n].srvConnectionString.
               - `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
               - `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`
               - `connection_strings.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.
               - `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
               - `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.
        :param str private_srv: [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        :param str standard: Public mongodb:// connection string for this cluster.
        :param str standard_srv: Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t  , use connectionStrings.standard.
        """
        pulumi.set(__self__, "private", private)
        pulumi.set(__self__, "private_endpoints", private_endpoints)
        pulumi.set(__self__, "private_srv", private_srv)
        pulumi.set(__self__, "standard", standard)
        pulumi.set(__self__, "standard_srv", standard_srv)

    @property
    @pulumi.getter
    def private(self) -> str:
        """
        [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        """
        return pulumi.get(self, "private")

    @property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Sequence['outputs.GetAdvancedClustersResultConnectionStringPrivateEndpointResult']:
        """
        Private endpoint connection strings. Each object describes the connection strings you can use to connect to this cluster through a private endpoint. Atlas returns this parameter only if you deployed a private endpoint to all regions to which you deployed this cluster's nodes.
        - `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
        - `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint. The `mongodb+srv` protocol tells the driver to look up the seed list of hosts in DNS . Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don't need to: Append the seed list or Change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn't, use `connection_strings.private_endpoint[n].connection_string`
        - `connection_strings.private_endpoint.#.srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint. If the connection string uses this Uniform Resource Identifier (URI) format, you don't need to change the Uniform Resource Identifier (URI) if the nodes change. Use this Uniform Resource Identifier (URI) format if your application and Atlas cluster supports it. If it doesn't, use and consult the documentation for connectionStrings.privateEndpoint[n].srvConnectionString.
        - `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
        - `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`
        - `connection_strings.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.
        - `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
        - `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.
        """
        return pulumi.get(self, "private_endpoints")

    @property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> str:
        """
        [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        """
        return pulumi.get(self, "private_srv")

    @property
    @pulumi.getter
    def standard(self) -> str:
        """
        Public mongodb:// connection string for this cluster.
        """
        return pulumi.get(self, "standard")

    @property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> str:
        """
        Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t  , use connectionStrings.standard.
        """
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class GetAdvancedClustersResultConnectionStringPrivateEndpointResult(dict):
    def __init__(__self__, *,
                 connection_string: str,
                 endpoints: Sequence['outputs.GetAdvancedClustersResultConnectionStringPrivateEndpointEndpointResult'],
                 srv_connection_string: str,
                 srv_shard_optimized_connection_string: str,
                 type: str):
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "srv_connection_string", srv_connection_string)
        pulumi.set(__self__, "srv_shard_optimized_connection_string", srv_shard_optimized_connection_string)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> str:
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def endpoints(self) -> Sequence['outputs.GetAdvancedClustersResultConnectionStringPrivateEndpointEndpointResult']:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> str:
        return pulumi.get(self, "srv_connection_string")

    @property
    @pulumi.getter(name="srvShardOptimizedConnectionString")
    def srv_shard_optimized_connection_string(self) -> str:
        return pulumi.get(self, "srv_shard_optimized_connection_string")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAdvancedClustersResultConnectionStringPrivateEndpointEndpointResult(dict):
    def __init__(__self__, *,
                 endpoint_id: str,
                 provider_name: str,
                 region: str):
        """
        :param str provider_name: Cloud service provider on which the servers are provisioned.
        """
        pulumi.set(__self__, "endpoint_id", endpoint_id)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> str:
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetAdvancedClustersResultLabelResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecResult(dict):
    def __init__(__self__, *,
                 container_id: Mapping[str, str],
                 external_id: str,
                 id: str,
                 num_shards: int,
                 region_configs: Sequence['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigResult'],
                 zone_id: str,
                 zone_name: str):
        """
        :param Mapping[str, str] container_id: A key-value map of the Network Peering Container ID(s) for the configuration specified in `region_configs`. The Container ID is the id of the container either created programmatically by the user before any clusters existed in a project or when the first cluster in the region (AWS/Azure) or project (GCP) was created.  The syntax is `"providerName:regionName" = "containerId"`. Example `AWS:US_EAST_1" = "61e0797dde08fb498ca11a71`.
        :param str external_id: Unique 24-hexadecimal digit string that identifies the replication object for a shard in a Cluster. This value corresponds to Shard ID displayed in the UI. When using old sharding configuration (replication spec with `num_shards` greater than 1) this value is not populated.
        :param int num_shards: Provide this value if you set a `cluster_type` of SHARDED or GEOSHARDED. **(DEPRECATED.)** To learn more, see the Migration Guide for more details.
        :param Sequence['GetAdvancedClustersResultReplicationSpecRegionConfigArgs'] region_configs: Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below
        :param str zone_id: Unique 24-hexadecimal digit string that identifies the zone in a Global Cluster. If clusterType is GEOSHARDED, this value indicates the zone that the given shard belongs to and can be used to configure Global Cluster backup policies.
        :param str zone_name: Name for the zone in a Global Cluster.
        """
        pulumi.set(__self__, "container_id", container_id)
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "num_shards", num_shards)
        pulumi.set(__self__, "region_configs", region_configs)
        pulumi.set(__self__, "zone_id", zone_id)
        pulumi.set(__self__, "zone_name", zone_name)

    @property
    @pulumi.getter(name="containerId")
    def container_id(self) -> Mapping[str, str]:
        """
        A key-value map of the Network Peering Container ID(s) for the configuration specified in `region_configs`. The Container ID is the id of the container either created programmatically by the user before any clusters existed in a project or when the first cluster in the region (AWS/Azure) or project (GCP) was created.  The syntax is `"providerName:regionName" = "containerId"`. Example `AWS:US_EAST_1" = "61e0797dde08fb498ca11a71`.
        """
        return pulumi.get(self, "container_id")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the replication object for a shard in a Cluster. This value corresponds to Shard ID displayed in the UI. When using old sharding configuration (replication spec with `num_shards` greater than 1) this value is not populated.
        """
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="numShards")
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
    def num_shards(self) -> int:
        """
        Provide this value if you set a `cluster_type` of SHARDED or GEOSHARDED. **(DEPRECATED.)** To learn more, see the Migration Guide for more details.
        """
        return pulumi.get(self, "num_shards")

    @property
    @pulumi.getter(name="regionConfigs")
    def region_configs(self) -> Sequence['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigResult']:
        """
        Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below
        """
        return pulumi.get(self, "region_configs")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the zone in a Global Cluster. If clusterType is GEOSHARDED, this value indicates the zone that the given shard belongs to and can be used to configure Global Cluster backup policies.
        """
        return pulumi.get(self, "zone_id")

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> str:
        """
        Name for the zone in a Global Cluster.
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecRegionConfigResult(dict):
    def __init__(__self__, *,
                 analytics_auto_scalings: Sequence['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsAutoScalingResult'],
                 analytics_specs: 'outputs.GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecsResult',
                 auto_scalings: Sequence['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigAutoScalingResult'],
                 backing_provider_name: str,
                 electable_specs: 'outputs.GetAdvancedClustersResultReplicationSpecRegionConfigElectableSpecsResult',
                 priority: int,
                 provider_name: str,
                 read_only_specs: 'outputs.GetAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecsResult',
                 region_name: str):
        """
        :param Sequence['GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsAutoScalingArgs'] analytics_auto_scalings: Configuration for the Collection of settings that configures analytis-auto-scaling information for the cluster. See below
        :param 'GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecsArgs' analytics_specs: Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. See below
        :param Sequence['GetAdvancedClustersResultReplicationSpecRegionConfigAutoScalingArgs'] auto_scalings: Configuration for the Collection of settings that configures auto-scaling information for the cluster. See below
        :param str backing_provider_name: Cloud service provider on which you provision the host for a multi-tenant cluster.
        :param 'GetAdvancedClustersResultReplicationSpecRegionConfigElectableSpecsArgs' electable_specs: Hardware specifications for electable nodes in the region.
        :param int priority: Election priority of the region.
        :param str provider_name: Cloud service provider on which the servers are provisioned.
        :param 'GetAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecsArgs' read_only_specs: Hardware specifications for read-only nodes in the region. See below
        :param str region_name: Physical location of your MongoDB cluster.
        """
        pulumi.set(__self__, "analytics_auto_scalings", analytics_auto_scalings)
        pulumi.set(__self__, "analytics_specs", analytics_specs)
        pulumi.set(__self__, "auto_scalings", auto_scalings)
        pulumi.set(__self__, "backing_provider_name", backing_provider_name)
        pulumi.set(__self__, "electable_specs", electable_specs)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "read_only_specs", read_only_specs)
        pulumi.set(__self__, "region_name", region_name)

    @property
    @pulumi.getter(name="analyticsAutoScalings")
    def analytics_auto_scalings(self) -> Sequence['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsAutoScalingResult']:
        """
        Configuration for the Collection of settings that configures analytis-auto-scaling information for the cluster. See below
        """
        return pulumi.get(self, "analytics_auto_scalings")

    @property
    @pulumi.getter(name="analyticsSpecs")
    def analytics_specs(self) -> 'outputs.GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecsResult':
        """
        Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. See below
        """
        return pulumi.get(self, "analytics_specs")

    @property
    @pulumi.getter(name="autoScalings")
    def auto_scalings(self) -> Sequence['outputs.GetAdvancedClustersResultReplicationSpecRegionConfigAutoScalingResult']:
        """
        Configuration for the Collection of settings that configures auto-scaling information for the cluster. See below
        """
        return pulumi.get(self, "auto_scalings")

    @property
    @pulumi.getter(name="backingProviderName")
    def backing_provider_name(self) -> str:
        """
        Cloud service provider on which you provision the host for a multi-tenant cluster.
        """
        return pulumi.get(self, "backing_provider_name")

    @property
    @pulumi.getter(name="electableSpecs")
    def electable_specs(self) -> 'outputs.GetAdvancedClustersResultReplicationSpecRegionConfigElectableSpecsResult':
        """
        Hardware specifications for electable nodes in the region.
        """
        return pulumi.get(self, "electable_specs")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Election priority of the region.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter(name="readOnlySpecs")
    def read_only_specs(self) -> 'outputs.GetAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecsResult':
        """
        Hardware specifications for read-only nodes in the region. See below
        """
        return pulumi.get(self, "read_only_specs")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        Physical location of your MongoDB cluster.
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsAutoScalingResult(dict):
    def __init__(__self__, *,
                 compute_enabled: bool,
                 compute_max_instance_size: str,
                 compute_min_instance_size: str,
                 compute_scale_down_enabled: bool,
                 disk_gb_enabled: bool):
        """
        :param bool compute_enabled: Flag that indicates whether instance size auto-scaling is enabled.
        :param str compute_max_instance_size: Maximum instance size to which your cluster can automatically scale (such as M40).
        :param str compute_min_instance_size: Minimum instance size to which your cluster can automatically scale (such as M10).
        :param bool compute_scale_down_enabled: Flag that indicates whether the instance size may scale down.
        :param bool disk_gb_enabled: Flag that indicates whether this cluster enables disk auto-scaling.
        """
        pulumi.set(__self__, "compute_enabled", compute_enabled)
        pulumi.set(__self__, "compute_max_instance_size", compute_max_instance_size)
        pulumi.set(__self__, "compute_min_instance_size", compute_min_instance_size)
        pulumi.set(__self__, "compute_scale_down_enabled", compute_scale_down_enabled)
        pulumi.set(__self__, "disk_gb_enabled", disk_gb_enabled)

    @property
    @pulumi.getter(name="computeEnabled")
    def compute_enabled(self) -> bool:
        """
        Flag that indicates whether instance size auto-scaling is enabled.
        """
        return pulumi.get(self, "compute_enabled")

    @property
    @pulumi.getter(name="computeMaxInstanceSize")
    def compute_max_instance_size(self) -> str:
        """
        Maximum instance size to which your cluster can automatically scale (such as M40).
        """
        return pulumi.get(self, "compute_max_instance_size")

    @property
    @pulumi.getter(name="computeMinInstanceSize")
    def compute_min_instance_size(self) -> str:
        """
        Minimum instance size to which your cluster can automatically scale (such as M10).
        """
        return pulumi.get(self, "compute_min_instance_size")

    @property
    @pulumi.getter(name="computeScaleDownEnabled")
    def compute_scale_down_enabled(self) -> bool:
        """
        Flag that indicates whether the instance size may scale down.
        """
        return pulumi.get(self, "compute_scale_down_enabled")

    @property
    @pulumi.getter(name="diskGbEnabled")
    def disk_gb_enabled(self) -> bool:
        """
        Flag that indicates whether this cluster enables disk auto-scaling.
        """
        return pulumi.get(self, "disk_gb_enabled")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecRegionConfigAnalyticsSpecsResult(dict):
    def __init__(__self__, *,
                 disk_iops: int,
                 disk_size_gb: float,
                 ebs_volume_type: str,
                 instance_size: str,
                 node_count: Optional[int] = None):
        """
        :param int disk_iops: Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        :param float disk_size_gb: Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        :param str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster.
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param str instance_size: Hardware specification for the instance sizes in this region.
        :param int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        pulumi.set(__self__, "disk_iops", disk_iops)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        pulumi.set(__self__, "instance_size", instance_size)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> int:
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> float:
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> str:
        """
        Type of storage you want to attach to your AWS-provisioned cluster.
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecRegionConfigAutoScalingResult(dict):
    def __init__(__self__, *,
                 compute_enabled: bool,
                 compute_max_instance_size: str,
                 compute_min_instance_size: str,
                 compute_scale_down_enabled: bool,
                 disk_gb_enabled: bool):
        """
        :param bool compute_enabled: Flag that indicates whether instance size auto-scaling is enabled.
        :param str compute_max_instance_size: Maximum instance size to which your cluster can automatically scale (such as M40).
        :param str compute_min_instance_size: Minimum instance size to which your cluster can automatically scale (such as M10).
        :param bool compute_scale_down_enabled: Flag that indicates whether the instance size may scale down.
        :param bool disk_gb_enabled: Flag that indicates whether this cluster enables disk auto-scaling.
        """
        pulumi.set(__self__, "compute_enabled", compute_enabled)
        pulumi.set(__self__, "compute_max_instance_size", compute_max_instance_size)
        pulumi.set(__self__, "compute_min_instance_size", compute_min_instance_size)
        pulumi.set(__self__, "compute_scale_down_enabled", compute_scale_down_enabled)
        pulumi.set(__self__, "disk_gb_enabled", disk_gb_enabled)

    @property
    @pulumi.getter(name="computeEnabled")
    def compute_enabled(self) -> bool:
        """
        Flag that indicates whether instance size auto-scaling is enabled.
        """
        return pulumi.get(self, "compute_enabled")

    @property
    @pulumi.getter(name="computeMaxInstanceSize")
    def compute_max_instance_size(self) -> str:
        """
        Maximum instance size to which your cluster can automatically scale (such as M40).
        """
        return pulumi.get(self, "compute_max_instance_size")

    @property
    @pulumi.getter(name="computeMinInstanceSize")
    def compute_min_instance_size(self) -> str:
        """
        Minimum instance size to which your cluster can automatically scale (such as M10).
        """
        return pulumi.get(self, "compute_min_instance_size")

    @property
    @pulumi.getter(name="computeScaleDownEnabled")
    def compute_scale_down_enabled(self) -> bool:
        """
        Flag that indicates whether the instance size may scale down.
        """
        return pulumi.get(self, "compute_scale_down_enabled")

    @property
    @pulumi.getter(name="diskGbEnabled")
    def disk_gb_enabled(self) -> bool:
        """
        Flag that indicates whether this cluster enables disk auto-scaling.
        """
        return pulumi.get(self, "disk_gb_enabled")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecRegionConfigElectableSpecsResult(dict):
    def __init__(__self__, *,
                 disk_iops: int,
                 disk_size_gb: float,
                 ebs_volume_type: str,
                 instance_size: str,
                 node_count: Optional[int] = None):
        """
        :param int disk_iops: Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        :param float disk_size_gb: Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        :param str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster.
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param str instance_size: Hardware specification for the instance sizes in this region.
        :param int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        pulumi.set(__self__, "disk_iops", disk_iops)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        pulumi.set(__self__, "instance_size", instance_size)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> int:
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> float:
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> str:
        """
        Type of storage you want to attach to your AWS-provisioned cluster.
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAdvancedClustersResultReplicationSpecRegionConfigReadOnlySpecsResult(dict):
    def __init__(__self__, *,
                 disk_iops: int,
                 disk_size_gb: float,
                 ebs_volume_type: str,
                 instance_size: str,
                 node_count: Optional[int] = None):
        """
        :param int disk_iops: Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        :param float disk_size_gb: Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        :param str ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster.
               * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
               * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        :param str instance_size: Hardware specification for the instance sizes in this region.
        :param int node_count: Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        pulumi.set(__self__, "disk_iops", disk_iops)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        pulumi.set(__self__, "instance_size", instance_size)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> int:
        """
        Target IOPS (Input/Output Operations Per Second) desired for storage attached to this hardware. This parameter defaults to the cluster tier's standard IOPS value.
        """
        return pulumi.get(self, "disk_iops")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> float:
        """
        Storage capacity that the host's root volume possesses expressed in gigabytes. If disk size specified is below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> str:
        """
        Type of storage you want to attach to your AWS-provisioned cluster.
        * `STANDARD` volume types can't exceed the default IOPS rate for the selected volume size.
        * `PROVISIONED` volume types must fall within the allowable IOPS range for the selected volume size.
        """
        return pulumi.get(self, "ebs_volume_type")

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the instance sizes in this region.
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[int]:
        """
        Number of nodes of the given type for MongoDB Atlas to deploy to the region.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetAdvancedClustersResultTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAlertConfigurationMatcherResult(dict):
    def __init__(__self__, *,
                 field_name: str,
                 operator: str,
                 value: str):
        """
        :param str field_name: Name of the field in the target object to match on.
        :param str operator: The operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
               - `GREATER_THAN`
               - `LESS_THAN`
        :param str value: Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
               - `PRIMARY`
               - `SECONDARY`
               - `STANDALONE`
               - `CONFIG`
               - `MONGOS`
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        """
        Name of the field in the target object to match on.
        """
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        - `GREATER_THAN`
        - `LESS_THAN`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
        - `PRIMARY`
        - `SECONDARY`
        - `STANDALONE`
        - `CONFIG`
        - `MONGOS`
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAlertConfigurationMetricThresholdConfigResult(dict):
    def __init__(__self__, *,
                 metric_name: str,
                 mode: str,
                 operator: str,
                 threshold: float,
                 units: str):
        """
        :param str metric_name: Name of the metric to check. The full list being quite large, please refer to atlas docs [here for general metrics](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types) and [here for serverless metrics](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-create-config/#serverless-measurements)
        :param str mode: This must be set to AVERAGE. Atlas computes the current metric value as an average.
        :param str operator: The operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
               - `GREATER_THAN`
               - `LESS_THAN`
        :param float threshold: Threshold value outside of which an alert will be triggered.
        :param str units: The units for the threshold value. Depends on the type of metric.
               Refer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "units", units)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        Name of the metric to check. The full list being quite large, please refer to atlas docs [here for general metrics](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types) and [here for serverless metrics](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-create-config/#serverless-measurements)
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        This must be set to AVERAGE. Atlas computes the current metric value as an average.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        - `GREATER_THAN`
        - `LESS_THAN`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        Threshold value outside of which an alert will be triggered.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def units(self) -> str:
        """
        The units for the threshold value. Depends on the type of metric.
        Refer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.
        """
        return pulumi.get(self, "units")


@pulumi.output_type
class GetAlertConfigurationNotificationResult(dict):
    def __init__(__self__, *,
                 api_token: str,
                 channel_name: str,
                 datadog_api_key: str,
                 datadog_region: str,
                 delay_min: int,
                 email_address: str,
                 email_enabled: bool,
                 integration_id: str,
                 interval_min: int,
                 microsoft_teams_webhook_url: str,
                 mobile_number: str,
                 notifier_id: str,
                 ops_genie_api_key: str,
                 ops_genie_region: str,
                 roles: Sequence[str],
                 service_key: str,
                 sms_enabled: bool,
                 team_id: str,
                 team_name: str,
                 type_name: str,
                 username: str,
                 victor_ops_api_key: str,
                 victor_ops_routing_key: str,
                 webhook_secret: str,
                 webhook_url: str):
        """
        :param str api_token: Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param str channel_name: Slack channel name. Required for the SLACK notifications type.
        :param str datadog_api_key: Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        :param str datadog_region: Region that indicates which API URL to use. See the `datadogRegion` field in the `notifications` request parameter of [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Alert-Configurations/operation/createAlertConfiguration) for more details. The default Datadog region is US.
        :param int delay_min: Number of minutes to wait after an alert condition is detected before sending out the first notification.
        :param str email_address: Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        :param bool email_enabled: Flag indicating email notifications should be sent. Atlas returns this value if `type_name` is set  to `ORG`, `GROUP`, or `USER`.
        :param str integration_id: The ID of the associated integration, the credentials of which to use for requests.
        :param int interval_min: Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5.
        :param str microsoft_teams_webhook_url: Microsoft Teams channel incoming webhook URL. Required for the `MICROSOFT_TEAMS` notifications type.
        :param str mobile_number: Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        :param str notifier_id: The notifier ID is a system-generated unique identifier assigned to each notification method. This is needed when updating third-party notifications without requiring explicit authentication credentials.
        :param str ops_genie_api_key: Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param str ops_genie_region: Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        :param Sequence[str] roles: Atlas role in current Project or Organization. Atlas returns this value if you set `type_name` to `ORG` or `GROUP`.
        :param str service_key: PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param bool sms_enabled: Flag indicating text notifications should be sent. Atlas returns this value if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        :param str team_id: Unique identifier of a team.
        :param str team_name: Label for the team that receives this notification.
        :param str type_name: Type of alert notification.
               Accepted values are:
               - `DATADOG`
               - `EMAIL`
               - `GROUP` (Project)
               - `OPS_GENIE`
               - `ORG`
               - `PAGER_DUTY`
               - `SLACK`
               - `SMS`
               - `TEAM`
               - `USER`
               - `VICTOR_OPS`
               - `WEBHOOK`
               - `MICROSOFT_TEAMS`
        :param str username: Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        :param str victor_ops_api_key: VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param str victor_ops_routing_key: VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param str webhook_secret: Authentication secret for the `WEBHOOK` notifications type.
        :param str webhook_url: Target URL  for the `WEBHOOK` notifications type.
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "channel_name", channel_name)
        pulumi.set(__self__, "datadog_api_key", datadog_api_key)
        pulumi.set(__self__, "datadog_region", datadog_region)
        pulumi.set(__self__, "delay_min", delay_min)
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "email_enabled", email_enabled)
        pulumi.set(__self__, "integration_id", integration_id)
        pulumi.set(__self__, "interval_min", interval_min)
        pulumi.set(__self__, "microsoft_teams_webhook_url", microsoft_teams_webhook_url)
        pulumi.set(__self__, "mobile_number", mobile_number)
        pulumi.set(__self__, "notifier_id", notifier_id)
        pulumi.set(__self__, "ops_genie_api_key", ops_genie_api_key)
        pulumi.set(__self__, "ops_genie_region", ops_genie_region)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "service_key", service_key)
        pulumi.set(__self__, "sms_enabled", sms_enabled)
        pulumi.set(__self__, "team_id", team_id)
        pulumi.set(__self__, "team_name", team_name)
        pulumi.set(__self__, "type_name", type_name)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "victor_ops_api_key", victor_ops_api_key)
        pulumi.set(__self__, "victor_ops_routing_key", victor_ops_routing_key)
        pulumi.set(__self__, "webhook_secret", webhook_secret)
        pulumi.set(__self__, "webhook_url", webhook_url)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> str:
        """
        Slack channel name. Required for the SLACK notifications type.
        """
        return pulumi.get(self, "channel_name")

    @property
    @pulumi.getter(name="datadogApiKey")
    def datadog_api_key(self) -> str:
        """
        Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        """
        return pulumi.get(self, "datadog_api_key")

    @property
    @pulumi.getter(name="datadogRegion")
    def datadog_region(self) -> str:
        """
        Region that indicates which API URL to use. See the `datadogRegion` field in the `notifications` request parameter of [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Alert-Configurations/operation/createAlertConfiguration) for more details. The default Datadog region is US.
        """
        return pulumi.get(self, "datadog_region")

    @property
    @pulumi.getter(name="delayMin")
    def delay_min(self) -> int:
        """
        Number of minutes to wait after an alert condition is detected before sending out the first notification.
        """
        return pulumi.get(self, "delay_min")

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> str:
        """
        Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter(name="emailEnabled")
    def email_enabled(self) -> bool:
        """
        Flag indicating email notifications should be sent. Atlas returns this value if `type_name` is set  to `ORG`, `GROUP`, or `USER`.
        """
        return pulumi.get(self, "email_enabled")

    @property
    @pulumi.getter(name="integrationId")
    def integration_id(self) -> str:
        """
        The ID of the associated integration, the credentials of which to use for requests.
        """
        return pulumi.get(self, "integration_id")

    @property
    @pulumi.getter(name="intervalMin")
    def interval_min(self) -> int:
        """
        Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5.
        """
        return pulumi.get(self, "interval_min")

    @property
    @pulumi.getter(name="microsoftTeamsWebhookUrl")
    def microsoft_teams_webhook_url(self) -> str:
        """
        Microsoft Teams channel incoming webhook URL. Required for the `MICROSOFT_TEAMS` notifications type.
        """
        return pulumi.get(self, "microsoft_teams_webhook_url")

    @property
    @pulumi.getter(name="mobileNumber")
    def mobile_number(self) -> str:
        """
        Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        """
        return pulumi.get(self, "mobile_number")

    @property
    @pulumi.getter(name="notifierId")
    def notifier_id(self) -> str:
        """
        The notifier ID is a system-generated unique identifier assigned to each notification method. This is needed when updating third-party notifications without requiring explicit authentication credentials.
        """
        return pulumi.get(self, "notifier_id")

    @property
    @pulumi.getter(name="opsGenieApiKey")
    def ops_genie_api_key(self) -> str:
        """
        Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "ops_genie_api_key")

    @property
    @pulumi.getter(name="opsGenieRegion")
    def ops_genie_region(self) -> str:
        """
        Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        """
        return pulumi.get(self, "ops_genie_region")

    @property
    @pulumi.getter
    def roles(self) -> Sequence[str]:
        """
        Atlas role in current Project or Organization. Atlas returns this value if you set `type_name` to `ORG` or `GROUP`.
        """
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter(name="serviceKey")
    def service_key(self) -> str:
        """
        PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "service_key")

    @property
    @pulumi.getter(name="smsEnabled")
    def sms_enabled(self) -> bool:
        """
        Flag indicating text notifications should be sent. Atlas returns this value if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        """
        return pulumi.get(self, "sms_enabled")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> str:
        """
        Unique identifier of a team.
        """
        return pulumi.get(self, "team_id")

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> str:
        """
        Label for the team that receives this notification.
        """
        return pulumi.get(self, "team_name")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        """
        Type of alert notification.
        Accepted values are:
        - `DATADOG`
        - `EMAIL`
        - `GROUP` (Project)
        - `OPS_GENIE`
        - `ORG`
        - `PAGER_DUTY`
        - `SLACK`
        - `SMS`
        - `TEAM`
        - `USER`
        - `VICTOR_OPS`
        - `WEBHOOK`
        - `MICROSOFT_TEAMS`
        """
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="victorOpsApiKey")
    def victor_ops_api_key(self) -> str:
        """
        VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "victor_ops_api_key")

    @property
    @pulumi.getter(name="victorOpsRoutingKey")
    def victor_ops_routing_key(self) -> str:
        """
        VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "victor_ops_routing_key")

    @property
    @pulumi.getter(name="webhookSecret")
    def webhook_secret(self) -> str:
        """
        Authentication secret for the `WEBHOOK` notifications type.
        """
        return pulumi.get(self, "webhook_secret")

    @property
    @pulumi.getter(name="webhookUrl")
    def webhook_url(self) -> str:
        """
        Target URL  for the `WEBHOOK` notifications type.
        """
        return pulumi.get(self, "webhook_url")


@pulumi.output_type
class GetAlertConfigurationOutputResult(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str,
                 label: Optional[str] = None):
        """
        :param str value: Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
               - `PRIMARY`
               - `SECONDARY`
               - `STANDALONE`
               - `CONFIG`
               - `MONGOS`
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
        - `PRIMARY`
        - `SECONDARY`
        - `STANDALONE`
        - `CONFIG`
        - `MONGOS`
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        return pulumi.get(self, "label")


@pulumi.output_type
class GetAlertConfigurationThresholdConfigResult(dict):
    def __init__(__self__, *,
                 operator: str,
                 threshold: float,
                 units: str):
        """
        :param str operator: The operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
               - `GREATER_THAN`
               - `LESS_THAN`
        :param float threshold: Threshold value outside of which an alert will be triggered.
        :param str units: The units for the threshold value. Depends on the type of metric.
               Refer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "units", units)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        - `GREATER_THAN`
        - `LESS_THAN`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        Threshold value outside of which an alert will be triggered.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def units(self) -> str:
        """
        The units for the threshold value. Depends on the type of metric.
        Refer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.
        """
        return pulumi.get(self, "units")


@pulumi.output_type
class GetAlertConfigurationsListOptionResult(dict):
    def __init__(__self__, *,
                 include_count: Optional[bool] = None,
                 items_per_page: Optional[int] = None,
                 page_num: Optional[int] = None):
        if include_count is not None:
            pulumi.set(__self__, "include_count", include_count)
        if items_per_page is not None:
            pulumi.set(__self__, "items_per_page", items_per_page)
        if page_num is not None:
            pulumi.set(__self__, "page_num", page_num)

    @property
    @pulumi.getter(name="includeCount")
    def include_count(self) -> Optional[bool]:
        return pulumi.get(self, "include_count")

    @property
    @pulumi.getter(name="itemsPerPage")
    def items_per_page(self) -> Optional[int]:
        return pulumi.get(self, "items_per_page")

    @property
    @pulumi.getter(name="pageNum")
    def page_num(self) -> Optional[int]:
        return pulumi.get(self, "page_num")


@pulumi.output_type
class GetAlertConfigurationsResultResult(dict):
    def __init__(__self__, *,
                 alert_configuration_id: str,
                 created: str,
                 enabled: bool,
                 event_type: str,
                 id: str,
                 matchers: Sequence['outputs.GetAlertConfigurationsResultMatcherResult'],
                 metric_threshold_configs: Sequence['outputs.GetAlertConfigurationsResultMetricThresholdConfigResult'],
                 notifications: Sequence['outputs.GetAlertConfigurationsResultNotificationResult'],
                 outputs: Sequence['outputs.GetAlertConfigurationsResultOutputResult'],
                 project_id: str,
                 threshold_configs: Sequence['outputs.GetAlertConfigurationsResultThresholdConfigResult'],
                 updated: str):
        """
        :param str alert_configuration_id: The ID of the alert configuration
        :param str created: Timestamp in ISO 8601 date and time format in UTC when this alert configuration was created.
        :param bool enabled: If set to true, the alert configuration is enabled. If enabled is not exported it is set to false.
        :param str event_type: The type of event that will trigger an alert.
        :param Sequence['GetAlertConfigurationsResultMatcherArgs'] matchers: Rules to apply when matching an object against this alert configuration. See matchers.
        :param Sequence['GetAlertConfigurationsResultMetricThresholdConfigArgs'] metric_threshold_configs: The threshold that causes an alert to be triggered. Required if `event_type_name` : `OUTSIDE_METRIC_THRESHOLD` or `OUTSIDE_SERVERLESS_METRIC_THRESHOLD`. See metric threshold config.
        :param Sequence['GetAlertConfigurationsResultOutputArgs'] outputs: Requested output string format for the alert configuration
        :param str project_id: The unique ID for the project to get the alert configurations.
        :param Sequence['GetAlertConfigurationsResultThresholdConfigArgs'] threshold_configs: Threshold that triggers an alert. Required if `event_type_name` is any value other than `OUTSIDE_METRIC_THRESHOLD` or `OUTSIDE_SERVERLESS_METRIC_THRESHOLD`. See threshold config.
        :param str updated: Timestamp in ISO 8601 date and time format in UTC when this alert configuration was last updated.
        """
        pulumi.set(__self__, "alert_configuration_id", alert_configuration_id)
        pulumi.set(__self__, "created", created)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "matchers", matchers)
        pulumi.set(__self__, "metric_threshold_configs", metric_threshold_configs)
        pulumi.set(__self__, "notifications", notifications)
        pulumi.set(__self__, "outputs", outputs)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "threshold_configs", threshold_configs)
        pulumi.set(__self__, "updated", updated)

    @property
    @pulumi.getter(name="alertConfigurationId")
    def alert_configuration_id(self) -> str:
        """
        The ID of the alert configuration
        """
        return pulumi.get(self, "alert_configuration_id")

    @property
    @pulumi.getter
    def created(self) -> str:
        """
        Timestamp in ISO 8601 date and time format in UTC when this alert configuration was created.
        """
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        If set to true, the alert configuration is enabled. If enabled is not exported it is set to false.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> str:
        """
        The type of event that will trigger an alert.
        """
        return pulumi.get(self, "event_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def matchers(self) -> Sequence['outputs.GetAlertConfigurationsResultMatcherResult']:
        """
        Rules to apply when matching an object against this alert configuration. See matchers.
        """
        return pulumi.get(self, "matchers")

    @property
    @pulumi.getter(name="metricThresholdConfigs")
    def metric_threshold_configs(self) -> Sequence['outputs.GetAlertConfigurationsResultMetricThresholdConfigResult']:
        """
        The threshold that causes an alert to be triggered. Required if `event_type_name` : `OUTSIDE_METRIC_THRESHOLD` or `OUTSIDE_SERVERLESS_METRIC_THRESHOLD`. See metric threshold config.
        """
        return pulumi.get(self, "metric_threshold_configs")

    @property
    @pulumi.getter
    def notifications(self) -> Sequence['outputs.GetAlertConfigurationsResultNotificationResult']:
        return pulumi.get(self, "notifications")

    @property
    @pulumi.getter
    def outputs(self) -> Sequence['outputs.GetAlertConfigurationsResultOutputResult']:
        """
        Requested output string format for the alert configuration
        """
        return pulumi.get(self, "outputs")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project to get the alert configurations.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="thresholdConfigs")
    def threshold_configs(self) -> Sequence['outputs.GetAlertConfigurationsResultThresholdConfigResult']:
        """
        Threshold that triggers an alert. Required if `event_type_name` is any value other than `OUTSIDE_METRIC_THRESHOLD` or `OUTSIDE_SERVERLESS_METRIC_THRESHOLD`. See threshold config.
        """
        return pulumi.get(self, "threshold_configs")

    @property
    @pulumi.getter
    def updated(self) -> str:
        """
        Timestamp in ISO 8601 date and time format in UTC when this alert configuration was last updated.
        """
        return pulumi.get(self, "updated")


@pulumi.output_type
class GetAlertConfigurationsResultMatcherResult(dict):
    def __init__(__self__, *,
                 field_name: str,
                 operator: str,
                 value: str):
        """
        :param str field_name: Name of the field in the target object to match on.
        :param str operator: The operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
               - `GREATER_THAN`
               - `LESS_THAN`
        :param str value: Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
               - `PRIMARY`
               - `SECONDARY`
               - `STANDALONE`
               - `CONFIG`
               - `MONGOS`
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        """
        Name of the field in the target object to match on.
        """
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        - `GREATER_THAN`
        - `LESS_THAN`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
        - `PRIMARY`
        - `SECONDARY`
        - `STANDALONE`
        - `CONFIG`
        - `MONGOS`
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAlertConfigurationsResultMetricThresholdConfigResult(dict):
    def __init__(__self__, *,
                 metric_name: str,
                 mode: str,
                 operator: str,
                 threshold: float,
                 units: str):
        """
        :param str metric_name: Name of the metric to check. The full list being quite large, please refer to atlas docs [here for general metrics](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types) and [here for serverless metrics](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-create-config/#serverless-measurements)
        :param str mode: This must be set to AVERAGE. Atlas computes the current metric value as an average.
        :param str operator: The operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
               - `GREATER_THAN`
               - `LESS_THAN`
        :param float threshold: Threshold value outside of which an alert will be triggered.
        :param str units: The units for the threshold value. Depends on the type of metric.
               Refer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "units", units)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        Name of the metric to check. The full list being quite large, please refer to atlas docs [here for general metrics](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types) and [here for serverless metrics](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-create-config/#serverless-measurements)
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        This must be set to AVERAGE. Atlas computes the current metric value as an average.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        - `GREATER_THAN`
        - `LESS_THAN`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        Threshold value outside of which an alert will be triggered.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def units(self) -> str:
        """
        The units for the threshold value. Depends on the type of metric.
        Refer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.
        """
        return pulumi.get(self, "units")


@pulumi.output_type
class GetAlertConfigurationsResultNotificationResult(dict):
    def __init__(__self__, *,
                 api_token: str,
                 channel_name: str,
                 datadog_api_key: str,
                 datadog_region: str,
                 delay_min: int,
                 email_address: str,
                 email_enabled: bool,
                 integration_id: str,
                 interval_min: int,
                 microsoft_teams_webhook_url: str,
                 mobile_number: str,
                 notifier_id: str,
                 ops_genie_api_key: str,
                 ops_genie_region: str,
                 roles: Sequence[str],
                 service_key: str,
                 sms_enabled: bool,
                 team_id: str,
                 team_name: str,
                 type_name: str,
                 username: str,
                 victor_ops_api_key: str,
                 victor_ops_routing_key: str,
                 webhook_secret: str,
                 webhook_url: str):
        """
        :param str api_token: Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param str channel_name: Slack channel name. Required for the SLACK notifications type.
        :param str datadog_api_key: Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        :param str datadog_region: Region that indicates which API URL to use. See the `datadogRegion` field in the `notifications` request parameter of [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Alert-Configurations/operation/createAlertConfiguration) for more details. The default Datadog region is US.
        :param int delay_min: Number of minutes to wait after an alert condition is detected before sending out the first notification.
        :param str email_address: Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        :param bool email_enabled: Flag indicating email notifications should be sent. Atlas returns this value if `type_name` is set  to `ORG`, `GROUP`, or `USER`.
        :param str integration_id: The ID of the associated integration, the credentials of which to use for requests.
        :param int interval_min: Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5.
        :param str microsoft_teams_webhook_url: Microsoft Teams channel incoming webhook URL. Required for the `MICROSOFT_TEAMS` notifications type.
        :param str mobile_number: Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        :param str notifier_id: The notifier ID is a system-generated unique identifier assigned to each notification method. This is needed when updating third-party notifications without requiring explicit authentication credentials.
        :param str ops_genie_api_key: Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param str ops_genie_region: Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        :param Sequence[str] roles: Atlas role in current Project or Organization. Atlas returns this value if you set `type_name` to `ORG` or `GROUP`.
        :param str service_key: PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param bool sms_enabled: Flag indicating text notifications should be sent. Atlas returns this value if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        :param str team_id: Unique identifier of a team.
        :param str team_name: Label for the team that receives this notification.
        :param str type_name: Type of alert notification.
               Accepted values are:
               - `DATADOG`
               - `EMAIL`
               - `GROUP` (Project)
               - `OPS_GENIE`
               - `ORG`
               - `PAGER_DUTY`
               - `SLACK`
               - `SMS`
               - `TEAM`
               - `USER`
               - `VICTOR_OPS`
               - `WEBHOOK`
               - `MICROSOFT_TEAMS`
        :param str username: Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        :param str victor_ops_api_key: VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param str victor_ops_routing_key: VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param str webhook_secret: Authentication secret for the `WEBHOOK` notifications type.
        :param str webhook_url: Target URL  for the `WEBHOOK` notifications type.
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "channel_name", channel_name)
        pulumi.set(__self__, "datadog_api_key", datadog_api_key)
        pulumi.set(__self__, "datadog_region", datadog_region)
        pulumi.set(__self__, "delay_min", delay_min)
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "email_enabled", email_enabled)
        pulumi.set(__self__, "integration_id", integration_id)
        pulumi.set(__self__, "interval_min", interval_min)
        pulumi.set(__self__, "microsoft_teams_webhook_url", microsoft_teams_webhook_url)
        pulumi.set(__self__, "mobile_number", mobile_number)
        pulumi.set(__self__, "notifier_id", notifier_id)
        pulumi.set(__self__, "ops_genie_api_key", ops_genie_api_key)
        pulumi.set(__self__, "ops_genie_region", ops_genie_region)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "service_key", service_key)
        pulumi.set(__self__, "sms_enabled", sms_enabled)
        pulumi.set(__self__, "team_id", team_id)
        pulumi.set(__self__, "team_name", team_name)
        pulumi.set(__self__, "type_name", type_name)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "victor_ops_api_key", victor_ops_api_key)
        pulumi.set(__self__, "victor_ops_routing_key", victor_ops_routing_key)
        pulumi.set(__self__, "webhook_secret", webhook_secret)
        pulumi.set(__self__, "webhook_url", webhook_url)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> str:
        """
        Slack channel name. Required for the SLACK notifications type.
        """
        return pulumi.get(self, "channel_name")

    @property
    @pulumi.getter(name="datadogApiKey")
    def datadog_api_key(self) -> str:
        """
        Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        """
        return pulumi.get(self, "datadog_api_key")

    @property
    @pulumi.getter(name="datadogRegion")
    def datadog_region(self) -> str:
        """
        Region that indicates which API URL to use. See the `datadogRegion` field in the `notifications` request parameter of [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Alert-Configurations/operation/createAlertConfiguration) for more details. The default Datadog region is US.
        """
        return pulumi.get(self, "datadog_region")

    @property
    @pulumi.getter(name="delayMin")
    def delay_min(self) -> int:
        """
        Number of minutes to wait after an alert condition is detected before sending out the first notification.
        """
        return pulumi.get(self, "delay_min")

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> str:
        """
        Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter(name="emailEnabled")
    def email_enabled(self) -> bool:
        """
        Flag indicating email notifications should be sent. Atlas returns this value if `type_name` is set  to `ORG`, `GROUP`, or `USER`.
        """
        return pulumi.get(self, "email_enabled")

    @property
    @pulumi.getter(name="integrationId")
    def integration_id(self) -> str:
        """
        The ID of the associated integration, the credentials of which to use for requests.
        """
        return pulumi.get(self, "integration_id")

    @property
    @pulumi.getter(name="intervalMin")
    def interval_min(self) -> int:
        """
        Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5.
        """
        return pulumi.get(self, "interval_min")

    @property
    @pulumi.getter(name="microsoftTeamsWebhookUrl")
    def microsoft_teams_webhook_url(self) -> str:
        """
        Microsoft Teams channel incoming webhook URL. Required for the `MICROSOFT_TEAMS` notifications type.
        """
        return pulumi.get(self, "microsoft_teams_webhook_url")

    @property
    @pulumi.getter(name="mobileNumber")
    def mobile_number(self) -> str:
        """
        Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        """
        return pulumi.get(self, "mobile_number")

    @property
    @pulumi.getter(name="notifierId")
    def notifier_id(self) -> str:
        """
        The notifier ID is a system-generated unique identifier assigned to each notification method. This is needed when updating third-party notifications without requiring explicit authentication credentials.
        """
        return pulumi.get(self, "notifier_id")

    @property
    @pulumi.getter(name="opsGenieApiKey")
    def ops_genie_api_key(self) -> str:
        """
        Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "ops_genie_api_key")

    @property
    @pulumi.getter(name="opsGenieRegion")
    def ops_genie_region(self) -> str:
        """
        Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        """
        return pulumi.get(self, "ops_genie_region")

    @property
    @pulumi.getter
    def roles(self) -> Sequence[str]:
        """
        Atlas role in current Project or Organization. Atlas returns this value if you set `type_name` to `ORG` or `GROUP`.
        """
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter(name="serviceKey")
    def service_key(self) -> str:
        """
        PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "service_key")

    @property
    @pulumi.getter(name="smsEnabled")
    def sms_enabled(self) -> bool:
        """
        Flag indicating text notifications should be sent. Atlas returns this value if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        """
        return pulumi.get(self, "sms_enabled")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> str:
        """
        Unique identifier of a team.
        """
        return pulumi.get(self, "team_id")

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> str:
        """
        Label for the team that receives this notification.
        """
        return pulumi.get(self, "team_name")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        """
        Type of alert notification.
        Accepted values are:
        - `DATADOG`
        - `EMAIL`
        - `GROUP` (Project)
        - `OPS_GENIE`
        - `ORG`
        - `PAGER_DUTY`
        - `SLACK`
        - `SMS`
        - `TEAM`
        - `USER`
        - `VICTOR_OPS`
        - `WEBHOOK`
        - `MICROSOFT_TEAMS`
        """
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="victorOpsApiKey")
    def victor_ops_api_key(self) -> str:
        """
        VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "victor_ops_api_key")

    @property
    @pulumi.getter(name="victorOpsRoutingKey")
    def victor_ops_routing_key(self) -> str:
        """
        VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "victor_ops_routing_key")

    @property
    @pulumi.getter(name="webhookSecret")
    def webhook_secret(self) -> str:
        """
        Authentication secret for the `WEBHOOK` notifications type.
        """
        return pulumi.get(self, "webhook_secret")

    @property
    @pulumi.getter(name="webhookUrl")
    def webhook_url(self) -> str:
        """
        Target URL  for the `WEBHOOK` notifications type.
        """
        return pulumi.get(self, "webhook_url")


@pulumi.output_type
class GetAlertConfigurationsResultOutputResult(dict):
    def __init__(__self__, *,
                 label: str,
                 type: str,
                 value: str):
        """
        :param str value: Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
               - `PRIMARY`
               - `SECONDARY`
               - `STANDALONE`
               - `CONFIG`
               - `MONGOS`
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
        - `PRIMARY`
        - `SECONDARY`
        - `STANDALONE`
        - `CONFIG`
        - `MONGOS`
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAlertConfigurationsResultThresholdConfigResult(dict):
    def __init__(__self__, *,
                 operator: str,
                 threshold: float,
                 units: str):
        """
        :param str operator: The operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
               - `GREATER_THAN`
               - `LESS_THAN`
        :param float threshold: Threshold value outside of which an alert will be triggered.
        :param str units: The units for the threshold value. Depends on the type of metric.
               Refer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "units", units)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        - `GREATER_THAN`
        - `LESS_THAN`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        Threshold value outside of which an alert will be triggered.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def units(self) -> str:
        """
        The units for the threshold value. Depends on the type of metric.
        Refer to the [MongoDB API Alert Configuration documentation](https://www.mongodb.com/docs/atlas/reference/api/alert-configurations-get-config/#request-body-parameters) for a list of accepted values.
        """
        return pulumi.get(self, "units")


@pulumi.output_type
class GetApiKeysResultResult(dict):
    def __init__(__self__, *,
                 api_key_id: str,
                 description: str,
                 public_key: str,
                 role_names: Sequence[str]):
        """
        :param str api_key_id: Unique identifier for the API key you want to update. Use the /orgs/{ORG-ID}/apiKeys endpoint to retrieve all API keys to which the authenticated user has access for the specified organization.
        :param str description: Description of this Organization API key.
        :param Sequence[str] role_names: Name of the role. This resource returns all the roles the user has in Atlas.
               
               The following are valid roles:
               * `ORG_OWNER`
               * `ORG_GROUP_CREATOR`
               * `ORG_BILLING_ADMIN`
               * `ORG_READ_ONLY`
               * `ORG_MEMBER`
               
               See [MongoDB Atlas API - Return All Organization API Keys](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Programmatic-API-Keys/operation/listApiKeys) - Documentation for more information.
        """
        pulumi.set(__self__, "api_key_id", api_key_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "public_key", public_key)
        pulumi.set(__self__, "role_names", role_names)

    @property
    @pulumi.getter(name="apiKeyId")
    def api_key_id(self) -> str:
        """
        Unique identifier for the API key you want to update. Use the /orgs/{ORG-ID}/apiKeys endpoint to retrieve all API keys to which the authenticated user has access for the specified organization.
        """
        return pulumi.get(self, "api_key_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of this Organization API key.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> str:
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[str]:
        """
        Name of the role. This resource returns all the roles the user has in Atlas.

        The following are valid roles:
        * `ORG_OWNER`
        * `ORG_GROUP_CREATOR`
        * `ORG_BILLING_ADMIN`
        * `ORG_READ_ONLY`
        * `ORG_MEMBER`

        See [MongoDB Atlas API - Return All Organization API Keys](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Programmatic-API-Keys/operation/listApiKeys) - Documentation for more information.
        """
        return pulumi.get(self, "role_names")


@pulumi.output_type
class GetAtlasUserLinkResult(dict):
    def __init__(__self__, *,
                 href: str,
                 rel: str):
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> str:
        return pulumi.get(self, "href")

    @property
    @pulumi.getter
    def rel(self) -> str:
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetAtlasUserRoleResult(dict):
    def __init__(__self__, *,
                 group_id: str,
                 org_id: str,
                 role_name: str):
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetAtlasUsersResultResult(dict):
    def __init__(__self__, *,
                 country: str,
                 created_at: str,
                 email_address: str,
                 first_name: str,
                 id: str,
                 last_auth: str,
                 last_name: str,
                 links: Sequence['outputs.GetAtlasUsersResultLinkResult'],
                 mobile_number: str,
                 roles: Sequence['outputs.GetAtlasUsersResultRoleResult'],
                 team_ids: Sequence[str],
                 user_id: str,
                 username: str):
        """
        :param str country: Two alphabet characters that identifies MongoDB Cloud user's geographic location. This parameter uses the ISO 3166-1a2 code format.
        :param str created_at: Date and time when the current account is created. This value is in the ISO 8601 timestamp format in UTC.
        :param str email_address: Email address that belongs to the MongoDB Atlas user.
        :param str first_name: First or given name that belongs to the MongoDB Atlas user.
        :param str last_auth: Date and time when the current account last authenticated. This value is in the ISO 8601 timestamp format in UTC.
        :param str last_name: Last name, family name, or surname that belongs to the MongoDB Atlas user.
        :param str mobile_number: Mobile phone number that belongs to the MongoDB Atlas user.
        :param Sequence[str] team_ids: List of unique 24-hexadecimal digit strings that identifies the teams to which this MongoDB Atlas user belongs.
               * `links.#.href` - Uniform Resource Locator (URL) that points another API resource to which this response has some relationship. This URL often begins with https://cloud.mongodb.com/api/atlas.
               * `links.#.rel` - Uniform Resource Locator (URL) that defines the semantic relationship between this resource and another API resource. This URL often begins with https://cloud.mongodb.com/api/atlas.
               * `roles.#.group_id` - Unique 24-hexadecimal digit string that identifies the project to which this role belongs. You can set a value for this parameter or orgId but not both in the same request.
               * `roles.#.org_id` - Unique 24-hexadecimal digit string that identifies the organization to which this role belongs. You can set a value for this parameter or groupId but not both in the same request.
               * `roles.#.role_name` - Human-readable label that identifies the collection of privileges that MongoDB Atlas grants a specific API key, user, or team. These roles include organization- and project-level roles. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#service-user-roles) describes the valid roles that can be assigned.
        :param str user_id: Unique 24-hexadecimal digit string that identifies this user.
        :param str username: Email address that belongs to the MongoDB Atlas user account. You cannot modify this address after creating the user.
        """
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_auth", last_auth)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "links", links)
        pulumi.set(__self__, "mobile_number", mobile_number)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "team_ids", team_ids)
        pulumi.set(__self__, "user_id", user_id)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def country(self) -> str:
        """
        Two alphabet characters that identifies MongoDB Cloud user's geographic location. This parameter uses the ISO 3166-1a2 code format.
        """
        return pulumi.get(self, "country")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Date and time when the current account is created. This value is in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> str:
        """
        Email address that belongs to the MongoDB Atlas user.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> str:
        """
        First or given name that belongs to the MongoDB Atlas user.
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastAuth")
    def last_auth(self) -> str:
        """
        Date and time when the current account last authenticated. This value is in the ISO 8601 timestamp format in UTC.
        """
        return pulumi.get(self, "last_auth")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> str:
        """
        Last name, family name, or surname that belongs to the MongoDB Atlas user.
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter
    def links(self) -> Sequence['outputs.GetAtlasUsersResultLinkResult']:
        return pulumi.get(self, "links")

    @property
    @pulumi.getter(name="mobileNumber")
    def mobile_number(self) -> str:
        """
        Mobile phone number that belongs to the MongoDB Atlas user.
        """
        return pulumi.get(self, "mobile_number")

    @property
    @pulumi.getter
    def roles(self) -> Sequence['outputs.GetAtlasUsersResultRoleResult']:
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter(name="teamIds")
    def team_ids(self) -> Sequence[str]:
        """
        List of unique 24-hexadecimal digit strings that identifies the teams to which this MongoDB Atlas user belongs.
        * `links.#.href` - Uniform Resource Locator (URL) that points another API resource to which this response has some relationship. This URL often begins with https://cloud.mongodb.com/api/atlas.
        * `links.#.rel` - Uniform Resource Locator (URL) that defines the semantic relationship between this resource and another API resource. This URL often begins with https://cloud.mongodb.com/api/atlas.
        * `roles.#.group_id` - Unique 24-hexadecimal digit string that identifies the project to which this role belongs. You can set a value for this parameter or orgId but not both in the same request.
        * `roles.#.org_id` - Unique 24-hexadecimal digit string that identifies the organization to which this role belongs. You can set a value for this parameter or groupId but not both in the same request.
        * `roles.#.role_name` - Human-readable label that identifies the collection of privileges that MongoDB Atlas grants a specific API key, user, or team. These roles include organization- and project-level roles. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#service-user-roles) describes the valid roles that can be assigned.
        """
        return pulumi.get(self, "team_ids")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies this user.
        """
        return pulumi.get(self, "user_id")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Email address that belongs to the MongoDB Atlas user account. You cannot modify this address after creating the user.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetAtlasUsersResultLinkResult(dict):
    def __init__(__self__, *,
                 href: str,
                 rel: str):
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> str:
        return pulumi.get(self, "href")

    @property
    @pulumi.getter
    def rel(self) -> str:
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetAtlasUsersResultRoleResult(dict):
    def __init__(__self__, *,
                 group_id: str,
                 org_id: str,
                 role_name: str):
        """
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization whose users you want to return. Also needed when `team_id` attributes is defined.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization whose users you want to return. Also needed when `team_id` attributes is defined.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetBackupCompliancePolicyOnDemandPolicyItemResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetBackupCompliancePolicyPolicyItemDailyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetBackupCompliancePolicyPolicyItemHourlyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetBackupCompliancePolicyPolicyItemMonthlyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetBackupCompliancePolicyPolicyItemWeeklyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetBackupCompliancePolicyPolicyItemYearlyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetCloudBackupScheduleCopySettingResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 frequencies: Sequence[str],
                 region_name: str,
                 replication_spec_id: str,
                 should_copy_oplogs: bool,
                 zone_id: str):
        """
        :param str cloud_provider: Human-readable label that identifies the cloud provider that stores the snapshot copy. i.e. "AWS" "AZURE" "GCP"
        :param Sequence[str] frequencies: List that describes which types of snapshots to copy. i.e. "HOURLY" "DAILY" "WEEKLY" "MONTHLY" "YEARLY" "ON_DEMAND"
        :param str region_name: Target region to copy snapshots belonging to replicationSpecId to. Please supply the 'Atlas Region' which can be found under https://www.mongodb.com/docs/atlas/reference/cloud-providers/ 'regions' link
        :param str replication_spec_id: Unique 24-hexadecimal digit string that identifies the replication object for a zone in a cluster. For global clusters, there can be multiple zones to choose from. For sharded clusters and replica set clusters, there is only one zone in the cluster. To find the Replication Spec Id, consult the replicationSpecs array returned from [Return One Multi-Cloud Cluster in One Project](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Clusters/operation/getCluster). **(DEPRECATED)** Use `zone_id` instead. To learn more, see the 1.18.0 upgrade guide.
        :param bool should_copy_oplogs: Flag that indicates whether to copy the oplogs to the target region. You can use the oplogs to perform point-in-time restores.
        :param str zone_id: Unique 24-hexadecimal digit string that identifies the zone in a cluster. For global clusters, there can be multiple zones to choose from. For sharded clusters and replica set clusters, there is only one zone in the cluster.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "frequencies", frequencies)
        pulumi.set(__self__, "region_name", region_name)
        pulumi.set(__self__, "replication_spec_id", replication_spec_id)
        pulumi.set(__self__, "should_copy_oplogs", should_copy_oplogs)
        pulumi.set(__self__, "zone_id", zone_id)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        Human-readable label that identifies the cloud provider that stores the snapshot copy. i.e. "AWS" "AZURE" "GCP"
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def frequencies(self) -> Sequence[str]:
        """
        List that describes which types of snapshots to copy. i.e. "HOURLY" "DAILY" "WEEKLY" "MONTHLY" "YEARLY" "ON_DEMAND"
        """
        return pulumi.get(self, "frequencies")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        Target region to copy snapshots belonging to replicationSpecId to. Please supply the 'Atlas Region' which can be found under https://www.mongodb.com/docs/atlas/reference/cloud-providers/ 'regions' link
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter(name="replicationSpecId")
    @_utilities.deprecated("""This parameter is deprecated. Please transition to `copy_settings.#.zone_id`. To learn more, see our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
    def replication_spec_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the replication object for a zone in a cluster. For global clusters, there can be multiple zones to choose from. For sharded clusters and replica set clusters, there is only one zone in the cluster. To find the Replication Spec Id, consult the replicationSpecs array returned from [Return One Multi-Cloud Cluster in One Project](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Clusters/operation/getCluster). **(DEPRECATED)** Use `zone_id` instead. To learn more, see the 1.18.0 upgrade guide.
        """
        return pulumi.get(self, "replication_spec_id")

    @property
    @pulumi.getter(name="shouldCopyOplogs")
    def should_copy_oplogs(self) -> bool:
        """
        Flag that indicates whether to copy the oplogs to the target region. You can use the oplogs to perform point-in-time restores.
        """
        return pulumi.get(self, "should_copy_oplogs")

    @property
    @pulumi.getter(name="zoneId")
    def zone_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the zone in a cluster. For global clusters, there can be multiple zones to choose from. For sharded clusters and replica set clusters, there is only one zone in the cluster.
        """
        return pulumi.get(self, "zone_id")


@pulumi.output_type
class GetCloudBackupScheduleExportResult(dict):
    def __init__(__self__, *,
                 export_bucket_id: str,
                 frequency_type: str):
        """
        :param str export_bucket_id: Unique identifier of the CloudBackupSnapshotExportBucket export_bucket_id value.
        :param str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        pulumi.set(__self__, "export_bucket_id", export_bucket_id)
        pulumi.set(__self__, "frequency_type", frequency_type)

    @property
    @pulumi.getter(name="exportBucketId")
    def export_bucket_id(self) -> str:
        """
        Unique identifier of the CloudBackupSnapshotExportBucket export_bucket_id value.
        """
        return pulumi.get(self, "export_bucket_id")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")


@pulumi.output_type
class GetCloudBackupSchedulePolicyItemDailyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetCloudBackupSchedulePolicyItemHourlyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetCloudBackupSchedulePolicyItemMonthlyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetCloudBackupSchedulePolicyItemWeeklyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetCloudBackupSchedulePolicyItemYearlyResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param int frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        :param str frequency_type: Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        :param str id: Unique identifier of the backup policy item.
        :param str retention_unit: Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        :param int retention_value: Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        """
        Desired frequency of the new backup policy item specified by `frequency_type` (yearly in this case). The supported values for yearly policies are
        """
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        """
        Frequency associated with the backup policy item. For yearly policies, the frequency type is defined as `yearly`. Note that this is a read-only value and not required in plan files - its value is implied from the policy resource type.
        """
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of the backup policy item.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        """
        Scope of the backup policy item: `days`, `weeks`, `months`, or `years`.
        """
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        """
        Value to associate with `retention_unit`. Yearly policy must have retention of at least 1 year.
        """
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetCloudBackupSnapshotExportBucketsResultResult(dict):
    def __init__(__self__, *,
                 bucket_name: str,
                 cloud_provider: str,
                 export_bucket_id: str,
                 iam_role_id: str,
                 role_id: str,
                 service_url: str,
                 tenant_id: str):
        """
        :param str bucket_name: Name of the bucket that the provided role ID is authorized to access.
        :param str cloud_provider: Name of the provider of the cloud service where Atlas can access the S3 bucket.
        :param str export_bucket_id: Unique identifier of the snapshot bucket id.
        :param str iam_role_id: Unique identifier of the role that Atlas can use to access the bucket.
        :param str role_id: Unique identifier of the Azure Service Principal that Atlas can use to access the Azure Blob Storage Container.
        :param str service_url: URL that identifies the blob Endpoint of the Azure Blob Storage Account.
        :param str tenant_id: UUID that identifies the Azure Active Directory Tenant ID.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "export_bucket_id", export_bucket_id)
        pulumi.set(__self__, "iam_role_id", iam_role_id)
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "service_url", service_url)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> str:
        """
        Name of the bucket that the provided role ID is authorized to access.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        Name of the provider of the cloud service where Atlas can access the S3 bucket.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="exportBucketId")
    def export_bucket_id(self) -> str:
        """
        Unique identifier of the snapshot bucket id.
        """
        return pulumi.get(self, "export_bucket_id")

    @property
    @pulumi.getter(name="iamRoleId")
    def iam_role_id(self) -> str:
        """
        Unique identifier of the role that Atlas can use to access the bucket.
        """
        return pulumi.get(self, "iam_role_id")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> str:
        """
        Unique identifier of the Azure Service Principal that Atlas can use to access the Azure Blob Storage Container.
        """
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="serviceUrl")
    def service_url(self) -> str:
        """
        URL that identifies the blob Endpoint of the Azure Blob Storage Account.
        """
        return pulumi.get(self, "service_url")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        UUID that identifies the Azure Active Directory Tenant ID.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetCloudBackupSnapshotExportJobComponentResult(dict):
    def __init__(__self__, *,
                 export_id: str,
                 replica_set_name: str):
        """
        :param str export_id: _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        :param str replica_set_name: _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
        pulumi.set(__self__, "export_id", export_id)
        pulumi.set(__self__, "replica_set_name", replica_set_name)

    @property
    @pulumi.getter(name="exportId")
    def export_id(self) -> str:
        """
        _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        """
        return pulumi.get(self, "export_id")

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> str:
        """
        _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
        return pulumi.get(self, "replica_set_name")


@pulumi.output_type
class GetCloudBackupSnapshotExportJobCustomDataResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Custom data specified as key in the key and value pair.
        :param str value: Value for the key specified using `key`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Custom data specified as key in the key and value pair.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value for the key specified using `key`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCloudBackupSnapshotExportJobsResultResult(dict):
    def __init__(__self__, *,
                 components: Sequence['outputs.GetCloudBackupSnapshotExportJobsResultComponentResult'],
                 created_at: str,
                 custom_datas: Sequence['outputs.GetCloudBackupSnapshotExportJobsResultCustomDataResult'],
                 export_bucket_id: str,
                 export_job_id: str,
                 export_status_exported_collections: int,
                 export_status_total_collections: int,
                 finished_at: str,
                 prefix: str,
                 snapshot_id: str,
                 state: str):
        """
        :param Sequence['GetCloudBackupSnapshotExportJobsResultComponentArgs'] components: _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        :param str created_at: Timestamp in ISO 8601 date and time format in UTC when the export job was created.
        :param Sequence['GetCloudBackupSnapshotExportJobsResultCustomDataArgs'] custom_datas: Custom data to include in the metadata file named `.complete` that Atlas uploads to the bucket when the export job finishes. Custom data can be specified as key and value pairs.
        :param str export_bucket_id: Unique identifier of the AWS bucket to export the Cloud Backup snapshot to.
        :param str export_job_id: Unique identifier of the export job.
               * `prefix ` - Full path on the cloud provider bucket to the folder where the snapshot is exported. The path is in the following format:`/exported_snapshots/{ORG-NAME}/{PROJECT-NAME}/{CLUSTER-NAME}/{SNAPSHOT-INITIATION-DATE}/{TIMESTAMP}`
        :param str finished_at: Timestamp in ISO 8601 date and time format in UTC when the export job completes.
        :param str snapshot_id: Unique identifier of the Cloud Backup snapshot to export.
        :param str state: Status of the export job. Value can be one of the following:
               * `Queued` - indicates that the export job is queued
               * `InProgress` - indicates that the snapshot is being exported
               * `Successful` - indicates that the export job has completed successfully
               * `Failed` - indicates that the export job has failed
        """
        pulumi.set(__self__, "components", components)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "custom_datas", custom_datas)
        pulumi.set(__self__, "export_bucket_id", export_bucket_id)
        pulumi.set(__self__, "export_job_id", export_job_id)
        pulumi.set(__self__, "export_status_exported_collections", export_status_exported_collections)
        pulumi.set(__self__, "export_status_total_collections", export_status_total_collections)
        pulumi.set(__self__, "finished_at", finished_at)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def components(self) -> Sequence['outputs.GetCloudBackupSnapshotExportJobsResultComponentResult']:
        """
        _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        """
        return pulumi.get(self, "components")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Timestamp in ISO 8601 date and time format in UTC when the export job was created.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="customDatas")
    def custom_datas(self) -> Sequence['outputs.GetCloudBackupSnapshotExportJobsResultCustomDataResult']:
        """
        Custom data to include in the metadata file named `.complete` that Atlas uploads to the bucket when the export job finishes. Custom data can be specified as key and value pairs.
        """
        return pulumi.get(self, "custom_datas")

    @property
    @pulumi.getter(name="exportBucketId")
    def export_bucket_id(self) -> str:
        """
        Unique identifier of the AWS bucket to export the Cloud Backup snapshot to.
        """
        return pulumi.get(self, "export_bucket_id")

    @property
    @pulumi.getter(name="exportJobId")
    def export_job_id(self) -> str:
        """
        Unique identifier of the export job.
        * `prefix ` - Full path on the cloud provider bucket to the folder where the snapshot is exported. The path is in the following format:`/exported_snapshots/{ORG-NAME}/{PROJECT-NAME}/{CLUSTER-NAME}/{SNAPSHOT-INITIATION-DATE}/{TIMESTAMP}`
        """
        return pulumi.get(self, "export_job_id")

    @property
    @pulumi.getter(name="exportStatusExportedCollections")
    def export_status_exported_collections(self) -> int:
        return pulumi.get(self, "export_status_exported_collections")

    @property
    @pulumi.getter(name="exportStatusTotalCollections")
    def export_status_total_collections(self) -> int:
        return pulumi.get(self, "export_status_total_collections")

    @property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> str:
        """
        Timestamp in ISO 8601 date and time format in UTC when the export job completes.
        """
        return pulumi.get(self, "finished_at")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> str:
        """
        Unique identifier of the Cloud Backup snapshot to export.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Status of the export job. Value can be one of the following:
        * `Queued` - indicates that the export job is queued
        * `InProgress` - indicates that the snapshot is being exported
        * `Successful` - indicates that the export job has completed successfully
        * `Failed` - indicates that the export job has failed
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetCloudBackupSnapshotExportJobsResultComponentResult(dict):
    def __init__(__self__, *,
                 export_id: str,
                 replica_set_name: str):
        """
        :param str export_id: _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        :param str replica_set_name: _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
        pulumi.set(__self__, "export_id", export_id)
        pulumi.set(__self__, "replica_set_name", replica_set_name)

    @property
    @pulumi.getter(name="exportId")
    def export_id(self) -> str:
        """
        _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        """
        return pulumi.get(self, "export_id")

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> str:
        """
        _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
        return pulumi.get(self, "replica_set_name")


@pulumi.output_type
class GetCloudBackupSnapshotExportJobsResultCustomDataResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Custom data specified as key in the key and value pair.
        :param str value: Value for the key specified using `key`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Custom data specified as key in the key and value pair.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value for the key specified using `key`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetCloudBackupSnapshotMemberResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 id: str,
                 replica_set_name: str):
        """
        :param str cloud_provider: Cloud provider that stores this snapshot.
        :param str id: Unique identifier for the sharded cluster snapshot.
        :param str replica_set_name: Label given to a shard or config server from which Atlas took this snapshot.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "replica_set_name", replica_set_name)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        Cloud provider that stores this snapshot.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier for the sharded cluster snapshot.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> str:
        """
        Label given to a shard or config server from which Atlas took this snapshot.
        """
        return pulumi.get(self, "replica_set_name")


@pulumi.output_type
class GetCloudBackupSnapshotRestoreJobsResultResult(dict):
    def __init__(__self__, *,
                 cancelled: bool,
                 delivery_type: str,
                 delivery_urls: Sequence[str],
                 expired: bool,
                 expires_at: str,
                 finished_at: str,
                 id: str,
                 oplog_inc: int,
                 oplog_ts: int,
                 point_in_time_utc_seconds: int,
                 snapshot_id: str,
                 target_cluster_name: str,
                 target_project_id: str,
                 timestamp: str):
        """
        :param bool cancelled: Indicates whether the restore job was canceled.
        :param str delivery_type: Type of restore job to create. Possible values are: automated and download.
        :param Sequence[str] delivery_urls: One or more URLs for the compressed snapshot files for manual download. Only visible if deliveryType is download.
        :param bool expired: Indicates whether the restore job expired.
        :param str expires_at: UTC ISO 8601 formatted point in time when the restore job expires.
        :param str finished_at: UTC ISO 8601 formatted point in time when the restore job completed.
        :param str id: The unique identifier of the restore job.
        :param str snapshot_id: Unique identifier of the source snapshot ID of the restore job.
        :param str target_cluster_name: Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.
        :param str target_project_id: Name of the target Atlas project of the restore job. Only visible if deliveryType is automated.
        :param str timestamp: Timestamp in ISO 8601 date and time format in UTC when the snapshot associated to snapshotId was taken.
               * `oplogTs` - Timestamp in the number of seconds that have elapsed since the UNIX epoch.
               * `oplogInc` - Oplog operation number from which to you want to restore this snapshot.
               * `pointInTimeUTCSeconds` - Timestamp in the number of seconds that have elapsed since the UNIX epoch.
        """
        pulumi.set(__self__, "cancelled", cancelled)
        pulumi.set(__self__, "delivery_type", delivery_type)
        pulumi.set(__self__, "delivery_urls", delivery_urls)
        pulumi.set(__self__, "expired", expired)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "finished_at", finished_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "oplog_inc", oplog_inc)
        pulumi.set(__self__, "oplog_ts", oplog_ts)
        pulumi.set(__self__, "point_in_time_utc_seconds", point_in_time_utc_seconds)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "target_cluster_name", target_cluster_name)
        pulumi.set(__self__, "target_project_id", target_project_id)
        pulumi.set(__self__, "timestamp", timestamp)

    @property
    @pulumi.getter
    def cancelled(self) -> bool:
        """
        Indicates whether the restore job was canceled.
        """
        return pulumi.get(self, "cancelled")

    @property
    @pulumi.getter(name="deliveryType")
    def delivery_type(self) -> str:
        """
        Type of restore job to create. Possible values are: automated and download.
        """
        return pulumi.get(self, "delivery_type")

    @property
    @pulumi.getter(name="deliveryUrls")
    def delivery_urls(self) -> Sequence[str]:
        """
        One or more URLs for the compressed snapshot files for manual download. Only visible if deliveryType is download.
        """
        return pulumi.get(self, "delivery_urls")

    @property
    @pulumi.getter
    def expired(self) -> bool:
        """
        Indicates whether the restore job expired.
        """
        return pulumi.get(self, "expired")

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> str:
        """
        UTC ISO 8601 formatted point in time when the restore job expires.
        """
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> str:
        """
        UTC ISO 8601 formatted point in time when the restore job completed.
        """
        return pulumi.get(self, "finished_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique identifier of the restore job.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="oplogInc")
    def oplog_inc(self) -> int:
        return pulumi.get(self, "oplog_inc")

    @property
    @pulumi.getter(name="oplogTs")
    def oplog_ts(self) -> int:
        return pulumi.get(self, "oplog_ts")

    @property
    @pulumi.getter(name="pointInTimeUtcSeconds")
    def point_in_time_utc_seconds(self) -> int:
        return pulumi.get(self, "point_in_time_utc_seconds")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> str:
        """
        Unique identifier of the source snapshot ID of the restore job.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter(name="targetClusterName")
    def target_cluster_name(self) -> str:
        """
        Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.
        """
        return pulumi.get(self, "target_cluster_name")

    @property
    @pulumi.getter(name="targetProjectId")
    def target_project_id(self) -> str:
        """
        Name of the target Atlas project of the restore job. Only visible if deliveryType is automated.
        """
        return pulumi.get(self, "target_project_id")

    @property
    @pulumi.getter
    def timestamp(self) -> str:
        """
        Timestamp in ISO 8601 date and time format in UTC when the snapshot associated to snapshotId was taken.
        * `oplogTs` - Timestamp in the number of seconds that have elapsed since the UNIX epoch.
        * `oplogInc` - Oplog operation number from which to you want to restore this snapshot.
        * `pointInTimeUTCSeconds` - Timestamp in the number of seconds that have elapsed since the UNIX epoch.
        """
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class GetCloudBackupSnapshotsResultResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 created_at: str,
                 description: str,
                 expires_at: str,
                 id: str,
                 master_key_uuid: str,
                 members: Sequence['outputs.GetCloudBackupSnapshotsResultMemberResult'],
                 mongod_version: str,
                 replica_set_name: str,
                 snapshot_ids: Sequence[str],
                 snapshot_type: str,
                 status: str,
                 storage_size_bytes: int,
                 type: str):
        """
        :param str cloud_provider: Cloud provider that stores this snapshot.
        :param str created_at: UTC ISO 8601 formatted point in time when Atlas took the snapshot.
        :param str description: UDescription of the snapshot. Only present for on-demand snapshots.
        :param str expires_at: UTC ISO 8601 formatted point in time when Atlas will delete the snapshot.
        :param str id: Unique identifier for the sharded cluster snapshot.
        :param str master_key_uuid: Unique ID of the AWS KMS Customer Master Key used to encrypt the snapshot. Only visible for clusters using Encryption at Rest via Customer KMS.
        :param Sequence['GetCloudBackupSnapshotsResultMemberArgs'] members: Block of List of snapshots and the cloud provider where the snapshots are stored. See below
        :param str mongod_version: Version of the MongoDB server.
        :param str replica_set_name: Label given to a shard or config server from which Atlas took this snapshot.
        :param Sequence[str] snapshot_ids: Unique identifiers of the snapshots created for the shards and config server for a sharded cluster.
        :param str snapshot_type: Specified the type of snapshot. Valid values are onDemand and scheduled.
        :param str status: Current status of the snapshot. One of the following values: queued, inProgress, completed, failed.
        :param int storage_size_bytes: Specifies the size of the snapshot in bytes.
        :param str type: Specifies the type of cluster: replicaSet or shardedCluster.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "master_key_uuid", master_key_uuid)
        pulumi.set(__self__, "members", members)
        pulumi.set(__self__, "mongod_version", mongod_version)
        pulumi.set(__self__, "replica_set_name", replica_set_name)
        pulumi.set(__self__, "snapshot_ids", snapshot_ids)
        pulumi.set(__self__, "snapshot_type", snapshot_type)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "storage_size_bytes", storage_size_bytes)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        Cloud provider that stores this snapshot.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        UTC ISO 8601 formatted point in time when Atlas took the snapshot.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        UDescription of the snapshot. Only present for on-demand snapshots.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> str:
        """
        UTC ISO 8601 formatted point in time when Atlas will delete the snapshot.
        """
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier for the sharded cluster snapshot.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="masterKeyUuid")
    def master_key_uuid(self) -> str:
        """
        Unique ID of the AWS KMS Customer Master Key used to encrypt the snapshot. Only visible for clusters using Encryption at Rest via Customer KMS.
        """
        return pulumi.get(self, "master_key_uuid")

    @property
    @pulumi.getter
    def members(self) -> Sequence['outputs.GetCloudBackupSnapshotsResultMemberResult']:
        """
        Block of List of snapshots and the cloud provider where the snapshots are stored. See below
        """
        return pulumi.get(self, "members")

    @property
    @pulumi.getter(name="mongodVersion")
    def mongod_version(self) -> str:
        """
        Version of the MongoDB server.
        """
        return pulumi.get(self, "mongod_version")

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> str:
        """
        Label given to a shard or config server from which Atlas took this snapshot.
        """
        return pulumi.get(self, "replica_set_name")

    @property
    @pulumi.getter(name="snapshotIds")
    def snapshot_ids(self) -> Sequence[str]:
        """
        Unique identifiers of the snapshots created for the shards and config server for a sharded cluster.
        """
        return pulumi.get(self, "snapshot_ids")

    @property
    @pulumi.getter(name="snapshotType")
    def snapshot_type(self) -> str:
        """
        Specified the type of snapshot. Valid values are onDemand and scheduled.
        """
        return pulumi.get(self, "snapshot_type")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Current status of the snapshot. One of the following values: queued, inProgress, completed, failed.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="storageSizeBytes")
    def storage_size_bytes(self) -> int:
        """
        Specifies the size of the snapshot in bytes.
        """
        return pulumi.get(self, "storage_size_bytes")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of cluster: replicaSet or shardedCluster.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetCloudBackupSnapshotsResultMemberResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 id: str,
                 replica_set_name: str):
        """
        :param str cloud_provider: Cloud provider that stores this snapshot.
        :param str id: Unique identifier for the sharded cluster snapshot.
        :param str replica_set_name: Label given to a shard or config server from which Atlas took this snapshot.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "replica_set_name", replica_set_name)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        Cloud provider that stores this snapshot.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier for the sharded cluster snapshot.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> str:
        """
        Label given to a shard or config server from which Atlas took this snapshot.
        """
        return pulumi.get(self, "replica_set_name")


@pulumi.output_type
class GetCloudProviderAccessSetupAwsConfigResult(dict):
    def __init__(__self__, *,
                 atlas_assumed_role_external_id: str,
                 atlas_aws_account_arn: str):
        """
        :param str atlas_assumed_role_external_id: Unique external ID Atlas uses when assuming the IAM role in your AWS account.
        :param str atlas_aws_account_arn: ARN associated with the Atlas AWS account used to assume IAM roles in your AWS account.
        """
        pulumi.set(__self__, "atlas_assumed_role_external_id", atlas_assumed_role_external_id)
        pulumi.set(__self__, "atlas_aws_account_arn", atlas_aws_account_arn)

    @property
    @pulumi.getter(name="atlasAssumedRoleExternalId")
    def atlas_assumed_role_external_id(self) -> str:
        """
        Unique external ID Atlas uses when assuming the IAM role in your AWS account.
        """
        return pulumi.get(self, "atlas_assumed_role_external_id")

    @property
    @pulumi.getter(name="atlasAwsAccountArn")
    def atlas_aws_account_arn(self) -> str:
        """
        ARN associated with the Atlas AWS account used to assume IAM roles in your AWS account.
        """
        return pulumi.get(self, "atlas_aws_account_arn")


@pulumi.output_type
class GetCloudProviderAccessSetupAzureConfigResult(dict):
    def __init__(__self__, *,
                 atlas_azure_app_id: str,
                 service_principal_id: str,
                 tenant_id: str):
        """
        :param str atlas_azure_app_id: Azure Active Directory Application ID of Atlas.
        :param str service_principal_id: UUID string that identifies the Azure Service Principal.
        :param str tenant_id: UUID String that identifies the Azure Active Directory Tenant ID.
        """
        pulumi.set(__self__, "atlas_azure_app_id", atlas_azure_app_id)
        pulumi.set(__self__, "service_principal_id", service_principal_id)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="atlasAzureAppId")
    def atlas_azure_app_id(self) -> str:
        """
        Azure Active Directory Application ID of Atlas.
        """
        return pulumi.get(self, "atlas_azure_app_id")

    @property
    @pulumi.getter(name="servicePrincipalId")
    def service_principal_id(self) -> str:
        """
        UUID string that identifies the Azure Service Principal.
        """
        return pulumi.get(self, "service_principal_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        UUID String that identifies the Azure Active Directory Tenant ID.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetClusterAdvancedConfigurationResult(dict):
    def __init__(__self__, *,
                 change_stream_options_pre_and_post_images_expire_after_seconds: int,
                 default_read_concern: str,
                 default_write_concern: str,
                 fail_index_key_too_long: bool,
                 javascript_enabled: bool,
                 minimum_enabled_tls_protocol: str,
                 no_table_scan: bool,
                 oplog_min_retention_hours: float,
                 oplog_size_mb: int,
                 sample_refresh_interval_bi_connector: int,
                 sample_size_bi_connector: int,
                 transaction_lifetime_limit_seconds: int):
        """
        :param int change_stream_options_pre_and_post_images_expire_after_seconds: (Optional) The minimum pre- and post-image retention time in seconds. This parameter is only supported for MongoDB version 6.0 and above. Defaults to `-1`(off).
        :param str default_read_concern: [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        :param str default_write_concern: [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        :param bool fail_index_key_too_long: When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        :param bool javascript_enabled: When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        :param str minimum_enabled_tls_protocol: Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        :param bool no_table_scan: When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        :param float oplog_min_retention_hours: Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        :param int oplog_size_mb: The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        :param int sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param int sample_size_bi_connector: Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param int transaction_lifetime_limit_seconds: Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        pulumi.set(__self__, "change_stream_options_pre_and_post_images_expire_after_seconds", change_stream_options_pre_and_post_images_expire_after_seconds)
        pulumi.set(__self__, "default_read_concern", default_read_concern)
        pulumi.set(__self__, "default_write_concern", default_write_concern)
        pulumi.set(__self__, "fail_index_key_too_long", fail_index_key_too_long)
        pulumi.set(__self__, "javascript_enabled", javascript_enabled)
        pulumi.set(__self__, "minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        pulumi.set(__self__, "no_table_scan", no_table_scan)
        pulumi.set(__self__, "oplog_min_retention_hours", oplog_min_retention_hours)
        pulumi.set(__self__, "oplog_size_mb", oplog_size_mb)
        pulumi.set(__self__, "sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        pulumi.set(__self__, "sample_size_bi_connector", sample_size_bi_connector)
        pulumi.set(__self__, "transaction_lifetime_limit_seconds", transaction_lifetime_limit_seconds)

    @property
    @pulumi.getter(name="changeStreamOptionsPreAndPostImagesExpireAfterSeconds")
    def change_stream_options_pre_and_post_images_expire_after_seconds(self) -> int:
        """
        (Optional) The minimum pre- and post-image retention time in seconds. This parameter is only supported for MongoDB version 6.0 and above. Defaults to `-1`(off).
        """
        return pulumi.get(self, "change_stream_options_pre_and_post_images_expire_after_seconds")

    @property
    @pulumi.getter(name="defaultReadConcern")
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
    def default_read_concern(self) -> str:
        """
        [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        """
        return pulumi.get(self, "default_read_concern")

    @property
    @pulumi.getter(name="defaultWriteConcern")
    def default_write_concern(self) -> str:
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        return pulumi.get(self, "default_write_concern")

    @property
    @pulumi.getter(name="failIndexKeyTooLong")
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
    def fail_index_key_too_long(self) -> bool:
        """
        When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        """
        return pulumi.get(self, "fail_index_key_too_long")

    @property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> bool:
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        return pulumi.get(self, "javascript_enabled")

    @property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> str:
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> bool:
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        return pulumi.get(self, "no_table_scan")

    @property
    @pulumi.getter(name="oplogMinRetentionHours")
    def oplog_min_retention_hours(self) -> float:
        """
        Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        """
        return pulumi.get(self, "oplog_min_retention_hours")

    @property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> int:
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        return pulumi.get(self, "oplog_size_mb")

    @property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> int:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> int:
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_size_bi_connector")

    @property
    @pulumi.getter(name="transactionLifetimeLimitSeconds")
    def transaction_lifetime_limit_seconds(self) -> int:
        """
        Lifetime, in seconds, of multi-document transactions. Defaults to 60 seconds.
        """
        return pulumi.get(self, "transaction_lifetime_limit_seconds")


@pulumi.output_type
class GetClusterBiConnectorConfigResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 read_preference: str):
        """
        :param bool enabled: Indicates whether or not BI Connector for Atlas is enabled on the cluster.
        :param str read_preference: Indicates the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "read_preference", read_preference)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Indicates whether or not BI Connector for Atlas is enabled on the cluster.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> str:
        """
        Indicates the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        return pulumi.get(self, "read_preference")


@pulumi.output_type
class GetClusterConnectionStringResult(dict):
    def __init__(__self__, *,
                 aws_private_link: Mapping[str, str],
                 aws_private_link_srv: Mapping[str, str],
                 private: str,
                 private_endpoints: Sequence['outputs.GetClusterConnectionStringPrivateEndpointResult'],
                 private_srv: str,
                 standard: str,
                 standard_srv: str):
        """
        :param str private: [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        :param str private_srv: [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
               - `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
               - `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint.
               - `connection_strings.private_endpoint.#.srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint.
               - `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
               - `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`
               - `connection_strings.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.
               - `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
               - `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.
        :param str standard: Public mongodb:// connection string for this cluster.
        :param str standard_srv: Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t, use connectionStrings.standard.
        """
        pulumi.set(__self__, "aws_private_link", aws_private_link)
        pulumi.set(__self__, "aws_private_link_srv", aws_private_link_srv)
        pulumi.set(__self__, "private", private)
        pulumi.set(__self__, "private_endpoints", private_endpoints)
        pulumi.set(__self__, "private_srv", private_srv)
        pulumi.set(__self__, "standard", standard)
        pulumi.set(__self__, "standard_srv", standard_srv)

    @property
    @pulumi.getter(name="awsPrivateLink")
    def aws_private_link(self) -> Mapping[str, str]:
        return pulumi.get(self, "aws_private_link")

    @property
    @pulumi.getter(name="awsPrivateLinkSrv")
    def aws_private_link_srv(self) -> Mapping[str, str]:
        return pulumi.get(self, "aws_private_link_srv")

    @property
    @pulumi.getter
    def private(self) -> str:
        """
        [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        """
        return pulumi.get(self, "private")

    @property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Sequence['outputs.GetClusterConnectionStringPrivateEndpointResult']:
        return pulumi.get(self, "private_endpoints")

    @property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> str:
        """
        [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        - `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
        - `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint.
        - `connection_strings.private_endpoint.#.srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint.
        - `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
        - `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`
        - `connection_strings.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.
        - `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
        - `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.
        """
        return pulumi.get(self, "private_srv")

    @property
    @pulumi.getter
    def standard(self) -> str:
        """
        Public mongodb:// connection string for this cluster.
        """
        return pulumi.get(self, "standard")

    @property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> str:
        """
        Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t, use connectionStrings.standard.
        """
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class GetClusterConnectionStringPrivateEndpointResult(dict):
    def __init__(__self__, *,
                 connection_string: str,
                 endpoints: Sequence['outputs.GetClusterConnectionStringPrivateEndpointEndpointResult'],
                 srv_connection_string: str,
                 srv_shard_optimized_connection_string: str,
                 type: str):
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "srv_connection_string", srv_connection_string)
        pulumi.set(__self__, "srv_shard_optimized_connection_string", srv_shard_optimized_connection_string)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> str:
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def endpoints(self) -> Sequence['outputs.GetClusterConnectionStringPrivateEndpointEndpointResult']:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> str:
        return pulumi.get(self, "srv_connection_string")

    @property
    @pulumi.getter(name="srvShardOptimizedConnectionString")
    def srv_shard_optimized_connection_string(self) -> str:
        return pulumi.get(self, "srv_shard_optimized_connection_string")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetClusterConnectionStringPrivateEndpointEndpointResult(dict):
    def __init__(__self__, *,
                 endpoint_id: str,
                 provider_name: str,
                 region: str):
        """
        :param str provider_name: Indicates the cloud service provider on which the servers are provisioned.
        """
        pulumi.set(__self__, "endpoint_id", endpoint_id)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> str:
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Indicates the cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetClusterLabelResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterOutageSimulationOutageFilterResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 region_name: str,
                 type: str):
        """
        :param str cloud_provider: The cloud provider of the region that undergoes the outage simulation. Following values are supported:
               * `AWS`
               * `GCP`
               * `AZURE`
        :param str region_name: The Atlas name of the region undergoing an outage simulation.
        :param str type: The type of cluster outage simulation. Following values are supported:
               * `REGION` (Simulates a cluster outage for a region)
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region_name", region_name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        The cloud provider of the region that undergoes the outage simulation. Following values are supported:
        * `AWS`
        * `GCP`
        * `AZURE`
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        The Atlas name of the region undergoing an outage simulation.
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of cluster outage simulation. Following values are supported:
        * `REGION` (Simulates a cluster outage for a region)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetClusterReplicationSpecResult(dict):
    def __init__(__self__, *,
                 id: str,
                 num_shards: int,
                 regions_configs: Sequence['outputs.GetClusterReplicationSpecRegionsConfigResult'],
                 zone_name: str):
        """
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        :param int num_shards: Number of shards to deploy in the specified zone.
        :param Sequence['GetClusterReplicationSpecRegionsConfigArgs'] regions_configs: Describes the physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        :param str zone_name: Indicates the n ame for the zone in a Global Cluster.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "num_shards", num_shards)
        pulumi.set(__self__, "regions_configs", regions_configs)
        pulumi.set(__self__, "zone_name", zone_name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> int:
        """
        Number of shards to deploy in the specified zone.
        """
        return pulumi.get(self, "num_shards")

    @property
    @pulumi.getter(name="regionsConfigs")
    def regions_configs(self) -> Sequence['outputs.GetClusterReplicationSpecRegionsConfigResult']:
        """
        Describes the physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        """
        return pulumi.get(self, "regions_configs")

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> str:
        """
        Indicates the n ame for the zone in a Global Cluster.
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class GetClusterReplicationSpecRegionsConfigResult(dict):
    def __init__(__self__, *,
                 analytics_nodes: int,
                 electable_nodes: int,
                 priority: int,
                 read_only_nodes: int,
                 region_name: str):
        """
        :param int analytics_nodes: Indicates the number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary.
        :param int electable_nodes: Number of electable nodes for Atlas to deploy to the region.
        :param int priority: Election priority of the region. For regions with only read-only nodes, set this value to 0.
        :param int read_only_nodes: Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        :param str region_name: Name for the region specified.
        """
        pulumi.set(__self__, "analytics_nodes", analytics_nodes)
        pulumi.set(__self__, "electable_nodes", electable_nodes)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "read_only_nodes", read_only_nodes)
        pulumi.set(__self__, "region_name", region_name)

    @property
    @pulumi.getter(name="analyticsNodes")
    def analytics_nodes(self) -> int:
        """
        Indicates the number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary.
        """
        return pulumi.get(self, "analytics_nodes")

    @property
    @pulumi.getter(name="electableNodes")
    def electable_nodes(self) -> int:
        """
        Number of electable nodes for Atlas to deploy to the region.
        """
        return pulumi.get(self, "electable_nodes")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Election priority of the region. For regions with only read-only nodes, set this value to 0.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="readOnlyNodes")
    def read_only_nodes(self) -> int:
        """
        Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        """
        return pulumi.get(self, "read_only_nodes")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        Name for the region specified.
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class GetClusterSnapshotBackupPolicyResult(dict):
    def __init__(__self__, *,
                 cluster_id: str,
                 cluster_name: str,
                 next_snapshot: str,
                 policies: Sequence['outputs.GetClusterSnapshotBackupPolicyPolicyResult'],
                 reference_hour_of_day: int,
                 reference_minute_of_hour: int,
                 restore_window_days: int,
                 update_snapshots: bool):
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "next_snapshot", next_snapshot)
        pulumi.set(__self__, "policies", policies)
        pulumi.set(__self__, "reference_hour_of_day", reference_hour_of_day)
        pulumi.set(__self__, "reference_minute_of_hour", reference_minute_of_hour)
        pulumi.set(__self__, "restore_window_days", restore_window_days)
        pulumi.set(__self__, "update_snapshots", update_snapshots)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="nextSnapshot")
    def next_snapshot(self) -> str:
        return pulumi.get(self, "next_snapshot")

    @property
    @pulumi.getter
    def policies(self) -> Sequence['outputs.GetClusterSnapshotBackupPolicyPolicyResult']:
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="referenceHourOfDay")
    def reference_hour_of_day(self) -> int:
        return pulumi.get(self, "reference_hour_of_day")

    @property
    @pulumi.getter(name="referenceMinuteOfHour")
    def reference_minute_of_hour(self) -> int:
        return pulumi.get(self, "reference_minute_of_hour")

    @property
    @pulumi.getter(name="restoreWindowDays")
    def restore_window_days(self) -> int:
        return pulumi.get(self, "restore_window_days")

    @property
    @pulumi.getter(name="updateSnapshots")
    def update_snapshots(self) -> bool:
        return pulumi.get(self, "update_snapshots")


@pulumi.output_type
class GetClusterSnapshotBackupPolicyPolicyResult(dict):
    def __init__(__self__, *,
                 id: str,
                 policy_items: Sequence['outputs.GetClusterSnapshotBackupPolicyPolicyPolicyItemResult']):
        """
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "policy_items", policy_items)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="policyItems")
    def policy_items(self) -> Sequence['outputs.GetClusterSnapshotBackupPolicyPolicyPolicyItemResult']:
        return pulumi.get(self, "policy_items")


@pulumi.output_type
class GetClusterSnapshotBackupPolicyPolicyPolicyItemResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetClusterTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClustersResultResult(dict):
    def __init__(__self__, *,
                 advanced_configurations: Sequence['outputs.GetClustersResultAdvancedConfigurationResult'],
                 auto_scaling_compute_enabled: bool,
                 auto_scaling_compute_scale_down_enabled: bool,
                 auto_scaling_disk_gb_enabled: bool,
                 backing_provider_name: str,
                 backup_enabled: bool,
                 bi_connector_configs: Sequence['outputs.GetClustersResultBiConnectorConfigResult'],
                 cluster_type: str,
                 connection_strings: Sequence['outputs.GetClustersResultConnectionStringResult'],
                 container_id: str,
                 disk_size_gb: float,
                 encryption_at_rest_provider: str,
                 labels: Sequence['outputs.GetClustersResultLabelResult'],
                 mongo_db_major_version: str,
                 mongo_db_version: str,
                 mongo_uri: str,
                 mongo_uri_updated: str,
                 mongo_uri_with_options: str,
                 name: str,
                 num_shards: int,
                 paused: bool,
                 pit_enabled: bool,
                 provider_auto_scaling_compute_max_instance_size: str,
                 provider_auto_scaling_compute_min_instance_size: str,
                 provider_backup_enabled: bool,
                 provider_disk_iops: int,
                 provider_disk_type_name: str,
                 provider_encrypt_ebs_volume: bool,
                 provider_instance_size_name: str,
                 provider_name: str,
                 provider_region_name: str,
                 provider_volume_type: str,
                 redact_client_log_data: bool,
                 replication_factor: int,
                 replication_specs: Sequence['outputs.GetClustersResultReplicationSpecResult'],
                 snapshot_backup_policies: Sequence['outputs.GetClustersResultSnapshotBackupPolicyResult'],
                 srv_address: str,
                 state_name: str,
                 tags: Sequence['outputs.GetClustersResultTagResult'],
                 termination_protection_enabled: bool,
                 version_release_system: str):
        """
        :param Sequence['GetClustersResultAdvancedConfigurationArgs'] advanced_configurations: Get the advanced configuration options. See Advanced Configuration below for more details.
        :param bool auto_scaling_compute_enabled: Specifies whether cluster tier auto-scaling is enabled. The default is false.
        :param bool auto_scaling_compute_scale_down_enabled: * `auto_scaling_compute_scale_down_enabled` - Specifies whether cluster tier auto-down-scaling is enabled.
        :param bool auto_scaling_disk_gb_enabled: Indicates whether disk auto-scaling is enabled.
        :param str backing_provider_name: Indicates Cloud service provider on which the server for a multi-tenant cluster is provisioned.
        :param bool backup_enabled: Legacy Option, Indicates whether Atlas continuous backups are enabled for the cluster.
        :param Sequence['GetClustersResultBiConnectorConfigArgs'] bi_connector_configs: Indicates BI Connector for Atlas configuration on this cluster. BI Connector for Atlas is only available for M10+ clusters. See BI Connector below for more details.
        :param str cluster_type: Indicates the type of the cluster that you want to modify. You cannot convert a sharded cluster deployment to a replica set deployment.
        :param Sequence['GetClustersResultConnectionStringArgs'] connection_strings: Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.
        :param str container_id: The Network Peering Container ID.
        :param float disk_size_gb: Indicates the size in gigabytes of the server’s root volume (AWS/GCP Only).
        :param str encryption_at_rest_provider: Indicates whether Encryption at Rest is enabled or disabled.
        :param Sequence['GetClustersResultLabelArgs'] labels: Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below. **DEPRECATED** Use `tags` instead.
        :param str mongo_db_major_version: Indicates the version of the cluster to deploy.
        :param str mongo_db_version: Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.
        :param str mongo_uri: Base connection string for the cluster. Atlas only displays this field after the cluster is operational, not while it builds the cluster.
        :param str mongo_uri_updated: Lists when the connection string was last updated. The connection string changes, for example, if you change a replica set to a sharded cluster.
        :param str mongo_uri_with_options: Describes connection string for connecting to the Atlas cluster. Includes the replicaSet, ssl, and authSource query parameters in the connection string with values appropriate for the cluster.
        :param str name: The name of the current plugin
        :param int num_shards: Number of shards to deploy in the specified zone.
        :param bool paused: Flag that indicates whether the cluster is paused or not.
        :param bool pit_enabled: Flag that indicates if the cluster uses Continuous Cloud Backup.
        :param str provider_auto_scaling_compute_max_instance_size: Maximum instance size to which your cluster can automatically scale.
        :param str provider_auto_scaling_compute_min_instance_size: Minimum instance size to which your cluster can automatically scale.
        :param bool provider_backup_enabled: Flag indicating if the cluster uses Cloud Backup Snapshots for backups. **DEPRECATED** Use `cloud_backup` instead.
        :param int provider_disk_iops: Indicates the maximum input/output operations per second (IOPS) the system can perform. The possible values depend on the selected providerSettings.instanceSizeName and diskSizeGB.
        :param str provider_disk_type_name: Describes Azure disk type of the server’s root volume (Azure Only).
        :param bool provider_encrypt_ebs_volume: **(DEPRECATED)** Indicates whether the Amazon EBS encryption is enabled. This feature encrypts the server’s root volume for both data at rest within the volume and data moving between the volume and the instance. By default this attribute is always enabled, per deprecation process showing the real value at `provider_encrypt_ebs_volume_flag` computed attribute.
        :param str provider_instance_size_name: Atlas provides different instance sizes, each with a default storage capacity and RAM size.
        :param str provider_name: Indicates the cloud service provider on which the servers are provisioned.
        :param str provider_region_name: Indicates Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases. Requires the Atlas Region name, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        :param str provider_volume_type: Indicates the type of the volume. The possible values are: `STANDARD` and `PROVISIONED`.
               > **NOTE:** `STANDARD` is not available for NVME clusters.
        :param bool redact_client_log_data: (Optional) Flag that enables or disables log redaction, see the [manual](https://www.mongodb.com/docs/manual/administration/monitoring/#log-redaction) for more info.
        :param int replication_factor: (Deprecated) Number of replica set members. Each member keeps a copy of your databases, providing high availability and data redundancy. The possible values are 3, 5, or 7. The default value is 3.
        :param Sequence['GetClustersResultReplicationSpecArgs'] replication_specs: Configuration for cluster regions.  See Replication Spec below for more details.
        :param Sequence['GetClustersResultSnapshotBackupPolicyArgs'] snapshot_backup_policies: current snapshot schedule and retention settings for the cluster.
        :param str srv_address: Connection string for connecting to the Atlas cluster. The +srv modifier forces the connection to use TLS/SSL. See the mongoURI for additional options.
        :param str state_name: Indicates the current state of the cluster. The possible states are:
               - IDLE
               - CREATING
               - UPDATING
               - DELETING
               - DELETED
               - REPAIRING
        :param Sequence['GetClustersResultTagArgs'] tags: Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.
        :param bool termination_protection_enabled: Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.
        :param str version_release_system: Release cadence that Atlas uses for this cluster.
        """
        pulumi.set(__self__, "advanced_configurations", advanced_configurations)
        pulumi.set(__self__, "auto_scaling_compute_enabled", auto_scaling_compute_enabled)
        pulumi.set(__self__, "auto_scaling_compute_scale_down_enabled", auto_scaling_compute_scale_down_enabled)
        pulumi.set(__self__, "auto_scaling_disk_gb_enabled", auto_scaling_disk_gb_enabled)
        pulumi.set(__self__, "backing_provider_name", backing_provider_name)
        pulumi.set(__self__, "backup_enabled", backup_enabled)
        pulumi.set(__self__, "bi_connector_configs", bi_connector_configs)
        pulumi.set(__self__, "cluster_type", cluster_type)
        pulumi.set(__self__, "connection_strings", connection_strings)
        pulumi.set(__self__, "container_id", container_id)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "encryption_at_rest_provider", encryption_at_rest_provider)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "mongo_db_major_version", mongo_db_major_version)
        pulumi.set(__self__, "mongo_db_version", mongo_db_version)
        pulumi.set(__self__, "mongo_uri", mongo_uri)
        pulumi.set(__self__, "mongo_uri_updated", mongo_uri_updated)
        pulumi.set(__self__, "mongo_uri_with_options", mongo_uri_with_options)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "num_shards", num_shards)
        pulumi.set(__self__, "paused", paused)
        pulumi.set(__self__, "pit_enabled", pit_enabled)
        pulumi.set(__self__, "provider_auto_scaling_compute_max_instance_size", provider_auto_scaling_compute_max_instance_size)
        pulumi.set(__self__, "provider_auto_scaling_compute_min_instance_size", provider_auto_scaling_compute_min_instance_size)
        pulumi.set(__self__, "provider_backup_enabled", provider_backup_enabled)
        pulumi.set(__self__, "provider_disk_iops", provider_disk_iops)
        pulumi.set(__self__, "provider_disk_type_name", provider_disk_type_name)
        pulumi.set(__self__, "provider_encrypt_ebs_volume", provider_encrypt_ebs_volume)
        pulumi.set(__self__, "provider_instance_size_name", provider_instance_size_name)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "provider_region_name", provider_region_name)
        pulumi.set(__self__, "provider_volume_type", provider_volume_type)
        pulumi.set(__self__, "redact_client_log_data", redact_client_log_data)
        pulumi.set(__self__, "replication_factor", replication_factor)
        pulumi.set(__self__, "replication_specs", replication_specs)
        pulumi.set(__self__, "snapshot_backup_policies", snapshot_backup_policies)
        pulumi.set(__self__, "srv_address", srv_address)
        pulumi.set(__self__, "state_name", state_name)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "termination_protection_enabled", termination_protection_enabled)
        pulumi.set(__self__, "version_release_system", version_release_system)

    @property
    @pulumi.getter(name="advancedConfigurations")
    def advanced_configurations(self) -> Sequence['outputs.GetClustersResultAdvancedConfigurationResult']:
        """
        Get the advanced configuration options. See Advanced Configuration below for more details.
        """
        return pulumi.get(self, "advanced_configurations")

    @property
    @pulumi.getter(name="autoScalingComputeEnabled")
    def auto_scaling_compute_enabled(self) -> bool:
        """
        Specifies whether cluster tier auto-scaling is enabled. The default is false.
        """
        return pulumi.get(self, "auto_scaling_compute_enabled")

    @property
    @pulumi.getter(name="autoScalingComputeScaleDownEnabled")
    def auto_scaling_compute_scale_down_enabled(self) -> bool:
        """
        * `auto_scaling_compute_scale_down_enabled` - Specifies whether cluster tier auto-down-scaling is enabled.
        """
        return pulumi.get(self, "auto_scaling_compute_scale_down_enabled")

    @property
    @pulumi.getter(name="autoScalingDiskGbEnabled")
    def auto_scaling_disk_gb_enabled(self) -> bool:
        """
        Indicates whether disk auto-scaling is enabled.
        """
        return pulumi.get(self, "auto_scaling_disk_gb_enabled")

    @property
    @pulumi.getter(name="backingProviderName")
    def backing_provider_name(self) -> str:
        """
        Indicates Cloud service provider on which the server for a multi-tenant cluster is provisioned.
        """
        return pulumi.get(self, "backing_provider_name")

    @property
    @pulumi.getter(name="backupEnabled")
    def backup_enabled(self) -> bool:
        """
        Legacy Option, Indicates whether Atlas continuous backups are enabled for the cluster.
        """
        return pulumi.get(self, "backup_enabled")

    @property
    @pulumi.getter(name="biConnectorConfigs")
    def bi_connector_configs(self) -> Sequence['outputs.GetClustersResultBiConnectorConfigResult']:
        """
        Indicates BI Connector for Atlas configuration on this cluster. BI Connector for Atlas is only available for M10+ clusters. See BI Connector below for more details.
        """
        return pulumi.get(self, "bi_connector_configs")

    @property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> str:
        """
        Indicates the type of the cluster that you want to modify. You cannot convert a sharded cluster deployment to a replica set deployment.
        """
        return pulumi.get(self, "cluster_type")

    @property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> Sequence['outputs.GetClustersResultConnectionStringResult']:
        """
        Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.
        """
        return pulumi.get(self, "connection_strings")

    @property
    @pulumi.getter(name="containerId")
    def container_id(self) -> str:
        """
        The Network Peering Container ID.
        """
        return pulumi.get(self, "container_id")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> float:
        """
        Indicates the size in gigabytes of the server’s root volume (AWS/GCP Only).
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter(name="encryptionAtRestProvider")
    def encryption_at_rest_provider(self) -> str:
        """
        Indicates whether Encryption at Rest is enabled or disabled.
        """
        return pulumi.get(self, "encryption_at_rest_provider")

    @property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetClustersResultLabelResult']:
        """
        Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below. **DEPRECATED** Use `tags` instead.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="mongoDbMajorVersion")
    def mongo_db_major_version(self) -> str:
        """
        Indicates the version of the cluster to deploy.
        """
        return pulumi.get(self, "mongo_db_major_version")

    @property
    @pulumi.getter(name="mongoDbVersion")
    def mongo_db_version(self) -> str:
        """
        Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.
        """
        return pulumi.get(self, "mongo_db_version")

    @property
    @pulumi.getter(name="mongoUri")
    def mongo_uri(self) -> str:
        """
        Base connection string for the cluster. Atlas only displays this field after the cluster is operational, not while it builds the cluster.
        """
        return pulumi.get(self, "mongo_uri")

    @property
    @pulumi.getter(name="mongoUriUpdated")
    def mongo_uri_updated(self) -> str:
        """
        Lists when the connection string was last updated. The connection string changes, for example, if you change a replica set to a sharded cluster.
        """
        return pulumi.get(self, "mongo_uri_updated")

    @property
    @pulumi.getter(name="mongoUriWithOptions")
    def mongo_uri_with_options(self) -> str:
        """
        Describes connection string for connecting to the Atlas cluster. Includes the replicaSet, ssl, and authSource query parameters in the connection string with values appropriate for the cluster.
        """
        return pulumi.get(self, "mongo_uri_with_options")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the current plugin
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> int:
        """
        Number of shards to deploy in the specified zone.
        """
        return pulumi.get(self, "num_shards")

    @property
    @pulumi.getter
    def paused(self) -> bool:
        """
        Flag that indicates whether the cluster is paused or not.
        """
        return pulumi.get(self, "paused")

    @property
    @pulumi.getter(name="pitEnabled")
    def pit_enabled(self) -> bool:
        """
        Flag that indicates if the cluster uses Continuous Cloud Backup.
        """
        return pulumi.get(self, "pit_enabled")

    @property
    @pulumi.getter(name="providerAutoScalingComputeMaxInstanceSize")
    def provider_auto_scaling_compute_max_instance_size(self) -> str:
        """
        Maximum instance size to which your cluster can automatically scale.
        """
        return pulumi.get(self, "provider_auto_scaling_compute_max_instance_size")

    @property
    @pulumi.getter(name="providerAutoScalingComputeMinInstanceSize")
    def provider_auto_scaling_compute_min_instance_size(self) -> str:
        """
        Minimum instance size to which your cluster can automatically scale.
        """
        return pulumi.get(self, "provider_auto_scaling_compute_min_instance_size")

    @property
    @pulumi.getter(name="providerBackupEnabled")
    def provider_backup_enabled(self) -> bool:
        """
        Flag indicating if the cluster uses Cloud Backup Snapshots for backups. **DEPRECATED** Use `cloud_backup` instead.
        """
        return pulumi.get(self, "provider_backup_enabled")

    @property
    @pulumi.getter(name="providerDiskIops")
    def provider_disk_iops(self) -> int:
        """
        Indicates the maximum input/output operations per second (IOPS) the system can perform. The possible values depend on the selected providerSettings.instanceSizeName and diskSizeGB.
        """
        return pulumi.get(self, "provider_disk_iops")

    @property
    @pulumi.getter(name="providerDiskTypeName")
    def provider_disk_type_name(self) -> str:
        """
        Describes Azure disk type of the server’s root volume (Azure Only).
        """
        return pulumi.get(self, "provider_disk_type_name")

    @property
    @pulumi.getter(name="providerEncryptEbsVolume")
    def provider_encrypt_ebs_volume(self) -> bool:
        """
        **(DEPRECATED)** Indicates whether the Amazon EBS encryption is enabled. This feature encrypts the server’s root volume for both data at rest within the volume and data moving between the volume and the instance. By default this attribute is always enabled, per deprecation process showing the real value at `provider_encrypt_ebs_volume_flag` computed attribute.
        """
        return pulumi.get(self, "provider_encrypt_ebs_volume")

    @property
    @pulumi.getter(name="providerInstanceSizeName")
    def provider_instance_size_name(self) -> str:
        """
        Atlas provides different instance sizes, each with a default storage capacity and RAM size.
        """
        return pulumi.get(self, "provider_instance_size_name")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Indicates the cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter(name="providerRegionName")
    def provider_region_name(self) -> str:
        """
        Indicates Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases. Requires the Atlas Region name, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        """
        return pulumi.get(self, "provider_region_name")

    @property
    @pulumi.getter(name="providerVolumeType")
    def provider_volume_type(self) -> str:
        """
        Indicates the type of the volume. The possible values are: `STANDARD` and `PROVISIONED`.
        > **NOTE:** `STANDARD` is not available for NVME clusters.
        """
        return pulumi.get(self, "provider_volume_type")

    @property
    @pulumi.getter(name="redactClientLogData")
    def redact_client_log_data(self) -> bool:
        """
        (Optional) Flag that enables or disables log redaction, see the [manual](https://www.mongodb.com/docs/manual/administration/monitoring/#log-redaction) for more info.
        """
        return pulumi.get(self, "redact_client_log_data")

    @property
    @pulumi.getter(name="replicationFactor")
    def replication_factor(self) -> int:
        """
        (Deprecated) Number of replica set members. Each member keeps a copy of your databases, providing high availability and data redundancy. The possible values are 3, 5, or 7. The default value is 3.
        """
        return pulumi.get(self, "replication_factor")

    @property
    @pulumi.getter(name="replicationSpecs")
    def replication_specs(self) -> Sequence['outputs.GetClustersResultReplicationSpecResult']:
        """
        Configuration for cluster regions.  See Replication Spec below for more details.
        """
        return pulumi.get(self, "replication_specs")

    @property
    @pulumi.getter(name="snapshotBackupPolicies")
    def snapshot_backup_policies(self) -> Sequence['outputs.GetClustersResultSnapshotBackupPolicyResult']:
        """
        current snapshot schedule and retention settings for the cluster.
        """
        return pulumi.get(self, "snapshot_backup_policies")

    @property
    @pulumi.getter(name="srvAddress")
    def srv_address(self) -> str:
        """
        Connection string for connecting to the Atlas cluster. The +srv modifier forces the connection to use TLS/SSL. See the mongoURI for additional options.
        """
        return pulumi.get(self, "srv_address")

    @property
    @pulumi.getter(name="stateName")
    def state_name(self) -> str:
        """
        Indicates the current state of the cluster. The possible states are:
        - IDLE
        - CREATING
        - UPDATING
        - DELETING
        - DELETED
        - REPAIRING
        """
        return pulumi.get(self, "state_name")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetClustersResultTagResult']:
        """
        Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="terminationProtectionEnabled")
    def termination_protection_enabled(self) -> bool:
        """
        Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.
        """
        return pulumi.get(self, "termination_protection_enabled")

    @property
    @pulumi.getter(name="versionReleaseSystem")
    def version_release_system(self) -> str:
        """
        Release cadence that Atlas uses for this cluster.
        """
        return pulumi.get(self, "version_release_system")


@pulumi.output_type
class GetClustersResultAdvancedConfigurationResult(dict):
    def __init__(__self__, *,
                 change_stream_options_pre_and_post_images_expire_after_seconds: int,
                 default_read_concern: str,
                 default_write_concern: str,
                 fail_index_key_too_long: bool,
                 javascript_enabled: bool,
                 minimum_enabled_tls_protocol: str,
                 no_table_scan: bool,
                 oplog_min_retention_hours: float,
                 oplog_size_mb: int,
                 sample_refresh_interval_bi_connector: int,
                 sample_size_bi_connector: int,
                 transaction_lifetime_limit_seconds: int):
        """
        :param int change_stream_options_pre_and_post_images_expire_after_seconds: (Optional) The minimum pre- and post-image retention time in seconds. This parameter is only supported for MongoDB version 6.0 and above. Defaults to `-1`(off).
        :param str default_read_concern: [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        :param str default_write_concern: [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        :param bool fail_index_key_too_long: When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        :param bool javascript_enabled: When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        :param str minimum_enabled_tls_protocol: Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        :param bool no_table_scan: When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        :param float oplog_min_retention_hours: Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        :param int oplog_size_mb: The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        :param int sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param int sample_size_bi_connector: Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        pulumi.set(__self__, "change_stream_options_pre_and_post_images_expire_after_seconds", change_stream_options_pre_and_post_images_expire_after_seconds)
        pulumi.set(__self__, "default_read_concern", default_read_concern)
        pulumi.set(__self__, "default_write_concern", default_write_concern)
        pulumi.set(__self__, "fail_index_key_too_long", fail_index_key_too_long)
        pulumi.set(__self__, "javascript_enabled", javascript_enabled)
        pulumi.set(__self__, "minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        pulumi.set(__self__, "no_table_scan", no_table_scan)
        pulumi.set(__self__, "oplog_min_retention_hours", oplog_min_retention_hours)
        pulumi.set(__self__, "oplog_size_mb", oplog_size_mb)
        pulumi.set(__self__, "sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        pulumi.set(__self__, "sample_size_bi_connector", sample_size_bi_connector)
        pulumi.set(__self__, "transaction_lifetime_limit_seconds", transaction_lifetime_limit_seconds)

    @property
    @pulumi.getter(name="changeStreamOptionsPreAndPostImagesExpireAfterSeconds")
    def change_stream_options_pre_and_post_images_expire_after_seconds(self) -> int:
        """
        (Optional) The minimum pre- and post-image retention time in seconds. This parameter is only supported for MongoDB version 6.0 and above. Defaults to `-1`(off).
        """
        return pulumi.get(self, "change_stream_options_pre_and_post_images_expire_after_seconds")

    @property
    @pulumi.getter(name="defaultReadConcern")
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
    def default_read_concern(self) -> str:
        """
        [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        """
        return pulumi.get(self, "default_read_concern")

    @property
    @pulumi.getter(name="defaultWriteConcern")
    def default_write_concern(self) -> str:
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        return pulumi.get(self, "default_write_concern")

    @property
    @pulumi.getter(name="failIndexKeyTooLong")
    @_utilities.deprecated("""This parameter is deprecated. Please refer to our examples, documentation, and 1.18.0 migration guide for more details at https://registry.terraform.io/providers/mongodb/mongodbatlas/latest/docs/guides/1.18.0-upgrade-guide.html.markdown""")
    def fail_index_key_too_long(self) -> bool:
        """
        When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        """
        return pulumi.get(self, "fail_index_key_too_long")

    @property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> bool:
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        return pulumi.get(self, "javascript_enabled")

    @property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> str:
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> bool:
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        return pulumi.get(self, "no_table_scan")

    @property
    @pulumi.getter(name="oplogMinRetentionHours")
    def oplog_min_retention_hours(self) -> float:
        """
        Minimum retention window for cluster's oplog expressed in hours. A value of null indicates that the cluster uses the default minimum oplog window that MongoDB Cloud calculates.
        """
        return pulumi.get(self, "oplog_min_retention_hours")

    @property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> int:
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        return pulumi.get(self, "oplog_size_mb")

    @property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> int:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> int:
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_size_bi_connector")

    @property
    @pulumi.getter(name="transactionLifetimeLimitSeconds")
    def transaction_lifetime_limit_seconds(self) -> int:
        return pulumi.get(self, "transaction_lifetime_limit_seconds")


@pulumi.output_type
class GetClustersResultBiConnectorConfigResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 read_preference: str):
        """
        :param bool enabled: Indicates whether or not BI Connector for Atlas is enabled on the cluster.
        :param str read_preference: Indicates the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "read_preference", read_preference)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Indicates whether or not BI Connector for Atlas is enabled on the cluster.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> str:
        """
        Indicates the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        return pulumi.get(self, "read_preference")


@pulumi.output_type
class GetClustersResultConnectionStringResult(dict):
    def __init__(__self__, *,
                 aws_private_link: Mapping[str, str],
                 aws_private_link_srv: Mapping[str, str],
                 private: str,
                 private_endpoints: Sequence['outputs.GetClustersResultConnectionStringPrivateEndpointResult'],
                 private_srv: str,
                 standard: str,
                 standard_srv: str):
        """
        :param str private: [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        :param str private_srv: [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
               - `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
               - `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint.
               - `connection_strings.private_endpoint.#.srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint.
               - `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
               - `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`
               - `connection_strings.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.
               - `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
               - `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.
        :param str standard: Public mongodb:// connection string for this cluster.
        :param str standard_srv: Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t, use connectionStrings.standard.
        """
        pulumi.set(__self__, "aws_private_link", aws_private_link)
        pulumi.set(__self__, "aws_private_link_srv", aws_private_link_srv)
        pulumi.set(__self__, "private", private)
        pulumi.set(__self__, "private_endpoints", private_endpoints)
        pulumi.set(__self__, "private_srv", private_srv)
        pulumi.set(__self__, "standard", standard)
        pulumi.set(__self__, "standard_srv", standard_srv)

    @property
    @pulumi.getter(name="awsPrivateLink")
    def aws_private_link(self) -> Mapping[str, str]:
        return pulumi.get(self, "aws_private_link")

    @property
    @pulumi.getter(name="awsPrivateLinkSrv")
    def aws_private_link_srv(self) -> Mapping[str, str]:
        return pulumi.get(self, "aws_private_link_srv")

    @property
    @pulumi.getter
    def private(self) -> str:
        """
        [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        """
        return pulumi.get(self, "private")

    @property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Sequence['outputs.GetClustersResultConnectionStringPrivateEndpointResult']:
        return pulumi.get(self, "private_endpoints")

    @property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> str:
        """
        [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        - `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
        - `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint.
        - `connection_strings.private_endpoint.#.srv_shard_optimized_connection_string` - Private endpoint-aware connection string optimized for sharded clusters that uses the `mongodb+srv://` protocol to connect to MongoDB Cloud through a private endpoint.
        - `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
        - `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`
        - `connection_strings.private_endpoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.
        - `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
        - `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.
        """
        return pulumi.get(self, "private_srv")

    @property
    @pulumi.getter
    def standard(self) -> str:
        """
        Public mongodb:// connection string for this cluster.
        """
        return pulumi.get(self, "standard")

    @property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> str:
        """
        Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t, use connectionStrings.standard.
        """
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class GetClustersResultConnectionStringPrivateEndpointResult(dict):
    def __init__(__self__, *,
                 connection_string: str,
                 endpoints: Sequence['outputs.GetClustersResultConnectionStringPrivateEndpointEndpointResult'],
                 srv_connection_string: str,
                 srv_shard_optimized_connection_string: str,
                 type: str):
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "srv_connection_string", srv_connection_string)
        pulumi.set(__self__, "srv_shard_optimized_connection_string", srv_shard_optimized_connection_string)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> str:
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def endpoints(self) -> Sequence['outputs.GetClustersResultConnectionStringPrivateEndpointEndpointResult']:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> str:
        return pulumi.get(self, "srv_connection_string")

    @property
    @pulumi.getter(name="srvShardOptimizedConnectionString")
    def srv_shard_optimized_connection_string(self) -> str:
        return pulumi.get(self, "srv_shard_optimized_connection_string")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetClustersResultConnectionStringPrivateEndpointEndpointResult(dict):
    def __init__(__self__, *,
                 endpoint_id: str,
                 provider_name: str,
                 region: str):
        """
        :param str provider_name: Indicates the cloud service provider on which the servers are provisioned.
        """
        pulumi.set(__self__, "endpoint_id", endpoint_id)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> str:
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Indicates the cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetClustersResultLabelResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClustersResultReplicationSpecResult(dict):
    def __init__(__self__, *,
                 id: str,
                 num_shards: int,
                 regions_configs: Sequence['outputs.GetClustersResultReplicationSpecRegionsConfigResult'],
                 zone_name: str):
        """
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        :param int num_shards: Number of shards to deploy in the specified zone.
        :param Sequence['GetClustersResultReplicationSpecRegionsConfigArgs'] regions_configs: Describes the physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        :param str zone_name: Indicates the n ame for the zone in a Global Cluster.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "num_shards", num_shards)
        pulumi.set(__self__, "regions_configs", regions_configs)
        pulumi.set(__self__, "zone_name", zone_name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> int:
        """
        Number of shards to deploy in the specified zone.
        """
        return pulumi.get(self, "num_shards")

    @property
    @pulumi.getter(name="regionsConfigs")
    def regions_configs(self) -> Sequence['outputs.GetClustersResultReplicationSpecRegionsConfigResult']:
        """
        Describes the physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        """
        return pulumi.get(self, "regions_configs")

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> str:
        """
        Indicates the n ame for the zone in a Global Cluster.
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class GetClustersResultReplicationSpecRegionsConfigResult(dict):
    def __init__(__self__, *,
                 analytics_nodes: int,
                 electable_nodes: int,
                 priority: int,
                 read_only_nodes: int,
                 region_name: str):
        """
        :param int analytics_nodes: Indicates the number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary.
        :param int electable_nodes: Number of electable nodes for Atlas to deploy to the region.
        :param int priority: Election priority of the region. For regions with only read-only nodes, set this value to 0.
        :param int read_only_nodes: Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        :param str region_name: Name for the region specified.
        """
        pulumi.set(__self__, "analytics_nodes", analytics_nodes)
        pulumi.set(__self__, "electable_nodes", electable_nodes)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "read_only_nodes", read_only_nodes)
        pulumi.set(__self__, "region_name", region_name)

    @property
    @pulumi.getter(name="analyticsNodes")
    def analytics_nodes(self) -> int:
        """
        Indicates the number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary.
        """
        return pulumi.get(self, "analytics_nodes")

    @property
    @pulumi.getter(name="electableNodes")
    def electable_nodes(self) -> int:
        """
        Number of electable nodes for Atlas to deploy to the region.
        """
        return pulumi.get(self, "electable_nodes")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Election priority of the region. For regions with only read-only nodes, set this value to 0.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="readOnlyNodes")
    def read_only_nodes(self) -> int:
        """
        Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        """
        return pulumi.get(self, "read_only_nodes")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        Name for the region specified.
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class GetClustersResultSnapshotBackupPolicyResult(dict):
    def __init__(__self__, *,
                 cluster_id: str,
                 cluster_name: str,
                 next_snapshot: str,
                 policies: Sequence['outputs.GetClustersResultSnapshotBackupPolicyPolicyResult'],
                 reference_hour_of_day: int,
                 reference_minute_of_hour: int,
                 restore_window_days: int,
                 update_snapshots: bool):
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "next_snapshot", next_snapshot)
        pulumi.set(__self__, "policies", policies)
        pulumi.set(__self__, "reference_hour_of_day", reference_hour_of_day)
        pulumi.set(__self__, "reference_minute_of_hour", reference_minute_of_hour)
        pulumi.set(__self__, "restore_window_days", restore_window_days)
        pulumi.set(__self__, "update_snapshots", update_snapshots)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="nextSnapshot")
    def next_snapshot(self) -> str:
        return pulumi.get(self, "next_snapshot")

    @property
    @pulumi.getter
    def policies(self) -> Sequence['outputs.GetClustersResultSnapshotBackupPolicyPolicyResult']:
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="referenceHourOfDay")
    def reference_hour_of_day(self) -> int:
        return pulumi.get(self, "reference_hour_of_day")

    @property
    @pulumi.getter(name="referenceMinuteOfHour")
    def reference_minute_of_hour(self) -> int:
        return pulumi.get(self, "reference_minute_of_hour")

    @property
    @pulumi.getter(name="restoreWindowDays")
    def restore_window_days(self) -> int:
        return pulumi.get(self, "restore_window_days")

    @property
    @pulumi.getter(name="updateSnapshots")
    def update_snapshots(self) -> bool:
        return pulumi.get(self, "update_snapshots")


@pulumi.output_type
class GetClustersResultSnapshotBackupPolicyPolicyResult(dict):
    def __init__(__self__, *,
                 id: str,
                 policy_items: Sequence['outputs.GetClustersResultSnapshotBackupPolicyPolicyPolicyItemResult']):
        """
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "policy_items", policy_items)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="policyItems")
    def policy_items(self) -> Sequence['outputs.GetClustersResultSnapshotBackupPolicyPolicyPolicyItemResult']:
        return pulumi.get(self, "policy_items")


@pulumi.output_type
class GetClustersResultSnapshotBackupPolicyPolicyPolicyItemResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifer of the replication document for a zone in a Global Cluster. This value corresponds to the legacy sharding schema (no independent shard scaling) and is different from the Shard ID you may see in the Atlas UI.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetClustersResultTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetControlPlaneIpAddressesInboundResult(dict):
    def __init__(__self__, *,
                 aws: Mapping[str, Sequence[str]],
                 azure: Mapping[str, Sequence[str]],
                 gcp: Mapping[str, Sequence[str]]):
        """
        :param Mapping[str, Sequence[str]] aws: Control plane IP addresses in AWS. Each key identifies an Amazon Web Services (AWS) region. Each value identifies control plane IP addresses in the AWS region.
        :param Mapping[str, Sequence[str]] azure: Control plane IP addresses in Azure. Each key identifies an Azure region. Each value identifies control plane IP addresses in the Azure region.
        :param Mapping[str, Sequence[str]] gcp: Control plane IP addresses in GCP. Each key identifies a Google Cloud (GCP) region. Each value identifies control plane IP addresses in the GCP region.
        """
        pulumi.set(__self__, "aws", aws)
        pulumi.set(__self__, "azure", azure)
        pulumi.set(__self__, "gcp", gcp)

    @property
    @pulumi.getter
    def aws(self) -> Mapping[str, Sequence[str]]:
        """
        Control plane IP addresses in AWS. Each key identifies an Amazon Web Services (AWS) region. Each value identifies control plane IP addresses in the AWS region.
        """
        return pulumi.get(self, "aws")

    @property
    @pulumi.getter
    def azure(self) -> Mapping[str, Sequence[str]]:
        """
        Control plane IP addresses in Azure. Each key identifies an Azure region. Each value identifies control plane IP addresses in the Azure region.
        """
        return pulumi.get(self, "azure")

    @property
    @pulumi.getter
    def gcp(self) -> Mapping[str, Sequence[str]]:
        """
        Control plane IP addresses in GCP. Each key identifies a Google Cloud (GCP) region. Each value identifies control plane IP addresses in the GCP region.
        """
        return pulumi.get(self, "gcp")


@pulumi.output_type
class GetControlPlaneIpAddressesOutboundResult(dict):
    def __init__(__self__, *,
                 aws: Mapping[str, Sequence[str]],
                 azure: Mapping[str, Sequence[str]],
                 gcp: Mapping[str, Sequence[str]]):
        """
        :param Mapping[str, Sequence[str]] aws: Control plane IP addresses in AWS. Each key identifies an Amazon Web Services (AWS) region. Each value identifies control plane IP addresses in the AWS region.
        :param Mapping[str, Sequence[str]] azure: Control plane IP addresses in Azure. Each key identifies an Azure region. Each value identifies control plane IP addresses in the Azure region.
        :param Mapping[str, Sequence[str]] gcp: Control plane IP addresses in GCP. Each key identifies a Google Cloud (GCP) region. Each value identifies control plane IP addresses in the GCP region.
        """
        pulumi.set(__self__, "aws", aws)
        pulumi.set(__self__, "azure", azure)
        pulumi.set(__self__, "gcp", gcp)

    @property
    @pulumi.getter
    def aws(self) -> Mapping[str, Sequence[str]]:
        """
        Control plane IP addresses in AWS. Each key identifies an Amazon Web Services (AWS) region. Each value identifies control plane IP addresses in the AWS region.
        """
        return pulumi.get(self, "aws")

    @property
    @pulumi.getter
    def azure(self) -> Mapping[str, Sequence[str]]:
        """
        Control plane IP addresses in Azure. Each key identifies an Azure region. Each value identifies control plane IP addresses in the Azure region.
        """
        return pulumi.get(self, "azure")

    @property
    @pulumi.getter
    def gcp(self) -> Mapping[str, Sequence[str]]:
        """
        Control plane IP addresses in GCP. Each key identifies a Google Cloud (GCP) region. Each value identifies control plane IP addresses in the GCP region.
        """
        return pulumi.get(self, "gcp")


@pulumi.output_type
class GetCustomDbRoleActionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 resources: Sequence['outputs.GetCustomDbRoleActionResourceResult']):
        """
        :param str action: (Required) Name of the privilege action. For a complete list of actions available in the Atlas API, see Custom Role Actions.
        :param Sequence['GetCustomDbRoleActionResourceArgs'] resources: (Required) Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        (Required) Name of the privilege action. For a complete list of actions available in the Atlas API, see Custom Role Actions.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetCustomDbRoleActionResourceResult']:
        """
        (Required) Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetCustomDbRoleActionResourceResult(dict):
    def __init__(__self__, *,
                 cluster: bool,
                 collection_name: str,
                 database_name: str):
        """
        :param str database_name: (Required) Database on which the inherited role is granted.
        """
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "database_name", database_name)

    @property
    @pulumi.getter
    def cluster(self) -> bool:
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> str:
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        (Required) Database on which the inherited role is granted.
        """
        return pulumi.get(self, "database_name")


@pulumi.output_type
class GetCustomDbRoleInheritedRoleResult(dict):
    def __init__(__self__, *,
                 database_name: str,
                 role_name: str):
        """
        :param str database_name: (Required) Database on which the inherited role is granted.
        :param str role_name: Name of the custom role.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        (Required) Database on which the inherited role is granted.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        """
        Name of the custom role.
        """
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetCustomDbRolesResultResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetCustomDbRolesResultActionResult'],
                 inherited_roles: Sequence['outputs.GetCustomDbRolesResultInheritedRoleResult'],
                 role_name: str):
        """
        :param str role_name: (Required) Name of the inherited role. This can either be another custom role or a built-in role.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "inherited_roles", inherited_roles)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetCustomDbRolesResultActionResult']:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="inheritedRoles")
    def inherited_roles(self) -> Sequence['outputs.GetCustomDbRolesResultInheritedRoleResult']:
        return pulumi.get(self, "inherited_roles")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        """
        (Required) Name of the inherited role. This can either be another custom role or a built-in role.
        """
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetCustomDbRolesResultActionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 resources: Sequence['outputs.GetCustomDbRolesResultActionResourceResult']):
        """
        :param str action: (Required) Name of the privilege action. For a complete list of actions available in the Atlas API, see Custom Role Actions.
        :param Sequence['GetCustomDbRolesResultActionResourceArgs'] resources: (Required) Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        (Required) Name of the privilege action. For a complete list of actions available in the Atlas API, see Custom Role Actions.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetCustomDbRolesResultActionResourceResult']:
        """
        (Required) Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetCustomDbRolesResultActionResourceResult(dict):
    def __init__(__self__, *,
                 cluster: bool,
                 collection_name: str,
                 database_name: str):
        """
        :param str database_name: (Required) Database on which the inherited role is granted.
        """
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "database_name", database_name)

    @property
    @pulumi.getter
    def cluster(self) -> bool:
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> str:
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        (Required) Database on which the inherited role is granted.
        """
        return pulumi.get(self, "database_name")


@pulumi.output_type
class GetCustomDbRolesResultInheritedRoleResult(dict):
    def __init__(__self__, *,
                 database_name: str,
                 role_name: str):
        """
        :param str database_name: (Required) Database on which the inherited role is granted.
        :param str role_name: (Required) Name of the inherited role. This can either be another custom role or a built-in role.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        (Required) Database on which the inherited role is granted.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        """
        (Required) Name of the inherited role. This can either be another custom role or a built-in role.
        """
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetDataLakePipelineIngestionScheduleResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param str id: Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetDataLakePipelineRunStatResult(dict):
    def __init__(__self__, *,
                 bytes_exported: int,
                 num_docs: int):
        """
        :param int bytes_exported: Total data size in bytes exported for this pipeline run.
        :param int num_docs: Number of docs ingested for a this pipeline run.
        """
        pulumi.set(__self__, "bytes_exported", bytes_exported)
        pulumi.set(__self__, "num_docs", num_docs)

    @property
    @pulumi.getter(name="bytesExported")
    def bytes_exported(self) -> int:
        """
        Total data size in bytes exported for this pipeline run.
        """
        return pulumi.get(self, "bytes_exported")

    @property
    @pulumi.getter(name="numDocs")
    def num_docs(self) -> int:
        """
        Number of docs ingested for a this pipeline run.
        """
        return pulumi.get(self, "num_docs")


@pulumi.output_type
class GetDataLakePipelineRunsResultResult(dict):
    def __init__(__self__, *,
                 backup_frequency_type: str,
                 created_date: str,
                 id: str,
                 last_updated_date: str,
                 phase: str,
                 pipeline_id: str,
                 pipeline_run_id: str,
                 snapshot_id: str,
                 state: str,
                 stats: Sequence['outputs.GetDataLakePipelineRunsResultStatResult']):
        """
        :param str backup_frequency_type: Backup schedule interval of the Data Lake Pipeline.
        :param str created_date: Timestamp that indicates when the pipeline run was created.
        :param str id: Unique 24-hexadecimal character string that identifies a Data Lake Pipeline run.
        :param str last_updated_date: Unique 24-hexadecimal character string that identifies a Data Lake Pipeline run.
        :param str phase: Processing phase of the Data Lake Pipeline.
        :param str pipeline_id: Unique 24-hexadecimal character string that identifies a Data Lake Pipeline.
        :param str pipeline_run_id: Unique 24-hexadecimal character string that identifies a Data Lake Pipeline run.
        :param str snapshot_id: Unique 24-hexadecimal character string that identifies the snapshot of a cluster.
        :param str state: State of the pipeline run.
        :param Sequence['GetDataLakePipelineRunsResultStatArgs'] stats: Runtime statistics for this Data Lake Pipeline run.
        """
        pulumi.set(__self__, "backup_frequency_type", backup_frequency_type)
        pulumi.set(__self__, "created_date", created_date)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_updated_date", last_updated_date)
        pulumi.set(__self__, "phase", phase)
        pulumi.set(__self__, "pipeline_id", pipeline_id)
        pulumi.set(__self__, "pipeline_run_id", pipeline_run_id)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "stats", stats)

    @property
    @pulumi.getter(name="backupFrequencyType")
    def backup_frequency_type(self) -> str:
        """
        Backup schedule interval of the Data Lake Pipeline.
        """
        return pulumi.get(self, "backup_frequency_type")

    @property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> str:
        """
        Timestamp that indicates when the pipeline run was created.
        """
        return pulumi.get(self, "created_date")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique 24-hexadecimal character string that identifies a Data Lake Pipeline run.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastUpdatedDate")
    def last_updated_date(self) -> str:
        """
        Unique 24-hexadecimal character string that identifies a Data Lake Pipeline run.
        """
        return pulumi.get(self, "last_updated_date")

    @property
    @pulumi.getter
    def phase(self) -> str:
        """
        Processing phase of the Data Lake Pipeline.
        """
        return pulumi.get(self, "phase")

    @property
    @pulumi.getter(name="pipelineId")
    def pipeline_id(self) -> str:
        """
        Unique 24-hexadecimal character string that identifies a Data Lake Pipeline.
        """
        return pulumi.get(self, "pipeline_id")

    @property
    @pulumi.getter(name="pipelineRunId")
    def pipeline_run_id(self) -> str:
        """
        Unique 24-hexadecimal character string that identifies a Data Lake Pipeline run.
        """
        return pulumi.get(self, "pipeline_run_id")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> str:
        """
        Unique 24-hexadecimal character string that identifies the snapshot of a cluster.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        State of the pipeline run.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def stats(self) -> Sequence['outputs.GetDataLakePipelineRunsResultStatResult']:
        """
        Runtime statistics for this Data Lake Pipeline run.
        """
        return pulumi.get(self, "stats")


@pulumi.output_type
class GetDataLakePipelineRunsResultStatResult(dict):
    def __init__(__self__, *,
                 bytes_exported: int,
                 num_docs: int):
        """
        :param int bytes_exported: Total data size in bytes exported for this pipeline run.
        :param int num_docs: Number of docs ingested for a this pipeline run.
        """
        pulumi.set(__self__, "bytes_exported", bytes_exported)
        pulumi.set(__self__, "num_docs", num_docs)

    @property
    @pulumi.getter(name="bytesExported")
    def bytes_exported(self) -> int:
        """
        Total data size in bytes exported for this pipeline run.
        """
        return pulumi.get(self, "bytes_exported")

    @property
    @pulumi.getter(name="numDocs")
    def num_docs(self) -> int:
        """
        Number of docs ingested for a this pipeline run.
        """
        return pulumi.get(self, "num_docs")


@pulumi.output_type
class GetDataLakePipelineSinkResult(dict):
    def __init__(__self__, *,
                 partition_fields: Sequence['outputs.GetDataLakePipelineSinkPartitionFieldResult'],
                 provider: str,
                 region: str,
                 type: str):
        """
        :param Sequence['GetDataLakePipelineSinkPartitionFieldArgs'] partition_fields: Ordered fields used to physically organize data in the destination.
               * `partition_fields.#.field_name` - Human-readable label that identifies the field name used to partition data.
               * `partition_fields.#.order` - Sequence in which MongoDB Atlas slices the collection data to create partitions. The resource expresses this sequence starting with zero.
        :param str provider: Target cloud provider for this Data Lake Pipeline.
        :param str region: Target cloud provider region for this Data Lake Pipeline. [Supported cloud provider regions](https://www.mongodb.com/docs/datalake/limitations).
        :param str type: Type of ingestion source of this Data Lake Pipeline.
        """
        pulumi.set(__self__, "partition_fields", partition_fields)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="partitionFields")
    def partition_fields(self) -> Sequence['outputs.GetDataLakePipelineSinkPartitionFieldResult']:
        """
        Ordered fields used to physically organize data in the destination.
        * `partition_fields.#.field_name` - Human-readable label that identifies the field name used to partition data.
        * `partition_fields.#.order` - Sequence in which MongoDB Atlas slices the collection data to create partitions. The resource expresses this sequence starting with zero.
        """
        return pulumi.get(self, "partition_fields")

    @property
    @pulumi.getter
    def provider(self) -> str:
        """
        Target cloud provider for this Data Lake Pipeline.
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Target cloud provider region for this Data Lake Pipeline. [Supported cloud provider regions](https://www.mongodb.com/docs/datalake/limitations).
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDataLakePipelineSinkPartitionFieldResult(dict):
    def __init__(__self__, *,
                 field_name: str,
                 order: int):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def order(self) -> int:
        return pulumi.get(self, "order")


@pulumi.output_type
class GetDataLakePipelineSnapshotResult(dict):
    def __init__(__self__, *,
                 copy_region: str,
                 created_at: str,
                 expires_at: str,
                 frequency_yype: str,
                 id: str,
                 master_key: str,
                 mongod_version: str,
                 policies: Sequence[str],
                 provider: str,
                 replica_set_name: str,
                 size: int,
                 status: str,
                 type: str):
        """
        :param str id: Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.
        :param str provider: Target cloud provider for this Data Lake Pipeline.
        :param str type: Type of ingestion source of this Data Lake Pipeline.
        """
        pulumi.set(__self__, "copy_region", copy_region)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "frequency_yype", frequency_yype)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "master_key", master_key)
        pulumi.set(__self__, "mongod_version", mongod_version)
        pulumi.set(__self__, "policies", policies)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "replica_set_name", replica_set_name)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="copyRegion")
    def copy_region(self) -> str:
        return pulumi.get(self, "copy_region")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> str:
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter(name="frequencyYype")
    def frequency_yype(self) -> str:
        return pulumi.get(self, "frequency_yype")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="masterKey")
    def master_key(self) -> str:
        return pulumi.get(self, "master_key")

    @property
    @pulumi.getter(name="mongodVersion")
    def mongod_version(self) -> str:
        return pulumi.get(self, "mongod_version")

    @property
    @pulumi.getter
    def policies(self) -> Sequence[str]:
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter
    def provider(self) -> str:
        """
        Target cloud provider for this Data Lake Pipeline.
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> str:
        return pulumi.get(self, "replica_set_name")

    @property
    @pulumi.getter
    def size(self) -> int:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDataLakePipelineSourceResult(dict):
    def __init__(__self__, *,
                 cluster_name: str,
                 collection_name: str,
                 database_name: str,
                 project_id: str,
                 type: str):
        """
        :param str cluster_name: Human-readable name that identifies the cluster.
        :param str collection_name: Human-readable name that identifies the collection.
        :param str database_name: Human-readable name that identifies the database.
        :param str project_id: The unique ID for the project to create a Data Lake Pipeline.
        :param str type: Type of ingestion source of this Data Lake Pipeline.
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        Human-readable name that identifies the cluster.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> str:
        """
        Human-readable name that identifies the collection.
        """
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Human-readable name that identifies the database.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project to create a Data Lake Pipeline.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDataLakePipelineTransformationResult(dict):
    def __init__(__self__, *,
                 field: str,
                 type: str):
        """
        :param str type: Type of ingestion source of this Data Lake Pipeline.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def field(self) -> str:
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDataLakePipelinesResultResult(dict):
    def __init__(__self__, *,
                 created_date: str,
                 id: str,
                 last_updated_date: str,
                 name: str,
                 project_id: str,
                 sinks: Sequence['outputs.GetDataLakePipelinesResultSinkResult'],
                 sources: Sequence['outputs.GetDataLakePipelinesResultSourceResult'],
                 state: str,
                 transformations: Sequence['outputs.GetDataLakePipelinesResultTransformationResult']):
        """
        :param str created_date: Timestamp that indicates when the Data Lake Pipeline was created.
        :param str id: Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.
        :param str last_updated_date: Timestamp that indicates the last time that the Data Lake Pipeline was updated.
        :param str project_id: The unique ID for the project to create a data lake pipeline.
        :param str state: State of this Data Lake Pipeline.
        :param Sequence['GetDataLakePipelinesResultTransformationArgs'] transformations: Fields to be excluded for this Data Lake Pipeline.
               * `transformations.#.field` - Key in the document.
               * `transformations.#.type` - Type of transformation applied during the export of the namespace in a Data Lake Pipeline.
        """
        pulumi.set(__self__, "created_date", created_date)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_updated_date", last_updated_date)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "sinks", sinks)
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "transformations", transformations)

    @property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> str:
        """
        Timestamp that indicates when the Data Lake Pipeline was created.
        """
        return pulumi.get(self, "created_date")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the Data Lake Pipeline.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="lastUpdatedDate")
    def last_updated_date(self) -> str:
        """
        Timestamp that indicates the last time that the Data Lake Pipeline was updated.
        """
        return pulumi.get(self, "last_updated_date")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project to create a data lake pipeline.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def sinks(self) -> Sequence['outputs.GetDataLakePipelinesResultSinkResult']:
        return pulumi.get(self, "sinks")

    @property
    @pulumi.getter
    def sources(self) -> Sequence['outputs.GetDataLakePipelinesResultSourceResult']:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        State of this Data Lake Pipeline.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def transformations(self) -> Sequence['outputs.GetDataLakePipelinesResultTransformationResult']:
        """
        Fields to be excluded for this Data Lake Pipeline.
        * `transformations.#.field` - Key in the document.
        * `transformations.#.type` - Type of transformation applied during the export of the namespace in a Data Lake Pipeline.
        """
        return pulumi.get(self, "transformations")


@pulumi.output_type
class GetDataLakePipelinesResultSinkResult(dict):
    def __init__(__self__, *,
                 partition_fields: Sequence['outputs.GetDataLakePipelinesResultSinkPartitionFieldResult'],
                 provider: str,
                 region: str,
                 type: str):
        """
        :param Sequence['GetDataLakePipelinesResultSinkPartitionFieldArgs'] partition_fields: Ordered fields used to physically organize data in the destination.
               * `partition_fields.#.field_name` - Human-readable label that identifies the field name used to partition data.
               * `partition_fields.#.order` - Sequence in which MongoDB Atlas slices the collection data to create partitions. The resource expresses this sequence starting with zero.
        :param str provider: Target cloud provider for this Data Lake Pipeline.
        :param str region: Target cloud provider region for this Data Lake Pipeline. [Supported cloud provider regions](https://www.mongodb.com/docs/datalake/limitations).
        :param str type: Type of ingestion source of this Data Lake Pipeline.
        """
        pulumi.set(__self__, "partition_fields", partition_fields)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="partitionFields")
    def partition_fields(self) -> Sequence['outputs.GetDataLakePipelinesResultSinkPartitionFieldResult']:
        """
        Ordered fields used to physically organize data in the destination.
        * `partition_fields.#.field_name` - Human-readable label that identifies the field name used to partition data.
        * `partition_fields.#.order` - Sequence in which MongoDB Atlas slices the collection data to create partitions. The resource expresses this sequence starting with zero.
        """
        return pulumi.get(self, "partition_fields")

    @property
    @pulumi.getter
    def provider(self) -> str:
        """
        Target cloud provider for this Data Lake Pipeline.
        """
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Target cloud provider region for this Data Lake Pipeline. [Supported cloud provider regions](https://www.mongodb.com/docs/datalake/limitations).
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDataLakePipelinesResultSinkPartitionFieldResult(dict):
    def __init__(__self__, *,
                 field_name: str,
                 order: int):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def order(self) -> int:
        return pulumi.get(self, "order")


@pulumi.output_type
class GetDataLakePipelinesResultSourceResult(dict):
    def __init__(__self__, *,
                 cluster_name: str,
                 collection_name: str,
                 database_name: str,
                 project_id: str,
                 type: str):
        """
        :param str cluster_name: Human-readable name that identifies the cluster.
        :param str collection_name: Human-readable name that identifies the collection.
        :param str database_name: Human-readable name that identifies the database.
        :param str project_id: The unique ID for the project to create a data lake pipeline.
        :param str type: Type of ingestion source of this Data Lake Pipeline.
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        Human-readable name that identifies the cluster.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> str:
        """
        Human-readable name that identifies the collection.
        """
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Human-readable name that identifies the database.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project to create a data lake pipeline.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDataLakePipelinesResultTransformationResult(dict):
    def __init__(__self__, *,
                 field: str,
                 type: str):
        """
        :param str type: Type of ingestion source of this Data Lake Pipeline.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def field(self) -> str:
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of ingestion source of this Data Lake Pipeline.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDatabaseUserLabelResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDatabaseUserRoleResult(dict):
    def __init__(__self__, *,
                 collection_name: str,
                 database_name: str,
                 role_name: str):
        """
        :param str collection_name: Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        :param str database_name: Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.
        """
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> str:
        """
        Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        """
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetDatabaseUserScopeResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str):
        """
        :param str name: Name of the role to grant.
        :param str type: Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the role to grant.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDatabaseUsersResultResult(dict):
    def __init__(__self__, *,
                 auth_database_name: str,
                 aws_iam_type: str,
                 id: str,
                 labels: Sequence['outputs.GetDatabaseUsersResultLabelResult'],
                 ldap_auth_type: str,
                 oidc_auth_type: str,
                 project_id: str,
                 roles: Sequence['outputs.GetDatabaseUsersResultRoleResult'],
                 scopes: Sequence['outputs.GetDatabaseUsersResultScopeResult'],
                 username: str,
                 x509_type: str):
        """
        :param str auth_database_name: (Required) Database against which Atlas authenticates the user. A user must provide both a username and authentication database to log into MongoDB.
               Possible values include:
        :param str aws_iam_type: The new database user authenticates with AWS IAM credentials. Default is `NONE`, `USER` means user has AWS IAM user credentials, `ROLE` - means user has credentials associated with an AWS IAM role.
        :param str id: Autogenerated Unique ID for this data source.
        :param str ldap_auth_type: Method by which the provided username is authenticated. Default is `NONE`. Other valid values are: `USER`, `GROUP`.
        :param str oidc_auth_type: (Optional) Human-readable label that indicates whether the new database user authenticates with OIDC (OpenID Connect) federated authentication. If no value is given, Atlas uses the default value of `NONE`. The accepted types are:
               * `NONE` -	The user does not use OIDC federated authentication.
               * `IDP_GROUP` - OIDC Workforce federated authentication group. To learn more about OIDC federated authentication, see [Set up Workforce Identity Federation with OIDC](https://www.mongodb.com/docs/atlas/security-oidc/).
               * `USER` - OIDC Workload federated authentication user. To learn more about OIDC federated authentication, see [Set up Workload Identity Federation with OIDC](https://www.mongodb.com/docs/atlas/security-oidc/).
        :param str project_id: The unique ID for the project to get all database users.
        :param Sequence['GetDatabaseUsersResultRoleArgs'] roles: List of user’s roles and the databases / collections on which the roles apply. A role allows the user to perform particular actions on the specified database. A role on the admin database can include privileges that apply to the other databases as well. See Roles below for more details.
        :param Sequence['GetDatabaseUsersResultScopeArgs'] scopes: Array of clusters and Atlas Data Lakes that this user has access to.
        :param str username: Username for authenticating to MongoDB.
        :param str x509_type: X.509 method by which the provided username is authenticated.
        """
        pulumi.set(__self__, "auth_database_name", auth_database_name)
        pulumi.set(__self__, "aws_iam_type", aws_iam_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "ldap_auth_type", ldap_auth_type)
        pulumi.set(__self__, "oidc_auth_type", oidc_auth_type)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "x509_type", x509_type)

    @property
    @pulumi.getter(name="authDatabaseName")
    def auth_database_name(self) -> str:
        """
        (Required) Database against which Atlas authenticates the user. A user must provide both a username and authentication database to log into MongoDB.
        Possible values include:
        """
        return pulumi.get(self, "auth_database_name")

    @property
    @pulumi.getter(name="awsIamType")
    def aws_iam_type(self) -> str:
        """
        The new database user authenticates with AWS IAM credentials. Default is `NONE`, `USER` means user has AWS IAM user credentials, `ROLE` - means user has credentials associated with an AWS IAM role.
        """
        return pulumi.get(self, "aws_iam_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Autogenerated Unique ID for this data source.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetDatabaseUsersResultLabelResult']:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="ldapAuthType")
    def ldap_auth_type(self) -> str:
        """
        Method by which the provided username is authenticated. Default is `NONE`. Other valid values are: `USER`, `GROUP`.
        """
        return pulumi.get(self, "ldap_auth_type")

    @property
    @pulumi.getter(name="oidcAuthType")
    def oidc_auth_type(self) -> str:
        """
        (Optional) Human-readable label that indicates whether the new database user authenticates with OIDC (OpenID Connect) federated authentication. If no value is given, Atlas uses the default value of `NONE`. The accepted types are:
        * `NONE` -	The user does not use OIDC federated authentication.
        * `IDP_GROUP` - OIDC Workforce federated authentication group. To learn more about OIDC federated authentication, see [Set up Workforce Identity Federation with OIDC](https://www.mongodb.com/docs/atlas/security-oidc/).
        * `USER` - OIDC Workload federated authentication user. To learn more about OIDC federated authentication, see [Set up Workload Identity Federation with OIDC](https://www.mongodb.com/docs/atlas/security-oidc/).
        """
        return pulumi.get(self, "oidc_auth_type")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project to get all database users.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def roles(self) -> Sequence['outputs.GetDatabaseUsersResultRoleResult']:
        """
        List of user’s roles and the databases / collections on which the roles apply. A role allows the user to perform particular actions on the specified database. A role on the admin database can include privileges that apply to the other databases as well. See Roles below for more details.
        """
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence['outputs.GetDatabaseUsersResultScopeResult']:
        """
        Array of clusters and Atlas Data Lakes that this user has access to.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username for authenticating to MongoDB.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="x509Type")
    def x509_type(self) -> str:
        """
        X.509 method by which the provided username is authenticated.
        """
        return pulumi.get(self, "x509_type")


@pulumi.output_type
class GetDatabaseUsersResultLabelResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDatabaseUsersResultRoleResult(dict):
    def __init__(__self__, *,
                 collection_name: str,
                 database_name: str,
                 role_name: str):
        """
        :param str collection_name: Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        :param str database_name: Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.
        """
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> str:
        """
        Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        """
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetDatabaseUsersResultScopeResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str):
        """
        :param str name: Name of the role to grant.
        :param str type: Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the role to grant.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetEncryptionAtRestAwsKmsConfigResult(dict):
    def __init__(__self__, *,
                 access_key_id: str,
                 customer_master_key_id: str,
                 enabled: bool,
                 region: str,
                 role_id: str,
                 secret_access_key: str,
                 valid: bool):
        """
        :param str access_key_id: Unique alphanumeric string that identifies an Identity and Access Management (IAM) access key with permissions required to access your Amazon Web Services (AWS) Customer Master Key (CMK).
        :param str customer_master_key_id: Unique alphanumeric string that identifies the Amazon Web Services (AWS) Customer Master Key (CMK) you used to encrypt and decrypt the MongoDB master keys.
        :param bool enabled: Flag that indicates whether someone enabled encryption at rest for the specified project through Amazon Web Services (AWS) Key Management Service (KMS). To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        :param str region: Physical location where MongoDB Atlas deploys your AWS-hosted MongoDB cluster nodes. The region you choose can affect network latency for clients accessing your databases. When MongoDB Atlas deploys a dedicated cluster, it checks if a VPC or VPC connection exists for that provider and region. If not, MongoDB Atlas creates them as part of the deployment. MongoDB Atlas assigns the VPC a CIDR block. To limit a new VPC peering connection to one CIDR block and region, create the connection first. Deploy the cluster after the connection starts.
        :param str role_id: Unique 24-hexadecimal digit string that identifies an Amazon Web Services (AWS) Identity and Access Management (IAM) role. This IAM role has the permissions required to manage your AWS customer master key.
        :param str secret_access_key: Human-readable label of the Identity and Access Management (IAM) secret access key with permissions required to access your Amazon Web Services (AWS) customer master key.
        :param bool valid: Flag that indicates whether the Amazon Web Services (AWS) Key Management Service (KMS) encryption key can encrypt and decrypt data.
        """
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "customer_master_key_id", customer_master_key_id)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "secret_access_key", secret_access_key)
        pulumi.set(__self__, "valid", valid)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> str:
        """
        Unique alphanumeric string that identifies an Identity and Access Management (IAM) access key with permissions required to access your Amazon Web Services (AWS) Customer Master Key (CMK).
        """
        return pulumi.get(self, "access_key_id")

    @property
    @pulumi.getter(name="customerMasterKeyId")
    def customer_master_key_id(self) -> str:
        """
        Unique alphanumeric string that identifies the Amazon Web Services (AWS) Customer Master Key (CMK) you used to encrypt and decrypt the MongoDB master keys.
        """
        return pulumi.get(self, "customer_master_key_id")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Flag that indicates whether someone enabled encryption at rest for the specified project through Amazon Web Services (AWS) Key Management Service (KMS). To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Physical location where MongoDB Atlas deploys your AWS-hosted MongoDB cluster nodes. The region you choose can affect network latency for clients accessing your databases. When MongoDB Atlas deploys a dedicated cluster, it checks if a VPC or VPC connection exists for that provider and region. If not, MongoDB Atlas creates them as part of the deployment. MongoDB Atlas assigns the VPC a CIDR block. To limit a new VPC peering connection to one CIDR block and region, create the connection first. Deploy the cluster after the connection starts.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies an Amazon Web Services (AWS) Identity and Access Management (IAM) role. This IAM role has the permissions required to manage your AWS customer master key.
        """
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> str:
        """
        Human-readable label of the Identity and Access Management (IAM) secret access key with permissions required to access your Amazon Web Services (AWS) customer master key.
        """
        return pulumi.get(self, "secret_access_key")

    @property
    @pulumi.getter
    def valid(self) -> bool:
        """
        Flag that indicates whether the Amazon Web Services (AWS) Key Management Service (KMS) encryption key can encrypt and decrypt data.
        """
        return pulumi.get(self, "valid")


@pulumi.output_type
class GetEncryptionAtRestAzureKeyVaultConfigResult(dict):
    def __init__(__self__, *,
                 azure_environment: str,
                 client_id: str,
                 enabled: bool,
                 key_identifier: str,
                 key_vault_name: str,
                 require_private_networking: bool,
                 resource_group_name: str,
                 secret: str,
                 subscription_id: str,
                 tenant_id: str,
                 valid: bool):
        """
        :param str azure_environment: Azure environment in which your account credentials reside.
        :param str client_id: Unique 36-hexadecimal character string that identifies an Azure application associated with your Azure Active Directory tenant.
        :param bool enabled: Flag that indicates whether someone enabled encryption at rest for the specified  project. To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        :param str key_identifier: Web address with a unique key that identifies for your Azure Key Vault.
        :param str key_vault_name: Unique string that identifies the Azure Key Vault that contains your key.
        :param bool require_private_networking: Enable connection to your Azure Key Vault over private networking.
        :param str resource_group_name: Name of the Azure resource group that contains your Azure Key Vault.
        :param str secret: Private data that you need secured and that belongs to the specified Azure Key Vault (AKV) tenant (**azureKeyVault.tenantID**). This data can include any type of sensitive data such as passwords, database connection strings, API keys, and the like. AKV stores this information as encrypted binary data.
        :param str subscription_id: Unique 36-hexadecimal character string that identifies your Azure subscription.
        :param str tenant_id: Unique 36-hexadecimal character string that identifies the Azure Active Directory tenant within your Azure subscription.
        :param bool valid: Flag that indicates whether the Azure encryption key can encrypt and decrypt data.
        """
        pulumi.set(__self__, "azure_environment", azure_environment)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "key_identifier", key_identifier)
        pulumi.set(__self__, "key_vault_name", key_vault_name)
        pulumi.set(__self__, "require_private_networking", require_private_networking)
        pulumi.set(__self__, "resource_group_name", resource_group_name)
        pulumi.set(__self__, "secret", secret)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "valid", valid)

    @property
    @pulumi.getter(name="azureEnvironment")
    def azure_environment(self) -> str:
        """
        Azure environment in which your account credentials reside.
        """
        return pulumi.get(self, "azure_environment")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Unique 36-hexadecimal character string that identifies an Azure application associated with your Azure Active Directory tenant.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Flag that indicates whether someone enabled encryption at rest for the specified  project. To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="keyIdentifier")
    def key_identifier(self) -> str:
        """
        Web address with a unique key that identifies for your Azure Key Vault.
        """
        return pulumi.get(self, "key_identifier")

    @property
    @pulumi.getter(name="keyVaultName")
    def key_vault_name(self) -> str:
        """
        Unique string that identifies the Azure Key Vault that contains your key.
        """
        return pulumi.get(self, "key_vault_name")

    @property
    @pulumi.getter(name="requirePrivateNetworking")
    def require_private_networking(self) -> bool:
        """
        Enable connection to your Azure Key Vault over private networking.
        """
        return pulumi.get(self, "require_private_networking")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> str:
        """
        Name of the Azure resource group that contains your Azure Key Vault.
        """
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        Private data that you need secured and that belongs to the specified Azure Key Vault (AKV) tenant (**azureKeyVault.tenantID**). This data can include any type of sensitive data such as passwords, database connection strings, API keys, and the like. AKV stores this information as encrypted binary data.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> str:
        """
        Unique 36-hexadecimal character string that identifies your Azure subscription.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        Unique 36-hexadecimal character string that identifies the Azure Active Directory tenant within your Azure subscription.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def valid(self) -> bool:
        """
        Flag that indicates whether the Azure encryption key can encrypt and decrypt data.
        """
        return pulumi.get(self, "valid")


@pulumi.output_type
class GetEncryptionAtRestGoogleCloudKmsConfigResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 key_version_resource_id: str,
                 service_account_key: str,
                 valid: bool):
        """
        :param bool enabled: Flag that indicates whether someone enabled encryption at rest for the specified  project. To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        :param str key_version_resource_id: Resource path that displays the key version resource ID for your Google Cloud KMS.
        :param str service_account_key: JavaScript Object Notation (JSON) object that contains the Google Cloud Key Management Service (KMS). Format the JSON as a string and not as an object.
        :param bool valid: Flag that indicates whether the Google Cloud Key Management Service (KMS) encryption key can encrypt and decrypt data.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "key_version_resource_id", key_version_resource_id)
        pulumi.set(__self__, "service_account_key", service_account_key)
        pulumi.set(__self__, "valid", valid)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Flag that indicates whether someone enabled encryption at rest for the specified  project. To disable encryption at rest using customer key management and remove the configuration details, pass only this parameter with a value of `false`.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="keyVersionResourceId")
    def key_version_resource_id(self) -> str:
        """
        Resource path that displays the key version resource ID for your Google Cloud KMS.
        """
        return pulumi.get(self, "key_version_resource_id")

    @property
    @pulumi.getter(name="serviceAccountKey")
    def service_account_key(self) -> str:
        """
        JavaScript Object Notation (JSON) object that contains the Google Cloud Key Management Service (KMS). Format the JSON as a string and not as an object.
        """
        return pulumi.get(self, "service_account_key")

    @property
    @pulumi.getter
    def valid(self) -> bool:
        """
        Flag that indicates whether the Google Cloud Key Management Service (KMS) encryption key can encrypt and decrypt data.
        """
        return pulumi.get(self, "valid")


@pulumi.output_type
class GetEncryptionAtRestPrivateEndpointsResultResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 error_message: str,
                 id: str,
                 private_endpoint_connection_name: str,
                 project_id: str,
                 region_name: str,
                 status: str):
        """
        :param str cloud_provider: Label that identifies the cloud provider of the private endpoint.
        :param str error_message: Error message for failures associated with the Encryption At Rest private endpoint.
        :param str id: Unique 24-hexadecimal digit string that identifies the Private Endpoint Service.
        :param str private_endpoint_connection_name: Connection name of the Azure Private Endpoint.
        :param str project_id: Unique 24-hexadecimal digit string that identifies your project.
        :param str region_name: Cloud provider region in which the Encryption At Rest private endpoint is located.
        :param str status: State of the Encryption At Rest private endpoint.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "error_message", error_message)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "private_endpoint_connection_name", private_endpoint_connection_name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "region_name", region_name)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        Label that identifies the cloud provider of the private endpoint.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> str:
        """
        Error message for failures associated with the Encryption At Rest private endpoint.
        """
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the Private Endpoint Service.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="privateEndpointConnectionName")
    def private_endpoint_connection_name(self) -> str:
        """
        Connection name of the Azure Private Endpoint.
        """
        return pulumi.get(self, "private_endpoint_connection_name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies your project.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        Cloud provider region in which the Encryption At Rest private endpoint is located.
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        State of the Encryption At Rest private endpoint.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetEventTriggerEventProcessorResult(dict):
    def __init__(__self__, *,
                 aws_eventbridges: Sequence['outputs.GetEventTriggerEventProcessorAwsEventbridgeResult']):
        pulumi.set(__self__, "aws_eventbridges", aws_eventbridges)

    @property
    @pulumi.getter(name="awsEventbridges")
    def aws_eventbridges(self) -> Sequence['outputs.GetEventTriggerEventProcessorAwsEventbridgeResult']:
        return pulumi.get(self, "aws_eventbridges")


@pulumi.output_type
class GetEventTriggerEventProcessorAwsEventbridgeResult(dict):
    def __init__(__self__, *,
                 config_account_id: str,
                 config_region: str):
        """
        :param str config_account_id: AWS Account ID.
        :param str config_region: Region of AWS Account.
        """
        pulumi.set(__self__, "config_account_id", config_account_id)
        pulumi.set(__self__, "config_region", config_region)

    @property
    @pulumi.getter(name="configAccountId")
    def config_account_id(self) -> str:
        """
        AWS Account ID.
        """
        return pulumi.get(self, "config_account_id")

    @property
    @pulumi.getter(name="configRegion")
    def config_region(self) -> str:
        """
        Region of AWS Account.
        """
        return pulumi.get(self, "config_region")


@pulumi.output_type
class GetEventTriggersResultResult(dict):
    def __init__(__self__, *,
                 config_collection: str,
                 config_database: str,
                 config_full_document: bool,
                 config_full_document_before: bool,
                 config_match: str,
                 config_operation_type: str,
                 config_operation_types: Sequence[str],
                 config_project: str,
                 config_providers: Sequence[str],
                 config_schedule: str,
                 config_schedule_type: str,
                 config_service_id: str,
                 disabled: bool,
                 event_processors: Sequence['outputs.GetEventTriggersResultEventProcessorResult'],
                 function_id: str,
                 function_name: str,
                 name: str,
                 trigger_id: str,
                 type: str,
                 unordered: bool):
        """
        :param str config_collection: The name of the MongoDB collection that the trigger watches for change events.
        :param str config_database: The name of the MongoDB database to watch.
        :param bool config_full_document: If true, indicates that `UPDATE` change events should include the most current [majority-committed](https://docs.mongodb.com/manual/reference/read-concern-majority/) version of the modified document in the fullDocument field.
        :param str config_match: A [$match](https://docs.mongodb.com/manual/reference/operator/aggregation/match/) expression document that MongoDB Realm includes in the underlying change stream pipeline for the trigger.
        :param str config_operation_type: The [authentication operation type](https://docs.mongodb.com/realm/triggers/authentication-triggers/#std-label-authentication-event-operation-types) to listen for.
        :param Sequence[str] config_operation_types: The [database event operation types](https://docs.mongodb.com/realm/triggers/database-triggers/#std-label-database-events) to listen for.
        :param str config_project: A [$project](https://docs.mongodb.com/manual/reference/operator/aggregation/project/) expression document that Realm uses to filter the fields that appear in change event objects.
        :param Sequence[str] config_providers: A list of one or more [authentication provider](https://docs.mongodb.com/realm/authentication/providers/) id values. The trigger will only listen for authentication events produced by these providers.
        :param str config_schedule: A [cron expression](https://docs.mongodb.com/realm/triggers/cron-expressions/) that defines the trigger schedule.
        :param str config_service_id: The ID of the MongoDB Service associated with the trigger.
        :param bool disabled: Status of a trigger.
        :param Sequence['GetEventTriggersResultEventProcessorArgs'] event_processors: An object where each field name is an event processor ID and each value is an object that configures its corresponding event processor.
        :param str function_id: The ID of the function associated with the trigger.
        :param str function_name: The name of the function associated with the trigger.
        :param str name: The name of the trigger.
        :param str type: The type of the trigger. Possible Values: `DATABASE`, `AUTHENTICATION`
        :param bool unordered: Sort order for `DATABASE` type.
        """
        pulumi.set(__self__, "config_collection", config_collection)
        pulumi.set(__self__, "config_database", config_database)
        pulumi.set(__self__, "config_full_document", config_full_document)
        pulumi.set(__self__, "config_full_document_before", config_full_document_before)
        pulumi.set(__self__, "config_match", config_match)
        pulumi.set(__self__, "config_operation_type", config_operation_type)
        pulumi.set(__self__, "config_operation_types", config_operation_types)
        pulumi.set(__self__, "config_project", config_project)
        pulumi.set(__self__, "config_providers", config_providers)
        pulumi.set(__self__, "config_schedule", config_schedule)
        pulumi.set(__self__, "config_schedule_type", config_schedule_type)
        pulumi.set(__self__, "config_service_id", config_service_id)
        pulumi.set(__self__, "disabled", disabled)
        pulumi.set(__self__, "event_processors", event_processors)
        pulumi.set(__self__, "function_id", function_id)
        pulumi.set(__self__, "function_name", function_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "trigger_id", trigger_id)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "unordered", unordered)

    @property
    @pulumi.getter(name="configCollection")
    def config_collection(self) -> str:
        """
        The name of the MongoDB collection that the trigger watches for change events.
        """
        return pulumi.get(self, "config_collection")

    @property
    @pulumi.getter(name="configDatabase")
    def config_database(self) -> str:
        """
        The name of the MongoDB database to watch.
        """
        return pulumi.get(self, "config_database")

    @property
    @pulumi.getter(name="configFullDocument")
    def config_full_document(self) -> bool:
        """
        If true, indicates that `UPDATE` change events should include the most current [majority-committed](https://docs.mongodb.com/manual/reference/read-concern-majority/) version of the modified document in the fullDocument field.
        """
        return pulumi.get(self, "config_full_document")

    @property
    @pulumi.getter(name="configFullDocumentBefore")
    def config_full_document_before(self) -> bool:
        return pulumi.get(self, "config_full_document_before")

    @property
    @pulumi.getter(name="configMatch")
    def config_match(self) -> str:
        """
        A [$match](https://docs.mongodb.com/manual/reference/operator/aggregation/match/) expression document that MongoDB Realm includes in the underlying change stream pipeline for the trigger.
        """
        return pulumi.get(self, "config_match")

    @property
    @pulumi.getter(name="configOperationType")
    def config_operation_type(self) -> str:
        """
        The [authentication operation type](https://docs.mongodb.com/realm/triggers/authentication-triggers/#std-label-authentication-event-operation-types) to listen for.
        """
        return pulumi.get(self, "config_operation_type")

    @property
    @pulumi.getter(name="configOperationTypes")
    def config_operation_types(self) -> Sequence[str]:
        """
        The [database event operation types](https://docs.mongodb.com/realm/triggers/database-triggers/#std-label-database-events) to listen for.
        """
        return pulumi.get(self, "config_operation_types")

    @property
    @pulumi.getter(name="configProject")
    def config_project(self) -> str:
        """
        A [$project](https://docs.mongodb.com/manual/reference/operator/aggregation/project/) expression document that Realm uses to filter the fields that appear in change event objects.
        """
        return pulumi.get(self, "config_project")

    @property
    @pulumi.getter(name="configProviders")
    def config_providers(self) -> Sequence[str]:
        """
        A list of one or more [authentication provider](https://docs.mongodb.com/realm/authentication/providers/) id values. The trigger will only listen for authentication events produced by these providers.
        """
        return pulumi.get(self, "config_providers")

    @property
    @pulumi.getter(name="configSchedule")
    def config_schedule(self) -> str:
        """
        A [cron expression](https://docs.mongodb.com/realm/triggers/cron-expressions/) that defines the trigger schedule.
        """
        return pulumi.get(self, "config_schedule")

    @property
    @pulumi.getter(name="configScheduleType")
    def config_schedule_type(self) -> str:
        return pulumi.get(self, "config_schedule_type")

    @property
    @pulumi.getter(name="configServiceId")
    def config_service_id(self) -> str:
        """
        The ID of the MongoDB Service associated with the trigger.
        """
        return pulumi.get(self, "config_service_id")

    @property
    @pulumi.getter
    def disabled(self) -> bool:
        """
        Status of a trigger.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="eventProcessors")
    def event_processors(self) -> Sequence['outputs.GetEventTriggersResultEventProcessorResult']:
        """
        An object where each field name is an event processor ID and each value is an object that configures its corresponding event processor.
        """
        return pulumi.get(self, "event_processors")

    @property
    @pulumi.getter(name="functionId")
    def function_id(self) -> str:
        """
        The ID of the function associated with the trigger.
        """
        return pulumi.get(self, "function_id")

    @property
    @pulumi.getter(name="functionName")
    def function_name(self) -> str:
        """
        The name of the function associated with the trigger.
        """
        return pulumi.get(self, "function_name")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the trigger.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="triggerId")
    def trigger_id(self) -> str:
        return pulumi.get(self, "trigger_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the trigger. Possible Values: `DATABASE`, `AUTHENTICATION`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unordered(self) -> bool:
        """
        Sort order for `DATABASE` type.
        """
        return pulumi.get(self, "unordered")


@pulumi.output_type
class GetEventTriggersResultEventProcessorResult(dict):
    def __init__(__self__, *,
                 aws_eventbridges: Sequence['outputs.GetEventTriggersResultEventProcessorAwsEventbridgeResult']):
        pulumi.set(__self__, "aws_eventbridges", aws_eventbridges)

    @property
    @pulumi.getter(name="awsEventbridges")
    def aws_eventbridges(self) -> Sequence['outputs.GetEventTriggersResultEventProcessorAwsEventbridgeResult']:
        return pulumi.get(self, "aws_eventbridges")


@pulumi.output_type
class GetEventTriggersResultEventProcessorAwsEventbridgeResult(dict):
    def __init__(__self__, *,
                 config_account_id: str,
                 config_region: str):
        """
        :param str config_account_id: AWS Account ID.
        :param str config_region: Region of AWS Account.
        """
        pulumi.set(__self__, "config_account_id", config_account_id)
        pulumi.set(__self__, "config_region", config_region)

    @property
    @pulumi.getter(name="configAccountId")
    def config_account_id(self) -> str:
        """
        AWS Account ID.
        """
        return pulumi.get(self, "config_account_id")

    @property
    @pulumi.getter(name="configRegion")
    def config_region(self) -> str:
        """
        Region of AWS Account.
        """
        return pulumi.get(self, "config_region")


@pulumi.output_type
class GetFederatedDatabaseInstanceCloudProviderConfigResult(dict):
    def __init__(__self__, *,
                 aws: 'outputs.GetFederatedDatabaseInstanceCloudProviderConfigAwsResult'):
        pulumi.set(__self__, "aws", aws)

    @property
    @pulumi.getter
    def aws(self) -> 'outputs.GetFederatedDatabaseInstanceCloudProviderConfigAwsResult':
        return pulumi.get(self, "aws")


@pulumi.output_type
class GetFederatedDatabaseInstanceCloudProviderConfigAwsResult(dict):
    def __init__(__self__, *,
                 external_id: str,
                 iam_assumed_role_arn: str,
                 iam_user_arn: str,
                 role_id: str,
                 test_s3_bucket: str):
        """
        :param str external_id: Unique identifier associated with the IAM Role that the Federated Database Instance assumes when accessing the data stores.
        :param str iam_assumed_role_arn: Amazon Resource Name (ARN) of the IAM Role that the Federated Database Instance assumes when accessing S3 Bucket data stores. The IAM Role must support the following actions against each S3 bucket:
               * `s3:GetObject`
               * `s3:ListBucket`
               * `s3:GetObjectVersion`
        :param str iam_user_arn: Amazon Resource Name (ARN) of the user that the Federated Database Instance assumes when accessing S3 Bucket data stores.
        :param str role_id: Unique identifier of the role that the data lake can use to access the data stores.
        """
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "iam_assumed_role_arn", iam_assumed_role_arn)
        pulumi.set(__self__, "iam_user_arn", iam_user_arn)
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "test_s3_bucket", test_s3_bucket)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> str:
        """
        Unique identifier associated with the IAM Role that the Federated Database Instance assumes when accessing the data stores.
        """
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="iamAssumedRoleArn")
    def iam_assumed_role_arn(self) -> str:
        """
        Amazon Resource Name (ARN) of the IAM Role that the Federated Database Instance assumes when accessing S3 Bucket data stores. The IAM Role must support the following actions against each S3 bucket:
        * `s3:GetObject`
        * `s3:ListBucket`
        * `s3:GetObjectVersion`
        """
        return pulumi.get(self, "iam_assumed_role_arn")

    @property
    @pulumi.getter(name="iamUserArn")
    def iam_user_arn(self) -> str:
        """
        Amazon Resource Name (ARN) of the user that the Federated Database Instance assumes when accessing S3 Bucket data stores.
        """
        return pulumi.get(self, "iam_user_arn")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> str:
        """
        Unique identifier of the role that the data lake can use to access the data stores.
        """
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="testS3Bucket")
    def test_s3_bucket(self) -> str:
        return pulumi.get(self, "test_s3_bucket")


@pulumi.output_type
class GetFederatedDatabaseInstanceDataProcessRegionResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 region: str):
        """
        :param str cloud_provider: Name of the cloud service provider. Atlas Federated Database only supports AWS.
        :param str region: Name of the region to which the Federanted Instnace routes client connections for data processing.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        Name of the cloud service provider. Atlas Federated Database only supports AWS.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Name of the region to which the Federanted Instnace routes client connections for data processing.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetFederatedDatabaseInstanceStorageDatabaseResult(dict):
    def __init__(__self__, *,
                 collections: Sequence['outputs.GetFederatedDatabaseInstanceStorageDatabaseCollectionResult'],
                 max_wildcard_collections: int,
                 name: str,
                 views: Sequence['outputs.GetFederatedDatabaseInstanceStorageDatabaseViewResult']):
        """
        :param str name: Name of the Atlas Federated Database Instance.
        """
        pulumi.set(__self__, "collections", collections)
        pulumi.set(__self__, "max_wildcard_collections", max_wildcard_collections)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "views", views)

    @property
    @pulumi.getter
    def collections(self) -> Sequence['outputs.GetFederatedDatabaseInstanceStorageDatabaseCollectionResult']:
        return pulumi.get(self, "collections")

    @property
    @pulumi.getter(name="maxWildcardCollections")
    def max_wildcard_collections(self) -> int:
        return pulumi.get(self, "max_wildcard_collections")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def views(self) -> Sequence['outputs.GetFederatedDatabaseInstanceStorageDatabaseViewResult']:
        return pulumi.get(self, "views")


@pulumi.output_type
class GetFederatedDatabaseInstanceStorageDatabaseCollectionResult(dict):
    def __init__(__self__, *,
                 data_sources: Sequence['outputs.GetFederatedDatabaseInstanceStorageDatabaseCollectionDataSourceResult'],
                 name: str):
        """
        :param str name: Name of the Atlas Federated Database Instance.
        """
        pulumi.set(__self__, "data_sources", data_sources)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Sequence['outputs.GetFederatedDatabaseInstanceStorageDatabaseCollectionDataSourceResult']:
        return pulumi.get(self, "data_sources")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetFederatedDatabaseInstanceStorageDatabaseCollectionDataSourceResult(dict):
    def __init__(__self__, *,
                 allow_insecure: bool,
                 collection: str,
                 collection_regex: str,
                 database: str,
                 database_regex: str,
                 dataset_name: str,
                 default_format: str,
                 path: str,
                 provenance_field_name: str,
                 store_name: str,
                 urls: Sequence[str]):
        pulumi.set(__self__, "allow_insecure", allow_insecure)
        pulumi.set(__self__, "collection", collection)
        pulumi.set(__self__, "collection_regex", collection_regex)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "database_regex", database_regex)
        pulumi.set(__self__, "dataset_name", dataset_name)
        pulumi.set(__self__, "default_format", default_format)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "provenance_field_name", provenance_field_name)
        pulumi.set(__self__, "store_name", store_name)
        pulumi.set(__self__, "urls", urls)

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> bool:
        return pulumi.get(self, "allow_insecure")

    @property
    @pulumi.getter
    def collection(self) -> str:
        return pulumi.get(self, "collection")

    @property
    @pulumi.getter(name="collectionRegex")
    def collection_regex(self) -> str:
        return pulumi.get(self, "collection_regex")

    @property
    @pulumi.getter
    def database(self) -> str:
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="databaseRegex")
    def database_regex(self) -> str:
        return pulumi.get(self, "database_regex")

    @property
    @pulumi.getter(name="datasetName")
    def dataset_name(self) -> str:
        return pulumi.get(self, "dataset_name")

    @property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> str:
        return pulumi.get(self, "default_format")

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="provenanceFieldName")
    def provenance_field_name(self) -> str:
        return pulumi.get(self, "provenance_field_name")

    @property
    @pulumi.getter(name="storeName")
    def store_name(self) -> str:
        return pulumi.get(self, "store_name")

    @property
    @pulumi.getter
    def urls(self) -> Sequence[str]:
        return pulumi.get(self, "urls")


@pulumi.output_type
class GetFederatedDatabaseInstanceStorageDatabaseViewResult(dict):
    def __init__(__self__, *,
                 name: str,
                 pipeline: str,
                 source: str):
        """
        :param str name: Name of the Atlas Federated Database Instance.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pipeline", pipeline)
        pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def pipeline(self) -> str:
        return pulumi.get(self, "pipeline")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")


@pulumi.output_type
class GetFederatedDatabaseInstanceStorageStoreResult(dict):
    def __init__(__self__, *,
                 additional_storage_classes: Sequence[str],
                 allow_insecure: bool,
                 bucket: str,
                 cluster_name: str,
                 default_format: str,
                 delimiter: str,
                 include_tags: bool,
                 name: str,
                 prefix: str,
                 project_id: str,
                 provider: str,
                 public: str,
                 read_preferences: Sequence['outputs.GetFederatedDatabaseInstanceStorageStoreReadPreferenceResult'],
                 region: str,
                 urls: Sequence[str]):
        """
        :param str name: Name of the Atlas Federated Database Instance.
        :param str project_id: The unique ID for the project to create a Federated Database Instance.
        :param str region: Name of the region to which the Federanted Instnace routes client connections for data processing.
        """
        pulumi.set(__self__, "additional_storage_classes", additional_storage_classes)
        pulumi.set(__self__, "allow_insecure", allow_insecure)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "default_format", default_format)
        pulumi.set(__self__, "delimiter", delimiter)
        pulumi.set(__self__, "include_tags", include_tags)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "public", public)
        pulumi.set(__self__, "read_preferences", read_preferences)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "urls", urls)

    @property
    @pulumi.getter(name="additionalStorageClasses")
    def additional_storage_classes(self) -> Sequence[str]:
        return pulumi.get(self, "additional_storage_classes")

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> bool:
        return pulumi.get(self, "allow_insecure")

    @property
    @pulumi.getter
    def bucket(self) -> str:
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> str:
        return pulumi.get(self, "default_format")

    @property
    @pulumi.getter
    def delimiter(self) -> str:
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="includeTags")
    def include_tags(self) -> bool:
        return pulumi.get(self, "include_tags")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project to create a Federated Database Instance.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def provider(self) -> str:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def public(self) -> str:
        return pulumi.get(self, "public")

    @property
    @pulumi.getter(name="readPreferences")
    def read_preferences(self) -> Sequence['outputs.GetFederatedDatabaseInstanceStorageStoreReadPreferenceResult']:
        return pulumi.get(self, "read_preferences")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Name of the region to which the Federanted Instnace routes client connections for data processing.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def urls(self) -> Sequence[str]:
        return pulumi.get(self, "urls")


@pulumi.output_type
class GetFederatedDatabaseInstanceStorageStoreReadPreferenceResult(dict):
    def __init__(__self__, *,
                 max_staleness_seconds: int,
                 mode: str,
                 tag_sets: Sequence['outputs.GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetResult']):
        pulumi.set(__self__, "max_staleness_seconds", max_staleness_seconds)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "tag_sets", tag_sets)

    @property
    @pulumi.getter(name="maxStalenessSeconds")
    def max_staleness_seconds(self) -> int:
        return pulumi.get(self, "max_staleness_seconds")

    @property
    @pulumi.getter
    def mode(self) -> str:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="tagSets")
    def tag_sets(self) -> Sequence['outputs.GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetResult']:
        return pulumi.get(self, "tag_sets")


@pulumi.output_type
class GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetResult(dict):
    def __init__(__self__, *,
                 tags: Sequence['outputs.GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTagResult']):
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTagResult']:
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetFederatedDatabaseInstanceStorageStoreReadPreferenceTagSetTagResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the Atlas Federated Database Instance.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultResult(dict):
    def __init__(__self__, *,
                 cloud_provider_config: 'outputs.GetFederatedDatabaseInstancesResultCloudProviderConfigResult',
                 data_process_regions: Sequence['outputs.GetFederatedDatabaseInstancesResultDataProcessRegionResult'],
                 hostnames: Sequence[str],
                 name: str,
                 project_id: str,
                 state: str,
                 storage_databases: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageDatabaseResult'],
                 storage_stores: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageStoreResult']):
        """
        :param Sequence[str] hostnames: The list of hostnames assigned to the Federated Database Instance. Each string in the array is a hostname assigned to the Federated Database Instance.
        :param str project_id: The unique ID for the project to create a Federated Database Instance.
        :param str state: Current state of the Federated Database Instance:
               * `ACTIVE` - The Federated Database Instance is active and verified. You can query the data stores associated with the Federated Database Instance.
               * `DELETED` - The Federated Database Instance was deleted.
        :param Sequence['GetFederatedDatabaseInstancesResultStorageDatabaseArgs'] storage_databases: Configuration details for mapping each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [databases](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-databases-reference). An empty object indicates that the Federated Database Instance has no mapping configuration for any data store.
               * `storage_databases.#.name` - Name of the database to which the Federated Database Instance maps the data contained in the data store.
               * `storage_databases.#.collections` -     Array of objects where each object represents a collection and data sources that map to a [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#mongodb-datalakeconf-datalakeconf.stores) data store.
               * `storage_databases.#.collections.#.name` - Name of the collection.
               * `storage_databases.#.collections.#.data_sources` -     Array of objects where each object represents a stores data store to map with the collection.
               * `storage_databases.#.collections.#.data_sources.#.store_name` -     Name of a data store to map to the `<collection>`. Must match the name of an object in the stores array.
               * `storage_databases.#.collections.#.data_sources.#.dataset_name` -     Human-readable label that identifies the dataset that Atlas generates for an ingestion pipeline run or Online Archive.
               * `storage_databases.#.collections.#.data_sources.#.default_format` - Default format that Federated Database assumes if it encounters a file without an extension while searching the storeName.
               * `storage_databases.#.collections.#.data_sources.#.path` - File path that controls how MongoDB Cloud searches for and parses files in the storeName before mapping them to a collection. Specify / to capture all files and folders from the prefix path.
               * `storage_databases.#.collections.#.data_sources.#.database` - Human-readable label that identifies the database, which contains the collection in the cluster.
               * `storage_databases.#.collections.#.data_sources.#.allow_insecure` - Flag that validates the scheme in the specified URLs. If true, allows insecure HTTP scheme, doesn't verify the server's certificate chain and hostname, and accepts any certificate with any hostname presented by the server. If false, allows secure HTTPS scheme only.
               * `storage_databases.#.collections.#.data_sources.#.database_regex` - Regex pattern to use for creating the wildcard database.
               * `storage_databases.#.collections.#.data_sources.#.collection` - Human-readable label that identifies the collection in the database.
               * `storage_databases.#.collections.#.data_sources.#.collection_regex` - Regex pattern to use for creating the wildcard (*) collection.
               * `storage_databases.#.collections.#.data_sources.#.provenance_field_name` - Name for the field that includes the provenance of the documents in the results.
               * `storage_databases.#.collections.#.data_sources.#.storeName` - Human-readable label that identifies the data store that MongoDB Cloud maps to the collection.
               * `storage_databases.#.collections.#.data_sources.#.urls` - URLs of the publicly accessible data files. You can't specify URLs that require authentication.
               * `storage_databases.#.views` -     Array of objects where each object represents an [aggregation pipeline](https://docs.mongodb.com/manual/core/aggregation-pipeline/#id1) on a collection. To learn more about views, see [Views](https://docs.mongodb.com/manual/core/views/).
               * `storage_databases.#.views.#.name` - Name of the view.
               * `storage_databases.#.views.#.source` -  Name of the source collection for the view.
               * `storage_databases.#.views.#.pipeline`- Aggregation pipeline stage(s) to apply to the source collection.
        :param Sequence['GetFederatedDatabaseInstancesResultStorageStoreArgs'] storage_stores: Each object in the array represents a data store. Federated Database uses the storage.databases configuration details to map data in each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-stores-reference). An empty object indicates that the Federated Database Instance has no configured data stores.
               * `storage_stores.#.name` - Name of the data store.
               * `storage_stores.#.provider` - Defines where the data is stored.
               * `storage_stores.#.region` - Name of the AWS region in which the S3 bucket is hosted.
               * `storage_stores.#.bucket` - Name of the AWS S3 bucket.
               * `storage_stores.#.prefix` - Prefix the Federated Database Instance applies when searching for files in the S3 bucket.
               * `storage_stores.#.delimiter` - The delimiter that separates `storage_databases.#.collections.#.data_sources.#.path` segments in the data store.
               * `storage_stores.#.include_tags` - Determines whether or not to use S3 tags on the files in the given path as additional partition attributes.
               * `storage_stores.#.cluster_name` - Human-readable label of the MongoDB Cloud cluster on which the store is based.
               * `storage_stores.#.allow_insecure` - Flag that validates the scheme in the specified URLs.
               * `storage_stores.#.public` - Flag that indicates whether the bucket is public.
               * `storage_stores.#.default_format` - Default format that Data Lake assumes if it encounters a file without an extension while searching the storeName.
               * `storage_stores.#.urls` - Comma-separated list of publicly accessible HTTP URLs where data is stored.
               * `storage_stores.#.read_preference` - MongoDB Cloud cluster read preference, which describes how to route read requests to the cluster.
               * `storage_stores.#.read_preference.maxStalenessSeconds` - Maximum replication lag, or staleness, for reads from secondaries.
               * `storage_stores.#.read_preference.mode` - Read preference mode that specifies to which replica set member to route the read requests.
               * `storage_stores.#.read_preference.tag_sets` - List that contains tag sets or tag specification documents.
               * `storage_stores.#.read_preference.tags` - List of all tags within a tag set
               * `storage_stores.#.read_preference.tags.name` - Human-readable label of the tag.
               * `storage_stores.#.read_preference.tags.value` - Value of the tag.
        """
        pulumi.set(__self__, "cloud_provider_config", cloud_provider_config)
        pulumi.set(__self__, "data_process_regions", data_process_regions)
        pulumi.set(__self__, "hostnames", hostnames)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "storage_databases", storage_databases)
        pulumi.set(__self__, "storage_stores", storage_stores)

    @property
    @pulumi.getter(name="cloudProviderConfig")
    def cloud_provider_config(self) -> 'outputs.GetFederatedDatabaseInstancesResultCloudProviderConfigResult':
        return pulumi.get(self, "cloud_provider_config")

    @property
    @pulumi.getter(name="dataProcessRegions")
    def data_process_regions(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultDataProcessRegionResult']:
        return pulumi.get(self, "data_process_regions")

    @property
    @pulumi.getter
    def hostnames(self) -> Sequence[str]:
        """
        The list of hostnames assigned to the Federated Database Instance. Each string in the array is a hostname assigned to the Federated Database Instance.
        """
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project to create a Federated Database Instance.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        Current state of the Federated Database Instance:
        * `ACTIVE` - The Federated Database Instance is active and verified. You can query the data stores associated with the Federated Database Instance.
        * `DELETED` - The Federated Database Instance was deleted.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="storageDatabases")
    def storage_databases(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultStorageDatabaseResult']:
        """
        Configuration details for mapping each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [databases](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-databases-reference). An empty object indicates that the Federated Database Instance has no mapping configuration for any data store.
        * `storage_databases.#.name` - Name of the database to which the Federated Database Instance maps the data contained in the data store.
        * `storage_databases.#.collections` -     Array of objects where each object represents a collection and data sources that map to a [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#mongodb-datalakeconf-datalakeconf.stores) data store.
        * `storage_databases.#.collections.#.name` - Name of the collection.
        * `storage_databases.#.collections.#.data_sources` -     Array of objects where each object represents a stores data store to map with the collection.
        * `storage_databases.#.collections.#.data_sources.#.store_name` -     Name of a data store to map to the `<collection>`. Must match the name of an object in the stores array.
        * `storage_databases.#.collections.#.data_sources.#.dataset_name` -     Human-readable label that identifies the dataset that Atlas generates for an ingestion pipeline run or Online Archive.
        * `storage_databases.#.collections.#.data_sources.#.default_format` - Default format that Federated Database assumes if it encounters a file without an extension while searching the storeName.
        * `storage_databases.#.collections.#.data_sources.#.path` - File path that controls how MongoDB Cloud searches for and parses files in the storeName before mapping them to a collection. Specify / to capture all files and folders from the prefix path.
        * `storage_databases.#.collections.#.data_sources.#.database` - Human-readable label that identifies the database, which contains the collection in the cluster.
        * `storage_databases.#.collections.#.data_sources.#.allow_insecure` - Flag that validates the scheme in the specified URLs. If true, allows insecure HTTP scheme, doesn't verify the server's certificate chain and hostname, and accepts any certificate with any hostname presented by the server. If false, allows secure HTTPS scheme only.
        * `storage_databases.#.collections.#.data_sources.#.database_regex` - Regex pattern to use for creating the wildcard database.
        * `storage_databases.#.collections.#.data_sources.#.collection` - Human-readable label that identifies the collection in the database.
        * `storage_databases.#.collections.#.data_sources.#.collection_regex` - Regex pattern to use for creating the wildcard (*) collection.
        * `storage_databases.#.collections.#.data_sources.#.provenance_field_name` - Name for the field that includes the provenance of the documents in the results.
        * `storage_databases.#.collections.#.data_sources.#.storeName` - Human-readable label that identifies the data store that MongoDB Cloud maps to the collection.
        * `storage_databases.#.collections.#.data_sources.#.urls` - URLs of the publicly accessible data files. You can't specify URLs that require authentication.
        * `storage_databases.#.views` -     Array of objects where each object represents an [aggregation pipeline](https://docs.mongodb.com/manual/core/aggregation-pipeline/#id1) on a collection. To learn more about views, see [Views](https://docs.mongodb.com/manual/core/views/).
        * `storage_databases.#.views.#.name` - Name of the view.
        * `storage_databases.#.views.#.source` -  Name of the source collection for the view.
        * `storage_databases.#.views.#.pipeline`- Aggregation pipeline stage(s) to apply to the source collection.
        """
        return pulumi.get(self, "storage_databases")

    @property
    @pulumi.getter(name="storageStores")
    def storage_stores(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultStorageStoreResult']:
        """
        Each object in the array represents a data store. Federated Database uses the storage.databases configuration details to map data in each data store to queryable databases and collections. For complete documentation on this object and its nested fields, see [stores](https://docs.mongodb.com/datalake/reference/format/data-lake-configuration#std-label-datalake-stores-reference). An empty object indicates that the Federated Database Instance has no configured data stores.
        * `storage_stores.#.name` - Name of the data store.
        * `storage_stores.#.provider` - Defines where the data is stored.
        * `storage_stores.#.region` - Name of the AWS region in which the S3 bucket is hosted.
        * `storage_stores.#.bucket` - Name of the AWS S3 bucket.
        * `storage_stores.#.prefix` - Prefix the Federated Database Instance applies when searching for files in the S3 bucket.
        * `storage_stores.#.delimiter` - The delimiter that separates `storage_databases.#.collections.#.data_sources.#.path` segments in the data store.
        * `storage_stores.#.include_tags` - Determines whether or not to use S3 tags on the files in the given path as additional partition attributes.
        * `storage_stores.#.cluster_name` - Human-readable label of the MongoDB Cloud cluster on which the store is based.
        * `storage_stores.#.allow_insecure` - Flag that validates the scheme in the specified URLs.
        * `storage_stores.#.public` - Flag that indicates whether the bucket is public.
        * `storage_stores.#.default_format` - Default format that Data Lake assumes if it encounters a file without an extension while searching the storeName.
        * `storage_stores.#.urls` - Comma-separated list of publicly accessible HTTP URLs where data is stored.
        * `storage_stores.#.read_preference` - MongoDB Cloud cluster read preference, which describes how to route read requests to the cluster.
        * `storage_stores.#.read_preference.maxStalenessSeconds` - Maximum replication lag, or staleness, for reads from secondaries.
        * `storage_stores.#.read_preference.mode` - Read preference mode that specifies to which replica set member to route the read requests.
        * `storage_stores.#.read_preference.tag_sets` - List that contains tag sets or tag specification documents.
        * `storage_stores.#.read_preference.tags` - List of all tags within a tag set
        * `storage_stores.#.read_preference.tags.name` - Human-readable label of the tag.
        * `storage_stores.#.read_preference.tags.value` - Value of the tag.
        """
        return pulumi.get(self, "storage_stores")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultCloudProviderConfigResult(dict):
    def __init__(__self__, *,
                 aws: 'outputs.GetFederatedDatabaseInstancesResultCloudProviderConfigAwsResult'):
        pulumi.set(__self__, "aws", aws)

    @property
    @pulumi.getter
    def aws(self) -> 'outputs.GetFederatedDatabaseInstancesResultCloudProviderConfigAwsResult':
        return pulumi.get(self, "aws")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultCloudProviderConfigAwsResult(dict):
    def __init__(__self__, *,
                 external_id: str,
                 iam_assumed_role_arn: str,
                 iam_user_arn: str,
                 role_id: str,
                 test_s3_bucket: str):
        """
        :param str external_id: Unique identifier associated with the IAM Role that the Federated Database Instance assumes when accessing the data stores.
        :param str iam_assumed_role_arn: Amazon Resource Name (ARN) of the IAM Role that the Federated Database Instance assumes when accessing S3 Bucket data stores. The IAM Role must support the following actions against each S3 bucket:
               * `s3:GetObject`
               * `s3:ListBucket`
               * `s3:GetObjectVersion`
        :param str iam_user_arn: Amazon Resource Name (ARN) of the user that the Federated Database Instance assumes when accessing S3 Bucket data stores.
        :param str role_id: Unique identifier of the role that the data lake can use to access the data stores.
               #### `data_process_region` - The cloud provider region to which the Federated Instance routes client connections for data processing.
        """
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "iam_assumed_role_arn", iam_assumed_role_arn)
        pulumi.set(__self__, "iam_user_arn", iam_user_arn)
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "test_s3_bucket", test_s3_bucket)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> str:
        """
        Unique identifier associated with the IAM Role that the Federated Database Instance assumes when accessing the data stores.
        """
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="iamAssumedRoleArn")
    def iam_assumed_role_arn(self) -> str:
        """
        Amazon Resource Name (ARN) of the IAM Role that the Federated Database Instance assumes when accessing S3 Bucket data stores. The IAM Role must support the following actions against each S3 bucket:
        * `s3:GetObject`
        * `s3:ListBucket`
        * `s3:GetObjectVersion`
        """
        return pulumi.get(self, "iam_assumed_role_arn")

    @property
    @pulumi.getter(name="iamUserArn")
    def iam_user_arn(self) -> str:
        """
        Amazon Resource Name (ARN) of the user that the Federated Database Instance assumes when accessing S3 Bucket data stores.
        """
        return pulumi.get(self, "iam_user_arn")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> str:
        """
        Unique identifier of the role that the data lake can use to access the data stores.
        #### `data_process_region` - The cloud provider region to which the Federated Instance routes client connections for data processing.
        """
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="testS3Bucket")
    def test_s3_bucket(self) -> str:
        return pulumi.get(self, "test_s3_bucket")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultDataProcessRegionResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 region: str):
        """
        :param str cloud_provider: Name of the cloud service provider. Atlas Federated Database only supports AWS.
        :param str region: Name of the region to which the Federanted Instnace routes client connections for data processing.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        Name of the cloud service provider. Atlas Federated Database only supports AWS.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Name of the region to which the Federanted Instnace routes client connections for data processing.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultStorageDatabaseResult(dict):
    def __init__(__self__, *,
                 collections: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageDatabaseCollectionResult'],
                 max_wildcard_collections: int,
                 name: str,
                 views: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageDatabaseViewResult']):
        pulumi.set(__self__, "collections", collections)
        pulumi.set(__self__, "max_wildcard_collections", max_wildcard_collections)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "views", views)

    @property
    @pulumi.getter
    def collections(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultStorageDatabaseCollectionResult']:
        return pulumi.get(self, "collections")

    @property
    @pulumi.getter(name="maxWildcardCollections")
    def max_wildcard_collections(self) -> int:
        return pulumi.get(self, "max_wildcard_collections")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def views(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultStorageDatabaseViewResult']:
        return pulumi.get(self, "views")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultStorageDatabaseCollectionResult(dict):
    def __init__(__self__, *,
                 data_sources: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageDatabaseCollectionDataSourceResult'],
                 name: str):
        pulumi.set(__self__, "data_sources", data_sources)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultStorageDatabaseCollectionDataSourceResult']:
        return pulumi.get(self, "data_sources")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultStorageDatabaseCollectionDataSourceResult(dict):
    def __init__(__self__, *,
                 allow_insecure: bool,
                 collection: str,
                 collection_regex: str,
                 database: str,
                 database_regex: str,
                 dataset_name: str,
                 default_format: str,
                 path: str,
                 provenance_field_name: str,
                 store_name: str,
                 urls: Sequence[str]):
        pulumi.set(__self__, "allow_insecure", allow_insecure)
        pulumi.set(__self__, "collection", collection)
        pulumi.set(__self__, "collection_regex", collection_regex)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "database_regex", database_regex)
        pulumi.set(__self__, "dataset_name", dataset_name)
        pulumi.set(__self__, "default_format", default_format)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "provenance_field_name", provenance_field_name)
        pulumi.set(__self__, "store_name", store_name)
        pulumi.set(__self__, "urls", urls)

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> bool:
        return pulumi.get(self, "allow_insecure")

    @property
    @pulumi.getter
    def collection(self) -> str:
        return pulumi.get(self, "collection")

    @property
    @pulumi.getter(name="collectionRegex")
    def collection_regex(self) -> str:
        return pulumi.get(self, "collection_regex")

    @property
    @pulumi.getter
    def database(self) -> str:
        return pulumi.get(self, "database")

    @property
    @pulumi.getter(name="databaseRegex")
    def database_regex(self) -> str:
        return pulumi.get(self, "database_regex")

    @property
    @pulumi.getter(name="datasetName")
    def dataset_name(self) -> str:
        return pulumi.get(self, "dataset_name")

    @property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> str:
        return pulumi.get(self, "default_format")

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="provenanceFieldName")
    def provenance_field_name(self) -> str:
        return pulumi.get(self, "provenance_field_name")

    @property
    @pulumi.getter(name="storeName")
    def store_name(self) -> str:
        return pulumi.get(self, "store_name")

    @property
    @pulumi.getter
    def urls(self) -> Sequence[str]:
        return pulumi.get(self, "urls")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultStorageDatabaseViewResult(dict):
    def __init__(__self__, *,
                 name: str,
                 pipeline: str,
                 source: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pipeline", pipeline)
        pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def pipeline(self) -> str:
        return pulumi.get(self, "pipeline")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultStorageStoreResult(dict):
    def __init__(__self__, *,
                 additional_storage_classes: Sequence[str],
                 allow_insecure: bool,
                 bucket: str,
                 cluster_name: str,
                 default_format: str,
                 delimiter: str,
                 include_tags: bool,
                 name: str,
                 prefix: str,
                 project_id: str,
                 provider: str,
                 public: str,
                 read_preferences: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceResult'],
                 region: str,
                 urls: Sequence[str]):
        """
        :param str project_id: The unique ID for the project to create a Federated Database Instance.
        :param str region: Name of the region to which the Federanted Instnace routes client connections for data processing.
        """
        pulumi.set(__self__, "additional_storage_classes", additional_storage_classes)
        pulumi.set(__self__, "allow_insecure", allow_insecure)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "default_format", default_format)
        pulumi.set(__self__, "delimiter", delimiter)
        pulumi.set(__self__, "include_tags", include_tags)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "prefix", prefix)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "public", public)
        pulumi.set(__self__, "read_preferences", read_preferences)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "urls", urls)

    @property
    @pulumi.getter(name="additionalStorageClasses")
    def additional_storage_classes(self) -> Sequence[str]:
        return pulumi.get(self, "additional_storage_classes")

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> bool:
        return pulumi.get(self, "allow_insecure")

    @property
    @pulumi.getter
    def bucket(self) -> str:
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> str:
        return pulumi.get(self, "default_format")

    @property
    @pulumi.getter
    def delimiter(self) -> str:
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="includeTags")
    def include_tags(self) -> bool:
        return pulumi.get(self, "include_tags")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project to create a Federated Database Instance.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def provider(self) -> str:
        return pulumi.get(self, "provider")

    @property
    @pulumi.getter
    def public(self) -> str:
        return pulumi.get(self, "public")

    @property
    @pulumi.getter(name="readPreferences")
    def read_preferences(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceResult']:
        return pulumi.get(self, "read_preferences")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Name of the region to which the Federanted Instnace routes client connections for data processing.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def urls(self) -> Sequence[str]:
        return pulumi.get(self, "urls")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceResult(dict):
    def __init__(__self__, *,
                 max_staleness_seconds: int,
                 mode: str,
                 tag_sets: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetResult']):
        pulumi.set(__self__, "max_staleness_seconds", max_staleness_seconds)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "tag_sets", tag_sets)

    @property
    @pulumi.getter(name="maxStalenessSeconds")
    def max_staleness_seconds(self) -> int:
        return pulumi.get(self, "max_staleness_seconds")

    @property
    @pulumi.getter
    def mode(self) -> str:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="tagSets")
    def tag_sets(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetResult']:
        return pulumi.get(self, "tag_sets")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetResult(dict):
    def __init__(__self__, *,
                 tags: Sequence['outputs.GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetTagResult']):
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetTagResult']:
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetFederatedDatabaseInstancesResultStorageStoreReadPreferenceTagSetTagResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetFederatedQueryLimitsResultResult(dict):
    def __init__(__self__, *,
                 current_usage: int,
                 default_limit: int,
                 last_modified_date: str,
                 limit_name: str,
                 maximum_limit: int,
                 overrun_policy: str,
                 project_id: str,
                 tenant_name: str,
                 value: int):
        """
        :param int current_usage: Amount that indicates the current usage of the limit.
        :param int default_limit: Default value of the limit.
               * `lastModifiedDate` - Only used for Data Federation limits. Timestamp that indicates when this usage limit was last modified. This field uses the ISO 8601 timestamp format in UTC.
               * `maximumLimit` - Maximum value of the limit.
        :param str project_id: The unique ID for the project to create a Federated Database Instance.
        :param str tenant_name: Name of the Atlas Federated Database Instance.
        """
        pulumi.set(__self__, "current_usage", current_usage)
        pulumi.set(__self__, "default_limit", default_limit)
        pulumi.set(__self__, "last_modified_date", last_modified_date)
        pulumi.set(__self__, "limit_name", limit_name)
        pulumi.set(__self__, "maximum_limit", maximum_limit)
        pulumi.set(__self__, "overrun_policy", overrun_policy)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "tenant_name", tenant_name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="currentUsage")
    def current_usage(self) -> int:
        """
        Amount that indicates the current usage of the limit.
        """
        return pulumi.get(self, "current_usage")

    @property
    @pulumi.getter(name="defaultLimit")
    def default_limit(self) -> int:
        """
        Default value of the limit.
        * `lastModifiedDate` - Only used for Data Federation limits. Timestamp that indicates when this usage limit was last modified. This field uses the ISO 8601 timestamp format in UTC.
        * `maximumLimit` - Maximum value of the limit.
        """
        return pulumi.get(self, "default_limit")

    @property
    @pulumi.getter(name="lastModifiedDate")
    def last_modified_date(self) -> str:
        return pulumi.get(self, "last_modified_date")

    @property
    @pulumi.getter(name="limitName")
    def limit_name(self) -> str:
        return pulumi.get(self, "limit_name")

    @property
    @pulumi.getter(name="maximumLimit")
    def maximum_limit(self) -> int:
        return pulumi.get(self, "maximum_limit")

    @property
    @pulumi.getter(name="overrunPolicy")
    def overrun_policy(self) -> str:
        return pulumi.get(self, "overrun_policy")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project to create a Federated Database Instance.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="tenantName")
    def tenant_name(self) -> str:
        """
        Name of the Atlas Federated Database Instance.
        """
        return pulumi.get(self, "tenant_name")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetFederatedSettingsIdentityProviderAssociatedOrgResult(dict):
    def __init__(__self__, *,
                 domain_allow_lists: Sequence[str],
                 domain_restriction_enabled: bool,
                 identity_provider_id: str,
                 org_id: str,
                 post_auth_role_grants: Sequence[str],
                 role_mappings: Sequence['outputs.GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingResult'],
                 user_conflicts: Sequence['outputs.GetFederatedSettingsIdentityProviderAssociatedOrgUserConflictResult']):
        """
        :param Sequence[str] domain_allow_lists: List that contains the approved domains from which organization users can log in.
        :param bool domain_restriction_enabled: Flag that indicates whether domain restriction is enabled for the connected organization.
        :param str identity_provider_id: Unique 24-hexadecimal digit string that identifies the IdP.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param Sequence[str] post_auth_role_grants: List that contains the default roles granted to users who authenticate through the IdP in a connected organization. If you provide a postAuthRoleGrants field in the request, the array that you provide replaces the current postAuthRoleGrants.
        """
        pulumi.set(__self__, "domain_allow_lists", domain_allow_lists)
        pulumi.set(__self__, "domain_restriction_enabled", domain_restriction_enabled)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "post_auth_role_grants", post_auth_role_grants)
        pulumi.set(__self__, "role_mappings", role_mappings)
        pulumi.set(__self__, "user_conflicts", user_conflicts)

    @property
    @pulumi.getter(name="domainAllowLists")
    def domain_allow_lists(self) -> Sequence[str]:
        """
        List that contains the approved domains from which organization users can log in.
        """
        return pulumi.get(self, "domain_allow_lists")

    @property
    @pulumi.getter(name="domainRestrictionEnabled")
    def domain_restriction_enabled(self) -> bool:
        """
        Flag that indicates whether domain restriction is enabled for the connected organization.
        """
        return pulumi.get(self, "domain_restriction_enabled")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the IdP.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter(name="postAuthRoleGrants")
    def post_auth_role_grants(self) -> Sequence[str]:
        """
        List that contains the default roles granted to users who authenticate through the IdP in a connected organization. If you provide a postAuthRoleGrants field in the request, the array that you provide replaces the current postAuthRoleGrants.
        """
        return pulumi.get(self, "post_auth_role_grants")

    @property
    @pulumi.getter(name="roleMappings")
    def role_mappings(self) -> Sequence['outputs.GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingResult']:
        return pulumi.get(self, "role_mappings")

    @property
    @pulumi.getter(name="userConflicts")
    def user_conflicts(self) -> Sequence['outputs.GetFederatedSettingsIdentityProviderAssociatedOrgUserConflictResult']:
        return pulumi.get(self, "user_conflicts")


@pulumi.output_type
class GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingResult(dict):
    def __init__(__self__, *,
                 external_group_name: str,
                 id: str,
                 role_assignments: Sequence['outputs.GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignmentResult']):
        """
        :param str external_group_name: Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        :param str id: Unique 24-hexadecimal digit string that identifies this role mapping.
        :param Sequence['GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignmentArgs'] role_assignments: Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        pulumi.set(__self__, "external_group_name", external_group_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "role_assignments", role_assignments)

    @property
    @pulumi.getter(name="externalGroupName")
    def external_group_name(self) -> str:
        """
        Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        """
        return pulumi.get(self, "external_group_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies this role mapping.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="roleAssignments")
    def role_assignments(self) -> Sequence['outputs.GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignmentResult']:
        """
        Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        return pulumi.get(self, "role_assignments")


@pulumi.output_type
class GetFederatedSettingsIdentityProviderAssociatedOrgRoleMappingRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 group_id: str,
                 org_id: str,
                 role: str):
        """
        :param str group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param str role: Specifies the Role that is attached to the Role Mapping.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Specifies the Role that is attached to the Role Mapping.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetFederatedSettingsIdentityProviderAssociatedOrgUserConflictResult(dict):
    def __init__(__self__, *,
                 email_address: str,
                 federation_settings_id: str,
                 first_name: str,
                 last_name: str,
                 user_id: str):
        """
        :param str email_address: Email address of the the user that conflicts with selected domains.
        :param str federation_settings_id: Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        :param str first_name: First name of the the user that conflicts with selected domains.
        :param str last_name: Last name of the the user that conflicts with selected domains.
        :param str user_id: Name of the Atlas user that conflicts with selected domains.
        """
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "federation_settings_id", federation_settings_id)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> str:
        """
        Email address of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter(name="federationSettingsId")
    def federation_settings_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        """
        return pulumi.get(self, "federation_settings_id")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> str:
        """
        First name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> str:
        """
        Last name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        """
        Name of the Atlas user that conflicts with selected domains.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetFederatedSettingsIdentityProviderPemFileInfoResult(dict):
    def __init__(__self__, *,
                 certificates: Sequence['outputs.GetFederatedSettingsIdentityProviderPemFileInfoCertificateResult'],
                 file_name: str):
        """
        :param str file_name: Filename of certificate
        """
        pulumi.set(__self__, "certificates", certificates)
        pulumi.set(__self__, "file_name", file_name)

    @property
    @pulumi.getter
    def certificates(self) -> Sequence['outputs.GetFederatedSettingsIdentityProviderPemFileInfoCertificateResult']:
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> str:
        """
        Filename of certificate
        """
        return pulumi.get(self, "file_name")


@pulumi.output_type
class GetFederatedSettingsIdentityProviderPemFileInfoCertificateResult(dict):
    def __init__(__self__, *,
                 not_after: str,
                 not_before: str):
        """
        :param str not_after: Expiration  Date.
        :param str not_before: Start Date.
        """
        pulumi.set(__self__, "not_after", not_after)
        pulumi.set(__self__, "not_before", not_before)

    @property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> str:
        """
        Expiration  Date.
        """
        return pulumi.get(self, "not_after")

    @property
    @pulumi.getter(name="notBefore")
    def not_before(self) -> str:
        """
        Start Date.
        """
        return pulumi.get(self, "not_before")


@pulumi.output_type
class GetFederatedSettingsIdentityProvidersResultResult(dict):
    def __init__(__self__, *,
                 acs_url: str,
                 associated_domains: Sequence[str],
                 associated_orgs: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgResult'],
                 audience: str,
                 audience_uri: str,
                 authorization_type: str,
                 client_id: str,
                 description: str,
                 display_name: str,
                 groups_claim: str,
                 idp_id: str,
                 idp_type: str,
                 issuer_uri: str,
                 okta_idp_id: str,
                 pem_file_infos: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultPemFileInfoResult'],
                 protocol: str,
                 request_binding: str,
                 requested_scopes: Sequence[str],
                 response_signature_algorithm: str,
                 sso_debug_enabled: bool,
                 sso_url: str,
                 status: str,
                 user_claim: str):
        """
        :param str acs_url: Assertion consumer service URL to which the IdP sends the SAML response.
        :param Sequence[str] associated_domains: List that contains the configured domains from which users can log in for this IdP.
        :param Sequence['GetFederatedSettingsIdentityProvidersResultAssociatedOrgArgs'] associated_orgs: List that contains the configured domains from which users can log in for this IdP.
        :param str audience: Identifier of the intended recipient of the token.
        :param str audience_uri: Identifier for the intended audience of the SAML Assertion.
        :param str authorization_type: Indicates whether authorization is granted based on group membership or user ID. Valid values are `GROUP` or `USER`.
        :param str client_id: Client identifier that is assigned to an application by the Identity Provider.
        :param str description: The description of the identity provider.
        :param str display_name: Human-readable label that identifies the IdP.
        :param str groups_claim: Identifier of the claim which contains IdP Group IDs in the token.
        :param str idp_id: Unique 24-hexadecimal digit string that identifies the IdP.
        :param str idp_type: Type of the identity provider. Valid values are `WORKFORCE` or `WORKLOAD`.
        :param str issuer_uri: Identifier for the issuer of the SAML Assertion.
        :param str protocol: The protocol of the identity provider
        :param str request_binding: SAML Authentication Request Protocol binding used to send the AuthNRequest. Atlas supports the following binding values:
               - HTTP POST
               - HTTP REDIRECT
        :param Sequence[str] requested_scopes: Scopes that MongoDB applications will request from the authorization endpoint.
        :param str response_signature_algorithm: Algorithm used to encrypt the IdP signature. Atlas supports the following signature algorithm values:
               - SHA-1
               - SHA-256
        :param bool sso_debug_enabled: Flag that indicates whether the IdP has enabled Bypass SAML Mode. Enabling this mode generates a URL that allows you bypass SAML and login to your organizations at any point. You can authenticate with this special URL only when Bypass Mode is enabled. Set this parameter to true during testing. This keeps you from getting locked out of MongoDB.
        :param str sso_url: URL of the receiver of the SAML AuthNRequest.
        :param str status: Label that indicates whether the identity provider is active. The IdP is Inactive until you map at least one domain to the IdP.
        :param str user_claim: Identifier of the claim which contains the user ID in the token.
        """
        pulumi.set(__self__, "acs_url", acs_url)
        pulumi.set(__self__, "associated_domains", associated_domains)
        pulumi.set(__self__, "associated_orgs", associated_orgs)
        pulumi.set(__self__, "audience", audience)
        pulumi.set(__self__, "audience_uri", audience_uri)
        pulumi.set(__self__, "authorization_type", authorization_type)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "groups_claim", groups_claim)
        pulumi.set(__self__, "idp_id", idp_id)
        pulumi.set(__self__, "idp_type", idp_type)
        pulumi.set(__self__, "issuer_uri", issuer_uri)
        pulumi.set(__self__, "okta_idp_id", okta_idp_id)
        pulumi.set(__self__, "pem_file_infos", pem_file_infos)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "request_binding", request_binding)
        pulumi.set(__self__, "requested_scopes", requested_scopes)
        pulumi.set(__self__, "response_signature_algorithm", response_signature_algorithm)
        pulumi.set(__self__, "sso_debug_enabled", sso_debug_enabled)
        pulumi.set(__self__, "sso_url", sso_url)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "user_claim", user_claim)

    @property
    @pulumi.getter(name="acsUrl")
    def acs_url(self) -> str:
        """
        Assertion consumer service URL to which the IdP sends the SAML response.
        """
        return pulumi.get(self, "acs_url")

    @property
    @pulumi.getter(name="associatedDomains")
    def associated_domains(self) -> Sequence[str]:
        """
        List that contains the configured domains from which users can log in for this IdP.
        """
        return pulumi.get(self, "associated_domains")

    @property
    @pulumi.getter(name="associatedOrgs")
    def associated_orgs(self) -> Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgResult']:
        """
        List that contains the configured domains from which users can log in for this IdP.
        """
        return pulumi.get(self, "associated_orgs")

    @property
    @pulumi.getter
    def audience(self) -> str:
        """
        Identifier of the intended recipient of the token.
        """
        return pulumi.get(self, "audience")

    @property
    @pulumi.getter(name="audienceUri")
    def audience_uri(self) -> str:
        """
        Identifier for the intended audience of the SAML Assertion.
        """
        return pulumi.get(self, "audience_uri")

    @property
    @pulumi.getter(name="authorizationType")
    def authorization_type(self) -> str:
        """
        Indicates whether authorization is granted based on group membership or user ID. Valid values are `GROUP` or `USER`.
        """
        return pulumi.get(self, "authorization_type")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Client identifier that is assigned to an application by the Identity Provider.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the identity provider.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        """
        Human-readable label that identifies the IdP.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="groupsClaim")
    def groups_claim(self) -> str:
        """
        Identifier of the claim which contains IdP Group IDs in the token.
        """
        return pulumi.get(self, "groups_claim")

    @property
    @pulumi.getter(name="idpId")
    def idp_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the IdP.
        """
        return pulumi.get(self, "idp_id")

    @property
    @pulumi.getter(name="idpType")
    def idp_type(self) -> str:
        """
        Type of the identity provider. Valid values are `WORKFORCE` or `WORKLOAD`.
        """
        return pulumi.get(self, "idp_type")

    @property
    @pulumi.getter(name="issuerUri")
    def issuer_uri(self) -> str:
        """
        Identifier for the issuer of the SAML Assertion.
        """
        return pulumi.get(self, "issuer_uri")

    @property
    @pulumi.getter(name="oktaIdpId")
    def okta_idp_id(self) -> str:
        return pulumi.get(self, "okta_idp_id")

    @property
    @pulumi.getter(name="pemFileInfos")
    def pem_file_infos(self) -> Sequence['outputs.GetFederatedSettingsIdentityProvidersResultPemFileInfoResult']:
        return pulumi.get(self, "pem_file_infos")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol of the identity provider
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="requestBinding")
    def request_binding(self) -> str:
        """
        SAML Authentication Request Protocol binding used to send the AuthNRequest. Atlas supports the following binding values:
        - HTTP POST
        - HTTP REDIRECT
        """
        return pulumi.get(self, "request_binding")

    @property
    @pulumi.getter(name="requestedScopes")
    def requested_scopes(self) -> Sequence[str]:
        """
        Scopes that MongoDB applications will request from the authorization endpoint.
        """
        return pulumi.get(self, "requested_scopes")

    @property
    @pulumi.getter(name="responseSignatureAlgorithm")
    def response_signature_algorithm(self) -> str:
        """
        Algorithm used to encrypt the IdP signature. Atlas supports the following signature algorithm values:
        - SHA-1
        - SHA-256
        """
        return pulumi.get(self, "response_signature_algorithm")

    @property
    @pulumi.getter(name="ssoDebugEnabled")
    def sso_debug_enabled(self) -> bool:
        """
        Flag that indicates whether the IdP has enabled Bypass SAML Mode. Enabling this mode generates a URL that allows you bypass SAML and login to your organizations at any point. You can authenticate with this special URL only when Bypass Mode is enabled. Set this parameter to true during testing. This keeps you from getting locked out of MongoDB.
        """
        return pulumi.get(self, "sso_debug_enabled")

    @property
    @pulumi.getter(name="ssoUrl")
    def sso_url(self) -> str:
        """
        URL of the receiver of the SAML AuthNRequest.
        """
        return pulumi.get(self, "sso_url")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Label that indicates whether the identity provider is active. The IdP is Inactive until you map at least one domain to the IdP.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="userClaim")
    def user_claim(self) -> str:
        """
        Identifier of the claim which contains the user ID in the token.
        """
        return pulumi.get(self, "user_claim")


@pulumi.output_type
class GetFederatedSettingsIdentityProvidersResultAssociatedOrgResult(dict):
    def __init__(__self__, *,
                 domain_allow_lists: Sequence[str],
                 domain_restriction_enabled: bool,
                 identity_provider_id: str,
                 org_id: str,
                 post_auth_role_grants: Sequence[str],
                 role_mappings: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingResult'],
                 user_conflicts: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgUserConflictResult']):
        """
        :param Sequence[str] domain_allow_lists: List that contains the approved domains from which organization users can log in.
        :param bool domain_restriction_enabled: Flag that indicates whether domain restriction is enabled for the connected organization.
        :param str identity_provider_id: Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param Sequence[str] post_auth_role_grants: List that contains the default roles granted to users who authenticate through the IdP in a connected organization. If you provide a postAuthRoleGrants field in the request, the array that you provide replaces the current postAuthRoleGrants.
        """
        pulumi.set(__self__, "domain_allow_lists", domain_allow_lists)
        pulumi.set(__self__, "domain_restriction_enabled", domain_restriction_enabled)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "post_auth_role_grants", post_auth_role_grants)
        pulumi.set(__self__, "role_mappings", role_mappings)
        pulumi.set(__self__, "user_conflicts", user_conflicts)

    @property
    @pulumi.getter(name="domainAllowLists")
    def domain_allow_lists(self) -> Sequence[str]:
        """
        List that contains the approved domains from which organization users can log in.
        """
        return pulumi.get(self, "domain_allow_lists")

    @property
    @pulumi.getter(name="domainRestrictionEnabled")
    def domain_restriction_enabled(self) -> bool:
        """
        Flag that indicates whether domain restriction is enabled for the connected organization.
        """
        return pulumi.get(self, "domain_restriction_enabled")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter(name="postAuthRoleGrants")
    def post_auth_role_grants(self) -> Sequence[str]:
        """
        List that contains the default roles granted to users who authenticate through the IdP in a connected organization. If you provide a postAuthRoleGrants field in the request, the array that you provide replaces the current postAuthRoleGrants.
        """
        return pulumi.get(self, "post_auth_role_grants")

    @property
    @pulumi.getter(name="roleMappings")
    def role_mappings(self) -> Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingResult']:
        return pulumi.get(self, "role_mappings")

    @property
    @pulumi.getter(name="userConflicts")
    def user_conflicts(self) -> Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgUserConflictResult']:
        return pulumi.get(self, "user_conflicts")


@pulumi.output_type
class GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingResult(dict):
    def __init__(__self__, *,
                 external_group_name: str,
                 id: str,
                 role_assignments: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignmentResult']):
        """
        :param str external_group_name: Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        :param str id: Unique 24-hexadecimal digit string that identifies this role mapping.
        :param Sequence['GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignmentArgs'] role_assignments: Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        pulumi.set(__self__, "external_group_name", external_group_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "role_assignments", role_assignments)

    @property
    @pulumi.getter(name="externalGroupName")
    def external_group_name(self) -> str:
        """
        Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        """
        return pulumi.get(self, "external_group_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies this role mapping.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="roleAssignments")
    def role_assignments(self) -> Sequence['outputs.GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignmentResult']:
        """
        Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        return pulumi.get(self, "role_assignments")


@pulumi.output_type
class GetFederatedSettingsIdentityProvidersResultAssociatedOrgRoleMappingRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 group_id: str,
                 org_id: str,
                 role: str):
        """
        :param str group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param str role: Specifies the Role that is attached to the Role Mapping.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Specifies the Role that is attached to the Role Mapping.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetFederatedSettingsIdentityProvidersResultAssociatedOrgUserConflictResult(dict):
    def __init__(__self__, *,
                 email_address: str,
                 federation_settings_id: str,
                 first_name: str,
                 last_name: str,
                 user_id: str):
        """
        :param str email_address: Email address of the the user that conflicts with selected domains.
        :param str federation_settings_id: Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        :param str first_name: First name of the the user that conflicts with selected domains.
        :param str last_name: Last name of the the user that conflicts with selected domains.
        :param str user_id: Name of the Atlas user that conflicts with selected domains.
        """
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "federation_settings_id", federation_settings_id)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> str:
        """
        Email address of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter(name="federationSettingsId")
    def federation_settings_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        """
        return pulumi.get(self, "federation_settings_id")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> str:
        """
        First name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> str:
        """
        Last name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        """
        Name of the Atlas user that conflicts with selected domains.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetFederatedSettingsIdentityProvidersResultPemFileInfoResult(dict):
    def __init__(__self__, *,
                 certificates: Sequence['outputs.GetFederatedSettingsIdentityProvidersResultPemFileInfoCertificateResult'],
                 file_name: str):
        """
        :param str file_name: Filename of certificate
        """
        pulumi.set(__self__, "certificates", certificates)
        pulumi.set(__self__, "file_name", file_name)

    @property
    @pulumi.getter
    def certificates(self) -> Sequence['outputs.GetFederatedSettingsIdentityProvidersResultPemFileInfoCertificateResult']:
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter(name="fileName")
    def file_name(self) -> str:
        """
        Filename of certificate
        """
        return pulumi.get(self, "file_name")


@pulumi.output_type
class GetFederatedSettingsIdentityProvidersResultPemFileInfoCertificateResult(dict):
    def __init__(__self__, *,
                 not_after: str,
                 not_before: str):
        """
        :param str not_after: Expiration  Date.
        :param str not_before: Start Date.
        """
        pulumi.set(__self__, "not_after", not_after)
        pulumi.set(__self__, "not_before", not_before)

    @property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> str:
        """
        Expiration  Date.
        """
        return pulumi.get(self, "not_after")

    @property
    @pulumi.getter(name="notBefore")
    def not_before(self) -> str:
        """
        Start Date.
        """
        return pulumi.get(self, "not_before")


@pulumi.output_type
class GetFederatedSettingsOrgConfigRoleMappingResult(dict):
    def __init__(__self__, *,
                 external_group_name: str,
                 id: str,
                 role_assignments: Sequence['outputs.GetFederatedSettingsOrgConfigRoleMappingRoleAssignmentResult']):
        """
        :param str external_group_name: Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        :param str id: Unique 24-hexadecimal digit string that identifies this role mapping.
        :param Sequence['GetFederatedSettingsOrgConfigRoleMappingRoleAssignmentArgs'] role_assignments: Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        pulumi.set(__self__, "external_group_name", external_group_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "role_assignments", role_assignments)

    @property
    @pulumi.getter(name="externalGroupName")
    def external_group_name(self) -> str:
        """
        Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        """
        return pulumi.get(self, "external_group_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies this role mapping.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="roleAssignments")
    def role_assignments(self) -> Sequence['outputs.GetFederatedSettingsOrgConfigRoleMappingRoleAssignmentResult']:
        """
        Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        return pulumi.get(self, "role_assignments")


@pulumi.output_type
class GetFederatedSettingsOrgConfigRoleMappingRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 group_id: str,
                 org_id: str,
                 role: str):
        """
        :param str group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param str role: Specifies the Role that is attached to the Role Mapping.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Specifies the Role that is attached to the Role Mapping.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetFederatedSettingsOrgConfigUserConflictResult(dict):
    def __init__(__self__, *,
                 email_address: str,
                 federation_settings_id: str,
                 first_name: str,
                 last_name: str,
                 user_id: str):
        """
        :param str email_address: Email address of the the user that conflicts with selected domains.
        :param str federation_settings_id: Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        :param str first_name: First name of the the user that conflicts with selected domains.
        :param str last_name: Last name of the the user that conflicts with selected domains.
        :param str user_id: Name of the Atlas user that conflicts with selected domains.
        """
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "federation_settings_id", federation_settings_id)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> str:
        """
        Email address of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter(name="federationSettingsId")
    def federation_settings_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        """
        return pulumi.get(self, "federation_settings_id")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> str:
        """
        First name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> str:
        """
        Last name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        """
        Name of the Atlas user that conflicts with selected domains.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetFederatedSettingsOrgConfigsResultResult(dict):
    def __init__(__self__, *,
                 data_access_identity_provider_ids: Sequence[str],
                 domain_allow_lists: Sequence[str],
                 domain_restriction_enabled: bool,
                 identity_provider_id: str,
                 org_id: str,
                 post_auth_role_grants: Sequence[str],
                 role_mappings: Sequence['outputs.GetFederatedSettingsOrgConfigsResultRoleMappingResult'],
                 user_conflicts: Sequence['outputs.GetFederatedSettingsOrgConfigsResultUserConflictResult']):
        """
        :param Sequence[str] data_access_identity_provider_ids: The collection of unique ids representing the identity providers that can be used for data access in this organization.
        :param Sequence[str] domain_allow_lists: List that contains the approved domains from which organization users can log in.
        :param bool domain_restriction_enabled: Flag that indicates whether domain restriction is enabled for the connected organization.
        :param str identity_provider_id: Legacy 20-hexadecimal digit string that identifies the SAML access identity provider that this connected org config is associated with. This id can be found in two ways:
               1. Within the Federation Management UI in Atlas in the Identity Providers tab by clicking the info icon in the IdP ID row of a configured SAML identity provider
               2. `okta_idp_id` on the `FederatedSettingsIdentityProvider` resource
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param Sequence[str] post_auth_role_grants: List that contains the default roles granted to users who authenticate through the IdP in a connected organization.
        :param Sequence['GetFederatedSettingsOrgConfigsResultRoleMappingArgs'] role_mappings: Role mappings that are configured in this organization. See below
        :param Sequence['GetFederatedSettingsOrgConfigsResultUserConflictArgs'] user_conflicts: List that contains the users who have an email address that doesn't match any domain on the allowed list. See below
        """
        pulumi.set(__self__, "data_access_identity_provider_ids", data_access_identity_provider_ids)
        pulumi.set(__self__, "domain_allow_lists", domain_allow_lists)
        pulumi.set(__self__, "domain_restriction_enabled", domain_restriction_enabled)
        pulumi.set(__self__, "identity_provider_id", identity_provider_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "post_auth_role_grants", post_auth_role_grants)
        pulumi.set(__self__, "role_mappings", role_mappings)
        pulumi.set(__self__, "user_conflicts", user_conflicts)

    @property
    @pulumi.getter(name="dataAccessIdentityProviderIds")
    def data_access_identity_provider_ids(self) -> Sequence[str]:
        """
        The collection of unique ids representing the identity providers that can be used for data access in this organization.
        """
        return pulumi.get(self, "data_access_identity_provider_ids")

    @property
    @pulumi.getter(name="domainAllowLists")
    def domain_allow_lists(self) -> Sequence[str]:
        """
        List that contains the approved domains from which organization users can log in.
        """
        return pulumi.get(self, "domain_allow_lists")

    @property
    @pulumi.getter(name="domainRestrictionEnabled")
    def domain_restriction_enabled(self) -> bool:
        """
        Flag that indicates whether domain restriction is enabled for the connected organization.
        """
        return pulumi.get(self, "domain_restriction_enabled")

    @property
    @pulumi.getter(name="identityProviderId")
    def identity_provider_id(self) -> str:
        """
        Legacy 20-hexadecimal digit string that identifies the SAML access identity provider that this connected org config is associated with. This id can be found in two ways:
        1. Within the Federation Management UI in Atlas in the Identity Providers tab by clicking the info icon in the IdP ID row of a configured SAML identity provider
        2. `okta_idp_id` on the `FederatedSettingsIdentityProvider` resource
        """
        return pulumi.get(self, "identity_provider_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter(name="postAuthRoleGrants")
    def post_auth_role_grants(self) -> Sequence[str]:
        """
        List that contains the default roles granted to users who authenticate through the IdP in a connected organization.
        """
        return pulumi.get(self, "post_auth_role_grants")

    @property
    @pulumi.getter(name="roleMappings")
    def role_mappings(self) -> Sequence['outputs.GetFederatedSettingsOrgConfigsResultRoleMappingResult']:
        """
        Role mappings that are configured in this organization. See below
        """
        return pulumi.get(self, "role_mappings")

    @property
    @pulumi.getter(name="userConflicts")
    def user_conflicts(self) -> Sequence['outputs.GetFederatedSettingsOrgConfigsResultUserConflictResult']:
        """
        List that contains the users who have an email address that doesn't match any domain on the allowed list. See below
        """
        return pulumi.get(self, "user_conflicts")


@pulumi.output_type
class GetFederatedSettingsOrgConfigsResultRoleMappingResult(dict):
    def __init__(__self__, *,
                 external_group_name: str,
                 id: str,
                 role_assignments: Sequence['outputs.GetFederatedSettingsOrgConfigsResultRoleMappingRoleAssignmentResult']):
        """
        :param str external_group_name: Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        :param str id: Unique 24-hexadecimal digit string that identifies this role mapping.
        :param Sequence['GetFederatedSettingsOrgConfigsResultRoleMappingRoleAssignmentArgs'] role_assignments: Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        pulumi.set(__self__, "external_group_name", external_group_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "role_assignments", role_assignments)

    @property
    @pulumi.getter(name="externalGroupName")
    def external_group_name(self) -> str:
        """
        Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        """
        return pulumi.get(self, "external_group_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies this role mapping.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="roleAssignments")
    def role_assignments(self) -> Sequence['outputs.GetFederatedSettingsOrgConfigsResultRoleMappingRoleAssignmentResult']:
        """
        Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        return pulumi.get(self, "role_assignments")


@pulumi.output_type
class GetFederatedSettingsOrgConfigsResultRoleMappingRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 group_id: str,
                 org_id: str,
                 role: str):
        """
        :param str group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param str role: Specifies the Role that is attached to the Role Mapping.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Specifies the Role that is attached to the Role Mapping.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetFederatedSettingsOrgConfigsResultUserConflictResult(dict):
    def __init__(__self__, *,
                 email_address: str,
                 federation_settings_id: str,
                 first_name: str,
                 last_name: str,
                 user_id: str):
        """
        :param str email_address: Email address of the the user that conflicts with selected domains.
        :param str federation_settings_id: Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        :param str first_name: First name of the the user that conflicts with selected domains.
        :param str last_name: Last name of the the user that conflicts with selected domains.
        :param str user_id: Name of the Atlas user that conflicts with selected domains.
        """
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "federation_settings_id", federation_settings_id)
        pulumi.set(__self__, "first_name", first_name)
        pulumi.set(__self__, "last_name", last_name)
        pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> str:
        """
        Email address of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter(name="federationSettingsId")
    def federation_settings_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the federated authentication configuration.
        """
        return pulumi.get(self, "federation_settings_id")

    @property
    @pulumi.getter(name="firstName")
    def first_name(self) -> str:
        """
        First name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "first_name")

    @property
    @pulumi.getter(name="lastName")
    def last_name(self) -> str:
        """
        Last name of the the user that conflicts with selected domains.
        """
        return pulumi.get(self, "last_name")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        """
        Name of the Atlas user that conflicts with selected domains.
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetFederatedSettingsOrgRoleMappingRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 group_id: str,
                 org_id: str,
                 role: str):
        """
        :param str group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param str role: Specifies the Role that is attached to the Role Mapping.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Specifies the Role that is attached to the Role Mapping.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetFederatedSettingsOrgRoleMappingsResultResult(dict):
    def __init__(__self__, *,
                 external_group_name: str,
                 id: str,
                 role_assignments: Sequence['outputs.GetFederatedSettingsOrgRoleMappingsResultRoleAssignmentResult']):
        """
        :param str external_group_name: Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        :param str id: Unique 24-hexadecimal digit string that identifies this role mapping.
        :param Sequence['GetFederatedSettingsOrgRoleMappingsResultRoleAssignmentArgs'] role_assignments: Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        pulumi.set(__self__, "external_group_name", external_group_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "role_assignments", role_assignments)

    @property
    @pulumi.getter(name="externalGroupName")
    def external_group_name(self) -> str:
        """
        Unique human-readable label that identifies the identity provider group to which this role mapping applies.
        """
        return pulumi.get(self, "external_group_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies this role mapping.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="roleAssignments")
    def role_assignments(self) -> Sequence['outputs.GetFederatedSettingsOrgRoleMappingsResultRoleAssignmentResult']:
        """
        Atlas roles and the unique identifiers of the groups and organizations associated with each role.
        """
        return pulumi.get(self, "role_assignments")


@pulumi.output_type
class GetFederatedSettingsOrgRoleMappingsResultRoleAssignmentResult(dict):
    def __init__(__self__, *,
                 group_id: str,
                 org_id: str,
                 role: str):
        """
        :param str group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param str org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param str role: Specifies the Role that is attached to the Role Mapping.
        """
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "role", role)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        Specifies the Role that is attached to the Role Mapping.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetGlobalClusterConfigManagedNamespaceResult(dict):
    def __init__(__self__, *,
                 collection: str,
                 custom_shard_key: str,
                 db: str,
                 is_custom_shard_key_hashed: bool,
                 is_shard_key_unique: bool):
        """
        :param str collection: (Required) The name of the collection associated with the managed namespace.
        :param str custom_shard_key: (Required)	The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        :param str db: (Required) The name of the database containing the collection.
        :param bool is_custom_shard_key_hashed: Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.
        :param bool is_shard_key_unique: Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).
        """
        pulumi.set(__self__, "collection", collection)
        pulumi.set(__self__, "custom_shard_key", custom_shard_key)
        pulumi.set(__self__, "db", db)
        pulumi.set(__self__, "is_custom_shard_key_hashed", is_custom_shard_key_hashed)
        pulumi.set(__self__, "is_shard_key_unique", is_shard_key_unique)

    @property
    @pulumi.getter
    def collection(self) -> str:
        """
        (Required) The name of the collection associated with the managed namespace.
        """
        return pulumi.get(self, "collection")

    @property
    @pulumi.getter(name="customShardKey")
    def custom_shard_key(self) -> str:
        """
        (Required)	The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        """
        return pulumi.get(self, "custom_shard_key")

    @property
    @pulumi.getter
    def db(self) -> str:
        """
        (Required) The name of the database containing the collection.
        """
        return pulumi.get(self, "db")

    @property
    @pulumi.getter(name="isCustomShardKeyHashed")
    def is_custom_shard_key_hashed(self) -> bool:
        """
        Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.
        """
        return pulumi.get(self, "is_custom_shard_key_hashed")

    @property
    @pulumi.getter(name="isShardKeyUnique")
    def is_shard_key_unique(self) -> bool:
        """
        Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).
        """
        return pulumi.get(self, "is_shard_key_unique")


@pulumi.output_type
class GetLdapConfigurationUserToDnMappingResult(dict):
    def __init__(__self__, *,
                 ldap_query: str,
                 match: str,
                 substitution: str):
        """
        :param str ldap_query: An LDAP query formatting template that inserts the LDAP name matched by the `match` regular expression into an LDAP query URI as specified by RFC 4515 and RFC 4516.
        :param str match: A regular expression to match against a provided LDAP username.
        :param str substitution: An LDAP Distinguished Name (DN) formatting template that converts the LDAP name matched by the `match` regular expression into an LDAP Distinguished Name.
        """
        pulumi.set(__self__, "ldap_query", ldap_query)
        pulumi.set(__self__, "match", match)
        pulumi.set(__self__, "substitution", substitution)

    @property
    @pulumi.getter(name="ldapQuery")
    def ldap_query(self) -> str:
        """
        An LDAP query formatting template that inserts the LDAP name matched by the `match` regular expression into an LDAP query URI as specified by RFC 4515 and RFC 4516.
        """
        return pulumi.get(self, "ldap_query")

    @property
    @pulumi.getter
    def match(self) -> str:
        """
        A regular expression to match against a provided LDAP username.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def substitution(self) -> str:
        """
        An LDAP Distinguished Name (DN) formatting template that converts the LDAP name matched by the `match` regular expression into an LDAP Distinguished Name.
        """
        return pulumi.get(self, "substitution")


@pulumi.output_type
class GetLdapVerifyLinkResult(dict):
    def __init__(__self__, *,
                 href: str,
                 rel: str):
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> str:
        return pulumi.get(self, "href")

    @property
    @pulumi.getter
    def rel(self) -> str:
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetLdapVerifyValidationResult(dict):
    def __init__(__self__, *,
                 status: str,
                 validation_type: str):
        """
        :param str status: The current status of the LDAP over TLS/SSL configuration.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "validation_type", validation_type)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The current status of the LDAP over TLS/SSL configuration.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="validationType")
    def validation_type(self) -> str:
        return pulumi.get(self, "validation_type")


@pulumi.output_type
class GetNetworkContainersResultResult(dict):
    def __init__(__self__, *,
                 atlas_cidr_block: str,
                 azure_subscription_id: str,
                 gcp_project_id: str,
                 id: str,
                 network_name: str,
                 provider_name: str,
                 provisioned: bool,
                 region: str,
                 region_name: str,
                 regions: Sequence[str],
                 vnet_name: str,
                 vpc_id: str):
        """
        :param str atlas_cidr_block: CIDR block that Atlas uses for your clusters. Atlas uses the specified CIDR block for all other Network Peering connections created in the project. The Atlas CIDR block must be at least a /24 and at most a /21 in one of the following [private networks](https://tools.ietf.org/html/rfc1918.html#section-3).
        :param str azure_subscription_id: Unique identifer of the Azure subscription in which the VNet resides.
        :param str gcp_project_id: Unique identifier of the GCP project in which the Network Peering connection resides.
        :param str id: The Network Peering Container ID.
        :param str network_name: Name of the Network Peering connection in the Atlas project.
        :param str provider_name: Cloud provider for this Network peering container. Accepted values are AWS, GCP, and Azure.
        :param bool provisioned: Indicates whether the project has Network Peering connections deployed in the container.
        :param str region: The Atlas Azure region name for where this container exists.
        :param str region_name: The Atlas AWS region name for where this container exists.
        :param Sequence[str] regions: Atlas GCP regions where the container resides.
        :param str vnet_name: The name of the Azure VNet. This value is null until you provision an Azure VNet in the container.
        :param str vpc_id: Unique identifier of the project’s VPC.
        """
        pulumi.set(__self__, "atlas_cidr_block", atlas_cidr_block)
        pulumi.set(__self__, "azure_subscription_id", azure_subscription_id)
        pulumi.set(__self__, "gcp_project_id", gcp_project_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "network_name", network_name)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "provisioned", provisioned)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "region_name", region_name)
        pulumi.set(__self__, "regions", regions)
        pulumi.set(__self__, "vnet_name", vnet_name)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="atlasCidrBlock")
    def atlas_cidr_block(self) -> str:
        """
        CIDR block that Atlas uses for your clusters. Atlas uses the specified CIDR block for all other Network Peering connections created in the project. The Atlas CIDR block must be at least a /24 and at most a /21 in one of the following [private networks](https://tools.ietf.org/html/rfc1918.html#section-3).
        """
        return pulumi.get(self, "atlas_cidr_block")

    @property
    @pulumi.getter(name="azureSubscriptionId")
    def azure_subscription_id(self) -> str:
        """
        Unique identifer of the Azure subscription in which the VNet resides.
        """
        return pulumi.get(self, "azure_subscription_id")

    @property
    @pulumi.getter(name="gcpProjectId")
    def gcp_project_id(self) -> str:
        """
        Unique identifier of the GCP project in which the Network Peering connection resides.
        """
        return pulumi.get(self, "gcp_project_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The Network Peering Container ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="networkName")
    def network_name(self) -> str:
        """
        Name of the Network Peering connection in the Atlas project.
        """
        return pulumi.get(self, "network_name")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Cloud provider for this Network peering container. Accepted values are AWS, GCP, and Azure.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def provisioned(self) -> bool:
        """
        Indicates whether the project has Network Peering connections deployed in the container.
        """
        return pulumi.get(self, "provisioned")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The Atlas Azure region name for where this container exists.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        The Atlas AWS region name for where this container exists.
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter
    def regions(self) -> Sequence[str]:
        """
        Atlas GCP regions where the container resides.
        """
        return pulumi.get(self, "regions")

    @property
    @pulumi.getter(name="vnetName")
    def vnet_name(self) -> str:
        """
        The name of the Azure VNet. This value is null until you provision an Azure VNet in the container.
        """
        return pulumi.get(self, "vnet_name")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        Unique identifier of the project’s VPC.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetNetworkPeeringsResultResult(dict):
    def __init__(__self__, *,
                 accepter_region_name: str,
                 atlas_cidr_block: str,
                 aws_account_id: str,
                 azure_directory_id: str,
                 azure_subscription_id: str,
                 connection_id: str,
                 container_id: str,
                 error_message: str,
                 error_state: str,
                 error_state_name: str,
                 gcp_project_id: str,
                 network_name: str,
                 peering_id: str,
                 provider_name: str,
                 resource_group_name: str,
                 route_table_cidr_block: str,
                 status: str,
                 status_name: str,
                 vnet_name: str,
                 vpc_id: str):
        """
        :param str accepter_region_name: Specifies the region where the peer VPC resides. For complete lists of supported regions, see [Amazon Web Services](https://docs.atlas.mongodb.com/reference/amazon-aws/).
        :param str aws_account_id: Account ID of the owner of the peer VPC.
        :param str azure_directory_id: Unique identifier for an Azure AD directory.
        :param str azure_subscription_id: Unique identifer of the Azure subscription in which the VNet resides.
        :param str connection_id: Unique identifier for the peering connection.
        :param str error_message: When `"status" : "FAILED"`, Atlas provides a description of the error.
        :param str error_state: Description of the Atlas error when `status` is `Failed`, Otherwise, Atlas returns `null`.
        :param str error_state_name: Error state, if any. The VPC peering connection error state value can be one of the following: `REJECTED`, `EXPIRED`, `INVALID_ARGUMENT`.
        :param str gcp_project_id: GCP project ID of the owner of the network peer.
        :param str network_name: Name of the network peer to which Atlas connects.
        :param str peering_id: Atlas assigned unique ID for the peering connection.
        :param str provider_name: Cloud provider for this VPC peering connection. If omitted, Atlas sets this parameter to AWS. (Possible Values `AWS`, `AZURE`, `GCP`).
        :param str resource_group_name: Name of your Azure resource group.
        :param str route_table_cidr_block: Peer VPC CIDR block or subnet.
        :param str status: Status of the Atlas network peering connection: `ADDING_PEER`, `AVAILABLE`, `FAILED`, `DELETING`, `WAITING_FOR_USER`.
        :param str status_name: The VPC peering connection status value can be one of the following: `INITIATING`, `PENDING_ACCEPTANCE`, `FAILED`, `FINALIZING`, `AVAILABLE`, `TERMINATING`.
        :param str vnet_name: Name of your Azure VNet.
        :param str vpc_id: Unique identifier of the peer VPC.
        """
        pulumi.set(__self__, "accepter_region_name", accepter_region_name)
        pulumi.set(__self__, "atlas_cidr_block", atlas_cidr_block)
        pulumi.set(__self__, "aws_account_id", aws_account_id)
        pulumi.set(__self__, "azure_directory_id", azure_directory_id)
        pulumi.set(__self__, "azure_subscription_id", azure_subscription_id)
        pulumi.set(__self__, "connection_id", connection_id)
        pulumi.set(__self__, "container_id", container_id)
        pulumi.set(__self__, "error_message", error_message)
        pulumi.set(__self__, "error_state", error_state)
        pulumi.set(__self__, "error_state_name", error_state_name)
        pulumi.set(__self__, "gcp_project_id", gcp_project_id)
        pulumi.set(__self__, "network_name", network_name)
        pulumi.set(__self__, "peering_id", peering_id)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)
        pulumi.set(__self__, "route_table_cidr_block", route_table_cidr_block)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_name", status_name)
        pulumi.set(__self__, "vnet_name", vnet_name)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="accepterRegionName")
    def accepter_region_name(self) -> str:
        """
        Specifies the region where the peer VPC resides. For complete lists of supported regions, see [Amazon Web Services](https://docs.atlas.mongodb.com/reference/amazon-aws/).
        """
        return pulumi.get(self, "accepter_region_name")

    @property
    @pulumi.getter(name="atlasCidrBlock")
    def atlas_cidr_block(self) -> str:
        return pulumi.get(self, "atlas_cidr_block")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> str:
        """
        Account ID of the owner of the peer VPC.
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="azureDirectoryId")
    def azure_directory_id(self) -> str:
        """
        Unique identifier for an Azure AD directory.
        """
        return pulumi.get(self, "azure_directory_id")

    @property
    @pulumi.getter(name="azureSubscriptionId")
    def azure_subscription_id(self) -> str:
        """
        Unique identifer of the Azure subscription in which the VNet resides.
        """
        return pulumi.get(self, "azure_subscription_id")

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> str:
        """
        Unique identifier for the peering connection.
        """
        return pulumi.get(self, "connection_id")

    @property
    @pulumi.getter(name="containerId")
    def container_id(self) -> str:
        return pulumi.get(self, "container_id")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> str:
        """
        When `"status" : "FAILED"`, Atlas provides a description of the error.
        """
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter(name="errorState")
    def error_state(self) -> str:
        """
        Description of the Atlas error when `status` is `Failed`, Otherwise, Atlas returns `null`.
        """
        return pulumi.get(self, "error_state")

    @property
    @pulumi.getter(name="errorStateName")
    def error_state_name(self) -> str:
        """
        Error state, if any. The VPC peering connection error state value can be one of the following: `REJECTED`, `EXPIRED`, `INVALID_ARGUMENT`.
        """
        return pulumi.get(self, "error_state_name")

    @property
    @pulumi.getter(name="gcpProjectId")
    def gcp_project_id(self) -> str:
        """
        GCP project ID of the owner of the network peer.
        """
        return pulumi.get(self, "gcp_project_id")

    @property
    @pulumi.getter(name="networkName")
    def network_name(self) -> str:
        """
        Name of the network peer to which Atlas connects.
        """
        return pulumi.get(self, "network_name")

    @property
    @pulumi.getter(name="peeringId")
    def peering_id(self) -> str:
        """
        Atlas assigned unique ID for the peering connection.
        """
        return pulumi.get(self, "peering_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Cloud provider for this VPC peering connection. If omitted, Atlas sets this parameter to AWS. (Possible Values `AWS`, `AZURE`, `GCP`).
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> str:
        """
        Name of your Azure resource group.
        """
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter(name="routeTableCidrBlock")
    def route_table_cidr_block(self) -> str:
        """
        Peer VPC CIDR block or subnet.
        """
        return pulumi.get(self, "route_table_cidr_block")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the Atlas network peering connection: `ADDING_PEER`, `AVAILABLE`, `FAILED`, `DELETING`, `WAITING_FOR_USER`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="statusName")
    def status_name(self) -> str:
        """
        The VPC peering connection status value can be one of the following: `INITIATING`, `PENDING_ACCEPTANCE`, `FAILED`, `FINALIZING`, `AVAILABLE`, `TERMINATING`.
        """
        return pulumi.get(self, "status_name")

    @property
    @pulumi.getter(name="vnetName")
    def vnet_name(self) -> str:
        """
        Name of your Azure VNet.
        """
        return pulumi.get(self, "vnet_name")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        Unique identifier of the peer VPC.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetOnlineArchiveCriteriaResult(dict):
    def __init__(__self__, *,
                 date_field: str,
                 date_format: str,
                 expire_after_days: int,
                 query: str,
                 type: str):
        pulumi.set(__self__, "date_field", date_field)
        pulumi.set(__self__, "date_format", date_format)
        pulumi.set(__self__, "expire_after_days", expire_after_days)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="dateField")
    def date_field(self) -> str:
        return pulumi.get(self, "date_field")

    @property
    @pulumi.getter(name="dateFormat")
    def date_format(self) -> str:
        return pulumi.get(self, "date_format")

    @property
    @pulumi.getter(name="expireAfterDays")
    def expire_after_days(self) -> int:
        return pulumi.get(self, "expire_after_days")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetOnlineArchiveDataExpirationRuleResult(dict):
    def __init__(__self__, *,
                 expire_after_days: int):
        pulumi.set(__self__, "expire_after_days", expire_after_days)

    @property
    @pulumi.getter(name="expireAfterDays")
    def expire_after_days(self) -> int:
        return pulumi.get(self, "expire_after_days")


@pulumi.output_type
class GetOnlineArchiveDataProcessRegionResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 region: str):
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetOnlineArchivePartitionFieldResult(dict):
    def __init__(__self__, *,
                 field_name: str,
                 field_type: str,
                 order: int):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "field_type", field_type)
        pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> str:
        return pulumi.get(self, "field_type")

    @property
    @pulumi.getter
    def order(self) -> int:
        return pulumi.get(self, "order")


@pulumi.output_type
class GetOnlineArchiveScheduleResult(dict):
    def __init__(__self__, *,
                 end_hour: int,
                 end_minute: int,
                 start_hour: int,
                 start_minute: int,
                 type: str,
                 day_of_month: Optional[int] = None,
                 day_of_week: Optional[int] = None):
        pulumi.set(__self__, "end_hour", end_hour)
        pulumi.set(__self__, "end_minute", end_minute)
        pulumi.set(__self__, "start_hour", start_hour)
        pulumi.set(__self__, "start_minute", start_minute)
        pulumi.set(__self__, "type", type)
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)

    @property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> int:
        return pulumi.get(self, "end_hour")

    @property
    @pulumi.getter(name="endMinute")
    def end_minute(self) -> int:
        return pulumi.get(self, "end_minute")

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> int:
        return pulumi.get(self, "start_hour")

    @property
    @pulumi.getter(name="startMinute")
    def start_minute(self) -> int:
        return pulumi.get(self, "start_minute")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[int]:
        return pulumi.get(self, "day_of_month")

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[int]:
        return pulumi.get(self, "day_of_week")


@pulumi.output_type
class GetOnlineArchivesResultResult(dict):
    def __init__(__self__, *,
                 archive_id: str,
                 cluster_name: str,
                 coll_name: str,
                 collection_type: str,
                 criterias: Sequence['outputs.GetOnlineArchivesResultCriteriaResult'],
                 data_expiration_rules: Sequence['outputs.GetOnlineArchivesResultDataExpirationRuleResult'],
                 data_process_regions: Sequence['outputs.GetOnlineArchivesResultDataProcessRegionResult'],
                 db_name: str,
                 partition_fields: Sequence['outputs.GetOnlineArchivesResultPartitionFieldResult'],
                 paused: bool,
                 project_id: str,
                 schedules: Sequence['outputs.GetOnlineArchivesResultScheduleResult'],
                 state: str):
        """
        :param str cluster_name: Name of the cluster that contains the collection.
               
               # Attributes Reference
               
               In addition to all arguments above, the following attributes are exported:
        :param str project_id: The unique ID for the project.
        """
        pulumi.set(__self__, "archive_id", archive_id)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "coll_name", coll_name)
        pulumi.set(__self__, "collection_type", collection_type)
        pulumi.set(__self__, "criterias", criterias)
        pulumi.set(__self__, "data_expiration_rules", data_expiration_rules)
        pulumi.set(__self__, "data_process_regions", data_process_regions)
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "partition_fields", partition_fields)
        pulumi.set(__self__, "paused", paused)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "schedules", schedules)
        pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="archiveId")
    def archive_id(self) -> str:
        return pulumi.get(self, "archive_id")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        Name of the cluster that contains the collection.

        # Attributes Reference

        In addition to all arguments above, the following attributes are exported:
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="collName")
    def coll_name(self) -> str:
        return pulumi.get(self, "coll_name")

    @property
    @pulumi.getter(name="collectionType")
    def collection_type(self) -> str:
        return pulumi.get(self, "collection_type")

    @property
    @pulumi.getter
    def criterias(self) -> Sequence['outputs.GetOnlineArchivesResultCriteriaResult']:
        return pulumi.get(self, "criterias")

    @property
    @pulumi.getter(name="dataExpirationRules")
    def data_expiration_rules(self) -> Sequence['outputs.GetOnlineArchivesResultDataExpirationRuleResult']:
        return pulumi.get(self, "data_expiration_rules")

    @property
    @pulumi.getter(name="dataProcessRegions")
    def data_process_regions(self) -> Sequence['outputs.GetOnlineArchivesResultDataProcessRegionResult']:
        return pulumi.get(self, "data_process_regions")

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> str:
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="partitionFields")
    def partition_fields(self) -> Sequence['outputs.GetOnlineArchivesResultPartitionFieldResult']:
        return pulumi.get(self, "partition_fields")

    @property
    @pulumi.getter
    def paused(self) -> bool:
        return pulumi.get(self, "paused")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.GetOnlineArchivesResultScheduleResult']:
        return pulumi.get(self, "schedules")

    @property
    @pulumi.getter
    def state(self) -> str:
        return pulumi.get(self, "state")


@pulumi.output_type
class GetOnlineArchivesResultCriteriaResult(dict):
    def __init__(__self__, *,
                 date_field: str,
                 date_format: str,
                 expire_after_days: int,
                 query: str,
                 type: str):
        pulumi.set(__self__, "date_field", date_field)
        pulumi.set(__self__, "date_format", date_format)
        pulumi.set(__self__, "expire_after_days", expire_after_days)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="dateField")
    def date_field(self) -> str:
        return pulumi.get(self, "date_field")

    @property
    @pulumi.getter(name="dateFormat")
    def date_format(self) -> str:
        return pulumi.get(self, "date_format")

    @property
    @pulumi.getter(name="expireAfterDays")
    def expire_after_days(self) -> int:
        return pulumi.get(self, "expire_after_days")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetOnlineArchivesResultDataExpirationRuleResult(dict):
    def __init__(__self__, *,
                 expire_after_days: int):
        pulumi.set(__self__, "expire_after_days", expire_after_days)

    @property
    @pulumi.getter(name="expireAfterDays")
    def expire_after_days(self) -> int:
        return pulumi.get(self, "expire_after_days")


@pulumi.output_type
class GetOnlineArchivesResultDataProcessRegionResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 region: str):
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetOnlineArchivesResultPartitionFieldResult(dict):
    def __init__(__self__, *,
                 field_name: str,
                 field_type: str,
                 order: int):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "field_type", field_type)
        pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> str:
        return pulumi.get(self, "field_type")

    @property
    @pulumi.getter
    def order(self) -> int:
        return pulumi.get(self, "order")


@pulumi.output_type
class GetOnlineArchivesResultScheduleResult(dict):
    def __init__(__self__, *,
                 end_hour: int,
                 end_minute: int,
                 start_hour: int,
                 start_minute: int,
                 type: str,
                 day_of_month: Optional[int] = None,
                 day_of_week: Optional[int] = None):
        pulumi.set(__self__, "end_hour", end_hour)
        pulumi.set(__self__, "end_minute", end_minute)
        pulumi.set(__self__, "start_hour", start_hour)
        pulumi.set(__self__, "start_minute", start_minute)
        pulumi.set(__self__, "type", type)
        if day_of_month is not None:
            pulumi.set(__self__, "day_of_month", day_of_month)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)

    @property
    @pulumi.getter(name="endHour")
    def end_hour(self) -> int:
        return pulumi.get(self, "end_hour")

    @property
    @pulumi.getter(name="endMinute")
    def end_minute(self) -> int:
        return pulumi.get(self, "end_minute")

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> int:
        return pulumi.get(self, "start_hour")

    @property
    @pulumi.getter(name="startMinute")
    def start_minute(self) -> int:
        return pulumi.get(self, "start_minute")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="dayOfMonth")
    def day_of_month(self) -> Optional[int]:
        return pulumi.get(self, "day_of_month")

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[int]:
        return pulumi.get(self, "day_of_week")


@pulumi.output_type
class GetOrganizationLinkResult(dict):
    def __init__(__self__, *,
                 href: str,
                 rel: str):
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> str:
        return pulumi.get(self, "href")

    @property
    @pulumi.getter
    def rel(self) -> str:
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetOrganizationsResultResult(dict):
    def __init__(__self__, *,
                 api_access_list_required: bool,
                 id: str,
                 is_deleted: bool,
                 links: Sequence['outputs.GetOrganizationsResultLinkResult'],
                 multi_factor_auth_required: bool,
                 name: str,
                 restrict_employee_access: bool):
        """
        :param bool api_access_list_required: Flag that indicates whether to require API operations to originate from an IP Address added to the API access list for the specified organization.
        :param str id: Autogenerated Unique ID for this data source.
        :param bool is_deleted: Flag that indicates whether this organization has been deleted.
        :param bool multi_factor_auth_required: Flag that indicates whether to require users to set up Multi-Factor Authentication (MFA) before accessing the specified organization. To learn more, see: https://www.mongodb.com/docs/atlas/security-multi-factor-authentication/.
        :param str name: Human-readable label that identifies the organization.
        :param bool restrict_employee_access: Flag that indicates whether to block MongoDB Support from accessing Atlas infrastructure for any deployment in the specified organization without explicit permission. Once this setting is turned on, you can grant MongoDB Support a 24-hour bypass access to the Atlas deployment to resolve support issues. To learn more, see: https://www.mongodb.com/docs/atlas/security-restrict-support-access/.
               
               See [MongoDB Atlas API - Organizations](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Organizations/operation/listOrganizations)  Documentation for more information.
        """
        pulumi.set(__self__, "api_access_list_required", api_access_list_required)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_deleted", is_deleted)
        pulumi.set(__self__, "links", links)
        pulumi.set(__self__, "multi_factor_auth_required", multi_factor_auth_required)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "restrict_employee_access", restrict_employee_access)

    @property
    @pulumi.getter(name="apiAccessListRequired")
    def api_access_list_required(self) -> bool:
        """
        Flag that indicates whether to require API operations to originate from an IP Address added to the API access list for the specified organization.
        """
        return pulumi.get(self, "api_access_list_required")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Autogenerated Unique ID for this data source.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isDeleted")
    def is_deleted(self) -> bool:
        """
        Flag that indicates whether this organization has been deleted.
        """
        return pulumi.get(self, "is_deleted")

    @property
    @pulumi.getter
    def links(self) -> Sequence['outputs.GetOrganizationsResultLinkResult']:
        return pulumi.get(self, "links")

    @property
    @pulumi.getter(name="multiFactorAuthRequired")
    def multi_factor_auth_required(self) -> bool:
        """
        Flag that indicates whether to require users to set up Multi-Factor Authentication (MFA) before accessing the specified organization. To learn more, see: https://www.mongodb.com/docs/atlas/security-multi-factor-authentication/.
        """
        return pulumi.get(self, "multi_factor_auth_required")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Human-readable label that identifies the organization.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="restrictEmployeeAccess")
    def restrict_employee_access(self) -> bool:
        """
        Flag that indicates whether to block MongoDB Support from accessing Atlas infrastructure for any deployment in the specified organization without explicit permission. Once this setting is turned on, you can grant MongoDB Support a 24-hour bypass access to the Atlas deployment to resolve support issues. To learn more, see: https://www.mongodb.com/docs/atlas/security-restrict-support-access/.

        See [MongoDB Atlas API - Organizations](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Organizations/operation/listOrganizations)  Documentation for more information.
        """
        return pulumi.get(self, "restrict_employee_access")


@pulumi.output_type
class GetOrganizationsResultLinkResult(dict):
    def __init__(__self__, *,
                 href: str,
                 rel: str):
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> str:
        return pulumi.get(self, "href")

    @property
    @pulumi.getter
    def rel(self) -> str:
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetPrivateLinkEndpointServiceEndpointResult(dict):
    def __init__(__self__, *,
                 endpoint_name: str,
                 ip_address: str,
                 status: str):
        """
        :param str endpoint_name: Forwarding rule that corresponds to the endpoint you created in GCP.
        :param str ip_address: Private IP address of the network endpoint group you created in GCP.
        :param str status: Status of the endpoint. Atlas returns one of the [values shown above](https://docs.atlas.mongodb.com/reference/api/private-endpoints-endpoint-create-one/#std-label-ref-status-field).
        """
        pulumi.set(__self__, "endpoint_name", endpoint_name)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="endpointName")
    def endpoint_name(self) -> str:
        """
        Forwarding rule that corresponds to the endpoint you created in GCP.
        """
        return pulumi.get(self, "endpoint_name")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        Private IP address of the network endpoint group you created in GCP.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the endpoint. Atlas returns one of the [values shown above](https://docs.atlas.mongodb.com/reference/api/private-endpoints-endpoint-create-one/#std-label-ref-status-field).
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetPrivatelinkEndpointServiceDataFederationOnlineArchivesResultResult(dict):
    def __init__(__self__, *,
                 comment: str,
                 customer_endpoint_dns_name: str,
                 endpoint_id: str,
                 provider_name: str,
                 region: str,
                 type: str):
        """
        :param str comment: Human-readable string to associate with this private endpoint.
        :param str customer_endpoint_dns_name: (Optional) Human-readable label to identify VPC endpoint DNS name.
        :param str endpoint_id: Unique 22-character alphanumeric string that identifies the private endpoint. See [Atlas Data Lake supports Amazon Web Services private endpoints using the AWS PrivateLink feature](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation/operation/createDataFederationPrivateEndpoint:~:text=Atlas%20Data%20Lake%20supports%20Amazon%20Web%20Services%20private%20endpoints%20using%20the%20AWS%20PrivateLink%20feature).
        :param str provider_name: Human-readable label that identifies the cloud service provider.
        :param str region: Human-readable label to identify the region of VPC endpoint.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        :param str type: Human-readable label that identifies the resource type associated with this private endpoint.
        """
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "customer_endpoint_dns_name", customer_endpoint_dns_name)
        pulumi.set(__self__, "endpoint_id", endpoint_id)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def comment(self) -> str:
        """
        Human-readable string to associate with this private endpoint.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="customerEndpointDnsName")
    def customer_endpoint_dns_name(self) -> str:
        """
        (Optional) Human-readable label to identify VPC endpoint DNS name.
        """
        return pulumi.get(self, "customer_endpoint_dns_name")

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> str:
        """
        Unique 22-character alphanumeric string that identifies the private endpoint. See [Atlas Data Lake supports Amazon Web Services private endpoints using the AWS PrivateLink feature](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Data-Federation/operation/createDataFederationPrivateEndpoint:~:text=Atlas%20Data%20Lake%20supports%20Amazon%20Web%20Services%20private%20endpoints%20using%20the%20AWS%20PrivateLink%20feature).
        """
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Human-readable label that identifies the cloud service provider.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Human-readable label to identify the region of VPC endpoint.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Human-readable label that identifies the resource type associated with this private endpoint.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetPrivatelinkEndpointsServiceServerlessResultResult(dict):
    def __init__(__self__, *,
                 cloud_provider_endpoint_id: str,
                 comment: str,
                 endpoint_id: str,
                 endpoint_service_name: str,
                 error_message: str,
                 private_endpoint_ip_address: str,
                 private_link_service_resource_id: str,
                 status: str):
        """
        :param str cloud_provider_endpoint_id: Unique string that identifies the private endpoint's network interface.
        :param str comment: Human-readable string to associate with this private endpoint.
        :param str endpoint_id: (Required) Unique 22-character alphanumeric string that identifies the private endpoint. Atlas supports AWS private endpoints using the [AWS PrivateLink](https://aws.amazon.com/privatelink/) feature.
        :param str endpoint_service_name: Unique string that identifies the PrivateLink endpoint service. MongoDB Cloud returns null while it creates the endpoint service.
        :param str private_endpoint_ip_address: IPv4 address of the private endpoint in your Azure VNet that someone added to this private endpoint service.
        :param str private_link_service_resource_id: Root-relative path that identifies the Azure Private Link Service that MongoDB Cloud manages.
        :param str status: Human-readable label that indicates the current operating status of the private endpoint. Values include: RESERVATION_REQUESTED, RESERVED, INITIATING, AVAILABLE, FAILED, DELETING.
        """
        pulumi.set(__self__, "cloud_provider_endpoint_id", cloud_provider_endpoint_id)
        pulumi.set(__self__, "comment", comment)
        pulumi.set(__self__, "endpoint_id", endpoint_id)
        pulumi.set(__self__, "endpoint_service_name", endpoint_service_name)
        pulumi.set(__self__, "error_message", error_message)
        pulumi.set(__self__, "private_endpoint_ip_address", private_endpoint_ip_address)
        pulumi.set(__self__, "private_link_service_resource_id", private_link_service_resource_id)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="cloudProviderEndpointId")
    def cloud_provider_endpoint_id(self) -> str:
        """
        Unique string that identifies the private endpoint's network interface.
        """
        return pulumi.get(self, "cloud_provider_endpoint_id")

    @property
    @pulumi.getter
    def comment(self) -> str:
        """
        Human-readable string to associate with this private endpoint.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> str:
        """
        (Required) Unique 22-character alphanumeric string that identifies the private endpoint. Atlas supports AWS private endpoints using the [AWS PrivateLink](https://aws.amazon.com/privatelink/) feature.
        """
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="endpointServiceName")
    def endpoint_service_name(self) -> str:
        """
        Unique string that identifies the PrivateLink endpoint service. MongoDB Cloud returns null while it creates the endpoint service.
        """
        return pulumi.get(self, "endpoint_service_name")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> str:
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter(name="privateEndpointIpAddress")
    def private_endpoint_ip_address(self) -> str:
        """
        IPv4 address of the private endpoint in your Azure VNet that someone added to this private endpoint service.
        """
        return pulumi.get(self, "private_endpoint_ip_address")

    @property
    @pulumi.getter(name="privateLinkServiceResourceId")
    def private_link_service_resource_id(self) -> str:
        """
        Root-relative path that identifies the Azure Private Link Service that MongoDB Cloud manages.
        """
        return pulumi.get(self, "private_link_service_resource_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Human-readable label that indicates the current operating status of the private endpoint. Values include: RESERVATION_REQUESTED, RESERVED, INITIATING, AVAILABLE, FAILED, DELETING.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetProjectApiKeyProjectAssignmentResult(dict):
    def __init__(__self__, *,
                 project_id: str,
                 role_names: Sequence[str]):
        """
        :param str project_id: The unique ID for the project.
        :param Sequence[str] role_names: List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project. You must specify an array even if you are only associating a single role with the Programmatic API key. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) describes the valid roles that can be assigned.
        """
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "role_names", role_names)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[str]:
        """
        List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project. You must specify an array even if you are only associating a single role with the Programmatic API key. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) describes the valid roles that can be assigned.
        """
        return pulumi.get(self, "role_names")


@pulumi.output_type
class GetProjectApiKeysResultResult(dict):
    def __init__(__self__, *,
                 api_key_id: str,
                 description: str,
                 private_key: str,
                 public_key: str,
                 project_assignments: Optional[Sequence['outputs.GetProjectApiKeysResultProjectAssignmentResult']] = None):
        """
        :param str api_key_id: Unique identifier for the API key you want to update. Use the /orgs/{ORG-ID}/apiKeys endpoint to retrieve all API keys to which the authenticated user has access for the specified organization.
        :param str description: Description of this Project API key.
        """
        pulumi.set(__self__, "api_key_id", api_key_id)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "public_key", public_key)
        if project_assignments is not None:
            pulumi.set(__self__, "project_assignments", project_assignments)

    @property
    @pulumi.getter(name="apiKeyId")
    def api_key_id(self) -> str:
        """
        Unique identifier for the API key you want to update. Use the /orgs/{ORG-ID}/apiKeys endpoint to retrieve all API keys to which the authenticated user has access for the specified organization.
        """
        return pulumi.get(self, "api_key_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of this Project API key.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> str:
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter(name="projectAssignments")
    def project_assignments(self) -> Optional[Sequence['outputs.GetProjectApiKeysResultProjectAssignmentResult']]:
        return pulumi.get(self, "project_assignments")


@pulumi.output_type
class GetProjectApiKeysResultProjectAssignmentResult(dict):
    def __init__(__self__, *,
                 project_id: str,
                 role_names: Sequence[str]):
        """
        :param str project_id: The unique ID for the project.
        :param Sequence[str] role_names: List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project. You must specify an array even if you are only associating a single role with the Programmatic API key. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) describes the valid roles that can be assigned.
        """
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "role_names", role_names)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[str]:
        """
        List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project. You must specify an array even if you are only associating a single role with the Programmatic API key. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) describes the valid roles that can be assigned.
        """
        return pulumi.get(self, "role_names")


@pulumi.output_type
class GetProjectIpAddressesResult(dict):
    def __init__(__self__, *,
                 services: 'outputs.GetProjectIpAddressesServicesResult'):
        pulumi.set(__self__, "services", services)

    @property
    @pulumi.getter
    def services(self) -> 'outputs.GetProjectIpAddressesServicesResult':
        return pulumi.get(self, "services")


@pulumi.output_type
class GetProjectIpAddressesServicesResult(dict):
    def __init__(__self__, *,
                 clusters: Sequence['outputs.GetProjectIpAddressesServicesClusterResult']):
        """
        :param Sequence['GetProjectIpAddressesServicesClusterArgs'] clusters: IP addresses of clusters.
        """
        pulumi.set(__self__, "clusters", clusters)

    @property
    @pulumi.getter
    def clusters(self) -> Sequence['outputs.GetProjectIpAddressesServicesClusterResult']:
        """
        IP addresses of clusters.
        """
        return pulumi.get(self, "clusters")


@pulumi.output_type
class GetProjectIpAddressesServicesClusterResult(dict):
    def __init__(__self__, *,
                 cluster_name: str,
                 inbounds: Sequence[str],
                 outbounds: Sequence[str]):
        """
        :param str cluster_name: Human-readable label that identifies the cluster.
        :param Sequence[str] inbounds: List of inbound IP addresses associated with the cluster. If your network allows outbound HTTP requests only to specific IP addresses, you must allow access to the following IP addresses so that your application can connect to your Atlas cluster.
        :param Sequence[str] outbounds: List of outbound IP addresses associated with the cluster. If your network allows inbound HTTP requests only from specific IP addresses, you must allow access from the following IP addresses so that your Atlas cluster can communicate with your webhooks and KMS.
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "inbounds", inbounds)
        pulumi.set(__self__, "outbounds", outbounds)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        Human-readable label that identifies the cluster.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter
    def inbounds(self) -> Sequence[str]:
        """
        List of inbound IP addresses associated with the cluster. If your network allows outbound HTTP requests only to specific IP addresses, you must allow access to the following IP addresses so that your application can connect to your Atlas cluster.
        """
        return pulumi.get(self, "inbounds")

    @property
    @pulumi.getter
    def outbounds(self) -> Sequence[str]:
        """
        List of outbound IP addresses associated with the cluster. If your network allows inbound HTTP requests only from specific IP addresses, you must allow access from the following IP addresses so that your Atlas cluster can communicate with your webhooks and KMS.
        """
        return pulumi.get(self, "outbounds")


@pulumi.output_type
class GetProjectLimitResult(dict):
    def __init__(__self__, *,
                 current_usage: int,
                 default_limit: int,
                 maximum_limit: int,
                 name: str,
                 value: int):
        """
        :param int current_usage: Amount that indicates the current usage of the limit.
        :param int default_limit: Default value of the limit.
        :param int maximum_limit: Maximum value of the limit.
        :param str name: The unique ID for the project.
               
               > **IMPORTANT:** Either `project_id` or `name` must be configurated.
        :param int value: Amount the limit is set to.
        """
        pulumi.set(__self__, "current_usage", current_usage)
        pulumi.set(__self__, "default_limit", default_limit)
        pulumi.set(__self__, "maximum_limit", maximum_limit)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="currentUsage")
    def current_usage(self) -> int:
        """
        Amount that indicates the current usage of the limit.
        """
        return pulumi.get(self, "current_usage")

    @property
    @pulumi.getter(name="defaultLimit")
    def default_limit(self) -> int:
        """
        Default value of the limit.
        """
        return pulumi.get(self, "default_limit")

    @property
    @pulumi.getter(name="maximumLimit")
    def maximum_limit(self) -> int:
        """
        Maximum value of the limit.
        """
        return pulumi.get(self, "maximum_limit")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The unique ID for the project.

        > **IMPORTANT:** Either `project_id` or `name` must be configurated.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Amount the limit is set to.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetProjectTeamResult(dict):
    def __init__(__self__, *,
                 role_names: Sequence[str],
                 team_id: str):
        """
        :param Sequence[str] role_names: Each string in the array represents a project role assigned to the team. Every user associated with the team inherits these roles. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles a user can have.
        :param str team_id: The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
        """
        pulumi.set(__self__, "role_names", role_names)
        pulumi.set(__self__, "team_id", team_id)

    @property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[str]:
        """
        Each string in the array represents a project role assigned to the team. Every user associated with the team inherits these roles. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles a user can have.
        """
        return pulumi.get(self, "role_names")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> str:
        """
        The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
        """
        return pulumi.get(self, "team_id")


@pulumi.output_type
class GetProjectsResultResult(dict):
    def __init__(__self__, *,
                 cluster_count: int,
                 created: str,
                 id: str,
                 ip_addresses: 'outputs.GetProjectsResultIpAddressesResult',
                 is_collect_database_specifics_statistics_enabled: bool,
                 is_data_explorer_enabled: bool,
                 is_extended_storage_sizes_enabled: bool,
                 is_performance_advisor_enabled: bool,
                 is_realtime_performance_panel_enabled: bool,
                 is_schema_advisor_enabled: bool,
                 is_slow_operation_thresholding_enabled: bool,
                 limits: Sequence['outputs.GetProjectsResultLimitResult'],
                 name: str,
                 org_id: str,
                 project_id: str,
                 region_usage_restrictions: str,
                 tags: Mapping[str, str],
                 teams: Sequence['outputs.GetProjectsResultTeamResult']):
        """
        :param int cluster_count: The number of Atlas clusters deployed in the project.
        :param str created: The ISO-8601-formatted timestamp of when Atlas created the project.
        :param str id: Autogenerated Unique ID for this data source.
        :param 'GetProjectsResultIpAddressesArgs' ip_addresses: IP addresses in a project categorized by services. See IP Addresses. **WARNING:** this attribute is deprecated and will be removed in version 1.21.0. Use the `get_project_ip_addresses` data source instead.
        :param bool is_collect_database_specifics_statistics_enabled: Flag that indicates whether to enable statistics in [cluster metrics](https://www.mongodb.com/docs/atlas/monitor-cluster-metrics/) collection for the project.
        :param bool is_data_explorer_enabled: Flag that indicates whether to enable Data Explorer for the project. If enabled, you can query your database with an easy to use interface.
        :param bool is_extended_storage_sizes_enabled: Flag that indicates whether to enable extended storage sizes for the specified project.
        :param bool is_performance_advisor_enabled: Flag that indicates whether to enable Performance Advisor and Profiler for the project. If enabled, you can analyze database logs to recommend performance improvements.
        :param bool is_realtime_performance_panel_enabled: Flag that indicates whether to enable Real Time Performance Panel for the project. If enabled, you can see real time metrics from your MongoDB database.
        :param bool is_schema_advisor_enabled: Flag that indicates whether to enable Schema Advisor for the project. If enabled, you receive customized recommendations to optimize your data model and enhance performance. Disable this setting to disable schema suggestions in the [Performance Advisor](https://www.mongodb.com/docs/atlas/performance-advisor/#std-label-performance-advisor) and the [Data Explorer](https://www.mongodb.com/docs/atlas/atlas-ui/#std-label-atlas-ui).
        :param bool is_slow_operation_thresholding_enabled: Flag that enables MongoDB Cloud to use its slow operation threshold for the specified project. The threshold determines which operations the Performance Advisor and Query Profiler considers slow. When enabled, MongoDB Cloud uses the average execution time for operations on your cluster to determine slow-running queries. As a result, the threshold is more pertinent to your cluster workload. The slow operation threshold is enabled by default for dedicated clusters (M10+). When disabled, MongoDB Cloud considers any operation that takes longer than 100 milliseconds to be slow. **Note**: To use this attribute, the requesting API Key must have the Project Owner role, if not it will show a warning and will return `false`. If you are not using this field, you don't need to take any action.
        :param Sequence['GetProjectsResultLimitArgs'] limits: The limits for the specified project. See Limits.
        :param str org_id: The ID of the organization you want to create the project within.
        :param str region_usage_restrictions: If GOV_REGIONS_ONLY the project can be used for government regions only, otherwise defaults to standard regions. For more information see [MongoDB Atlas for Government](https://www.mongodb.com/docs/atlas/government/api/#creating-a-project).
        :param Mapping[str, str] tags: Map that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the project. To learn more, see [Resource Tags](https://www.mongodb.com/docs/atlas/tags/)
        :param Sequence['GetProjectsResultTeamArgs'] teams: Returns all teams to which the authenticated user has access in the project. See Teams.
        """
        pulumi.set(__self__, "cluster_count", cluster_count)
        pulumi.set(__self__, "created", created)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip_addresses", ip_addresses)
        pulumi.set(__self__, "is_collect_database_specifics_statistics_enabled", is_collect_database_specifics_statistics_enabled)
        pulumi.set(__self__, "is_data_explorer_enabled", is_data_explorer_enabled)
        pulumi.set(__self__, "is_extended_storage_sizes_enabled", is_extended_storage_sizes_enabled)
        pulumi.set(__self__, "is_performance_advisor_enabled", is_performance_advisor_enabled)
        pulumi.set(__self__, "is_realtime_performance_panel_enabled", is_realtime_performance_panel_enabled)
        pulumi.set(__self__, "is_schema_advisor_enabled", is_schema_advisor_enabled)
        pulumi.set(__self__, "is_slow_operation_thresholding_enabled", is_slow_operation_thresholding_enabled)
        pulumi.set(__self__, "limits", limits)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "region_usage_restrictions", region_usage_restrictions)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="clusterCount")
    def cluster_count(self) -> int:
        """
        The number of Atlas clusters deployed in the project.
        """
        return pulumi.get(self, "cluster_count")

    @property
    @pulumi.getter
    def created(self) -> str:
        """
        The ISO-8601-formatted timestamp of when Atlas created the project.
        """
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Autogenerated Unique ID for this data source.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddresses")
    @_utilities.deprecated("""This parameter is deprecated and will be removed in version 1.21.0. Please transition to get_project_ip_addresses data source.""")
    def ip_addresses(self) -> 'outputs.GetProjectsResultIpAddressesResult':
        """
        IP addresses in a project categorized by services. See IP Addresses. **WARNING:** this attribute is deprecated and will be removed in version 1.21.0. Use the `get_project_ip_addresses` data source instead.
        """
        return pulumi.get(self, "ip_addresses")

    @property
    @pulumi.getter(name="isCollectDatabaseSpecificsStatisticsEnabled")
    def is_collect_database_specifics_statistics_enabled(self) -> bool:
        """
        Flag that indicates whether to enable statistics in [cluster metrics](https://www.mongodb.com/docs/atlas/monitor-cluster-metrics/) collection for the project.
        """
        return pulumi.get(self, "is_collect_database_specifics_statistics_enabled")

    @property
    @pulumi.getter(name="isDataExplorerEnabled")
    def is_data_explorer_enabled(self) -> bool:
        """
        Flag that indicates whether to enable Data Explorer for the project. If enabled, you can query your database with an easy to use interface.
        """
        return pulumi.get(self, "is_data_explorer_enabled")

    @property
    @pulumi.getter(name="isExtendedStorageSizesEnabled")
    def is_extended_storage_sizes_enabled(self) -> bool:
        """
        Flag that indicates whether to enable extended storage sizes for the specified project.
        """
        return pulumi.get(self, "is_extended_storage_sizes_enabled")

    @property
    @pulumi.getter(name="isPerformanceAdvisorEnabled")
    def is_performance_advisor_enabled(self) -> bool:
        """
        Flag that indicates whether to enable Performance Advisor and Profiler for the project. If enabled, you can analyze database logs to recommend performance improvements.
        """
        return pulumi.get(self, "is_performance_advisor_enabled")

    @property
    @pulumi.getter(name="isRealtimePerformancePanelEnabled")
    def is_realtime_performance_panel_enabled(self) -> bool:
        """
        Flag that indicates whether to enable Real Time Performance Panel for the project. If enabled, you can see real time metrics from your MongoDB database.
        """
        return pulumi.get(self, "is_realtime_performance_panel_enabled")

    @property
    @pulumi.getter(name="isSchemaAdvisorEnabled")
    def is_schema_advisor_enabled(self) -> bool:
        """
        Flag that indicates whether to enable Schema Advisor for the project. If enabled, you receive customized recommendations to optimize your data model and enhance performance. Disable this setting to disable schema suggestions in the [Performance Advisor](https://www.mongodb.com/docs/atlas/performance-advisor/#std-label-performance-advisor) and the [Data Explorer](https://www.mongodb.com/docs/atlas/atlas-ui/#std-label-atlas-ui).
        """
        return pulumi.get(self, "is_schema_advisor_enabled")

    @property
    @pulumi.getter(name="isSlowOperationThresholdingEnabled")
    @_utilities.deprecated("""This parameter is deprecated and will be removed in version 1.24.0.""")
    def is_slow_operation_thresholding_enabled(self) -> bool:
        """
        Flag that enables MongoDB Cloud to use its slow operation threshold for the specified project. The threshold determines which operations the Performance Advisor and Query Profiler considers slow. When enabled, MongoDB Cloud uses the average execution time for operations on your cluster to determine slow-running queries. As a result, the threshold is more pertinent to your cluster workload. The slow operation threshold is enabled by default for dedicated clusters (M10+). When disabled, MongoDB Cloud considers any operation that takes longer than 100 milliseconds to be slow. **Note**: To use this attribute, the requesting API Key must have the Project Owner role, if not it will show a warning and will return `false`. If you are not using this field, you don't need to take any action.
        """
        return pulumi.get(self, "is_slow_operation_thresholding_enabled")

    @property
    @pulumi.getter
    def limits(self) -> Sequence['outputs.GetProjectsResultLimitResult']:
        """
        The limits for the specified project. See Limits.
        """
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        The ID of the organization you want to create the project within.
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="regionUsageRestrictions")
    def region_usage_restrictions(self) -> str:
        """
        If GOV_REGIONS_ONLY the project can be used for government regions only, otherwise defaults to standard regions. For more information see [MongoDB Atlas for Government](https://www.mongodb.com/docs/atlas/government/api/#creating-a-project).
        """
        return pulumi.get(self, "region_usage_restrictions")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, str]:
        """
        Map that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the project. To learn more, see [Resource Tags](https://www.mongodb.com/docs/atlas/tags/)
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def teams(self) -> Sequence['outputs.GetProjectsResultTeamResult']:
        """
        Returns all teams to which the authenticated user has access in the project. See Teams.
        """
        return pulumi.get(self, "teams")


@pulumi.output_type
class GetProjectsResultIpAddressesResult(dict):
    def __init__(__self__, *,
                 services: 'outputs.GetProjectsResultIpAddressesServicesResult'):
        pulumi.set(__self__, "services", services)

    @property
    @pulumi.getter
    def services(self) -> 'outputs.GetProjectsResultIpAddressesServicesResult':
        return pulumi.get(self, "services")


@pulumi.output_type
class GetProjectsResultIpAddressesServicesResult(dict):
    def __init__(__self__, *,
                 clusters: Sequence['outputs.GetProjectsResultIpAddressesServicesClusterResult']):
        pulumi.set(__self__, "clusters", clusters)

    @property
    @pulumi.getter
    def clusters(self) -> Sequence['outputs.GetProjectsResultIpAddressesServicesClusterResult']:
        return pulumi.get(self, "clusters")


@pulumi.output_type
class GetProjectsResultIpAddressesServicesClusterResult(dict):
    def __init__(__self__, *,
                 cluster_name: str,
                 inbounds: Sequence[str],
                 outbounds: Sequence[str]):
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "inbounds", inbounds)
        pulumi.set(__self__, "outbounds", outbounds)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter
    def inbounds(self) -> Sequence[str]:
        return pulumi.get(self, "inbounds")

    @property
    @pulumi.getter
    def outbounds(self) -> Sequence[str]:
        return pulumi.get(self, "outbounds")


@pulumi.output_type
class GetProjectsResultLimitResult(dict):
    def __init__(__self__, *,
                 current_usage: int,
                 default_limit: int,
                 maximum_limit: int,
                 name: str,
                 value: int):
        """
        :param int current_usage: Amount that indicates the current usage of the limit.
        :param int default_limit: Default value of the limit.
        :param int maximum_limit: Maximum value of the limit.
        :param str name: Human-readable label that identifies this project limit.
        :param int value: Amount the limit is set to.
        """
        pulumi.set(__self__, "current_usage", current_usage)
        pulumi.set(__self__, "default_limit", default_limit)
        pulumi.set(__self__, "maximum_limit", maximum_limit)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="currentUsage")
    def current_usage(self) -> int:
        """
        Amount that indicates the current usage of the limit.
        """
        return pulumi.get(self, "current_usage")

    @property
    @pulumi.getter(name="defaultLimit")
    def default_limit(self) -> int:
        """
        Default value of the limit.
        """
        return pulumi.get(self, "default_limit")

    @property
    @pulumi.getter(name="maximumLimit")
    def maximum_limit(self) -> int:
        """
        Maximum value of the limit.
        """
        return pulumi.get(self, "maximum_limit")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Human-readable label that identifies this project limit.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Amount the limit is set to.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetProjectsResultTeamResult(dict):
    def __init__(__self__, *,
                 role_names: Sequence[str],
                 team_id: str):
        """
        :param Sequence[str] role_names: Each string in the array represents a project role assigned to the team. Every user associated with the team inherits these roles. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles a user can have.
        :param str team_id: The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
        """
        pulumi.set(__self__, "role_names", role_names)
        pulumi.set(__self__, "team_id", team_id)

    @property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[str]:
        """
        Each string in the array represents a project role assigned to the team. Every user associated with the team inherits these roles. The [MongoDB Documentation](https://www.mongodb.com/docs/atlas/reference/user-roles/#organization-roles) describes the roles a user can have.
        """
        return pulumi.get(self, "role_names")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> str:
        """
        The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
        """
        return pulumi.get(self, "team_id")


@pulumi.output_type
class GetSearchDeploymentSpecResult(dict):
    def __init__(__self__, *,
                 instance_size: str,
                 node_count: int):
        """
        :param str instance_size: Hardware specification for the search node instance sizes. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Atlas-Search/operation/createAtlasSearchDeployment) describes the valid values. More details can also be found in the [Search Node Documentation](https://www.mongodb.com/docs/atlas/cluster-config/multi-cloud-distribution/#search-tier).
        :param int node_count: Number of search nodes in the cluster.
        """
        pulumi.set(__self__, "instance_size", instance_size)
        pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> str:
        """
        Hardware specification for the search node instance sizes. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Atlas-Search/operation/createAtlasSearchDeployment) describes the valid values. More details can also be found in the [Search Node Documentation](https://www.mongodb.com/docs/atlas/cluster-config/multi-cloud-distribution/#search-tier).
        """
        return pulumi.get(self, "instance_size")

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> int:
        """
        Number of search nodes in the cluster.
        """
        return pulumi.get(self, "node_count")


@pulumi.output_type
class GetSearchIndexSynonymResult(dict):
    def __init__(__self__, *,
                 analyzer: str,
                 name: str,
                 source_collection: str):
        """
        :param str analyzer: [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.
        :param str name: Name of the index.
        """
        pulumi.set(__self__, "analyzer", analyzer)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source_collection", source_collection)

    @property
    @pulumi.getter
    def analyzer(self) -> str:
        """
        [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.
        """
        return pulumi.get(self, "analyzer")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the index.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sourceCollection")
    def source_collection(self) -> str:
        return pulumi.get(self, "source_collection")


@pulumi.output_type
class GetSearchIndexesResultResult(dict):
    def __init__(__self__, *,
                 analyzer: str,
                 analyzers: str,
                 cluster_name: str,
                 collection_name: str,
                 database: str,
                 fields: str,
                 index_id: str,
                 mappings_dynamic: bool,
                 mappings_fields: str,
                 name: str,
                 project_id: str,
                 search_analyzer: str,
                 status: str,
                 stored_source: str,
                 synonyms: Sequence['outputs.GetSearchIndexesResultSynonymResult'],
                 type: str):
        """
        :param str analyzer: [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.
        :param str analyzers: [Custom analyzers](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-custom-analyzers) to use in this index (this is an array of objects).
        :param str cluster_name: Name of the cluster containing the collection with one or more Atlas Search indexes.
        :param str collection_name: Name of the collection with one or more Atlas Search indexes.
        :param str database: (Required) Name of the database the collection is in.
        :param str index_id: The unique identifier of the Atlas Search index.
        :param bool mappings_dynamic: Flag indicating whether the index uses dynamic or static mappings.
        :param str mappings_fields: Object containing one or more field specifications.
        :param str name: Name of the index.
        :param str project_id: Unique identifier for the [project](https://docs.atlas.mongodb.com/organizations-projects/#std-label-projects) that contains the specified cluster.
        :param str search_analyzer: [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when searching the index.
        :param str status: Current status of the index.
        :param str stored_source: String that can be "true" (store all fields), "false" (default, don't store any field), or a JSON string that contains the list of fields to store (include) or not store (exclude) on Atlas Search. To learn more, see [Stored Source Fields](https://www.mongodb.com/docs/atlas/atlas-search/stored-source-definition/).
        :param Sequence['GetSearchIndexesResultSynonymArgs'] synonyms: Synonyms mapping definition to use in this index.
               * `synonyms.#.name` - Name of the [synonym mapping definition](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-ref).
               * `synonyms.#.source_collection` - Name of the source MongoDB collection for the synonyms.
               * `synonyms.#.analyzer` - Name of the [analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use with this synonym mapping.
        """
        pulumi.set(__self__, "analyzer", analyzer)
        pulumi.set(__self__, "analyzers", analyzers)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "fields", fields)
        pulumi.set(__self__, "index_id", index_id)
        pulumi.set(__self__, "mappings_dynamic", mappings_dynamic)
        pulumi.set(__self__, "mappings_fields", mappings_fields)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "search_analyzer", search_analyzer)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "stored_source", stored_source)
        pulumi.set(__self__, "synonyms", synonyms)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def analyzer(self) -> str:
        """
        [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.
        """
        return pulumi.get(self, "analyzer")

    @property
    @pulumi.getter
    def analyzers(self) -> str:
        """
        [Custom analyzers](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-custom-analyzers) to use in this index (this is an array of objects).
        """
        return pulumi.get(self, "analyzers")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        Name of the cluster containing the collection with one or more Atlas Search indexes.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> str:
        """
        Name of the collection with one or more Atlas Search indexes.
        """
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter
    def database(self) -> str:
        """
        (Required) Name of the database the collection is in.
        """
        return pulumi.get(self, "database")

    @property
    @pulumi.getter
    def fields(self) -> str:
        return pulumi.get(self, "fields")

    @property
    @pulumi.getter(name="indexId")
    def index_id(self) -> str:
        """
        The unique identifier of the Atlas Search index.
        """
        return pulumi.get(self, "index_id")

    @property
    @pulumi.getter(name="mappingsDynamic")
    def mappings_dynamic(self) -> bool:
        """
        Flag indicating whether the index uses dynamic or static mappings.
        """
        return pulumi.get(self, "mappings_dynamic")

    @property
    @pulumi.getter(name="mappingsFields")
    def mappings_fields(self) -> str:
        """
        Object containing one or more field specifications.
        """
        return pulumi.get(self, "mappings_fields")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the index.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Unique identifier for the [project](https://docs.atlas.mongodb.com/organizations-projects/#std-label-projects) that contains the specified cluster.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="searchAnalyzer")
    def search_analyzer(self) -> str:
        """
        [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when searching the index.
        """
        return pulumi.get(self, "search_analyzer")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Current status of the index.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="storedSource")
    def stored_source(self) -> str:
        """
        String that can be "true" (store all fields), "false" (default, don't store any field), or a JSON string that contains the list of fields to store (include) or not store (exclude) on Atlas Search. To learn more, see [Stored Source Fields](https://www.mongodb.com/docs/atlas/atlas-search/stored-source-definition/).
        """
        return pulumi.get(self, "stored_source")

    @property
    @pulumi.getter
    def synonyms(self) -> Sequence['outputs.GetSearchIndexesResultSynonymResult']:
        """
        Synonyms mapping definition to use in this index.
        * `synonyms.#.name` - Name of the [synonym mapping definition](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-ref).
        * `synonyms.#.source_collection` - Name of the source MongoDB collection for the synonyms.
        * `synonyms.#.analyzer` - Name of the [analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use with this synonym mapping.
        """
        return pulumi.get(self, "synonyms")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetSearchIndexesResultSynonymResult(dict):
    def __init__(__self__, *,
                 analyzer: str,
                 name: str,
                 source_collection: str):
        """
        :param str analyzer: [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.
        :param str name: Name of the index.
        """
        pulumi.set(__self__, "analyzer", analyzer)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source_collection", source_collection)

    @property
    @pulumi.getter
    def analyzer(self) -> str:
        """
        [Analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use when creating the index.
        """
        return pulumi.get(self, "analyzer")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the index.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sourceCollection")
    def source_collection(self) -> str:
        return pulumi.get(self, "source_collection")


@pulumi.output_type
class GetServerlessInstanceLinkResult(dict):
    def __init__(__self__, *,
                 href: str,
                 rel: str):
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> str:
        return pulumi.get(self, "href")

    @property
    @pulumi.getter
    def rel(self) -> str:
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetServerlessInstanceTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Constant that defines the set of the tag.
        :param str value: Variable that belongs to the set of the tag.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Constant that defines the set of the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Variable that belongs to the set of the tag.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetServerlessInstancesResultResult(dict):
    def __init__(__self__, *,
                 auto_indexing: bool,
                 connection_strings_private_endpoint_srvs: Sequence[str],
                 connection_strings_standard_srv: str,
                 continuous_backup_enabled: bool,
                 create_date: str,
                 id: str,
                 links: Sequence['outputs.GetServerlessInstancesResultLinkResult'],
                 mongo_db_version: str,
                 name: str,
                 project_id: str,
                 provider_settings_backing_provider_name: str,
                 provider_settings_provider_name: str,
                 provider_settings_region_name: str,
                 state_name: str,
                 tags: Sequence['outputs.GetServerlessInstancesResultTagResult'],
                 termination_protection_enabled: bool):
        """
        :param bool auto_indexing: Flag that indicates whether the serverless instance uses [Serverless Auto Indexing](https://www.mongodb.com/docs/atlas/performance-advisor/auto-index-serverless/).
        :param str connection_strings_standard_srv: Public `mongodb+srv://` connection string that you can use to connect to this serverless instance.
        :param bool continuous_backup_enabled: Flag that indicates whether the serverless instance uses Serverless Continuous Backup.
        :param str id: Unique 24-hexadecimal digit string that identifies the serverless instance.
        :param str mongo_db_version: Version of MongoDB that the serverless instance runs, in `<major version>`.`<minor version>` format.
        :param str name: (Required) Human-readable label that identifies your serverless instance.
        :param str project_id: Unique identifier for the [project](https://docs.atlas.mongodb.com/organizations-projects/#std-label-projects) that contains the specified cluster.
        :param str provider_settings_backing_provider_name: Cloud service provider on which MongoDB Cloud provisioned the serverless instance.
        :param str provider_settings_provider_name: Cloud service provider that applies to the provisioned the serverless instance.
        :param str provider_settings_region_name: Human-readable label that identifies the physical location of your MongoDB serverless instance. The region you choose can affect network latency for clients accessing your databases.
        :param str state_name: Stage of deployment of this serverless instance when the resource made its request.
        :param Sequence['GetServerlessInstancesResultTagArgs'] tags: Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.
        :param bool termination_protection_enabled: Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.
        """
        pulumi.set(__self__, "auto_indexing", auto_indexing)
        pulumi.set(__self__, "connection_strings_private_endpoint_srvs", connection_strings_private_endpoint_srvs)
        pulumi.set(__self__, "connection_strings_standard_srv", connection_strings_standard_srv)
        pulumi.set(__self__, "continuous_backup_enabled", continuous_backup_enabled)
        pulumi.set(__self__, "create_date", create_date)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "links", links)
        pulumi.set(__self__, "mongo_db_version", mongo_db_version)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "provider_settings_backing_provider_name", provider_settings_backing_provider_name)
        pulumi.set(__self__, "provider_settings_provider_name", provider_settings_provider_name)
        pulumi.set(__self__, "provider_settings_region_name", provider_settings_region_name)
        pulumi.set(__self__, "state_name", state_name)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "termination_protection_enabled", termination_protection_enabled)

    @property
    @pulumi.getter(name="autoIndexing")
    def auto_indexing(self) -> bool:
        """
        Flag that indicates whether the serverless instance uses [Serverless Auto Indexing](https://www.mongodb.com/docs/atlas/performance-advisor/auto-index-serverless/).
        """
        return pulumi.get(self, "auto_indexing")

    @property
    @pulumi.getter(name="connectionStringsPrivateEndpointSrvs")
    def connection_strings_private_endpoint_srvs(self) -> Sequence[str]:
        return pulumi.get(self, "connection_strings_private_endpoint_srvs")

    @property
    @pulumi.getter(name="connectionStringsStandardSrv")
    def connection_strings_standard_srv(self) -> str:
        """
        Public `mongodb+srv://` connection string that you can use to connect to this serverless instance.
        """
        return pulumi.get(self, "connection_strings_standard_srv")

    @property
    @pulumi.getter(name="continuousBackupEnabled")
    def continuous_backup_enabled(self) -> bool:
        """
        Flag that indicates whether the serverless instance uses Serverless Continuous Backup.
        """
        return pulumi.get(self, "continuous_backup_enabled")

    @property
    @pulumi.getter(name="createDate")
    def create_date(self) -> str:
        return pulumi.get(self, "create_date")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies the serverless instance.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def links(self) -> Sequence['outputs.GetServerlessInstancesResultLinkResult']:
        return pulumi.get(self, "links")

    @property
    @pulumi.getter(name="mongoDbVersion")
    def mongo_db_version(self) -> str:
        """
        Version of MongoDB that the serverless instance runs, in `<major version>`.`<minor version>` format.
        """
        return pulumi.get(self, "mongo_db_version")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        (Required) Human-readable label that identifies your serverless instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Unique identifier for the [project](https://docs.atlas.mongodb.com/organizations-projects/#std-label-projects) that contains the specified cluster.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="providerSettingsBackingProviderName")
    def provider_settings_backing_provider_name(self) -> str:
        """
        Cloud service provider on which MongoDB Cloud provisioned the serverless instance.
        """
        return pulumi.get(self, "provider_settings_backing_provider_name")

    @property
    @pulumi.getter(name="providerSettingsProviderName")
    def provider_settings_provider_name(self) -> str:
        """
        Cloud service provider that applies to the provisioned the serverless instance.
        """
        return pulumi.get(self, "provider_settings_provider_name")

    @property
    @pulumi.getter(name="providerSettingsRegionName")
    def provider_settings_region_name(self) -> str:
        """
        Human-readable label that identifies the physical location of your MongoDB serverless instance. The region you choose can affect network latency for clients accessing your databases.
        """
        return pulumi.get(self, "provider_settings_region_name")

    @property
    @pulumi.getter(name="stateName")
    def state_name(self) -> str:
        """
        Stage of deployment of this serverless instance when the resource made its request.
        """
        return pulumi.get(self, "state_name")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetServerlessInstancesResultTagResult']:
        """
        Set that contains key-value pairs between 1 to 255 characters in length for tagging and categorizing the cluster. See below.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="terminationProtectionEnabled")
    def termination_protection_enabled(self) -> bool:
        """
        Flag that indicates whether termination protection is enabled on the cluster. If set to true, MongoDB Cloud won't delete the cluster. If set to false, MongoDB Cloud will delete the cluster.
        """
        return pulumi.get(self, "termination_protection_enabled")


@pulumi.output_type
class GetServerlessInstancesResultLinkResult(dict):
    def __init__(__self__, *,
                 href: str,
                 rel: str):
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> str:
        return pulumi.get(self, "href")

    @property
    @pulumi.getter
    def rel(self) -> str:
        return pulumi.get(self, "rel")


@pulumi.output_type
class GetServerlessInstancesResultTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Constant that defines the set of the tag.
        :param str value: Variable that belongs to the set of the tag.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Constant that defines the set of the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Variable that belongs to the set of the tag.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetSharedTierRestoreJobsResultResult(dict):
    def __init__(__self__, *,
                 delivery_type: str,
                 expiration_date: str,
                 job_id: str,
                 restore_finished_date: str,
                 restore_scheduled_date: str,
                 snapshot_finished_date: str,
                 snapshot_id: str,
                 snapshot_url: str,
                 status: str,
                 target_deployment_item_name: str,
                 target_project_id: str):
        pulumi.set(__self__, "delivery_type", delivery_type)
        pulumi.set(__self__, "expiration_date", expiration_date)
        pulumi.set(__self__, "job_id", job_id)
        pulumi.set(__self__, "restore_finished_date", restore_finished_date)
        pulumi.set(__self__, "restore_scheduled_date", restore_scheduled_date)
        pulumi.set(__self__, "snapshot_finished_date", snapshot_finished_date)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "snapshot_url", snapshot_url)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "target_deployment_item_name", target_deployment_item_name)
        pulumi.set(__self__, "target_project_id", target_project_id)

    @property
    @pulumi.getter(name="deliveryType")
    def delivery_type(self) -> str:
        return pulumi.get(self, "delivery_type")

    @property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> str:
        return pulumi.get(self, "expiration_date")

    @property
    @pulumi.getter(name="jobId")
    def job_id(self) -> str:
        return pulumi.get(self, "job_id")

    @property
    @pulumi.getter(name="restoreFinishedDate")
    def restore_finished_date(self) -> str:
        return pulumi.get(self, "restore_finished_date")

    @property
    @pulumi.getter(name="restoreScheduledDate")
    def restore_scheduled_date(self) -> str:
        return pulumi.get(self, "restore_scheduled_date")

    @property
    @pulumi.getter(name="snapshotFinishedDate")
    def snapshot_finished_date(self) -> str:
        return pulumi.get(self, "snapshot_finished_date")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> str:
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter(name="snapshotUrl")
    def snapshot_url(self) -> str:
        return pulumi.get(self, "snapshot_url")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="targetDeploymentItemName")
    def target_deployment_item_name(self) -> str:
        return pulumi.get(self, "target_deployment_item_name")

    @property
    @pulumi.getter(name="targetProjectId")
    def target_project_id(self) -> str:
        return pulumi.get(self, "target_project_id")


@pulumi.output_type
class GetSharedTierSnapshotsResultResult(dict):
    def __init__(__self__, *,
                 expiration: str,
                 finish_time: str,
                 mongo_db_version: str,
                 scheduled_time: str,
                 snapshot_id: str,
                 start_time: str,
                 status: str):
        pulumi.set(__self__, "expiration", expiration)
        pulumi.set(__self__, "finish_time", finish_time)
        pulumi.set(__self__, "mongo_db_version", mongo_db_version)
        pulumi.set(__self__, "scheduled_time", scheduled_time)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def expiration(self) -> str:
        return pulumi.get(self, "expiration")

    @property
    @pulumi.getter(name="finishTime")
    def finish_time(self) -> str:
        return pulumi.get(self, "finish_time")

    @property
    @pulumi.getter(name="mongoDbVersion")
    def mongo_db_version(self) -> str:
        return pulumi.get(self, "mongo_db_version")

    @property
    @pulumi.getter(name="scheduledTime")
    def scheduled_time(self) -> str:
        return pulumi.get(self, "scheduled_time")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> str:
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")


@pulumi.output_type
class GetStreamConnectionAuthenticationResult(dict):
    def __init__(__self__, *,
                 mechanism: str,
                 password: str,
                 username: str):
        """
        :param str mechanism: Style of authentication. Can be one of `PLAIN`, `SCRAM-256`, or `SCRAM-512`.
        :param str password: Password of the account to connect to the Kafka cluster.
        :param str username: Username of the account to connect to the Kafka cluster.
        """
        pulumi.set(__self__, "mechanism", mechanism)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def mechanism(self) -> str:
        """
        Style of authentication. Can be one of `PLAIN`, `SCRAM-256`, or `SCRAM-512`.
        """
        return pulumi.get(self, "mechanism")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password of the account to connect to the Kafka cluster.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username of the account to connect to the Kafka cluster.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetStreamConnectionDbRoleToExecuteResult(dict):
    def __init__(__self__, *,
                 role: str,
                 type: str):
        """
        :param str role: The name of the role to use. Can be a built in role or a custom role.
        :param str type: Type of the DB role. Can be either BUILT_IN or CUSTOM.
        """
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        The name of the role to use. Can be a built in role or a custom role.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the DB role. Can be either BUILT_IN or CUSTOM.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetStreamConnectionSecurityResult(dict):
    def __init__(__self__, *,
                 broker_public_certificate: str,
                 protocol: str):
        """
        :param str broker_public_certificate: A trusted, public x509 certificate for connecting to Kafka over SSL. String value of the certificate must be defined in the attribute.
        :param str protocol: Describes the transport type. Can be either `PLAINTEXT` or `SSL`.
        """
        pulumi.set(__self__, "broker_public_certificate", broker_public_certificate)
        pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="brokerPublicCertificate")
    def broker_public_certificate(self) -> str:
        """
        A trusted, public x509 certificate for connecting to Kafka over SSL. String value of the certificate must be defined in the attribute.
        """
        return pulumi.get(self, "broker_public_certificate")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Describes the transport type. Can be either `PLAINTEXT` or `SSL`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetStreamConnectionsResultResult(dict):
    def __init__(__self__, *,
                 authentication: 'outputs.GetStreamConnectionsResultAuthenticationResult',
                 bootstrap_servers: str,
                 cluster_name: str,
                 config: Mapping[str, str],
                 connection_name: str,
                 db_role_to_execute: 'outputs.GetStreamConnectionsResultDbRoleToExecuteResult',
                 id: str,
                 instance_name: str,
                 project_id: str,
                 security: 'outputs.GetStreamConnectionsResultSecurityResult',
                 type: str):
        """
        :param 'GetStreamConnectionsResultAuthenticationArgs' authentication: User credentials required to connect to a Kafka cluster. Includes the authentication type, as well as the parameters for that authentication mode. See authentication.
        :param str bootstrap_servers: Comma separated list of server addresses.
        :param str cluster_name: Name of the cluster configured for this connection.
        :param Mapping[str, str] config: A map of Kafka key-value pairs for optional configuration. This is a flat object, and keys can have '.' characters.
        :param str connection_name: Human-readable label that identifies the stream connection. In the case of the Sample type, this is the name of the sample source.
        :param 'GetStreamConnectionsResultDbRoleToExecuteArgs' db_role_to_execute: The name of a Built in or Custom DB Role to connect to an Atlas Cluster. See DBRoleToExecute.
        :param str instance_name: Human-readable label that identifies the stream instance.
        :param str project_id: Unique 24-hexadecimal digit string that identifies your project.
        :param 'GetStreamConnectionsResultSecurityArgs' security: Properties for the secure transport connection to Kafka. For SSL, this can include the trusted certificate to use. See security.
        :param str type: Type of the DB role. Can be either BUILT_IN or CUSTOM.
        """
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "bootstrap_servers", bootstrap_servers)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "connection_name", connection_name)
        pulumi.set(__self__, "db_role_to_execute", db_role_to_execute)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "instance_name", instance_name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "security", security)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def authentication(self) -> 'outputs.GetStreamConnectionsResultAuthenticationResult':
        """
        User credentials required to connect to a Kafka cluster. Includes the authentication type, as well as the parameters for that authentication mode. See authentication.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter(name="bootstrapServers")
    def bootstrap_servers(self) -> str:
        """
        Comma separated list of server addresses.
        """
        return pulumi.get(self, "bootstrap_servers")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        Name of the cluster configured for this connection.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter
    def config(self) -> Mapping[str, str]:
        """
        A map of Kafka key-value pairs for optional configuration. This is a flat object, and keys can have '.' characters.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> str:
        """
        Human-readable label that identifies the stream connection. In the case of the Sample type, this is the name of the sample source.
        """
        return pulumi.get(self, "connection_name")

    @property
    @pulumi.getter(name="dbRoleToExecute")
    def db_role_to_execute(self) -> 'outputs.GetStreamConnectionsResultDbRoleToExecuteResult':
        """
        The name of a Built in or Custom DB Role to connect to an Atlas Cluster. See DBRoleToExecute.
        """
        return pulumi.get(self, "db_role_to_execute")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> str:
        """
        Human-readable label that identifies the stream instance.
        """
        return pulumi.get(self, "instance_name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies your project.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def security(self) -> 'outputs.GetStreamConnectionsResultSecurityResult':
        """
        Properties for the secure transport connection to Kafka. For SSL, this can include the trusted certificate to use. See security.
        """
        return pulumi.get(self, "security")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the DB role. Can be either BUILT_IN or CUSTOM.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetStreamConnectionsResultAuthenticationResult(dict):
    def __init__(__self__, *,
                 mechanism: str,
                 password: str,
                 username: str):
        """
        :param str mechanism: Style of authentication. Can be one of `PLAIN`, `SCRAM-256`, or `SCRAM-512`.
        :param str password: Password of the account to connect to the Kafka cluster.
        :param str username: Username of the account to connect to the Kafka cluster.
        """
        pulumi.set(__self__, "mechanism", mechanism)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def mechanism(self) -> str:
        """
        Style of authentication. Can be one of `PLAIN`, `SCRAM-256`, or `SCRAM-512`.
        """
        return pulumi.get(self, "mechanism")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password of the account to connect to the Kafka cluster.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username of the account to connect to the Kafka cluster.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetStreamConnectionsResultDbRoleToExecuteResult(dict):
    def __init__(__self__, *,
                 role: str,
                 type: str):
        """
        :param str role: The name of the role to use. Can be a built in role or a custom role.
        :param str type: Type of the DB role. Can be either BUILT_IN or CUSTOM.
        """
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def role(self) -> str:
        """
        The name of the role to use. Can be a built in role or a custom role.
        """
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the DB role. Can be either BUILT_IN or CUSTOM.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetStreamConnectionsResultSecurityResult(dict):
    def __init__(__self__, *,
                 broker_public_certificate: str,
                 protocol: str):
        """
        :param str broker_public_certificate: A trusted, public x509 certificate for connecting to Kafka over SSL. String value of the certificate must be defined in the attribute.
        :param str protocol: Describes the transport type. Can be either `PLAINTEXT` or `SSL`.
        """
        pulumi.set(__self__, "broker_public_certificate", broker_public_certificate)
        pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="brokerPublicCertificate")
    def broker_public_certificate(self) -> str:
        """
        A trusted, public x509 certificate for connecting to Kafka over SSL. String value of the certificate must be defined in the attribute.
        """
        return pulumi.get(self, "broker_public_certificate")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        Describes the transport type. Can be either `PLAINTEXT` or `SSL`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetStreamInstanceDataProcessRegionResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 region: str):
        """
        :param str cloud_provider: Label that identifies the cloud service provider where MongoDB Cloud performs stream processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        :param str region: Name of the cloud provider region hosting Atlas Stream Processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        Label that identifies the cloud service provider where MongoDB Cloud performs stream processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Name of the cloud provider region hosting Atlas Stream Processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetStreamInstanceStreamConfigResult(dict):
    def __init__(__self__, *,
                 tier: str):
        """
        :param str tier: Selected tier for the Stream Instance. Configures Memory / VCPU allowances. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def tier(self) -> str:
        """
        Selected tier for the Stream Instance. Configures Memory / VCPU allowances. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class GetStreamInstancesResultResult(dict):
    def __init__(__self__, *,
                 data_process_region: 'outputs.GetStreamInstancesResultDataProcessRegionResult',
                 hostnames: Sequence[str],
                 id: str,
                 instance_name: str,
                 project_id: str,
                 stream_config: 'outputs.GetStreamInstancesResultStreamConfigResult'):
        """
        :param 'GetStreamInstancesResultDataProcessRegionArgs' data_process_region: Defines the cloud service provider and region where MongoDB Cloud performs stream processing. See data process region.
        :param Sequence[str] hostnames: List that contains the hostnames assigned to the stream instance.
        :param str instance_name: Human-readable label that identifies the stream instance.
        :param str project_id: Unique 24-hexadecimal digit string that identifies your project.
        :param 'GetStreamInstancesResultStreamConfigArgs' stream_config: Defines the configuration options for an Atlas Stream Processing Instance. See stream config
        """
        pulumi.set(__self__, "data_process_region", data_process_region)
        pulumi.set(__self__, "hostnames", hostnames)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "instance_name", instance_name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "stream_config", stream_config)

    @property
    @pulumi.getter(name="dataProcessRegion")
    def data_process_region(self) -> 'outputs.GetStreamInstancesResultDataProcessRegionResult':
        """
        Defines the cloud service provider and region where MongoDB Cloud performs stream processing. See data process region.
        """
        return pulumi.get(self, "data_process_region")

    @property
    @pulumi.getter
    def hostnames(self) -> Sequence[str]:
        """
        List that contains the hostnames assigned to the stream instance.
        """
        return pulumi.get(self, "hostnames")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> str:
        """
        Human-readable label that identifies the stream instance.
        """
        return pulumi.get(self, "instance_name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies your project.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="streamConfig")
    def stream_config(self) -> 'outputs.GetStreamInstancesResultStreamConfigResult':
        """
        Defines the configuration options for an Atlas Stream Processing Instance. See stream config
        """
        return pulumi.get(self, "stream_config")


@pulumi.output_type
class GetStreamInstancesResultDataProcessRegionResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 region: str):
        """
        :param str cloud_provider: Label that identifies the cloud service provider where MongoDB Cloud performs stream processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        :param str region: Name of the cloud provider region hosting Atlas Stream Processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        """
        Label that identifies the cloud service provider where MongoDB Cloud performs stream processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Name of the cloud provider region hosting Atlas Stream Processing. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetStreamInstancesResultStreamConfigResult(dict):
    def __init__(__self__, *,
                 tier: str):
        """
        :param str tier: Selected tier for the Stream Instance. Configures Memory / VCPU allowances. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        pulumi.set(__self__, "tier", tier)

    @property
    @pulumi.getter
    def tier(self) -> str:
        """
        Selected tier for the Stream Instance. Configures Memory / VCPU allowances. The [MongoDB Atlas API](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/#tag/Streams/operation/createStreamInstance) describes the valid values.
        """
        return pulumi.get(self, "tier")


@pulumi.output_type
class GetStreamProcessorOptionsResult(dict):
    def __init__(__self__, *,
                 dlq: 'outputs.GetStreamProcessorOptionsDlqResult'):
        """
        :param 'GetStreamProcessorOptionsDlqArgs' dlq: Dead letter queue for the stream processor. Refer to the [MongoDB Atlas Docs](https://www.mongodb.com/docs/atlas/reference/glossary/#std-term-dead-letter-queue) for more information.
        """
        pulumi.set(__self__, "dlq", dlq)

    @property
    @pulumi.getter
    def dlq(self) -> 'outputs.GetStreamProcessorOptionsDlqResult':
        """
        Dead letter queue for the stream processor. Refer to the [MongoDB Atlas Docs](https://www.mongodb.com/docs/atlas/reference/glossary/#std-term-dead-letter-queue) for more information.
        """
        return pulumi.get(self, "dlq")


@pulumi.output_type
class GetStreamProcessorOptionsDlqResult(dict):
    def __init__(__self__, *,
                 coll: str,
                 connection_name: str,
                 db: str):
        """
        :param str coll: Name of the collection to use for the DLQ.
        :param str connection_name: Name of the connection to write DLQ messages to. Must be an Atlas connection.
        :param str db: Name of the database to use for the DLQ.
        """
        pulumi.set(__self__, "coll", coll)
        pulumi.set(__self__, "connection_name", connection_name)
        pulumi.set(__self__, "db", db)

    @property
    @pulumi.getter
    def coll(self) -> str:
        """
        Name of the collection to use for the DLQ.
        """
        return pulumi.get(self, "coll")

    @property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> str:
        """
        Name of the connection to write DLQ messages to. Must be an Atlas connection.
        """
        return pulumi.get(self, "connection_name")

    @property
    @pulumi.getter
    def db(self) -> str:
        """
        Name of the database to use for the DLQ.
        """
        return pulumi.get(self, "db")


@pulumi.output_type
class GetStreamProcessorsResultResult(dict):
    def __init__(__self__, *,
                 id: str,
                 instance_name: str,
                 options: 'outputs.GetStreamProcessorsResultOptionsResult',
                 pipeline: str,
                 processor_name: str,
                 project_id: str,
                 state: str,
                 stats: str):
        """
        :param str id: Unique 24-hexadecimal character string that identifies the stream processor.
        :param str instance_name: Human-readable label that identifies the stream instance.
        :param 'GetStreamProcessorsResultOptionsArgs' options: Optional configuration for the stream processor.
        :param str pipeline: Stream aggregation pipeline you want to apply to your streaming data.
        :param str processor_name: Human-readable label that identifies the stream processor.
        :param str project_id: Unique 24-hexadecimal digit string that identifies your project. Use the /groups endpoint to retrieve all projects to which the authenticated user has access.
        :param str state: The state of the stream processor.
        :param str stats: The stats associated with the stream processor.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "instance_name", instance_name)
        pulumi.set(__self__, "options", options)
        pulumi.set(__self__, "pipeline", pipeline)
        pulumi.set(__self__, "processor_name", processor_name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "stats", stats)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique 24-hexadecimal character string that identifies the stream processor.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="instanceName")
    def instance_name(self) -> str:
        """
        Human-readable label that identifies the stream instance.
        """
        return pulumi.get(self, "instance_name")

    @property
    @pulumi.getter
    def options(self) -> 'outputs.GetStreamProcessorsResultOptionsResult':
        """
        Optional configuration for the stream processor.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def pipeline(self) -> str:
        """
        Stream aggregation pipeline you want to apply to your streaming data.
        """
        return pulumi.get(self, "pipeline")

    @property
    @pulumi.getter(name="processorName")
    def processor_name(self) -> str:
        """
        Human-readable label that identifies the stream processor.
        """
        return pulumi.get(self, "processor_name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Unique 24-hexadecimal digit string that identifies your project. Use the /groups endpoint to retrieve all projects to which the authenticated user has access.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the stream processor.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def stats(self) -> str:
        """
        The stats associated with the stream processor.
        """
        return pulumi.get(self, "stats")


@pulumi.output_type
class GetStreamProcessorsResultOptionsResult(dict):
    def __init__(__self__, *,
                 dlq: 'outputs.GetStreamProcessorsResultOptionsDlqResult'):
        """
        :param 'GetStreamProcessorsResultOptionsDlqArgs' dlq: Dead letter queue for the stream processor. Refer to the [MongoDB Atlas Docs](https://www.mongodb.com/docs/atlas/reference/glossary/#std-term-dead-letter-queue) for more information.
        """
        pulumi.set(__self__, "dlq", dlq)

    @property
    @pulumi.getter
    def dlq(self) -> 'outputs.GetStreamProcessorsResultOptionsDlqResult':
        """
        Dead letter queue for the stream processor. Refer to the [MongoDB Atlas Docs](https://www.mongodb.com/docs/atlas/reference/glossary/#std-term-dead-letter-queue) for more information.
        """
        return pulumi.get(self, "dlq")


@pulumi.output_type
class GetStreamProcessorsResultOptionsDlqResult(dict):
    def __init__(__self__, *,
                 coll: str,
                 connection_name: str,
                 db: str):
        """
        :param str coll: Name of the collection to use for the DLQ.
        :param str connection_name: Name of the connection to write DLQ messages to. Must be an Atlas connection.
        :param str db: Name of the database to use for the DLQ.
        """
        pulumi.set(__self__, "coll", coll)
        pulumi.set(__self__, "connection_name", connection_name)
        pulumi.set(__self__, "db", db)

    @property
    @pulumi.getter
    def coll(self) -> str:
        """
        Name of the collection to use for the DLQ.
        """
        return pulumi.get(self, "coll")

    @property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> str:
        """
        Name of the connection to write DLQ messages to. Must be an Atlas connection.
        """
        return pulumi.get(self, "connection_name")

    @property
    @pulumi.getter
    def db(self) -> str:
        """
        Name of the database to use for the DLQ.
        """
        return pulumi.get(self, "db")


@pulumi.output_type
class GetThirdPartyIntegrationsResultResult(dict):
    def __init__(__self__, *,
                 account_id: str,
                 api_key: str,
                 channel_name: str,
                 id: str,
                 project_id: str,
                 region: str,
                 routing_key: str,
                 secret: str,
                 service_key: str,
                 team_name: str,
                 type: str,
                 url: str,
                 enabled: Optional[bool] = None,
                 microsoft_teams_webhook_url: Optional[str] = None,
                 service_discovery: Optional[str] = None,
                 user_name: Optional[str] = None):
        """
        :param str api_key: Your API Key.
        :param str id: Unique identifier of the integration.
        :param str project_id: The unique ID for the project to get all Third-Party service integrations
        :param str region: Two-letter code that indicates which API URL to use. See the `region` response field of [MongoDB API Third-Party Service Integration documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Third-Party-Integrations/operation/getThirdPartyIntegration) for more details. Opsgenie will use US by default.
               * `VICTOR_OPS`
        :param str routing_key: An optional field for your Routing Key.
               * `WEBHOOK`
        :param str secret: An optional field for your webhook secret.
               * `MICROSOFT_TEAMS`
        :param str service_key: Your Service Key.
               * `DATADOG`
        :param str type: Thirt-Party service integration type.
        :param str url: Your webhook URL.
        :param bool enabled: Whether your cluster has Prometheus enabled.
        :param str microsoft_teams_webhook_url: Your Microsoft Teams incoming webhook URL.
               * `PROMETHEUS`
        :param str service_discovery: Indicates which service discovery method is used, either file or http.
        :param str user_name: Your Prometheus username.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "channel_name", channel_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "routing_key", routing_key)
        pulumi.set(__self__, "secret", secret)
        pulumi.set(__self__, "service_key", service_key)
        pulumi.set(__self__, "team_name", team_name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "url", url)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if microsoft_teams_webhook_url is not None:
            pulumi.set(__self__, "microsoft_teams_webhook_url", microsoft_teams_webhook_url)
        if service_discovery is not None:
            pulumi.set(__self__, "service_discovery", service_discovery)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Your API Key.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> str:
        return pulumi.get(self, "channel_name")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of the integration.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project to get all Third-Party service integrations
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Two-letter code that indicates which API URL to use. See the `region` response field of [MongoDB API Third-Party Service Integration documentation](https://www.mongodb.com/docs/atlas/reference/api-resources-spec/v2/#tag/Third-Party-Integrations/operation/getThirdPartyIntegration) for more details. Opsgenie will use US by default.
        * `VICTOR_OPS`
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="routingKey")
    def routing_key(self) -> str:
        """
        An optional field for your Routing Key.
        * `WEBHOOK`
        """
        return pulumi.get(self, "routing_key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        An optional field for your webhook secret.
        * `MICROSOFT_TEAMS`
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="serviceKey")
    def service_key(self) -> str:
        """
        Your Service Key.
        * `DATADOG`
        """
        return pulumi.get(self, "service_key")

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> str:
        return pulumi.get(self, "team_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Thirt-Party service integration type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Your webhook URL.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether your cluster has Prometheus enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="microsoftTeamsWebhookUrl")
    def microsoft_teams_webhook_url(self) -> Optional[str]:
        """
        Your Microsoft Teams incoming webhook URL.
        * `PROMETHEUS`
        """
        return pulumi.get(self, "microsoft_teams_webhook_url")

    @property
    @pulumi.getter(name="serviceDiscovery")
    def service_discovery(self) -> Optional[str]:
        """
        Indicates which service discovery method is used, either file or http.
        """
        return pulumi.get(self, "service_discovery")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[str]:
        """
        Your Prometheus username.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetX509AuthenticationDatabaseUserCertificateResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 group_id: str,
                 id: int,
                 not_after: str,
                 subject: str):
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "not_after", not_after)
        pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> str:
        return pulumi.get(self, "not_after")

    @property
    @pulumi.getter
    def subject(self) -> str:
        return pulumi.get(self, "subject")


