# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities, _tables
from . import outputs

__all__ = [
    'AlertConfigurationMatcher',
    'AlertConfigurationMetricThreshold',
    'AlertConfigurationNotification',
    'AlertConfigurationThreshold',
    'CloudProviderAccessFeatureUsage',
    'CloudProviderSnapshotBackupPolicyPolicy',
    'CloudProviderSnapshotBackupPolicyPolicyPolicyItem',
    'CloudProviderSnapshotRestoreJobDeliveryType',
    'ClusterAdvancedConfiguration',
    'ClusterBiConnector',
    'ClusterConnectionStrings',
    'ClusterConnectionStringsPrivateEndpoint',
    'ClusterConnectionStringsPrivateEndpointEndpoint',
    'ClusterLabel',
    'ClusterReplicationSpec',
    'ClusterReplicationSpecRegionsConfig',
    'ClusterSnapshotBackupPolicy',
    'ClusterSnapshotBackupPolicyPolicy',
    'ClusterSnapshotBackupPolicyPolicyPolicyItem',
    'CustomDbRoleAction',
    'CustomDbRoleActionResource',
    'CustomDbRoleInheritedRole',
    'DatabaseUserLabel',
    'DatabaseUserRole',
    'DatabaseUserScope',
    'EncryptionAtRestAwsKms',
    'EncryptionAtRestAzureKeyVault',
    'EncryptionAtRestGoogleCloudKms',
    'GlobalClusterConfigCustomZoneMapping',
    'GlobalClusterConfigManagedNamespace',
    'ProjectTeam',
    'X509AuthenticationDatabaseUserCertificate',
    'Get509AuthenticationDatabaseUserCertificateResult',
    'GetAlertConfigurationMatcherResult',
    'GetAlertConfigurationMetricThresholdResult',
    'GetAlertConfigurationNotificationResult',
    'GetAlertConfigurationThresholdResult',
    'GetCloudProviderAccessAwsIamRoleResult',
    'GetCloudProviderAccessAwsIamRoleFeatureUsageResult',
    'GetCloudProviderSnapshotBackupPolicyPolicyResult',
    'GetCloudProviderSnapshotBackupPolicyPolicyPolicyItemResult',
    'GetCloudProviderSnapshotRestoreJobsResultResult',
    'GetCloudProviderSnapshotsResultResult',
    'GetClusterBiConnectorResult',
    'GetClusterConnectionStringsResult',
    'GetClusterConnectionStringsPrivateEndpointResult',
    'GetClusterConnectionStringsPrivateEndpointEndpointResult',
    'GetClusterLabelResult',
    'GetClusterReplicationSpecResult',
    'GetClusterReplicationSpecRegionsConfigResult',
    'GetClusterSnapshotBackupPolicyResult',
    'GetClusterSnapshotBackupPolicyPolicyResult',
    'GetClusterSnapshotBackupPolicyPolicyPolicyItemResult',
    'GetClustersResultResult',
    'GetClustersResultBiConnectorResult',
    'GetClustersResultConnectionStringsResult',
    'GetClustersResultConnectionStringsPrivateEndpointResult',
    'GetClustersResultConnectionStringsPrivateEndpointEndpointResult',
    'GetClustersResultLabelResult',
    'GetClustersResultReplicationSpecResult',
    'GetClustersResultReplicationSpecRegionsConfigResult',
    'GetClustersResultSnapshotBackupPolicyResult',
    'GetClustersResultSnapshotBackupPolicyPolicyResult',
    'GetClustersResultSnapshotBackupPolicyPolicyPolicyItemResult',
    'GetCustomDbRoleActionResult',
    'GetCustomDbRoleActionResourceResult',
    'GetCustomDbRoleInheritedRoleResult',
    'GetCustomDbRolesResultResult',
    'GetCustomDbRolesResultActionResult',
    'GetCustomDbRolesResultActionResourceResult',
    'GetCustomDbRolesResultInheritedRoleResult',
    'GetDatabaseUserLabelResult',
    'GetDatabaseUserRoleResult',
    'GetDatabaseUserScopeResult',
    'GetDatabaseUsersResultResult',
    'GetDatabaseUsersResultLabelResult',
    'GetDatabaseUsersResultRoleResult',
    'GetDatabaseUsersResultScopeResult',
    'GetGlobalClusterConfigManagedNamespaceResult',
    'GetNetworkContainersResultResult',
    'GetNetworkPeeringsResultResult',
    'GetProjectTeamResult',
    'GetProjectsResultResult',
    'GetProjectsResultTeamResult',
    'GetThirdPartyIntegrationsResultResult',
]

@pulumi.output_type
class AlertConfigurationMatcher(dict):
    def __init__(__self__, *,
                 field_name: Optional[str] = None,
                 operator: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str field_name: Name of the field in the target object to match on.
        :param str operator: Operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
               - `GREATER_THAN`
               - `LESS_THAN`
        :param str value: Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
               - `PRIMARY`
               - `SECONDARY`
               - `STANDALONE`
               - `CONFIG`
               - `MONGOS`
        """
        if field_name is not None:
            pulumi.set(__self__, "field_name", field_name)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> Optional[str]:
        """
        Name of the field in the target object to match on.
        """
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        - `GREATER_THAN`
        - `LESS_THAN`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
        - `PRIMARY`
        - `SECONDARY`
        - `STANDALONE`
        - `CONFIG`
        - `MONGOS`
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AlertConfigurationMetricThreshold(dict):
    def __init__(__self__, *,
                 metric_name: Optional[str] = None,
                 mode: Optional[str] = None,
                 operator: Optional[str] = None,
                 threshold: Optional[float] = None,
                 units: Optional[str] = None):
        """
        :param str metric_name: Name of the metric to check. The full list of current options is available [here](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types)
        :param str mode: This must be set to AVERAGE. Atlas computes the current metric value as an average.
        :param str operator: Operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
               - `GREATER_THAN`
               - `LESS_THAN`
        :param float threshold: Threshold value outside of which an alert will be triggered.
        :param str units: The units for the threshold value. Depends on the type of metric.
               Accepted values are:
               - `RAW`
               - `BITS`
               - `BYTES`
               - `KILOBITS`
               - `KILOBYTES`
               - `MEGABITS`
               - `MEGABYTES`
               - `GIGABITS`
               - `GIGABYTES`
               - `TERABYTES`
               - `PETABYTES`
               - `MILLISECONDS`
               - `SECONDS`
               - `MINUTES`
               - `HOURS`
               - `DAYS`
        """
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if units is not None:
            pulumi.set(__self__, "units", units)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[str]:
        """
        Name of the metric to check. The full list of current options is available [here](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types)
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        This must be set to AVERAGE. Atlas computes the current metric value as an average.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        - `GREATER_THAN`
        - `LESS_THAN`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        """
        Threshold value outside of which an alert will be triggered.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def units(self) -> Optional[str]:
        """
        The units for the threshold value. Depends on the type of metric.
        Accepted values are:
        - `RAW`
        - `BITS`
        - `BYTES`
        - `KILOBITS`
        - `KILOBYTES`
        - `MEGABITS`
        - `MEGABYTES`
        - `GIGABITS`
        - `GIGABYTES`
        - `TERABYTES`
        - `PETABYTES`
        - `MILLISECONDS`
        - `SECONDS`
        - `MINUTES`
        - `HOURS`
        - `DAYS`
        """
        return pulumi.get(self, "units")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AlertConfigurationNotification(dict):
    def __init__(__self__, *,
                 api_token: Optional[str] = None,
                 channel_name: Optional[str] = None,
                 datadog_api_key: Optional[str] = None,
                 datadog_region: Optional[str] = None,
                 delay_min: Optional[int] = None,
                 email_address: Optional[str] = None,
                 email_enabled: Optional[bool] = None,
                 flow_name: Optional[str] = None,
                 flowdock_api_token: Optional[str] = None,
                 interval_min: Optional[int] = None,
                 mobile_number: Optional[str] = None,
                 ops_genie_api_key: Optional[str] = None,
                 ops_genie_region: Optional[str] = None,
                 org_name: Optional[str] = None,
                 roles: Optional[Sequence[str]] = None,
                 service_key: Optional[str] = None,
                 sms_enabled: Optional[bool] = None,
                 team_id: Optional[str] = None,
                 type_name: Optional[str] = None,
                 username: Optional[str] = None,
                 victor_ops_api_key: Optional[str] = None,
                 victor_ops_routing_key: Optional[str] = None):
        """
        :param str api_token: Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param str channel_name: Slack channel name. Required for the SLACK notifications type.
        :param str datadog_api_key: Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        :param str datadog_region: Region that indicates which API URL to use. Accepted regions are: `US`, `EU`. The default Datadog region is US.
        :param int delay_min: Number of minutes to wait after an alert condition is detected before sending out the first notification.
        :param str email_address: Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        :param bool email_enabled: Flag indicating if email notifications should be sent. Configurable for `ORG`, `GROUP`, and `USER` notifications types.
        :param str flow_name: Flowdock flow name in lower-case letters. Required for the `FLOWDOCK` notifications type
        :param str flowdock_api_token: The Flowdock personal API token. Required for the `FLOWDOCK` notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param int interval_min: Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5.
        :param str mobile_number: Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        :param str ops_genie_api_key: Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param str ops_genie_region: Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        :param str org_name: Flowdock organization name in lower-case letters. This is the name that appears after www.flowdock.com/app/ in the URL string. Required for the FLOWDOCK notifications type.
        :param str service_key: PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param bool sms_enabled: Flag indicating if text message notifications should be sent. Configurable for `ORG`, `GROUP`, and `USER` notifications types.
        :param str team_id: Unique identifier of a team.
        :param str type_name: Type of alert notification.
               Accepted values are:
               - `DATADOG`
               - `EMAIL`
               - `FLOWDOCK`
        :param str username: Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        :param str victor_ops_api_key: VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param str victor_ops_routing_key: VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        if api_token is not None:
            pulumi.set(__self__, "api_token", api_token)
        if channel_name is not None:
            pulumi.set(__self__, "channel_name", channel_name)
        if datadog_api_key is not None:
            pulumi.set(__self__, "datadog_api_key", datadog_api_key)
        if datadog_region is not None:
            pulumi.set(__self__, "datadog_region", datadog_region)
        if delay_min is not None:
            pulumi.set(__self__, "delay_min", delay_min)
        if email_address is not None:
            pulumi.set(__self__, "email_address", email_address)
        if email_enabled is not None:
            pulumi.set(__self__, "email_enabled", email_enabled)
        if flow_name is not None:
            pulumi.set(__self__, "flow_name", flow_name)
        if flowdock_api_token is not None:
            pulumi.set(__self__, "flowdock_api_token", flowdock_api_token)
        if interval_min is not None:
            pulumi.set(__self__, "interval_min", interval_min)
        if mobile_number is not None:
            pulumi.set(__self__, "mobile_number", mobile_number)
        if ops_genie_api_key is not None:
            pulumi.set(__self__, "ops_genie_api_key", ops_genie_api_key)
        if ops_genie_region is not None:
            pulumi.set(__self__, "ops_genie_region", ops_genie_region)
        if org_name is not None:
            pulumi.set(__self__, "org_name", org_name)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)
        if service_key is not None:
            pulumi.set(__self__, "service_key", service_key)
        if sms_enabled is not None:
            pulumi.set(__self__, "sms_enabled", sms_enabled)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)
        if type_name is not None:
            pulumi.set(__self__, "type_name", type_name)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if victor_ops_api_key is not None:
            pulumi.set(__self__, "victor_ops_api_key", victor_ops_api_key)
        if victor_ops_routing_key is not None:
            pulumi.set(__self__, "victor_ops_routing_key", victor_ops_routing_key)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional[str]:
        """
        Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> Optional[str]:
        """
        Slack channel name. Required for the SLACK notifications type.
        """
        return pulumi.get(self, "channel_name")

    @property
    @pulumi.getter(name="datadogApiKey")
    def datadog_api_key(self) -> Optional[str]:
        """
        Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        """
        return pulumi.get(self, "datadog_api_key")

    @property
    @pulumi.getter(name="datadogRegion")
    def datadog_region(self) -> Optional[str]:
        """
        Region that indicates which API URL to use. Accepted regions are: `US`, `EU`. The default Datadog region is US.
        """
        return pulumi.get(self, "datadog_region")

    @property
    @pulumi.getter(name="delayMin")
    def delay_min(self) -> Optional[int]:
        """
        Number of minutes to wait after an alert condition is detected before sending out the first notification.
        """
        return pulumi.get(self, "delay_min")

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> Optional[str]:
        """
        Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter(name="emailEnabled")
    def email_enabled(self) -> Optional[bool]:
        """
        Flag indicating if email notifications should be sent. Configurable for `ORG`, `GROUP`, and `USER` notifications types.
        """
        return pulumi.get(self, "email_enabled")

    @property
    @pulumi.getter(name="flowName")
    def flow_name(self) -> Optional[str]:
        """
        Flowdock flow name in lower-case letters. Required for the `FLOWDOCK` notifications type
        """
        return pulumi.get(self, "flow_name")

    @property
    @pulumi.getter(name="flowdockApiToken")
    def flowdock_api_token(self) -> Optional[str]:
        """
        The Flowdock personal API token. Required for the `FLOWDOCK` notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "flowdock_api_token")

    @property
    @pulumi.getter(name="intervalMin")
    def interval_min(self) -> Optional[int]:
        """
        Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5.
        """
        return pulumi.get(self, "interval_min")

    @property
    @pulumi.getter(name="mobileNumber")
    def mobile_number(self) -> Optional[str]:
        """
        Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        """
        return pulumi.get(self, "mobile_number")

    @property
    @pulumi.getter(name="opsGenieApiKey")
    def ops_genie_api_key(self) -> Optional[str]:
        """
        Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "ops_genie_api_key")

    @property
    @pulumi.getter(name="opsGenieRegion")
    def ops_genie_region(self) -> Optional[str]:
        """
        Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        """
        return pulumi.get(self, "ops_genie_region")

    @property
    @pulumi.getter(name="orgName")
    def org_name(self) -> Optional[str]:
        """
        Flowdock organization name in lower-case letters. This is the name that appears after www.flowdock.com/app/ in the URL string. Required for the FLOWDOCK notifications type.
        """
        return pulumi.get(self, "org_name")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter(name="serviceKey")
    def service_key(self) -> Optional[str]:
        """
        PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "service_key")

    @property
    @pulumi.getter(name="smsEnabled")
    def sms_enabled(self) -> Optional[bool]:
        """
        Flag indicating if text message notifications should be sent. Configurable for `ORG`, `GROUP`, and `USER` notifications types.
        """
        return pulumi.get(self, "sms_enabled")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[str]:
        """
        Unique identifier of a team.
        """
        return pulumi.get(self, "team_id")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> Optional[str]:
        """
        Type of alert notification.
        Accepted values are:
        - `DATADOG`
        - `EMAIL`
        - `FLOWDOCK`
        """
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="victorOpsApiKey")
    def victor_ops_api_key(self) -> Optional[str]:
        """
        VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "victor_ops_api_key")

    @property
    @pulumi.getter(name="victorOpsRoutingKey")
    def victor_ops_routing_key(self) -> Optional[str]:
        """
        VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "victor_ops_routing_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class AlertConfigurationThreshold(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 threshold: Optional[float] = None,
                 units: Optional[str] = None):
        """
        :param str operator: Operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
               - `GREATER_THAN`
               - `LESS_THAN`
        :param float threshold: Threshold value outside of which an alert will be triggered.
        :param str units: The units for the threshold value. Depends on the type of metric.
               Accepted values are:
               - `RAW`
               - `BITS`
               - `BYTES`
               - `KILOBITS`
               - `KILOBYTES`
               - `MEGABITS`
               - `MEGABYTES`
               - `GIGABITS`
               - `GIGABYTES`
               - `TERABYTES`
               - `PETABYTES`
               - `MILLISECONDS`
               - `SECONDS`
               - `MINUTES`
               - `HOURS`
               - `DAYS`
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if units is not None:
            pulumi.set(__self__, "units", units)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        - `GREATER_THAN`
        - `LESS_THAN`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        """
        Threshold value outside of which an alert will be triggered.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def units(self) -> Optional[str]:
        """
        The units for the threshold value. Depends on the type of metric.
        Accepted values are:
        - `RAW`
        - `BITS`
        - `BYTES`
        - `KILOBITS`
        - `KILOBYTES`
        - `MEGABITS`
        - `MEGABYTES`
        - `GIGABITS`
        - `GIGABYTES`
        - `TERABYTES`
        - `PETABYTES`
        - `MILLISECONDS`
        - `SECONDS`
        - `MINUTES`
        - `HOURS`
        - `DAYS`
        """
        return pulumi.get(self, "units")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class CloudProviderAccessFeatureUsage(dict):
    def __init__(__self__, *,
                 feature_id: Optional[str] = None,
                 feature_type: Optional[str] = None):
        if feature_id is not None:
            pulumi.set(__self__, "feature_id", feature_id)
        if feature_type is not None:
            pulumi.set(__self__, "feature_type", feature_type)

    @property
    @pulumi.getter(name="featureId")
    def feature_id(self) -> Optional[str]:
        return pulumi.get(self, "feature_id")

    @property
    @pulumi.getter(name="featureType")
    def feature_type(self) -> Optional[str]:
        return pulumi.get(self, "feature_type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class CloudProviderSnapshotBackupPolicyPolicy(dict):
    def __init__(__self__, *,
                 id: str,
                 policy_items: Sequence['outputs.CloudProviderSnapshotBackupPolicyPolicyPolicyItem']):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "policy_items", policy_items)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="policyItems")
    def policy_items(self) -> Sequence['outputs.CloudProviderSnapshotBackupPolicyPolicyPolicyItem']:
        return pulumi.get(self, "policy_items")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class CloudProviderSnapshotBackupPolicyPolicyPolicyItem(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        return pulumi.get(self, "retention_value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class CloudProviderSnapshotRestoreJobDeliveryType(dict):
    def __init__(__self__, *,
                 automated: Optional[bool] = None,
                 download: Optional[bool] = None,
                 oplog_inc: Optional[int] = None,
                 oplog_ts: Optional[int] = None,
                 point_in_time: Optional[bool] = None,
                 point_in_time_utc_seconds: Optional[int] = None,
                 target_cluster_name: Optional[str] = None,
                 target_project_id: Optional[str] = None):
        """
        :param str target_cluster_name: Name of the target Atlas cluster to which the restore job restores the snapshot. Only required if deliveryType is automated.
        """
        if automated is not None:
            pulumi.set(__self__, "automated", automated)
        if download is not None:
            pulumi.set(__self__, "download", download)
        if oplog_inc is not None:
            pulumi.set(__self__, "oplog_inc", oplog_inc)
        if oplog_ts is not None:
            pulumi.set(__self__, "oplog_ts", oplog_ts)
        if point_in_time is not None:
            pulumi.set(__self__, "point_in_time", point_in_time)
        if point_in_time_utc_seconds is not None:
            pulumi.set(__self__, "point_in_time_utc_seconds", point_in_time_utc_seconds)
        if target_cluster_name is not None:
            pulumi.set(__self__, "target_cluster_name", target_cluster_name)
        if target_project_id is not None:
            pulumi.set(__self__, "target_project_id", target_project_id)

    @property
    @pulumi.getter
    def automated(self) -> Optional[bool]:
        return pulumi.get(self, "automated")

    @property
    @pulumi.getter
    def download(self) -> Optional[bool]:
        return pulumi.get(self, "download")

    @property
    @pulumi.getter(name="oplogInc")
    def oplog_inc(self) -> Optional[int]:
        return pulumi.get(self, "oplog_inc")

    @property
    @pulumi.getter(name="oplogTs")
    def oplog_ts(self) -> Optional[int]:
        return pulumi.get(self, "oplog_ts")

    @property
    @pulumi.getter(name="pointInTime")
    def point_in_time(self) -> Optional[bool]:
        return pulumi.get(self, "point_in_time")

    @property
    @pulumi.getter(name="pointInTimeUtcSeconds")
    def point_in_time_utc_seconds(self) -> Optional[int]:
        return pulumi.get(self, "point_in_time_utc_seconds")

    @property
    @pulumi.getter(name="targetClusterName")
    def target_cluster_name(self) -> Optional[str]:
        """
        Name of the target Atlas cluster to which the restore job restores the snapshot. Only required if deliveryType is automated.
        """
        return pulumi.get(self, "target_cluster_name")

    @property
    @pulumi.getter(name="targetProjectId")
    def target_project_id(self) -> Optional[str]:
        return pulumi.get(self, "target_project_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ClusterAdvancedConfiguration(dict):
    def __init__(__self__, *,
                 fail_index_key_too_long: Optional[bool] = None,
                 javascript_enabled: Optional[bool] = None,
                 minimum_enabled_tls_protocol: Optional[str] = None,
                 no_table_scan: Optional[bool] = None,
                 oplog_size_mb: Optional[int] = None,
                 sample_refresh_interval_bi_connector: Optional[int] = None,
                 sample_size_bi_connector: Optional[int] = None):
        """
        :param bool fail_index_key_too_long: When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        :param bool javascript_enabled: When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        :param str minimum_enabled_tls_protocol: Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        :param bool no_table_scan: When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        :param int oplog_size_mb: The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        :param int sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param int sample_size_bi_connector: Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        if fail_index_key_too_long is not None:
            pulumi.set(__self__, "fail_index_key_too_long", fail_index_key_too_long)
        if javascript_enabled is not None:
            pulumi.set(__self__, "javascript_enabled", javascript_enabled)
        if minimum_enabled_tls_protocol is not None:
            pulumi.set(__self__, "minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        if no_table_scan is not None:
            pulumi.set(__self__, "no_table_scan", no_table_scan)
        if oplog_size_mb is not None:
            pulumi.set(__self__, "oplog_size_mb", oplog_size_mb)
        if sample_refresh_interval_bi_connector is not None:
            pulumi.set(__self__, "sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        if sample_size_bi_connector is not None:
            pulumi.set(__self__, "sample_size_bi_connector", sample_size_bi_connector)

    @property
    @pulumi.getter(name="failIndexKeyTooLong")
    def fail_index_key_too_long(self) -> Optional[bool]:
        """
        When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        """
        return pulumi.get(self, "fail_index_key_too_long")

    @property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> Optional[bool]:
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        return pulumi.get(self, "javascript_enabled")

    @property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> Optional[str]:
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> Optional[bool]:
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        return pulumi.get(self, "no_table_scan")

    @property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> Optional[int]:
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        return pulumi.get(self, "oplog_size_mb")

    @property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> Optional[int]:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> Optional[int]:
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_size_bi_connector")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ClusterBiConnector(dict):
    def __init__(__self__, *,
                 enabled: Optional[str] = None,
                 read_preference: Optional[str] = None):
        """
        :param str enabled: Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
               *
               - Set to `true` to enable BI Connector for Atlas.
               - Set to `false` to disable BI Connector for Atlas.
        :param str read_preference: Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if read_preference is not None:
            pulumi.set(__self__, "read_preference", read_preference)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[str]:
        """
        Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
        *
        - Set to `true` to enable BI Connector for Atlas.
        - Set to `false` to disable BI Connector for Atlas.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> Optional[str]:
        """
        Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        return pulumi.get(self, "read_preference")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ClusterConnectionStrings(dict):
    def __init__(__self__, *,
                 aws_private_link: Optional[Mapping[str, Any]] = None,
                 aws_private_link_srv: Optional[Mapping[str, Any]] = None,
                 private: Optional[str] = None,
                 private_endpoints: Optional[Sequence['outputs.ClusterConnectionStringsPrivateEndpoint']] = None,
                 private_srv: Optional[str] = None,
                 standard: Optional[str] = None,
                 standard_srv: Optional[str] = None):
        if aws_private_link is not None:
            pulumi.set(__self__, "aws_private_link", aws_private_link)
        if aws_private_link_srv is not None:
            pulumi.set(__self__, "aws_private_link_srv", aws_private_link_srv)
        if private is not None:
            pulumi.set(__self__, "private", private)
        if private_endpoints is not None:
            pulumi.set(__self__, "private_endpoints", private_endpoints)
        if private_srv is not None:
            pulumi.set(__self__, "private_srv", private_srv)
        if standard is not None:
            pulumi.set(__self__, "standard", standard)
        if standard_srv is not None:
            pulumi.set(__self__, "standard_srv", standard_srv)

    @property
    @pulumi.getter(name="awsPrivateLink")
    def aws_private_link(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "aws_private_link")

    @property
    @pulumi.getter(name="awsPrivateLinkSrv")
    def aws_private_link_srv(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "aws_private_link_srv")

    @property
    @pulumi.getter
    def private(self) -> Optional[str]:
        return pulumi.get(self, "private")

    @property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Optional[Sequence['outputs.ClusterConnectionStringsPrivateEndpoint']]:
        return pulumi.get(self, "private_endpoints")

    @property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> Optional[str]:
        return pulumi.get(self, "private_srv")

    @property
    @pulumi.getter
    def standard(self) -> Optional[str]:
        return pulumi.get(self, "standard")

    @property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> Optional[str]:
        return pulumi.get(self, "standard_srv")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ClusterConnectionStringsPrivateEndpoint(dict):
    def __init__(__self__, *,
                 connection_string: Optional[str] = None,
                 endpoints: Optional[Sequence['outputs.ClusterConnectionStringsPrivateEndpointEndpoint']] = None,
                 srv_connection_string: Optional[str] = None,
                 type: Optional[str] = None):
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if srv_connection_string is not None:
            pulumi.set(__self__, "srv_connection_string", srv_connection_string)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[str]:
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence['outputs.ClusterConnectionStringsPrivateEndpointEndpoint']]:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> Optional[str]:
        return pulumi.get(self, "srv_connection_string")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ClusterConnectionStringsPrivateEndpointEndpoint(dict):
    def __init__(__self__, *,
                 endpoint_id: Optional[str] = None,
                 provider_name: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str provider_name: Cloud service provider on which the servers are provisioned.
        """
        if endpoint_id is not None:
            pulumi.set(__self__, "endpoint_id", endpoint_id)
        if provider_name is not None:
            pulumi.set(__self__, "provider_name", provider_name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[str]:
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> Optional[str]:
        """
        Cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ClusterLabel(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ClusterReplicationSpec(dict):
    def __init__(__self__, *,
                 num_shards: int,
                 id: Optional[str] = None,
                 regions_configs: Optional[Sequence['outputs.ClusterReplicationSpecRegionsConfig']] = None,
                 zone_name: Optional[str] = None):
        """
        :param int num_shards: Number of shards to deploy in the specified zone, minimum 1.
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster.
        :param Sequence['ClusterReplicationSpecRegionsConfigArgs'] regions_configs: Physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        :param str zone_name: Name for the zone in a Global Cluster.
        """
        pulumi.set(__self__, "num_shards", num_shards)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if regions_configs is not None:
            pulumi.set(__self__, "regions_configs", regions_configs)
        if zone_name is not None:
            pulumi.set(__self__, "zone_name", zone_name)

    @property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> int:
        """
        Number of shards to deploy in the specified zone, minimum 1.
        """
        return pulumi.get(self, "num_shards")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifer of the replication document for a zone in a Global Cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="regionsConfigs")
    def regions_configs(self) -> Optional[Sequence['outputs.ClusterReplicationSpecRegionsConfig']]:
        """
        Physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        """
        return pulumi.get(self, "regions_configs")

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> Optional[str]:
        """
        Name for the zone in a Global Cluster.
        """
        return pulumi.get(self, "zone_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ClusterReplicationSpecRegionsConfig(dict):
    def __init__(__self__, *,
                 analytics_nodes: Optional[int] = None,
                 electable_nodes: Optional[int] = None,
                 priority: Optional[int] = None,
                 read_only_nodes: Optional[int] = None,
                 region_name: Optional[str] = None):
        """
        :param int analytics_nodes: The number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary. If you do not specify this option, no analytics nodes are deployed to the region.
        :param int electable_nodes: Number of electable nodes for Atlas to deploy to the region. Electable nodes can become the primary and can facilitate local reads.
               * The total number of electableNodes across all replication spec regions  must total 3, 5, or 7.
               * Specify 0 if you do not want any electable nodes in the region.
               * You cannot create electable nodes in a region if `priority` is 0.
        :param int priority: Election priority of the region. For regions with only read-only nodes, set this value to 0.
               * For regions where `electable_nodes` is at least 1, each region must have a priority of exactly one (1) less than the previous region. The first region must have a priority of 7. The lowest possible priority is 1.
               * The priority 7 region identifies the Preferred Region of the cluster. Atlas places the primary node in the Preferred Region. Priorities 1 through 7 are exclusive - no more than one region per cluster can be assigned a given priority.
               * Example: If you have three regions, their priorities would be 7, 6, and 5 respectively. If you added two more regions for supporting electable nodes, the priorities of those regions would be 4 and 3 respectively.
        :param int read_only_nodes: Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        :param str region_name: Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        """
        if analytics_nodes is not None:
            pulumi.set(__self__, "analytics_nodes", analytics_nodes)
        if electable_nodes is not None:
            pulumi.set(__self__, "electable_nodes", electable_nodes)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if read_only_nodes is not None:
            pulumi.set(__self__, "read_only_nodes", read_only_nodes)
        if region_name is not None:
            pulumi.set(__self__, "region_name", region_name)

    @property
    @pulumi.getter(name="analyticsNodes")
    def analytics_nodes(self) -> Optional[int]:
        """
        The number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary. If you do not specify this option, no analytics nodes are deployed to the region.
        """
        return pulumi.get(self, "analytics_nodes")

    @property
    @pulumi.getter(name="electableNodes")
    def electable_nodes(self) -> Optional[int]:
        """
        Number of electable nodes for Atlas to deploy to the region. Electable nodes can become the primary and can facilitate local reads.
        * The total number of electableNodes across all replication spec regions  must total 3, 5, or 7.
        * Specify 0 if you do not want any electable nodes in the region.
        * You cannot create electable nodes in a region if `priority` is 0.
        """
        return pulumi.get(self, "electable_nodes")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Election priority of the region. For regions with only read-only nodes, set this value to 0.
        * For regions where `electable_nodes` is at least 1, each region must have a priority of exactly one (1) less than the previous region. The first region must have a priority of 7. The lowest possible priority is 1.
        * The priority 7 region identifies the Preferred Region of the cluster. Atlas places the primary node in the Preferred Region. Priorities 1 through 7 are exclusive - no more than one region per cluster can be assigned a given priority.
        * Example: If you have three regions, their priorities would be 7, 6, and 5 respectively. If you added two more regions for supporting electable nodes, the priorities of those regions would be 4 and 3 respectively.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="readOnlyNodes")
    def read_only_nodes(self) -> Optional[int]:
        """
        Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        """
        return pulumi.get(self, "read_only_nodes")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> Optional[str]:
        """
        Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        """
        return pulumi.get(self, "region_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ClusterSnapshotBackupPolicy(dict):
    def __init__(__self__, *,
                 cluster_id: Optional[str] = None,
                 cluster_name: Optional[str] = None,
                 next_snapshot: Optional[str] = None,
                 policies: Optional[Sequence['outputs.ClusterSnapshotBackupPolicyPolicy']] = None,
                 reference_hour_of_day: Optional[int] = None,
                 reference_minute_of_hour: Optional[int] = None,
                 restore_window_days: Optional[int] = None,
                 update_snapshots: Optional[bool] = None):
        """
        :param str cluster_id: The cluster ID.
        """
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if next_snapshot is not None:
            pulumi.set(__self__, "next_snapshot", next_snapshot)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if reference_hour_of_day is not None:
            pulumi.set(__self__, "reference_hour_of_day", reference_hour_of_day)
        if reference_minute_of_hour is not None:
            pulumi.set(__self__, "reference_minute_of_hour", reference_minute_of_hour)
        if restore_window_days is not None:
            pulumi.set(__self__, "restore_window_days", restore_window_days)
        if update_snapshots is not None:
            pulumi.set(__self__, "update_snapshots", update_snapshots)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[str]:
        """
        The cluster ID.
        """
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="nextSnapshot")
    def next_snapshot(self) -> Optional[str]:
        return pulumi.get(self, "next_snapshot")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence['outputs.ClusterSnapshotBackupPolicyPolicy']]:
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="referenceHourOfDay")
    def reference_hour_of_day(self) -> Optional[int]:
        return pulumi.get(self, "reference_hour_of_day")

    @property
    @pulumi.getter(name="referenceMinuteOfHour")
    def reference_minute_of_hour(self) -> Optional[int]:
        return pulumi.get(self, "reference_minute_of_hour")

    @property
    @pulumi.getter(name="restoreWindowDays")
    def restore_window_days(self) -> Optional[int]:
        return pulumi.get(self, "restore_window_days")

    @property
    @pulumi.getter(name="updateSnapshots")
    def update_snapshots(self) -> Optional[bool]:
        return pulumi.get(self, "update_snapshots")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ClusterSnapshotBackupPolicyPolicy(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 policy_items: Optional[Sequence['outputs.ClusterSnapshotBackupPolicyPolicyPolicyItem']] = None):
        """
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if policy_items is not None:
            pulumi.set(__self__, "policy_items", policy_items)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifer of the replication document for a zone in a Global Cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="policyItems")
    def policy_items(self) -> Optional[Sequence['outputs.ClusterSnapshotBackupPolicyPolicyPolicyItem']]:
        return pulumi.get(self, "policy_items")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ClusterSnapshotBackupPolicyPolicyPolicyItem(dict):
    def __init__(__self__, *,
                 frequency_interval: Optional[int] = None,
                 frequency_type: Optional[str] = None,
                 id: Optional[str] = None,
                 retention_unit: Optional[str] = None,
                 retention_value: Optional[int] = None):
        """
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster.
        """
        if frequency_interval is not None:
            pulumi.set(__self__, "frequency_interval", frequency_interval)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if retention_unit is not None:
            pulumi.set(__self__, "retention_unit", retention_unit)
        if retention_value is not None:
            pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> Optional[int]:
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[str]:
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifer of the replication document for a zone in a Global Cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> Optional[str]:
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> Optional[int]:
        return pulumi.get(self, "retention_value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class CustomDbRoleAction(dict):
    def __init__(__self__, *,
                 action: str,
                 resources: Sequence['outputs.CustomDbRoleActionResource']):
        """
        :param str action: Name of the privilege action. For a complete list of actions available in the Atlas API, see [Custom Role Actions](https://docs.atlas.mongodb.com/reference/api/custom-role-actions)
               > **Note**: The privilege actions available to the Custom Roles API resource represent a subset of the privilege actions available in the Atlas Custom Roles UI.
        :param Sequence['CustomDbRoleActionResourceArgs'] resources: Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Name of the privilege action. For a complete list of actions available in the Atlas API, see [Custom Role Actions](https://docs.atlas.mongodb.com/reference/api/custom-role-actions)
        > **Note**: The privilege actions available to the Custom Roles API resource represent a subset of the privilege actions available in the Atlas Custom Roles UI.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.CustomDbRoleActionResource']:
        """
        Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
        """
        return pulumi.get(self, "resources")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class CustomDbRoleActionResource(dict):
    def __init__(__self__, *,
                 cluster: Optional[bool] = None,
                 collection_name: Optional[str] = None,
                 database_name: Optional[str] = None):
        """
        :param str database_name: Database on which the inherited role is granted.
        """
        if cluster is not None:
            pulumi.set(__self__, "cluster", cluster)
        if collection_name is not None:
            pulumi.set(__self__, "collection_name", collection_name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)

    @property
    @pulumi.getter
    def cluster(self) -> Optional[bool]:
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[str]:
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        Database on which the inherited role is granted.
        """
        return pulumi.get(self, "database_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class CustomDbRoleInheritedRole(dict):
    def __init__(__self__, *,
                 database_name: str,
                 role_name: str):
        """
        :param str database_name: Database on which the inherited role is granted.
        :param str role_name: Name of the inherited role. This can either be another custom role or a built-in role.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Database on which the inherited role is granted.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        """
        Name of the inherited role. This can either be another custom role or a built-in role.
        """
        return pulumi.get(self, "role_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DatabaseUserLabel(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DatabaseUserRole(dict):
    def __init__(__self__, *,
                 collection_name: Optional[str] = None,
                 database_name: Optional[str] = None,
                 role_name: Optional[str] = None):
        """
        :param str collection_name: Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        :param str database_name: Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.
        :param str role_name: Name of the role to grant. See [Create a Database User](https://docs.atlas.mongodb.com/reference/api/database-users-create-a-user/) `roles.roleName` for valid values and restrictions.
        """
        if collection_name is not None:
            pulumi.set(__self__, "collection_name", collection_name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if role_name is not None:
            pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[str]:
        """
        Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        """
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        """
        Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> Optional[str]:
        """
        Name of the role to grant. See [Create a Database User](https://docs.atlas.mongodb.com/reference/api/database-users-create-a-user/) `roles.roleName` for valid values and restrictions.
        """
        return pulumi.get(self, "role_name")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class DatabaseUserScope(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: Name of the cluster or Atlas Data Lake that the user has access to.
        :param str type: Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the cluster or Atlas Data Lake that the user has access to.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class EncryptionAtRestAwsKms(dict):
    def __init__(__self__, *,
                 access_key_id: Optional[str] = None,
                 customer_master_key_id: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 region: Optional[str] = None,
                 role_id: Optional[str] = None,
                 secret_access_key: Optional[str] = None):
        """
        :param str access_key_id: The IAM access key ID with permissions to access the customer master key specified by customerMasterKeyID.
        :param str customer_master_key_id: The AWS customer master key used to encrypt and decrypt the MongoDB master keys.
        :param bool enabled: Specifies whether Encryption at Rest is enabled for an Atlas project. To disable Encryption at Rest, pass only this parameter with a value of false. When you disable Encryption at Rest, Atlas also removes the configuration details.
        :param str region: The AWS region in which the AWS customer master key exists: CA_CENTRAL_1, US_EAST_1, US_EAST_2, US_WEST_1, US_WEST_2, SA_EAST_1
        :param str role_id: ID of an AWS IAM role authorized to manage an AWS customer master key. To find the ID for an existing IAM role check the `role_id` attribute of the `CloudProviderAccess` resource.
        :param str secret_access_key: The IAM secret access key with permissions to access the customer master key specified by customerMasterKeyID.
        """
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if customer_master_key_id is not None:
            pulumi.set(__self__, "customer_master_key_id", customer_master_key_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_id is not None:
            pulumi.set(__self__, "role_id", role_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[str]:
        """
        The IAM access key ID with permissions to access the customer master key specified by customerMasterKeyID.
        """
        return pulumi.get(self, "access_key_id")

    @property
    @pulumi.getter(name="customerMasterKeyId")
    def customer_master_key_id(self) -> Optional[str]:
        """
        The AWS customer master key used to encrypt and decrypt the MongoDB master keys.
        """
        return pulumi.get(self, "customer_master_key_id")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Specifies whether Encryption at Rest is enabled for an Atlas project. To disable Encryption at Rest, pass only this parameter with a value of false. When you disable Encryption at Rest, Atlas also removes the configuration details.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        The AWS region in which the AWS customer master key exists: CA_CENTRAL_1, US_EAST_1, US_EAST_2, US_WEST_1, US_WEST_2, SA_EAST_1
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[str]:
        """
        ID of an AWS IAM role authorized to manage an AWS customer master key. To find the ID for an existing IAM role check the `role_id` attribute of the `CloudProviderAccess` resource.
        """
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[str]:
        """
        The IAM secret access key with permissions to access the customer master key specified by customerMasterKeyID.
        """
        return pulumi.get(self, "secret_access_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class EncryptionAtRestAzureKeyVault(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 azure_environment: Optional[str] = None,
                 client_id: Optional[str] = None,
                 key_identifier: Optional[str] = None,
                 key_vault_name: Optional[str] = None,
                 resource_group_name: Optional[str] = None,
                 secret: Optional[str] = None,
                 subscription_id: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        :param bool enabled: Specifies whether Encryption at Rest is enabled for an Atlas project. To disable Encryption at Rest, pass only this parameter with a value of false. When you disable Encryption at Rest, Atlas also removes the configuration details.
        :param str azure_environment: The Azure environment where the Azure account credentials reside. Valid values are the following: AZURE, AZURE_CHINA, AZURE_GERMANY
        :param str client_id: The client ID, also known as the application ID, for an Azure application associated with the Azure AD tenant.
        :param str key_identifier: The unique identifier of a key in an Azure Key Vault.
        :param str key_vault_name: The name of an Azure Key Vault containing your key.
        :param str resource_group_name: The name of the Azure Resource group that contains an Azure Key Vault.
        :param str secret: The secret associated with the Azure Key Vault specified by azureKeyVault.tenantID.
        :param str subscription_id: The unique identifier associated with an Azure subscription.
        :param str tenant_id: The unique identifier for an Azure AD tenant within an Azure subscription.
        """
        pulumi.set(__self__, "enabled", enabled)
        if azure_environment is not None:
            pulumi.set(__self__, "azure_environment", azure_environment)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if key_identifier is not None:
            pulumi.set(__self__, "key_identifier", key_identifier)
        if key_vault_name is not None:
            pulumi.set(__self__, "key_vault_name", key_vault_name)
        if resource_group_name is not None:
            pulumi.set(__self__, "resource_group_name", resource_group_name)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Specifies whether Encryption at Rest is enabled for an Atlas project. To disable Encryption at Rest, pass only this parameter with a value of false. When you disable Encryption at Rest, Atlas also removes the configuration details.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="azureEnvironment")
    def azure_environment(self) -> Optional[str]:
        """
        The Azure environment where the Azure account credentials reside. Valid values are the following: AZURE, AZURE_CHINA, AZURE_GERMANY
        """
        return pulumi.get(self, "azure_environment")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The client ID, also known as the application ID, for an Azure application associated with the Azure AD tenant.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="keyIdentifier")
    def key_identifier(self) -> Optional[str]:
        """
        The unique identifier of a key in an Azure Key Vault.
        """
        return pulumi.get(self, "key_identifier")

    @property
    @pulumi.getter(name="keyVaultName")
    def key_vault_name(self) -> Optional[str]:
        """
        The name of an Azure Key Vault containing your key.
        """
        return pulumi.get(self, "key_vault_name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[str]:
        """
        The name of the Azure Resource group that contains an Azure Key Vault.
        """
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter
    def secret(self) -> Optional[str]:
        """
        The secret associated with the Azure Key Vault specified by azureKeyVault.tenantID.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[str]:
        """
        The unique identifier associated with an Azure subscription.
        """
        return pulumi.get(self, "subscription_id")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The unique identifier for an Azure AD tenant within an Azure subscription.
        """
        return pulumi.get(self, "tenant_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class EncryptionAtRestGoogleCloudKms(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 key_version_resource_id: Optional[str] = None,
                 service_account_key: Optional[str] = None):
        """
        :param bool enabled: Specifies whether Encryption at Rest is enabled for an Atlas project. To disable Encryption at Rest, pass only this parameter with a value of false. When you disable Encryption at Rest, Atlas also removes the configuration details.
        :param str key_version_resource_id: The Key Version Resource ID from your GCP account.
        :param str service_account_key: String-formatted JSON object containing GCP KMS credentials from your GCP account.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if key_version_resource_id is not None:
            pulumi.set(__self__, "key_version_resource_id", key_version_resource_id)
        if service_account_key is not None:
            pulumi.set(__self__, "service_account_key", service_account_key)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Specifies whether Encryption at Rest is enabled for an Atlas project. To disable Encryption at Rest, pass only this parameter with a value of false. When you disable Encryption at Rest, Atlas also removes the configuration details.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="keyVersionResourceId")
    def key_version_resource_id(self) -> Optional[str]:
        """
        The Key Version Resource ID from your GCP account.
        """
        return pulumi.get(self, "key_version_resource_id")

    @property
    @pulumi.getter(name="serviceAccountKey")
    def service_account_key(self) -> Optional[str]:
        """
        String-formatted JSON object containing GCP KMS credentials from your GCP account.
        """
        return pulumi.get(self, "service_account_key")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalClusterConfigCustomZoneMapping(dict):
    def __init__(__self__, *,
                 location: Optional[str] = None,
                 zone: Optional[str] = None):
        """
        :param str location: The ISO location code to which you want to map a zone in your Global Cluster. You can find a list of all supported location codes [here](https://cloud.mongodb.com/static/atlas/country_iso_codes.txt).
        :param str zone: The name of the zone in your Global Cluster that you want to map to location.
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        The ISO location code to which you want to map a zone in your Global Cluster. You can find a list of all supported location codes [here](https://cloud.mongodb.com/static/atlas/country_iso_codes.txt).
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        """
        The name of the zone in your Global Cluster that you want to map to location.
        """
        return pulumi.get(self, "zone")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class GlobalClusterConfigManagedNamespace(dict):
    def __init__(__self__, *,
                 collection: str,
                 custom_shard_key: str,
                 db: str):
        """
        :param str collection: The name of the collection associated with the managed namespace.
        :param str custom_shard_key: The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        :param str db: The name of the database containing the collection.
        """
        pulumi.set(__self__, "collection", collection)
        pulumi.set(__self__, "custom_shard_key", custom_shard_key)
        pulumi.set(__self__, "db", db)

    @property
    @pulumi.getter
    def collection(self) -> str:
        """
        The name of the collection associated with the managed namespace.
        """
        return pulumi.get(self, "collection")

    @property
    @pulumi.getter(name="customShardKey")
    def custom_shard_key(self) -> str:
        """
        The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        """
        return pulumi.get(self, "custom_shard_key")

    @property
    @pulumi.getter
    def db(self) -> str:
        """
        The name of the database containing the collection.
        """
        return pulumi.get(self, "db")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ProjectTeam(dict):
    def __init__(__self__, *,
                 role_names: Sequence[str],
                 team_id: str):
        """
        :param Sequence[str] role_names: Each string in the array represents a project role you want to assign to the team. Every user associated with the team inherits these roles. You must specify an array even if you are only associating a single role with the team.
               The following are valid roles:
               * `GROUP_OWNER`
               * `GROUP_READ_ONLY`
               * `GROUP_DATA_ACCESS_ADMIN`
               * `GROUP_DATA_ACCESS_READ_WRITE`
               * `GROUP_DATA_ACCESS_READ_ONLY`
               * `GROUP_CLUSTER_MANAGER`
        :param str team_id: The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
        """
        pulumi.set(__self__, "role_names", role_names)
        pulumi.set(__self__, "team_id", team_id)

    @property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[str]:
        """
        Each string in the array represents a project role you want to assign to the team. Every user associated with the team inherits these roles. You must specify an array even if you are only associating a single role with the team.
        The following are valid roles:
        * `GROUP_OWNER`
        * `GROUP_READ_ONLY`
        * `GROUP_DATA_ACCESS_ADMIN`
        * `GROUP_DATA_ACCESS_READ_WRITE`
        * `GROUP_DATA_ACCESS_READ_ONLY`
        * `GROUP_CLUSTER_MANAGER`
        """
        return pulumi.get(self, "role_names")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> str:
        """
        The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
        """
        return pulumi.get(self, "team_id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class X509AuthenticationDatabaseUserCertificate(dict):
    def __init__(__self__, *,
                 created_at: Optional[str] = None,
                 group_id: Optional[str] = None,
                 id: Optional[int] = None,
                 not_after: Optional[str] = None,
                 subject: Optional[str] = None):
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if not_after is not None:
            pulumi.set(__self__, "not_after", not_after)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> Optional[str]:
        return pulumi.get(self, "not_after")

    @property
    @pulumi.getter
    def subject(self) -> Optional[str]:
        return pulumi.get(self, "subject")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class Get509AuthenticationDatabaseUserCertificateResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 group_id: str,
                 id: int,
                 not_after: str,
                 subject: str):
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "group_id", group_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "not_after", not_after)
        pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> str:
        return pulumi.get(self, "not_after")

    @property
    @pulumi.getter
    def subject(self) -> str:
        return pulumi.get(self, "subject")


@pulumi.output_type
class GetAlertConfigurationMatcherResult(dict):
    def __init__(__self__, *,
                 field_name: str,
                 operator: str,
                 value: str):
        """
        :param str field_name: Name of the field in the target object to match on.
        :param str operator: Operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
               - `GREATER_THAN`
               - `LESS_THAN`
        :param str value: Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
               - `PRIMARY`
               - `SECONDARY`
               - `STANDALONE`
               - `CONFIG`
               - `MONGOS`
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        """
        Name of the field in the target object to match on.
        """
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        - `GREATER_THAN`
        - `LESS_THAN`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
        - `PRIMARY`
        - `SECONDARY`
        - `STANDALONE`
        - `CONFIG`
        - `MONGOS`
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAlertConfigurationMetricThresholdResult(dict):
    def __init__(__self__, *,
                 metric_name: str,
                 mode: str,
                 operator: str,
                 threshold: float,
                 units: str):
        """
        :param str metric_name: Name of the metric to check. The full list of current options is available [here](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types)
        :param str mode: This must be set to AVERAGE. Atlas computes the current metric value as an average.
        :param str operator: Operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
               - `GREATER_THAN`
               - `LESS_THAN`
        :param float threshold: Threshold value outside of which an alert will be triggered.
        :param str units: The units for the threshold value. Depends on the type of metric.
               Accepted values are:
               - `RAW`
               - `BITS`
               - `BYTES`
               - `KILOBITS`
               - `KILOBYTES`
               - `MEGABITS`
               - `MEGABYTES`
               - `GIGABITS`
               - `GIGABYTES`
               - `TERABYTES`
               - `PETABYTES`
               - `MILLISECONDS`
               - `SECONDS`
               - `MINUTES`
               - `HOURS`
               - `DAYS`
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "units", units)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        Name of the metric to check. The full list of current options is available [here](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types)
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def mode(self) -> str:
        """
        This must be set to AVERAGE. Atlas computes the current metric value as an average.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        - `GREATER_THAN`
        - `LESS_THAN`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        Threshold value outside of which an alert will be triggered.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def units(self) -> str:
        """
        The units for the threshold value. Depends on the type of metric.
        Accepted values are:
        - `RAW`
        - `BITS`
        - `BYTES`
        - `KILOBITS`
        - `KILOBYTES`
        - `MEGABITS`
        - `MEGABYTES`
        - `GIGABITS`
        - `GIGABYTES`
        - `TERABYTES`
        - `PETABYTES`
        - `MILLISECONDS`
        - `SECONDS`
        - `MINUTES`
        - `HOURS`
        - `DAYS`
        """
        return pulumi.get(self, "units")


@pulumi.output_type
class GetAlertConfigurationNotificationResult(dict):
    def __init__(__self__, *,
                 api_token: str,
                 channel_name: str,
                 datadog_api_key: str,
                 datadog_region: str,
                 delay_min: int,
                 email_address: str,
                 email_enabled: bool,
                 flow_name: str,
                 flowdock_api_token: str,
                 interval_min: int,
                 mobile_number: str,
                 ops_genie_api_key: str,
                 ops_genie_region: str,
                 org_name: str,
                 service_key: str,
                 sms_enabled: bool,
                 team_id: str,
                 type_name: str,
                 username: str,
                 victor_ops_api_key: str,
                 victor_ops_routing_key: str,
                 roles: Optional[Sequence[str]] = None):
        """
        :param str api_token: Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param str channel_name: Slack channel name. Required for the SLACK notifications type.
        :param str datadog_api_key: Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        :param str datadog_region: Region that indicates which API URL to use. Accepted regions are: `US`, `EU`. The default Datadog region is US.
        :param int delay_min: Number of minutes to wait after an alert condition is detected before sending out the first notification.
        :param str email_address: Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        :param bool email_enabled: Flag indicating if email notifications should be sent. Configurable for `ORG`, `GROUP`, and `USER` notifications types.
        :param str flow_name: Flowdock flow name in lower-case letters. Required for the `FLOWDOCK` notifications type
        :param str flowdock_api_token: The Flowdock personal API token. Required for the `FLOWDOCK` notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param int interval_min: Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5.
        :param str mobile_number: Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        :param str ops_genie_api_key: Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param str ops_genie_region: Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        :param str org_name: Flowdock organization name in lower-case letters. This is the name that appears after www.flowdock.com/app/ in the URL string. Required for the FLOWDOCK notifications type.
        :param str service_key: PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param bool sms_enabled: Flag indicating if text message notifications should be sent. Configurable for `ORG`, `GROUP`, and `USER` notifications types.
        :param str team_id: Unique identifier of a team.
        :param str type_name: Type of alert notification.
               Accepted values are:
               - `DATADOG`
               - `EMAIL`
               - `FLOWDOCK`
               - `GROUP` (Project)
               - `OPS_GENIE`
               - `ORG`
               - `PAGER_DUTY`
               - `SLACK`
               - `SMS`
               - `TEAM`
               - `USER`
               - `VICTOR_OPS`
               - `WEBHOOK`
        :param str username: Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        :param str victor_ops_api_key: VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param str victor_ops_routing_key: VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "channel_name", channel_name)
        pulumi.set(__self__, "datadog_api_key", datadog_api_key)
        pulumi.set(__self__, "datadog_region", datadog_region)
        pulumi.set(__self__, "delay_min", delay_min)
        pulumi.set(__self__, "email_address", email_address)
        pulumi.set(__self__, "email_enabled", email_enabled)
        pulumi.set(__self__, "flow_name", flow_name)
        pulumi.set(__self__, "flowdock_api_token", flowdock_api_token)
        pulumi.set(__self__, "interval_min", interval_min)
        pulumi.set(__self__, "mobile_number", mobile_number)
        pulumi.set(__self__, "ops_genie_api_key", ops_genie_api_key)
        pulumi.set(__self__, "ops_genie_region", ops_genie_region)
        pulumi.set(__self__, "org_name", org_name)
        pulumi.set(__self__, "service_key", service_key)
        pulumi.set(__self__, "sms_enabled", sms_enabled)
        pulumi.set(__self__, "team_id", team_id)
        pulumi.set(__self__, "type_name", type_name)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "victor_ops_api_key", victor_ops_api_key)
        pulumi.set(__self__, "victor_ops_routing_key", victor_ops_routing_key)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> str:
        """
        Slack channel name. Required for the SLACK notifications type.
        """
        return pulumi.get(self, "channel_name")

    @property
    @pulumi.getter(name="datadogApiKey")
    def datadog_api_key(self) -> str:
        """
        Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        """
        return pulumi.get(self, "datadog_api_key")

    @property
    @pulumi.getter(name="datadogRegion")
    def datadog_region(self) -> str:
        """
        Region that indicates which API URL to use. Accepted regions are: `US`, `EU`. The default Datadog region is US.
        """
        return pulumi.get(self, "datadog_region")

    @property
    @pulumi.getter(name="delayMin")
    def delay_min(self) -> int:
        """
        Number of minutes to wait after an alert condition is detected before sending out the first notification.
        """
        return pulumi.get(self, "delay_min")

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> str:
        """
        Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter(name="emailEnabled")
    def email_enabled(self) -> bool:
        """
        Flag indicating if email notifications should be sent. Configurable for `ORG`, `GROUP`, and `USER` notifications types.
        """
        return pulumi.get(self, "email_enabled")

    @property
    @pulumi.getter(name="flowName")
    def flow_name(self) -> str:
        """
        Flowdock flow name in lower-case letters. Required for the `FLOWDOCK` notifications type
        """
        return pulumi.get(self, "flow_name")

    @property
    @pulumi.getter(name="flowdockApiToken")
    def flowdock_api_token(self) -> str:
        """
        The Flowdock personal API token. Required for the `FLOWDOCK` notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "flowdock_api_token")

    @property
    @pulumi.getter(name="intervalMin")
    def interval_min(self) -> int:
        """
        Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5.
        """
        return pulumi.get(self, "interval_min")

    @property
    @pulumi.getter(name="mobileNumber")
    def mobile_number(self) -> str:
        """
        Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        """
        return pulumi.get(self, "mobile_number")

    @property
    @pulumi.getter(name="opsGenieApiKey")
    def ops_genie_api_key(self) -> str:
        """
        Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "ops_genie_api_key")

    @property
    @pulumi.getter(name="opsGenieRegion")
    def ops_genie_region(self) -> str:
        """
        Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        """
        return pulumi.get(self, "ops_genie_region")

    @property
    @pulumi.getter(name="orgName")
    def org_name(self) -> str:
        """
        Flowdock organization name in lower-case letters. This is the name that appears after www.flowdock.com/app/ in the URL string. Required for the FLOWDOCK notifications type.
        """
        return pulumi.get(self, "org_name")

    @property
    @pulumi.getter(name="serviceKey")
    def service_key(self) -> str:
        """
        PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "service_key")

    @property
    @pulumi.getter(name="smsEnabled")
    def sms_enabled(self) -> bool:
        """
        Flag indicating if text message notifications should be sent. Configurable for `ORG`, `GROUP`, and `USER` notifications types.
        """
        return pulumi.get(self, "sms_enabled")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> str:
        """
        Unique identifier of a team.
        """
        return pulumi.get(self, "team_id")

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> str:
        """
        Type of alert notification.
        Accepted values are:
        - `DATADOG`
        - `EMAIL`
        - `FLOWDOCK`
        - `GROUP` (Project)
        - `OPS_GENIE`
        - `ORG`
        - `PAGER_DUTY`
        - `SLACK`
        - `SMS`
        - `TEAM`
        - `USER`
        - `VICTOR_OPS`
        - `WEBHOOK`
        """
        return pulumi.get(self, "type_name")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="victorOpsApiKey")
    def victor_ops_api_key(self) -> str:
        """
        VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "victor_ops_api_key")

    @property
    @pulumi.getter(name="victorOpsRoutingKey")
    def victor_ops_routing_key(self) -> str:
        """
        VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "victor_ops_routing_key")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "roles")


@pulumi.output_type
class GetAlertConfigurationThresholdResult(dict):
    def __init__(__self__, *,
                 operator: str,
                 threshold: float,
                 units: str):
        """
        :param str operator: Operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
               - `GREATER_THAN`
               - `LESS_THAN`
        :param float threshold: Threshold value outside of which an alert will be triggered.
        :param str units: The units for the threshold value. Depends on the type of metric.
               Accepted values are:
               - `RAW`
               - `BITS`
               - `BYTES`
               - `KILOBITS`
               - `KILOBYTES`
               - `MEGABITS`
               - `MEGABYTES`
               - `GIGABITS`
               - `GIGABYTES`
               - `TERABYTES`
               - `PETABYTES`
               - `MILLISECONDS`
               - `SECONDS`
               - `MINUTES`
               - `HOURS`
               - `DAYS`
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "units", units)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        - `GREATER_THAN`
        - `LESS_THAN`
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        Threshold value outside of which an alert will be triggered.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def units(self) -> str:
        """
        The units for the threshold value. Depends on the type of metric.
        Accepted values are:
        - `RAW`
        - `BITS`
        - `BYTES`
        - `KILOBITS`
        - `KILOBYTES`
        - `MEGABITS`
        - `MEGABYTES`
        - `GIGABITS`
        - `GIGABYTES`
        - `TERABYTES`
        - `PETABYTES`
        - `MILLISECONDS`
        - `SECONDS`
        - `MINUTES`
        - `HOURS`
        - `DAYS`
        """
        return pulumi.get(self, "units")


@pulumi.output_type
class GetCloudProviderAccessAwsIamRoleResult(dict):
    def __init__(__self__, *,
                 atlas_assumed_role_external_id: str,
                 atlas_aws_account_arn: str,
                 authorized_date: str,
                 created_date: str,
                 feature_usages: Sequence['outputs.GetCloudProviderAccessAwsIamRoleFeatureUsageResult'],
                 iam_assumed_role_arn: str,
                 provider_name: str,
                 role_id: str):
        """
        :param str atlas_assumed_role_external_id: Unique external ID Atlas uses when assuming the IAM role in your AWS account.
        :param str atlas_aws_account_arn: ARN associated with the Atlas AWS account used to assume IAM roles in your AWS account.
        :param str authorized_date: Date on which this role was authorized.
        :param str created_date: Date on which this role was created.
        :param Sequence['GetCloudProviderAccessAwsIamRoleFeatureUsageArgs'] feature_usages: Atlas features this AWS IAM role is linked to.
        :param str iam_assumed_role_arn: ARN of the IAM Role that Atlas assumes when accessing resources in your AWS account.
        :param str provider_name: Name of the cloud provider. Currently limited to AWS.
        :param str role_id: Unique ID of this role.
        """
        pulumi.set(__self__, "atlas_assumed_role_external_id", atlas_assumed_role_external_id)
        pulumi.set(__self__, "atlas_aws_account_arn", atlas_aws_account_arn)
        pulumi.set(__self__, "authorized_date", authorized_date)
        pulumi.set(__self__, "created_date", created_date)
        pulumi.set(__self__, "feature_usages", feature_usages)
        pulumi.set(__self__, "iam_assumed_role_arn", iam_assumed_role_arn)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "role_id", role_id)

    @property
    @pulumi.getter(name="atlasAssumedRoleExternalId")
    def atlas_assumed_role_external_id(self) -> str:
        """
        Unique external ID Atlas uses when assuming the IAM role in your AWS account.
        """
        return pulumi.get(self, "atlas_assumed_role_external_id")

    @property
    @pulumi.getter(name="atlasAwsAccountArn")
    def atlas_aws_account_arn(self) -> str:
        """
        ARN associated with the Atlas AWS account used to assume IAM roles in your AWS account.
        """
        return pulumi.get(self, "atlas_aws_account_arn")

    @property
    @pulumi.getter(name="authorizedDate")
    def authorized_date(self) -> str:
        """
        Date on which this role was authorized.
        """
        return pulumi.get(self, "authorized_date")

    @property
    @pulumi.getter(name="createdDate")
    def created_date(self) -> str:
        """
        Date on which this role was created.
        """
        return pulumi.get(self, "created_date")

    @property
    @pulumi.getter(name="featureUsages")
    def feature_usages(self) -> Sequence['outputs.GetCloudProviderAccessAwsIamRoleFeatureUsageResult']:
        """
        Atlas features this AWS IAM role is linked to.
        """
        return pulumi.get(self, "feature_usages")

    @property
    @pulumi.getter(name="iamAssumedRoleArn")
    def iam_assumed_role_arn(self) -> str:
        """
        ARN of the IAM Role that Atlas assumes when accessing resources in your AWS account.
        """
        return pulumi.get(self, "iam_assumed_role_arn")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Name of the cloud provider. Currently limited to AWS.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> str:
        """
        Unique ID of this role.
        """
        return pulumi.get(self, "role_id")


@pulumi.output_type
class GetCloudProviderAccessAwsIamRoleFeatureUsageResult(dict):
    def __init__(__self__, *,
                 feature_id: str,
                 feature_type: str):
        pulumi.set(__self__, "feature_id", feature_id)
        pulumi.set(__self__, "feature_type", feature_type)

    @property
    @pulumi.getter(name="featureId")
    def feature_id(self) -> str:
        return pulumi.get(self, "feature_id")

    @property
    @pulumi.getter(name="featureType")
    def feature_type(self) -> str:
        return pulumi.get(self, "feature_type")


@pulumi.output_type
class GetCloudProviderSnapshotBackupPolicyPolicyResult(dict):
    def __init__(__self__, *,
                 id: str,
                 policy_items: Sequence['outputs.GetCloudProviderSnapshotBackupPolicyPolicyPolicyItemResult']):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "policy_items", policy_items)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="policyItems")
    def policy_items(self) -> Sequence['outputs.GetCloudProviderSnapshotBackupPolicyPolicyPolicyItemResult']:
        return pulumi.get(self, "policy_items")


@pulumi.output_type
class GetCloudProviderSnapshotBackupPolicyPolicyPolicyItemResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetCloudProviderSnapshotRestoreJobsResultResult(dict):
    def __init__(__self__, *,
                 cancelled: bool,
                 created_at: str,
                 delivery_type: str,
                 delivery_urls: Sequence[str],
                 expired: bool,
                 expires_at: str,
                 finished_at: str,
                 id: str,
                 oplog_inc: int,
                 oplog_ts: int,
                 point_in_time_utc_seconds: int,
                 snapshot_id: str,
                 target_cluster_name: str,
                 target_project_id: str,
                 timestamp: str):
        """
        :param bool cancelled: Indicates whether the restore job was canceled.
        :param str created_at: UTC ISO 8601 formatted point in time when Atlas created the restore job.
        :param str delivery_type: Type of restore job to create. Possible values are: automated and download.
        :param Sequence[str] delivery_urls: One or more URLs for the compressed snapshot files for manual download. Only visible if deliveryType is download.
        :param bool expired: Indicates whether the restore job expired.
        :param str expires_at: UTC ISO 8601 formatted point in time when the restore job expires.
        :param str finished_at: UTC ISO 8601 formatted point in time when the restore job completed.
        :param str id: The unique identifier of the restore job.
        :param str snapshot_id: Unique identifier of the source snapshot ID of the restore job.
        :param str target_cluster_name: Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.
        :param str timestamp: Timestamp in ISO 8601 date and time format in UTC when the snapshot associated to snapshotId was taken.
        """
        pulumi.set(__self__, "cancelled", cancelled)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "delivery_type", delivery_type)
        pulumi.set(__self__, "delivery_urls", delivery_urls)
        pulumi.set(__self__, "expired", expired)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "finished_at", finished_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "oplog_inc", oplog_inc)
        pulumi.set(__self__, "oplog_ts", oplog_ts)
        pulumi.set(__self__, "point_in_time_utc_seconds", point_in_time_utc_seconds)
        pulumi.set(__self__, "snapshot_id", snapshot_id)
        pulumi.set(__self__, "target_cluster_name", target_cluster_name)
        pulumi.set(__self__, "target_project_id", target_project_id)
        pulumi.set(__self__, "timestamp", timestamp)

    @property
    @pulumi.getter
    def cancelled(self) -> bool:
        """
        Indicates whether the restore job was canceled.
        """
        return pulumi.get(self, "cancelled")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        UTC ISO 8601 formatted point in time when Atlas created the restore job.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="deliveryType")
    def delivery_type(self) -> str:
        """
        Type of restore job to create. Possible values are: automated and download.
        """
        return pulumi.get(self, "delivery_type")

    @property
    @pulumi.getter(name="deliveryUrls")
    def delivery_urls(self) -> Sequence[str]:
        """
        One or more URLs for the compressed snapshot files for manual download. Only visible if deliveryType is download.
        """
        return pulumi.get(self, "delivery_urls")

    @property
    @pulumi.getter
    def expired(self) -> bool:
        """
        Indicates whether the restore job expired.
        """
        return pulumi.get(self, "expired")

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> str:
        """
        UTC ISO 8601 formatted point in time when the restore job expires.
        """
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> str:
        """
        UTC ISO 8601 formatted point in time when the restore job completed.
        """
        return pulumi.get(self, "finished_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique identifier of the restore job.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="oplogInc")
    def oplog_inc(self) -> int:
        return pulumi.get(self, "oplog_inc")

    @property
    @pulumi.getter(name="oplogTs")
    def oplog_ts(self) -> int:
        return pulumi.get(self, "oplog_ts")

    @property
    @pulumi.getter(name="pointInTimeUtcSeconds")
    def point_in_time_utc_seconds(self) -> int:
        return pulumi.get(self, "point_in_time_utc_seconds")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> str:
        """
        Unique identifier of the source snapshot ID of the restore job.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter(name="targetClusterName")
    def target_cluster_name(self) -> str:
        """
        Name of the target Atlas cluster to which the restore job restores the snapshot. Only visible if deliveryType is automated.
        """
        return pulumi.get(self, "target_cluster_name")

    @property
    @pulumi.getter(name="targetProjectId")
    def target_project_id(self) -> str:
        return pulumi.get(self, "target_project_id")

    @property
    @pulumi.getter
    def timestamp(self) -> str:
        """
        Timestamp in ISO 8601 date and time format in UTC when the snapshot associated to snapshotId was taken.
        """
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class GetCloudProviderSnapshotsResultResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 description: str,
                 expires_at: str,
                 id: str,
                 master_key_uuid: str,
                 mongod_version: str,
                 snapshot_type: str,
                 status: str,
                 storage_size_bytes: int,
                 type: str):
        """
        :param str created_at: UTC ISO 8601 formatted point in time when Atlas took the snapshot.
        :param str description: UDescription of the snapshot. Only present for on-demand snapshots.
        :param str expires_at: UTC ISO 8601 formatted point in time when Atlas will delete the snapshot.
        :param str id: Unique identifier of the snapshot.
        :param str master_key_uuid: Unique ID of the AWS KMS Customer Master Key used to encrypt the snapshot. Only visible for clusters using Encryption at Rest via Customer KMS.
        :param str mongod_version: Version of the MongoDB server.
        :param str snapshot_type: Specified the type of snapshot. Valid values are onDemand and scheduled.
        :param str status: Current status of the snapshot. One of the following values: queued, inProgress, completed, failed.
        :param int storage_size_bytes: Specifies the size of the snapshot in bytes.
        :param str type: Specifies the type of cluster: replicaSet or shardedCluster.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "master_key_uuid", master_key_uuid)
        pulumi.set(__self__, "mongod_version", mongod_version)
        pulumi.set(__self__, "snapshot_type", snapshot_type)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "storage_size_bytes", storage_size_bytes)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        UTC ISO 8601 formatted point in time when Atlas took the snapshot.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        UDescription of the snapshot. Only present for on-demand snapshots.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> str:
        """
        UTC ISO 8601 formatted point in time when Atlas will delete the snapshot.
        """
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifier of the snapshot.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="masterKeyUuid")
    def master_key_uuid(self) -> str:
        """
        Unique ID of the AWS KMS Customer Master Key used to encrypt the snapshot. Only visible for clusters using Encryption at Rest via Customer KMS.
        """
        return pulumi.get(self, "master_key_uuid")

    @property
    @pulumi.getter(name="mongodVersion")
    def mongod_version(self) -> str:
        """
        Version of the MongoDB server.
        """
        return pulumi.get(self, "mongod_version")

    @property
    @pulumi.getter(name="snapshotType")
    def snapshot_type(self) -> str:
        """
        Specified the type of snapshot. Valid values are onDemand and scheduled.
        """
        return pulumi.get(self, "snapshot_type")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Current status of the snapshot. One of the following values: queued, inProgress, completed, failed.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="storageSizeBytes")
    def storage_size_bytes(self) -> int:
        """
        Specifies the size of the snapshot in bytes.
        """
        return pulumi.get(self, "storage_size_bytes")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Specifies the type of cluster: replicaSet or shardedCluster.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetClusterBiConnectorResult(dict):
    def __init__(__self__, *,
                 enabled: str,
                 read_preference: str):
        """
        :param str enabled: Indicates whether or not BI Connector for Atlas is enabled on the cluster.
        :param str read_preference: Indicates the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "read_preference", read_preference)

    @property
    @pulumi.getter
    def enabled(self) -> str:
        """
        Indicates whether or not BI Connector for Atlas is enabled on the cluster.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> str:
        """
        Indicates the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        return pulumi.get(self, "read_preference")


@pulumi.output_type
class GetClusterConnectionStringsResult(dict):
    def __init__(__self__, *,
                 aws_private_link: Mapping[str, Any],
                 aws_private_link_srv: Mapping[str, Any],
                 private: str,
                 private_endpoints: Sequence['outputs.GetClusterConnectionStringsPrivateEndpointResult'],
                 private_srv: str,
                 standard: str,
                 standard_srv: str):
        pulumi.set(__self__, "aws_private_link", aws_private_link)
        pulumi.set(__self__, "aws_private_link_srv", aws_private_link_srv)
        pulumi.set(__self__, "private", private)
        pulumi.set(__self__, "private_endpoints", private_endpoints)
        pulumi.set(__self__, "private_srv", private_srv)
        pulumi.set(__self__, "standard", standard)
        pulumi.set(__self__, "standard_srv", standard_srv)

    @property
    @pulumi.getter(name="awsPrivateLink")
    def aws_private_link(self) -> Mapping[str, Any]:
        return pulumi.get(self, "aws_private_link")

    @property
    @pulumi.getter(name="awsPrivateLinkSrv")
    def aws_private_link_srv(self) -> Mapping[str, Any]:
        return pulumi.get(self, "aws_private_link_srv")

    @property
    @pulumi.getter
    def private(self) -> str:
        return pulumi.get(self, "private")

    @property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Sequence['outputs.GetClusterConnectionStringsPrivateEndpointResult']:
        return pulumi.get(self, "private_endpoints")

    @property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> str:
        return pulumi.get(self, "private_srv")

    @property
    @pulumi.getter
    def standard(self) -> str:
        return pulumi.get(self, "standard")

    @property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> str:
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class GetClusterConnectionStringsPrivateEndpointResult(dict):
    def __init__(__self__, *,
                 connection_string: str,
                 endpoints: Sequence['outputs.GetClusterConnectionStringsPrivateEndpointEndpointResult'],
                 srv_connection_string: str,
                 type: str):
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "srv_connection_string", srv_connection_string)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> str:
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def endpoints(self) -> Sequence['outputs.GetClusterConnectionStringsPrivateEndpointEndpointResult']:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> str:
        return pulumi.get(self, "srv_connection_string")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetClusterConnectionStringsPrivateEndpointEndpointResult(dict):
    def __init__(__self__, *,
                 endpoint_id: str,
                 provider_name: str,
                 region: str):
        """
        :param str provider_name: Indicates the cloud service provider on which the servers are provisioned.
        """
        pulumi.set(__self__, "endpoint_id", endpoint_id)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> str:
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Indicates the cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetClusterLabelResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that was set.
        :param str value: The value that represents the key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that was set.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that represents the key.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterReplicationSpecResult(dict):
    def __init__(__self__, *,
                 id: str,
                 num_shards: int,
                 regions_configs: Sequence['outputs.GetClusterReplicationSpecRegionsConfigResult'],
                 zone_name: str):
        """
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster.
        :param int num_shards: Number of shards to deploy in the specified zone.
        :param Sequence['GetClusterReplicationSpecRegionsConfigArgs'] regions_configs: Describes the physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        :param str zone_name: Indicates the n ame for the zone in a Global Cluster.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "num_shards", num_shards)
        pulumi.set(__self__, "regions_configs", regions_configs)
        pulumi.set(__self__, "zone_name", zone_name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifer of the replication document for a zone in a Global Cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> int:
        """
        Number of shards to deploy in the specified zone.
        """
        return pulumi.get(self, "num_shards")

    @property
    @pulumi.getter(name="regionsConfigs")
    def regions_configs(self) -> Sequence['outputs.GetClusterReplicationSpecRegionsConfigResult']:
        """
        Describes the physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        """
        return pulumi.get(self, "regions_configs")

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> str:
        """
        Indicates the n ame for the zone in a Global Cluster.
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class GetClusterReplicationSpecRegionsConfigResult(dict):
    def __init__(__self__, *,
                 analytics_nodes: int,
                 electable_nodes: int,
                 priority: int,
                 read_only_nodes: int,
                 region_name: str):
        """
        :param int analytics_nodes: Indicates the number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary.
        :param int electable_nodes: Number of electable nodes for Atlas to deploy to the region.
        :param int priority: Election priority of the region. For regions with only read-only nodes, set this value to 0.
        :param int read_only_nodes: Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        :param str region_name: Name for the region specified.
        """
        pulumi.set(__self__, "analytics_nodes", analytics_nodes)
        pulumi.set(__self__, "electable_nodes", electable_nodes)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "read_only_nodes", read_only_nodes)
        pulumi.set(__self__, "region_name", region_name)

    @property
    @pulumi.getter(name="analyticsNodes")
    def analytics_nodes(self) -> int:
        """
        Indicates the number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary.
        """
        return pulumi.get(self, "analytics_nodes")

    @property
    @pulumi.getter(name="electableNodes")
    def electable_nodes(self) -> int:
        """
        Number of electable nodes for Atlas to deploy to the region.
        """
        return pulumi.get(self, "electable_nodes")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Election priority of the region. For regions with only read-only nodes, set this value to 0.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="readOnlyNodes")
    def read_only_nodes(self) -> int:
        """
        Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        """
        return pulumi.get(self, "read_only_nodes")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        Name for the region specified.
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class GetClusterSnapshotBackupPolicyResult(dict):
    def __init__(__self__, *,
                 cluster_id: str,
                 cluster_name: str,
                 next_snapshot: str,
                 policies: Sequence['outputs.GetClusterSnapshotBackupPolicyPolicyResult'],
                 reference_hour_of_day: int,
                 reference_minute_of_hour: int,
                 restore_window_days: int,
                 update_snapshots: bool):
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "next_snapshot", next_snapshot)
        pulumi.set(__self__, "policies", policies)
        pulumi.set(__self__, "reference_hour_of_day", reference_hour_of_day)
        pulumi.set(__self__, "reference_minute_of_hour", reference_minute_of_hour)
        pulumi.set(__self__, "restore_window_days", restore_window_days)
        pulumi.set(__self__, "update_snapshots", update_snapshots)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="nextSnapshot")
    def next_snapshot(self) -> str:
        return pulumi.get(self, "next_snapshot")

    @property
    @pulumi.getter
    def policies(self) -> Sequence['outputs.GetClusterSnapshotBackupPolicyPolicyResult']:
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="referenceHourOfDay")
    def reference_hour_of_day(self) -> int:
        return pulumi.get(self, "reference_hour_of_day")

    @property
    @pulumi.getter(name="referenceMinuteOfHour")
    def reference_minute_of_hour(self) -> int:
        return pulumi.get(self, "reference_minute_of_hour")

    @property
    @pulumi.getter(name="restoreWindowDays")
    def restore_window_days(self) -> int:
        return pulumi.get(self, "restore_window_days")

    @property
    @pulumi.getter(name="updateSnapshots")
    def update_snapshots(self) -> bool:
        return pulumi.get(self, "update_snapshots")


@pulumi.output_type
class GetClusterSnapshotBackupPolicyPolicyResult(dict):
    def __init__(__self__, *,
                 id: str,
                 policy_items: Sequence['outputs.GetClusterSnapshotBackupPolicyPolicyPolicyItemResult']):
        """
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "policy_items", policy_items)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifer of the replication document for a zone in a Global Cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="policyItems")
    def policy_items(self) -> Sequence['outputs.GetClusterSnapshotBackupPolicyPolicyPolicyItemResult']:
        return pulumi.get(self, "policy_items")


@pulumi.output_type
class GetClusterSnapshotBackupPolicyPolicyPolicyItemResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifer of the replication document for a zone in a Global Cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetClustersResultResult(dict):
    def __init__(__self__, *,
                 auto_scaling_compute_enabled: bool,
                 auto_scaling_compute_scale_down_enabled: bool,
                 auto_scaling_disk_gb_enabled: bool,
                 backing_provider_name: str,
                 backup_enabled: bool,
                 bi_connector: 'outputs.GetClustersResultBiConnectorResult',
                 cluster_type: str,
                 connection_strings: 'outputs.GetClustersResultConnectionStringsResult',
                 container_id: str,
                 disk_size_gb: float,
                 encryption_at_rest_provider: str,
                 labels: Sequence['outputs.GetClustersResultLabelResult'],
                 mongo_db_major_version: str,
                 mongo_db_version: str,
                 mongo_uri: str,
                 mongo_uri_updated: str,
                 mongo_uri_with_options: str,
                 name: str,
                 num_shards: int,
                 paused: bool,
                 pit_enabled: bool,
                 provider_auto_scaling_compute_max_instance_size: str,
                 provider_auto_scaling_compute_min_instance_size: str,
                 provider_backup_enabled: bool,
                 provider_disk_iops: int,
                 provider_disk_type_name: str,
                 provider_encrypt_ebs_volume: bool,
                 provider_instance_size_name: str,
                 provider_name: str,
                 provider_region_name: str,
                 provider_volume_type: str,
                 replication_factor: int,
                 replication_specs: Sequence['outputs.GetClustersResultReplicationSpecResult'],
                 snapshot_backup_policies: Sequence['outputs.GetClustersResultSnapshotBackupPolicyResult'],
                 srv_address: str,
                 state_name: str):
        """
        :param bool auto_scaling_compute_enabled: (Optional) Specifies whether cluster tier auto-scaling is enabled. The default is false.
        :param bool auto_scaling_compute_scale_down_enabled: (Optional) Set to `true` to enable the cluster tier to scale down.
        :param bool auto_scaling_disk_gb_enabled: Indicates whether disk auto-scaling is enabled.
        :param str backing_provider_name: Indicates Cloud service provider on which the server for a multi-tenant cluster is provisioned.
        :param bool backup_enabled: Legacy Option, Indicates whether Atlas continuous backups are enabled for the cluster.
        :param 'GetClustersResultBiConnectorArgs' bi_connector: Indicates BI Connector for Atlas configuration on this cluster. BI Connector for Atlas is only available for M10+ clusters. See BI Connector below for more details.
        :param str cluster_type: Indicates the type of the cluster that you want to modify. You cannot convert a sharded cluster deployment to a replica set deployment.
        :param 'GetClustersResultConnectionStringsArgs' connection_strings: Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.
               - `connection_strings.standard` -   Public mongodb:// connection string for this cluster.
               - `connection_strings.standard_srv` - Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t, use connectionStrings.standard.
               - `connection_strings.aws_private_link` -  [Private-endpoint-aware](https://docs.atlas.mongodb.com/security-private-endpoint/#private-endpoint-connection-strings) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a AWS PrivateLink connection to this cluster. **DEPRECATED** Use `connection_strings.private_endpoint[n].connection_string` instead.
               - `connection_strings.aws_private_link_srv` - [Private-endpoint-aware](https://docs.atlas.mongodb.com/security-private-endpoint/#private-endpoint-connection-strings) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a AWS PrivateLink connection to this cluster. Use this URI format if your driver supports it. If it doesn’t, use connectionStrings.awsPrivateLink. **DEPRECATED** `connection_strings.private_endpoint[n].srv_connection_string` instead.
               - `connection_strings.private` -   [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
               - `connection_strings.private_srv` -  [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
               - `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
               - `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint.
               - `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
               - `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`
               - `connection_strings.private_endoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.
               - `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
               - `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.
        :param str container_id: The Network Peering Container ID.
        :param float disk_size_gb: Indicates the size in gigabytes of the server’s root volume (AWS/GCP Only).
        :param str encryption_at_rest_provider: Indicates whether Encryption at Rest is enabled or disabled.
        :param str mongo_db_major_version: Indicates the version of the cluster to deploy.
        :param str mongo_db_version: Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.
        :param str mongo_uri: Base connection string for the cluster. Atlas only displays this field after the cluster is operational, not while it builds the cluster.
        :param str mongo_uri_updated: Lists when the connection string was last updated. The connection string changes, for example, if you change a replica set to a sharded cluster.
        :param str mongo_uri_with_options: Describes connection string for connecting to the Atlas cluster. Includes the replicaSet, ssl, and authSource query parameters in the connection string with values appropriate for the cluster.
        :param str name: The name of the current plugin
        :param int num_shards: Number of shards to deploy in the specified zone.
        :param bool paused: Flag that indicates whether the cluster is paused or not.
        :param bool pit_enabled: Flag that indicates if the cluster uses Continuous Cloud Backup.
        :param str provider_auto_scaling_compute_max_instance_size: (Optional) Maximum instance size to which your cluster can automatically scale.
        :param str provider_auto_scaling_compute_min_instance_size: (Optional) Minimum instance size to which your cluster can automatically scale.
        :param bool provider_backup_enabled: Flag indicating if the cluster uses Cloud Backup Snapshots for backups.
        :param int provider_disk_iops: Indicates the maximum input/output operations per second (IOPS) the system can perform. The possible values depend on the selected providerSettings.instanceSizeName and diskSizeGB.
        :param str provider_disk_type_name: Describes Azure disk type of the server’s root volume (Azure Only).
        :param bool provider_encrypt_ebs_volume: Indicates whether the Amazon EBS encryption is enabled. This feature encrypts the server’s root volume for both data at rest within the volume and data moving between the volume and the instance.
        :param str provider_instance_size_name: Atlas provides different instance sizes, each with a default storage capacity and RAM size.
        :param str provider_name: Indicates the cloud service provider on which the servers are provisioned.
        :param str provider_region_name: Indicates Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases. Requires the Atlas Region name, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        :param str provider_volume_type: Indicates the type of the volume. The possible values are: `STANDARD` and `PROVISIONED`.
        :param int replication_factor: (Deprecated) Number of replica set members. Each member keeps a copy of your databases, providing high availability and data redundancy. The possible values are 3, 5, or 7. The default value is 3.
        :param Sequence['GetClustersResultReplicationSpecArgs'] replication_specs: Configuration for cluster regions.  See Replication Spec below for more details.
        :param Sequence['GetClustersResultSnapshotBackupPolicyArgs'] snapshot_backup_policies: current snapshot schedule and retention settings for the cluster.
        :param str srv_address: Connection string for connecting to the Atlas cluster. The +srv modifier forces the connection to use TLS/SSL. See the mongoURI for additional options.
        :param str state_name: Indicates the current state of the cluster. The possible states are:
               - IDLE
               - CREATING
               - UPDATING
               - DELETING
               - DELETED
               - REPAIRING
        """
        pulumi.set(__self__, "auto_scaling_compute_enabled", auto_scaling_compute_enabled)
        pulumi.set(__self__, "auto_scaling_compute_scale_down_enabled", auto_scaling_compute_scale_down_enabled)
        pulumi.set(__self__, "auto_scaling_disk_gb_enabled", auto_scaling_disk_gb_enabled)
        pulumi.set(__self__, "backing_provider_name", backing_provider_name)
        pulumi.set(__self__, "backup_enabled", backup_enabled)
        pulumi.set(__self__, "bi_connector", bi_connector)
        pulumi.set(__self__, "cluster_type", cluster_type)
        pulumi.set(__self__, "connection_strings", connection_strings)
        pulumi.set(__self__, "container_id", container_id)
        pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        pulumi.set(__self__, "encryption_at_rest_provider", encryption_at_rest_provider)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "mongo_db_major_version", mongo_db_major_version)
        pulumi.set(__self__, "mongo_db_version", mongo_db_version)
        pulumi.set(__self__, "mongo_uri", mongo_uri)
        pulumi.set(__self__, "mongo_uri_updated", mongo_uri_updated)
        pulumi.set(__self__, "mongo_uri_with_options", mongo_uri_with_options)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "num_shards", num_shards)
        pulumi.set(__self__, "paused", paused)
        pulumi.set(__self__, "pit_enabled", pit_enabled)
        pulumi.set(__self__, "provider_auto_scaling_compute_max_instance_size", provider_auto_scaling_compute_max_instance_size)
        pulumi.set(__self__, "provider_auto_scaling_compute_min_instance_size", provider_auto_scaling_compute_min_instance_size)
        pulumi.set(__self__, "provider_backup_enabled", provider_backup_enabled)
        pulumi.set(__self__, "provider_disk_iops", provider_disk_iops)
        pulumi.set(__self__, "provider_disk_type_name", provider_disk_type_name)
        pulumi.set(__self__, "provider_encrypt_ebs_volume", provider_encrypt_ebs_volume)
        pulumi.set(__self__, "provider_instance_size_name", provider_instance_size_name)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "provider_region_name", provider_region_name)
        pulumi.set(__self__, "provider_volume_type", provider_volume_type)
        pulumi.set(__self__, "replication_factor", replication_factor)
        pulumi.set(__self__, "replication_specs", replication_specs)
        pulumi.set(__self__, "snapshot_backup_policies", snapshot_backup_policies)
        pulumi.set(__self__, "srv_address", srv_address)
        pulumi.set(__self__, "state_name", state_name)

    @property
    @pulumi.getter(name="autoScalingComputeEnabled")
    def auto_scaling_compute_enabled(self) -> bool:
        """
        (Optional) Specifies whether cluster tier auto-scaling is enabled. The default is false.
        """
        return pulumi.get(self, "auto_scaling_compute_enabled")

    @property
    @pulumi.getter(name="autoScalingComputeScaleDownEnabled")
    def auto_scaling_compute_scale_down_enabled(self) -> bool:
        """
        (Optional) Set to `true` to enable the cluster tier to scale down.
        """
        return pulumi.get(self, "auto_scaling_compute_scale_down_enabled")

    @property
    @pulumi.getter(name="autoScalingDiskGbEnabled")
    def auto_scaling_disk_gb_enabled(self) -> bool:
        """
        Indicates whether disk auto-scaling is enabled.
        """
        return pulumi.get(self, "auto_scaling_disk_gb_enabled")

    @property
    @pulumi.getter(name="backingProviderName")
    def backing_provider_name(self) -> str:
        """
        Indicates Cloud service provider on which the server for a multi-tenant cluster is provisioned.
        """
        return pulumi.get(self, "backing_provider_name")

    @property
    @pulumi.getter(name="backupEnabled")
    def backup_enabled(self) -> bool:
        """
        Legacy Option, Indicates whether Atlas continuous backups are enabled for the cluster.
        """
        return pulumi.get(self, "backup_enabled")

    @property
    @pulumi.getter(name="biConnector")
    def bi_connector(self) -> 'outputs.GetClustersResultBiConnectorResult':
        """
        Indicates BI Connector for Atlas configuration on this cluster. BI Connector for Atlas is only available for M10+ clusters. See BI Connector below for more details.
        """
        return pulumi.get(self, "bi_connector")

    @property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> str:
        """
        Indicates the type of the cluster that you want to modify. You cannot convert a sharded cluster deployment to a replica set deployment.
        """
        return pulumi.get(self, "cluster_type")

    @property
    @pulumi.getter(name="connectionStrings")
    def connection_strings(self) -> 'outputs.GetClustersResultConnectionStringsResult':
        """
        Set of connection strings that your applications use to connect to this cluster. More info in [Connection-strings](https://docs.mongodb.com/manual/reference/connection-string/). Use the parameters in this object to connect your applications to this cluster. To learn more about the formats of connection strings, see [Connection String Options](https://docs.atlas.mongodb.com/reference/faq/connection-changes/). NOTE: Atlas returns the contents of this object after the cluster is operational, not while it builds the cluster.
        - `connection_strings.standard` -   Public mongodb:// connection string for this cluster.
        - `connection_strings.standard_srv` - Public mongodb+srv:// connection string for this cluster. The mongodb+srv protocol tells the driver to look up the seed list of hosts in DNS. Atlas synchronizes this list with the nodes in a cluster. If the connection string uses this URI format, you don’t need to append the seed list or change the URI if the nodes change. Use this URI format if your driver supports it. If it doesn’t, use connectionStrings.standard.
        - `connection_strings.aws_private_link` -  [Private-endpoint-aware](https://docs.atlas.mongodb.com/security-private-endpoint/#private-endpoint-connection-strings) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a AWS PrivateLink connection to this cluster. **DEPRECATED** Use `connection_strings.private_endpoint[n].connection_string` instead.
        - `connection_strings.aws_private_link_srv` - [Private-endpoint-aware](https://docs.atlas.mongodb.com/security-private-endpoint/#private-endpoint-connection-strings) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a AWS PrivateLink connection to this cluster. Use this URI format if your driver supports it. If it doesn’t, use connectionStrings.awsPrivateLink. **DEPRECATED** `connection_strings.private_endpoint[n].srv_connection_string` instead.
        - `connection_strings.private` -   [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        - `connection_strings.private_srv` -  [Network-peering-endpoint-aware](https://docs.atlas.mongodb.com/security-vpc-peering/#vpc-peering) mongodb+srv://connection strings for each interface VPC endpoint you configured to connect to this cluster. Returned only if you created a network peering connection to this cluster.
        - `connection_strings.private_endpoint.#.connection_string` - Private-endpoint-aware `mongodb://`connection string for this private endpoint.
        - `connection_strings.private_endpoint.#.srv_connection_string` - Private-endpoint-aware `mongodb+srv://` connection string for this private endpoint.
        - `connection_strings.private_endpoint.#.type` - Type of MongoDB process that you connect to with the connection strings. Atlas returns `MONGOD` for replica sets, or `MONGOS` for sharded clusters.
        - `connection_strings.private_endpoint.#.endpoints` - Private endpoint through which you connect to Atlas when you use `connection_strings.private_endpoint[n].connection_string` or `connection_strings.private_endpoint[n].srv_connection_string`
        - `connection_strings.private_endoint.#.endpoints.#.endpoint_id` - Unique identifier of the private endpoint.
        - `connection_strings.private_endpoint.#.endpoints.#.provider_name` - Cloud provider to which you deployed the private endpoint. Atlas returns `AWS` or `AZURE`.
        - `connection_strings.private_endpoint.#.endpoints.#.region` - Region to which you deployed the private endpoint.
        """
        return pulumi.get(self, "connection_strings")

    @property
    @pulumi.getter(name="containerId")
    def container_id(self) -> str:
        """
        The Network Peering Container ID.
        """
        return pulumi.get(self, "container_id")

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> float:
        """
        Indicates the size in gigabytes of the server’s root volume (AWS/GCP Only).
        """
        return pulumi.get(self, "disk_size_gb")

    @property
    @pulumi.getter(name="encryptionAtRestProvider")
    def encryption_at_rest_provider(self) -> str:
        """
        Indicates whether Encryption at Rest is enabled or disabled.
        """
        return pulumi.get(self, "encryption_at_rest_provider")

    @property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetClustersResultLabelResult']:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="mongoDbMajorVersion")
    def mongo_db_major_version(self) -> str:
        """
        Indicates the version of the cluster to deploy.
        """
        return pulumi.get(self, "mongo_db_major_version")

    @property
    @pulumi.getter(name="mongoDbVersion")
    def mongo_db_version(self) -> str:
        """
        Version of MongoDB the cluster runs, in `major-version`.`minor-version` format.
        """
        return pulumi.get(self, "mongo_db_version")

    @property
    @pulumi.getter(name="mongoUri")
    def mongo_uri(self) -> str:
        """
        Base connection string for the cluster. Atlas only displays this field after the cluster is operational, not while it builds the cluster.
        """
        return pulumi.get(self, "mongo_uri")

    @property
    @pulumi.getter(name="mongoUriUpdated")
    def mongo_uri_updated(self) -> str:
        """
        Lists when the connection string was last updated. The connection string changes, for example, if you change a replica set to a sharded cluster.
        """
        return pulumi.get(self, "mongo_uri_updated")

    @property
    @pulumi.getter(name="mongoUriWithOptions")
    def mongo_uri_with_options(self) -> str:
        """
        Describes connection string for connecting to the Atlas cluster. Includes the replicaSet, ssl, and authSource query parameters in the connection string with values appropriate for the cluster.
        """
        return pulumi.get(self, "mongo_uri_with_options")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the current plugin
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> int:
        """
        Number of shards to deploy in the specified zone.
        """
        return pulumi.get(self, "num_shards")

    @property
    @pulumi.getter
    def paused(self) -> bool:
        """
        Flag that indicates whether the cluster is paused or not.
        """
        return pulumi.get(self, "paused")

    @property
    @pulumi.getter(name="pitEnabled")
    def pit_enabled(self) -> bool:
        """
        Flag that indicates if the cluster uses Continuous Cloud Backup.
        """
        return pulumi.get(self, "pit_enabled")

    @property
    @pulumi.getter(name="providerAutoScalingComputeMaxInstanceSize")
    def provider_auto_scaling_compute_max_instance_size(self) -> str:
        """
        (Optional) Maximum instance size to which your cluster can automatically scale.
        """
        return pulumi.get(self, "provider_auto_scaling_compute_max_instance_size")

    @property
    @pulumi.getter(name="providerAutoScalingComputeMinInstanceSize")
    def provider_auto_scaling_compute_min_instance_size(self) -> str:
        """
        (Optional) Minimum instance size to which your cluster can automatically scale.
        """
        return pulumi.get(self, "provider_auto_scaling_compute_min_instance_size")

    @property
    @pulumi.getter(name="providerBackupEnabled")
    def provider_backup_enabled(self) -> bool:
        """
        Flag indicating if the cluster uses Cloud Backup Snapshots for backups.
        """
        return pulumi.get(self, "provider_backup_enabled")

    @property
    @pulumi.getter(name="providerDiskIops")
    def provider_disk_iops(self) -> int:
        """
        Indicates the maximum input/output operations per second (IOPS) the system can perform. The possible values depend on the selected providerSettings.instanceSizeName and diskSizeGB.
        """
        return pulumi.get(self, "provider_disk_iops")

    @property
    @pulumi.getter(name="providerDiskTypeName")
    def provider_disk_type_name(self) -> str:
        """
        Describes Azure disk type of the server’s root volume (Azure Only).
        """
        return pulumi.get(self, "provider_disk_type_name")

    @property
    @pulumi.getter(name="providerEncryptEbsVolume")
    def provider_encrypt_ebs_volume(self) -> bool:
        """
        Indicates whether the Amazon EBS encryption is enabled. This feature encrypts the server’s root volume for both data at rest within the volume and data moving between the volume and the instance.
        """
        return pulumi.get(self, "provider_encrypt_ebs_volume")

    @property
    @pulumi.getter(name="providerInstanceSizeName")
    def provider_instance_size_name(self) -> str:
        """
        Atlas provides different instance sizes, each with a default storage capacity and RAM size.
        """
        return pulumi.get(self, "provider_instance_size_name")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Indicates the cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter(name="providerRegionName")
    def provider_region_name(self) -> str:
        """
        Indicates Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases. Requires the Atlas Region name, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        """
        return pulumi.get(self, "provider_region_name")

    @property
    @pulumi.getter(name="providerVolumeType")
    def provider_volume_type(self) -> str:
        """
        Indicates the type of the volume. The possible values are: `STANDARD` and `PROVISIONED`.
        """
        return pulumi.get(self, "provider_volume_type")

    @property
    @pulumi.getter(name="replicationFactor")
    def replication_factor(self) -> int:
        """
        (Deprecated) Number of replica set members. Each member keeps a copy of your databases, providing high availability and data redundancy. The possible values are 3, 5, or 7. The default value is 3.
        """
        return pulumi.get(self, "replication_factor")

    @property
    @pulumi.getter(name="replicationSpecs")
    def replication_specs(self) -> Sequence['outputs.GetClustersResultReplicationSpecResult']:
        """
        Configuration for cluster regions.  See Replication Spec below for more details.
        """
        return pulumi.get(self, "replication_specs")

    @property
    @pulumi.getter(name="snapshotBackupPolicies")
    def snapshot_backup_policies(self) -> Sequence['outputs.GetClustersResultSnapshotBackupPolicyResult']:
        """
        current snapshot schedule and retention settings for the cluster.
        """
        return pulumi.get(self, "snapshot_backup_policies")

    @property
    @pulumi.getter(name="srvAddress")
    def srv_address(self) -> str:
        """
        Connection string for connecting to the Atlas cluster. The +srv modifier forces the connection to use TLS/SSL. See the mongoURI for additional options.
        """
        return pulumi.get(self, "srv_address")

    @property
    @pulumi.getter(name="stateName")
    def state_name(self) -> str:
        """
        Indicates the current state of the cluster. The possible states are:
        - IDLE
        - CREATING
        - UPDATING
        - DELETING
        - DELETED
        - REPAIRING
        """
        return pulumi.get(self, "state_name")


@pulumi.output_type
class GetClustersResultBiConnectorResult(dict):
    def __init__(__self__, *,
                 enabled: str,
                 read_preference: str):
        """
        :param str enabled: Indicates whether or not BI Connector for Atlas is enabled on the cluster.
        :param str read_preference: Indicates the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "read_preference", read_preference)

    @property
    @pulumi.getter
    def enabled(self) -> str:
        """
        Indicates whether or not BI Connector for Atlas is enabled on the cluster.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> str:
        """
        Indicates the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        return pulumi.get(self, "read_preference")


@pulumi.output_type
class GetClustersResultConnectionStringsResult(dict):
    def __init__(__self__, *,
                 aws_private_link: Mapping[str, Any],
                 aws_private_link_srv: Mapping[str, Any],
                 private: str,
                 private_endpoints: Sequence['outputs.GetClustersResultConnectionStringsPrivateEndpointResult'],
                 private_srv: str,
                 standard: str,
                 standard_srv: str):
        pulumi.set(__self__, "aws_private_link", aws_private_link)
        pulumi.set(__self__, "aws_private_link_srv", aws_private_link_srv)
        pulumi.set(__self__, "private", private)
        pulumi.set(__self__, "private_endpoints", private_endpoints)
        pulumi.set(__self__, "private_srv", private_srv)
        pulumi.set(__self__, "standard", standard)
        pulumi.set(__self__, "standard_srv", standard_srv)

    @property
    @pulumi.getter(name="awsPrivateLink")
    def aws_private_link(self) -> Mapping[str, Any]:
        return pulumi.get(self, "aws_private_link")

    @property
    @pulumi.getter(name="awsPrivateLinkSrv")
    def aws_private_link_srv(self) -> Mapping[str, Any]:
        return pulumi.get(self, "aws_private_link_srv")

    @property
    @pulumi.getter
    def private(self) -> str:
        return pulumi.get(self, "private")

    @property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Sequence['outputs.GetClustersResultConnectionStringsPrivateEndpointResult']:
        return pulumi.get(self, "private_endpoints")

    @property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> str:
        return pulumi.get(self, "private_srv")

    @property
    @pulumi.getter
    def standard(self) -> str:
        return pulumi.get(self, "standard")

    @property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> str:
        return pulumi.get(self, "standard_srv")


@pulumi.output_type
class GetClustersResultConnectionStringsPrivateEndpointResult(dict):
    def __init__(__self__, *,
                 connection_string: str,
                 endpoints: Sequence['outputs.GetClustersResultConnectionStringsPrivateEndpointEndpointResult'],
                 srv_connection_string: str,
                 type: str):
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "endpoints", endpoints)
        pulumi.set(__self__, "srv_connection_string", srv_connection_string)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> str:
        return pulumi.get(self, "connection_string")

    @property
    @pulumi.getter
    def endpoints(self) -> Sequence['outputs.GetClustersResultConnectionStringsPrivateEndpointEndpointResult']:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> str:
        return pulumi.get(self, "srv_connection_string")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetClustersResultConnectionStringsPrivateEndpointEndpointResult(dict):
    def __init__(__self__, *,
                 endpoint_id: str,
                 provider_name: str,
                 region: str):
        """
        :param str provider_name: Indicates the cloud service provider on which the servers are provisioned.
        """
        pulumi.set(__self__, "endpoint_id", endpoint_id)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> str:
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Indicates the cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")


@pulumi.output_type
class GetClustersResultLabelResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that was set.
        :param str value: The value that represents the key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that was set.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that represents the key.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClustersResultReplicationSpecResult(dict):
    def __init__(__self__, *,
                 id: str,
                 num_shards: int,
                 regions_configs: Sequence['outputs.GetClustersResultReplicationSpecRegionsConfigResult'],
                 zone_name: str):
        """
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster.
        :param int num_shards: Number of shards to deploy in the specified zone.
        :param Sequence['GetClustersResultReplicationSpecRegionsConfigArgs'] regions_configs: Describes the physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        :param str zone_name: Indicates the n ame for the zone in a Global Cluster.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "num_shards", num_shards)
        pulumi.set(__self__, "regions_configs", regions_configs)
        pulumi.set(__self__, "zone_name", zone_name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifer of the replication document for a zone in a Global Cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> int:
        """
        Number of shards to deploy in the specified zone.
        """
        return pulumi.get(self, "num_shards")

    @property
    @pulumi.getter(name="regionsConfigs")
    def regions_configs(self) -> Sequence['outputs.GetClustersResultReplicationSpecRegionsConfigResult']:
        """
        Describes the physical location of the region. Each regionsConfig document describes the region’s priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        """
        return pulumi.get(self, "regions_configs")

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> str:
        """
        Indicates the n ame for the zone in a Global Cluster.
        """
        return pulumi.get(self, "zone_name")


@pulumi.output_type
class GetClustersResultReplicationSpecRegionsConfigResult(dict):
    def __init__(__self__, *,
                 analytics_nodes: int,
                 electable_nodes: int,
                 priority: int,
                 read_only_nodes: int,
                 region_name: str):
        """
        :param int analytics_nodes: Indicates the number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary.
        :param int electable_nodes: Number of electable nodes for Atlas to deploy to the region.
        :param int priority: Election priority of the region. For regions with only read-only nodes, set this value to 0.
        :param int read_only_nodes: Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        :param str region_name: Name for the region specified.
        """
        pulumi.set(__self__, "analytics_nodes", analytics_nodes)
        pulumi.set(__self__, "electable_nodes", electable_nodes)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "read_only_nodes", read_only_nodes)
        pulumi.set(__self__, "region_name", region_name)

    @property
    @pulumi.getter(name="analyticsNodes")
    def analytics_nodes(self) -> int:
        """
        Indicates the number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary.
        """
        return pulumi.get(self, "analytics_nodes")

    @property
    @pulumi.getter(name="electableNodes")
    def electable_nodes(self) -> int:
        """
        Number of electable nodes for Atlas to deploy to the region.
        """
        return pulumi.get(self, "electable_nodes")

    @property
    @pulumi.getter
    def priority(self) -> int:
        """
        Election priority of the region. For regions with only read-only nodes, set this value to 0.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="readOnlyNodes")
    def read_only_nodes(self) -> int:
        """
        Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        """
        return pulumi.get(self, "read_only_nodes")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        Name for the region specified.
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class GetClustersResultSnapshotBackupPolicyResult(dict):
    def __init__(__self__, *,
                 cluster_id: str,
                 cluster_name: str,
                 next_snapshot: str,
                 policies: Sequence['outputs.GetClustersResultSnapshotBackupPolicyPolicyResult'],
                 reference_hour_of_day: int,
                 reference_minute_of_hour: int,
                 restore_window_days: int,
                 update_snapshots: bool):
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "next_snapshot", next_snapshot)
        pulumi.set(__self__, "policies", policies)
        pulumi.set(__self__, "reference_hour_of_day", reference_hour_of_day)
        pulumi.set(__self__, "reference_minute_of_hour", reference_minute_of_hour)
        pulumi.set(__self__, "restore_window_days", restore_window_days)
        pulumi.set(__self__, "update_snapshots", update_snapshots)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="nextSnapshot")
    def next_snapshot(self) -> str:
        return pulumi.get(self, "next_snapshot")

    @property
    @pulumi.getter
    def policies(self) -> Sequence['outputs.GetClustersResultSnapshotBackupPolicyPolicyResult']:
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="referenceHourOfDay")
    def reference_hour_of_day(self) -> int:
        return pulumi.get(self, "reference_hour_of_day")

    @property
    @pulumi.getter(name="referenceMinuteOfHour")
    def reference_minute_of_hour(self) -> int:
        return pulumi.get(self, "reference_minute_of_hour")

    @property
    @pulumi.getter(name="restoreWindowDays")
    def restore_window_days(self) -> int:
        return pulumi.get(self, "restore_window_days")

    @property
    @pulumi.getter(name="updateSnapshots")
    def update_snapshots(self) -> bool:
        return pulumi.get(self, "update_snapshots")


@pulumi.output_type
class GetClustersResultSnapshotBackupPolicyPolicyResult(dict):
    def __init__(__self__, *,
                 id: str,
                 policy_items: Sequence['outputs.GetClustersResultSnapshotBackupPolicyPolicyPolicyItemResult']):
        """
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "policy_items", policy_items)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifer of the replication document for a zone in a Global Cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="policyItems")
    def policy_items(self) -> Sequence['outputs.GetClustersResultSnapshotBackupPolicyPolicyPolicyItemResult']:
        return pulumi.get(self, "policy_items")


@pulumi.output_type
class GetClustersResultSnapshotBackupPolicyPolicyPolicyItemResult(dict):
    def __init__(__self__, *,
                 frequency_interval: int,
                 frequency_type: str,
                 id: str,
                 retention_unit: str,
                 retention_value: int):
        """
        :param str id: Unique identifer of the replication document for a zone in a Global Cluster.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> int:
        return pulumi.get(self, "frequency_interval")

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> str:
        return pulumi.get(self, "frequency_type")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Unique identifer of the replication document for a zone in a Global Cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> str:
        return pulumi.get(self, "retention_unit")

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> int:
        return pulumi.get(self, "retention_value")


@pulumi.output_type
class GetCustomDbRoleActionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 resources: Sequence['outputs.GetCustomDbRoleActionResourceResult']):
        """
        :param str action: (Required) Name of the privilege action. For a complete list of actions available in the Atlas API, see Custom Role Actions.
        :param Sequence['GetCustomDbRoleActionResourceArgs'] resources: (Required) Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        (Required) Name of the privilege action. For a complete list of actions available in the Atlas API, see Custom Role Actions.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetCustomDbRoleActionResourceResult']:
        """
        (Required) Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetCustomDbRoleActionResourceResult(dict):
    def __init__(__self__, *,
                 cluster: bool,
                 collection_name: str,
                 database_name: str):
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "database_name", database_name)

    @property
    @pulumi.getter
    def cluster(self) -> bool:
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> str:
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        return pulumi.get(self, "database_name")


@pulumi.output_type
class GetCustomDbRoleInheritedRoleResult(dict):
    def __init__(__self__, *,
                 database_name: str,
                 role_name: str):
        """
        :param str role_name: Name of the custom role.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        """
        Name of the custom role.
        """
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetCustomDbRolesResultResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetCustomDbRolesResultActionResult'],
                 inherited_roles: Sequence['outputs.GetCustomDbRolesResultInheritedRoleResult'],
                 role_name: str):
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "inherited_roles", inherited_roles)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetCustomDbRolesResultActionResult']:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="inheritedRoles")
    def inherited_roles(self) -> Sequence['outputs.GetCustomDbRolesResultInheritedRoleResult']:
        return pulumi.get(self, "inherited_roles")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetCustomDbRolesResultActionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 resources: Sequence['outputs.GetCustomDbRolesResultActionResourceResult']):
        """
        :param str action: (Required) Name of the privilege action. For a complete list of actions available in the Atlas API, see Custom Role Actions.
        :param Sequence['GetCustomDbRolesResultActionResourceArgs'] resources: (Required) Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        (Required) Name of the privilege action. For a complete list of actions available in the Atlas API, see Custom Role Actions.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetCustomDbRolesResultActionResourceResult']:
        """
        (Required) Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetCustomDbRolesResultActionResourceResult(dict):
    def __init__(__self__, *,
                 cluster: bool,
                 collection_name: str,
                 database_name: str):
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "database_name", database_name)

    @property
    @pulumi.getter
    def cluster(self) -> bool:
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> str:
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        return pulumi.get(self, "database_name")


@pulumi.output_type
class GetCustomDbRolesResultInheritedRoleResult(dict):
    def __init__(__self__, *,
                 database_name: str,
                 role_name: str):
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetDatabaseUserLabelResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDatabaseUserRoleResult(dict):
    def __init__(__self__, *,
                 collection_name: str,
                 database_name: str,
                 role_name: str):
        """
        :param str collection_name: Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        :param str database_name: Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.
        """
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> str:
        """
        Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        """
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetDatabaseUserScopeResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str):
        """
        :param str name: Name of the role to grant.
        :param str type: Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the role to grant.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetDatabaseUsersResultResult(dict):
    def __init__(__self__, *,
                 auth_database_name: str,
                 aws_iam_type: str,
                 labels: Sequence['outputs.GetDatabaseUsersResultLabelResult'],
                 project_id: str,
                 roles: Sequence['outputs.GetDatabaseUsersResultRoleResult'],
                 scopes: Sequence['outputs.GetDatabaseUsersResultScopeResult'],
                 username: str,
                 x509_type: str):
        """
        :param str auth_database_name: (Required) Database against which Atlas authenticates the user. A user must provide both a username and authentication database to log into MongoDB.
               Possible values include:
               * `admin` if `x509_type` and `aws_iam_type` are omitted or NONE.
               * `$external` if:
               * `x509_type` is MANAGED or CUSTOMER, or
               * `aws_iam_type` is USER or ROLE.
        :param str aws_iam_type: The new database user authenticates with AWS IAM credentials. Default is `NONE`, `USER` means user has AWS IAM user credentials, `ROLE` - means user has credentials associated with an AWS IAM role.
        :param str project_id: The unique ID for the project to get all database users.
        :param Sequence['GetDatabaseUsersResultRoleArgs'] roles: List of user’s roles and the databases / collections on which the roles apply. A role allows the user to perform particular actions on the specified database. A role on the admin database can include privileges that apply to the other databases as well. See Roles below for more details.
        :param Sequence['GetDatabaseUsersResultScopeArgs'] scopes: Array of clusters and Atlas Data Lakes that this user has access to.
        :param str username: Username for authenticating to MongoDB.
        :param str x509_type: X.509 method by which the provided username is authenticated.
        """
        pulumi.set(__self__, "auth_database_name", auth_database_name)
        pulumi.set(__self__, "aws_iam_type", aws_iam_type)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "x509_type", x509_type)

    @property
    @pulumi.getter(name="authDatabaseName")
    def auth_database_name(self) -> str:
        """
        (Required) Database against which Atlas authenticates the user. A user must provide both a username and authentication database to log into MongoDB.
        Possible values include:
        * `admin` if `x509_type` and `aws_iam_type` are omitted or NONE.
        * `$external` if:
        * `x509_type` is MANAGED or CUSTOMER, or
        * `aws_iam_type` is USER or ROLE.
        """
        return pulumi.get(self, "auth_database_name")

    @property
    @pulumi.getter(name="awsIamType")
    def aws_iam_type(self) -> str:
        """
        The new database user authenticates with AWS IAM credentials. Default is `NONE`, `USER` means user has AWS IAM user credentials, `ROLE` - means user has credentials associated with an AWS IAM role.
        """
        return pulumi.get(self, "aws_iam_type")

    @property
    @pulumi.getter
    def labels(self) -> Sequence['outputs.GetDatabaseUsersResultLabelResult']:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project to get all database users.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def roles(self) -> Sequence['outputs.GetDatabaseUsersResultRoleResult']:
        """
        List of user’s roles and the databases / collections on which the roles apply. A role allows the user to perform particular actions on the specified database. A role on the admin database can include privileges that apply to the other databases as well. See Roles below for more details.
        """
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence['outputs.GetDatabaseUsersResultScopeResult']:
        """
        Array of clusters and Atlas Data Lakes that this user has access to.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username for authenticating to MongoDB.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="x509Type")
    def x509_type(self) -> str:
        """
        X.509 method by which the provided username is authenticated.
        """
        return pulumi.get(self, "x509_type")


@pulumi.output_type
class GetDatabaseUsersResultLabelResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key that you want to write.
        :param str value: The value that you want to write.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetDatabaseUsersResultRoleResult(dict):
    def __init__(__self__, *,
                 collection_name: str,
                 database_name: str,
                 role_name: str):
        """
        :param str collection_name: Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        :param str database_name: Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.
        """
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> str:
        """
        Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        """
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        return pulumi.get(self, "role_name")


@pulumi.output_type
class GetDatabaseUsersResultScopeResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str):
        """
        :param str name: Name of the role to grant.
        :param str type: Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the role to grant.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetGlobalClusterConfigManagedNamespaceResult(dict):
    def __init__(__self__, *,
                 collection: str,
                 custom_shard_key: str,
                 db: str):
        """
        :param str collection: (Required) The name of the collection associated with the managed namespace.
        :param str custom_shard_key: (Required)	The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        :param str db: (Required) The name of the database containing the collection.
        """
        pulumi.set(__self__, "collection", collection)
        pulumi.set(__self__, "custom_shard_key", custom_shard_key)
        pulumi.set(__self__, "db", db)

    @property
    @pulumi.getter
    def collection(self) -> str:
        """
        (Required) The name of the collection associated with the managed namespace.
        """
        return pulumi.get(self, "collection")

    @property
    @pulumi.getter(name="customShardKey")
    def custom_shard_key(self) -> str:
        """
        (Required)	The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        """
        return pulumi.get(self, "custom_shard_key")

    @property
    @pulumi.getter
    def db(self) -> str:
        """
        (Required) The name of the database containing the collection.
        """
        return pulumi.get(self, "db")


@pulumi.output_type
class GetNetworkContainersResultResult(dict):
    def __init__(__self__, *,
                 atlas_cidr_block: str,
                 azure_subscription_id: str,
                 gcp_project_id: str,
                 id: str,
                 network_name: str,
                 provider_name: str,
                 provisioned: bool,
                 region: str,
                 region_name: str,
                 vnet_name: str,
                 vpc_id: str):
        """
        :param str atlas_cidr_block: CIDR block that Atlas uses for your clusters. Atlas uses the specified CIDR block for all other Network Peering connections created in the project. The Atlas CIDR block must be at least a /24 and at most a /21 in one of the following [private networks](https://tools.ietf.org/html/rfc1918.html#section-3).
        :param str azure_subscription_id: Unique identifer of the Azure subscription in which the VNet resides.
        :param str gcp_project_id: Unique identifier of the GCP project in which the Network Peering connection resides.
        :param str id: The Network Peering Container ID.
        :param str network_name: Name of the Network Peering connection in the Atlas project.
        :param str provider_name: Cloud provider for this Network peering container. Accepted values are AWS, GCP, and Azure.
        :param bool provisioned: Indicates whether the project has Network Peering connections deployed in the container.
        :param str region: The Atlas Azure region name for where this container exists.
        :param str region_name: The Atlas AWS region name for where this container exists.
        :param str vnet_name: The name of the Azure VNet. This value is null until you provision an Azure VNet in the container.
        :param str vpc_id: Unique identifier of the project’s VPC.
        """
        pulumi.set(__self__, "atlas_cidr_block", atlas_cidr_block)
        pulumi.set(__self__, "azure_subscription_id", azure_subscription_id)
        pulumi.set(__self__, "gcp_project_id", gcp_project_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "network_name", network_name)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "provisioned", provisioned)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "region_name", region_name)
        pulumi.set(__self__, "vnet_name", vnet_name)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="atlasCidrBlock")
    def atlas_cidr_block(self) -> str:
        """
        CIDR block that Atlas uses for your clusters. Atlas uses the specified CIDR block for all other Network Peering connections created in the project. The Atlas CIDR block must be at least a /24 and at most a /21 in one of the following [private networks](https://tools.ietf.org/html/rfc1918.html#section-3).
        """
        return pulumi.get(self, "atlas_cidr_block")

    @property
    @pulumi.getter(name="azureSubscriptionId")
    def azure_subscription_id(self) -> str:
        """
        Unique identifer of the Azure subscription in which the VNet resides.
        """
        return pulumi.get(self, "azure_subscription_id")

    @property
    @pulumi.getter(name="gcpProjectId")
    def gcp_project_id(self) -> str:
        """
        Unique identifier of the GCP project in which the Network Peering connection resides.
        """
        return pulumi.get(self, "gcp_project_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The Network Peering Container ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="networkName")
    def network_name(self) -> str:
        """
        Name of the Network Peering connection in the Atlas project.
        """
        return pulumi.get(self, "network_name")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Cloud provider for this Network peering container. Accepted values are AWS, GCP, and Azure.
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter
    def provisioned(self) -> bool:
        """
        Indicates whether the project has Network Peering connections deployed in the container.
        """
        return pulumi.get(self, "provisioned")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        The Atlas Azure region name for where this container exists.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        The Atlas AWS region name for where this container exists.
        """
        return pulumi.get(self, "region_name")

    @property
    @pulumi.getter(name="vnetName")
    def vnet_name(self) -> str:
        """
        The name of the Azure VNet. This value is null until you provision an Azure VNet in the container.
        """
        return pulumi.get(self, "vnet_name")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        Unique identifier of the project’s VPC.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetNetworkPeeringsResultResult(dict):
    def __init__(__self__, *,
                 accepter_region_name: str,
                 atlas_cidr_block: str,
                 aws_account_id: str,
                 azure_directory_id: str,
                 azure_subscription_id: str,
                 connection_id: str,
                 container_id: str,
                 error_message: str,
                 error_state: str,
                 error_state_name: str,
                 gcp_project_id: str,
                 network_name: str,
                 peering_id: str,
                 provider_name: str,
                 resource_group_name: str,
                 route_table_cidr_block: str,
                 status: str,
                 status_name: str,
                 vnet_name: str,
                 vpc_id: str):
        """
        :param str accepter_region_name: Specifies the region where the peer VPC resides. For complete lists of supported regions, see [Amazon Web Services](https://docs.atlas.mongodb.com/reference/amazon-aws/).
        :param str atlas_cidr_block: Unique identifier for an Azure AD directory.
        :param str aws_account_id: Account ID of the owner of the peer VPC.
        :param str azure_directory_id: Unique identifier for an Azure AD directory.
        :param str azure_subscription_id: Unique identifer of the Azure subscription in which the VNet resides.
        :param str connection_id: Unique identifier for the peering connection.
        :param str error_message: When `"status" : "FAILED"`, Atlas provides a description of the error.
        :param str error_state: Description of the Atlas error when `status` is `Failed`, Otherwise, Atlas returns `null`.
        :param str error_state_name: Error state, if any. The VPC peering connection error state value can be one of the following: `REJECTED`, `EXPIRED`, `INVALID_ARGUMENT`.
        :param str gcp_project_id: GCP project ID of the owner of the network peer.
        :param str network_name: Name of the network peer to which Atlas connects.
        :param str peering_id: Atlas assigned unique ID for the peering connection.
        :param str provider_name: Cloud provider for this VPC peering connection. If omitted, Atlas sets this parameter to AWS. (Possible Values `AWS`, `AZURE`, `GCP`).
        :param str resource_group_name: Name of your Azure resource group.
        :param str route_table_cidr_block: Peer VPC CIDR block or subnet.
        :param str status: Status of the Atlas network peering connection: `ADDING_PEER`, `AVAILABLE`, `FAILED`, `DELETING`, `WAITING_FOR_USER`.
        :param str status_name: The VPC peering connection status value can be one of the following: `INITIATING`, `PENDING_ACCEPTANCE`, `FAILED`, `FINALIZING`, `AVAILABLE`, `TERMINATING`.
        :param str vnet_name: Name of your Azure VNet.
        :param str vpc_id: Unique identifier of the peer VPC.
        """
        pulumi.set(__self__, "accepter_region_name", accepter_region_name)
        pulumi.set(__self__, "atlas_cidr_block", atlas_cidr_block)
        pulumi.set(__self__, "aws_account_id", aws_account_id)
        pulumi.set(__self__, "azure_directory_id", azure_directory_id)
        pulumi.set(__self__, "azure_subscription_id", azure_subscription_id)
        pulumi.set(__self__, "connection_id", connection_id)
        pulumi.set(__self__, "container_id", container_id)
        pulumi.set(__self__, "error_message", error_message)
        pulumi.set(__self__, "error_state", error_state)
        pulumi.set(__self__, "error_state_name", error_state_name)
        pulumi.set(__self__, "gcp_project_id", gcp_project_id)
        pulumi.set(__self__, "network_name", network_name)
        pulumi.set(__self__, "peering_id", peering_id)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "resource_group_name", resource_group_name)
        pulumi.set(__self__, "route_table_cidr_block", route_table_cidr_block)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "status_name", status_name)
        pulumi.set(__self__, "vnet_name", vnet_name)
        pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="accepterRegionName")
    def accepter_region_name(self) -> str:
        """
        Specifies the region where the peer VPC resides. For complete lists of supported regions, see [Amazon Web Services](https://docs.atlas.mongodb.com/reference/amazon-aws/).
        """
        return pulumi.get(self, "accepter_region_name")

    @property
    @pulumi.getter(name="atlasCidrBlock")
    def atlas_cidr_block(self) -> str:
        """
        Unique identifier for an Azure AD directory.
        """
        return pulumi.get(self, "atlas_cidr_block")

    @property
    @pulumi.getter(name="awsAccountId")
    def aws_account_id(self) -> str:
        """
        Account ID of the owner of the peer VPC.
        """
        return pulumi.get(self, "aws_account_id")

    @property
    @pulumi.getter(name="azureDirectoryId")
    def azure_directory_id(self) -> str:
        """
        Unique identifier for an Azure AD directory.
        """
        return pulumi.get(self, "azure_directory_id")

    @property
    @pulumi.getter(name="azureSubscriptionId")
    def azure_subscription_id(self) -> str:
        """
        Unique identifer of the Azure subscription in which the VNet resides.
        """
        return pulumi.get(self, "azure_subscription_id")

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> str:
        """
        Unique identifier for the peering connection.
        """
        return pulumi.get(self, "connection_id")

    @property
    @pulumi.getter(name="containerId")
    def container_id(self) -> str:
        return pulumi.get(self, "container_id")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> str:
        """
        When `"status" : "FAILED"`, Atlas provides a description of the error.
        """
        return pulumi.get(self, "error_message")

    @property
    @pulumi.getter(name="errorState")
    def error_state(self) -> str:
        """
        Description of the Atlas error when `status` is `Failed`, Otherwise, Atlas returns `null`.
        """
        return pulumi.get(self, "error_state")

    @property
    @pulumi.getter(name="errorStateName")
    def error_state_name(self) -> str:
        """
        Error state, if any. The VPC peering connection error state value can be one of the following: `REJECTED`, `EXPIRED`, `INVALID_ARGUMENT`.
        """
        return pulumi.get(self, "error_state_name")

    @property
    @pulumi.getter(name="gcpProjectId")
    def gcp_project_id(self) -> str:
        """
        GCP project ID of the owner of the network peer.
        """
        return pulumi.get(self, "gcp_project_id")

    @property
    @pulumi.getter(name="networkName")
    def network_name(self) -> str:
        """
        Name of the network peer to which Atlas connects.
        """
        return pulumi.get(self, "network_name")

    @property
    @pulumi.getter(name="peeringId")
    def peering_id(self) -> str:
        """
        Atlas assigned unique ID for the peering connection.
        """
        return pulumi.get(self, "peering_id")

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> str:
        """
        Cloud provider for this VPC peering connection. If omitted, Atlas sets this parameter to AWS. (Possible Values `AWS`, `AZURE`, `GCP`).
        """
        return pulumi.get(self, "provider_name")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> str:
        """
        Name of your Azure resource group.
        """
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter(name="routeTableCidrBlock")
    def route_table_cidr_block(self) -> str:
        """
        Peer VPC CIDR block or subnet.
        """
        return pulumi.get(self, "route_table_cidr_block")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the Atlas network peering connection: `ADDING_PEER`, `AVAILABLE`, `FAILED`, `DELETING`, `WAITING_FOR_USER`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="statusName")
    def status_name(self) -> str:
        """
        The VPC peering connection status value can be one of the following: `INITIATING`, `PENDING_ACCEPTANCE`, `FAILED`, `FINALIZING`, `AVAILABLE`, `TERMINATING`.
        """
        return pulumi.get(self, "status_name")

    @property
    @pulumi.getter(name="vnetName")
    def vnet_name(self) -> str:
        """
        Name of your Azure VNet.
        """
        return pulumi.get(self, "vnet_name")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        Unique identifier of the peer VPC.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class GetProjectTeamResult(dict):
    def __init__(__self__, *,
                 role_names: Sequence[str],
                 team_id: str):
        pulumi.set(__self__, "role_names", role_names)
        pulumi.set(__self__, "team_id", team_id)

    @property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[str]:
        return pulumi.get(self, "role_names")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> str:
        return pulumi.get(self, "team_id")


@pulumi.output_type
class GetProjectsResultResult(dict):
    def __init__(__self__, *,
                 cluster_count: int,
                 created: str,
                 id: str,
                 name: str,
                 org_id: str,
                 teams: Sequence['outputs.GetProjectsResultTeamResult']):
        """
        :param str id: Autogenerated Unique ID for this data source.
        :param str name: The name of the project you want to create. (Cannot be changed via this Provider after creation.)
        :param str org_id: The ID of the organization you want to create the project within.
               *`cluster_count` - The number of Atlas clusters deployed in the project.
               *`created` - The ISO-8601-formatted timestamp of when Atlas created the project.
               * `teams.#.team_id` - The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
               * `teams.#.role_names` - Each string in the array represents a project role assigned to the team. Every user associated with the team inherits these roles.
               The following are valid roles:
               * `GROUP_OWNER`
               * `GROUP_READ_ONLY`
               * `GROUP_DATA_ACCESS_ADMIN`
               * `GROUP_DATA_ACCESS_READ_WRITE`
               * `GROUP_DATA_ACCESS_READ_ONLY`
               * `GROUP_CLUSTER_MANAGER`
        """
        pulumi.set(__self__, "cluster_count", cluster_count)
        pulumi.set(__self__, "created", created)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "teams", teams)

    @property
    @pulumi.getter(name="clusterCount")
    def cluster_count(self) -> int:
        return pulumi.get(self, "cluster_count")

    @property
    @pulumi.getter
    def created(self) -> str:
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Autogenerated Unique ID for this data source.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the project you want to create. (Cannot be changed via this Provider after creation.)
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        The ID of the organization you want to create the project within.
        *`cluster_count` - The number of Atlas clusters deployed in the project.
        *`created` - The ISO-8601-formatted timestamp of when Atlas created the project.
        * `teams.#.team_id` - The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
        * `teams.#.role_names` - Each string in the array represents a project role assigned to the team. Every user associated with the team inherits these roles.
        The following are valid roles:
        * `GROUP_OWNER`
        * `GROUP_READ_ONLY`
        * `GROUP_DATA_ACCESS_ADMIN`
        * `GROUP_DATA_ACCESS_READ_WRITE`
        * `GROUP_DATA_ACCESS_READ_ONLY`
        * `GROUP_CLUSTER_MANAGER`
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter
    def teams(self) -> Sequence['outputs.GetProjectsResultTeamResult']:
        return pulumi.get(self, "teams")


@pulumi.output_type
class GetProjectsResultTeamResult(dict):
    def __init__(__self__, *,
                 role_names: Sequence[str],
                 team_id: str):
        pulumi.set(__self__, "role_names", role_names)
        pulumi.set(__self__, "team_id", team_id)

    @property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> Sequence[str]:
        return pulumi.get(self, "role_names")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> str:
        return pulumi.get(self, "team_id")


@pulumi.output_type
class GetThirdPartyIntegrationsResultResult(dict):
    def __init__(__self__, *,
                 account_id: str,
                 api_key: str,
                 api_token: str,
                 channel_name: str,
                 flow_name: str,
                 license_key: str,
                 org_name: str,
                 project_id: str,
                 read_token: str,
                 region: str,
                 routing_key: str,
                 secret: str,
                 service_key: str,
                 team_name: str,
                 type: str,
                 url: str,
                 write_token: str):
        """
        :param str account_id: Unique identifier of your New Relic account.
        :param str api_key: Your API Key.
        :param str api_token: Your API Token.
        :param str flow_name: Your Flowdock Flow name.
        :param str license_key: Your License Key.
        :param str org_name: Your Flowdock organization name.
               * `WEBHOOK`
        :param str project_id: The unique ID for the project to get all Third-Party service integrations
        :param str read_token: Your Insights Query Key.
               * `OPS_GENIE`
        :param str region: Indicates which API URL to use, either US or EU. Opsgenie will use US by default.
               * `VICTOR_OPS`
        :param str routing_key: An optional field for your Routing Key.
               * `FLOWDOCK`
        :param str secret: An optional field for your webhook secret.
        :param str service_key: Your Service Key.
               * `DATADOG`
        :param str type: (Required) Thirt-Party service integration type.
        :param str url: Your webhook URL.
        :param str write_token: Your Insights Insert Key.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "api_key", api_key)
        pulumi.set(__self__, "api_token", api_token)
        pulumi.set(__self__, "channel_name", channel_name)
        pulumi.set(__self__, "flow_name", flow_name)
        pulumi.set(__self__, "license_key", license_key)
        pulumi.set(__self__, "org_name", org_name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "read_token", read_token)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "routing_key", routing_key)
        pulumi.set(__self__, "secret", secret)
        pulumi.set(__self__, "service_key", service_key)
        pulumi.set(__self__, "team_name", team_name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "write_token", write_token)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        """
        Unique identifier of your New Relic account.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> str:
        """
        Your API Key.
        """
        return pulumi.get(self, "api_key")

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> str:
        """
        Your API Token.
        """
        return pulumi.get(self, "api_token")

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> str:
        return pulumi.get(self, "channel_name")

    @property
    @pulumi.getter(name="flowName")
    def flow_name(self) -> str:
        """
        Your Flowdock Flow name.
        """
        return pulumi.get(self, "flow_name")

    @property
    @pulumi.getter(name="licenseKey")
    def license_key(self) -> str:
        """
        Your License Key.
        """
        return pulumi.get(self, "license_key")

    @property
    @pulumi.getter(name="orgName")
    def org_name(self) -> str:
        """
        Your Flowdock organization name.
        * `WEBHOOK`
        """
        return pulumi.get(self, "org_name")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The unique ID for the project to get all Third-Party service integrations
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="readToken")
    def read_token(self) -> str:
        """
        Your Insights Query Key.
        * `OPS_GENIE`
        """
        return pulumi.get(self, "read_token")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        Indicates which API URL to use, either US or EU. Opsgenie will use US by default.
        * `VICTOR_OPS`
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="routingKey")
    def routing_key(self) -> str:
        """
        An optional field for your Routing Key.
        * `FLOWDOCK`
        """
        return pulumi.get(self, "routing_key")

    @property
    @pulumi.getter
    def secret(self) -> str:
        """
        An optional field for your webhook secret.
        """
        return pulumi.get(self, "secret")

    @property
    @pulumi.getter(name="serviceKey")
    def service_key(self) -> str:
        """
        Your Service Key.
        * `DATADOG`
        """
        return pulumi.get(self, "service_key")

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> str:
        return pulumi.get(self, "team_name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        (Required) Thirt-Party service integration type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        Your webhook URL.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="writeToken")
    def write_token(self) -> str:
        """
        Your Insights Insert Key.
        """
        return pulumi.get(self, "write_token")


