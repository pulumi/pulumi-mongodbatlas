# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['OnlineArchiveArgs', 'OnlineArchive']

@pulumi.input_type
class OnlineArchiveArgs:
    def __init__(__self__, *,
                 cluster_name: pulumi.Input[str],
                 coll_name: pulumi.Input[str],
                 criteria: pulumi.Input['OnlineArchiveCriteriaArgs'],
                 db_name: pulumi.Input[str],
                 project_id: pulumi.Input[str],
                 collection_type: Optional[pulumi.Input[str]] = None,
                 partition_fields: Optional[pulumi.Input[Sequence[pulumi.Input['OnlineArchivePartitionFieldArgs']]]] = None,
                 paused: Optional[pulumi.Input[bool]] = None,
                 schedule: Optional[pulumi.Input['OnlineArchiveScheduleArgs']] = None,
                 sync_creation: Optional[pulumi.Input[bool]] = None):
        """
        The set of arguments for constructing a OnlineArchive resource.
        :param pulumi.Input[str] cluster_name: Name of the cluster that contains the collection.
        :param pulumi.Input[str] coll_name: Name of the collection.
        :param pulumi.Input['OnlineArchiveCriteriaArgs'] criteria: Criteria to use for archiving data.
        :param pulumi.Input[str] db_name: Name of the database that contains the collection.
        :param pulumi.Input[str] project_id: The unique ID for the project
        :param pulumi.Input[str] collection_type: Classification of MongoDB database collection that you want to return, "TIMESERIES" or "STANDARD". Default is "STANDARD".
        :param pulumi.Input[Sequence[pulumi.Input['OnlineArchivePartitionFieldArgs']]] partition_fields: Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Note that queries that don’t contain the specified fields will require a full collection scan of all archived documents, which will take longer and increase your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived.
        :param pulumi.Input[bool] paused: State of the online archive. This is required for pausing an active or resume a paused online archive. The resume request will fail if the collection has another active online archive.
        """
        OnlineArchiveArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster_name=cluster_name,
            coll_name=coll_name,
            criteria=criteria,
            db_name=db_name,
            project_id=project_id,
            collection_type=collection_type,
            partition_fields=partition_fields,
            paused=paused,
            schedule=schedule,
            sync_creation=sync_creation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster_name: pulumi.Input[str],
             coll_name: pulumi.Input[str],
             criteria: pulumi.Input['OnlineArchiveCriteriaArgs'],
             db_name: pulumi.Input[str],
             project_id: pulumi.Input[str],
             collection_type: Optional[pulumi.Input[str]] = None,
             partition_fields: Optional[pulumi.Input[Sequence[pulumi.Input['OnlineArchivePartitionFieldArgs']]]] = None,
             paused: Optional[pulumi.Input[bool]] = None,
             schedule: Optional[pulumi.Input['OnlineArchiveScheduleArgs']] = None,
             sync_creation: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cluster_name", cluster_name)
        _setter("coll_name", coll_name)
        _setter("criteria", criteria)
        _setter("db_name", db_name)
        _setter("project_id", project_id)
        if collection_type is not None:
            _setter("collection_type", collection_type)
        if partition_fields is not None:
            _setter("partition_fields", partition_fields)
        if paused is not None:
            _setter("paused", paused)
        if schedule is not None:
            _setter("schedule", schedule)
        if sync_creation is not None:
            _setter("sync_creation", sync_creation)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[str]:
        """
        Name of the cluster that contains the collection.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="collName")
    def coll_name(self) -> pulumi.Input[str]:
        """
        Name of the collection.
        """
        return pulumi.get(self, "coll_name")

    @coll_name.setter
    def coll_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "coll_name", value)

    @property
    @pulumi.getter
    def criteria(self) -> pulumi.Input['OnlineArchiveCriteriaArgs']:
        """
        Criteria to use for archiving data.
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: pulumi.Input['OnlineArchiveCriteriaArgs']):
        pulumi.set(self, "criteria", value)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> pulumi.Input[str]:
        """
        Name of the database that contains the collection.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        The unique ID for the project
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="collectionType")
    def collection_type(self) -> Optional[pulumi.Input[str]]:
        """
        Classification of MongoDB database collection that you want to return, "TIMESERIES" or "STANDARD". Default is "STANDARD".
        """
        return pulumi.get(self, "collection_type")

    @collection_type.setter
    def collection_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "collection_type", value)

    @property
    @pulumi.getter(name="partitionFields")
    def partition_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OnlineArchivePartitionFieldArgs']]]]:
        """
        Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Note that queries that don’t contain the specified fields will require a full collection scan of all archived documents, which will take longer and increase your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived.
        """
        return pulumi.get(self, "partition_fields")

    @partition_fields.setter
    def partition_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OnlineArchivePartitionFieldArgs']]]]):
        pulumi.set(self, "partition_fields", value)

    @property
    @pulumi.getter
    def paused(self) -> Optional[pulumi.Input[bool]]:
        """
        State of the online archive. This is required for pausing an active or resume a paused online archive. The resume request will fail if the collection has another active online archive.
        """
        return pulumi.get(self, "paused")

    @paused.setter
    def paused(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "paused", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input['OnlineArchiveScheduleArgs']]:
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input['OnlineArchiveScheduleArgs']]):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter(name="syncCreation")
    def sync_creation(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "sync_creation")

    @sync_creation.setter
    def sync_creation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_creation", value)


@pulumi.input_type
class _OnlineArchiveState:
    def __init__(__self__, *,
                 archive_id: Optional[pulumi.Input[str]] = None,
                 cluster_name: Optional[pulumi.Input[str]] = None,
                 coll_name: Optional[pulumi.Input[str]] = None,
                 collection_type: Optional[pulumi.Input[str]] = None,
                 criteria: Optional[pulumi.Input['OnlineArchiveCriteriaArgs']] = None,
                 db_name: Optional[pulumi.Input[str]] = None,
                 partition_fields: Optional[pulumi.Input[Sequence[pulumi.Input['OnlineArchivePartitionFieldArgs']]]] = None,
                 paused: Optional[pulumi.Input[bool]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 schedule: Optional[pulumi.Input['OnlineArchiveScheduleArgs']] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 sync_creation: Optional[pulumi.Input[bool]] = None):
        """
        Input properties used for looking up and filtering OnlineArchive resources.
        :param pulumi.Input[str] archive_id: ID of the online archive.
        :param pulumi.Input[str] cluster_name: Name of the cluster that contains the collection.
        :param pulumi.Input[str] coll_name: Name of the collection.
        :param pulumi.Input[str] collection_type: Classification of MongoDB database collection that you want to return, "TIMESERIES" or "STANDARD". Default is "STANDARD".
        :param pulumi.Input['OnlineArchiveCriteriaArgs'] criteria: Criteria to use for archiving data.
        :param pulumi.Input[str] db_name: Name of the database that contains the collection.
        :param pulumi.Input[Sequence[pulumi.Input['OnlineArchivePartitionFieldArgs']]] partition_fields: Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Note that queries that don’t contain the specified fields will require a full collection scan of all archived documents, which will take longer and increase your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived.
        :param pulumi.Input[bool] paused: State of the online archive. This is required for pausing an active or resume a paused online archive. The resume request will fail if the collection has another active online archive.
        :param pulumi.Input[str] project_id: The unique ID for the project
        :param pulumi.Input[str] state: Status of the online archive. Valid values are: Pending, Archiving, Idle, Pausing, Paused, Orphaned and Deleted
        """
        _OnlineArchiveState._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            archive_id=archive_id,
            cluster_name=cluster_name,
            coll_name=coll_name,
            collection_type=collection_type,
            criteria=criteria,
            db_name=db_name,
            partition_fields=partition_fields,
            paused=paused,
            project_id=project_id,
            schedule=schedule,
            state=state,
            sync_creation=sync_creation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             archive_id: Optional[pulumi.Input[str]] = None,
             cluster_name: Optional[pulumi.Input[str]] = None,
             coll_name: Optional[pulumi.Input[str]] = None,
             collection_type: Optional[pulumi.Input[str]] = None,
             criteria: Optional[pulumi.Input['OnlineArchiveCriteriaArgs']] = None,
             db_name: Optional[pulumi.Input[str]] = None,
             partition_fields: Optional[pulumi.Input[Sequence[pulumi.Input['OnlineArchivePartitionFieldArgs']]]] = None,
             paused: Optional[pulumi.Input[bool]] = None,
             project_id: Optional[pulumi.Input[str]] = None,
             schedule: Optional[pulumi.Input['OnlineArchiveScheduleArgs']] = None,
             state: Optional[pulumi.Input[str]] = None,
             sync_creation: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if archive_id is not None:
            _setter("archive_id", archive_id)
        if cluster_name is not None:
            _setter("cluster_name", cluster_name)
        if coll_name is not None:
            _setter("coll_name", coll_name)
        if collection_type is not None:
            _setter("collection_type", collection_type)
        if criteria is not None:
            _setter("criteria", criteria)
        if db_name is not None:
            _setter("db_name", db_name)
        if partition_fields is not None:
            _setter("partition_fields", partition_fields)
        if paused is not None:
            _setter("paused", paused)
        if project_id is not None:
            _setter("project_id", project_id)
        if schedule is not None:
            _setter("schedule", schedule)
        if state is not None:
            _setter("state", state)
        if sync_creation is not None:
            _setter("sync_creation", sync_creation)

    @property
    @pulumi.getter(name="archiveId")
    def archive_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the online archive.
        """
        return pulumi.get(self, "archive_id")

    @archive_id.setter
    def archive_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "archive_id", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the cluster that contains the collection.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="collName")
    def coll_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the collection.
        """
        return pulumi.get(self, "coll_name")

    @coll_name.setter
    def coll_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "coll_name", value)

    @property
    @pulumi.getter(name="collectionType")
    def collection_type(self) -> Optional[pulumi.Input[str]]:
        """
        Classification of MongoDB database collection that you want to return, "TIMESERIES" or "STANDARD". Default is "STANDARD".
        """
        return pulumi.get(self, "collection_type")

    @collection_type.setter
    def collection_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "collection_type", value)

    @property
    @pulumi.getter
    def criteria(self) -> Optional[pulumi.Input['OnlineArchiveCriteriaArgs']]:
        """
        Criteria to use for archiving data.
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: Optional[pulumi.Input['OnlineArchiveCriteriaArgs']]):
        pulumi.set(self, "criteria", value)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the database that contains the collection.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter(name="partitionFields")
    def partition_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OnlineArchivePartitionFieldArgs']]]]:
        """
        Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Note that queries that don’t contain the specified fields will require a full collection scan of all archived documents, which will take longer and increase your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived.
        """
        return pulumi.get(self, "partition_fields")

    @partition_fields.setter
    def partition_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OnlineArchivePartitionFieldArgs']]]]):
        pulumi.set(self, "partition_fields", value)

    @property
    @pulumi.getter
    def paused(self) -> Optional[pulumi.Input[bool]]:
        """
        State of the online archive. This is required for pausing an active or resume a paused online archive. The resume request will fail if the collection has another active online archive.
        """
        return pulumi.get(self, "paused")

    @paused.setter
    def paused(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "paused", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique ID for the project
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input['OnlineArchiveScheduleArgs']]:
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input['OnlineArchiveScheduleArgs']]):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        Status of the online archive. Valid values are: Pending, Archiving, Idle, Pausing, Paused, Orphaned and Deleted
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="syncCreation")
    def sync_creation(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "sync_creation")

    @sync_creation.setter
    def sync_creation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sync_creation", value)


class OnlineArchive(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 cluster_name: Optional[pulumi.Input[str]] = None,
                 coll_name: Optional[pulumi.Input[str]] = None,
                 collection_type: Optional[pulumi.Input[str]] = None,
                 criteria: Optional[pulumi.Input[pulumi.InputType['OnlineArchiveCriteriaArgs']]] = None,
                 db_name: Optional[pulumi.Input[str]] = None,
                 partition_fields: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['OnlineArchivePartitionFieldArgs']]]]] = None,
                 paused: Optional[pulumi.Input[bool]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 schedule: Optional[pulumi.Input[pulumi.InputType['OnlineArchiveScheduleArgs']]] = None,
                 sync_creation: Optional[pulumi.Input[bool]] = None,
                 __props__=None):
        """
        `OnlineArchive` resource provides access to create, edit, pause and resume an online archive for a collection.

        > **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.

        > **IMPORTANT:** The collection must exists before performing an online archive.

        > **IMPORTANT:** There are fields that are immutable after creation, i.e if `date_field` value does not exist in the collection, the online archive state will be pending forever, and this field cannot be updated, that means a destroy is required, known error `ONLINE_ARCHIVE_CANNOT_MODIFY_FIELD`

        ## Example Usage
        ### S
        ```python
        import pulumi
        import pulumi_mongodbatlas as mongodbatlas

        test = mongodbatlas.OnlineArchive("test",
            project_id=var["project_id"],
            cluster_name=var["cluster_name"],
            coll_name=var["collection_name"],
            db_name=var["database_name"],
            partition_fields=[
                mongodbatlas.OnlineArchivePartitionFieldArgs(
                    field_name="firstName",
                    order=0,
                ),
                mongodbatlas.OnlineArchivePartitionFieldArgs(
                    field_name="lastName",
                    order=1,
                ),
            ],
            criteria=mongodbatlas.OnlineArchiveCriteriaArgs(
                type="DATE",
                date_field="created",
                expire_after_days=5,
            ),
            schedule=mongodbatlas.OnlineArchiveScheduleArgs(
                type="DAILY",
                end_hour=1,
                end_minute=1,
                start_hour=1,
                start_minute=1,
            ))
        ```

        For custom criteria example

        ```python
        import pulumi
        import pulumi_mongodbatlas as mongodbatlas

        test = mongodbatlas.OnlineArchive("test",
            project_id=var["project_id"],
            cluster_name=var["cluster_name"],
            coll_name=var["collection_name"],
            db_name=var["database_name"],
            partition_fields=[
                mongodbatlas.OnlineArchivePartitionFieldArgs(
                    field_name="firstName",
                    order=0,
                ),
                mongodbatlas.OnlineArchivePartitionFieldArgs(
                    field_name="secondName",
                    order=1,
                ),
            ],
            criteria=mongodbatlas.OnlineArchiveCriteriaArgs(
                type="CUSTOM",
                query="{ \\"department\\": \\"engineering\\" }",
            ))
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] cluster_name: Name of the cluster that contains the collection.
        :param pulumi.Input[str] coll_name: Name of the collection.
        :param pulumi.Input[str] collection_type: Classification of MongoDB database collection that you want to return, "TIMESERIES" or "STANDARD". Default is "STANDARD".
        :param pulumi.Input[pulumi.InputType['OnlineArchiveCriteriaArgs']] criteria: Criteria to use for archiving data.
        :param pulumi.Input[str] db_name: Name of the database that contains the collection.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['OnlineArchivePartitionFieldArgs']]]] partition_fields: Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Note that queries that don’t contain the specified fields will require a full collection scan of all archived documents, which will take longer and increase your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived.
        :param pulumi.Input[bool] paused: State of the online archive. This is required for pausing an active or resume a paused online archive. The resume request will fail if the collection has another active online archive.
        :param pulumi.Input[str] project_id: The unique ID for the project
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: OnlineArchiveArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        `OnlineArchive` resource provides access to create, edit, pause and resume an online archive for a collection.

        > **NOTE:** Groups and projects are synonymous terms. You may find group_id in the official documentation.

        > **IMPORTANT:** The collection must exists before performing an online archive.

        > **IMPORTANT:** There are fields that are immutable after creation, i.e if `date_field` value does not exist in the collection, the online archive state will be pending forever, and this field cannot be updated, that means a destroy is required, known error `ONLINE_ARCHIVE_CANNOT_MODIFY_FIELD`

        ## Example Usage
        ### S
        ```python
        import pulumi
        import pulumi_mongodbatlas as mongodbatlas

        test = mongodbatlas.OnlineArchive("test",
            project_id=var["project_id"],
            cluster_name=var["cluster_name"],
            coll_name=var["collection_name"],
            db_name=var["database_name"],
            partition_fields=[
                mongodbatlas.OnlineArchivePartitionFieldArgs(
                    field_name="firstName",
                    order=0,
                ),
                mongodbatlas.OnlineArchivePartitionFieldArgs(
                    field_name="lastName",
                    order=1,
                ),
            ],
            criteria=mongodbatlas.OnlineArchiveCriteriaArgs(
                type="DATE",
                date_field="created",
                expire_after_days=5,
            ),
            schedule=mongodbatlas.OnlineArchiveScheduleArgs(
                type="DAILY",
                end_hour=1,
                end_minute=1,
                start_hour=1,
                start_minute=1,
            ))
        ```

        For custom criteria example

        ```python
        import pulumi
        import pulumi_mongodbatlas as mongodbatlas

        test = mongodbatlas.OnlineArchive("test",
            project_id=var["project_id"],
            cluster_name=var["cluster_name"],
            coll_name=var["collection_name"],
            db_name=var["database_name"],
            partition_fields=[
                mongodbatlas.OnlineArchivePartitionFieldArgs(
                    field_name="firstName",
                    order=0,
                ),
                mongodbatlas.OnlineArchivePartitionFieldArgs(
                    field_name="secondName",
                    order=1,
                ),
            ],
            criteria=mongodbatlas.OnlineArchiveCriteriaArgs(
                type="CUSTOM",
                query="{ \\"department\\": \\"engineering\\" }",
            ))
        ```

        :param str resource_name: The name of the resource.
        :param OnlineArchiveArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(OnlineArchiveArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            kwargs = kwargs or {}
            def _setter(key, value):
                kwargs[key] = value
            OnlineArchiveArgs._configure(_setter, **kwargs)
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 cluster_name: Optional[pulumi.Input[str]] = None,
                 coll_name: Optional[pulumi.Input[str]] = None,
                 collection_type: Optional[pulumi.Input[str]] = None,
                 criteria: Optional[pulumi.Input[pulumi.InputType['OnlineArchiveCriteriaArgs']]] = None,
                 db_name: Optional[pulumi.Input[str]] = None,
                 partition_fields: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['OnlineArchivePartitionFieldArgs']]]]] = None,
                 paused: Optional[pulumi.Input[bool]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 schedule: Optional[pulumi.Input[pulumi.InputType['OnlineArchiveScheduleArgs']]] = None,
                 sync_creation: Optional[pulumi.Input[bool]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = OnlineArchiveArgs.__new__(OnlineArchiveArgs)

            if cluster_name is None and not opts.urn:
                raise TypeError("Missing required property 'cluster_name'")
            __props__.__dict__["cluster_name"] = cluster_name
            if coll_name is None and not opts.urn:
                raise TypeError("Missing required property 'coll_name'")
            __props__.__dict__["coll_name"] = coll_name
            __props__.__dict__["collection_type"] = collection_type
            if criteria is not None and not isinstance(criteria, OnlineArchiveCriteriaArgs):
                criteria = criteria or {}
                def _setter(key, value):
                    criteria[key] = value
                OnlineArchiveCriteriaArgs._configure(_setter, **criteria)
            if criteria is None and not opts.urn:
                raise TypeError("Missing required property 'criteria'")
            __props__.__dict__["criteria"] = criteria
            if db_name is None and not opts.urn:
                raise TypeError("Missing required property 'db_name'")
            __props__.__dict__["db_name"] = db_name
            __props__.__dict__["partition_fields"] = partition_fields
            __props__.__dict__["paused"] = paused
            if project_id is None and not opts.urn:
                raise TypeError("Missing required property 'project_id'")
            __props__.__dict__["project_id"] = project_id
            if schedule is not None and not isinstance(schedule, OnlineArchiveScheduleArgs):
                schedule = schedule or {}
                def _setter(key, value):
                    schedule[key] = value
                OnlineArchiveScheduleArgs._configure(_setter, **schedule)
            __props__.__dict__["schedule"] = schedule
            __props__.__dict__["sync_creation"] = sync_creation
            __props__.__dict__["archive_id"] = None
            __props__.__dict__["state"] = None
        super(OnlineArchive, __self__).__init__(
            'mongodbatlas:index/onlineArchive:OnlineArchive',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            archive_id: Optional[pulumi.Input[str]] = None,
            cluster_name: Optional[pulumi.Input[str]] = None,
            coll_name: Optional[pulumi.Input[str]] = None,
            collection_type: Optional[pulumi.Input[str]] = None,
            criteria: Optional[pulumi.Input[pulumi.InputType['OnlineArchiveCriteriaArgs']]] = None,
            db_name: Optional[pulumi.Input[str]] = None,
            partition_fields: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['OnlineArchivePartitionFieldArgs']]]]] = None,
            paused: Optional[pulumi.Input[bool]] = None,
            project_id: Optional[pulumi.Input[str]] = None,
            schedule: Optional[pulumi.Input[pulumi.InputType['OnlineArchiveScheduleArgs']]] = None,
            state: Optional[pulumi.Input[str]] = None,
            sync_creation: Optional[pulumi.Input[bool]] = None) -> 'OnlineArchive':
        """
        Get an existing OnlineArchive resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] archive_id: ID of the online archive.
        :param pulumi.Input[str] cluster_name: Name of the cluster that contains the collection.
        :param pulumi.Input[str] coll_name: Name of the collection.
        :param pulumi.Input[str] collection_type: Classification of MongoDB database collection that you want to return, "TIMESERIES" or "STANDARD". Default is "STANDARD".
        :param pulumi.Input[pulumi.InputType['OnlineArchiveCriteriaArgs']] criteria: Criteria to use for archiving data.
        :param pulumi.Input[str] db_name: Name of the database that contains the collection.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['OnlineArchivePartitionFieldArgs']]]] partition_fields: Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Note that queries that don’t contain the specified fields will require a full collection scan of all archived documents, which will take longer and increase your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived.
        :param pulumi.Input[bool] paused: State of the online archive. This is required for pausing an active or resume a paused online archive. The resume request will fail if the collection has another active online archive.
        :param pulumi.Input[str] project_id: The unique ID for the project
        :param pulumi.Input[str] state: Status of the online archive. Valid values are: Pending, Archiving, Idle, Pausing, Paused, Orphaned and Deleted
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _OnlineArchiveState.__new__(_OnlineArchiveState)

        __props__.__dict__["archive_id"] = archive_id
        __props__.__dict__["cluster_name"] = cluster_name
        __props__.__dict__["coll_name"] = coll_name
        __props__.__dict__["collection_type"] = collection_type
        __props__.__dict__["criteria"] = criteria
        __props__.__dict__["db_name"] = db_name
        __props__.__dict__["partition_fields"] = partition_fields
        __props__.__dict__["paused"] = paused
        __props__.__dict__["project_id"] = project_id
        __props__.__dict__["schedule"] = schedule
        __props__.__dict__["state"] = state
        __props__.__dict__["sync_creation"] = sync_creation
        return OnlineArchive(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="archiveId")
    def archive_id(self) -> pulumi.Output[str]:
        """
        ID of the online archive.
        """
        return pulumi.get(self, "archive_id")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Output[str]:
        """
        Name of the cluster that contains the collection.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="collName")
    def coll_name(self) -> pulumi.Output[str]:
        """
        Name of the collection.
        """
        return pulumi.get(self, "coll_name")

    @property
    @pulumi.getter(name="collectionType")
    def collection_type(self) -> pulumi.Output[str]:
        """
        Classification of MongoDB database collection that you want to return, "TIMESERIES" or "STANDARD". Default is "STANDARD".
        """
        return pulumi.get(self, "collection_type")

    @property
    @pulumi.getter
    def criteria(self) -> pulumi.Output['outputs.OnlineArchiveCriteria']:
        """
        Criteria to use for archiving data.
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> pulumi.Output[str]:
        """
        Name of the database that contains the collection.
        """
        return pulumi.get(self, "db_name")

    @property
    @pulumi.getter(name="partitionFields")
    def partition_fields(self) -> pulumi.Output[Sequence['outputs.OnlineArchivePartitionField']]:
        """
        Fields to use to partition data. You can specify up to two frequently queried fields to use for partitioning data. Note that queries that don’t contain the specified fields will require a full collection scan of all archived documents, which will take longer and increase your costs. To learn more about how partition improves query performance, see [Data Structure in S3](https://docs.mongodb.com/datalake/admin/optimize-query-performance/#data-structure-in-s3). The value of a partition field can be up to a maximum of 700 characters. Documents with values exceeding 700 characters are not archived.
        """
        return pulumi.get(self, "partition_fields")

    @property
    @pulumi.getter
    def paused(self) -> pulumi.Output[bool]:
        """
        State of the online archive. This is required for pausing an active or resume a paused online archive. The resume request will fail if the collection has another active online archive.
        """
        return pulumi.get(self, "paused")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Output[str]:
        """
        The unique ID for the project
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def schedule(self) -> pulumi.Output[Optional['outputs.OnlineArchiveSchedule']]:
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter
    def state(self) -> pulumi.Output[str]:
        """
        Status of the online archive. Valid values are: Pending, Archiving, Idle, Pausing, Paused, Orphaned and Deleted
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="syncCreation")
    def sync_creation(self) -> pulumi.Output[Optional[bool]]:
        return pulumi.get(self, "sync_creation")

