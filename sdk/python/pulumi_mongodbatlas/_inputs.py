# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'AdvancedClusterAdvancedConfigurationArgs',
    'AdvancedClusterBiConnectorArgs',
    'AdvancedClusterConnectionStringArgs',
    'AdvancedClusterConnectionStringPrivateEndpointArgs',
    'AdvancedClusterConnectionStringPrivateEndpointEndpointArgs',
    'AdvancedClusterLabelArgs',
    'AdvancedClusterReplicationSpecArgs',
    'AdvancedClusterReplicationSpecRegionConfigArgs',
    'AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgs',
    'AdvancedClusterReplicationSpecRegionConfigAutoScalingArgs',
    'AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs',
    'AdvancedClusterReplicationSpecRegionConfigReadOnlySpecsArgs',
    'AlertConfigurationMatcherArgs',
    'AlertConfigurationMetricThresholdConfigArgs',
    'AlertConfigurationNotificationArgs',
    'AlertConfigurationThresholdConfigArgs',
    'CloudBackupScheduleExportArgs',
    'CloudBackupSchedulePolicyItemDailyArgs',
    'CloudBackupSchedulePolicyItemHourlyArgs',
    'CloudBackupSchedulePolicyItemMonthlyArgs',
    'CloudBackupSchedulePolicyItemWeeklyArgs',
    'CloudBackupSnapshotExportJobComponentArgs',
    'CloudBackupSnapshotExportJobCustomDataArgs',
    'CloudBackupSnapshotMemberArgs',
    'CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs',
    'CloudProviderAccessAuthorizationAwsArgs',
    'CloudProviderAccessAuthorizationFeatureUsageArgs',
    'CloudProviderAccessFeatureUsageArgs',
    'CloudProviderAccessSetupAwsConfigArgs',
    'CloudProviderSnapshotBackupPolicyPolicyArgs',
    'CloudProviderSnapshotBackupPolicyPolicyPolicyItemArgs',
    'CloudProviderSnapshotRestoreJobDeliveryTypeConfigArgs',
    'ClusterAdvancedConfigurationArgs',
    'ClusterBiConnectorConfigArgs',
    'ClusterConnectionStringArgs',
    'ClusterConnectionStringPrivateEndpointArgs',
    'ClusterConnectionStringPrivateEndpointEndpointArgs',
    'ClusterLabelArgs',
    'ClusterReplicationSpecArgs',
    'ClusterReplicationSpecRegionsConfigArgs',
    'ClusterSnapshotBackupPolicyArgs',
    'ClusterSnapshotBackupPolicyPolicyArgs',
    'ClusterSnapshotBackupPolicyPolicyPolicyItemArgs',
    'CustomDbRoleActionArgs',
    'CustomDbRoleActionResourceArgs',
    'CustomDbRoleInheritedRoleArgs',
    'DataLakeAwsArgs',
    'DataLakeDataProcessRegionArgs',
    'DataLakeStorageDatabaseArgs',
    'DataLakeStorageDatabaseCollectionArgs',
    'DataLakeStorageDatabaseCollectionDataSourceArgs',
    'DataLakeStorageDatabaseViewArgs',
    'DataLakeStorageStoreArgs',
    'DatabaseUserLabelArgs',
    'DatabaseUserRoleArgs',
    'DatabaseUserScopeArgs',
    'EncryptionAtRestAwsKmsConfigArgs',
    'EncryptionAtRestAzureKeyVaultConfigArgs',
    'EncryptionAtRestGoogleCloudKmsConfigArgs',
    'EventTriggerEventProcessorsArgs',
    'EventTriggerEventProcessorsAwsEventbridgeArgs',
    'FederatedSettingsOrgRoleMappingRoleAssignmentArgs',
    'GlobalClusterConfigCustomZoneMappingArgs',
    'GlobalClusterConfigManagedNamespaceArgs',
    'LdapConfigurationUserToDnMappingArgs',
    'LdapVerifyLinkArgs',
    'LdapVerifyValidationArgs',
    'OnlineArchiveCriteriaArgs',
    'OnlineArchivePartitionFieldArgs',
    'PrivateLinkEndpointServiceEndpointArgs',
    'ProjectApiKeyArgs',
    'ProjectTeamArgs',
    'SearchIndexSynonymArgs',
    'ServerlessInstanceLinkArgs',
    'X509AuthenticationDatabaseUserCertificateArgs',
    'GetCustomDbRoleInheritedRoleArgs',
    'GetGlobalClusterConfigManagedNamespaceArgs',
    'GetServerlessInstanceLinkArgs',
]

@pulumi.input_type
class AdvancedClusterAdvancedConfigurationArgs:
    def __init__(__self__, *,
                 default_read_concern: Optional[pulumi.Input[str]] = None,
                 default_write_concern: Optional[pulumi.Input[str]] = None,
                 fail_index_key_too_long: Optional[pulumi.Input[bool]] = None,
                 javascript_enabled: Optional[pulumi.Input[bool]] = None,
                 minimum_enabled_tls_protocol: Optional[pulumi.Input[str]] = None,
                 no_table_scan: Optional[pulumi.Input[bool]] = None,
                 oplog_size_mb: Optional[pulumi.Input[int]] = None,
                 sample_refresh_interval_bi_connector: Optional[pulumi.Input[int]] = None,
                 sample_size_bi_connector: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] default_read_concern: [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        :param pulumi.Input[str] default_write_concern: [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        :param pulumi.Input[bool] fail_index_key_too_long: When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        :param pulumi.Input[bool] javascript_enabled: When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        :param pulumi.Input[str] minimum_enabled_tls_protocol: Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        :param pulumi.Input[bool] no_table_scan: When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        :param pulumi.Input[int] oplog_size_mb: The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        :param pulumi.Input[int] sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param pulumi.Input[int] sample_size_bi_connector: Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        if default_read_concern is not None:
            pulumi.set(__self__, "default_read_concern", default_read_concern)
        if default_write_concern is not None:
            pulumi.set(__self__, "default_write_concern", default_write_concern)
        if fail_index_key_too_long is not None:
            pulumi.set(__self__, "fail_index_key_too_long", fail_index_key_too_long)
        if javascript_enabled is not None:
            pulumi.set(__self__, "javascript_enabled", javascript_enabled)
        if minimum_enabled_tls_protocol is not None:
            pulumi.set(__self__, "minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        if no_table_scan is not None:
            pulumi.set(__self__, "no_table_scan", no_table_scan)
        if oplog_size_mb is not None:
            pulumi.set(__self__, "oplog_size_mb", oplog_size_mb)
        if sample_refresh_interval_bi_connector is not None:
            pulumi.set(__self__, "sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        if sample_size_bi_connector is not None:
            pulumi.set(__self__, "sample_size_bi_connector", sample_size_bi_connector)

    @property
    @pulumi.getter(name="defaultReadConcern")
    def default_read_concern(self) -> Optional[pulumi.Input[str]]:
        """
        [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        """
        return pulumi.get(self, "default_read_concern")

    @default_read_concern.setter
    def default_read_concern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_read_concern", value)

    @property
    @pulumi.getter(name="defaultWriteConcern")
    def default_write_concern(self) -> Optional[pulumi.Input[str]]:
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        return pulumi.get(self, "default_write_concern")

    @default_write_concern.setter
    def default_write_concern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_write_concern", value)

    @property
    @pulumi.getter(name="failIndexKeyTooLong")
    def fail_index_key_too_long(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        """
        return pulumi.get(self, "fail_index_key_too_long")

    @fail_index_key_too_long.setter
    def fail_index_key_too_long(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fail_index_key_too_long", value)

    @property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        return pulumi.get(self, "javascript_enabled")

    @javascript_enabled.setter
    def javascript_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "javascript_enabled", value)

    @property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @minimum_enabled_tls_protocol.setter
    def minimum_enabled_tls_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum_enabled_tls_protocol", value)

    @property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        return pulumi.get(self, "no_table_scan")

    @no_table_scan.setter
    def no_table_scan(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_table_scan", value)

    @property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> Optional[pulumi.Input[int]]:
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        return pulumi.get(self, "oplog_size_mb")

    @oplog_size_mb.setter
    def oplog_size_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "oplog_size_mb", value)

    @property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> Optional[pulumi.Input[int]]:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @sample_refresh_interval_bi_connector.setter
    def sample_refresh_interval_bi_connector(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sample_refresh_interval_bi_connector", value)

    @property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> Optional[pulumi.Input[int]]:
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_size_bi_connector")

    @sample_size_bi_connector.setter
    def sample_size_bi_connector(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sample_size_bi_connector", value)


@pulumi.input_type
class AdvancedClusterBiConnectorArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 read_preference: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
               *
               - Set to `true` to enable BI Connector for Atlas.
               - Set to `false` to disable BI Connector for Atlas.
        :param pulumi.Input[str] read_preference: Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if read_preference is not None:
            pulumi.set(__self__, "read_preference", read_preference)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
        *
        - Set to `true` to enable BI Connector for Atlas.
        - Set to `false` to disable BI Connector for Atlas.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        return pulumi.get(self, "read_preference")

    @read_preference.setter
    def read_preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "read_preference", value)


@pulumi.input_type
class AdvancedClusterConnectionStringArgs:
    def __init__(__self__, *,
                 aws_private_link: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 aws_private_link_srv: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 private: Optional[pulumi.Input[str]] = None,
                 private_endpoints: Optional[pulumi.Input[Sequence[pulumi.Input['AdvancedClusterConnectionStringPrivateEndpointArgs']]]] = None,
                 private_srv: Optional[pulumi.Input[str]] = None,
                 standard: Optional[pulumi.Input[str]] = None,
                 standard_srv: Optional[pulumi.Input[str]] = None):
        if aws_private_link is not None:
            warnings.warn("""This field is deprecated. Use connection_strings.private_endpoint[n].connection_string instead""", DeprecationWarning)
            pulumi.log.warn("""aws_private_link is deprecated: This field is deprecated. Use connection_strings.private_endpoint[n].connection_string instead""")
        if aws_private_link is not None:
            pulumi.set(__self__, "aws_private_link", aws_private_link)
        if aws_private_link_srv is not None:
            warnings.warn("""This field is deprecated. Use connection_strings.private_endpoint[n].srv_connection_string instead""", DeprecationWarning)
            pulumi.log.warn("""aws_private_link_srv is deprecated: This field is deprecated. Use connection_strings.private_endpoint[n].srv_connection_string instead""")
        if aws_private_link_srv is not None:
            pulumi.set(__self__, "aws_private_link_srv", aws_private_link_srv)
        if private is not None:
            pulumi.set(__self__, "private", private)
        if private_endpoints is not None:
            pulumi.set(__self__, "private_endpoints", private_endpoints)
        if private_srv is not None:
            pulumi.set(__self__, "private_srv", private_srv)
        if standard is not None:
            pulumi.set(__self__, "standard", standard)
        if standard_srv is not None:
            pulumi.set(__self__, "standard_srv", standard_srv)

    @property
    @pulumi.getter(name="awsPrivateLink")
    def aws_private_link(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "aws_private_link")

    @aws_private_link.setter
    def aws_private_link(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "aws_private_link", value)

    @property
    @pulumi.getter(name="awsPrivateLinkSrv")
    def aws_private_link_srv(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "aws_private_link_srv")

    @aws_private_link_srv.setter
    def aws_private_link_srv(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "aws_private_link_srv", value)

    @property
    @pulumi.getter
    def private(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "private")

    @private.setter
    def private(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private", value)

    @property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AdvancedClusterConnectionStringPrivateEndpointArgs']]]]:
        return pulumi.get(self, "private_endpoints")

    @private_endpoints.setter
    def private_endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AdvancedClusterConnectionStringPrivateEndpointArgs']]]]):
        pulumi.set(self, "private_endpoints", value)

    @property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "private_srv")

    @private_srv.setter
    def private_srv(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_srv", value)

    @property
    @pulumi.getter
    def standard(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "standard")

    @standard.setter
    def standard(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "standard", value)

    @property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "standard_srv")

    @standard_srv.setter
    def standard_srv(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "standard_srv", value)


@pulumi.input_type
class AdvancedClusterConnectionStringPrivateEndpointArgs:
    def __init__(__self__, *,
                 connection_string: Optional[pulumi.Input[str]] = None,
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input['AdvancedClusterConnectionStringPrivateEndpointEndpointArgs']]]] = None,
                 srv_connection_string: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if srv_connection_string is not None:
            pulumi.set(__self__, "srv_connection_string", srv_connection_string)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AdvancedClusterConnectionStringPrivateEndpointEndpointArgs']]]]:
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AdvancedClusterConnectionStringPrivateEndpointEndpointArgs']]]]):
        pulumi.set(self, "endpoints", value)

    @property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "srv_connection_string")

    @srv_connection_string.setter
    def srv_connection_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "srv_connection_string", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class AdvancedClusterConnectionStringPrivateEndpointEndpointArgs:
    def __init__(__self__, *,
                 endpoint_id: Optional[pulumi.Input[str]] = None,
                 provider_name: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] provider_name: Cloud service provider on which the servers are provisioned.
               The possible values are:
        """
        if endpoint_id is not None:
            pulumi.set(__self__, "endpoint_id", endpoint_id)
        if provider_name is not None:
            pulumi.set(__self__, "provider_name", provider_name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "endpoint_id")

    @endpoint_id.setter
    def endpoint_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_id", value)

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> Optional[pulumi.Input[str]]:
        """
        Cloud service provider on which the servers are provisioned.
        The possible values are:
        """
        return pulumi.get(self, "provider_name")

    @provider_name.setter
    def provider_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider_name", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class AdvancedClusterLabelArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The key that you want to write.
        :param pulumi.Input[str] value: The value that you want to write.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class AdvancedClusterReplicationSpecArgs:
    def __init__(__self__, *,
                 region_configs: pulumi.Input[Sequence[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigArgs']]],
                 container_id: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 num_shards: Optional[pulumi.Input[int]] = None,
                 zone_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigArgs']]] region_configs: Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] container_id: A key-value map of the Network Peering Container ID(s) for the configuration specified in `region_configs`. The Container ID is the id of the container either created programmatically by the user before any clusters existed in a project or when the first cluster in the region (AWS/Azure) or project (GCP) was created.  The syntax is `"providerName:regionName" = "containerId"`. Example `AWS:US_EAST_1" = "61e0797dde08fb498ca11a71`.
        :param pulumi.Input[int] num_shards: Provide this value if you set a `cluster_type` of SHARDED or GEOSHARDED. Omit this value if you selected a `cluster_type` of REPLICASET. This API resource accepts 1 through 50, inclusive. This parameter defaults to 1. If you specify a `num_shards` value of 1 and a `cluster_type` of SHARDED, Atlas deploys a single-shard [sharded cluster](https://docs.atlas.mongodb.com/reference/glossary/#std-term-sharded-cluster). Don't create a sharded cluster with a single shard for production environments. Single-shard sharded clusters don't provide the same benefits as multi-shard configurations.
        :param pulumi.Input[str] zone_name: Name for the zone in a Global Cluster.
        """
        pulumi.set(__self__, "region_configs", region_configs)
        if container_id is not None:
            pulumi.set(__self__, "container_id", container_id)
        if num_shards is not None:
            pulumi.set(__self__, "num_shards", num_shards)
        if zone_name is not None:
            pulumi.set(__self__, "zone_name", zone_name)

    @property
    @pulumi.getter(name="regionConfigs")
    def region_configs(self) -> pulumi.Input[Sequence[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigArgs']]]:
        """
        Configuration for the hardware specifications for nodes set for a given regionEach `region_configs` object describes the region's priority in elections and the number and type of MongoDB nodes that Atlas deploys to the region. Each `region_configs` object must have either an `analytics_specs` object, `electable_specs` object, or `read_only_specs` object. See below
        """
        return pulumi.get(self, "region_configs")

    @region_configs.setter
    def region_configs(self, value: pulumi.Input[Sequence[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigArgs']]]):
        pulumi.set(self, "region_configs", value)

    @property
    @pulumi.getter(name="containerId")
    def container_id(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A key-value map of the Network Peering Container ID(s) for the configuration specified in `region_configs`. The Container ID is the id of the container either created programmatically by the user before any clusters existed in a project or when the first cluster in the region (AWS/Azure) or project (GCP) was created.  The syntax is `"providerName:regionName" = "containerId"`. Example `AWS:US_EAST_1" = "61e0797dde08fb498ca11a71`.
        """
        return pulumi.get(self, "container_id")

    @container_id.setter
    def container_id(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "container_id", value)

    @property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> Optional[pulumi.Input[int]]:
        """
        Provide this value if you set a `cluster_type` of SHARDED or GEOSHARDED. Omit this value if you selected a `cluster_type` of REPLICASET. This API resource accepts 1 through 50, inclusive. This parameter defaults to 1. If you specify a `num_shards` value of 1 and a `cluster_type` of SHARDED, Atlas deploys a single-shard [sharded cluster](https://docs.atlas.mongodb.com/reference/glossary/#std-term-sharded-cluster). Don't create a sharded cluster with a single shard for production environments. Single-shard sharded clusters don't provide the same benefits as multi-shard configurations.
        """
        return pulumi.get(self, "num_shards")

    @num_shards.setter
    def num_shards(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_shards", value)

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name for the zone in a Global Cluster.
        """
        return pulumi.get(self, "zone_name")

    @zone_name.setter
    def zone_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_name", value)


@pulumi.input_type
class AdvancedClusterReplicationSpecRegionConfigArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 provider_name: pulumi.Input[str],
                 region_name: pulumi.Input[str],
                 analytics_specs: Optional[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgs']] = None,
                 auto_scaling: Optional[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigAutoScalingArgs']] = None,
                 backing_provider_name: Optional[pulumi.Input[str]] = None,
                 electable_specs: Optional[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs']] = None,
                 read_only_specs: Optional[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigReadOnlySpecsArgs']] = None):
        """
        :param pulumi.Input[int] priority: Election priority of the region. For regions with only read-only nodes, set this value to 0.
               * If you have multiple `region_configs` objects (your cluster is multi-region or multi-cloud), they must have priorities in descending order. The highest priority is 7.
               * If your region has set `region_configs.#.electable_specs.0.node_count` to 1 or higher, it must have a priority of exactly one (1) less than another region in the `replication_specs.#.region_configs.#` array. The highest-priority region must have a priority of 7. The lowest possible priority is 1.
        :param pulumi.Input[str] provider_name: Cloud service provider on which the servers are provisioned.
               The possible values are:
        :param pulumi.Input[str] region_name: Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        :param pulumi.Input['AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgs'] analytics_specs: Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. Analytics nodes handle analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only and can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary). If you don't specify this parameter, no analytics nodes deploy to this region. See below
        :param pulumi.Input['AdvancedClusterReplicationSpecRegionConfigAutoScalingArgs'] auto_scaling: Configuration for the Collection of settings that configures auto-scaling information for the cluster. The values for the `auto_scaling` parameter must be the same for every item in the `replication_specs` array. See below
        :param pulumi.Input[str] backing_provider_name: Cloud service provider on which you provision the host for a multi-tenant cluster. Use this only when a `provider_name` is `TENANT` and `instance_size` of a specs is `M2` or `M5`.
        :param pulumi.Input['AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs'] electable_specs: Hardware specifications for electable nodes in the region. Electable nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you do not specify this option, no electable nodes are deployed to the region. See below
        :param pulumi.Input['AdvancedClusterReplicationSpecRegionConfigReadOnlySpecsArgs'] read_only_specs: Hardware specifications for read-only nodes in the region. Read-only nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you don't specify this parameter, no read-only nodes are deployed to the region. See below
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "provider_name", provider_name)
        pulumi.set(__self__, "region_name", region_name)
        if analytics_specs is not None:
            pulumi.set(__self__, "analytics_specs", analytics_specs)
        if auto_scaling is not None:
            pulumi.set(__self__, "auto_scaling", auto_scaling)
        if backing_provider_name is not None:
            pulumi.set(__self__, "backing_provider_name", backing_provider_name)
        if electable_specs is not None:
            pulumi.set(__self__, "electable_specs", electable_specs)
        if read_only_specs is not None:
            pulumi.set(__self__, "read_only_specs", read_only_specs)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Election priority of the region. For regions with only read-only nodes, set this value to 0.
        * If you have multiple `region_configs` objects (your cluster is multi-region or multi-cloud), they must have priorities in descending order. The highest priority is 7.
        * If your region has set `region_configs.#.electable_specs.0.node_count` to 1 or higher, it must have a priority of exactly one (1) less than another region in the `replication_specs.#.region_configs.#` array. The highest-priority region must have a priority of 7. The lowest possible priority is 1.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> pulumi.Input[str]:
        """
        Cloud service provider on which the servers are provisioned.
        The possible values are:
        """
        return pulumi.get(self, "provider_name")

    @provider_name.setter
    def provider_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "provider_name", value)

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> pulumi.Input[str]:
        """
        Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        """
        return pulumi.get(self, "region_name")

    @region_name.setter
    def region_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "region_name", value)

    @property
    @pulumi.getter(name="analyticsSpecs")
    def analytics_specs(self) -> Optional[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgs']]:
        """
        Hardware specifications for [analytics nodes](https://docs.atlas.mongodb.com/reference/faq/deployment/#std-label-analytics-nodes-overview) needed in the region. Analytics nodes handle analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only and can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary). If you don't specify this parameter, no analytics nodes deploy to this region. See below
        """
        return pulumi.get(self, "analytics_specs")

    @analytics_specs.setter
    def analytics_specs(self, value: Optional[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgs']]):
        pulumi.set(self, "analytics_specs", value)

    @property
    @pulumi.getter(name="autoScaling")
    def auto_scaling(self) -> Optional[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigAutoScalingArgs']]:
        """
        Configuration for the Collection of settings that configures auto-scaling information for the cluster. The values for the `auto_scaling` parameter must be the same for every item in the `replication_specs` array. See below
        """
        return pulumi.get(self, "auto_scaling")

    @auto_scaling.setter
    def auto_scaling(self, value: Optional[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigAutoScalingArgs']]):
        pulumi.set(self, "auto_scaling", value)

    @property
    @pulumi.getter(name="backingProviderName")
    def backing_provider_name(self) -> Optional[pulumi.Input[str]]:
        """
        Cloud service provider on which you provision the host for a multi-tenant cluster. Use this only when a `provider_name` is `TENANT` and `instance_size` of a specs is `M2` or `M5`.
        """
        return pulumi.get(self, "backing_provider_name")

    @backing_provider_name.setter
    def backing_provider_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backing_provider_name", value)

    @property
    @pulumi.getter(name="electableSpecs")
    def electable_specs(self) -> Optional[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs']]:
        """
        Hardware specifications for electable nodes in the region. Electable nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you do not specify this option, no electable nodes are deployed to the region. See below
        """
        return pulumi.get(self, "electable_specs")

    @electable_specs.setter
    def electable_specs(self, value: Optional[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs']]):
        pulumi.set(self, "electable_specs", value)

    @property
    @pulumi.getter(name="readOnlySpecs")
    def read_only_specs(self) -> Optional[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigReadOnlySpecsArgs']]:
        """
        Hardware specifications for read-only nodes in the region. Read-only nodes can become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary) and can enable local reads. If you don't specify this parameter, no read-only nodes are deployed to the region. See below
        """
        return pulumi.get(self, "read_only_specs")

    @read_only_specs.setter
    def read_only_specs(self, value: Optional[pulumi.Input['AdvancedClusterReplicationSpecRegionConfigReadOnlySpecsArgs']]):
        pulumi.set(self, "read_only_specs", value)


@pulumi.input_type
class AdvancedClusterReplicationSpecRegionConfigAnalyticsSpecsArgs:
    def __init__(__self__, *,
                 instance_size: pulumi.Input[str],
                 disk_iops: Optional[pulumi.Input[int]] = None,
                 ebs_volume_type: Optional[pulumi.Input[str]] = None,
                 node_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] instance_size: Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size.
        :param pulumi.Input[int] disk_iops: Target throughput (IOPS) desired for AWS storage attached to your cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster.
        :param pulumi.Input[str] ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        :param pulumi.Input[int] node_count: Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary), but can enable local reads.
        """
        pulumi.set(__self__, "instance_size", instance_size)
        if disk_iops is not None:
            pulumi.set(__self__, "disk_iops", disk_iops)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> pulumi.Input[str]:
        """
        Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size.
        """
        return pulumi.get(self, "instance_size")

    @instance_size.setter
    def instance_size(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_size", value)

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[pulumi.Input[int]]:
        """
        Target throughput (IOPS) desired for AWS storage attached to your cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster.
        """
        return pulumi.get(self, "disk_iops")

    @disk_iops.setter
    def disk_iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_iops", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        """
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ebs_volume_type", value)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary), but can enable local reads.
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "node_count", value)


@pulumi.input_type
class AdvancedClusterReplicationSpecRegionConfigAutoScalingArgs:
    def __init__(__self__, *,
                 compute_enabled: Optional[pulumi.Input[bool]] = None,
                 compute_max_instance_size: Optional[pulumi.Input[str]] = None,
                 compute_min_instance_size: Optional[pulumi.Input[str]] = None,
                 compute_scale_down_enabled: Optional[pulumi.Input[bool]] = None,
                 disk_gb_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] compute_enabled: Flag that indicates whether instance size auto-scaling is enabled. This parameter defaults to false.
        :param pulumi.Input[str] compute_max_instance_size: Maximum instance size to which your cluster can automatically scale (such as M40). Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_enabled` is true.
        :param pulumi.Input[str] compute_min_instance_size: Minimum instance size to which your cluster can automatically scale (such as M10). Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_scale_down_enabled` is true.
        :param pulumi.Input[bool] compute_scale_down_enabled: Flag that indicates whether the instance size may scale down. Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_enabled` : true. If you enable this option, specify a value for `replication_specs.#.region_configs.#.auto_scaling.0.compute_min_instance_size`.
        :param pulumi.Input[bool] disk_gb_enabled: Flag that indicates whether this cluster enables disk auto-scaling. This parameter defaults to true.
        """
        if compute_enabled is not None:
            pulumi.set(__self__, "compute_enabled", compute_enabled)
        if compute_max_instance_size is not None:
            pulumi.set(__self__, "compute_max_instance_size", compute_max_instance_size)
        if compute_min_instance_size is not None:
            pulumi.set(__self__, "compute_min_instance_size", compute_min_instance_size)
        if compute_scale_down_enabled is not None:
            pulumi.set(__self__, "compute_scale_down_enabled", compute_scale_down_enabled)
        if disk_gb_enabled is not None:
            pulumi.set(__self__, "disk_gb_enabled", disk_gb_enabled)

    @property
    @pulumi.getter(name="computeEnabled")
    def compute_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag that indicates whether instance size auto-scaling is enabled. This parameter defaults to false.
        """
        return pulumi.get(self, "compute_enabled")

    @compute_enabled.setter
    def compute_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compute_enabled", value)

    @property
    @pulumi.getter(name="computeMaxInstanceSize")
    def compute_max_instance_size(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum instance size to which your cluster can automatically scale (such as M40). Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_enabled` is true.
        """
        return pulumi.get(self, "compute_max_instance_size")

    @compute_max_instance_size.setter
    def compute_max_instance_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compute_max_instance_size", value)

    @property
    @pulumi.getter(name="computeMinInstanceSize")
    def compute_min_instance_size(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum instance size to which your cluster can automatically scale (such as M10). Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_scale_down_enabled` is true.
        """
        return pulumi.get(self, "compute_min_instance_size")

    @compute_min_instance_size.setter
    def compute_min_instance_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compute_min_instance_size", value)

    @property
    @pulumi.getter(name="computeScaleDownEnabled")
    def compute_scale_down_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag that indicates whether the instance size may scale down. Atlas requires this parameter if `replication_specs.#.region_configs.#.auto_scaling.0.compute_enabled` : true. If you enable this option, specify a value for `replication_specs.#.region_configs.#.auto_scaling.0.compute_min_instance_size`.
        """
        return pulumi.get(self, "compute_scale_down_enabled")

    @compute_scale_down_enabled.setter
    def compute_scale_down_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compute_scale_down_enabled", value)

    @property
    @pulumi.getter(name="diskGbEnabled")
    def disk_gb_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag that indicates whether this cluster enables disk auto-scaling. This parameter defaults to true.
        """
        return pulumi.get(self, "disk_gb_enabled")

    @disk_gb_enabled.setter
    def disk_gb_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disk_gb_enabled", value)


@pulumi.input_type
class AdvancedClusterReplicationSpecRegionConfigElectableSpecsArgs:
    def __init__(__self__, *,
                 instance_size: pulumi.Input[str],
                 disk_iops: Optional[pulumi.Input[int]] = None,
                 ebs_volume_type: Optional[pulumi.Input[str]] = None,
                 node_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] instance_size: Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size.
        :param pulumi.Input[int] disk_iops: Target throughput (IOPS) desired for AWS storage attached to your cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster.
        :param pulumi.Input[str] ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        :param pulumi.Input[int] node_count: Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary), but can enable local reads.
        """
        pulumi.set(__self__, "instance_size", instance_size)
        if disk_iops is not None:
            pulumi.set(__self__, "disk_iops", disk_iops)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> pulumi.Input[str]:
        """
        Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size.
        """
        return pulumi.get(self, "instance_size")

    @instance_size.setter
    def instance_size(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_size", value)

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[pulumi.Input[int]]:
        """
        Target throughput (IOPS) desired for AWS storage attached to your cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster.
        """
        return pulumi.get(self, "disk_iops")

    @disk_iops.setter
    def disk_iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_iops", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        """
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ebs_volume_type", value)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary), but can enable local reads.
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "node_count", value)


@pulumi.input_type
class AdvancedClusterReplicationSpecRegionConfigReadOnlySpecsArgs:
    def __init__(__self__, *,
                 instance_size: pulumi.Input[str],
                 disk_iops: Optional[pulumi.Input[int]] = None,
                 ebs_volume_type: Optional[pulumi.Input[str]] = None,
                 node_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] instance_size: Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size.
        :param pulumi.Input[int] disk_iops: Target throughput (IOPS) desired for AWS storage attached to your cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster.
        :param pulumi.Input[str] ebs_volume_type: Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        :param pulumi.Input[int] node_count: Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary), but can enable local reads.
        """
        pulumi.set(__self__, "instance_size", instance_size)
        if disk_iops is not None:
            pulumi.set(__self__, "disk_iops", disk_iops)
        if ebs_volume_type is not None:
            pulumi.set(__self__, "ebs_volume_type", ebs_volume_type)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="instanceSize")
    def instance_size(self) -> pulumi.Input[str]:
        """
        Hardware specification for the instance sizes in this region. Each instance size has a default storage and memory capacity. The instance size you select applies to all the data-bearing hosts in your instance size.
        """
        return pulumi.get(self, "instance_size")

    @instance_size.setter
    def instance_size(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_size", value)

    @property
    @pulumi.getter(name="diskIops")
    def disk_iops(self) -> Optional[pulumi.Input[int]]:
        """
        Target throughput (IOPS) desired for AWS storage attached to your cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster.
        """
        return pulumi.get(self, "disk_iops")

    @disk_iops.setter
    def disk_iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_iops", value)

    @property
    @pulumi.getter(name="ebsVolumeType")
    def ebs_volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of storage you want to attach to your AWS-provisioned cluster. Set only if you selected AWS as your cloud service provider. You can't set this parameter for a multi-cloud cluster. Valid values are:
        """
        return pulumi.get(self, "ebs_volume_type")

    @ebs_volume_type.setter
    def ebs_volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ebs_volume_type", value)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the [primary](https://docs.atlas.mongodb.com/reference/glossary/#std-term-primary), but can enable local reads.
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "node_count", value)


@pulumi.input_type
class AlertConfigurationMatcherArgs:
    def __init__(__self__, *,
                 field_name: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] field_name: Name of the field in the target object to match on.
        :param pulumi.Input[str] operator: Operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
               - `GREATER_THAN`
               - `LESS_THAN`
        :param pulumi.Input[str] value: Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
               - `PRIMARY`
               - `SECONDARY`
               - `STANDALONE`
               - `CONFIG`
               - `MONGOS`
        """
        if field_name is not None:
            pulumi.set(__self__, "field_name", field_name)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the field in the target object to match on.
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_name", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        - `GREATER_THAN`
        - `LESS_THAN`
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value to test with the specified operator. If `field_name` is set to TYPE_NAME, you can match on the following values:
        - `PRIMARY`
        - `SECONDARY`
        - `STANDALONE`
        - `CONFIG`
        - `MONGOS`
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class AlertConfigurationMetricThresholdConfigArgs:
    def __init__(__self__, *,
                 metric_name: Optional[pulumi.Input[str]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 threshold: Optional[pulumi.Input[float]] = None,
                 units: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric_name: Name of the metric to check. The full list of current options is available [here](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types)
        :param pulumi.Input[str] mode: This must be set to AVERAGE. Atlas computes the current metric value as an average.
        :param pulumi.Input[str] operator: Operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
               - `GREATER_THAN`
               - `LESS_THAN`
        :param pulumi.Input[float] threshold: Threshold value outside of which an alert will be triggered.
        :param pulumi.Input[str] units: The units for the threshold value. Depends on the type of metric.
               Accepted values are:
               - `RAW`
               - `BITS`
               - `BYTES`
               - `KILOBITS`
               - `KILOBYTES`
               - `MEGABITS`
               - `MEGABYTES`
               - `GIGABITS`
               - `GIGABYTES`
               - `TERABYTES`
               - `PETABYTES`
               - `MILLISECONDS`
               - `SECONDS`
               - `MINUTES`
               - `HOURS`
               - `DAYS`
        """
        if metric_name is not None:
            pulumi.set(__self__, "metric_name", metric_name)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if units is not None:
            pulumi.set(__self__, "units", units)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the metric to check. The full list of current options is available [here](https://docs.atlas.mongodb.com/reference/alert-host-metrics/#measurement-types)
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        This must be set to AVERAGE. Atlas computes the current metric value as an average.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        - `GREATER_THAN`
        - `LESS_THAN`
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[float]]:
        """
        Threshold value outside of which an alert will be triggered.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def units(self) -> Optional[pulumi.Input[str]]:
        """
        The units for the threshold value. Depends on the type of metric.
        Accepted values are:
        - `RAW`
        - `BITS`
        - `BYTES`
        - `KILOBITS`
        - `KILOBYTES`
        - `MEGABITS`
        - `MEGABYTES`
        - `GIGABITS`
        - `GIGABYTES`
        - `TERABYTES`
        - `PETABYTES`
        - `MILLISECONDS`
        - `SECONDS`
        - `MINUTES`
        - `HOURS`
        - `DAYS`
        """
        return pulumi.get(self, "units")

    @units.setter
    def units(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "units", value)


@pulumi.input_type
class AlertConfigurationNotificationArgs:
    def __init__(__self__, *,
                 api_token: Optional[pulumi.Input[str]] = None,
                 channel_name: Optional[pulumi.Input[str]] = None,
                 datadog_api_key: Optional[pulumi.Input[str]] = None,
                 datadog_region: Optional[pulumi.Input[str]] = None,
                 delay_min: Optional[pulumi.Input[int]] = None,
                 email_address: Optional[pulumi.Input[str]] = None,
                 email_enabled: Optional[pulumi.Input[bool]] = None,
                 flow_name: Optional[pulumi.Input[str]] = None,
                 flowdock_api_token: Optional[pulumi.Input[str]] = None,
                 interval_min: Optional[pulumi.Input[int]] = None,
                 mobile_number: Optional[pulumi.Input[str]] = None,
                 ops_genie_api_key: Optional[pulumi.Input[str]] = None,
                 ops_genie_region: Optional[pulumi.Input[str]] = None,
                 org_name: Optional[pulumi.Input[str]] = None,
                 roles: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_key: Optional[pulumi.Input[str]] = None,
                 sms_enabled: Optional[pulumi.Input[bool]] = None,
                 team_id: Optional[pulumi.Input[str]] = None,
                 team_name: Optional[pulumi.Input[str]] = None,
                 type_name: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None,
                 victor_ops_api_key: Optional[pulumi.Input[str]] = None,
                 victor_ops_routing_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_token: Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param pulumi.Input[str] channel_name: Slack channel name. Required for the SLACK notifications type.
        :param pulumi.Input[str] datadog_api_key: Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        :param pulumi.Input[str] datadog_region: Region that indicates which API URL to use. Accepted regions are: `US`, `EU`. The default Datadog region is US.
        :param pulumi.Input[int] delay_min: Number of minutes to wait after an alert condition is detected before sending out the first notification.
        :param pulumi.Input[str] email_address: Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        :param pulumi.Input[bool] email_enabled: Flag indicating email notifications should be sent. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        :param pulumi.Input[str] flow_name: Flowdock flow name in lower-case letters. Required for the `FLOWDOCK` notifications type
        :param pulumi.Input[str] flowdock_api_token: The Flowdock personal API token. Required for the `FLOWDOCK` notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param pulumi.Input[int] interval_min: Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5. **NOTE** `PAGER_DUTY`, `VICTOR_OPS`, and `OPS_GENIE` notifications do not return this value. The notification interval must be configured and managed within each external service.
        :param pulumi.Input[str] mobile_number: Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        :param pulumi.Input[str] ops_genie_api_key: Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        :param pulumi.Input[str] ops_genie_region: Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        :param pulumi.Input[str] org_name: Flowdock organization name in lower-case letters. This is the name that appears after www.flowdock.com/app/ in the URL string. Required for the FLOWDOCK notifications type.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] roles: Optional. One or more roles that receive the configured alert. If you include this field, Atlas sends alerts only to users assigned the roles you specify in the array. If you omit this field, Atlas sends alerts to users assigned any role. This parameter is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
               Accepted values are:
        :param pulumi.Input[str] service_key: PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param pulumi.Input[bool] sms_enabled: Flag indicating if text message notifications should be sent to this user's mobile phone. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        :param pulumi.Input[str] team_id: Unique identifier of a team.
        :param pulumi.Input[str] team_name: Label for the team that receives this notification.
        :param pulumi.Input[str] type_name: Type of alert notification.
               Accepted values are:
               - `DATADOG`
               - `EMAIL`
               - `FLOWDOCK`
        :param pulumi.Input[str] username: Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        :param pulumi.Input[str] victor_ops_api_key: VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        :param pulumi.Input[str] victor_ops_routing_key: VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        if api_token is not None:
            pulumi.set(__self__, "api_token", api_token)
        if channel_name is not None:
            pulumi.set(__self__, "channel_name", channel_name)
        if datadog_api_key is not None:
            pulumi.set(__self__, "datadog_api_key", datadog_api_key)
        if datadog_region is not None:
            pulumi.set(__self__, "datadog_region", datadog_region)
        if delay_min is not None:
            pulumi.set(__self__, "delay_min", delay_min)
        if email_address is not None:
            pulumi.set(__self__, "email_address", email_address)
        if email_enabled is not None:
            pulumi.set(__self__, "email_enabled", email_enabled)
        if flow_name is not None:
            pulumi.set(__self__, "flow_name", flow_name)
        if flowdock_api_token is not None:
            pulumi.set(__self__, "flowdock_api_token", flowdock_api_token)
        if interval_min is not None:
            pulumi.set(__self__, "interval_min", interval_min)
        if mobile_number is not None:
            pulumi.set(__self__, "mobile_number", mobile_number)
        if ops_genie_api_key is not None:
            pulumi.set(__self__, "ops_genie_api_key", ops_genie_api_key)
        if ops_genie_region is not None:
            pulumi.set(__self__, "ops_genie_region", ops_genie_region)
        if org_name is not None:
            pulumi.set(__self__, "org_name", org_name)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)
        if service_key is not None:
            pulumi.set(__self__, "service_key", service_key)
        if sms_enabled is not None:
            pulumi.set(__self__, "sms_enabled", sms_enabled)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)
        if team_name is not None:
            pulumi.set(__self__, "team_name", team_name)
        if type_name is not None:
            pulumi.set(__self__, "type_name", type_name)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if victor_ops_api_key is not None:
            pulumi.set(__self__, "victor_ops_api_key", victor_ops_api_key)
        if victor_ops_routing_key is not None:
            pulumi.set(__self__, "victor_ops_routing_key", victor_ops_routing_key)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> Optional[pulumi.Input[str]]:
        """
        Slack API token. Required for the SLACK notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> Optional[pulumi.Input[str]]:
        """
        Slack channel name. Required for the SLACK notifications type.
        """
        return pulumi.get(self, "channel_name")

    @channel_name.setter
    def channel_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "channel_name", value)

    @property
    @pulumi.getter(name="datadogApiKey")
    def datadog_api_key(self) -> Optional[pulumi.Input[str]]:
        """
        Datadog API Key. Found in the Datadog dashboard. Required for the DATADOG notifications type.
        """
        return pulumi.get(self, "datadog_api_key")

    @datadog_api_key.setter
    def datadog_api_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datadog_api_key", value)

    @property
    @pulumi.getter(name="datadogRegion")
    def datadog_region(self) -> Optional[pulumi.Input[str]]:
        """
        Region that indicates which API URL to use. Accepted regions are: `US`, `EU`. The default Datadog region is US.
        """
        return pulumi.get(self, "datadog_region")

    @datadog_region.setter
    def datadog_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datadog_region", value)

    @property
    @pulumi.getter(name="delayMin")
    def delay_min(self) -> Optional[pulumi.Input[int]]:
        """
        Number of minutes to wait after an alert condition is detected before sending out the first notification.
        """
        return pulumi.get(self, "delay_min")

    @delay_min.setter
    def delay_min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "delay_min", value)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> Optional[pulumi.Input[str]]:
        """
        Email address to which alert notifications are sent. Required for the EMAIL notifications type.
        """
        return pulumi.get(self, "email_address")

    @email_address.setter
    def email_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "email_address", value)

    @property
    @pulumi.getter(name="emailEnabled")
    def email_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag indicating email notifications should be sent. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        """
        return pulumi.get(self, "email_enabled")

    @email_enabled.setter
    def email_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "email_enabled", value)

    @property
    @pulumi.getter(name="flowName")
    def flow_name(self) -> Optional[pulumi.Input[str]]:
        """
        Flowdock flow name in lower-case letters. Required for the `FLOWDOCK` notifications type
        """
        return pulumi.get(self, "flow_name")

    @flow_name.setter
    def flow_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flow_name", value)

    @property
    @pulumi.getter(name="flowdockApiToken")
    def flowdock_api_token(self) -> Optional[pulumi.Input[str]]:
        """
        The Flowdock personal API token. Required for the `FLOWDOCK` notifications type. If the token later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "flowdock_api_token")

    @flowdock_api_token.setter
    def flowdock_api_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flowdock_api_token", value)

    @property
    @pulumi.getter(name="intervalMin")
    def interval_min(self) -> Optional[pulumi.Input[int]]:
        """
        Number of minutes to wait between successive notifications for unacknowledged alerts that are not resolved. The minimum value is 5. **NOTE** `PAGER_DUTY`, `VICTOR_OPS`, and `OPS_GENIE` notifications do not return this value. The notification interval must be configured and managed within each external service.
        """
        return pulumi.get(self, "interval_min")

    @interval_min.setter
    def interval_min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval_min", value)

    @property
    @pulumi.getter(name="mobileNumber")
    def mobile_number(self) -> Optional[pulumi.Input[str]]:
        """
        Mobile number to which alert notifications are sent. Required for the SMS notifications type.
        """
        return pulumi.get(self, "mobile_number")

    @mobile_number.setter
    def mobile_number(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mobile_number", value)

    @property
    @pulumi.getter(name="opsGenieApiKey")
    def ops_genie_api_key(self) -> Optional[pulumi.Input[str]]:
        """
        Opsgenie API Key. Required for the `OPS_GENIE` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the token.
        """
        return pulumi.get(self, "ops_genie_api_key")

    @ops_genie_api_key.setter
    def ops_genie_api_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ops_genie_api_key", value)

    @property
    @pulumi.getter(name="opsGenieRegion")
    def ops_genie_region(self) -> Optional[pulumi.Input[str]]:
        """
        Region that indicates which API URL to use. Accepted regions are: `US` ,`EU`. The default Opsgenie region is US.
        """
        return pulumi.get(self, "ops_genie_region")

    @ops_genie_region.setter
    def ops_genie_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ops_genie_region", value)

    @property
    @pulumi.getter(name="orgName")
    def org_name(self) -> Optional[pulumi.Input[str]]:
        """
        Flowdock organization name in lower-case letters. This is the name that appears after www.flowdock.com/app/ in the URL string. Required for the FLOWDOCK notifications type.
        """
        return pulumi.get(self, "org_name")

    @org_name.setter
    def org_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "org_name", value)

    @property
    @pulumi.getter
    def roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional. One or more roles that receive the configured alert. If you include this field, Atlas sends alerts only to users assigned the roles you specify in the array. If you omit this field, Atlas sends alerts to users assigned any role. This parameter is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        Accepted values are:
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "roles", value)

    @property
    @pulumi.getter(name="serviceKey")
    def service_key(self) -> Optional[pulumi.Input[str]]:
        """
        PagerDuty service key. Required for the PAGER_DUTY notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "service_key")

    @service_key.setter
    def service_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_key", value)

    @property
    @pulumi.getter(name="smsEnabled")
    def sms_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag indicating if text message notifications should be sent to this user's mobile phone. This flag is only valid if `type_name` is set to `ORG`, `GROUP`, or `USER`.
        """
        return pulumi.get(self, "sms_enabled")

    @sms_enabled.setter
    def sms_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sms_enabled", value)

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of a team.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_id", value)

    @property
    @pulumi.getter(name="teamName")
    def team_name(self) -> Optional[pulumi.Input[str]]:
        """
        Label for the team that receives this notification.
        """
        return pulumi.get(self, "team_name")

    @team_name.setter
    def team_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_name", value)

    @property
    @pulumi.getter(name="typeName")
    def type_name(self) -> Optional[pulumi.Input[str]]:
        """
        Type of alert notification.
        Accepted values are:
        - `DATADOG`
        - `EMAIL`
        - `FLOWDOCK`
        """
        return pulumi.get(self, "type_name")

    @type_name.setter
    def type_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type_name", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Atlas user to which to send notifications. Only a user in the project that owns the alert configuration is allowed here. Required for the `USER` notifications type.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="victorOpsApiKey")
    def victor_ops_api_key(self) -> Optional[pulumi.Input[str]]:
        """
        VictorOps API key. Required for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "victor_ops_api_key")

    @victor_ops_api_key.setter
    def victor_ops_api_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "victor_ops_api_key", value)

    @property
    @pulumi.getter(name="victorOpsRoutingKey")
    def victor_ops_routing_key(self) -> Optional[pulumi.Input[str]]:
        """
        VictorOps routing key. Optional for the `VICTOR_OPS` notifications type. If the key later becomes invalid, Atlas sends an email to the project owner and eventually removes the key.
        """
        return pulumi.get(self, "victor_ops_routing_key")

    @victor_ops_routing_key.setter
    def victor_ops_routing_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "victor_ops_routing_key", value)


@pulumi.input_type
class AlertConfigurationThresholdConfigArgs:
    def __init__(__self__, *,
                 operator: Optional[pulumi.Input[str]] = None,
                 threshold: Optional[pulumi.Input[float]] = None,
                 units: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] operator: Operator to apply when checking the current metric value against the threshold value.
               Accepted values are:
               - `GREATER_THAN`
               - `LESS_THAN`
        :param pulumi.Input[float] threshold: Threshold value outside of which an alert will be triggered.
        :param pulumi.Input[str] units: The units for the threshold value. Depends on the type of metric.
               Accepted values are:
               - `RAW`
               - `BITS`
               - `BYTES`
               - `KILOBITS`
               - `KILOBYTES`
               - `MEGABITS`
               - `MEGABYTES`
               - `GIGABITS`
               - `GIGABYTES`
               - `TERABYTES`
               - `PETABYTES`
               - `MILLISECONDS`
               - `SECONDS`
               - `MINUTES`
               - `HOURS`
               - `DAYS`
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if units is not None:
            pulumi.set(__self__, "units", units)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Operator to apply when checking the current metric value against the threshold value.
        Accepted values are:
        - `GREATER_THAN`
        - `LESS_THAN`
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[float]]:
        """
        Threshold value outside of which an alert will be triggered.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def units(self) -> Optional[pulumi.Input[str]]:
        """
        The units for the threshold value. Depends on the type of metric.
        Accepted values are:
        - `RAW`
        - `BITS`
        - `BYTES`
        - `KILOBITS`
        - `KILOBYTES`
        - `MEGABITS`
        - `MEGABYTES`
        - `GIGABITS`
        - `GIGABYTES`
        - `TERABYTES`
        - `PETABYTES`
        - `MILLISECONDS`
        - `SECONDS`
        - `MINUTES`
        - `HOURS`
        - `DAYS`
        """
        return pulumi.get(self, "units")

    @units.setter
    def units(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "units", value)


@pulumi.input_type
class CloudBackupScheduleExportArgs:
    def __init__(__self__, *,
                 export_bucket_id: Optional[pulumi.Input[str]] = None,
                 frequency_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] export_bucket_id: Unique identifier of the CloudBackupSnapshotExportBucket export_bucket_id value.
        :param pulumi.Input[str] frequency_type: Frequency associated with the export snapshot item.
        """
        if export_bucket_id is not None:
            pulumi.set(__self__, "export_bucket_id", export_bucket_id)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)

    @property
    @pulumi.getter(name="exportBucketId")
    def export_bucket_id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of the CloudBackupSnapshotExportBucket export_bucket_id value.
        """
        return pulumi.get(self, "export_bucket_id")

    @export_bucket_id.setter
    def export_bucket_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "export_bucket_id", value)

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[pulumi.Input[str]]:
        """
        Frequency associated with the export snapshot item.
        """
        return pulumi.get(self, "frequency_type")

    @frequency_type.setter
    def frequency_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency_type", value)


@pulumi.input_type
class CloudBackupSchedulePolicyItemDailyArgs:
    def __init__(__self__, *,
                 frequency_interval: pulumi.Input[int],
                 retention_unit: pulumi.Input[str],
                 retention_value: pulumi.Input[int],
                 frequency_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type`.
        :param pulumi.Input[str] retention_unit: Scope of the backup policy item: days, weeks, or months.
        :param pulumi.Input[int] retention_value: Value to associate with `retention_unit`.
        :param pulumi.Input[str] frequency_type: Frequency associated with the export snapshot item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> pulumi.Input[int]:
        """
        Desired frequency of the new backup policy item specified by `frequency_type`.
        """
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> pulumi.Input[str]:
        """
        Scope of the backup policy item: days, weeks, or months.
        """
        return pulumi.get(self, "retention_unit")

    @retention_unit.setter
    def retention_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "retention_unit", value)

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> pulumi.Input[int]:
        """
        Value to associate with `retention_unit`.
        """
        return pulumi.get(self, "retention_value")

    @retention_value.setter
    def retention_value(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_value", value)

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[pulumi.Input[str]]:
        """
        Frequency associated with the export snapshot item.
        """
        return pulumi.get(self, "frequency_type")

    @frequency_type.setter
    def frequency_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency_type", value)


@pulumi.input_type
class CloudBackupSchedulePolicyItemHourlyArgs:
    def __init__(__self__, *,
                 frequency_interval: pulumi.Input[int],
                 retention_unit: pulumi.Input[str],
                 retention_value: pulumi.Input[int],
                 frequency_type: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type`.
        :param pulumi.Input[str] retention_unit: Scope of the backup policy item: days, weeks, or months.
        :param pulumi.Input[int] retention_value: Value to associate with `retention_unit`.
        :param pulumi.Input[str] frequency_type: Frequency associated with the export snapshot item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> pulumi.Input[int]:
        """
        Desired frequency of the new backup policy item specified by `frequency_type`.
        """
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> pulumi.Input[str]:
        """
        Scope of the backup policy item: days, weeks, or months.
        """
        return pulumi.get(self, "retention_unit")

    @retention_unit.setter
    def retention_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "retention_unit", value)

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> pulumi.Input[int]:
        """
        Value to associate with `retention_unit`.
        """
        return pulumi.get(self, "retention_value")

    @retention_value.setter
    def retention_value(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_value", value)

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[pulumi.Input[str]]:
        """
        Frequency associated with the export snapshot item.
        """
        return pulumi.get(self, "frequency_type")

    @frequency_type.setter
    def frequency_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency_type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class CloudBackupSchedulePolicyItemMonthlyArgs:
    def __init__(__self__, *,
                 frequency_interval: pulumi.Input[int],
                 retention_unit: pulumi.Input[str],
                 retention_value: pulumi.Input[int],
                 frequency_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type`.
        :param pulumi.Input[str] retention_unit: Scope of the backup policy item: days, weeks, or months.
        :param pulumi.Input[int] retention_value: Value to associate with `retention_unit`.
        :param pulumi.Input[str] frequency_type: Frequency associated with the export snapshot item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> pulumi.Input[int]:
        """
        Desired frequency of the new backup policy item specified by `frequency_type`.
        """
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> pulumi.Input[str]:
        """
        Scope of the backup policy item: days, weeks, or months.
        """
        return pulumi.get(self, "retention_unit")

    @retention_unit.setter
    def retention_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "retention_unit", value)

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> pulumi.Input[int]:
        """
        Value to associate with `retention_unit`.
        """
        return pulumi.get(self, "retention_value")

    @retention_value.setter
    def retention_value(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_value", value)

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[pulumi.Input[str]]:
        """
        Frequency associated with the export snapshot item.
        """
        return pulumi.get(self, "frequency_type")

    @frequency_type.setter
    def frequency_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency_type", value)


@pulumi.input_type
class CloudBackupSchedulePolicyItemWeeklyArgs:
    def __init__(__self__, *,
                 frequency_interval: pulumi.Input[int],
                 retention_unit: pulumi.Input[str],
                 retention_value: pulumi.Input[int],
                 frequency_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] frequency_interval: Desired frequency of the new backup policy item specified by `frequency_type`.
        :param pulumi.Input[str] retention_unit: Scope of the backup policy item: days, weeks, or months.
        :param pulumi.Input[int] retention_value: Value to associate with `retention_unit`.
        :param pulumi.Input[str] frequency_type: Frequency associated with the export snapshot item.
        """
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> pulumi.Input[int]:
        """
        Desired frequency of the new backup policy item specified by `frequency_type`.
        """
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> pulumi.Input[str]:
        """
        Scope of the backup policy item: days, weeks, or months.
        """
        return pulumi.get(self, "retention_unit")

    @retention_unit.setter
    def retention_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "retention_unit", value)

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> pulumi.Input[int]:
        """
        Value to associate with `retention_unit`.
        """
        return pulumi.get(self, "retention_value")

    @retention_value.setter
    def retention_value(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_value", value)

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[pulumi.Input[str]]:
        """
        Frequency associated with the export snapshot item.
        """
        return pulumi.get(self, "frequency_type")

    @frequency_type.setter
    def frequency_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency_type", value)


@pulumi.input_type
class CloudBackupSnapshotExportJobComponentArgs:
    def __init__(__self__, *,
                 export_id: Optional[pulumi.Input[str]] = None,
                 replica_set_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] export_id: _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        :param pulumi.Input[str] replica_set_name: _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
        if export_id is not None:
            pulumi.set(__self__, "export_id", export_id)
        if replica_set_name is not None:
            pulumi.set(__self__, "replica_set_name", replica_set_name)

    @property
    @pulumi.getter(name="exportId")
    def export_id(self) -> Optional[pulumi.Input[str]]:
        """
        _Returned for sharded clusters only._ Export job details for each replica set in the sharded cluster.
        """
        return pulumi.get(self, "export_id")

    @export_id.setter
    def export_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "export_id", value)

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> Optional[pulumi.Input[str]]:
        """
        _Returned for sharded clusters only._ Unique identifier of the export job for the replica set.
        """
        return pulumi.get(self, "replica_set_name")

    @replica_set_name.setter
    def replica_set_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replica_set_name", value)


@pulumi.input_type
class CloudBackupSnapshotExportJobCustomDataArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Required if you want to include custom data using `custom_data` in the metadata file uploaded to the bucket. Key to include in the metadata file that Atlas uploads to the bucket when the export job finishes.
        :param pulumi.Input[str] value: Required if you specify `key`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Required if you want to include custom data using `custom_data` in the metadata file uploaded to the bucket. Key to include in the metadata file that Atlas uploads to the bucket when the export job finishes.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Required if you specify `key`.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class CloudBackupSnapshotMemberArgs:
    def __init__(__self__, *,
                 cloud_provider: Optional[pulumi.Input[str]] = None,
                 replica_set_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cloud_provider: Cloud provider that stores this snapshot.
        :param pulumi.Input[str] replica_set_name: Label given to a shard or config server from which Atlas took this snapshot.
        """
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if replica_set_name is not None:
            pulumi.set(__self__, "replica_set_name", replica_set_name)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[pulumi.Input[str]]:
        """
        Cloud provider that stores this snapshot.
        """
        return pulumi.get(self, "cloud_provider")

    @cloud_provider.setter
    def cloud_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_provider", value)

    @property
    @pulumi.getter(name="replicaSetName")
    def replica_set_name(self) -> Optional[pulumi.Input[str]]:
        """
        Label given to a shard or config server from which Atlas took this snapshot.
        """
        return pulumi.get(self, "replica_set_name")

    @replica_set_name.setter
    def replica_set_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replica_set_name", value)


@pulumi.input_type
class CloudBackupSnapshotRestoreJobDeliveryTypeConfigArgs:
    def __init__(__self__, *,
                 automated: Optional[pulumi.Input[bool]] = None,
                 download: Optional[pulumi.Input[bool]] = None,
                 oplog_inc: Optional[pulumi.Input[int]] = None,
                 oplog_ts: Optional[pulumi.Input[int]] = None,
                 point_in_time: Optional[pulumi.Input[bool]] = None,
                 point_in_time_utc_seconds: Optional[pulumi.Input[int]] = None,
                 target_cluster_name: Optional[pulumi.Input[str]] = None,
                 target_project_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] target_cluster_name: Name of the target Atlas cluster to which the restore job restores the snapshot. Only required if deliveryType is automated.
        """
        if automated is not None:
            pulumi.set(__self__, "automated", automated)
        if download is not None:
            pulumi.set(__self__, "download", download)
        if oplog_inc is not None:
            pulumi.set(__self__, "oplog_inc", oplog_inc)
        if oplog_ts is not None:
            pulumi.set(__self__, "oplog_ts", oplog_ts)
        if point_in_time is not None:
            pulumi.set(__self__, "point_in_time", point_in_time)
        if point_in_time_utc_seconds is not None:
            pulumi.set(__self__, "point_in_time_utc_seconds", point_in_time_utc_seconds)
        if target_cluster_name is not None:
            pulumi.set(__self__, "target_cluster_name", target_cluster_name)
        if target_project_id is not None:
            pulumi.set(__self__, "target_project_id", target_project_id)

    @property
    @pulumi.getter
    def automated(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "automated")

    @automated.setter
    def automated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "automated", value)

    @property
    @pulumi.getter
    def download(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "download")

    @download.setter
    def download(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "download", value)

    @property
    @pulumi.getter(name="oplogInc")
    def oplog_inc(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "oplog_inc")

    @oplog_inc.setter
    def oplog_inc(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "oplog_inc", value)

    @property
    @pulumi.getter(name="oplogTs")
    def oplog_ts(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "oplog_ts")

    @oplog_ts.setter
    def oplog_ts(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "oplog_ts", value)

    @property
    @pulumi.getter(name="pointInTime")
    def point_in_time(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "point_in_time")

    @point_in_time.setter
    def point_in_time(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "point_in_time", value)

    @property
    @pulumi.getter(name="pointInTimeUtcSeconds")
    def point_in_time_utc_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "point_in_time_utc_seconds")

    @point_in_time_utc_seconds.setter
    def point_in_time_utc_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "point_in_time_utc_seconds", value)

    @property
    @pulumi.getter(name="targetClusterName")
    def target_cluster_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the target Atlas cluster to which the restore job restores the snapshot. Only required if deliveryType is automated.
        """
        return pulumi.get(self, "target_cluster_name")

    @target_cluster_name.setter
    def target_cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_cluster_name", value)

    @property
    @pulumi.getter(name="targetProjectId")
    def target_project_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "target_project_id")

    @target_project_id.setter
    def target_project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_project_id", value)


@pulumi.input_type
class CloudProviderAccessAuthorizationAwsArgs:
    def __init__(__self__, *,
                 iam_assumed_role_arn: pulumi.Input[str]):
        pulumi.set(__self__, "iam_assumed_role_arn", iam_assumed_role_arn)

    @property
    @pulumi.getter(name="iamAssumedRoleArn")
    def iam_assumed_role_arn(self) -> pulumi.Input[str]:
        return pulumi.get(self, "iam_assumed_role_arn")

    @iam_assumed_role_arn.setter
    def iam_assumed_role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "iam_assumed_role_arn", value)


@pulumi.input_type
class CloudProviderAccessAuthorizationFeatureUsageArgs:
    def __init__(__self__, *,
                 feature_id: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 feature_type: Optional[pulumi.Input[str]] = None):
        if feature_id is not None:
            pulumi.set(__self__, "feature_id", feature_id)
        if feature_type is not None:
            pulumi.set(__self__, "feature_type", feature_type)

    @property
    @pulumi.getter(name="featureId")
    def feature_id(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "feature_id")

    @feature_id.setter
    def feature_id(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "feature_id", value)

    @property
    @pulumi.getter(name="featureType")
    def feature_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "feature_type")

    @feature_type.setter
    def feature_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "feature_type", value)


@pulumi.input_type
class CloudProviderAccessFeatureUsageArgs:
    def __init__(__self__, *,
                 feature_id: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 feature_type: Optional[pulumi.Input[str]] = None):
        if feature_id is not None:
            pulumi.set(__self__, "feature_id", feature_id)
        if feature_type is not None:
            pulumi.set(__self__, "feature_type", feature_type)

    @property
    @pulumi.getter(name="featureId")
    def feature_id(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "feature_id")

    @feature_id.setter
    def feature_id(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "feature_id", value)

    @property
    @pulumi.getter(name="featureType")
    def feature_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "feature_type")

    @feature_type.setter
    def feature_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "feature_type", value)


@pulumi.input_type
class CloudProviderAccessSetupAwsConfigArgs:
    def __init__(__self__, *,
                 atlas_assumed_role_external_id: Optional[pulumi.Input[str]] = None,
                 atlas_aws_account_arn: Optional[pulumi.Input[str]] = None):
        if atlas_assumed_role_external_id is not None:
            pulumi.set(__self__, "atlas_assumed_role_external_id", atlas_assumed_role_external_id)
        if atlas_aws_account_arn is not None:
            pulumi.set(__self__, "atlas_aws_account_arn", atlas_aws_account_arn)

    @property
    @pulumi.getter(name="atlasAssumedRoleExternalId")
    def atlas_assumed_role_external_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "atlas_assumed_role_external_id")

    @atlas_assumed_role_external_id.setter
    def atlas_assumed_role_external_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "atlas_assumed_role_external_id", value)

    @property
    @pulumi.getter(name="atlasAwsAccountArn")
    def atlas_aws_account_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "atlas_aws_account_arn")

    @atlas_aws_account_arn.setter
    def atlas_aws_account_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "atlas_aws_account_arn", value)


@pulumi.input_type
class CloudProviderSnapshotBackupPolicyPolicyArgs:
    def __init__(__self__, *,
                 policy_items: pulumi.Input[Sequence[pulumi.Input['CloudProviderSnapshotBackupPolicyPolicyPolicyItemArgs']]]):
        pulumi.set(__self__, "policy_items", policy_items)

    @property
    @pulumi.getter(name="policyItems")
    def policy_items(self) -> pulumi.Input[Sequence[pulumi.Input['CloudProviderSnapshotBackupPolicyPolicyPolicyItemArgs']]]:
        return pulumi.get(self, "policy_items")

    @policy_items.setter
    def policy_items(self, value: pulumi.Input[Sequence[pulumi.Input['CloudProviderSnapshotBackupPolicyPolicyPolicyItemArgs']]]):
        pulumi.set(self, "policy_items", value)


@pulumi.input_type
class CloudProviderSnapshotBackupPolicyPolicyPolicyItemArgs:
    def __init__(__self__, *,
                 frequency_interval: pulumi.Input[int],
                 frequency_type: pulumi.Input[str],
                 retention_unit: pulumi.Input[str],
                 retention_value: pulumi.Input[int]):
        pulumi.set(__self__, "frequency_interval", frequency_interval)
        pulumi.set(__self__, "frequency_type", frequency_type)
        pulumi.set(__self__, "retention_unit", retention_unit)
        pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> pulumi.Input[int]:
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "frequency_type")

    @frequency_type.setter
    def frequency_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "frequency_type", value)

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> pulumi.Input[str]:
        return pulumi.get(self, "retention_unit")

    @retention_unit.setter
    def retention_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "retention_unit", value)

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> pulumi.Input[int]:
        return pulumi.get(self, "retention_value")

    @retention_value.setter
    def retention_value(self, value: pulumi.Input[int]):
        pulumi.set(self, "retention_value", value)


@pulumi.input_type
class CloudProviderSnapshotRestoreJobDeliveryTypeConfigArgs:
    def __init__(__self__, *,
                 automated: Optional[pulumi.Input[bool]] = None,
                 download: Optional[pulumi.Input[bool]] = None,
                 oplog_inc: Optional[pulumi.Input[int]] = None,
                 oplog_ts: Optional[pulumi.Input[int]] = None,
                 point_in_time: Optional[pulumi.Input[bool]] = None,
                 point_in_time_utc_seconds: Optional[pulumi.Input[int]] = None,
                 target_cluster_name: Optional[pulumi.Input[str]] = None,
                 target_project_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] target_cluster_name: Name of the target Atlas cluster to which the restore job restores the snapshot. Only required if deliveryType is automated.
        """
        if automated is not None:
            pulumi.set(__self__, "automated", automated)
        if download is not None:
            pulumi.set(__self__, "download", download)
        if oplog_inc is not None:
            pulumi.set(__self__, "oplog_inc", oplog_inc)
        if oplog_ts is not None:
            pulumi.set(__self__, "oplog_ts", oplog_ts)
        if point_in_time is not None:
            pulumi.set(__self__, "point_in_time", point_in_time)
        if point_in_time_utc_seconds is not None:
            pulumi.set(__self__, "point_in_time_utc_seconds", point_in_time_utc_seconds)
        if target_cluster_name is not None:
            pulumi.set(__self__, "target_cluster_name", target_cluster_name)
        if target_project_id is not None:
            pulumi.set(__self__, "target_project_id", target_project_id)

    @property
    @pulumi.getter
    def automated(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "automated")

    @automated.setter
    def automated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "automated", value)

    @property
    @pulumi.getter
    def download(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "download")

    @download.setter
    def download(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "download", value)

    @property
    @pulumi.getter(name="oplogInc")
    def oplog_inc(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "oplog_inc")

    @oplog_inc.setter
    def oplog_inc(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "oplog_inc", value)

    @property
    @pulumi.getter(name="oplogTs")
    def oplog_ts(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "oplog_ts")

    @oplog_ts.setter
    def oplog_ts(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "oplog_ts", value)

    @property
    @pulumi.getter(name="pointInTime")
    def point_in_time(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "point_in_time")

    @point_in_time.setter
    def point_in_time(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "point_in_time", value)

    @property
    @pulumi.getter(name="pointInTimeUtcSeconds")
    def point_in_time_utc_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "point_in_time_utc_seconds")

    @point_in_time_utc_seconds.setter
    def point_in_time_utc_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "point_in_time_utc_seconds", value)

    @property
    @pulumi.getter(name="targetClusterName")
    def target_cluster_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the target Atlas cluster to which the restore job restores the snapshot. Only required if deliveryType is automated.
        """
        return pulumi.get(self, "target_cluster_name")

    @target_cluster_name.setter
    def target_cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_cluster_name", value)

    @property
    @pulumi.getter(name="targetProjectId")
    def target_project_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "target_project_id")

    @target_project_id.setter
    def target_project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_project_id", value)


@pulumi.input_type
class ClusterAdvancedConfigurationArgs:
    def __init__(__self__, *,
                 default_read_concern: Optional[pulumi.Input[str]] = None,
                 default_write_concern: Optional[pulumi.Input[str]] = None,
                 fail_index_key_too_long: Optional[pulumi.Input[bool]] = None,
                 javascript_enabled: Optional[pulumi.Input[bool]] = None,
                 minimum_enabled_tls_protocol: Optional[pulumi.Input[str]] = None,
                 no_table_scan: Optional[pulumi.Input[bool]] = None,
                 oplog_size_mb: Optional[pulumi.Input[int]] = None,
                 sample_refresh_interval_bi_connector: Optional[pulumi.Input[int]] = None,
                 sample_size_bi_connector: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] default_read_concern: [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        :param pulumi.Input[str] default_write_concern: [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        :param pulumi.Input[bool] fail_index_key_too_long: When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        :param pulumi.Input[bool] javascript_enabled: When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        :param pulumi.Input[str] minimum_enabled_tls_protocol: Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        :param pulumi.Input[bool] no_table_scan: When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        :param pulumi.Input[int] oplog_size_mb: The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        :param pulumi.Input[int] sample_refresh_interval_bi_connector: Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        :param pulumi.Input[int] sample_size_bi_connector: Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        if default_read_concern is not None:
            pulumi.set(__self__, "default_read_concern", default_read_concern)
        if default_write_concern is not None:
            pulumi.set(__self__, "default_write_concern", default_write_concern)
        if fail_index_key_too_long is not None:
            pulumi.set(__self__, "fail_index_key_too_long", fail_index_key_too_long)
        if javascript_enabled is not None:
            pulumi.set(__self__, "javascript_enabled", javascript_enabled)
        if minimum_enabled_tls_protocol is not None:
            pulumi.set(__self__, "minimum_enabled_tls_protocol", minimum_enabled_tls_protocol)
        if no_table_scan is not None:
            pulumi.set(__self__, "no_table_scan", no_table_scan)
        if oplog_size_mb is not None:
            pulumi.set(__self__, "oplog_size_mb", oplog_size_mb)
        if sample_refresh_interval_bi_connector is not None:
            pulumi.set(__self__, "sample_refresh_interval_bi_connector", sample_refresh_interval_bi_connector)
        if sample_size_bi_connector is not None:
            pulumi.set(__self__, "sample_size_bi_connector", sample_size_bi_connector)

    @property
    @pulumi.getter(name="defaultReadConcern")
    def default_read_concern(self) -> Optional[pulumi.Input[str]]:
        """
        [Default level of acknowledgment requested from MongoDB for read operations](https://docs.mongodb.com/manual/reference/read-concern/) set for this cluster. MongoDB 4.4 clusters default to [available](https://docs.mongodb.com/manual/reference/read-concern-available/).
        """
        return pulumi.get(self, "default_read_concern")

    @default_read_concern.setter
    def default_read_concern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_read_concern", value)

    @property
    @pulumi.getter(name="defaultWriteConcern")
    def default_write_concern(self) -> Optional[pulumi.Input[str]]:
        """
        [Default level of acknowledgment requested from MongoDB for write operations](https://docs.mongodb.com/manual/reference/write-concern/) set for this cluster. MongoDB 4.4 clusters default to [1](https://docs.mongodb.com/manual/reference/write-concern/).
        """
        return pulumi.get(self, "default_write_concern")

    @default_write_concern.setter
    def default_write_concern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_write_concern", value)

    @property
    @pulumi.getter(name="failIndexKeyTooLong")
    def fail_index_key_too_long(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, documents can only be updated or inserted if, for all indexed fields on the target collection, the corresponding index entries do not exceed 1024 bytes. When false, mongod writes documents that exceed the limit but does not index them.
        """
        return pulumi.get(self, "fail_index_key_too_long")

    @fail_index_key_too_long.setter
    def fail_index_key_too_long(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fail_index_key_too_long", value)

    @property
    @pulumi.getter(name="javascriptEnabled")
    def javascript_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, the cluster allows execution of operations that perform server-side executions of JavaScript. When false, the cluster disables execution of those operations.
        """
        return pulumi.get(self, "javascript_enabled")

    @javascript_enabled.setter
    def javascript_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "javascript_enabled", value)

    @property
    @pulumi.getter(name="minimumEnabledTlsProtocol")
    def minimum_enabled_tls_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Sets the minimum Transport Layer Security (TLS) version the cluster accepts for incoming connections.Valid values are:
        """
        return pulumi.get(self, "minimum_enabled_tls_protocol")

    @minimum_enabled_tls_protocol.setter
    def minimum_enabled_tls_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum_enabled_tls_protocol", value)

    @property
    @pulumi.getter(name="noTableScan")
    def no_table_scan(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, the cluster disables the execution of any query that requires a collection scan to return results. When false, the cluster allows the execution of those operations.
        """
        return pulumi.get(self, "no_table_scan")

    @no_table_scan.setter
    def no_table_scan(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_table_scan", value)

    @property
    @pulumi.getter(name="oplogSizeMb")
    def oplog_size_mb(self) -> Optional[pulumi.Input[int]]:
        """
        The custom oplog size of the cluster. Without a value that indicates that the cluster uses the default oplog size calculated by Atlas.
        """
        return pulumi.get(self, "oplog_size_mb")

    @oplog_size_mb.setter
    def oplog_size_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "oplog_size_mb", value)

    @property
    @pulumi.getter(name="sampleRefreshIntervalBiConnector")
    def sample_refresh_interval_bi_connector(self) -> Optional[pulumi.Input[int]]:
        """
        Interval in seconds at which the mongosqld process re-samples data to create its relational schema. The default value is 300. The specified value must be a positive integer. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_refresh_interval_bi_connector")

    @sample_refresh_interval_bi_connector.setter
    def sample_refresh_interval_bi_connector(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sample_refresh_interval_bi_connector", value)

    @property
    @pulumi.getter(name="sampleSizeBiConnector")
    def sample_size_bi_connector(self) -> Optional[pulumi.Input[int]]:
        """
        Number of documents per database to sample when gathering schema information. Defaults to 100. Available only for Atlas deployments in which BI Connector for Atlas is enabled.
        """
        return pulumi.get(self, "sample_size_bi_connector")

    @sample_size_bi_connector.setter
    def sample_size_bi_connector(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sample_size_bi_connector", value)


@pulumi.input_type
class ClusterBiConnectorConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 read_preference: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
               *
               - Set to `true` to enable BI Connector for Atlas.
               - Set to `false` to disable BI Connector for Atlas.
        :param pulumi.Input[str] read_preference: Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if read_preference is not None:
            pulumi.set(__self__, "read_preference", read_preference)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether or not BI Connector for Atlas is enabled on the cluster.l
        *
        - Set to `true` to enable BI Connector for Atlas.
        - Set to `false` to disable BI Connector for Atlas.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="readPreference")
    def read_preference(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the read preference to be used by BI Connector for Atlas on the cluster. Each BI Connector for Atlas read preference contains a distinct combination of [readPreference](https://docs.mongodb.com/manual/core/read-preference/) and [readPreferenceTags](https://docs.mongodb.com/manual/core/read-preference/#tag-sets) options. For details on BI Connector for Atlas read preferences, refer to the [BI Connector Read Preferences Table](https://docs.atlas.mongodb.com/tutorial/create-global-writes-cluster/#bic-read-preferences).
        """
        return pulumi.get(self, "read_preference")

    @read_preference.setter
    def read_preference(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "read_preference", value)


@pulumi.input_type
class ClusterConnectionStringArgs:
    def __init__(__self__, *,
                 aws_private_link: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 aws_private_link_srv: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 private: Optional[pulumi.Input[str]] = None,
                 private_endpoints: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterConnectionStringPrivateEndpointArgs']]]] = None,
                 private_srv: Optional[pulumi.Input[str]] = None,
                 standard: Optional[pulumi.Input[str]] = None,
                 standard_srv: Optional[pulumi.Input[str]] = None):
        if aws_private_link is not None:
            warnings.warn("""This field is deprecated. Use connection_strings.private_endpoint[n].connection_string instead""", DeprecationWarning)
            pulumi.log.warn("""aws_private_link is deprecated: This field is deprecated. Use connection_strings.private_endpoint[n].connection_string instead""")
        if aws_private_link is not None:
            pulumi.set(__self__, "aws_private_link", aws_private_link)
        if aws_private_link_srv is not None:
            warnings.warn("""This field is deprecated. Use connection_strings.private_endpoint[n].srv_connection_string instead""", DeprecationWarning)
            pulumi.log.warn("""aws_private_link_srv is deprecated: This field is deprecated. Use connection_strings.private_endpoint[n].srv_connection_string instead""")
        if aws_private_link_srv is not None:
            pulumi.set(__self__, "aws_private_link_srv", aws_private_link_srv)
        if private is not None:
            pulumi.set(__self__, "private", private)
        if private_endpoints is not None:
            pulumi.set(__self__, "private_endpoints", private_endpoints)
        if private_srv is not None:
            pulumi.set(__self__, "private_srv", private_srv)
        if standard is not None:
            pulumi.set(__self__, "standard", standard)
        if standard_srv is not None:
            pulumi.set(__self__, "standard_srv", standard_srv)

    @property
    @pulumi.getter(name="awsPrivateLink")
    def aws_private_link(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "aws_private_link")

    @aws_private_link.setter
    def aws_private_link(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "aws_private_link", value)

    @property
    @pulumi.getter(name="awsPrivateLinkSrv")
    def aws_private_link_srv(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "aws_private_link_srv")

    @aws_private_link_srv.setter
    def aws_private_link_srv(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "aws_private_link_srv", value)

    @property
    @pulumi.getter
    def private(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "private")

    @private.setter
    def private(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private", value)

    @property
    @pulumi.getter(name="privateEndpoints")
    def private_endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterConnectionStringPrivateEndpointArgs']]]]:
        return pulumi.get(self, "private_endpoints")

    @private_endpoints.setter
    def private_endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterConnectionStringPrivateEndpointArgs']]]]):
        pulumi.set(self, "private_endpoints", value)

    @property
    @pulumi.getter(name="privateSrv")
    def private_srv(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "private_srv")

    @private_srv.setter
    def private_srv(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_srv", value)

    @property
    @pulumi.getter
    def standard(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "standard")

    @standard.setter
    def standard(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "standard", value)

    @property
    @pulumi.getter(name="standardSrv")
    def standard_srv(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "standard_srv")

    @standard_srv.setter
    def standard_srv(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "standard_srv", value)


@pulumi.input_type
class ClusterConnectionStringPrivateEndpointArgs:
    def __init__(__self__, *,
                 connection_string: Optional[pulumi.Input[str]] = None,
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterConnectionStringPrivateEndpointEndpointArgs']]]] = None,
                 srv_connection_string: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if connection_string is not None:
            pulumi.set(__self__, "connection_string", connection_string)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if srv_connection_string is not None:
            pulumi.set(__self__, "srv_connection_string", srv_connection_string)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterConnectionStringPrivateEndpointEndpointArgs']]]]:
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterConnectionStringPrivateEndpointEndpointArgs']]]]):
        pulumi.set(self, "endpoints", value)

    @property
    @pulumi.getter(name="srvConnectionString")
    def srv_connection_string(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "srv_connection_string")

    @srv_connection_string.setter
    def srv_connection_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "srv_connection_string", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ClusterConnectionStringPrivateEndpointEndpointArgs:
    def __init__(__self__, *,
                 endpoint_id: Optional[pulumi.Input[str]] = None,
                 provider_name: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] provider_name: Cloud service provider on which the servers are provisioned.
        """
        if endpoint_id is not None:
            pulumi.set(__self__, "endpoint_id", endpoint_id)
        if provider_name is not None:
            pulumi.set(__self__, "provider_name", provider_name)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "endpoint_id")

    @endpoint_id.setter
    def endpoint_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_id", value)

    @property
    @pulumi.getter(name="providerName")
    def provider_name(self) -> Optional[pulumi.Input[str]]:
        """
        Cloud service provider on which the servers are provisioned.
        """
        return pulumi.get(self, "provider_name")

    @provider_name.setter
    def provider_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider_name", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class ClusterLabelArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The key that you want to write.
        :param pulumi.Input[str] value: The value that you want to write.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ClusterReplicationSpecArgs:
    def __init__(__self__, *,
                 num_shards: pulumi.Input[int],
                 id: Optional[pulumi.Input[str]] = None,
                 regions_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterReplicationSpecRegionsConfigArgs']]]] = None,
                 zone_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] num_shards: Number of shards to deploy in the specified zone, minimum 1.
        :param pulumi.Input[str] id: Unique identifer of the replication document for a zone in a Global Cluster.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterReplicationSpecRegionsConfigArgs']]] regions_configs: Physical location of the region. Each regionsConfig document describes the regions priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        :param pulumi.Input[str] zone_name: Name for the zone in a Global Cluster.
        """
        pulumi.set(__self__, "num_shards", num_shards)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if regions_configs is not None:
            pulumi.set(__self__, "regions_configs", regions_configs)
        if zone_name is not None:
            pulumi.set(__self__, "zone_name", zone_name)

    @property
    @pulumi.getter(name="numShards")
    def num_shards(self) -> pulumi.Input[int]:
        """
        Number of shards to deploy in the specified zone, minimum 1.
        """
        return pulumi.get(self, "num_shards")

    @num_shards.setter
    def num_shards(self, value: pulumi.Input[int]):
        pulumi.set(self, "num_shards", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifer of the replication document for a zone in a Global Cluster.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="regionsConfigs")
    def regions_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterReplicationSpecRegionsConfigArgs']]]]:
        """
        Physical location of the region. Each regionsConfig document describes the regions priority in elections and the number and type of MongoDB nodes Atlas deploys to the region. You must order each regionsConfigs document by regionsConfig.priority, descending. See Region Config below for more details.
        """
        return pulumi.get(self, "regions_configs")

    @regions_configs.setter
    def regions_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterReplicationSpecRegionsConfigArgs']]]]):
        pulumi.set(self, "regions_configs", value)

    @property
    @pulumi.getter(name="zoneName")
    def zone_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name for the zone in a Global Cluster.
        """
        return pulumi.get(self, "zone_name")

    @zone_name.setter
    def zone_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone_name", value)


@pulumi.input_type
class ClusterReplicationSpecRegionsConfigArgs:
    def __init__(__self__, *,
                 region_name: pulumi.Input[str],
                 analytics_nodes: Optional[pulumi.Input[int]] = None,
                 electable_nodes: Optional[pulumi.Input[int]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 read_only_nodes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] region_name: Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        :param pulumi.Input[int] analytics_nodes: The number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary. If you do not specify this option, no analytics nodes are deployed to the region.
        :param pulumi.Input[int] electable_nodes: Number of electable nodes for Atlas to deploy to the region. Electable nodes can become the primary and can facilitate local reads.
               * The total number of electableNodes across all replication spec regions  must total 3, 5, or 7.
               * Specify 0 if you do not want any electable nodes in the region.
               * You cannot create electable nodes in a region if `priority` is 0.
        :param pulumi.Input[int] priority: Election priority of the region. For regions with only read-only nodes, set this value to 0.
               * For regions where `electable_nodes` is at least 1, each region must have a priority of exactly one (1) less than the previous region. The first region must have a priority of 7. The lowest possible priority is 1.
               * The priority 7 region identifies the Preferred Region of the cluster. Atlas places the primary node in the Preferred Region. Priorities 1 through 7 are exclusive - no more than one region per cluster can be assigned a given priority.
               * Example: If you have three regions, their priorities would be 7, 6, and 5 respectively. If you added two more regions for supporting electable nodes, the priorities of those regions would be 4 and 3 respectively.
        :param pulumi.Input[int] read_only_nodes: Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        """
        pulumi.set(__self__, "region_name", region_name)
        if analytics_nodes is not None:
            pulumi.set(__self__, "analytics_nodes", analytics_nodes)
        if electable_nodes is not None:
            pulumi.set(__self__, "electable_nodes", electable_nodes)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if read_only_nodes is not None:
            pulumi.set(__self__, "read_only_nodes", read_only_nodes)

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> pulumi.Input[str]:
        """
        Physical location of your MongoDB cluster. The region you choose can affect network latency for clients accessing your databases.  Requires the **Atlas region name**, see the reference list for [AWS](https://docs.atlas.mongodb.com/reference/amazon-aws/), [GCP](https://docs.atlas.mongodb.com/reference/google-gcp/), [Azure](https://docs.atlas.mongodb.com/reference/microsoft-azure/).
        """
        return pulumi.get(self, "region_name")

    @region_name.setter
    def region_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "region_name", value)

    @property
    @pulumi.getter(name="analyticsNodes")
    def analytics_nodes(self) -> Optional[pulumi.Input[int]]:
        """
        The number of analytics nodes for Atlas to deploy to the region. Analytics nodes are useful for handling analytic data such as reporting queries from BI Connector for Atlas. Analytics nodes are read-only, and can never become the primary. If you do not specify this option, no analytics nodes are deployed to the region.
        """
        return pulumi.get(self, "analytics_nodes")

    @analytics_nodes.setter
    def analytics_nodes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "analytics_nodes", value)

    @property
    @pulumi.getter(name="electableNodes")
    def electable_nodes(self) -> Optional[pulumi.Input[int]]:
        """
        Number of electable nodes for Atlas to deploy to the region. Electable nodes can become the primary and can facilitate local reads.
        * The total number of electableNodes across all replication spec regions  must total 3, 5, or 7.
        * Specify 0 if you do not want any electable nodes in the region.
        * You cannot create electable nodes in a region if `priority` is 0.
        """
        return pulumi.get(self, "electable_nodes")

    @electable_nodes.setter
    def electable_nodes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "electable_nodes", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        Election priority of the region. For regions with only read-only nodes, set this value to 0.
        * For regions where `electable_nodes` is at least 1, each region must have a priority of exactly one (1) less than the previous region. The first region must have a priority of 7. The lowest possible priority is 1.
        * The priority 7 region identifies the Preferred Region of the cluster. Atlas places the primary node in the Preferred Region. Priorities 1 through 7 are exclusive - no more than one region per cluster can be assigned a given priority.
        * Example: If you have three regions, their priorities would be 7, 6, and 5 respectively. If you added two more regions for supporting electable nodes, the priorities of those regions would be 4 and 3 respectively.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="readOnlyNodes")
    def read_only_nodes(self) -> Optional[pulumi.Input[int]]:
        """
        Number of read-only nodes for Atlas to deploy to the region. Read-only nodes can never become the primary, but can facilitate local-reads. Specify 0 if you do not want any read-only nodes in the region.
        """
        return pulumi.get(self, "read_only_nodes")

    @read_only_nodes.setter
    def read_only_nodes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "read_only_nodes", value)


@pulumi.input_type
class ClusterSnapshotBackupPolicyArgs:
    def __init__(__self__, *,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 cluster_name: Optional[pulumi.Input[str]] = None,
                 next_snapshot: Optional[pulumi.Input[str]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSnapshotBackupPolicyPolicyArgs']]]] = None,
                 reference_hour_of_day: Optional[pulumi.Input[int]] = None,
                 reference_minute_of_hour: Optional[pulumi.Input[int]] = None,
                 restore_window_days: Optional[pulumi.Input[int]] = None,
                 update_snapshots: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] cluster_id: The cluster ID.
        """
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if next_snapshot is not None:
            pulumi.set(__self__, "next_snapshot", next_snapshot)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)
        if reference_hour_of_day is not None:
            pulumi.set(__self__, "reference_hour_of_day", reference_hour_of_day)
        if reference_minute_of_hour is not None:
            pulumi.set(__self__, "reference_minute_of_hour", reference_minute_of_hour)
        if restore_window_days is not None:
            pulumi.set(__self__, "restore_window_days", restore_window_days)
        if update_snapshots is not None:
            pulumi.set(__self__, "update_snapshots", update_snapshots)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        The cluster ID.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="nextSnapshot")
    def next_snapshot(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "next_snapshot")

    @next_snapshot.setter
    def next_snapshot(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "next_snapshot", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSnapshotBackupPolicyPolicyArgs']]]]:
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSnapshotBackupPolicyPolicyArgs']]]]):
        pulumi.set(self, "policies", value)

    @property
    @pulumi.getter(name="referenceHourOfDay")
    def reference_hour_of_day(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "reference_hour_of_day")

    @reference_hour_of_day.setter
    def reference_hour_of_day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reference_hour_of_day", value)

    @property
    @pulumi.getter(name="referenceMinuteOfHour")
    def reference_minute_of_hour(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "reference_minute_of_hour")

    @reference_minute_of_hour.setter
    def reference_minute_of_hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "reference_minute_of_hour", value)

    @property
    @pulumi.getter(name="restoreWindowDays")
    def restore_window_days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "restore_window_days")

    @restore_window_days.setter
    def restore_window_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "restore_window_days", value)

    @property
    @pulumi.getter(name="updateSnapshots")
    def update_snapshots(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "update_snapshots")

    @update_snapshots.setter
    def update_snapshots(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "update_snapshots", value)


@pulumi.input_type
class ClusterSnapshotBackupPolicyPolicyArgs:
    def __init__(__self__, *,
                 policy_items: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSnapshotBackupPolicyPolicyPolicyItemArgs']]]] = None):
        if policy_items is not None:
            pulumi.set(__self__, "policy_items", policy_items)

    @property
    @pulumi.getter(name="policyItems")
    def policy_items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSnapshotBackupPolicyPolicyPolicyItemArgs']]]]:
        return pulumi.get(self, "policy_items")

    @policy_items.setter
    def policy_items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterSnapshotBackupPolicyPolicyPolicyItemArgs']]]]):
        pulumi.set(self, "policy_items", value)


@pulumi.input_type
class ClusterSnapshotBackupPolicyPolicyPolicyItemArgs:
    def __init__(__self__, *,
                 frequency_interval: Optional[pulumi.Input[int]] = None,
                 frequency_type: Optional[pulumi.Input[str]] = None,
                 retention_unit: Optional[pulumi.Input[str]] = None,
                 retention_value: Optional[pulumi.Input[int]] = None):
        if frequency_interval is not None:
            pulumi.set(__self__, "frequency_interval", frequency_interval)
        if frequency_type is not None:
            pulumi.set(__self__, "frequency_type", frequency_type)
        if retention_unit is not None:
            pulumi.set(__self__, "retention_unit", retention_unit)
        if retention_value is not None:
            pulumi.set(__self__, "retention_value", retention_value)

    @property
    @pulumi.getter(name="frequencyInterval")
    def frequency_interval(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "frequency_interval")

    @frequency_interval.setter
    def frequency_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "frequency_interval", value)

    @property
    @pulumi.getter(name="frequencyType")
    def frequency_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "frequency_type")

    @frequency_type.setter
    def frequency_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency_type", value)

    @property
    @pulumi.getter(name="retentionUnit")
    def retention_unit(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "retention_unit")

    @retention_unit.setter
    def retention_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "retention_unit", value)

    @property
    @pulumi.getter(name="retentionValue")
    def retention_value(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "retention_value")

    @retention_value.setter
    def retention_value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention_value", value)


@pulumi.input_type
class CustomDbRoleActionArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 resources: pulumi.Input[Sequence[pulumi.Input['CustomDbRoleActionResourceArgs']]]):
        """
        :param pulumi.Input[str] action: Name of the privilege action. For a complete list of actions available in the Atlas API, see [Custom Role Actions](https://docs.atlas.mongodb.com/reference/api/custom-role-actions)
               > **Note**: The privilege actions available to the Custom Roles API resource represent a subset of the privilege actions available in the Atlas Custom Roles UI.
        :param pulumi.Input[Sequence[pulumi.Input['CustomDbRoleActionResourceArgs']]] resources: Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Name of the privilege action. For a complete list of actions available in the Atlas API, see [Custom Role Actions](https://docs.atlas.mongodb.com/reference/api/custom-role-actions)
        > **Note**: The privilege actions available to the Custom Roles API resource represent a subset of the privilege actions available in the Atlas Custom Roles UI.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def resources(self) -> pulumi.Input[Sequence[pulumi.Input['CustomDbRoleActionResourceArgs']]]:
        """
        Contains information on where the action is granted. Each object in the array either indicates a database and collection on which the action is granted, or indicates that the action is granted on the cluster resource.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input[Sequence[pulumi.Input['CustomDbRoleActionResourceArgs']]]):
        pulumi.set(self, "resources", value)


@pulumi.input_type
class CustomDbRoleActionResourceArgs:
    def __init__(__self__, *,
                 cluster: Optional[pulumi.Input[bool]] = None,
                 collection_name: Optional[pulumi.Input[str]] = None,
                 database_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database_name: Database on which the inherited role is granted.
        """
        if cluster is not None:
            pulumi.set(__self__, "cluster", cluster)
        if collection_name is not None:
            pulumi.set(__self__, "collection_name", collection_name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)

    @property
    @pulumi.getter
    def cluster(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "cluster")

    @cluster.setter
    def cluster(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cluster", value)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "collection_name")

    @collection_name.setter
    def collection_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "collection_name", value)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[str]]:
        """
        Database on which the inherited role is granted.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_name", value)


@pulumi.input_type
class CustomDbRoleInheritedRoleArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[str],
                 role_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] database_name: Database on which the inherited role is granted.
        :param pulumi.Input[str] role_name: Name of the inherited role. This can either be another custom role or a built-in role.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        Database on which the inherited role is granted.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> pulumi.Input[str]:
        """
        Name of the inherited role. This can either be another custom role or a built-in role.
        """
        return pulumi.get(self, "role_name")

    @role_name.setter
    def role_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_name", value)


@pulumi.input_type
class DataLakeAwsArgs:
    def __init__(__self__, *,
                 role_id: pulumi.Input[str],
                 test_s3_bucket: pulumi.Input[str],
                 external_id: Optional[pulumi.Input[str]] = None,
                 iam_assumed_role_arn: Optional[pulumi.Input[str]] = None,
                 iam_user_arn: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "test_s3_bucket", test_s3_bucket)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if iam_assumed_role_arn is not None:
            pulumi.set(__self__, "iam_assumed_role_arn", iam_assumed_role_arn)
        if iam_user_arn is not None:
            pulumi.set(__self__, "iam_user_arn", iam_user_arn)

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "role_id")

    @role_id.setter
    def role_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_id", value)

    @property
    @pulumi.getter(name="testS3Bucket")
    def test_s3_bucket(self) -> pulumi.Input[str]:
        return pulumi.get(self, "test_s3_bucket")

    @test_s3_bucket.setter
    def test_s3_bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "test_s3_bucket", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter(name="iamAssumedRoleArn")
    def iam_assumed_role_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "iam_assumed_role_arn")

    @iam_assumed_role_arn.setter
    def iam_assumed_role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "iam_assumed_role_arn", value)

    @property
    @pulumi.getter(name="iamUserArn")
    def iam_user_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "iam_user_arn")

    @iam_user_arn.setter
    def iam_user_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "iam_user_arn", value)


@pulumi.input_type
class DataLakeDataProcessRegionArgs:
    def __init__(__self__, *,
                 cloud_provider: pulumi.Input[str],
                 region: pulumi.Input[str]):
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> pulumi.Input[str]:
        return pulumi.get(self, "cloud_provider")

    @cloud_provider.setter
    def cloud_provider(self, value: pulumi.Input[str]):
        pulumi.set(self, "cloud_provider", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class DataLakeStorageDatabaseArgs:
    def __init__(__self__, *,
                 collections: Optional[pulumi.Input[Sequence[pulumi.Input['DataLakeStorageDatabaseCollectionArgs']]]] = None,
                 max_wildcard_collections: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 views: Optional[pulumi.Input[Sequence[pulumi.Input['DataLakeStorageDatabaseViewArgs']]]] = None):
        """
        :param pulumi.Input[str] name: Name of the Atlas Data Lake.
        """
        if collections is not None:
            pulumi.set(__self__, "collections", collections)
        if max_wildcard_collections is not None:
            pulumi.set(__self__, "max_wildcard_collections", max_wildcard_collections)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if views is not None:
            pulumi.set(__self__, "views", views)

    @property
    @pulumi.getter
    def collections(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataLakeStorageDatabaseCollectionArgs']]]]:
        return pulumi.get(self, "collections")

    @collections.setter
    def collections(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataLakeStorageDatabaseCollectionArgs']]]]):
        pulumi.set(self, "collections", value)

    @property
    @pulumi.getter(name="maxWildcardCollections")
    def max_wildcard_collections(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_wildcard_collections")

    @max_wildcard_collections.setter
    def max_wildcard_collections(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_wildcard_collections", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Atlas Data Lake.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def views(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataLakeStorageDatabaseViewArgs']]]]:
        return pulumi.get(self, "views")

    @views.setter
    def views(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataLakeStorageDatabaseViewArgs']]]]):
        pulumi.set(self, "views", value)


@pulumi.input_type
class DataLakeStorageDatabaseCollectionArgs:
    def __init__(__self__, *,
                 data_sources: Optional[pulumi.Input[Sequence[pulumi.Input['DataLakeStorageDatabaseCollectionDataSourceArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the Atlas Data Lake.
        """
        if data_sources is not None:
            pulumi.set(__self__, "data_sources", data_sources)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="dataSources")
    def data_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataLakeStorageDatabaseCollectionDataSourceArgs']]]]:
        return pulumi.get(self, "data_sources")

    @data_sources.setter
    def data_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataLakeStorageDatabaseCollectionDataSourceArgs']]]]):
        pulumi.set(self, "data_sources", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Atlas Data Lake.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class DataLakeStorageDatabaseCollectionDataSourceArgs:
    def __init__(__self__, *,
                 default_format: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 store_name: Optional[pulumi.Input[str]] = None):
        if default_format is not None:
            pulumi.set(__self__, "default_format", default_format)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if store_name is not None:
            pulumi.set(__self__, "store_name", store_name)

    @property
    @pulumi.getter(name="defaultFormat")
    def default_format(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "default_format")

    @default_format.setter
    def default_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_format", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="storeName")
    def store_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "store_name")

    @store_name.setter
    def store_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "store_name", value)


@pulumi.input_type
class DataLakeStorageDatabaseViewArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 pipeline: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the Atlas Data Lake.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if pipeline is not None:
            pulumi.set(__self__, "pipeline", pipeline)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Atlas Data Lake.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def pipeline(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pipeline")

    @pipeline.setter
    def pipeline(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pipeline", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)


@pulumi.input_type
class DataLakeStorageStoreArgs:
    def __init__(__self__, *,
                 additional_storage_classes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 bucket: Optional[pulumi.Input[str]] = None,
                 delimiter: Optional[pulumi.Input[str]] = None,
                 include_tags: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 provider: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the Atlas Data Lake.
        """
        if additional_storage_classes is not None:
            pulumi.set(__self__, "additional_storage_classes", additional_storage_classes)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if include_tags is not None:
            pulumi.set(__self__, "include_tags", include_tags)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="additionalStorageClasses")
    def additional_storage_classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "additional_storage_classes")

    @additional_storage_classes.setter
    def additional_storage_classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "additional_storage_classes", value)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter(name="includeTags")
    def include_tags(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "include_tags")

    @include_tags.setter
    def include_tags(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_tags", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Atlas Data Lake.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class DatabaseUserLabelArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The key that you want to write.
        :param pulumi.Input[str] value: The value that you want to write.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The key that you want to write.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value that you want to write.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class DatabaseUserRoleArgs:
    def __init__(__self__, *,
                 collection_name: Optional[pulumi.Input[str]] = None,
                 database_name: Optional[pulumi.Input[str]] = None,
                 role_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] collection_name: Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        :param pulumi.Input[str] database_name: Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.
        :param pulumi.Input[str] role_name: Name of the role to grant. See [Create a Database User](https://docs.atlas.mongodb.com/reference/api/database-users-create-a-user/) `roles.roleName` for valid values and restrictions.
        """
        if collection_name is not None:
            pulumi.set(__self__, "collection_name", collection_name)
        if database_name is not None:
            pulumi.set(__self__, "database_name", database_name)
        if role_name is not None:
            pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> Optional[pulumi.Input[str]]:
        """
        Collection for which the role applies. You can specify a collection for the `read` and `readWrite` roles. If you do not specify a collection for `read` and `readWrite`, the role applies to all collections in the database (excluding some collections in the `system`. database).
        """
        return pulumi.get(self, "collection_name")

    @collection_name.setter
    def collection_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "collection_name", value)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[pulumi.Input[str]]:
        """
        Database on which the user has the specified role. A role on the `admin` database can include privileges that apply to the other databases.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the role to grant. See [Create a Database User](https://docs.atlas.mongodb.com/reference/api/database-users-create-a-user/) `roles.roleName` for valid values and restrictions.
        """
        return pulumi.get(self, "role_name")

    @role_name.setter
    def role_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_name", value)


@pulumi.input_type
class DatabaseUserScopeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the cluster or Atlas Data Lake that the user has access to.
        :param pulumi.Input[str] type: Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the cluster or Atlas Data Lake that the user has access to.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of resource that the user has access to. Valid values are: `CLUSTER` and `DATA_LAKE`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class EncryptionAtRestAwsKmsConfigArgs:
    def __init__(__self__, *,
                 access_key_id: Optional[pulumi.Input[str]] = None,
                 customer_master_key_id: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 role_id: Optional[pulumi.Input[str]] = None,
                 secret_access_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] customer_master_key_id: The AWS customer master key used to encrypt and decrypt the MongoDB master keys.
        :param pulumi.Input[bool] enabled: Specifies whether Encryption at Rest is enabled for an Atlas project. To disable Encryption at Rest, pass only this parameter with a value of false. When you disable Encryption at Rest, Atlas also removes the configuration details.
        :param pulumi.Input[str] region: The AWS region in which the AWS customer master key exists: CA_CENTRAL_1, US_EAST_1, US_EAST_2, US_WEST_1, US_WEST_2, SA_EAST_1
        :param pulumi.Input[str] role_id: ID of an AWS IAM role authorized to manage an AWS customer master key. To find the ID for an existing IAM role check the `role_id` attribute of the `CloudProviderAccess` resource.
        """
        if access_key_id is not None:
            pulumi.set(__self__, "access_key_id", access_key_id)
        if customer_master_key_id is not None:
            pulumi.set(__self__, "customer_master_key_id", customer_master_key_id)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_id is not None:
            pulumi.set(__self__, "role_id", role_id)
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)

    @property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key_id", value)

    @property
    @pulumi.getter(name="customerMasterKeyId")
    def customer_master_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The AWS customer master key used to encrypt and decrypt the MongoDB master keys.
        """
        return pulumi.get(self, "customer_master_key_id")

    @customer_master_key_id.setter
    def customer_master_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "customer_master_key_id", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether Encryption at Rest is enabled for an Atlas project. To disable Encryption at Rest, pass only this parameter with a value of false. When you disable Encryption at Rest, Atlas also removes the configuration details.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        The AWS region in which the AWS customer master key exists: CA_CENTRAL_1, US_EAST_1, US_EAST_2, US_WEST_1, US_WEST_2, SA_EAST_1
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of an AWS IAM role authorized to manage an AWS customer master key. To find the ID for an existing IAM role check the `role_id` attribute of the `CloudProviderAccess` resource.
        """
        return pulumi.get(self, "role_id")

    @role_id.setter
    def role_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_id", value)

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_access_key", value)


@pulumi.input_type
class EncryptionAtRestAzureKeyVaultConfigArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 azure_environment: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 key_identifier: Optional[pulumi.Input[str]] = None,
                 key_vault_name: Optional[pulumi.Input[str]] = None,
                 resource_group_name: Optional[pulumi.Input[str]] = None,
                 secret: Optional[pulumi.Input[str]] = None,
                 subscription_id: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Specifies whether Encryption at Rest is enabled for an Atlas project. To disable Encryption at Rest, pass only this parameter with a value of false. When you disable Encryption at Rest, Atlas also removes the configuration details.
        :param pulumi.Input[str] azure_environment: The Azure environment where the Azure account credentials reside. Valid values are the following: AZURE, AZURE_CHINA, AZURE_GERMANY
        :param pulumi.Input[str] client_id: The client ID, also known as the application ID, for an Azure application associated with the Azure AD tenant.
        :param pulumi.Input[str] key_identifier: The unique identifier of a key in an Azure Key Vault.
        :param pulumi.Input[str] key_vault_name: The name of an Azure Key Vault containing your key.
        :param pulumi.Input[str] resource_group_name: The name of the Azure Resource group that contains an Azure Key Vault.
        :param pulumi.Input[str] secret: The secret associated with the Azure Key Vault specified by azureKeyVault.tenantID.
        :param pulumi.Input[str] subscription_id: The unique identifier associated with an Azure subscription.
        :param pulumi.Input[str] tenant_id: The unique identifier for an Azure AD tenant within an Azure subscription.
        """
        pulumi.set(__self__, "enabled", enabled)
        if azure_environment is not None:
            pulumi.set(__self__, "azure_environment", azure_environment)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if key_identifier is not None:
            pulumi.set(__self__, "key_identifier", key_identifier)
        if key_vault_name is not None:
            pulumi.set(__self__, "key_vault_name", key_vault_name)
        if resource_group_name is not None:
            pulumi.set(__self__, "resource_group_name", resource_group_name)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Specifies whether Encryption at Rest is enabled for an Atlas project. To disable Encryption at Rest, pass only this parameter with a value of false. When you disable Encryption at Rest, Atlas also removes the configuration details.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="azureEnvironment")
    def azure_environment(self) -> Optional[pulumi.Input[str]]:
        """
        The Azure environment where the Azure account credentials reside. Valid values are the following: AZURE, AZURE_CHINA, AZURE_GERMANY
        """
        return pulumi.get(self, "azure_environment")

    @azure_environment.setter
    def azure_environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "azure_environment", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The client ID, also known as the application ID, for an Azure application associated with the Azure AD tenant.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="keyIdentifier")
    def key_identifier(self) -> Optional[pulumi.Input[str]]:
        """
        The unique identifier of a key in an Azure Key Vault.
        """
        return pulumi.get(self, "key_identifier")

    @key_identifier.setter
    def key_identifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_identifier", value)

    @property
    @pulumi.getter(name="keyVaultName")
    def key_vault_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of an Azure Key Vault containing your key.
        """
        return pulumi.get(self, "key_vault_name")

    @key_vault_name.setter
    def key_vault_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_vault_name", value)

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Azure Resource group that contains an Azure Key Vault.
        """
        return pulumi.get(self, "resource_group_name")

    @resource_group_name.setter
    def resource_group_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_group_name", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input[str]]:
        """
        The secret associated with the Azure Key Vault specified by azureKeyVault.tenantID.
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret", value)

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique identifier associated with an Azure subscription.
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subscription_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique identifier for an Azure AD tenant within an Azure subscription.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class EncryptionAtRestGoogleCloudKmsConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 key_version_resource_id: Optional[pulumi.Input[str]] = None,
                 service_account_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Specifies whether Encryption at Rest is enabled for an Atlas project. To disable Encryption at Rest, pass only this parameter with a value of false. When you disable Encryption at Rest, Atlas also removes the configuration details.
        :param pulumi.Input[str] key_version_resource_id: The Key Version Resource ID from your GCP account.
        :param pulumi.Input[str] service_account_key: String-formatted JSON object containing GCP KMS credentials from your GCP account.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if key_version_resource_id is not None:
            pulumi.set(__self__, "key_version_resource_id", key_version_resource_id)
        if service_account_key is not None:
            pulumi.set(__self__, "service_account_key", service_account_key)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether Encryption at Rest is enabled for an Atlas project. To disable Encryption at Rest, pass only this parameter with a value of false. When you disable Encryption at Rest, Atlas also removes the configuration details.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="keyVersionResourceId")
    def key_version_resource_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Key Version Resource ID from your GCP account.
        """
        return pulumi.get(self, "key_version_resource_id")

    @key_version_resource_id.setter
    def key_version_resource_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_version_resource_id", value)

    @property
    @pulumi.getter(name="serviceAccountKey")
    def service_account_key(self) -> Optional[pulumi.Input[str]]:
        """
        String-formatted JSON object containing GCP KMS credentials from your GCP account.
        """
        return pulumi.get(self, "service_account_key")

    @service_account_key.setter
    def service_account_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_key", value)


@pulumi.input_type
class EventTriggerEventProcessorsArgs:
    def __init__(__self__, *,
                 aws_eventbridge: Optional[pulumi.Input['EventTriggerEventProcessorsAwsEventbridgeArgs']] = None):
        if aws_eventbridge is not None:
            pulumi.set(__self__, "aws_eventbridge", aws_eventbridge)

    @property
    @pulumi.getter(name="awsEventbridge")
    def aws_eventbridge(self) -> Optional[pulumi.Input['EventTriggerEventProcessorsAwsEventbridgeArgs']]:
        return pulumi.get(self, "aws_eventbridge")

    @aws_eventbridge.setter
    def aws_eventbridge(self, value: Optional[pulumi.Input['EventTriggerEventProcessorsAwsEventbridgeArgs']]):
        pulumi.set(self, "aws_eventbridge", value)


@pulumi.input_type
class EventTriggerEventProcessorsAwsEventbridgeArgs:
    def __init__(__self__, *,
                 config_account_id: Optional[pulumi.Input[str]] = None,
                 config_region: Optional[pulumi.Input[str]] = None):
        if config_account_id is not None:
            pulumi.set(__self__, "config_account_id", config_account_id)
        if config_region is not None:
            pulumi.set(__self__, "config_region", config_region)

    @property
    @pulumi.getter(name="configAccountId")
    def config_account_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "config_account_id")

    @config_account_id.setter
    def config_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_account_id", value)

    @property
    @pulumi.getter(name="configRegion")
    def config_region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "config_region")

    @config_region.setter
    def config_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_region", value)


@pulumi.input_type
class FederatedSettingsOrgRoleMappingRoleAssignmentArgs:
    def __init__(__self__, *,
                 group_id: Optional[pulumi.Input[str]] = None,
                 org_id: Optional[pulumi.Input[str]] = None,
                 roles: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] group_id: Unique identifier of the project to which you want the role mapping to apply.
        :param pulumi.Input[str] org_id: Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] roles: Specifies the Roles that are attached to the Role Mapping.
        """
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier of the project to which you want the role mapping to apply.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique 24-hexadecimal digit string that identifies the organization that contains your projects.
        """
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "org_id", value)

    @property
    @pulumi.getter
    def roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies the Roles that are attached to the Role Mapping.
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "roles", value)


@pulumi.input_type
class GlobalClusterConfigCustomZoneMappingArgs:
    def __init__(__self__, *,
                 location: Optional[pulumi.Input[str]] = None,
                 zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] location: The ISO location code to which you want to map a zone in your Global Cluster. You can find a list of all supported location codes [here](https://cloud.mongodb.com/static/atlas/country_iso_codes.txt).
        :param pulumi.Input[str] zone: The name of the zone in your Global Cluster that you want to map to location.
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        The ISO location code to which you want to map a zone in your Global Cluster. You can find a list of all supported location codes [here](https://cloud.mongodb.com/static/atlas/country_iso_codes.txt).
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the zone in your Global Cluster that you want to map to location.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone", value)


@pulumi.input_type
class GlobalClusterConfigManagedNamespaceArgs:
    def __init__(__self__, *,
                 collection: pulumi.Input[str],
                 custom_shard_key: pulumi.Input[str],
                 db: pulumi.Input[str],
                 is_custom_shard_key_hashed: Optional[pulumi.Input[bool]] = None,
                 is_shard_key_unique: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] collection: The name of the collection associated with the managed namespace.
        :param pulumi.Input[str] custom_shard_key: The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        :param pulumi.Input[str] db: The name of the database containing the collection.
        :param pulumi.Input[bool] is_custom_shard_key_hashed: Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.
        :param pulumi.Input[bool] is_shard_key_unique: Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).
        """
        pulumi.set(__self__, "collection", collection)
        pulumi.set(__self__, "custom_shard_key", custom_shard_key)
        pulumi.set(__self__, "db", db)
        if is_custom_shard_key_hashed is not None:
            pulumi.set(__self__, "is_custom_shard_key_hashed", is_custom_shard_key_hashed)
        if is_shard_key_unique is not None:
            pulumi.set(__self__, "is_shard_key_unique", is_shard_key_unique)

    @property
    @pulumi.getter
    def collection(self) -> pulumi.Input[str]:
        """
        The name of the collection associated with the managed namespace.
        """
        return pulumi.get(self, "collection")

    @collection.setter
    def collection(self, value: pulumi.Input[str]):
        pulumi.set(self, "collection", value)

    @property
    @pulumi.getter(name="customShardKey")
    def custom_shard_key(self) -> pulumi.Input[str]:
        """
        The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        """
        return pulumi.get(self, "custom_shard_key")

    @custom_shard_key.setter
    def custom_shard_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "custom_shard_key", value)

    @property
    @pulumi.getter
    def db(self) -> pulumi.Input[str]:
        """
        The name of the database containing the collection.
        """
        return pulumi.get(self, "db")

    @db.setter
    def db(self, value: pulumi.Input[str]):
        pulumi.set(self, "db", value)

    @property
    @pulumi.getter(name="isCustomShardKeyHashed")
    def is_custom_shard_key_hashed(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.
        """
        return pulumi.get(self, "is_custom_shard_key_hashed")

    @is_custom_shard_key_hashed.setter
    def is_custom_shard_key_hashed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom_shard_key_hashed", value)

    @property
    @pulumi.getter(name="isShardKeyUnique")
    def is_shard_key_unique(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).
        """
        return pulumi.get(self, "is_shard_key_unique")

    @is_shard_key_unique.setter
    def is_shard_key_unique(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_shard_key_unique", value)


@pulumi.input_type
class LdapConfigurationUserToDnMappingArgs:
    def __init__(__self__, *,
                 ldap_query: Optional[pulumi.Input[str]] = None,
                 match: Optional[pulumi.Input[str]] = None,
                 substitution: Optional[pulumi.Input[str]] = None):
        if ldap_query is not None:
            pulumi.set(__self__, "ldap_query", ldap_query)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if substitution is not None:
            pulumi.set(__self__, "substitution", substitution)

    @property
    @pulumi.getter(name="ldapQuery")
    def ldap_query(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ldap_query")

    @ldap_query.setter
    def ldap_query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ldap_query", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def substitution(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "substitution")

    @substitution.setter
    def substitution(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "substitution", value)


@pulumi.input_type
class LdapVerifyLinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


@pulumi.input_type
class LdapVerifyValidationArgs:
    def __init__(__self__, *,
                 status: Optional[pulumi.Input[str]] = None,
                 validation_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] status: The current status of the LDAP over TLS/SSL configuration. One of the following values: `PENDING`, `SUCCESS`, and `FAILED`.
        """
        if status is not None:
            pulumi.set(__self__, "status", status)
        if validation_type is not None:
            pulumi.set(__self__, "validation_type", validation_type)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        The current status of the LDAP over TLS/SSL configuration. One of the following values: `PENDING`, `SUCCESS`, and `FAILED`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="validationType")
    def validation_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "validation_type")

    @validation_type.setter
    def validation_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "validation_type", value)


@pulumi.input_type
class OnlineArchiveCriteriaArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 date_field: Optional[pulumi.Input[str]] = None,
                 date_format: Optional[pulumi.Input[str]] = None,
                 expire_after_days: Optional[pulumi.Input[int]] = None,
                 query: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "type", type)
        if date_field is not None:
            pulumi.set(__self__, "date_field", date_field)
        if date_format is not None:
            pulumi.set(__self__, "date_format", date_format)
        if expire_after_days is not None:
            pulumi.set(__self__, "expire_after_days", expire_after_days)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dateField")
    def date_field(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "date_field")

    @date_field.setter
    def date_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_field", value)

    @property
    @pulumi.getter(name="dateFormat")
    def date_format(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "date_format")

    @date_format.setter
    def date_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date_format", value)

    @property
    @pulumi.getter(name="expireAfterDays")
    def expire_after_days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "expire_after_days")

    @expire_after_days.setter
    def expire_after_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "expire_after_days", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class OnlineArchivePartitionFieldArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[str],
                 order: pulumi.Input[int],
                 field_type: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "order", order)
        if field_type is not None:
            pulumi.set(__self__, "field_type", field_type)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "field_name", value)

    @property
    @pulumi.getter
    def order(self) -> pulumi.Input[int]:
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: pulumi.Input[int]):
        pulumi.set(self, "order", value)

    @property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "field_type")

    @field_type.setter
    def field_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_type", value)


@pulumi.input_type
class PrivateLinkEndpointServiceEndpointArgs:
    def __init__(__self__, *,
                 endpoint_name: Optional[pulumi.Input[str]] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 service_attachment_name: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] endpoint_name: Forwarding rule that corresponds to the endpoint you created in GCP.
        :param pulumi.Input[str] ip_address: Private IP address of the endpoint you created in GCP.
        :param pulumi.Input[str] service_attachment_name: Unique alphanumeric and special character strings that identify the service attachment associated with the endpoint.
        :param pulumi.Input[str] status: Status of the endpoint. Atlas returns one of the [values shown above](https://docs.atlas.mongodb.com/reference/api/private-endpoints-endpoint-create-one/#std-label-ref-status-field).
        """
        if endpoint_name is not None:
            pulumi.set(__self__, "endpoint_name", endpoint_name)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if service_attachment_name is not None:
            pulumi.set(__self__, "service_attachment_name", service_attachment_name)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="endpointName")
    def endpoint_name(self) -> Optional[pulumi.Input[str]]:
        """
        Forwarding rule that corresponds to the endpoint you created in GCP.
        """
        return pulumi.get(self, "endpoint_name")

    @endpoint_name.setter
    def endpoint_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_name", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        Private IP address of the endpoint you created in GCP.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="serviceAttachmentName")
    def service_attachment_name(self) -> Optional[pulumi.Input[str]]:
        """
        Unique alphanumeric and special character strings that identify the service attachment associated with the endpoint.
        """
        return pulumi.get(self, "service_attachment_name")

    @service_attachment_name.setter
    def service_attachment_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_attachment_name", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Status of the endpoint. Atlas returns one of the [values shown above](https://docs.atlas.mongodb.com/reference/api/private-endpoints-endpoint-create-one/#std-label-ref-status-field).
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


@pulumi.input_type
class ProjectApiKeyArgs:
    def __init__(__self__, *,
                 api_key_id: pulumi.Input[str],
                 role_names: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] api_key_id: The unique identifier of the Programmatic API key you want to associate with the Project.  The Programmatic API key and Project must share the same parent organization.  Note: this is not the `publicKey` of the Programmatic API key but the `id` of the key. See [Programmatic API Keys](https://docs.atlas.mongodb.com/reference/api/apiKeys/) for more.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] role_names: List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project.  You must specify an array even if you are only associating a single role with the Programmatic API key.
               The following are valid roles:
               * `GROUP_OWNER`
               * `GROUP_READ_ONLY`
               * `GROUP_DATA_ACCESS_ADMIN`
               * `GROUP_DATA_ACCESS_READ_WRITE`
               * `GROUP_DATA_ACCESS_READ_ONLY`
        """
        pulumi.set(__self__, "api_key_id", api_key_id)
        pulumi.set(__self__, "role_names", role_names)

    @property
    @pulumi.getter(name="apiKeyId")
    def api_key_id(self) -> pulumi.Input[str]:
        """
        The unique identifier of the Programmatic API key you want to associate with the Project.  The Programmatic API key and Project must share the same parent organization.  Note: this is not the `publicKey` of the Programmatic API key but the `id` of the key. See [Programmatic API Keys](https://docs.atlas.mongodb.com/reference/api/apiKeys/) for more.
        """
        return pulumi.get(self, "api_key_id")

    @api_key_id.setter
    def api_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key_id", value)

    @property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project.  You must specify an array even if you are only associating a single role with the Programmatic API key.
        The following are valid roles:
        * `GROUP_OWNER`
        * `GROUP_READ_ONLY`
        * `GROUP_DATA_ACCESS_ADMIN`
        * `GROUP_DATA_ACCESS_READ_WRITE`
        * `GROUP_DATA_ACCESS_READ_ONLY`
        """
        return pulumi.get(self, "role_names")

    @role_names.setter
    def role_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "role_names", value)


@pulumi.input_type
class ProjectTeamArgs:
    def __init__(__self__, *,
                 role_names: pulumi.Input[Sequence[pulumi.Input[str]]],
                 team_id: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] role_names: List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project.  You must specify an array even if you are only associating a single role with the Programmatic API key.
               The following are valid roles:
               * `GROUP_OWNER`
               * `GROUP_READ_ONLY`
               * `GROUP_DATA_ACCESS_ADMIN`
               * `GROUP_DATA_ACCESS_READ_WRITE`
               * `GROUP_DATA_ACCESS_READ_ONLY`
        :param pulumi.Input[str] team_id: The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
        """
        pulumi.set(__self__, "role_names", role_names)
        pulumi.set(__self__, "team_id", team_id)

    @property
    @pulumi.getter(name="roleNames")
    def role_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of Project roles that the Programmatic API key needs to have. Ensure you provide: at least one role and ensure all roles are valid for the Project.  You must specify an array even if you are only associating a single role with the Programmatic API key.
        The following are valid roles:
        * `GROUP_OWNER`
        * `GROUP_READ_ONLY`
        * `GROUP_DATA_ACCESS_ADMIN`
        * `GROUP_DATA_ACCESS_READ_WRITE`
        * `GROUP_DATA_ACCESS_READ_ONLY`
        """
        return pulumi.get(self, "role_names")

    @role_names.setter
    def role_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "role_names", value)

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> pulumi.Input[str]:
        """
        The unique identifier of the team you want to associate with the project. The team and project must share the same parent organization.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "team_id", value)


@pulumi.input_type
class SearchIndexSynonymArgs:
    def __init__(__self__, *,
                 analyzer: pulumi.Input[str],
                 name: pulumi.Input[str],
                 source_collection: pulumi.Input[str]):
        """
        :param pulumi.Input[str] analyzer: Name of the [analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use with this synonym mapping. Atlas Search doesn't support these [custom analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-custom-analyzers) tokenizers and token filters in [analyzers used in synonym mappings](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#options):
               * [nGram](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-ngram-tokenizer-ref) Tokenizer
               * [edgeGram](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-edgegram-tokenizer-ref) Tokenizers
               * [daitchMokotoffSoundex](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-daitchmokotoffsoundex-tf-ref) token filter
               * [nGram](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-ngram-tf-ref) token filter
               * [edgeGram](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-edgegram-tf-ref) token filter
               * [shingle](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-shingle-tf-ref) token filter
        :param pulumi.Input[str] name: Name of the [synonym mapping definition](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-ref). Name must be unique in this index definition and it can't be an empty string.
        :param pulumi.Input[str] source_collection: Name of the source MongoDB collection for the synonyms. Documents in this collection must be in the format described in the [Synonyms Source Collection Documents](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-coll-spec).
        """
        pulumi.set(__self__, "analyzer", analyzer)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source_collection", source_collection)

    @property
    @pulumi.getter
    def analyzer(self) -> pulumi.Input[str]:
        """
        Name of the [analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/#std-label-analyzers-ref) to use with this synonym mapping. Atlas Search doesn't support these [custom analyzer](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-custom-analyzers) tokenizers and token filters in [analyzers used in synonym mappings](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#options):
        * [nGram](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-ngram-tokenizer-ref) Tokenizer
        * [edgeGram](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-edgegram-tokenizer-ref) Tokenizers
        * [daitchMokotoffSoundex](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-daitchmokotoffsoundex-tf-ref) token filter
        * [nGram](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-ngram-tf-ref) token filter
        * [edgeGram](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-edgegram-tf-ref) token filter
        * [shingle](https://docs.atlas.mongodb.com/reference/atlas-search/analyzers/custom/#std-label-shingle-tf-ref) token filter
        """
        return pulumi.get(self, "analyzer")

    @analyzer.setter
    def analyzer(self, value: pulumi.Input[str]):
        pulumi.set(self, "analyzer", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the [synonym mapping definition](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-ref). Name must be unique in this index definition and it can't be an empty string.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sourceCollection")
    def source_collection(self) -> pulumi.Input[str]:
        """
        Name of the source MongoDB collection for the synonyms. Documents in this collection must be in the format described in the [Synonyms Source Collection Documents](https://docs.atlas.mongodb.com/reference/atlas-search/synonyms/#std-label-synonyms-coll-spec).
        """
        return pulumi.get(self, "source_collection")

    @source_collection.setter
    def source_collection(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_collection", value)


@pulumi.input_type
class ServerlessInstanceLinkArgs:
    def __init__(__self__, *,
                 href: Optional[pulumi.Input[str]] = None,
                 rel: Optional[pulumi.Input[str]] = None):
        if href is not None:
            pulumi.set(__self__, "href", href)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rel", value)


@pulumi.input_type
class X509AuthenticationDatabaseUserCertificateArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[str]] = None,
                 group_id: Optional[pulumi.Input[str]] = None,
                 not_after: Optional[pulumi.Input[str]] = None,
                 subject: Optional[pulumi.Input[str]] = None):
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if not_after is not None:
            pulumi.set(__self__, "not_after", not_after)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_id", value)

    @property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "not_after")

    @not_after.setter
    def not_after(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "not_after", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject", value)


@pulumi.input_type
class GetCustomDbRoleInheritedRoleArgs:
    def __init__(__self__, *,
                 database_name: str,
                 role_name: str):
        """
        :param str role_name: Name of the custom role.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: str):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        """
        Name of the custom role.
        """
        return pulumi.get(self, "role_name")

    @role_name.setter
    def role_name(self, value: str):
        pulumi.set(self, "role_name", value)


@pulumi.input_type
class GetGlobalClusterConfigManagedNamespaceArgs:
    def __init__(__self__, *,
                 collection: str,
                 custom_shard_key: str,
                 db: str,
                 is_custom_shard_key_hashed: bool,
                 is_shard_key_unique: bool):
        """
        :param str collection: (Required) The name of the collection associated with the managed namespace.
        :param str custom_shard_key: (Required)	The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        :param str db: (Required) The name of the database containing the collection.
        :param bool is_custom_shard_key_hashed: Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.
        :param bool is_shard_key_unique: Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).
        """
        pulumi.set(__self__, "collection", collection)
        pulumi.set(__self__, "custom_shard_key", custom_shard_key)
        pulumi.set(__self__, "db", db)
        pulumi.set(__self__, "is_custom_shard_key_hashed", is_custom_shard_key_hashed)
        pulumi.set(__self__, "is_shard_key_unique", is_shard_key_unique)

    @property
    @pulumi.getter
    def collection(self) -> str:
        """
        (Required) The name of the collection associated with the managed namespace.
        """
        return pulumi.get(self, "collection")

    @collection.setter
    def collection(self, value: str):
        pulumi.set(self, "collection", value)

    @property
    @pulumi.getter(name="customShardKey")
    def custom_shard_key(self) -> str:
        """
        (Required)	The custom shard key for the collection. Global Clusters require a compound shard key consisting of a location field and a user-selected second key, the custom shard key.
        """
        return pulumi.get(self, "custom_shard_key")

    @custom_shard_key.setter
    def custom_shard_key(self, value: str):
        pulumi.set(self, "custom_shard_key", value)

    @property
    @pulumi.getter
    def db(self) -> str:
        """
        (Required) The name of the database containing the collection.
        """
        return pulumi.get(self, "db")

    @db.setter
    def db(self, value: str):
        pulumi.set(self, "db", value)

    @property
    @pulumi.getter(name="isCustomShardKeyHashed")
    def is_custom_shard_key_hashed(self) -> bool:
        """
        Specifies whether the custom shard key for the collection is [hashed](https://docs.mongodb.com/manual/reference/method/sh.shardCollection/#hashed-shard-keys). If omitted, defaults to `false`. If `false`, Atlas uses [ranged sharding](https://docs.mongodb.com/manual/core/ranged-sharding/). This is only available for Atlas clusters with MongoDB v4.4 and later.
        """
        return pulumi.get(self, "is_custom_shard_key_hashed")

    @is_custom_shard_key_hashed.setter
    def is_custom_shard_key_hashed(self, value: bool):
        pulumi.set(self, "is_custom_shard_key_hashed", value)

    @property
    @pulumi.getter(name="isShardKeyUnique")
    def is_shard_key_unique(self) -> bool:
        """
        Specifies whether the underlying index enforces a unique constraint. If omitted, defaults to false. You cannot specify true when using [hashed shard keys](https://docs.mongodb.com/manual/core/hashed-sharding/#std-label-sharding-hashed).
        """
        return pulumi.get(self, "is_shard_key_unique")

    @is_shard_key_unique.setter
    def is_shard_key_unique(self, value: bool):
        pulumi.set(self, "is_shard_key_unique", value)


@pulumi.input_type
class GetServerlessInstanceLinkArgs:
    def __init__(__self__, *,
                 href: str,
                 rel: str):
        pulumi.set(__self__, "href", href)
        pulumi.set(__self__, "rel", rel)

    @property
    @pulumi.getter
    def href(self) -> str:
        return pulumi.get(self, "href")

    @href.setter
    def href(self, value: str):
        pulumi.set(self, "href", value)

    @property
    @pulumi.getter
    def rel(self) -> str:
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: str):
        pulumi.set(self, "rel", value)


